"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_codemirror_autocomplete_dist_index_js-node_modules_codemirror_commands_d-9bbb67"],{

/***/ "./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompletionContext\": () => (/* binding */ CompletionContext),\n/* harmony export */   \"acceptCompletion\": () => (/* binding */ acceptCompletion),\n/* harmony export */   \"autocompletion\": () => (/* binding */ autocompletion),\n/* harmony export */   \"clearSnippet\": () => (/* binding */ clearSnippet),\n/* harmony export */   \"closeBrackets\": () => (/* binding */ closeBrackets),\n/* harmony export */   \"closeBracketsKeymap\": () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   \"closeCompletion\": () => (/* binding */ closeCompletion),\n/* harmony export */   \"completeAnyWord\": () => (/* binding */ completeAnyWord),\n/* harmony export */   \"completeFromList\": () => (/* binding */ completeFromList),\n/* harmony export */   \"completionKeymap\": () => (/* binding */ completionKeymap),\n/* harmony export */   \"completionStatus\": () => (/* binding */ completionStatus),\n/* harmony export */   \"currentCompletions\": () => (/* binding */ currentCompletions),\n/* harmony export */   \"deleteBracketPair\": () => (/* binding */ deleteBracketPair),\n/* harmony export */   \"ifIn\": () => (/* binding */ ifIn),\n/* harmony export */   \"ifNotIn\": () => (/* binding */ ifNotIn),\n/* harmony export */   \"insertBracket\": () => (/* binding */ insertBracket),\n/* harmony export */   \"insertCompletionText\": () => (/* binding */ insertCompletionText),\n/* harmony export */   \"moveCompletionSelection\": () => (/* binding */ moveCompletionSelection),\n/* harmony export */   \"nextSnippetField\": () => (/* binding */ nextSnippetField),\n/* harmony export */   \"pickedCompletion\": () => (/* binding */ pickedCompletion),\n/* harmony export */   \"prevSnippetField\": () => (/* binding */ prevSnippetField),\n/* harmony export */   \"selectedCompletion\": () => (/* binding */ selectedCompletion),\n/* harmony export */   \"selectedCompletionIndex\": () => (/* binding */ selectedCompletionIndex),\n/* harmony export */   \"setSelectedCompletion\": () => (/* binding */ setSelectedCompletion),\n/* harmony export */   \"snippet\": () => (/* binding */ snippet),\n/* harmony export */   \"snippetCompletion\": () => (/* binding */ snippetCompletion),\n/* harmony export */   \"snippetKeymap\": () => (/* binding */ snippetKeymap),\n/* harmony export */   \"startCompletion\": () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/\nclass CompletionContext {\n  /**\n  Create a new completion context. (Mostly useful for testing\n  completion sources—in the editor, the extension will create\n  these for you.)\n  */\n  constructor(\n  /**\n  The editor state that the completion happens in.\n  */\n  state,\n  /**\n  The position at which the completion is happening.\n  */\n  pos,\n  /**\n  Indicates whether completion was activated explicitly, or\n  implicitly by typing. The usual way to respond to this is to\n  only return completions when either there is part of a\n  completable entity before the cursor, or `explicit` is true.\n  */\n  explicit) {\n    this.state = state;\n    this.pos = pos;\n    this.explicit = explicit;\n    /**\n    @internal\n    */\n    this.abortListeners = [];\n  }\n  /**\n  Get the extent, content, and (if there is a token) type of the\n  token before `this.pos`.\n  */\n  tokenBefore(types) {\n    let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n    while (token && types.indexOf(token.name) < 0) token = token.parent;\n    return token ? {\n      from: token.from,\n      to: this.pos,\n      text: this.state.sliceDoc(token.from, this.pos),\n      type: token.type\n    } : null;\n  }\n  /**\n  Get the match of the given expression directly before the\n  cursor.\n  */\n  matchBefore(expr) {\n    let line = this.state.doc.lineAt(this.pos);\n    let start = Math.max(line.from, this.pos - 250);\n    let str = line.text.slice(start - line.from, this.pos - line.from);\n    let found = str.search(ensureAnchor(expr, false));\n    return found < 0 ? null : {\n      from: start + found,\n      to: this.pos,\n      text: str.slice(found)\n    };\n  }\n  /**\n  Yields true when the query has been aborted. Can be useful in\n  asynchronous queries to avoid doing work that will be ignored.\n  */\n  get aborted() {\n    return this.abortListeners == null;\n  }\n  /**\n  Allows you to register abort handlers, which will be called when\n  the query is\n  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n  */\n  addEventListener(type, listener) {\n    if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n  }\n}\nfunction toSet(chars) {\n  let flat = Object.keys(chars).join(\"\");\n  let words = /\\w/.test(flat);\n  if (words) flat = flat.replace(/\\w/g, \"\");\n  return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n  let first = Object.create(null),\n    rest = Object.create(null);\n  for (let {\n    label\n  } of options) {\n    first[label[0]] = true;\n    for (let i = 1; i < label.length; i++) rest[label[i]] = true;\n  }\n  let source = toSet(first) + toSet(rest) + \"*$\";\n  return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/\nfunction completeFromList(list) {\n  let options = list.map(o => typeof o == \"string\" ? {\n    label: o\n  } : o);\n  let [validFor, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n  return context => {\n    let token = context.matchBefore(match);\n    return token || context.explicit ? {\n      from: token ? token.from : context.pos,\n      options,\n      validFor\n    } : null;\n  };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifIn(nodes, source) {\n  return context => {\n    for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) if (nodes.indexOf(pos.name) > -1) return source(context);\n    return null;\n  };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/\nfunction ifNotIn(nodes, source) {\n  return context => {\n    for (let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) if (nodes.indexOf(pos.name) > -1) return null;\n    return source(context);\n  };\n}\nclass Option {\n  constructor(completion, source, match) {\n    this.completion = completion;\n    this.source = source;\n    this.match = match;\n  }\n}\nfunction cur(state) {\n  return state.selection.main.head;\n}\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n  var _a;\n  let {\n    source\n  } = expr;\n  let addStart = start && source[0] != \"^\",\n    addEnd = source[source.length - 1] != \"$\";\n  if (!addStart && !addEnd) return expr;\n  return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/\nconst pickedCompletion = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/\nfunction insertCompletionText(state, text, from, to) {\n  return Object.assign(Object.assign({}, state.changeByRange(range => {\n    if (range == state.selection.main) return {\n      changes: {\n        from: from,\n        to: to,\n        insert: text\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + text.length)\n    };\n    let len = to - from;\n    if (!range.empty || len && state.sliceDoc(range.from - len, range.from) != state.sliceDoc(from, to)) return {\n      range\n    };\n    return {\n      changes: {\n        from: range.from - len,\n        to: range.from,\n        insert: text\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from - len + text.length)\n    };\n  })), {\n    userEvent: \"input.complete\"\n  });\n}\nfunction applyCompletion(view, option) {\n  const apply = option.completion.apply || option.completion.label;\n  let result = option.source;\n  if (typeof apply == \"string\") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {\n    annotations: pickedCompletion.of(option.completion)\n  }));else apply(view, option.completion, result.from, result.to);\n}\nconst SourceCache = /*@__PURE__*/new WeakMap();\nfunction asSource(source) {\n  if (!Array.isArray(source)) return source;\n  let known = SourceCache.get(source);\n  if (!known) SourceCache.set(source, known = completeFromList(source));\n  return known;\n}\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n  constructor(pattern) {\n    this.pattern = pattern;\n    this.chars = [];\n    this.folded = [];\n    // Buffers reused by calls to `match` to track matched character\n    // positions.\n    this.any = [];\n    this.precise = [];\n    this.byWord = [];\n    for (let p = 0; p < pattern.length;) {\n      let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p),\n        size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n      this.chars.push(char);\n      let part = pattern.slice(p, p + size),\n        upper = part.toUpperCase();\n      this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n      p += size;\n    }\n    this.astral = pattern.length != this.chars.length;\n  }\n  // Matches a given word (completion) against the pattern (input).\n  // Will return null for no match, and otherwise an array that starts\n  // with the match score, followed by any number of `from, to` pairs\n  // indicating the matched parts of `word`.\n  //\n  // The score is a number that is more negative the worse the match\n  // is. See `Penalty` above.\n  match(word) {\n    if (this.pattern.length == 0) return [0];\n    if (word.length < this.pattern.length) return null;\n    let {\n      chars,\n      folded,\n      any,\n      precise,\n      byWord\n    } = this;\n    // For single-character queries, only match when they occur right\n    // at the start\n    if (chars.length == 1) {\n      let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0);\n      return first == chars[0] ? [0, 0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first)] : first == folded[0] ? [-200 /* Penalty.CaseFold */, 0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first)] : null;\n    }\n    let direct = word.indexOf(this.pattern);\n    if (direct == 0) return [0, 0, this.pattern.length];\n    let len = chars.length,\n      anyTo = 0;\n    if (direct < 0) {\n      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n        if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n        i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n      }\n      // No match, exit immediately\n      if (anyTo < len) return null;\n    }\n    // This tracks the extent of the precise (non-folded, not\n    // necessarily adjacent) match\n    let preciseTo = 0;\n    // Tracks whether there is a match that hits only characters that\n    // appear to be starting words. `byWordFolded` is set to true when\n    // a case folded character is encountered in such a match\n    let byWordTo = 0,\n      byWordFolded = false;\n    // If we've found a partial adjacent match, these track its state\n    let adjacentTo = 0,\n      adjacentStart = -1,\n      adjacentEnd = -1;\n    let hasLower = /[a-z]/.test(word),\n      wordAdjacent = true;\n    // Go over the option's text, scanning for the various kinds of matches\n    for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */; i < e && byWordTo < len;) {\n      let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n      if (direct < 0) {\n        if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n        if (adjacentTo < len) {\n          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n            if (adjacentTo == 0) adjacentStart = i;\n            adjacentEnd = i + 1;\n            adjacentTo++;\n          } else {\n            adjacentTo = 0;\n          }\n        }\n      }\n      let ch,\n        type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */ : next >= 65 && next <= 90 ? 1 /* Tp.Upper */ : 0 /* Tp.NonWord */ : (ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */ : ch != ch.toUpperCase() ? 2 /* Tp.Lower */ : 0 /* Tp.NonWord */;\n      if (!i || type == 1 /* Tp.Upper */ && hasLower || prevType == 0 /* Tp.NonWord */ && type != 0 /* Tp.NonWord */) {\n        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;else if (byWord.length) wordAdjacent = false;\n      }\n      prevType = type;\n      i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n    }\n    if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0), byWord, word);\n    if (adjacentTo == len && adjacentStart == 0) return [-200 /* Penalty.CaseFold */ - word.length, 0, adjacentEnd];\n    if (direct > -1) return [-700 /* Penalty.NotStart */ - word.length, direct, direct + this.pattern.length];\n    if (adjacentTo == len) return [-200 /* Penalty.CaseFold */ + -700 /* Penalty.NotStart */ - word.length, adjacentStart, adjacentEnd];\n    if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) + -700 /* Penalty.NotStart */ + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */), byWord, word);\n    return chars.length == 2 ? null : this.result((any[0] ? -700 /* Penalty.NotStart */ : 0) + -200 /* Penalty.CaseFold */ + -1100 /* Penalty.Gap */, any, word);\n  }\n  result(score, positions, word) {\n    let result = [score - word.length],\n      i = 1;\n    for (let pos of positions) {\n      let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n      if (i > 1 && result[i - 1] == pos) result[i - 1] = to;else {\n        result[i++] = pos;\n        result[i++] = to;\n      }\n    }\n    return result;\n  }\n}\nconst completionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n      activateOnTyping: true,\n      selectOnOpen: true,\n      override: null,\n      closeOnBlur: true,\n      maxRenderedOptions: 100,\n      defaultKeymap: true,\n      tooltipClass: () => \"\",\n      optionClass: () => \"\",\n      aboveCursor: false,\n      icons: true,\n      addToOptions: [],\n      compareCompletions: (a, b) => a.label.localeCompare(b.label),\n      interactionDelay: 75\n    }, {\n      defaultKeymap: (a, b) => a && b,\n      closeOnBlur: (a, b) => a && b,\n      icons: (a, b) => a && b,\n      tooltipClass: (a, b) => c => joinClass(a(c), b(c)),\n      optionClass: (a, b) => c => joinClass(a(c), b(c)),\n      addToOptions: (a, b) => a.concat(b)\n    });\n  }\n});\nfunction joinClass(a, b) {\n  return a ? b ? a + \" \" + b : a : b;\n}\nfunction optionContent(config) {\n  let content = config.addToOptions.slice();\n  if (config.icons) content.push({\n    render(completion) {\n      let icon = document.createElement(\"div\");\n      icon.classList.add(\"cm-completionIcon\");\n      if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map(cls => \"cm-completionIcon-\" + cls));\n      icon.setAttribute(\"aria-hidden\", \"true\");\n      return icon;\n    },\n    position: 20\n  });\n  content.push({\n    render(completion, _s, match) {\n      let labelElt = document.createElement(\"span\");\n      labelElt.className = \"cm-completionLabel\";\n      let {\n          label\n        } = completion,\n        off = 0;\n      for (let j = 1; j < match.length;) {\n        let from = match[j++],\n          to = match[j++];\n        if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n        let span = labelElt.appendChild(document.createElement(\"span\"));\n        span.appendChild(document.createTextNode(label.slice(from, to)));\n        span.className = \"cm-completionMatchedText\";\n        off = to;\n      }\n      if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n      return labelElt;\n    },\n    position: 50\n  }, {\n    render(completion) {\n      if (!completion.detail) return null;\n      let detailElt = document.createElement(\"span\");\n      detailElt.className = \"cm-completionDetail\";\n      detailElt.textContent = completion.detail;\n      return detailElt;\n    },\n    position: 80\n  });\n  return content.sort((a, b) => a.position - b.position).map(a => a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n  if (total <= max) return {\n    from: 0,\n    to: total\n  };\n  if (selected < 0) selected = 0;\n  if (selected <= total >> 1) {\n    let off = Math.floor(selected / max);\n    return {\n      from: off * max,\n      to: (off + 1) * max\n    };\n  }\n  let off = Math.floor((total - selected) / max);\n  return {\n    from: total - (off + 1) * max,\n    to: total - off * max\n  };\n}\nclass CompletionTooltip {\n  constructor(view, stateField) {\n    this.view = view;\n    this.stateField = stateField;\n    this.info = null;\n    this.placeInfo = {\n      read: () => this.measureInfo(),\n      write: pos => this.positionInfo(pos),\n      key: this\n    };\n    this.space = null;\n    this.currentClass = \"\";\n    let cState = view.state.field(stateField);\n    let {\n      options,\n      selected\n    } = cState.open;\n    let config = view.state.facet(completionConfig);\n    this.optionContent = optionContent(config);\n    this.optionClass = config.optionClass;\n    this.tooltipClass = config.tooltipClass;\n    this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-tooltip-autocomplete\";\n    this.updateTooltipClass(view.state);\n    this.dom.addEventListener(\"mousedown\", e => {\n      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n        if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n          applyCompletion(view, options[+match[1]]);\n          e.preventDefault();\n          return;\n        }\n      }\n    });\n    this.list = this.dom.appendChild(this.createListBox(options, cState.id, this.range));\n    this.list.addEventListener(\"scroll\", () => {\n      if (this.info) this.view.requestMeasure(this.placeInfo);\n    });\n  }\n  mount() {\n    this.updateSel();\n  }\n  update(update) {\n    var _a, _b, _c;\n    let cState = update.state.field(this.stateField);\n    let prevState = update.startState.field(this.stateField);\n    this.updateTooltipClass(update.state);\n    if (cState != prevState) {\n      this.updateSel();\n      if (((_a = cState.open) === null || _a === void 0 ? void 0 : _a.disabled) != ((_b = prevState.open) === null || _b === void 0 ? void 0 : _b.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!((_c = cState.open) === null || _c === void 0 ? void 0 : _c.disabled));\n    }\n  }\n  updateTooltipClass(state) {\n    let cls = this.tooltipClass(state);\n    if (cls != this.currentClass) {\n      for (let c of this.currentClass.split(\" \")) if (c) this.dom.classList.remove(c);\n      for (let c of cls.split(\" \")) if (c) this.dom.classList.add(c);\n      this.currentClass = cls;\n    }\n  }\n  positioned(space) {\n    this.space = space;\n    if (this.info) this.view.requestMeasure(this.placeInfo);\n  }\n  updateSel() {\n    let cState = this.view.state.field(this.stateField),\n      open = cState.open;\n    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n      this.list.remove();\n      this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));\n      this.list.addEventListener(\"scroll\", () => {\n        if (this.info) this.view.requestMeasure(this.placeInfo);\n      });\n    }\n    if (this.updateSelectedOption(open.selected)) {\n      if (this.info) {\n        this.info.remove();\n        this.info = null;\n      }\n      let {\n        completion\n      } = open.options[open.selected];\n      let {\n        info\n      } = completion;\n      if (!info) return;\n      let infoResult = typeof info === 'string' ? document.createTextNode(info) : info(completion);\n      if (!infoResult) return;\n      if ('then' in infoResult) {\n        infoResult.then(node => {\n          if (node && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(node);\n        }).catch(e => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n      } else {\n        this.addInfoPane(infoResult);\n      }\n    }\n  }\n  addInfoPane(content) {\n    let dom = this.info = document.createElement(\"div\");\n    dom.className = \"cm-tooltip cm-completionInfo\";\n    dom.appendChild(content);\n    this.dom.appendChild(dom);\n    this.view.requestMeasure(this.placeInfo);\n  }\n  updateSelectedOption(selected) {\n    let set = null;\n    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n      if (i == selected) {\n        if (!opt.hasAttribute(\"aria-selected\")) {\n          opt.setAttribute(\"aria-selected\", \"true\");\n          set = opt;\n        }\n      } else {\n        if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n      }\n    }\n    if (set) scrollIntoView(this.list, set);\n    return set;\n  }\n  measureInfo() {\n    let sel = this.dom.querySelector(\"[aria-selected]\");\n    if (!sel || !this.info) return null;\n    let listRect = this.dom.getBoundingClientRect();\n    let infoRect = this.info.getBoundingClientRect();\n    let selRect = sel.getBoundingClientRect();\n    let space = this.space;\n    if (!space) {\n      let win = this.dom.ownerDocument.defaultView || window;\n      space = {\n        left: 0,\n        top: 0,\n        right: win.innerWidth,\n        bottom: win.innerHeight\n      };\n    }\n    if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n    let rtl = this.view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL,\n      left = rtl,\n      narrow = false,\n      maxWidth;\n    let top = \"\",\n      bottom = \"\";\n    let spaceLeft = listRect.left - space.left,\n      spaceRight = space.right - listRect.right;\n    if (left && spaceLeft < Math.min(infoRect.width, spaceRight)) left = false;else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft)) left = true;\n    if (infoRect.width <= (left ? spaceLeft : spaceRight)) {\n      top = Math.max(space.top, Math.min(selRect.top, space.bottom - infoRect.height)) - listRect.top + \"px\";\n      maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight) + \"px\";\n    } else {\n      narrow = true;\n      maxWidth = Math.min(400 /* Info.Width */, (rtl ? listRect.right : space.right - listRect.left) - 30 /* Info.Margin */) + \"px\";\n      let spaceBelow = space.bottom - listRect.bottom;\n      if (spaceBelow >= infoRect.height || spaceBelow > listRect.top)\n        // Below the completion\n        top = selRect.bottom - listRect.top + \"px\";else\n        // Above it\n        bottom = listRect.bottom - selRect.top + \"px\";\n    }\n    return {\n      top,\n      bottom,\n      maxWidth,\n      class: narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\"\n    };\n  }\n  positionInfo(pos) {\n    if (this.info) {\n      if (pos) {\n        this.info.style.top = pos.top;\n        this.info.style.bottom = pos.bottom;\n        this.info.style.maxWidth = pos.maxWidth;\n        this.info.className = \"cm-tooltip cm-completionInfo cm-completionInfo-\" + pos.class;\n      } else {\n        this.info.style.top = \"-1e6px\";\n      }\n    }\n  }\n  createListBox(options, id, range) {\n    const ul = document.createElement(\"ul\");\n    ul.id = id;\n    ul.setAttribute(\"role\", \"listbox\");\n    ul.setAttribute(\"aria-expanded\", \"true\");\n    ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n    for (let i = range.from; i < range.to; i++) {\n      let {\n        completion,\n        match\n      } = options[i];\n      const li = ul.appendChild(document.createElement(\"li\"));\n      li.id = id + \"-\" + i;\n      li.setAttribute(\"role\", \"option\");\n      let cls = this.optionClass(completion);\n      if (cls) li.className = cls;\n      for (let source of this.optionContent) {\n        let node = source(completion, this.view.state, match);\n        if (node) li.appendChild(node);\n      }\n    }\n    if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n    if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n    return ul;\n  }\n}\n// We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\nfunction completionTooltip(stateField) {\n  return view => new CompletionTooltip(view, stateField);\n}\nfunction scrollIntoView(container, element) {\n  let parent = container.getBoundingClientRect();\n  let self = element.getBoundingClientRect();\n  if (self.top < parent.top) container.scrollTop -= parent.top - self.top;else if (self.bottom > parent.bottom) container.scrollTop += self.bottom - parent.bottom;\n}\n\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n  let options = [],\n    i = 0;\n  for (let a of active) if (a.hasResult()) {\n    if (a.result.filter === false) {\n      let getMatch = a.result.getMatch;\n      for (let option of a.result.options) {\n        let match = [1e9 - i++];\n        if (getMatch) for (let n of getMatch(option)) match.push(n);\n        options.push(new Option(option, a, match));\n      }\n    } else {\n      let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)),\n        match;\n      for (let option of a.result.options) if (match = matcher.match(option.label)) {\n        if (option.boost != null) match[0] += option.boost;\n        options.push(new Option(option, a, match));\n      }\n    }\n  }\n  let result = [],\n    prev = null;\n  let compare = state.facet(completionConfig).compareCompletions;\n  for (let opt of options.sort((a, b) => b.match[0] - a.match[0] || compare(a.completion, b.completion))) {\n    if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply) result.push(opt);else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n    prev = opt.completion;\n  }\n  return result;\n}\nclass CompletionDialog {\n  constructor(options, attrs, tooltip, timestamp, selected, disabled) {\n    this.options = options;\n    this.attrs = attrs;\n    this.tooltip = tooltip;\n    this.timestamp = timestamp;\n    this.selected = selected;\n    this.disabled = disabled;\n  }\n  setSelected(selected, id) {\n    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n  }\n  static build(active, state, id, prev, conf) {\n    let options = sortOptions(active, state);\n    if (!options.length) {\n      return prev && active.some(a => a.state == 1 /* State.Pending */) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n    }\n    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n    if (prev && prev.selected != selected && prev.selected != -1) {\n      let selectedValue = prev.options[prev.selected].completion;\n      for (let i = 0; i < options.length; i++) if (options[i].completion == selectedValue) {\n        selected = i;\n        break;\n      }\n    }\n    return new CompletionDialog(options, makeAttrs(id, selected), {\n      pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n      create: completionTooltip(completionState),\n      above: conf.aboveCursor\n    }, prev ? prev.timestamp : Date.now(), selected, false);\n  }\n  map(changes) {\n    return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n      pos: changes.mapPos(this.tooltip.pos)\n    }), this.timestamp, this.selected, this.disabled);\n  }\n}\nclass CompletionState {\n  constructor(active, id, open) {\n    this.active = active;\n    this.id = id;\n    this.open = open;\n  }\n  static start() {\n    return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n  }\n  update(tr) {\n    let {\n        state\n      } = tr,\n      conf = state.facet(completionConfig);\n    let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n    let active = sources.map(source => {\n      let value = this.active.find(s => s.source == source) || new ActiveSource(source, this.active.some(a => a.state != 0 /* State.Inactive */) ? 1 /* State.Pending */ : 0 /* State.Inactive */);\n      return value.update(tr, conf);\n    });\n    if (active.length == this.active.length && active.every((a, i) => a == this.active[i])) active = this.active;\n    let open = this.open;\n    if (open && tr.docChanged) open = open.map(tr.changes);\n    if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active)) open = CompletionDialog.build(active, state, this.id, open, conf);else if (open && open.disabled && !active.some(a => a.state == 1 /* State.Pending */)) open = null;\n    if (!open && active.every(a => a.state != 1 /* State.Pending */) && active.some(a => a.hasResult())) active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */) : a);\n    for (let effect of tr.effects) if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n    return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n  }\n  get tooltip() {\n    return this.open ? this.open.tooltip : null;\n  }\n  get attrs() {\n    return this.open ? this.open.attrs : baseAttrs;\n  }\n}\nfunction sameResults(a, b) {\n  if (a == b) return true;\n  for (let iA = 0, iB = 0;;) {\n    while (iA < a.length && !a[iA].hasResult) iA++;\n    while (iB < b.length && !b[iB].hasResult) iB++;\n    let endA = iA == a.length,\n      endB = iB == b.length;\n    if (endA || endB) return endA == endB;\n    if (a[iA++].result != b[iB++].result) return false;\n  }\n}\nconst baseAttrs = {\n  \"aria-autocomplete\": \"list\"\n};\nfunction makeAttrs(id, selected) {\n  let result = {\n    \"aria-autocomplete\": \"list\",\n    \"aria-haspopup\": \"listbox\",\n    \"aria-controls\": id\n  };\n  if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n  return result;\n}\nconst none = [];\nfunction getUserEvent(tr) {\n  return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass ActiveSource {\n  constructor(source, state, explicitPos = -1) {\n    this.source = source;\n    this.state = state;\n    this.explicitPos = explicitPos;\n  }\n  hasResult() {\n    return false;\n  }\n  update(tr, conf) {\n    let event = getUserEvent(tr),\n      value = this;\n    if (event) value = value.handleUserEvent(tr, event, conf);else if (tr.docChanged) value = value.handleChange(tr);else if (tr.selection && value.state != 0 /* State.Inactive */) value = new ActiveSource(value.source, 0 /* State.Inactive */);\n    for (let effect of tr.effects) {\n      if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */, effect.value ? cur(tr.state) : -1);else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */);else if (effect.is(setActiveEffect)) for (let active of effect.value) if (active.source == value.source) value = active;\n    }\n    return value;\n  }\n  handleUserEvent(tr, type, conf) {\n    return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* State.Pending */);\n  }\n\n  handleChange(tr) {\n    return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);\n  }\n  map(changes) {\n    return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n  }\n}\nclass ActiveResult extends ActiveSource {\n  constructor(source, explicitPos, result, from, to) {\n    super(source, 2 /* State.Result */, explicitPos);\n    this.result = result;\n    this.from = from;\n    this.to = to;\n  }\n  hasResult() {\n    return true;\n  }\n  handleUserEvent(tr, type, conf) {\n    var _a;\n    let from = tr.changes.mapPos(this.from),\n      to = tr.changes.mapPos(this.to, 1);\n    let pos = cur(tr.state);\n    if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == \"delete\" && cur(tr.startState) == this.from) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* State.Pending */ : 0 /* State.Inactive */);\n    let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos),\n      updated;\n    if (checkValid(this.result.validFor, tr.state, from, to)) return new ActiveResult(this.source, explicitPos, this.result, from, to);\n    if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0)))) return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n    return new ActiveSource(this.source, 1 /* State.Pending */, explicitPos);\n  }\n  handleChange(tr) {\n    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);\n  }\n  map(mapping) {\n    return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n  }\n}\nfunction checkValid(validFor, state, from, to) {\n  if (!validFor) return false;\n  let text = state.sliceDoc(from, to);\n  return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst startCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst setActiveEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n  map(sources, mapping) {\n    return sources.map(s => s.map(mapping));\n  }\n});\nconst setSelectedEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create() {\n    return CompletionState.start();\n  },\n  update(value, tr) {\n    return value.update(tr);\n  },\n  provide: f => [_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, val => val.tooltip), _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, state => state.attrs)]\n});\n\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/\nfunction moveCompletionSelection(forward, by = \"option\") {\n  return view => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    let step = 1,\n      tooltip;\n    if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n    let {\n      length\n    } = cState.open.options;\n    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n    if (selected < 0) selected = by == \"page\" ? 0 : length - 1;else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n    view.dispatch({\n      effects: setSelectedEffect.of(selected)\n    });\n    return true;\n  };\n}\n/**\nAccept the current completion.\n*/\nconst acceptCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n  if (!cState.open.disabled) applyCompletion(view, cState.open.options[cState.open.selected]);\n  return true;\n};\n/**\nExplicitly start autocompletion.\n*/\nconst startCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (!cState) return false;\n  view.dispatch({\n    effects: startCompletionEffect.of(true)\n  });\n  return true;\n};\n/**\nClose the currently active completion.\n*/\nconst closeCompletion = view => {\n  let cState = view.state.field(completionState, false);\n  if (!cState || !cState.active.some(a => a.state != 0 /* State.Inactive */)) return false;\n  view.dispatch({\n    effects: closeCompletionEffect.of(null)\n  });\n  return true;\n};\nclass RunningQuery {\n  constructor(active, context) {\n    this.active = active;\n    this.context = context;\n    this.time = Date.now();\n    this.updates = [];\n    // Note that 'undefined' means 'not done yet', whereas 'null' means\n    // 'query returned null'.\n    this.done = undefined;\n  }\n}\nconst DebounceTime = 50,\n  MaxUpdateCount = 50,\n  MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.debounceUpdate = -1;\n    this.running = [];\n    this.debounceAccept = -1;\n    this.composing = 0 /* CompositionState.None */;\n    for (let active of view.state.field(completionState).active) if (active.state == 1 /* State.Pending */) this.startQuery(active);\n  }\n  update(update) {\n    let cState = update.state.field(completionState);\n    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n    let doesReset = update.transactions.some(tr => {\n      return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n    });\n    for (let i = 0; i < this.running.length; i++) {\n      let query = this.running[i];\n      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n        for (let handler of query.context.abortListeners) {\n          try {\n            handler();\n          } catch (e) {\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n          }\n        }\n        query.context.abortListeners = null;\n        this.running.splice(i--, 1);\n      } else {\n        query.updates.push(...update.transactions);\n      }\n    }\n    if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n    this.debounceUpdate = cState.active.some(a => a.state == 1 /* State.Pending */ && !this.running.some(q => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n    if (this.composing != 0 /* CompositionState.None */) for (let tr of update.transactions) {\n      if (getUserEvent(tr) == \"input\") this.composing = 2 /* CompositionState.Changed */;else if (this.composing == 2 /* CompositionState.Changed */ && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */;\n    }\n  }\n\n  startUpdate() {\n    this.debounceUpdate = -1;\n    let {\n        state\n      } = this.view,\n      cState = state.field(completionState);\n    for (let active of cState.active) {\n      if (active.state == 1 /* State.Pending */ && !this.running.some(r => r.active.source == active.source)) this.startQuery(active);\n    }\n  }\n  startQuery(active) {\n    let {\n        state\n      } = this.view,\n      pos = cur(state);\n    let context = new CompletionContext(state, pos, active.explicitPos == pos);\n    let pending = new RunningQuery(active, context);\n    this.running.push(pending);\n    Promise.resolve(active.source(context)).then(result => {\n      if (!pending.context.aborted) {\n        pending.done = result || null;\n        this.scheduleAccept();\n      }\n    }, err => {\n      this.view.dispatch({\n        effects: closeCompletionEffect.of(null)\n      });\n      (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n    });\n  }\n  scheduleAccept() {\n    if (this.running.every(q => q.done !== undefined)) this.accept();else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n  }\n  // For each finished query in this.running, try to create a result\n  // or, if appropriate, restart the query.\n  accept() {\n    var _a;\n    if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n    this.debounceAccept = -1;\n    let updated = [];\n    let conf = this.view.state.facet(completionConfig);\n    for (let i = 0; i < this.running.length; i++) {\n      let query = this.running[i];\n      if (query.done === undefined) continue;\n      this.running.splice(i--, 1);\n      if (query.done) {\n        let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\n        // Replay the transactions that happened since the start of\n        // the request and see if that preserves the result\n        for (let tr of query.updates) active = active.update(tr, conf);\n        if (active.hasResult()) {\n          updated.push(active);\n          continue;\n        }\n      }\n      let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);\n      if (current && current.state == 1 /* State.Pending */) {\n        if (query.done == null) {\n          // Explicitly failed. Should clear the pending status if it\n          // hasn't been re-set in the meantime.\n          let active = new ActiveSource(query.active.source, 0 /* State.Inactive */);\n          for (let tr of query.updates) active = active.update(tr, conf);\n          if (active.state != 1 /* State.Pending */) updated.push(active);\n        } else {\n          // Cleared by subsequent transactions. Restart.\n          this.startQuery(current);\n        }\n      }\n    }\n    if (updated.length) this.view.dispatch({\n      effects: setActiveEffect.of(updated)\n    });\n  }\n}, {\n  eventHandlers: {\n    blur() {\n      let state = this.view.state.field(completionState, false);\n      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) this.view.dispatch({\n        effects: closeCompletionEffect.of(null)\n      });\n    },\n    compositionstart() {\n      this.composing = 1 /* CompositionState.Started */;\n    },\n\n    compositionend() {\n      if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {\n        // Safari fires compositionend events synchronously, possibly\n        // from inside an update, so dispatch asynchronously to avoid reentrancy\n        setTimeout(() => this.view.dispatch({\n          effects: startCompletionEffect.of(false)\n        }), 20);\n      }\n      this.composing = 0 /* CompositionState.None */;\n    }\n  }\n});\n\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      minWidth: \"250px\",\n      maxHeight: \"10em\",\n      height: \"100%\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li\": {\n        overflowX: \"hidden\",\n        textOverflow: \"ellipsis\",\n        cursor: \"pointer\",\n        padding: \"1px 3px\",\n        lineHeight: 1.2\n      }\n    }\n  },\n  \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#17c\",\n    color: \"white\"\n  },\n  \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n    background: \"#777\"\n  },\n  \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#347\",\n    color: \"white\"\n  },\n  \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n    background: \"#444\"\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"···\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: `${400 /* Info.Width */}px`,\n    boxSizing: \"border-box\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": {\n    right: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-right\": {\n    left: \"100%\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n    right: `${30 /* Info.Margin */}px`\n  },\n  \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n    left: `${30 /* Info.Margin */}px`\n  },\n  \"&light .cm-snippetField\": {\n    backgroundColor: \"#00000022\"\n  },\n  \"&dark .cm-snippetField\": {\n    backgroundColor: \"#ffffff22\"\n  },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    display: \"inline-block\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\",\n    boxSizing: \"content-box\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": {\n      content: \"'ƒ'\"\n    }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": {\n      content: \"'○'\"\n    }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": {\n      content: \"'◌'\"\n    }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": {\n      content: \"'𝑥'\"\n    }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": {\n      content: \"'𝐶'\"\n    }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": {\n      content: \"'𝑡'\"\n    }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": {\n      content: \"'∪'\"\n    }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": {\n      content: \"'□'\"\n    }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": {\n      content: \"'🔑\\uFE0E'\"\n    } // Disable emoji rendering\n  },\n\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": {\n      content: \"'▢'\"\n    }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": {\n      content: \"'abc'\",\n      fontSize: \"50%\",\n      verticalAlign: \"middle\"\n    }\n  }\n});\nclass FieldPos {\n  constructor(field, line, from, to) {\n    this.field = field;\n    this.line = line;\n    this.from = from;\n    this.to = to;\n  }\n}\nclass FieldRange {\n  constructor(field, from, to) {\n    this.field = field;\n    this.from = from;\n    this.to = to;\n  }\n  map(changes) {\n    let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n    let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n    return from == null || to == null ? null : new FieldRange(this.field, from, to);\n  }\n}\nclass Snippet {\n  constructor(lines, fieldPositions) {\n    this.lines = lines;\n    this.fieldPositions = fieldPositions;\n  }\n  instantiate(state, pos) {\n    let text = [],\n      lineStart = [pos];\n    let lineObj = state.doc.lineAt(pos),\n      baseIndent = /^\\s*/.exec(lineObj.text)[0];\n    for (let line of this.lines) {\n      if (text.length) {\n        let indent = baseIndent,\n          tabs = /^\\t*/.exec(line)[0].length;\n        for (let i = 0; i < tabs; i++) indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n        lineStart.push(pos + indent.length - tabs);\n        line = indent + line.slice(tabs);\n      }\n      text.push(line);\n      pos += line.length + 1;\n    }\n    let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n    return {\n      text,\n      ranges\n    };\n  }\n  static parse(template) {\n    let fields = [];\n    let lines = [],\n      positions = [],\n      m;\n    for (let line of template.split(/\\r\\n?|\\n/)) {\n      while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n        let seq = m[1] ? +m[1] : null,\n          name = m[2] || m[3] || \"\",\n          found = -1;\n        for (let i = 0; i < fields.length; i++) {\n          if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n        }\n        if (found < 0) {\n          let i = 0;\n          while (i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq)) i++;\n          fields.splice(i, 0, {\n            seq,\n            name\n          });\n          found = i;\n          for (let pos of positions) if (pos.field >= found) pos.field++;\n        }\n        positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n        line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n      }\n      for (let esc; esc = /\\\\([{}])/.exec(line);) {\n        line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);\n        for (let pos of positions) if (pos.line == lines.length && pos.from > esc.index) {\n          pos.from--;\n          pos.to--;\n        }\n      }\n      lines.push(line);\n    }\n    return new Snippet(lines, positions);\n  }\n}\nlet fieldMarker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n  widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n    toDOM() {\n      let span = document.createElement(\"span\");\n      span.className = \"cm-snippetFieldPosition\";\n      return span;\n    }\n    ignoreEvent() {\n      return false;\n    }\n  }()\n});\nlet fieldRange = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n  class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n  constructor(ranges, active) {\n    this.ranges = ranges;\n    this.active = active;\n    this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n  }\n  map(changes) {\n    let ranges = [];\n    for (let r of this.ranges) {\n      let mapped = r.map(changes);\n      if (!mapped) return null;\n      ranges.push(mapped);\n    }\n    return new ActiveSnippet(ranges, this.active);\n  }\n  selectionInsideField(sel) {\n    return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n  }\n}\nconst setActive = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n  map(value, changes) {\n    return value && value.map(changes);\n  }\n});\nconst moveToField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create() {\n    return null;\n  },\n  update(value, tr) {\n    for (let effect of tr.effects) {\n      if (effect.is(setActive)) return effect.value;\n      if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n    }\n    if (value && tr.docChanged) value = value.map(tr.changes);\n    if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n    return value;\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, val => val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter(r => r.field == field).map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/\nfunction snippet(template) {\n  let snippet = Snippet.parse(template);\n  return (editor, _completion, from, to) => {\n    let {\n      text,\n      ranges\n    } = snippet.instantiate(editor.state, from);\n    let spec = {\n      changes: {\n        from,\n        to,\n        insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text)\n      },\n      scrollIntoView: true\n    };\n    if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n    if (ranges.length > 1) {\n      let active = new ActiveSnippet(ranges, 0);\n      let effects = spec.effects = [setActive.of(active)];\n      if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));\n    }\n    editor.dispatch(editor.state.update(spec));\n  };\n}\nfunction moveField(dir) {\n  return ({\n    state,\n    dispatch\n  }) => {\n    let active = state.field(snippetState, false);\n    if (!active || dir < 0 && active.active == 0) return false;\n    let next = active.active + dir,\n      last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n    dispatch(state.update({\n      selection: fieldSelection(active.ranges, next),\n      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n    }));\n    return true;\n  };\n}\n/**\nA command that clears the active snippet, if any.\n*/\nconst clearSnippet = ({\n  state,\n  dispatch\n}) => {\n  let active = state.field(snippetState, false);\n  if (!active) return false;\n  dispatch(state.update({\n    effects: setActive.of(null)\n  }));\n  return true;\n};\n/**\nMove to the next snippet field, if available.\n*/\nconst nextSnippetField = /*@__PURE__*/moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/\nconst prevSnippetField = /*@__PURE__*/moveField(-1);\nconst defaultSnippetKeymap = [{\n  key: \"Tab\",\n  run: nextSnippetField,\n  shift: prevSnippetField\n}, {\n  key: \"Escape\",\n  run: clearSnippet\n}];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/\nconst snippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine(maps) {\n    return maps.length ? maps[0] : defaultSnippetKeymap;\n  }\n});\nconst addSnippetKeymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/\nfunction snippetCompletion(template, completion) {\n  return Object.assign(Object.assign({}, completion), {\n    apply: snippet(template)\n  });\n}\nconst snippetPointerHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n  mousedown(event, view) {\n    let active = view.state.field(snippetState, false),\n      pos;\n    if (!active || (pos = view.posAtCoords({\n      x: event.clientX,\n      y: event.clientY\n    })) == null) return false;\n    let match = active.ranges.find(r => r.from <= pos && r.to >= pos);\n    if (!match || match.field == active.active) return false;\n    view.dispatch({\n      selection: fieldSelection(active.ranges, match.field),\n      effects: setActive.of(active.ranges.some(r => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null)\n    });\n    return true;\n  }\n});\nfunction wordRE(wordChars) {\n  let escaped = wordChars.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\n  try {\n    return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n  } catch (_a) {\n    return new RegExp(`[\\w${escaped}]`, \"g\");\n  }\n}\nfunction mapRE(re, f) {\n  return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/Object.create(null);\nfunction wordCache(wordChars) {\n  return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap());\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n  for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {\n    let {\n        value\n      } = lines,\n      m;\n    wordRE.lastIndex = 0;\n    while (m = wordRE.exec(value)) {\n      if (!seen[m[0]] && pos + m.index != ignoreAt) {\n        result.push({\n          type: \"text\",\n          label: m[0]\n        });\n        seen[m[0]] = true;\n        if (result.length >= 2000 /* C.MaxList */) return;\n      }\n    }\n    pos += value.length + 1;\n  }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n  let big = doc.length >= 1000 /* C.MinCacheLen */;\n  let cached = big && cache.get(doc);\n  if (cached) return cached;\n  let result = [],\n    seen = Object.create(null);\n  if (doc.children) {\n    let pos = 0;\n    for (let ch of doc.children) {\n      if (ch.length >= 1000 /* C.MinCacheLen */) {\n        for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {\n          if (!seen[c.label]) {\n            seen[c.label] = true;\n            result.push(c);\n          }\n        }\n      } else {\n        storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n      }\n      pos += ch.length + 1;\n    }\n  } else {\n    storeWords(doc, wordRE, result, seen, ignoreAt);\n  }\n  if (big && result.length < 2000 /* C.MaxList */) cache.set(doc, result);\n  return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/\nconst completeAnyWord = context => {\n  let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n  let re = wordRE(wordChars);\n  let token = context.matchBefore(mapRE(re, s => s + \"$\"));\n  if (!token && !context.explicit) return null;\n  let from = token ? token.from : context.pos;\n  let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */, from);\n  return {\n    from,\n    options,\n    validFor: mapRE(re, s => \"^\" + s)\n  };\n};\nconst defaults = {\n  brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n  before: \")]}:;>\",\n  stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n  map(value, mapping) {\n    let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n    return mapped == null ? undefined : mapped;\n  }\n});\nconst skipBracketEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n  map(value, mapping) {\n    return mapping.mapPos(value);\n  }\n});\nconst closedBracket = /*@__PURE__*/new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {}();\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n  },\n  update(value, tr) {\n    if (tr.selection) {\n      let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\n      let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\n      if (lineStart != tr.changes.mapPos(prevLineStart, -1)) value = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    }\n    value = value.map(tr.changes);\n    for (let effect of tr.effects) {\n      if (effect.is(closeBracketEffect)) value = value.update({\n        add: [closedBracket.range(effect.value, effect.value + 1)]\n      });else if (effect.is(skipBracketEffect)) value = value.update({\n        filter: from => from != effect.value\n      });\n    }\n    return value;\n  }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/\nfunction closeBrackets() {\n  return [inputHandler, bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n  for (let i = 0; i < definedClosing.length; i += 2) if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n  return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n  return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert) => {\n  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n  let sel = view.state.selection.main;\n  if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n  let tr = insertBracket(view.state, insert);\n  if (!tr) return false;\n  view.dispatch(tr);\n  return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/\nconst deleteBracketPair = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let conf = config(state, state.selection.main.head);\n  let tokens = conf.brackets || defaults.brackets;\n  let dont = null,\n    changes = state.changeByRange(range => {\n      if (range.empty) {\n        let before = prevChar(state.doc, range.head);\n        for (let token of tokens) {\n          if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0))) return {\n            changes: {\n              from: range.head - token.length,\n              to: range.head + token.length\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length)\n          };\n        }\n      }\n      return {\n        range: dont = range\n      };\n    });\n  if (!dont) dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"delete.backward\"\n  }));\n  return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/\nconst closeBracketsKeymap = [{\n  key: \"Backspace\",\n  run: deleteBracketPair\n}];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/\nfunction insertBracket(state, bracket) {\n  let conf = config(state, state.selection.main.head);\n  let tokens = conf.brackets || defaults.brackets;\n  for (let tok of tokens) {\n    let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n    if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n    if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n  }\n  return null;\n}\nfunction closedBracketAt(state, pos) {\n  let found = false;\n  state.field(bracketState).between(0, state.doc.length, from => {\n    if (from == pos) found = true;\n  });\n  return found;\n}\nfunction nextChar(doc, pos) {\n  let next = doc.sliceString(pos, pos + 2);\n  return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n  let prev = doc.sliceString(pos - 2, pos);\n  return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n  let dont = null,\n    changes = state.changeByRange(range => {\n      if (!range.empty) return {\n        changes: [{\n          insert: open,\n          from: range.from\n        }, {\n          insert: close,\n          from: range.to\n        }],\n        effects: closeBracketEffect.of(range.to + open.length),\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n      };\n      let next = nextChar(state.doc, range.head);\n      if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n        changes: {\n          insert: open + close,\n          from: range.head\n        },\n        effects: closeBracketEffect.of(range.head + open.length),\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length)\n      };\n      return {\n        range: dont = range\n      };\n    });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input.type\"\n  });\n}\nfunction handleClose(state, _open, close) {\n  let dont = null,\n    moved = state.selection.ranges.map(range => {\n      if (range.empty && nextChar(state.doc, range.head) == close) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length);\n      return dont = range;\n    });\n  return dont ? null : state.update({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(moved, state.selection.mainIndex),\n    scrollIntoView: true,\n    effects: state.selection.ranges.map(({\n      from\n    }) => skipBracketEffect.of(from))\n  });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n  let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n  let dont = null,\n    changes = state.changeByRange(range => {\n      if (!range.empty) return {\n        changes: [{\n          insert: token,\n          from: range.from\n        }, {\n          insert: token,\n          from: range.to\n        }],\n        effects: closeBracketEffect.of(range.to + token.length),\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n      };\n      let pos = range.head,\n        next = nextChar(state.doc, pos),\n        start;\n      if (next == token) {\n        if (nodeStart(state, pos)) {\n          return {\n            changes: {\n              insert: token + token,\n              from: pos\n            },\n            effects: closeBracketEffect.of(pos + token.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n          };\n        } else if (closedBracketAt(state, pos)) {\n          let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n          return {\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),\n            effects: skipBracketEffect.of(pos)\n          };\n        }\n      } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n        return {\n          changes: {\n            insert: token + token + token + token,\n            from: pos\n          },\n          effects: closeBracketEffect.of(pos + token.length),\n          range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n        };\n      } else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n        if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n          changes: {\n            insert: token + token,\n            from: pos\n          },\n          effects: closeBracketEffect.of(pos + token.length),\n          range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n        };\n      }\n      return {\n        range: dont = range\n      };\n    });\n  return dont ? null : state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input.type\"\n  });\n}\nfunction nodeStart(state, pos) {\n  let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n  return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n  let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n  let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);\n  for (let i = 0; i < 5; i++) {\n    let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n    let quotePos = start.indexOf(quoteToken);\n    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n      let first = node.firstChild;\n      while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {\n        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n        first = first.firstChild;\n      }\n      return true;\n    }\n    let parent = node.to == pos && node.parent;\n    if (!parent) break;\n    node = parent;\n  }\n  return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n  let charCat = state.charCategorizer(pos);\n  if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return pos;\n  for (let prefix of prefixes) {\n    let start = pos - prefix.length;\n    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return start;\n  }\n  return -1;\n}\n\n/**\nReturns an extension that enables autocompletion.\n*/\nfunction autocompletion(config = {}) {\n  return [completionState, completionConfig.of(config), completionPlugin, completionKeymapExt, baseTheme];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/\nconst completionKeymap = [{\n  key: \"Ctrl-Space\",\n  run: startCompletion\n}, {\n  key: \"Escape\",\n  run: closeCompletion\n}, {\n  key: \"ArrowDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true)\n}, {\n  key: \"ArrowUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false)\n}, {\n  key: \"PageDown\",\n  run: /*@__PURE__*/moveCompletionSelection(true, \"page\")\n}, {\n  key: \"PageUp\",\n  run: /*@__PURE__*/moveCompletionSelection(false, \"page\")\n}, {\n  key: \"Enter\",\n  run: acceptCompletion\n}];\nconst completionKeymapExt = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/\nfunction completionStatus(state) {\n  let cState = state.field(completionState, false);\n  return cState && cState.active.some(a => a.state == 1 /* State.Pending */) ? \"pending\" : cState && cState.active.some(a => a.state != 0 /* State.Inactive */) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/new WeakMap();\n/**\nReturns the available completions as an array.\n*/\nfunction currentCompletions(state) {\n  var _a;\n  let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  if (!open || open.disabled) return [];\n  let completions = completionArrayCache.get(open.options);\n  if (!completions) completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));\n  return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/\nfunction selectedCompletion(state) {\n  var _a;\n  let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/\nfunction selectedCompletionIndex(state) {\n  var _a;\n  let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n  return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/\nfunction setSelectedCompletion(index) {\n  return setSelectedEffect.of(index);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9hdXRvY29tcGxldGUvZGlzdC9pbmRleC5qcz9kNDU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFubm90YXRpb24sIEVkaXRvclNlbGVjdGlvbiwgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGZyb21Db2RlUG9pbnQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgUHJlYywgVGV4dCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgUmFuZ2VTZXQsIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IGxvZ0V4Y2VwdGlvbiwgRGlyZWN0aW9uLCBzaG93VG9vbHRpcCwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgZ2V0VG9vbHRpcCwgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwga2V5bWFwIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBzeW50YXhUcmVlLCBpbmRlbnRVbml0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuXG4vKipcbkFuIGluc3RhbmNlIG9mIHRoaXMgaXMgcGFzc2VkIHRvIGNvbXBsZXRpb24gc291cmNlIGZ1bmN0aW9ucy5cbiovXG5jbGFzcyBDb21wbGV0aW9uQ29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGNvbXBsZXRpb24gY29udGV4dC4gKE1vc3RseSB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICBjb21wbGV0aW9uIHNvdXJjZXPigJRpbiB0aGUgZWRpdG9yLCB0aGUgZXh0ZW5zaW9uIHdpbGwgY3JlYXRlXG4gICAgdGhlc2UgZm9yIHlvdS4pXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHN0YXRlIHRoYXQgdGhlIGNvbXBsZXRpb24gaGFwcGVucyBpbi5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGNvbXBsZXRpb24gaXMgaGFwcGVuaW5nLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciBjb21wbGV0aW9uIHdhcyBhY3RpdmF0ZWQgZXhwbGljaXRseSwgb3JcbiAgICBpbXBsaWNpdGx5IGJ5IHR5cGluZy4gVGhlIHVzdWFsIHdheSB0byByZXNwb25kIHRvIHRoaXMgaXMgdG9cbiAgICBvbmx5IHJldHVybiBjb21wbGV0aW9ucyB3aGVuIGVpdGhlciB0aGVyZSBpcyBwYXJ0IG9mIGFcbiAgICBjb21wbGV0YWJsZSBlbnRpdHkgYmVmb3JlIHRoZSBjdXJzb3IsIG9yIGBleHBsaWNpdGAgaXMgdHJ1ZS5cbiAgICAqL1xuICAgIGV4cGxpY2l0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gICAgdG9rZW4gYmVmb3JlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSBzeW50YXhUcmVlKHRoaXMuc3RhdGUpLnJlc29sdmVJbm5lcih0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycylcbiAgICAgICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TZXQoY2hhcnMpIHtcbiAgICBsZXQgZmxhdCA9IE9iamVjdC5rZXlzKGNoYXJzKS5qb2luKFwiXCIpO1xuICAgIGxldCB3b3JkcyA9IC9cXHcvLnRlc3QoZmxhdCk7XG4gICAgaWYgKHdvcmRzKVxuICAgICAgICBmbGF0ID0gZmxhdC5yZXBsYWNlKC9cXHcvZywgXCJcIik7XG4gICAgcmV0dXJuIGBbJHt3b3JkcyA/IFwiXFxcXHdcIiA6IFwiXCJ9JHtmbGF0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCBcIlxcXFwkJlwiKX1dYDtcbn1cbmZ1bmN0aW9uIHByZWZpeE1hdGNoKG9wdGlvbnMpIHtcbiAgICBsZXQgZmlyc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByZXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCB7IGxhYmVsIH0gb2Ygb3B0aW9ucykge1xuICAgICAgICBmaXJzdFtsYWJlbFswXV0gPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzdFtsYWJlbFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgc291cmNlID0gdG9TZXQoZmlyc3QpICsgdG9TZXQocmVzdCkgKyBcIiokXCI7XG4gICAgcmV0dXJuIFtuZXcgUmVnRXhwKFwiXlwiICsgc291cmNlKSwgbmV3IFJlZ0V4cChzb3VyY2UpXTtcbn1cbi8qKlxuR2l2ZW4gYSBhIGZpeGVkIGFycmF5IG9mIG9wdGlvbnMsIHJldHVybiBhbiBhdXRvY29tcGxldGVyIHRoYXRcbmNvbXBsZXRlcyB0aGVtLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRlRnJvbUxpc3QobGlzdCkge1xuICAgIGxldCBvcHRpb25zID0gbGlzdC5tYXAobyA9PiB0eXBlb2YgbyA9PSBcInN0cmluZ1wiID8geyBsYWJlbDogbyB9IDogbyk7XG4gICAgbGV0IFt2YWxpZEZvciwgbWF0Y2hdID0gb3B0aW9ucy5ldmVyeShvID0+IC9eXFx3KyQvLnRlc3Qoby5sYWJlbCkpID8gWy9cXHcqJC8sIC9cXHcrJC9dIDogcHJlZml4TWF0Y2gob3B0aW9ucyk7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCB0b2tlbiA9IGNvbnRleHQubWF0Y2hCZWZvcmUobWF0Y2gpO1xuICAgICAgICByZXR1cm4gdG9rZW4gfHwgY29udGV4dC5leHBsaWNpdCA/IHsgZnJvbTogdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3MsIG9wdGlvbnMsIHZhbGlkRm9yIH0gOiBudWxsO1xuICAgIH07XG59XG4vKipcbldyYXAgdGhlIGdpdmVuIGNvbXBsZXRpb24gc291cmNlIHNvIHRoYXQgaXQgd2lsbCBvbmx5IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZkluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KVxuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCB0aGUgZ2l2ZW4gY29tcGxldGlvbiBzb3VyY2Ugc28gdGhhdCBpdCB3aWxsIG5vdCBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZOb3RJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudClcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uID0gY29tcGxldGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggaW5zZXJ0cyBhXG5jb21wbGV0aW9uJ3MgdGV4dCBpbiB0aGUgbWFpbiBzZWxlY3Rpb24gcmFuZ2UsIGFuZCBhbnkgb3RoZXJcbnNlbGVjdGlvbiByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSB0ZXh0IGluIGZyb250IG9mIGl0LlxuKi9cbmZ1bmN0aW9uIGluc2VydENvbXBsZXRpb25UZXh0KHN0YXRlLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW4pXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogZnJvbSwgdG86IHRvLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgdGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB9O1xuICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8XG4gICAgICAgICAgICBsZW4gJiYgc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSAtIGxlbiwgcmFuZ2UuZnJvbSkgIT0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSAtIGxlbiwgdG86IHJhbmdlLmZyb20sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSAtIGxlbiArIHRleHQubGVuZ3RoKVxuICAgICAgICB9O1xuICAgIH0pKSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIiB9KTtcbn1cbmZ1bmN0aW9uIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pIHtcbiAgICBjb25zdCBhcHBseSA9IG9wdGlvbi5jb21wbGV0aW9uLmFwcGx5IHx8IG9wdGlvbi5jb21wbGV0aW9uLmxhYmVsO1xuICAgIGxldCByZXN1bHQgPSBvcHRpb24uc291cmNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc2VydENvbXBsZXRpb25UZXh0KHZpZXcuc3RhdGUsIGFwcGx5LCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKSksIHsgYW5ub3RhdGlvbnM6IHBpY2tlZENvbXBsZXRpb24ub2Yob3B0aW9uLmNvbXBsZXRpb24pIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbn1cbmNvbnN0IFNvdXJjZUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcbiAgICBpZiAoIWtub3duKVxuICAgICAgICBTb3VyY2VDYWNoZS5zZXQoc291cmNlLCBrbm93biA9IGNvbXBsZXRlRnJvbUxpc3Qoc291cmNlKSk7XG4gICAgcmV0dXJuIGtub3duO1xufVxuXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXG4vLyBvbmNlIGZvciBhIHBhdHRlcm4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIG1hdGNoIGFueSBudW1iZXIgb2Zcbi8vIGNvbXBsZXRpb25zLlxuY2xhc3MgRnV6enlNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBbXTtcbiAgICAgICAgLy8gQnVmZmVycyByZXVzZWQgYnkgY2FsbHMgdG8gYG1hdGNoYCB0byB0cmFjayBtYXRjaGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IFtdO1xuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdHRlcm4ubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGNoYXIgPSBjb2RlUG9pbnRBdChwYXR0ZXJuLCBwKSwgc2l6ZSA9IGNvZGVQb2ludFNpemUoY2hhcik7XG4gICAgICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcik7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHBhdHRlcm4uc2xpY2UocCwgcCArIHNpemUpLCB1cHBlciA9IHBhcnQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZm9sZGVkLnB1c2goY29kZVBvaW50QXQodXBwZXIgPT0gcGFydCA/IHBhcnQudG9Mb3dlckNhc2UoKSA6IHVwcGVyLCAwKSk7XG4gICAgICAgICAgICBwICs9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3RyYWwgPSBwYXR0ZXJuLmxlbmd0aCAhPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhIGdpdmVuIHdvcmQgKGNvbXBsZXRpb24pIGFnYWluc3QgdGhlIHBhdHRlcm4gKGlucHV0KS5cbiAgICAvLyBXaWxsIHJldHVybiBudWxsIGZvciBubyBtYXRjaCwgYW5kIG90aGVyd2lzZSBhbiBhcnJheSB0aGF0IHN0YXJ0c1xuICAgIC8vIHdpdGggdGhlIG1hdGNoIHNjb3JlLCBmb2xsb3dlZCBieSBhbnkgbnVtYmVyIG9mIGBmcm9tLCB0b2AgcGFpcnNcbiAgICAvLyBpbmRpY2F0aW5nIHRoZSBtYXRjaGVkIHBhcnRzIG9mIGB3b3JkYC5cbiAgICAvL1xuICAgIC8vIFRoZSBzY29yZSBpcyBhIG51bWJlciB0aGF0IGlzIG1vcmUgbmVnYXRpdmUgdGhlIHdvcnNlIHRoZSBtYXRjaFxuICAgIC8vIGlzLiBTZWUgYFBlbmFsdHlgIGFib3ZlLlxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgY2hhcnMsIGZvbGRlZCwgYW55LCBwcmVjaXNlLCBieVdvcmQgfSA9IHRoaXM7XG4gICAgICAgIC8vIEZvciBzaW5nbGUtY2hhcmFjdGVyIHF1ZXJpZXMsIG9ubHkgbWF0Y2ggd2hlbiB0aGV5IG9jY3VyIHJpZ2h0XG4gICAgICAgIC8vIGF0IHRoZSBzdGFydFxuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGNvZGVQb2ludEF0KHdvcmQsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09IGNoYXJzWzBdID8gWzAsIDAsIGNvZGVQb2ludFNpemUoZmlyc3QpXVxuICAgICAgICAgICAgICAgIDogZmlyc3QgPT0gZm9sZGVkWzBdID8gWy0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLywgMCwgY29kZVBvaW50U2l6ZShmaXJzdCldIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlyZWN0ID0gd29yZC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgICAgIGlmIChkaXJlY3QgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMCwgMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aF07XG4gICAgICAgIGxldCBsZW4gPSBjaGFycy5sZW5ndGgsIGFueVRvID0gMDtcbiAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCk7IGkgPCBlICYmIGFueVRvIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYW55VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FueVRvXSlcbiAgICAgICAgICAgICAgICAgICAgYW55W2FueVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtYXRjaCwgZXhpdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGFueVRvIDwgbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgdHJhY2tzIHRoZSBleHRlbnQgb2YgdGhlIHByZWNpc2UgKG5vbi1mb2xkZWQsIG5vdFxuICAgICAgICAvLyBuZWNlc3NhcmlseSBhZGphY2VudCkgbWF0Y2hcbiAgICAgICAgbGV0IHByZWNpc2VUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZXJlIGlzIGEgbWF0Y2ggdGhhdCBoaXRzIG9ubHkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgIC8vIGFwcGVhciB0byBiZSBzdGFydGluZyB3b3Jkcy4gYGJ5V29yZEZvbGRlZGAgaXMgc2V0IHRvIHRydWUgd2hlblxuICAgICAgICAvLyBhIGNhc2UgZm9sZGVkIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBzdWNoIGEgbWF0Y2hcbiAgICAgICAgbGV0IGJ5V29yZFRvID0gMCwgYnlXb3JkRm9sZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIGEgcGFydGlhbCBhZGphY2VudCBtYXRjaCwgdGhlc2UgdHJhY2sgaXRzIHN0YXRlXG4gICAgICAgIGxldCBhZGphY2VudFRvID0gMCwgYWRqYWNlbnRTdGFydCA9IC0xLCBhZGphY2VudEVuZCA9IC0xO1xuICAgICAgICBsZXQgaGFzTG93ZXIgPSAvW2Etel0vLnRlc3Qod29yZCksIHdvcmRBZGphY2VudCA9IHRydWU7XG4gICAgICAgIC8vIEdvIG92ZXIgdGhlIG9wdGlvbidzIHRleHQsIHNjYW5uaW5nIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBtYXRjaGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCksIHByZXZUeXBlID0gMCAvKiBUcC5Ob25Xb3JkICovOyBpIDwgZSAmJiBieVdvcmRUbyA8IGxlbjspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNlVG8gPCBsZW4gJiYgbmV4dCA9PSBjaGFyc1twcmVjaXNlVG9dKVxuICAgICAgICAgICAgICAgICAgICBwcmVjaXNlW3ByZWNpc2VUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYWRqYWNlbnRUb10gfHwgbmV4dCA9PSBmb2xkZWRbYWRqYWNlbnRUb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudEVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2gsIHR5cGUgPSBuZXh0IDwgMHhmZlxuICAgICAgICAgICAgICAgID8gKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NyB8fCBuZXh0ID49IDk3ICYmIG5leHQgPD0gMTIyID8gMiAvKiBUcC5Mb3dlciAqLyA6IG5leHQgPj0gNjUgJiYgbmV4dCA8PSA5MCA/IDEgLyogVHAuVXBwZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pXG4gICAgICAgICAgICAgICAgOiAoKGNoID0gZnJvbUNvZGVQb2ludChuZXh0KSkgIT0gY2gudG9Mb3dlckNhc2UoKSA/IDEgLyogVHAuVXBwZXIgKi8gOiBjaCAhPSBjaC50b1VwcGVyQ2FzZSgpID8gMiAvKiBUcC5Mb3dlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLyk7XG4gICAgICAgICAgICBpZiAoIWkgfHwgdHlwZSA9PSAxIC8qIFRwLlVwcGVyICovICYmIGhhc0xvd2VyIHx8IHByZXZUeXBlID09IDAgLyogVHAuTm9uV29yZCAqLyAmJiB0eXBlICE9IDAgLyogVHAuTm9uV29yZCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyc1tieVdvcmRUb10gPT0gbmV4dCB8fCAoZm9sZGVkW2J5V29yZFRvXSA9PSBuZXh0ICYmIChieVdvcmRGb2xkZWQgPSB0cnVlKSkpXG4gICAgICAgICAgICAgICAgICAgIGJ5V29yZFtieVdvcmRUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnlXb3JkLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd29yZEFkamFjZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbiAmJiBieVdvcmRbMF0gPT0gMCAmJiB3b3JkQWRqYWNlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuICYmIGFkamFjZW50U3RhcnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIC0gd29yZC5sZW5ndGgsIDAsIGFkamFjZW50RW5kXTtcbiAgICAgICAgaWYgKGRpcmVjdCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIFstNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgZGlyZWN0LCBkaXJlY3QgKyB0aGlzLnBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIFstMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gLSB3b3JkLmxlbmd0aCwgYWRqYWNlbnRTdGFydCwgYWRqYWNlbnRFbmRdO1xuICAgICAgICBpZiAoYnlXb3JkVG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0KC0xMDAgLyogUGVuYWx0eS5CeVdvcmQgKi8gKyAoYnlXb3JkRm9sZGVkID8gLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovIDogMCkgKyAtNzAwIC8qIFBlbmFsdHkuTm90U3RhcnQgKi8gK1xuICAgICAgICAgICAgICAgICh3b3JkQWRqYWNlbnQgPyAwIDogLTExMDAgLyogUGVuYWx0eS5HYXAgKi8pLCBieVdvcmQsIHdvcmQpO1xuICAgICAgICByZXR1cm4gY2hhcnMubGVuZ3RoID09IDIgPyBudWxsIDogdGhpcy5yZXN1bHQoKGFueVswXSA/IC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyA6IDApICsgLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTExMDAgLyogUGVuYWx0eS5HYXAgKi8sIGFueSwgd29yZCk7XG4gICAgfVxuICAgIHJlc3VsdChzY29yZSwgcG9zaXRpb25zLCB3b3JkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbc2NvcmUgLSB3b3JkLmxlbmd0aF0sIGkgPSAxO1xuICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKSB7XG4gICAgICAgICAgICBsZXQgdG8gPSBwb3MgKyAodGhpcy5hc3RyYWwgPyBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KHdvcmQsIHBvcykpIDogMSk7XG4gICAgICAgICAgICBpZiAoaSA+IDEgJiYgcmVzdWx0W2kgLSAxXSA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2kgLSAxXSA9IHRvO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuY29uc3QgY29tcGxldGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhY3RpdmF0ZU9uVHlwaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0T25PcGVuOiB0cnVlLFxuICAgICAgICAgICAgb3ZlcnJpZGU6IG51bGwsXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogdHJ1ZSxcbiAgICAgICAgICAgIG1heFJlbmRlcmVkT3B0aW9uczogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogdHJ1ZSxcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKCkgPT4gXCJcIixcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgYWJvdmVDdXJzb3I6IGZhbHNlLFxuICAgICAgICAgICAgaWNvbnM6IHRydWUsXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IFtdLFxuICAgICAgICAgICAgY29tcGFyZUNvbXBsZXRpb25zOiAoYSwgYikgPT4gYS5sYWJlbC5sb2NhbGVDb21wYXJlKGIubGFiZWwpLFxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EZWxheTogNzVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZGVmYXVsdEtleW1hcDogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgaWNvbnM6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICB0b29sdGlwQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIG9wdGlvbkNsYXNzOiAoYSwgYikgPT4gYyA9PiBqb2luQ2xhc3MoYShjKSwgYihjKSksXG4gICAgICAgICAgICBhZGRUb09wdGlvbnM6IChhLCBiKSA9PiBhLmNvbmNhdChiKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGpvaW5DbGFzcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyBiID8gYSArIFwiIFwiICsgYiA6IGEgOiBiO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Db250ZW50KGNvbmZpZykge1xuICAgIGxldCBjb250ZW50ID0gY29uZmlnLmFkZFRvT3B0aW9ucy5zbGljZSgpO1xuICAgIGlmIChjb25maWcuaWNvbnMpXG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICByZW5kZXIoY29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBpY29uLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uSWNvblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbi50eXBlKVxuICAgICAgICAgICAgICAgICAgICBpY29uLmNsYXNzTGlzdC5hZGQoLi4uY29tcGxldGlvbi50eXBlLnNwbGl0KC9cXHMrL2cpLm1hcChjbHMgPT4gXCJjbS1jb21wbGV0aW9uSWNvbi1cIiArIGNscykpO1xuICAgICAgICAgICAgICAgIGljb24uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAyMFxuICAgICAgICB9KTtcbiAgICBjb250ZW50LnB1c2goe1xuICAgICAgICByZW5kZXIoY29tcGxldGlvbiwgX3MsIG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGxhYmVsRWx0LmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkxhYmVsXCI7XG4gICAgICAgICAgICBsZXQgeyBsYWJlbCB9ID0gY29tcGxldGlvbiwgb2ZmID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgbWF0Y2gubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbWF0Y2hbaisrXSwgdG8gPSBtYXRjaFtqKytdO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gb2ZmKVxuICAgICAgICAgICAgICAgICAgICBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShvZmYsIGZyb20pKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNwYW4gPSBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShmcm9tLCB0bykpKTtcbiAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbk1hdGNoZWRUZXh0XCI7XG4gICAgICAgICAgICAgICAgb2ZmID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2ZmIDwgbGFiZWwubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGxhYmVsRWx0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxhYmVsLnNsaWNlKG9mZikpKTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEVsdDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IDUwXG4gICAgfSwge1xuICAgICAgICByZW5kZXIoY29tcGxldGlvbikge1xuICAgICAgICAgICAgaWYgKCFjb21wbGV0aW9uLmRldGFpbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBkZXRhaWxFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIGRldGFpbEVsdC5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25EZXRhaWxcIjtcbiAgICAgICAgICAgIGRldGFpbEVsdC50ZXh0Q29udGVudCA9IGNvbXBsZXRpb24uZGV0YWlsO1xuICAgICAgICAgICAgcmV0dXJuIGRldGFpbEVsdDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IDgwXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnQuc29ydCgoYSwgYikgPT4gYS5wb3NpdGlvbiAtIGIucG9zaXRpb24pLm1hcChhID0+IGEucmVuZGVyKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQXJvdW5kU2VsZWN0ZWQodG90YWwsIHNlbGVjdGVkLCBtYXgpIHtcbiAgICBpZiAodG90YWwgPD0gbWF4KVxuICAgICAgICByZXR1cm4geyBmcm9tOiAwLCB0bzogdG90YWwgfTtcbiAgICBpZiAoc2VsZWN0ZWQgPCAwKVxuICAgICAgICBzZWxlY3RlZCA9IDA7XG4gICAgaWYgKHNlbGVjdGVkIDw9ICh0b3RhbCA+PiAxKSkge1xuICAgICAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcihzZWxlY3RlZCAvIG1heCk7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZiAqIG1heCwgdG86IChvZmYgKyAxKSAqIG1heCB9O1xuICAgIH1cbiAgICBsZXQgb2ZmID0gTWF0aC5mbG9vcigodG90YWwgLSBzZWxlY3RlZCkgLyBtYXgpO1xuICAgIHJldHVybiB7IGZyb206IHRvdGFsIC0gKG9mZiArIDEpICogbWF4LCB0bzogdG90YWwgLSBvZmYgKiBtYXggfTtcbn1cbmNsYXNzIENvbXBsZXRpb25Ub29sdGlwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGF0ZUZpZWxkKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XG4gICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhY2VJbmZvID0ge1xuICAgICAgICAgICAgcmVhZDogKCkgPT4gdGhpcy5tZWFzdXJlSW5mbygpLFxuICAgICAgICAgICAgd3JpdGU6IChwb3MpID0+IHRoaXMucG9zaXRpb25JbmZvKHBvcyksXG4gICAgICAgICAgICBrZXk6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zcGFjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gXCJcIjtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkIH0gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMub3B0aW9uQ29udGVudCA9IG9wdGlvbkNvbnRlbnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25DbGFzcyA9IGNvbmZpZy5vcHRpb25DbGFzcztcbiAgICAgICAgdGhpcy50b29sdGlwQ2xhc3MgPSBjb25maWcudG9vbHRpcENsYXNzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcHRpb25zLmxlbmd0aCwgc2VsZWN0ZWQsIGNvbmZpZy5tYXhSZW5kZXJlZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3Modmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSA9IGUudGFyZ2V0LCBtYXRjaDsgZG9tICYmIGRvbSAhPSB0aGlzLmRvbTsgZG9tID0gZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiTElcIiAmJiAobWF0Y2ggPSAvLShcXGQrKSQvLmV4ZWMoZG9tLmlkKSkgJiYgK21hdGNoWzFdIDwgb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlDb21wbGV0aW9uKHZpZXcsIG9wdGlvbnNbK21hdGNoWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcHRpb25zLCBjU3RhdGUuaWQsIHRoaXMucmFuZ2UpKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW91bnQoKSB7IHRoaXMudXBkYXRlU2VsKCk7IH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCk7XG4gICAgICAgIGxldCBwcmV2U3RhdGUgPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAoY1N0YXRlICE9IHByZXZTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWwoKTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gY1N0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkgIT0gKChfYiA9IHByZXZTdGF0ZS5vcGVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzYWJsZWQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhISgoX2MgPSBjU3RhdGUub3BlbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc2FibGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVG9vbHRpcENsYXNzKHN0YXRlKSB7XG4gICAgICAgIGxldCBjbHMgPSB0aGlzLnRvb2x0aXBDbGFzcyhzdGF0ZSk7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jdXJyZW50Q2xhc3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5jdXJyZW50Q2xhc3Muc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjbHMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xuICAgICAgICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm8pO1xuICAgIH1cbiAgICB1cGRhdGVTZWwoKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKSwgb3BlbiA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBpZiAob3Blbi5zZWxlY3RlZCA+IC0xICYmIG9wZW4uc2VsZWN0ZWQgPCB0aGlzLnJhbmdlLmZyb20gfHwgb3Blbi5zZWxlY3RlZCA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VBcm91bmRTZWxlY3RlZChvcGVuLm9wdGlvbnMubGVuZ3RoLCBvcGVuLnNlbGVjdGVkLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykubWF4UmVuZGVyZWRPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcGVuLm9wdGlvbnMsIGNTdGF0ZS5pZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICAgICAgdGhpcy5saXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZm8pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihvcGVuLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiB9ID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgbGV0IHsgaW5mbyB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaW5mb1Jlc3VsdCA9IHR5cGVvZiBpbmZvID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZm8pIDogaW5mbyhjb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGlmICghaW5mb1Jlc3VsdClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoJ3RoZW4nIGluIGluZm9SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpbmZvUmVzdWx0LnRoZW4obm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQsIGZhbHNlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEluZm9QYW5lKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJjb21wbGV0aW9uIGluZm9cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmZvUGFuZShpbmZvUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRJbmZvUGFuZShjb250ZW50KSB7XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvXCI7XG4gICAgICAgIGRvbS5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXQgPSBvcHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKVxuICAgICAgICAgICAgICAgICAgICBvcHQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0KVxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5saXN0LCBzZXQpO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICBtZWFzdXJlSW5mbygpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbYXJpYS1zZWxlY3RlZF1cIik7XG4gICAgICAgIGlmICghc2VsIHx8ICF0aGlzLmluZm8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxpc3RSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBpbmZvUmVjdCA9IHRoaXMuaW5mby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNlbFJlY3QgPSBzZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzcGFjZSA9IHRoaXMuc3BhY2U7XG4gICAgICAgIGlmICghc3BhY2UpIHtcbiAgICAgICAgICAgIGxldCB3aW4gPSB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICAgICAgICAgIHNwYWNlID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsUmVjdC50b3AgPiBNYXRoLm1pbihzcGFjZS5ib3R0b20sIGxpc3RSZWN0LmJvdHRvbSkgLSAxMCB8fFxuICAgICAgICAgICAgc2VsUmVjdC5ib3R0b20gPCBNYXRoLm1heChzcGFjZS50b3AsIGxpc3RSZWN0LnRvcCkgKyAxMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcnRsID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLlJUTCwgbGVmdCA9IHJ0bCwgbmFycm93ID0gZmFsc2UsIG1heFdpZHRoO1xuICAgICAgICBsZXQgdG9wID0gXCJcIiwgYm90dG9tID0gXCJcIjtcbiAgICAgICAgbGV0IHNwYWNlTGVmdCA9IGxpc3RSZWN0LmxlZnQgLSBzcGFjZS5sZWZ0LCBzcGFjZVJpZ2h0ID0gc3BhY2UucmlnaHQgLSBsaXN0UmVjdC5yaWdodDtcbiAgICAgICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oaW5mb1JlY3Qud2lkdGgsIHNwYWNlUmlnaHQpKVxuICAgICAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICghbGVmdCAmJiBzcGFjZVJpZ2h0IDwgTWF0aC5taW4oaW5mb1JlY3Qud2lkdGgsIHNwYWNlTGVmdCkpXG4gICAgICAgICAgICBsZWZ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluZm9SZWN0LndpZHRoIDw9IChsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkpIHtcbiAgICAgICAgICAgIHRvcCA9IChNYXRoLm1heChzcGFjZS50b3AsIE1hdGgubWluKHNlbFJlY3QudG9wLCBzcGFjZS5ib3R0b20gLSBpbmZvUmVjdC5oZWlnaHQpKSAtIGxpc3RSZWN0LnRvcCkgKyBcInB4XCI7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCBsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYXJyb3cgPSB0cnVlO1xuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1pbig0MDAgLyogSW5mby5XaWR0aCAqLywgKHJ0bCA/IGxpc3RSZWN0LnJpZ2h0IDogc3BhY2UucmlnaHQgLSBsaXN0UmVjdC5sZWZ0KSAtIDMwIC8qIEluZm8uTWFyZ2luICovKSArIFwicHhcIjtcbiAgICAgICAgICAgIGxldCBzcGFjZUJlbG93ID0gc3BhY2UuYm90dG9tIC0gbGlzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgaWYgKHNwYWNlQmVsb3cgPj0gaW5mb1JlY3QuaGVpZ2h0IHx8IHNwYWNlQmVsb3cgPiBsaXN0UmVjdC50b3ApIC8vIEJlbG93IHRoZSBjb21wbGV0aW9uXG4gICAgICAgICAgICAgICAgdG9wID0gKHNlbFJlY3QuYm90dG9tIC0gbGlzdFJlY3QudG9wKSArIFwicHhcIjtcbiAgICAgICAgICAgIGVsc2UgLy8gQWJvdmUgaXRcbiAgICAgICAgICAgICAgICBib3R0b20gPSAobGlzdFJlY3QuYm90dG9tIC0gc2VsUmVjdC50b3ApICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsIGJvdHRvbSwgbWF4V2lkdGgsXG4gICAgICAgICAgICBjbGFzczogbmFycm93ID8gKHJ0bCA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIpIDogbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwb3NpdGlvbkluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUudG9wID0gcG9zLnRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuYm90dG9tID0gcG9zLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUubWF4V2lkdGggPSBwb3MubWF4V2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mbyBjbS1jb21wbGV0aW9uSW5mby1cIiArIHBvcy5jbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS50b3AgPSBcIi0xZTZweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlLmZyb207IGkgPCByYW5nZS50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBjb21wbGV0aW9uLCBtYXRjaCB9ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxpID0gdWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIGxpLmlkID0gaWQgKyBcIi1cIiArIGk7XG4gICAgICAgICAgICBsaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgbGV0IGNscyA9IHRoaXMub3B0aW9uQ2xhc3MoY29tcGxldGlvbik7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSA9IGNscztcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB0aGlzLm9wdGlvbkNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHNvdXJjZShjb21wbGV0aW9uLCB0aGlzLnZpZXcuc3RhdGUsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG59XG4vLyBXZSBhbGxvY2F0ZSBhIG5ldyBmdW5jdGlvbiBpbnN0YW5jZSBldmVyeSB0aW1lIHRoZSBjb21wbGV0aW9uXG4vLyBjaGFuZ2VzIHRvIGZvcmNlIHJlZHJhd2luZy9yZXBvc2l0aW9uaW5nIG9mIHRoZSB0b29sdGlwXG5mdW5jdGlvbiBjb21wbGV0aW9uVG9vbHRpcChzdGF0ZUZpZWxkKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiBuZXcgQ29tcGxldGlvblRvb2x0aXAodmlldywgc3RhdGVGaWVsZCk7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoc2VsZi50b3AgPCBwYXJlbnQudG9wKVxuICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wIC09IHBhcmVudC50b3AgLSBzZWxmLnRvcDtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZi5ib3R0b20gLSBwYXJlbnQuYm90dG9tO1xufVxuXG4vLyBVc2VkIHRvIHBpY2sgYSBwcmVmZXJyZWQgb3B0aW9uIHdoZW4gdHdvIG9wdGlvbnMgd2l0aCB0aGUgc2FtZVxuLy8gbGFiZWwgb2NjdXIgaW4gdGhlIHJlc3VsdC5cbmZ1bmN0aW9uIHNjb3JlKG9wdGlvbikge1xuICAgIHJldHVybiAob3B0aW9uLmJvb3N0IHx8IDApICogMTAwICsgKG9wdGlvbi5hcHBseSA/IDEwIDogMCkgKyAob3B0aW9uLmluZm8gPyA1IDogMCkgK1xuICAgICAgICAob3B0aW9uLnR5cGUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiBzb3J0T3B0aW9ucyhhY3RpdmUsIHN0YXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBbXSwgaSA9IDA7XG4gICAgZm9yIChsZXQgYSBvZiBhY3RpdmUpXG4gICAgICAgIGlmIChhLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICBpZiAoYS5yZXN1bHQuZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGxldCBnZXRNYXRjaCA9IGEucmVzdWx0LmdldE1hdGNoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IFsxZTkgLSBpKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0TWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuIG9mIGdldE1hdGNoKG9wdGlvbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG5ldyBPcHRpb24ob3B0aW9uLCBhLCBtYXRjaCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVyID0gbmV3IEZ1enp5TWF0Y2hlcihzdGF0ZS5zbGljZURvYyhhLmZyb20sIGEudG8pKSwgbWF0Y2g7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9IG1hdGNoZXIubWF0Y2gob3B0aW9uLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5ib29zdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdICs9IG9wdGlvbi5ib29zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChuZXcgT3B0aW9uKG9wdGlvbiwgYSwgbWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBwcmV2ID0gbnVsbDtcbiAgICBsZXQgY29tcGFyZSA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNvbXBhcmVDb21wbGV0aW9ucztcbiAgICBmb3IgKGxldCBvcHQgb2Ygb3B0aW9ucy5zb3J0KChhLCBiKSA9PiAoYi5tYXRjaFswXSAtIGEubWF0Y2hbMF0pIHx8IGNvbXBhcmUoYS5jb21wbGV0aW9uLCBiLmNvbXBsZXRpb24pKSkge1xuICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5sYWJlbCAhPSBvcHQuY29tcGxldGlvbi5sYWJlbCB8fCBwcmV2LmRldGFpbCAhPSBvcHQuY29tcGxldGlvbi5kZXRhaWwgfHxcbiAgICAgICAgICAgIChwcmV2LnR5cGUgIT0gbnVsbCAmJiBvcHQuY29tcGxldGlvbi50eXBlICE9IG51bGwgJiYgcHJldi50eXBlICE9IG9wdC5jb21wbGV0aW9uLnR5cGUpIHx8XG4gICAgICAgICAgICBwcmV2LmFwcGx5ICE9IG9wdC5jb21wbGV0aW9uLmFwcGx5KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0KTtcbiAgICAgICAgZWxzZSBpZiAoc2NvcmUob3B0LmNvbXBsZXRpb24pID4gc2NvcmUocHJldikpXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gb3B0O1xuICAgICAgICBwcmV2ID0gb3B0LmNvbXBsZXRpb247XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBDb21wbGV0aW9uRGlhbG9nIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhdHRycywgdG9vbHRpcCwgdGltZXN0YW1wLCBzZWxlY3RlZCwgZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldFNlbGVjdGVkKHNlbGVjdGVkLCBpZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgPT0gdGhpcy5zZWxlY3RlZCB8fCBzZWxlY3RlZCA+PSB0aGlzLm9wdGlvbnMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCBzZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZChhY3RpdmUsIHN0YXRlLCBpZCwgcHJldiwgY29uZikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBhY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/XG4gICAgICAgICAgICAgICAgbmV3IENvbXBsZXRpb25EaWFsb2cocHJldi5vcHRpb25zLCBwcmV2LmF0dHJzLCBwcmV2LnRvb2x0aXAsIHByZXYudGltZXN0YW1wLCBwcmV2LnNlbGVjdGVkLCB0cnVlKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGVkID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuc2VsZWN0T25PcGVuID8gMCA6IC0xO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2LnNlbGVjdGVkICE9IHNlbGVjdGVkICYmIHByZXYuc2VsZWN0ZWQgIT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZFZhbHVlID0gcHJldi5vcHRpb25zW3ByZXYuc2VsZWN0ZWRdLmNvbXBsZXRpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0uY29tcGxldGlvbiA9PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyhvcHRpb25zLCBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSwge1xuICAgICAgICAgICAgcG9zOiBhY3RpdmUucmVkdWNlKChhLCBiKSA9PiBiLmhhc1Jlc3VsdCgpID8gTWF0aC5taW4oYSwgYi5mcm9tKSA6IGEsIDFlOCksXG4gICAgICAgICAgICBjcmVhdGU6IGNvbXBsZXRpb25Ub29sdGlwKGNvbXBsZXRpb25TdGF0ZSksXG4gICAgICAgICAgICBhYm92ZTogY29uZi5hYm92ZUN1cnNvcixcbiAgICAgICAgfSwgcHJldiA/IHByZXYudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgc2VsZWN0ZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgdGhpcy5hdHRycywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnRvb2x0aXApLCB7IHBvczogY2hhbmdlcy5tYXBQb3ModGhpcy50b29sdGlwLnBvcykgfSksIHRoaXMudGltZXN0YW1wLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG59XG5jbGFzcyBDb21wbGV0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgaWQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25TdGF0ZShub25lLCBcImNtLWFjLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMmU2KS50b1N0cmluZygzNiksIG51bGwpO1xuICAgIH1cbiAgICB1cGRhdGUodHIpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBzb3VyY2VzID0gY29uZi5vdmVycmlkZSB8fFxuICAgICAgICAgICAgc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJhdXRvY29tcGxldGVcIiwgY3VyKHN0YXRlKSkubWFwKGFzU291cmNlKTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmFjdGl2ZS5maW5kKHMgPT4gcy5zb3VyY2UgPT0gc291cmNlKSB8fFxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCB0aGlzLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCA9PSB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgYWN0aXZlLmV2ZXJ5KChhLCBpKSA9PiBhID09IHRoaXMuYWN0aXZlW2ldKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMub3BlbjtcbiAgICAgICAgaWYgKG9wZW4gJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIG9wZW4gPSBvcGVuLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbiB8fCBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoYS5mcm9tLCBhLnRvKSkgfHxcbiAgICAgICAgICAgICFzYW1lUmVzdWx0cyhhY3RpdmUsIHRoaXMuYWN0aXZlKSlcbiAgICAgICAgICAgIG9wZW4gPSBDb21wbGV0aW9uRGlhbG9nLmJ1aWxkKGFjdGl2ZSwgc3RhdGUsIHRoaXMuaWQsIG9wZW4sIGNvbmYpO1xuICAgICAgICBlbHNlIGlmIChvcGVuICYmIG9wZW4uZGlzYWJsZWQgJiYgIWFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pKVxuICAgICAgICAgICAgb3BlbiA9IG51bGw7XG4gICAgICAgIGlmICghb3BlbiAmJiBhY3RpdmUuZXZlcnkoYSA9PiBhLnN0YXRlICE9IDEgLyogU3RhdGUuUGVuZGluZyAqLykgJiYgYWN0aXZlLnNvbWUoYSA9PiBhLmhhc1Jlc3VsdCgpKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IGFjdGl2ZS5tYXAoYSA9PiBhLmhhc1Jlc3VsdCgpID8gbmV3IEFjdGl2ZVNvdXJjZShhLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgOiBhKTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlbGVjdGVkRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBvcGVuID0gb3BlbiAmJiBvcGVuLnNldFNlbGVjdGVkKGVmZmVjdC52YWx1ZSwgdGhpcy5pZCk7XG4gICAgICAgIHJldHVybiBhY3RpdmUgPT0gdGhpcy5hY3RpdmUgJiYgb3BlbiA9PSB0aGlzLm9wZW4gPyB0aGlzIDogbmV3IENvbXBsZXRpb25TdGF0ZShhY3RpdmUsIHRoaXMuaWQsIG9wZW4pO1xuICAgIH1cbiAgICBnZXQgdG9vbHRpcCgpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi50b29sdGlwIDogbnVsbDsgfVxuICAgIGdldCBhdHRycygpIHsgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMub3Blbi5hdHRycyA6IGJhc2VBdHRyczsgfVxufVxuZnVuY3Rpb24gc2FtZVJlc3VsdHMoYSwgYikge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgd2hpbGUgKGlBIDwgYS5sZW5ndGggJiYgIWFbaUFdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlBKys7XG4gICAgICAgIHdoaWxlIChpQiA8IGIubGVuZ3RoICYmICFiW2lCXS5oYXNSZXN1bHQpXG4gICAgICAgICAgICBpQisrO1xuICAgICAgICBsZXQgZW5kQSA9IGlBID09IGEubGVuZ3RoLCBlbmRCID0gaUIgPT0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRBIHx8IGVuZEIpXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xuICAgICAgICBpZiAoYVtpQSsrXS5yZXN1bHQgIT0gYltpQisrXS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgYmFzZUF0dHJzID0ge1xuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCJcbn07XG5mdW5jdGlvbiBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcbiAgICB9O1xuICAgIGlmIChzZWxlY3RlZCA+IC0xKVxuICAgICAgICByZXN1bHRbXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIl0gPSBpZCArIFwiLVwiICsgc2VsZWN0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGdldFVzZXJFdmVudCh0cikge1xuICAgIHJldHVybiB0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgPyBcImlucHV0XCIgOiB0ci5pc1VzZXJFdmVudChcImRlbGV0ZS5iYWNrd2FyZFwiKSA/IFwiZGVsZXRlXCIgOiBudWxsO1xufVxuY2xhc3MgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXRlLCBleHBsaWNpdFBvcyA9IC0xKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXhwbGljaXRQb3MgPSBleHBsaWNpdFBvcztcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB1cGRhdGUodHIsIGNvbmYpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gZ2V0VXNlckV2ZW50KHRyKSwgdmFsdWUgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZVVzZXJFdmVudCh0ciwgZXZlbnQsIGNvbmYpO1xuICAgICAgICBlbHNlIGlmICh0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5oYW5kbGVDaGFuZ2UodHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24gJiYgdmFsdWUuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLylcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZWZmZWN0LnZhbHVlID8gY3VyKHRyLnN0YXRlKSA6IC0xKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhjbG9zZUNvbXBsZXRpb25FZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFjdGl2ZVNvdXJjZSh2YWx1ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGVmZmVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zb3VyY2UgPT0gdmFsdWUuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhY3RpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBoYW5kbGVVc2VyRXZlbnQodHIsIHR5cGUsIGNvbmYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT0gXCJkZWxldGVcIiB8fCAhY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gdGhpcy5tYXAodHIuY2hhbmdlcykgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGN1cih0ci5zdGFydFN0YXRlKSkgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHRoaXMgOiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0aGlzLnN0YXRlLCBjaGFuZ2VzLm1hcFBvcyh0aGlzLmV4cGxpY2l0UG9zKSk7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlUmVzdWx0IGV4dGVuZHMgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGV4cGxpY2l0UG9zLCByZXN1bHQsIGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgMiAvKiBTdGF0ZS5SZXN1bHQgKi8sIGV4cGxpY2l0UG9zKTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBmcm9tID0gdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5mcm9tKSwgdG8gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxKTtcbiAgICAgICAgbGV0IHBvcyA9IGN1cih0ci5zdGF0ZSk7XG4gICAgICAgIGlmICgodGhpcy5leHBsaWNpdFBvcyA8IDAgPyBwb3MgPD0gZnJvbSA6IHBvcyA8IHRoaXMuZnJvbSkgfHxcbiAgICAgICAgICAgIHBvcyA+IHRvIHx8XG4gICAgICAgICAgICB0eXBlID09IFwiZGVsZXRlXCIgJiYgY3VyKHRyLnN0YXJ0U3RhdGUpID09IHRoaXMuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0eXBlID09IFwiaW5wdXRcIiAmJiBjb25mLmFjdGl2YXRlT25UeXBpbmcgPyAxIC8qIFN0YXRlLlBlbmRpbmcgKi8gOiAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgbGV0IGV4cGxpY2l0UG9zID0gdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB1cGRhdGVkO1xuICAgICAgICBpZiAoY2hlY2tWYWxpZCh0aGlzLnJlc3VsdC52YWxpZEZvciwgdHIuc3RhdGUsIGZyb20sIHRvKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCBleHBsaWNpdFBvcywgdGhpcy5yZXN1bHQsIGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0LnVwZGF0ZSAmJlxuICAgICAgICAgICAgKHVwZGF0ZWQgPSB0aGlzLnJlc3VsdC51cGRhdGUodGhpcy5yZXN1bHQsIGZyb20sIHRvLCBuZXcgQ29tcGxldGlvbkNvbnRleHQodHIuc3RhdGUsIHBvcywgZXhwbGljaXRQb3MgPj0gMCkpKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCBleHBsaWNpdFBvcywgdXBkYXRlZCwgdXBkYXRlZC5mcm9tLCAoX2EgPSB1cGRhdGVkLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXIodHIuc3RhdGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLywgZXhwbGljaXRQb3MpO1xuICAgIH1cbiAgICBoYW5kbGVDaGFuZ2UodHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKHRoaXMuZnJvbSwgdGhpcy50bykgPyBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IHRoaXMubWFwKHRyLmNoYW5nZXMpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbWFwcGluZy5lbXB0eSA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IG1hcHBpbmcubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB0aGlzLnJlc3VsdCwgbWFwcGluZy5tYXBQb3ModGhpcy5mcm9tKSwgbWFwcGluZy5tYXBQb3ModGhpcy50bywgMSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWQodmFsaWRGb3IsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIGlmICghdmFsaWRGb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbGlkRm9yID09IFwiZnVuY3Rpb25cIiA/IHZhbGlkRm9yKHRleHQsIGZyb20sIHRvLCBzdGF0ZSkgOiBlbnN1cmVBbmNob3IodmFsaWRGb3IsIHRydWUpLnRlc3QodGV4dCk7XG59XG5jb25zdCBzdGFydENvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjbG9zZUNvbXBsZXRpb25FZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZXRBY3RpdmVFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAoc291cmNlcywgbWFwcGluZykgeyByZXR1cm4gc291cmNlcy5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSk7IH1cbn0pO1xuY29uc3Qgc2V0U2VsZWN0ZWRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBjb21wbGV0aW9uU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIENvbXBsZXRpb25TdGF0ZS5zdGFydCgpOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHsgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0cik7IH0sXG4gICAgcHJvdmlkZTogZiA9PiBbXG4gICAgICAgIHNob3dUb29sdGlwLmZyb20oZiwgdmFsID0+IHZhbC50b29sdGlwKSxcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5mcm9tKGYsIHN0YXRlID0+IHN0YXRlLmF0dHJzKVxuICAgIF1cbn0pO1xuXG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgbW92ZXMgdGhlIGNvbXBsZXRpb24gc2VsZWN0aW9uIGZvcndhcmQgb3JcbmJhY2t3YXJkIGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4qL1xuZnVuY3Rpb24gbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZm9yd2FyZCwgYnkgPSBcIm9wdGlvblwiKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGVwID0gMSwgdG9vbHRpcDtcbiAgICAgICAgaWYgKGJ5ID09IFwicGFnZVwiICYmICh0b29sdGlwID0gZ2V0VG9vbHRpcCh2aWV3LCBjU3RhdGUub3Blbi50b29sdGlwKSkpXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcih0b29sdGlwLmRvbS5vZmZzZXRIZWlnaHQgL1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKS5vZmZzZXRIZWlnaHQpIC0gMSk7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gY1N0YXRlLm9wZW4ub3B0aW9ucztcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPiAtMSA/IGNTdGF0ZS5vcGVuLnNlbGVjdGVkICsgc3RlcCAqIChmb3J3YXJkID8gMSA6IC0xKSA6IGZvcndhcmQgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQgPj0gbGVuZ3RoKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VsZWN0ZWRFZmZlY3Qub2Yoc2VsZWN0ZWQpIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BY2NlcHQgdGhlIGN1cnJlbnQgY29tcGxldGlvbi5cbiovXG5jb25zdCBhY2NlcHRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSB8fCAhY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5zZWxlY3RlZCA8IDAgfHxcbiAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY1N0YXRlLm9wZW4uZGlzYWJsZWQpXG4gICAgICAgIGFwcGx5Q29tcGxldGlvbih2aWV3LCBjU3RhdGUub3Blbi5vcHRpb25zW2NTdGF0ZS5vcGVuLnNlbGVjdGVkXSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FeHBsaWNpdGx5IHN0YXJ0IGF1dG9jb21wbGV0aW9uLlxuKi9cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKHRydWUpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgY29tcGxldGlvbi5cbiovXG5jb25zdCBjbG9zZUNvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jbGFzcyBSdW5uaW5nUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy51cGRhdGVzID0gW107XG4gICAgICAgIC8vIE5vdGUgdGhhdCAndW5kZWZpbmVkJyBtZWFucyAnbm90IGRvbmUgeWV0Jywgd2hlcmVhcyAnbnVsbCcgbWVhbnNcbiAgICAgICAgLy8gJ3F1ZXJ5IHJldHVybmVkIG51bGwnLlxuICAgICAgICB0aGlzLmRvbmUgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY29uc3QgRGVib3VuY2VUaW1lID0gNTAsIE1heFVwZGF0ZUNvdW50ID0gNTAsIE1pbkFib3J0VGltZSA9IDEwMDA7XG5jb25zdCBjb21wbGV0aW9uUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gW107XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGlmICghdXBkYXRlLnNlbGVjdGlvblNldCAmJiAhdXBkYXRlLmRvY0NoYW5nZWQgJiYgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgIWdldFVzZXJFdmVudCh0cik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLnB1c2goLi4udXBkYXRlLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVXBkYXRlKTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovICYmICF0aGlzLnJ1bm5pbmcuc29tZShxID0+IHEuYWN0aXZlLnNvdXJjZSA9PSBhLnNvdXJjZSkpXG4gICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFVwZGF0ZSgpLCBEZWJvdW5jZVRpbWUpIDogLTE7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyAhPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLylcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VXNlckV2ZW50KHRyKSA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb21wb3NpbmcgPT0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBjU3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUociA9PiByLmFjdGl2ZS5zb3VyY2UgPT0gYWN0aXZlLnNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRRdWVyeShhY3RpdmUpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgcG9zID0gY3VyKHN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgQ29tcGxldGlvbkNvbnRleHQoc3RhdGUsIHBvcywgYWN0aXZlLmV4cGxpY2l0UG9zID09IHBvcyk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gbmV3IFJ1bm5pbmdRdWVyeShhY3RpdmUsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcucHVzaChwZW5kaW5nKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGFjdGl2ZS5zb3VyY2UoY29udGV4dCkpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLmRvbmUgPSByZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVBY2NlcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcuZXZlcnkocSA9PiBxLmRvbmUgIT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0IDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWNjZXB0KCksIERlYm91bmNlVGltZSk7XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGZpbmlzaGVkIHF1ZXJ5IGluIHRoaXMucnVubmluZywgdHJ5IHRvIGNyZWF0ZSBhIHJlc3VsdFxuICAgIC8vIG9yLCBpZiBhcHByb3ByaWF0ZSwgcmVzdGFydCB0aGUgcXVlcnkuXG4gICAgYWNjZXB0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0ID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZUFjY2VwdCk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVJlc3VsdChxdWVyeS5hY3RpdmUuc291cmNlLCBxdWVyeS5hY3RpdmUuZXhwbGljaXRQb3MsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKSk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSB0cmFuc2FjdGlvbnMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBhbmQgc2VlIGlmIHRoYXQgcHJlc2VydmVzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gcXVlcnkuYWN0aXZlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSAhPSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyZWQgYnkgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMuIFJlc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0QWN0aXZlRWZmZWN0Lm9mKHVwZGF0ZWQpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGJsdXIoKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuY2xvc2VPbkJsdXIpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbnN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAxIC8qIENvbXBvc2l0aW9uU3RhdGUuU3RhcnRlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPT0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBjb21wb3NpdGlvbmVuZCBldmVudHMgc3luY2hyb25vdXNseSwgcG9zc2libHlcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGluc2lkZSBhbiB1cGRhdGUsIHNvIGRpc3BhdGNoIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZihmYWxzZSkgfSksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWxcIjoge1xuICAgICAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW4gYXV0b1wiLFxuICAgICAgICAgICAgbWF4V2lkdGhfZmFsbGJhY2s6IFwiNzAwcHhcIixcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIm1pbig3MDBweCwgOTV2dylcIixcbiAgICAgICAgICAgIG1pbldpZHRoOiBcIjI1MHB4XCIsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTBlbVwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgXCImID4gbGlcIjoge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IFwiZWxsaXBzaXNcIixcbiAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMTdjXCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3NzdcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMzQ3XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZCB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzQ0NFwiLFxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wOmJlZm9yZSwgLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZUJvdHRvbTphZnRlclwiOiB7XG4gICAgICAgIGNvbnRlbnQ6ICdcIsK3wrfCt1wiJyxcbiAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC5jbS1jb21wbGV0aW9uSW5mb1wiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiM3B4IDlweFwiLFxuICAgICAgICB3aWR0aDogXCJtYXgtY29udGVudFwiLFxuICAgICAgICBtYXhXaWR0aDogYCR7NDAwIC8qIEluZm8uV2lkdGggKi99cHhgLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1sZWZ0XCI6IHsgcmlnaHQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHRcIjogeyBsZWZ0OiBcIjEwMCVcIiB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnQtbmFycm93XCI6IHsgcmlnaHQ6IGAkezMwIC8qIEluZm8uTWFyZ2luICovfXB4YCB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0LW5hcnJvd1wiOiB7IGxlZnQ6IGAkezMwIC8qIEluZm8uTWFyZ2luICovfXB4YCB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zbmlwcGV0RmllbGRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMDAwMDIyXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zbmlwcGV0RmllbGRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmZmZjIyXCIgfSxcbiAgICBcIi5jbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC10b3BcIixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogXCIxLjE1ZW1cIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgbWFyZ2luOiBcIjAgLTAuN3B4IC0uN2VtXCIsXG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS40cHggZG90dGVkICM4ODhcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbk1hdGNoZWRUZXh0XCI6IHtcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25EZXRhaWxcIjoge1xuICAgICAgICBtYXJnaW5MZWZ0OiBcIjAuNWVtXCIsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb25cIjoge1xuICAgICAgICBmb250U2l6ZTogXCI5MCVcIixcbiAgICAgICAgd2lkdGg6IFwiLjhlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHBhZGRpbmdSaWdodDogXCIuNmVtXCIsXG4gICAgICAgIG9wYWNpdHk6IFwiMC42XCIsXG4gICAgICAgIGJveFNpemluZzogXCJjb250ZW50LWJveFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1mdW5jdGlvbiwgLmNtLWNvbXBsZXRpb25JY29uLW1ldGhvZFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ8aSJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNsYXNzXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4peLJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWludGVyZmFjZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXjCdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi12YXJpYWJsZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkaUnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tY29uc3RhbnRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZC2J1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXR5cGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGhJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWVudW1cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifiiKonXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tcHJvcGVydHlcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24ta2V5d29yZFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CflJFcXHVGRTBFJ1wiIH0gLy8gRGlzYWJsZSBlbW9qaSByZW5kZXJpbmdcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLW5hbWVzcGFjZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KWoidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10ZXh0XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInYWJjJ1wiLCBmb250U2l6ZTogXCI1MCVcIiwgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIiB9XG4gICAgfVxufSk7XG5cbmNsYXNzIEZpZWxkUG9zIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgbGluZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuY2xhc3MgRmllbGRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHRoaXMuZnJvbSwgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICBsZXQgdG8gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgcmV0dXJuIGZyb20gPT0gbnVsbCB8fCB0byA9PSBudWxsID8gbnVsbCA6IG5ldyBGaWVsZFJhbmdlKHRoaXMuZmllbGQsIGZyb20sIHRvKTtcbiAgICB9XG59XG5jbGFzcyBTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lcywgZmllbGRQb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmZpZWxkUG9zaXRpb25zID0gZmllbGRQb3NpdGlvbnM7XG4gICAgfVxuICAgIGluc3RhbnRpYXRlKHN0YXRlLCBwb3MpIHtcbiAgICAgICAgbGV0IHRleHQgPSBbXSwgbGluZVN0YXJ0ID0gW3Bvc107XG4gICAgICAgIGxldCBsaW5lT2JqID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiYXNlSW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmVPYmoudGV4dClbMF07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy5saW5lcykge1xuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IGJhc2VJbmRlbnQsIHRhYnMgPSAvXlxcdCovLmV4ZWMobGluZSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFiczsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0LnB1c2gocG9zICsgaW5kZW50Lmxlbmd0aCAtIHRhYnMpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBpbmRlbnQgKyBsaW5lLnNsaWNlKHRhYnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5maWVsZFBvc2l0aW9ucy5tYXAocG9zID0+IG5ldyBGaWVsZFJhbmdlKHBvcy5maWVsZCwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy5mcm9tLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLnRvKSk7XG4gICAgICAgIHJldHVybiB7IHRleHQsIHJhbmdlcyB9O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgbGluZXMgPSBbXSwgcG9zaXRpb25zID0gW10sIG07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGVtcGxhdGUuc3BsaXQoL1xcclxcbj98XFxuLykpIHtcbiAgICAgICAgICAgIHdoaWxlIChtID0gL1sjJF1cXHsoPzooXFxkKykoPzo6KFtefV0qKSk/fChbXn1dKikpXFx9Ly5leGVjKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlcSA9IG1bMV0gPyArbVsxXSA6IG51bGwsIG5hbWUgPSBtWzJdIHx8IG1bM10gfHwgXCJcIiwgZm91bmQgPSAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VxICE9IG51bGwgPyBmaWVsZHNbaV0uc2VxID09IHNlcSA6IG5hbWUgPyBmaWVsZHNbaV0ubmFtZSA9PSBuYW1lIDogZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGZpZWxkcy5sZW5ndGggJiYgKHNlcSA9PSBudWxsIHx8IChmaWVsZHNbaV0uc2VxICE9IG51bGwgJiYgZmllbGRzW2ldLnNlcSA8IHNlcSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc3BsaWNlKGksIDAsIHsgc2VxLCBuYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmZpZWxkID49IGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5maWVsZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChuZXcgRmllbGRQb3MoZm91bmQsIGxpbmVzLmxlbmd0aCwgbS5pbmRleCwgbS5pbmRleCArIG5hbWUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbS5pbmRleCkgKyBuYW1lICsgbGluZS5zbGljZShtLmluZGV4ICsgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZXNjOyBlc2MgPSAvXFxcXChbe31dKS8uZXhlYyhsaW5lKTspIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBlc2MuaW5kZXgpICsgZXNjWzFdICsgbGluZS5zbGljZShlc2MuaW5kZXggKyBlc2NbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmUgPT0gbGluZXMubGVuZ3RoICYmIHBvcy5mcm9tID4gZXNjLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MuZnJvbS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLnRvLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTbmlwcGV0KGxpbmVzLCBwb3NpdGlvbnMpO1xuICAgIH1cbn1cbmxldCBmaWVsZE1hcmtlciA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICB0b0RPTSgpIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9IH0pO1xubGV0IGZpZWxkUmFuZ2UgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc25pcHBldEZpZWxkXCIgfSk7XG5jbGFzcyBBY3RpdmVTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZXMsIGFjdGl2ZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuZGVjbyA9IERlY29yYXRpb24uc2V0KHJhbmdlcy5tYXAociA9PiAoci5mcm9tID09IHIudG8gPyBmaWVsZE1hcmtlciA6IGZpZWxkUmFuZ2UpLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gci5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoIW1hcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTbmlwcGV0KHJhbmdlcywgdGhpcy5hY3RpdmUpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25JbnNpZGVGaWVsZChzZWwpIHtcbiAgICAgICAgcmV0dXJuIHNlbC5yYW5nZXMuZXZlcnkocmFuZ2UgPT4gdGhpcy5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gdGhpcy5hY3RpdmUgJiYgci5mcm9tIDw9IHJhbmdlLmZyb20gJiYgci50byA+PSByYW5nZS50bykpO1xuICAgIH1cbn1cbmNvbnN0IHNldEFjdGl2ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcCh2YWx1ZSwgY2hhbmdlcykgeyByZXR1cm4gdmFsdWUgJiYgdmFsdWUubWFwKGNoYW5nZXMpOyB9XG59KTtcbmNvbnN0IG1vdmVUb0ZpZWxkID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc25pcHBldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhtb3ZlVG9GaWVsZCkgJiYgdmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTbmlwcGV0KHZhbHVlLnJhbmdlcywgZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHIuc2VsZWN0aW9uICYmICF2YWx1ZS5zZWxlY3Rpb25JbnNpZGVGaWVsZCh0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmLCB2YWwgPT4gdmFsID8gdmFsLmRlY28gOiBEZWNvcmF0aW9uLm5vbmUpXG59KTtcbmZ1bmN0aW9uIGZpZWxkU2VsZWN0aW9uKHJhbmdlcywgZmllbGQpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuZmlsdGVyKHIgPT4gci5maWVsZCA9PSBmaWVsZCkubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbn1cbi8qKlxuQ29udmVydCBhIHNuaXBwZXQgdGVtcGxhdGUgdG8gYSBmdW5jdGlvbiB0aGF0IGNhblxuW2FwcGx5XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uLmFwcGx5KSBpdC4gU25pcHBldHMgYXJlIHdyaXR0ZW5cbnVzaW5nIHN5bnRheCBsaWtlIHRoaXM6XG5cbiAgICBcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2VuZH07ICR7aW5kZXh9KyspIHtcXG5cXHQke31cXG59XCJcblxuRWFjaCBgJHt9YCBwbGFjZWhvbGRlciAoeW91IG1heSBhbHNvIHVzZSBgI3t9YCkgaW5kaWNhdGVzIGEgZmllbGRcbnRoYXQgdGhlIHVzZXIgY2FuIGZpbGwgaW4uIEl0cyBuYW1lLCBpZiBhbnksIHdpbGwgYmUgdGhlIGRlZmF1bHRcbmNvbnRlbnQgZm9yIHRoZSBmaWVsZC5cblxuV2hlbiB0aGUgc25pcHBldCBpcyBhY3RpdmF0ZWQgYnkgY2FsbGluZyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24sXG50aGUgY29kZSBpcyBpbnNlcnRlZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIE5ld2xpbmVzIGluIHRoZVxudGVtcGxhdGUgYXJlIGluZGVudGVkIGJ5IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgc3RhcnQgbGluZSwgcGx1c1xub25lIFtpbmRlbnQgdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBwZXIgdGFiIGNoYXJhY3RlciBhZnRlclxudGhlIG5ld2xpbmUuXG5cbk9uIGFjdGl2YXRpb24sIChhbGwgaW5zdGFuY2VzIG9mKSB0aGUgZmlyc3QgZmllbGQgYXJlIHNlbGVjdGVkLlxuVGhlIHVzZXIgY2FuIG1vdmUgYmV0d2VlbiBmaWVsZHMgd2l0aCBUYWIgYW5kIFNoaWZ0LVRhYiBhcyBsb25nIGFzXG50aGUgZmllbGRzIGFyZSBhY3RpdmUuIE1vdmluZyB0byB0aGUgbGFzdCBmaWVsZCBvciBtb3ZpbmcgdGhlXG5jdXJzb3Igb3V0IG9mIHRoZSBjdXJyZW50IGZpZWxkIGRlYWN0aXZhdGVzIHRoZSBmaWVsZHMuXG5cblRoZSBvcmRlciBvZiBmaWVsZHMgZGVmYXVsdHMgdG8gdGV4dHVhbCBvcmRlciwgYnV0IHlvdSBjYW4gYWRkXG5udW1iZXJzIHRvIHBsYWNlaG9sZGVycyAoYCR7MX1gIG9yIGAkezE6ZGVmYXVsdFRleHR9YCkgdG8gcHJvdmlkZVxuYSBjdXN0b20gb3JkZXIuXG5cblRvIGluY2x1ZGUgYSBsaXRlcmFsIGB7YCBvciBgfWAgaW4geW91ciB0ZW1wbGF0ZSwgcHV0IGEgYmFja3NsYXNoXG5pbiBmcm9udCBvZiBpdC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgYW5kIHRoZSBicmFjZSB3aWxsIG5vdCBiZVxuaW50ZXJwcmV0ZWQgYXMgaW5kaWNhdGluZyBhIHBsYWNlaG9sZGVyLlxuKi9cbmZ1bmN0aW9uIHNuaXBwZXQodGVtcGxhdGUpIHtcbiAgICBsZXQgc25pcHBldCA9IFNuaXBwZXQucGFyc2UodGVtcGxhdGUpO1xuICAgIHJldHVybiAoZWRpdG9yLCBfY29tcGxldGlvbiwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgbGV0IHsgdGV4dCwgcmFuZ2VzIH0gPSBzbmlwcGV0Lmluc3RhbnRpYXRlKGVkaXRvci5zdGF0ZSwgZnJvbSk7XG4gICAgICAgIGxldCBzcGVjID0ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKHRleHQpIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMuc2VsZWN0aW9uID0gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCAwKTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCAwKTtcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihhY3RpdmUpXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtzbmlwcGV0U3RhdGUsIGFkZFNuaXBwZXRLZXltYXAsIHNuaXBwZXRQb2ludGVySGFuZGxlciwgYmFzZVRoZW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChlZGl0b3Iuc3RhdGUudXBkYXRlKHNwZWMpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZUZpZWxkKGRpcikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IGRpciA8IDAgJiYgYWN0aXZlLmFjdGl2ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbmV4dCA9IGFjdGl2ZS5hY3RpdmUgKyBkaXIsIGxhc3QgPSBkaXIgPiAwICYmICFhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IG5leHQgKyBkaXIpO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBuZXh0KSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihsYXN0ID8gbnVsbCA6IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG5leHQpKVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkEgY29tbWFuZCB0aGF0IGNsZWFycyB0aGUgYWN0aXZlIHNuaXBwZXQsIGlmIGFueS5cbiovXG5jb25zdCBjbGVhclNuaXBwZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHM6IHNldEFjdGl2ZS5vZihudWxsKSB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRvIHRoZSBuZXh0IHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBuZXh0U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgxKTtcbi8qKlxuTW92ZSB0byB0aGUgcHJldmlvdXMgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHByZXZTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKC0xKTtcbmNvbnN0IGRlZmF1bHRTbmlwcGV0S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIlRhYlwiLCBydW46IG5leHRTbmlwcGV0RmllbGQsIHNoaWZ0OiBwcmV2U25pcHBldEZpZWxkIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xlYXJTbmlwcGV0IH1cbl07XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgdGhlIGtleSBiaW5kaW5ncyB1c2VkIGJ5XG5zbmlwcGV0cy4gVGhlIGRlZmF1bHQgYmluZHMgVGFiIHRvXG5bYG5leHRTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5uZXh0U25pcHBldEZpZWxkKSwgU2hpZnQtVGFiIHRvXG5bYHByZXZTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5wcmV2U25pcHBldEZpZWxkKSwgYW5kIEVzY2FwZVxudG8gW2BjbGVhclNuaXBwZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbGVhclNuaXBwZXQpLlxuKi9cbmNvbnN0IHNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKG1hcHMpIHsgcmV0dXJuIG1hcHMubGVuZ3RoID8gbWFwc1swXSA6IGRlZmF1bHRTbmlwcGV0S2V5bWFwOyB9XG59KTtcbmNvbnN0IGFkZFNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZShbc25pcHBldEtleW1hcF0sIHN0YXRlID0+IHN0YXRlLmZhY2V0KHNuaXBwZXRLZXltYXApKSk7XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gZnJvbSBhIHNuaXBwZXQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlXG5wcm9wZXJ0aWVzIGZyb20gYGNvbXBsZXRpb25gLCBwbHVzIGFuIGBhcHBseWAgZnVuY3Rpb24gdGhhdFxuYXBwbGllcyB0aGUgc25pcHBldC5cbiovXG5mdW5jdGlvbiBzbmlwcGV0Q29tcGxldGlvbih0ZW1wbGF0ZSwgY29tcGxldGlvbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbXBsZXRpb24pLCB7IGFwcGx5OiBzbmlwcGV0KHRlbXBsYXRlKSB9KTtcbn1cbmNvbnN0IHNuaXBwZXRQb2ludGVySGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIG1vdXNlZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAocG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YoYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IG1hdGNoLmZpZWxkKSA/IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gd29yZFJFKHdvcmRDaGFycykge1xuICAgIGxldCBlc2NhcGVkID0gd29yZENoYXJzLnJlcGxhY2UoL1tcXFxcWy4rKj8oKXt8XiRdL2csIFwiXFxcXCQmXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9XyR7ZXNjYXBlZH1dK2AsIFwidWdcIik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcdyR7ZXNjYXBlZH1dYCwgXCJnXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFJFKHJlLCBmKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZihyZS5zb3VyY2UpLCByZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKTtcbn1cbmNvbnN0IHdvcmRDYWNoZXMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHdvcmRDYWNoZSh3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gd29yZENhY2hlc1t3b3JkQ2hhcnNdIHx8ICh3b3JkQ2FjaGVzW3dvcmRDaGFyc10gPSBuZXcgV2Vha01hcCk7XG59XG5mdW5jdGlvbiBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KSB7XG4gICAgZm9yIChsZXQgbGluZXMgPSBkb2MuaXRlckxpbmVzKCksIHBvcyA9IDA7ICFsaW5lcy5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IGxpbmVzLCBtO1xuICAgICAgICB3b3JkUkUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKG0gPSB3b3JkUkUuZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghc2VlblttWzBdXSAmJiBwb3MgKyBtLmluZGV4ICE9IGlnbm9yZUF0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyB0eXBlOiBcInRleHRcIiwgbGFiZWw6IG1bMF0gfSk7XG4gICAgICAgICAgICAgICAgc2VlblttWzBdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPj0gMjAwMCAvKiBDLk1heExpc3QgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdmFsdWUubGVuZ3RoICsgMTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0V29yZHMoZG9jLCBjYWNoZSwgd29yZFJFLCB0bywgaWdub3JlQXQpIHtcbiAgICBsZXQgYmlnID0gZG9jLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi87XG4gICAgbGV0IGNhY2hlZCA9IGJpZyAmJiBjYWNoZS5nZXQoZG9jKTtcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIGxldCByZXN1bHQgPSBbXSwgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGRvYy5jaGlsZHJlbikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgZG9jLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2gubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY29sbGVjdFdvcmRzKGNoLCBjYWNoZSwgd29yZFJFLCB0byAtIHBvcywgaWdub3JlQXQgLSBwb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VlbltjLmxhYmVsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltjLmxhYmVsXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlV29yZHMoY2gsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCAtIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gY2gubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCk7XG4gICAgfVxuICAgIGlmIChiaWcgJiYgcmVzdWx0Lmxlbmd0aCA8IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICBjYWNoZS5zZXQoZG9jLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkEgY29tcGxldGlvbiBzb3VyY2UgdGhhdCB3aWxsIHNjYW4gdGhlIGRvY3VtZW50IGZvciB3b3JkcyAodXNpbmcgYVxuW2NoYXJhY3RlciBjYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpKSwgYW5kXG5yZXR1cm4gdGhvc2UgYXMgY29tcGxldGlvbnMuXG4qL1xuY29uc3QgY29tcGxldGVBbnlXb3JkID0gY29udGV4dCA9PiB7XG4gICAgbGV0IHdvcmRDaGFycyA9IGNvbnRleHQuc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgY29udGV4dC5wb3MpLmpvaW4oXCJcIik7XG4gICAgbGV0IHJlID0gd29yZFJFKHdvcmRDaGFycyk7XG4gICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXBSRShyZSwgcyA9PiBzICsgXCIkXCIpKTtcbiAgICBpZiAoIXRva2VuICYmICFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZnJvbSA9IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zO1xuICAgIGxldCBvcHRpb25zID0gY29sbGVjdFdvcmRzKGNvbnRleHQuc3RhdGUuZG9jLCB3b3JkQ2FjaGUod29yZENoYXJzKSwgcmUsIDUwMDAwIC8qIEMuUmFuZ2UgKi8sIGZyb20pO1xuICAgIHJldHVybiB7IGZyb20sIG9wdGlvbnMsIHZhbGlkRm9yOiBtYXBSRShyZSwgcyA9PiBcIl5cIiArIHMpIH07XG59O1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBicmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInXSxcbiAgICBiZWZvcmU6IFwiKV19Ojs+XCIsXG4gICAgc3RyaW5nUHJlZml4ZXM6IFtdXG59O1xuY29uc3QgY2xvc2VCcmFja2V0RWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSBtYXBwaW5nLm1hcFBvcyh2YWx1ZSwgLTEsIE1hcE1vZGUuVHJhY2tBZnRlcik7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG1hcHBlZDtcbiAgICB9XG59KTtcbmNvbnN0IHNraXBCcmFja2V0RWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBtYXBwaW5nKSB7IHJldHVybiBtYXBwaW5nLm1hcFBvcyh2YWx1ZSk7IH1cbn0pO1xuY29uc3QgY2xvc2VkQnJhY2tldCA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbn07XG5jbG9zZWRCcmFja2V0LnN0YXJ0U2lkZSA9IDE7XG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcbmNvbnN0IGJyYWNrZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgbGluZVN0YXJ0ID0gdHIuc3RhdGUuZG9jLmxpbmVBdCh0ci5zZWxlY3Rpb24ubWFpbi5oZWFkKS5mcm9tO1xuICAgICAgICAgICAgbGV0IHByZXZMaW5lU3RhcnQgPSB0ci5zdGFydFN0YXRlLmRvYy5saW5lQXQodHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxpbmVTdGFydCAhPSB0ci5jaGFuZ2VzLm1hcFBvcyhwcmV2TGluZVN0YXJ0LCAtMSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBSYW5nZVNldC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VCcmFja2V0RWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGFkZDogW2Nsb3NlZEJyYWNrZXQucmFuZ2UoZWZmZWN0LnZhbHVlLCBlZmZlY3QudmFsdWUgKyAxKV0gfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2tpcEJyYWNrZXRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgZmlsdGVyOiBmcm9tID0+IGZyb20gIT0gZWZmZWN0LnZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59KTtcbi8qKlxuRXh0ZW5zaW9uIHRvIGVuYWJsZSBicmFja2V0LWNsb3NpbmcgYmVoYXZpb3IuIFdoZW4gYSBjbG9zZWFibGVcbmJyYWNrZXQgaXMgdHlwZWQsIGl0cyBjbG9zaW5nIGJyYWNrZXQgaXMgaW1tZWRpYXRlbHkgaW5zZXJ0ZWRcbmFmdGVyIHRoZSBjdXJzb3IuIFdoZW4gY2xvc2luZyBhIGJyYWNrZXQgZGlyZWN0bHkgaW4gZnJvbnQgb2YgYVxuY2xvc2luZyBicmFja2V0IGluc2VydGVkIGJ5IHRoZSBleHRlbnNpb24sIHRoZSBjdXJzb3IgbW92ZXMgb3ZlclxudGhhdCBicmFja2V0LlxuKi9cbmZ1bmN0aW9uIGNsb3NlQnJhY2tldHMoKSB7XG4gICAgcmV0dXJuIFtpbnB1dEhhbmRsZXIsIGJyYWNrZXRTdGF0ZV07XG59XG5jb25zdCBkZWZpbmVkQ2xvc2luZyA9IFwiKClbXXt9PD5cIjtcbmZ1bmN0aW9uIGNsb3NpbmcoY2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluZWRDbG9zaW5nLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZGVmaW5lZENsb3NpbmcuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgIHJldHVybiBkZWZpbmVkQ2xvc2luZy5jaGFyQXQoaSArIDEpO1xuICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNoIDwgMTI4ID8gY2ggOiBjaCArIDEpO1xufVxuZnVuY3Rpb24gY29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICByZXR1cm4gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjbG9zZUJyYWNrZXRzXCIsIHBvcylbMF0gfHwgZGVmYXVsdHM7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIGluc2VydCkgPT4ge1xuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoaW5zZXJ0Lmxlbmd0aCA+IDIgfHwgaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQoaW5zZXJ0LCAwKSkgPT0gMSB8fFxuICAgICAgICBmcm9tICE9IHNlbC5mcm9tIHx8IHRvICE9IHNlbC50bylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ciA9IGluc2VydEJyYWNrZXQodmlldy5zdGF0ZSwgaW5zZXJ0KTtcbiAgICBpZiAoIXRyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IGltcGxlbWVudHMgZGVsZXRpbmcgYSBwYWlyIG9mIG1hdGNoaW5nIGJyYWNrZXRzIHdoZW5cbnRoZSBjdXJzb3IgaXMgYmV0d2VlbiB0aGVtLlxuKi9cbmNvbnN0IGRlbGV0ZUJyYWNrZXRQYWlyID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHRva2VucyA9IGNvbmYuYnJhY2tldHMgfHwgZGVmYXVsdHMuYnJhY2tldHM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHByZXZDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2tlbiwgMCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmhlYWQgLSB0b2tlbi5sZW5ndGgsIHRvOiByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoIWRvbnQpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmJhY2t3YXJkXCIgfSkpO1xuICAgIHJldHVybiAhZG9udDtcbn07XG4vKipcbkNsb3NlLWJyYWNrZXRzIHJlbGF0ZWQga2V5IGJpbmRpbmdzLiBCaW5kcyBCYWNrc3BhY2UgdG9cbltgZGVsZXRlQnJhY2tldFBhaXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5kZWxldGVCcmFja2V0UGFpcikuXG4qL1xuY29uc3QgY2xvc2VCcmFja2V0c0tleW1hcCA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVCcmFja2V0UGFpciB9XG5dO1xuLyoqXG5JbXBsZW1lbnRzIHRoZSBleHRlbnNpb24ncyBiZWhhdmlvciBvbiB0ZXh0IGluc2VydGlvbi4gSWYgdGhlXG5naXZlbiBzdHJpbmcgY291bnRzIGFzIGEgYnJhY2tldCBpbiB0aGUgbGFuZ3VhZ2UgYXJvdW5kIHRoZVxuc2VsZWN0aW9uLCBhbmQgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBpdCByZXF1aXJlcyBjdXN0b21cbmJlaGF2aW9yIChpbnNlcnRpbmcgYSBjbG9zaW5nIHZlcnNpb24gb3Igc2tpcHBpbmcgcGFzdCBhXG5wcmV2aW91c2x5LWNsb3NlZCBicmFja2V0KSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudGluZyB0aGF0IGN1c3RvbSBiZWhhdmlvci4gKFlvdSBvbmx5IG5lZWQgdGhpcyBpZiB5b3Ugd2FudFxudG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYnJhY2tldHPigJR0aGVcbltgY2xvc2VCcmFja2V0c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpIGV4dGVuc2lvbiB3aWxsXG50YWtlIGNhcmUgb2YgcnVubmluZyB0aGlzIGZvciB1c2VyIGlucHV0LilcbiovXG5mdW5jdGlvbiBpbnNlcnRCcmFja2V0KHN0YXRlLCBicmFja2V0KSB7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGZvciAobGV0IHRvayBvZiB0b2tlbnMpIHtcbiAgICAgICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcoY29kZVBvaW50QXQodG9rLCAwKSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IHRvaylcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSwgdG9rLCB0b2tlbnMuaW5kZXhPZih0b2sgKyB0b2sgKyB0b2spID4gLTEsIGNvbmYpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVPcGVuKHN0YXRlLCB0b2ssIGNsb3NlZCwgY29uZi5iZWZvcmUgfHwgZGVmYXVsdHMuYmVmb3JlKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gY2xvc2VkICYmIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xvc2Uoc3RhdGUsIHRvaywgY2xvc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIHN0YXRlLmZpZWxkKGJyYWNrZXRTdGF0ZSkuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCBmcm9tID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT0gcG9zKVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG5leHRDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IG5leHQgPSBkb2Muc2xpY2VTdHJpbmcocG9zLCBwb3MgKyAyKTtcbiAgICByZXR1cm4gbmV4dC5zbGljZSgwLCBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KG5leHQsIDApKSk7XG59XG5mdW5jdGlvbiBwcmV2Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBwcmV2ID0gZG9jLnNsaWNlU3RyaW5nKHBvcyAtIDIsIHBvcyk7XG4gICAgcmV0dXJuIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQocHJldiwgMCkpID09IHByZXYubGVuZ3RoID8gcHJldiA6IHByZXYuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcGVuKHN0YXRlLCBvcGVuLCBjbG9zZSwgY2xvc2VCZWZvcmUpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogb3BlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogY2xvc2UsIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIG9wZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IC9cXHMvLnRlc3QobmV4dCkgfHwgY2xvc2VCZWZvcmUuaW5kZXhPZihuZXh0KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IG9wZW4gKyBjbG9zZSwgZnJvbTogcmFuZ2UuaGVhZCB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbG9zZShzdGF0ZSwgX29wZW4sIGNsb3NlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBtb3ZlZCA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5ICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRvbnQgPSByYW5nZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUobW92ZWQsIHN0YXRlLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgZWZmZWN0czogc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAoKHsgZnJvbSB9KSA9PiBza2lwQnJhY2tldEVmZmVjdC5vZihmcm9tKSlcbiAgICB9KTtcbn1cbi8vIEhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIG9wZW4gYW5kIGNsb3NlIHRva2VuIGFyZSB0aGUgc2FtZSwgYW5kXG4vLyBwb3NzaWJseSB0cmlwbGUgcXVvdGVzIChhcyBpbiBgXCJcIlwiYWJjXCJcIlwiYC1zdHlsZSBxdW90aW5nKS5cbmZ1bmN0aW9uIGhhbmRsZVNhbWUoc3RhdGUsIHRva2VuLCBhbGxvd1RyaXBsZSwgY29uZmlnKSB7XG4gICAgbGV0IHN0cmluZ1ByZWZpeGVzID0gY29uZmlnLnN0cmluZ1ByZWZpeGVzIHx8IGRlZmF1bHRzLnN0cmluZ1ByZWZpeGVzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW3sgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyB0b2tlbi5sZW5ndGgsIHJhbmdlLmhlYWQgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCBwb3MpLCBzdGFydDtcbiAgICAgICAgaWYgKG5leHQgPT0gdG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlU3RhcnQoc3RhdGUsIHBvcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNUcmlwbGUgPSBhbGxvd1RyaXBsZSAmJiBzdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIHRva2VuLmxlbmd0aCAqIDMpID09IHRva2VuICsgdG9rZW4gKyB0b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGggKiAoaXNUcmlwbGUgPyAzIDogMSkpLFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBza2lwQnJhY2tldEVmZmVjdC5vZihwb3MpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXG4gICAgICAgICAgICAoc3RhcnQgPSBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBzdHJpbmdQcmVmaXhlcykpID4gLTEgJiZcbiAgICAgICAgICAgIG5vZGVTdGFydChzdGF0ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKShuZXh0KSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgc3RyaW5nUHJlZml4ZXMpID4gLTEgJiYgIXByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgdG9rZW4sIHN0cmluZ1ByZWZpeGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlU3RhcnQoc3RhdGUsIHBvcykge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xuICAgIGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBtYXhQcmVmaXggPSBwcmVmaXhlcy5yZWR1Y2UoKG0sIHApID0+IE1hdGgubWF4KG0sIHAubGVuZ3RoKSwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBNYXRoLm1pbihub2RlLnRvLCBub2RlLmZyb20gKyBxdW90ZVRva2VuLmxlbmd0aCArIG1heFByZWZpeCkpO1xuICAgICAgICBsZXQgcXVvdGVQb3MgPSBzdGFydC5pbmRleE9mKHF1b3RlVG9rZW4pO1xuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC5mcm9tID09IG5vZGUuZnJvbSAmJiBmaXJzdC50byAtIGZpcnN0LmZyb20gPiBxdW90ZVRva2VuLmxlbmd0aCArIHF1b3RlUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNoYXJDYXQgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBpZiAoY2hhckNhdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBmb3IgKGxldCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBwb3MpID09IHByZWZpeCAmJiBjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHN0YXJ0IC0gMSwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhdXRvY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBhdXRvY29tcGxldGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcbiAgICAgICAgY29tcGxldGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjb21wbGV0aW9uUGx1Z2luLFxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xufVxuLyoqXG5CYXNpYyBrZXliaW5kaW5ncyBmb3IgYXV0b2NvbXBsZXRpb24uXG5cbiAtIEN0cmwtU3BhY2U6IFtgc3RhcnRDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuc3RhcnRDb21wbGV0aW9uKVxuIC0gRXNjYXBlOiBbYGNsb3NlQ29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQ29tcGxldGlvbilcbiAtIEFycm93RG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSlgXG4gLSBBcnJvd1VwOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYChmYWxzZSlgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gUGFnZURvd246IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKHRydWUsIFwicGFnZVwiKWBcbiAtIEVudGVyOiBbYGFjY2VwdENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hY2NlcHRDb21wbGV0aW9uKVxuKi9cbmNvbnN0IGNvbXBsZXRpb25LZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TcGFjZVwiLCBydW46IHN0YXJ0Q29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsb3NlQ29tcGxldGlvbiB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlKSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UpIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGFjY2VwdENvbXBsZXRpb24gfVxuXTtcbmNvbnN0IGNvbXBsZXRpb25LZXltYXBFeHQgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZU4oW2NvbXBsZXRpb25Db25maWddLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5kZWZhdWx0S2V5bWFwID8gW2NvbXBsZXRpb25LZXltYXBdIDogW10pKTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IGNvbXBsZXRpb24gc3RhdHVzLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBhdmFpbGFibGUsXG50aGlzIHdpbGwgcmV0dXJuIGBcImFjdGl2ZVwiYC4gV2hlbiBjb21wbGV0aW9ucyBhcmUgcGVuZGluZyAoaW4gdGhlXG5wcm9jZXNzIG9mIGJlaW5nIHF1ZXJpZWQpLCB0aGlzIHJldHVybnMgYFwicGVuZGluZ1wiYC4gT3RoZXJ3aXNlLCBpdFxucmV0dXJucyBgbnVsbGAuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblN0YXR1cyhzdGF0ZSkge1xuICAgIGxldCBjU3RhdGUgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgPT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSA/IFwicGVuZGluZ1wiXG4gICAgICAgIDogY1N0YXRlICYmIGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuc3RhdGUgIT0gMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLykgPyBcImFjdGl2ZVwiIDogbnVsbDtcbn1cbmNvbnN0IGNvbXBsZXRpb25BcnJheUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwO1xuLyoqXG5SZXR1cm5zIHRoZSBhdmFpbGFibGUgY29tcGxldGlvbnMgYXMgYW4gYXJyYXkuXG4qL1xuZnVuY3Rpb24gY3VycmVudENvbXBsZXRpb25zKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIGlmICghb3BlbiB8fCBvcGVuLmRpc2FibGVkKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGNvbXBsZXRpb25zID0gY29tcGxldGlvbkFycmF5Q2FjaGUuZ2V0KG9wZW4ub3B0aW9ucyk7XG4gICAgaWYgKCFjb21wbGV0aW9ucylcbiAgICAgICAgY29tcGxldGlvbkFycmF5Q2FjaGUuc2V0KG9wZW4ub3B0aW9ucywgY29tcGxldGlvbnMgPSBvcGVuLm9wdGlvbnMubWFwKG8gPT4gby5jb21wbGV0aW9uKSk7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuLyoqXG5SZXR1cm4gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4ub3B0aW9uc1tvcGVuLnNlbGVjdGVkXS5jb21wbGV0aW9uIDogbnVsbDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBvc2l0aW9uIGluIHRoZSBhY3RpdmUgY29tcGxldGlvblxubGlzdCwgb3IgbnVsbCBpZiBubyBjb21wbGV0aW9ucyBhcmUgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4KHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBvcGVuID0gKF9hID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcGVuO1xuICAgIHJldHVybiBvcGVuICYmICFvcGVuLmRpc2FibGVkICYmIG9wZW4uc2VsZWN0ZWQgPj0gMCA/IG9wZW4uc2VsZWN0ZWQgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYW4gZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gY2hhbmdlXG50aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24uXG4qL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRDb21wbGV0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHNldFNlbGVjdGVkRWZmZWN0Lm9mKGluZGV4KTtcbn1cblxuZXhwb3J0IHsgQ29tcGxldGlvbkNvbnRleHQsIGFjY2VwdENvbXBsZXRpb24sIGF1dG9jb21wbGV0aW9uLCBjbGVhclNuaXBwZXQsIGNsb3NlQnJhY2tldHMsIGNsb3NlQnJhY2tldHNLZXltYXAsIGNsb3NlQ29tcGxldGlvbiwgY29tcGxldGVBbnlXb3JkLCBjb21wbGV0ZUZyb21MaXN0LCBjb21wbGV0aW9uS2V5bWFwLCBjb21wbGV0aW9uU3RhdHVzLCBjdXJyZW50Q29tcGxldGlvbnMsIGRlbGV0ZUJyYWNrZXRQYWlyLCBpZkluLCBpZk5vdEluLCBpbnNlcnRCcmFja2V0LCBpbnNlcnRDb21wbGV0aW9uVGV4dCwgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24sIG5leHRTbmlwcGV0RmllbGQsIHBpY2tlZENvbXBsZXRpb24sIHByZXZTbmlwcGV0RmllbGQsIHNlbGVjdGVkQ29tcGxldGlvbiwgc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgsIHNldFNlbGVjdGVkQ29tcGxldGlvbiwgc25pcHBldCwgc25pcHBldENvbXBsZXRpb24sIHNuaXBwZXRLZXltYXAsIHN0YXJ0Q29tcGxldGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"blockComment\": () => (/* binding */ blockComment),\n/* harmony export */   \"blockUncomment\": () => (/* binding */ blockUncomment),\n/* harmony export */   \"copyLineDown\": () => (/* binding */ copyLineDown),\n/* harmony export */   \"copyLineUp\": () => (/* binding */ copyLineUp),\n/* harmony export */   \"cursorCharBackward\": () => (/* binding */ cursorCharBackward),\n/* harmony export */   \"cursorCharForward\": () => (/* binding */ cursorCharForward),\n/* harmony export */   \"cursorCharLeft\": () => (/* binding */ cursorCharLeft),\n/* harmony export */   \"cursorCharRight\": () => (/* binding */ cursorCharRight),\n/* harmony export */   \"cursorDocEnd\": () => (/* binding */ cursorDocEnd),\n/* harmony export */   \"cursorDocStart\": () => (/* binding */ cursorDocStart),\n/* harmony export */   \"cursorGroupBackward\": () => (/* binding */ cursorGroupBackward),\n/* harmony export */   \"cursorGroupForward\": () => (/* binding */ cursorGroupForward),\n/* harmony export */   \"cursorGroupLeft\": () => (/* binding */ cursorGroupLeft),\n/* harmony export */   \"cursorGroupRight\": () => (/* binding */ cursorGroupRight),\n/* harmony export */   \"cursorLineBoundaryBackward\": () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   \"cursorLineBoundaryForward\": () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   \"cursorLineBoundaryLeft\": () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   \"cursorLineBoundaryRight\": () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   \"cursorLineDown\": () => (/* binding */ cursorLineDown),\n/* harmony export */   \"cursorLineEnd\": () => (/* binding */ cursorLineEnd),\n/* harmony export */   \"cursorLineStart\": () => (/* binding */ cursorLineStart),\n/* harmony export */   \"cursorLineUp\": () => (/* binding */ cursorLineUp),\n/* harmony export */   \"cursorMatchingBracket\": () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   \"cursorPageDown\": () => (/* binding */ cursorPageDown),\n/* harmony export */   \"cursorPageUp\": () => (/* binding */ cursorPageUp),\n/* harmony export */   \"cursorSubwordBackward\": () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   \"cursorSubwordForward\": () => (/* binding */ cursorSubwordForward),\n/* harmony export */   \"cursorSyntaxLeft\": () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   \"cursorSyntaxRight\": () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   \"defaultKeymap\": () => (/* binding */ defaultKeymap),\n/* harmony export */   \"deleteCharBackward\": () => (/* binding */ deleteCharBackward),\n/* harmony export */   \"deleteCharForward\": () => (/* binding */ deleteCharForward),\n/* harmony export */   \"deleteGroupBackward\": () => (/* binding */ deleteGroupBackward),\n/* harmony export */   \"deleteGroupForward\": () => (/* binding */ deleteGroupForward),\n/* harmony export */   \"deleteLine\": () => (/* binding */ deleteLine),\n/* harmony export */   \"deleteToLineEnd\": () => (/* binding */ deleteToLineEnd),\n/* harmony export */   \"deleteToLineStart\": () => (/* binding */ deleteToLineStart),\n/* harmony export */   \"deleteTrailingWhitespace\": () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   \"emacsStyleKeymap\": () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   \"history\": () => (/* binding */ history),\n/* harmony export */   \"historyField\": () => (/* binding */ historyField),\n/* harmony export */   \"historyKeymap\": () => (/* binding */ historyKeymap),\n/* harmony export */   \"indentLess\": () => (/* binding */ indentLess),\n/* harmony export */   \"indentMore\": () => (/* binding */ indentMore),\n/* harmony export */   \"indentSelection\": () => (/* binding */ indentSelection),\n/* harmony export */   \"indentWithTab\": () => (/* binding */ indentWithTab),\n/* harmony export */   \"insertBlankLine\": () => (/* binding */ insertBlankLine),\n/* harmony export */   \"insertNewline\": () => (/* binding */ insertNewline),\n/* harmony export */   \"insertNewlineAndIndent\": () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   \"insertTab\": () => (/* binding */ insertTab),\n/* harmony export */   \"invertedEffects\": () => (/* binding */ invertedEffects),\n/* harmony export */   \"isolateHistory\": () => (/* binding */ isolateHistory),\n/* harmony export */   \"lineComment\": () => (/* binding */ lineComment),\n/* harmony export */   \"lineUncomment\": () => (/* binding */ lineUncomment),\n/* harmony export */   \"moveLineDown\": () => (/* binding */ moveLineDown),\n/* harmony export */   \"moveLineUp\": () => (/* binding */ moveLineUp),\n/* harmony export */   \"redo\": () => (/* binding */ redo),\n/* harmony export */   \"redoDepth\": () => (/* binding */ redoDepth),\n/* harmony export */   \"redoSelection\": () => (/* binding */ redoSelection),\n/* harmony export */   \"selectAll\": () => (/* binding */ selectAll),\n/* harmony export */   \"selectCharBackward\": () => (/* binding */ selectCharBackward),\n/* harmony export */   \"selectCharForward\": () => (/* binding */ selectCharForward),\n/* harmony export */   \"selectCharLeft\": () => (/* binding */ selectCharLeft),\n/* harmony export */   \"selectCharRight\": () => (/* binding */ selectCharRight),\n/* harmony export */   \"selectDocEnd\": () => (/* binding */ selectDocEnd),\n/* harmony export */   \"selectDocStart\": () => (/* binding */ selectDocStart),\n/* harmony export */   \"selectGroupBackward\": () => (/* binding */ selectGroupBackward),\n/* harmony export */   \"selectGroupForward\": () => (/* binding */ selectGroupForward),\n/* harmony export */   \"selectGroupLeft\": () => (/* binding */ selectGroupLeft),\n/* harmony export */   \"selectGroupRight\": () => (/* binding */ selectGroupRight),\n/* harmony export */   \"selectLine\": () => (/* binding */ selectLine),\n/* harmony export */   \"selectLineBoundaryBackward\": () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   \"selectLineBoundaryForward\": () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   \"selectLineBoundaryLeft\": () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   \"selectLineBoundaryRight\": () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   \"selectLineDown\": () => (/* binding */ selectLineDown),\n/* harmony export */   \"selectLineEnd\": () => (/* binding */ selectLineEnd),\n/* harmony export */   \"selectLineStart\": () => (/* binding */ selectLineStart),\n/* harmony export */   \"selectLineUp\": () => (/* binding */ selectLineUp),\n/* harmony export */   \"selectMatchingBracket\": () => (/* binding */ selectMatchingBracket),\n/* harmony export */   \"selectPageDown\": () => (/* binding */ selectPageDown),\n/* harmony export */   \"selectPageUp\": () => (/* binding */ selectPageUp),\n/* harmony export */   \"selectParentSyntax\": () => (/* binding */ selectParentSyntax),\n/* harmony export */   \"selectSubwordBackward\": () => (/* binding */ selectSubwordBackward),\n/* harmony export */   \"selectSubwordForward\": () => (/* binding */ selectSubwordForward),\n/* harmony export */   \"selectSyntaxLeft\": () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   \"selectSyntaxRight\": () => (/* binding */ selectSyntaxRight),\n/* harmony export */   \"simplifySelection\": () => (/* binding */ simplifySelection),\n/* harmony export */   \"splitLine\": () => (/* binding */ splitLine),\n/* harmony export */   \"standardKeymap\": () => (/* binding */ standardKeymap),\n/* harmony export */   \"toggleBlockComment\": () => (/* binding */ toggleBlockComment),\n/* harmony export */   \"toggleBlockCommentByLine\": () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   \"toggleComment\": () => (/* binding */ toggleComment),\n/* harmony export */   \"toggleLineComment\": () => (/* binding */ toggleLineComment),\n/* harmony export */   \"transposeChars\": () => (/* binding */ transposeChars),\n/* harmony export */   \"undo\": () => (/* binding */ undo),\n/* harmony export */   \"undoDepth\": () => (/* binding */ undoDepth),\n/* harmony export */   \"undoSelection\": () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n  let config = getConfig(target.state);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n  return ({\n    state,\n    dispatch\n  }) => {\n    if (state.readOnly) return false;\n    let tr = f(option, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);\nfunction getConfig(state, pos = state.selection.main.head) {\n  let data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, {\n  open,\n  close\n}, from, to) {\n  let textBefore = state.sliceDoc(from - SearchMargin, from);\n  let textAfter = state.sliceDoc(to, to + SearchMargin);\n  let spaceBefore = /\\s*$/.exec(textBefore)[0].length,\n    spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n  let beforeOff = textBefore.length - spaceBefore;\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n  let startText, endText;\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n  let startSpace = /^\\s*/.exec(startText)[0].length,\n    endSpace = /\\s*$/.exec(endText)[0].length;\n  let endOff = endText.length - endSpace - close.length;\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n  return null;\n}\nfunction selectedLineRanges(state) {\n  let ranges = [];\n  for (let r of state.selection.ranges) {\n    let fromLine = state.doc.lineAt(r.from);\n    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;else ranges.push({\n      from: fromLine.from,\n      to: toLine.to\n    });\n  }\n  return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n  let tokens = ranges.map(r => getConfig(state, r.from).block);\n  if (!tokens.every(c => c)) return null;\n  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n  if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {\n    return {\n      changes: state.changes(ranges.map((range, i) => {\n        if (comments[i]) return [];\n        return [{\n          from: range.from,\n          insert: tokens[i].open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + tokens[i].close\n        }];\n      }))\n    };\n  } else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {\n    let changes = [];\n    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {\n      let token = tokens[i],\n        {\n          open,\n          close\n        } = comment;\n      changes.push({\n        from: open.pos - token.open.length,\n        to: open.pos + open.margin\n      }, {\n        from: close.pos - close.margin,\n        to: close.pos + token.close.length\n      });\n    }\n    return {\n      changes\n    };\n  }\n  return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n  let lines = [];\n  let prevLine = -1;\n  for (let {\n    from,\n    to\n  } of ranges) {\n    let startI = lines.length,\n      minIndent = 1e9;\n    for (let pos = from; pos <= to;) {\n      let line = state.doc.lineAt(pos);\n      if (line.from > prevLine && (from == to || to > line.from)) {\n        prevLine = line.from;\n        let token = getConfig(state, pos).line;\n        if (!token) continue;\n        let indent = /^\\s*/.exec(line.text)[0].length;\n        let empty = indent == line.length;\n        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n        if (indent < line.text.length && indent < minIndent) minIndent = indent;\n        lines.push({\n          line,\n          comment,\n          token,\n          indent,\n          empty,\n          single: false\n        });\n      }\n      pos = line.to + 1;\n    }\n    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n    if (lines.length == startI + 1) lines[startI].single = true;\n  }\n  if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n    let changes = [];\n    for (let {\n      line,\n      token,\n      indent,\n      empty,\n      single\n    } of lines) if (single || !empty) changes.push({\n      from: line.from + indent,\n      insert: token + \" \"\n    });\n    let changeSet = state.changes(changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  } else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {\n    let changes = [];\n    for (let {\n      line,\n      comment,\n      token\n    } of lines) if (comment >= 0) {\n      let from = line.from + comment,\n        to = from + token.length;\n      if (line.text[to - line.from] == \" \") to++;\n      changes.push({\n        from,\n        to\n      });\n    }\n    return {\n      changes\n    };\n  }\n  return null;\n}\nconst fromHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n      minDepth: 100,\n      newGroupDelay: 500,\n      joinToEvent: (_t, isAdjacent) => isAdjacent\n    }, {\n      minDepth: Math.max,\n      newGroupDelay: Math.min,\n      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)\n    });\n  }\n});\nfunction changeEnd(changes) {\n  let end = 0;\n  changes.iterChangedRanges((_, to) => end = to);\n  return end;\n}\nconst historyField_ = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create() {\n    return HistoryState.empty;\n  },\n  update(state, tr) {\n    let config = tr.state.facet(historyConfig);\n    let fromHist = tr.annotation(fromHistory);\n    if (fromHist) {\n      let selection = tr.docChanged ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(changeEnd(tr.changes)) : undefined;\n      let item = HistEvent.fromTransaction(tr, selection),\n        from = fromHist.side;\n      let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;\n      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = addSelection(other, tr.startState.selection);\n      return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);\n    }\n    let isolate = tr.annotation(isolateHistory);\n    if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n    if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n    let event = HistEvent.fromTransaction(tr);\n    let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time),\n      userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n    if (event) state = state.addChanges(event, time, userEvent, config, tr);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n    if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n    return state;\n  },\n  toJSON(value) {\n    return {\n      done: value.done.map(e => e.toJSON()),\n      undone: value.undone.map(e => e.toJSON())\n    };\n  },\n  fromJSON(json) {\n    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n  }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n  return [historyField_, historyConfig.of(config), _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    beforeinput(e, view) {\n      let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n      if (!command) return false;\n      e.preventDefault();\n      return command(view);\n    }\n  })];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n  return function ({\n    state,\n    dispatch\n  }) {\n    if (!selection && state.readOnly) return false;\n    let historyState = state.field(historyField_, false);\n    if (!historyState) return false;\n    let tr = historyState.pop(side, state, selection);\n    if (!tr) return false;\n    dispatch(tr);\n    return true;\n  };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);\n/**\nUndo a change or selection change.\n*/\nconst undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);\n/**\nRedo a change or selection change.\n*/\nconst redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);\nfunction depth(side) {\n  return function (state) {\n    let histState = state.field(historyField_, false);\n    if (!histState) return 0;\n    let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;\n    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n  };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = /*@__PURE__*/depth(0 /* BranchName.Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = /*@__PURE__*/depth(1 /* BranchName.Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n  constructor(\n  // The changes in this event. Normal events hold at least one\n  // change or effect. But it may be necessary to store selection\n  // events before the first change, in which case a special type of\n  // instance is created which doesn't hold any changes, with\n  // changes == startSelection == undefined\n  changes,\n  // The effects associated with this event\n  effects,\n  // Accumulated mapping (from addToHistory==false) that should be\n  // applied to events below this one.\n  mapped,\n  // The selection before this event\n  startSelection,\n  // Stores selection changes after this event, to be used for\n  // selection undo/redo.\n  selectionsAfter) {\n    this.changes = changes;\n    this.effects = effects;\n    this.mapped = mapped;\n    this.startSelection = startSelection;\n    this.selectionsAfter = selectionsAfter;\n  }\n  setSelAfter(after) {\n    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n  }\n  toJSON() {\n    var _a, _b, _c;\n    return {\n      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n      selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n    };\n  }\n  static fromJSON(json) {\n    return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n  }\n  // This does not check `addToHistory` and such, it assumes the\n  // transaction needs to be converted to an item. Returns null when\n  // there are no changes or effects in the transaction.\n  static fromTransaction(tr, selection) {\n    let effects = none;\n    for (let invert of tr.startState.facet(invertedEffects)) {\n      let result = invert(tr);\n      if (result.length) effects = effects.concat(result);\n    }\n    if (!effects.length && tr.changes.empty) return null;\n    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n  }\n  static selection(selections) {\n    return new HistEvent(undefined, none, undefined, undefined, selections);\n  }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n  let newBranch = branch.slice(start, to);\n  newBranch.push(newEvent);\n  return newBranch;\n}\nfunction isAdjacent(a, b) {\n  let ranges = [],\n    isAdjacent = false;\n  a.iterChangedRanges((f, t) => ranges.push(f, t));\n  b.iterChangedRanges((_f, _t, f, t) => {\n    for (let i = 0; i < ranges.length;) {\n      let from = ranges[i++],\n        to = ranges[i++];\n      if (t >= from && f <= to) isAdjacent = true;\n    }\n  });\n  return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n  return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n  if (!branch.length) {\n    return [HistEvent.selection([selection])];\n  } else {\n    let lastEvent = branch[branch.length - 1];\n    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n    sels.push(selection);\n    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n  }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n  let last = branch[branch.length - 1];\n  let newBranch = branch.slice();\n  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n  return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n  if (!branch.length) return branch;\n  let length = branch.length,\n    selections = none;\n  while (length) {\n    let event = mapEvent(branch[length - 1], mapping, selections);\n    if (event.changes && !event.changes.empty || event.effects.length) {\n      // Event survived mapping\n      let result = branch.slice(0, length);\n      result[length - 1] = event;\n      return result;\n    } else {\n      // Drop this event, since there's no changes or effects left\n      mapping = event.mapped;\n      length--;\n      selections = event.selectionsAfter;\n    }\n  }\n  return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n  // Change-less events don't store mappings (they are always the last event in a branch)\n  if (!event.changes) return HistEvent.selection(selections);\n  let mappedChanges = event.changes.map(mapping),\n    before = mapping.mapDesc(event.changes, true);\n  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n  return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n  constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n    this.done = done;\n    this.undone = undone;\n    this.prevTime = prevTime;\n    this.prevUserEvent = prevUserEvent;\n  }\n  isolate() {\n    return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n  }\n  addChanges(event, time, userEvent, config, tr) {\n    let done = this.done,\n      lastEvent = done[done.length - 1];\n    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) ||\n    // For compose (but not compose.start) events, always join with previous event\n    userEvent == \"input.type.compose\")) {\n      done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n    } else {\n      done = updateBranch(done, done.length, config.minDepth, event);\n    }\n    return new HistoryState(done, none, time, userEvent);\n  }\n  addSelection(selection, time, userEvent, newGroupDelay) {\n    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n  }\n  addMapping(mapping) {\n    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n  }\n  pop(side, state, selection) {\n    let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;\n    if (branch.length == 0) return null;\n    let event = branch[branch.length - 1];\n    if (selection && event.selectionsAfter.length) {\n      return state.update({\n        selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n        annotations: fromHistory.of({\n          side,\n          rest: popSelection(branch)\n        }),\n        userEvent: side == 0 /* BranchName.Done */ ? \"select.undo\" : \"select.redo\",\n        scrollIntoView: true\n      });\n    } else if (!event.changes) {\n      return null;\n    } else {\n      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n      if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n      return state.update({\n        changes: event.changes,\n        selection: event.startSelection,\n        effects: event.effects,\n        annotations: fromHistory.of({\n          side,\n          rest\n        }),\n        filter: false,\n        userEvent: side == 0 /* BranchName.Done */ ? \"undo\" : \"redo\",\n        scrollIntoView: true\n      });\n    }\n  }\n}\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\nconst historyKeymap = [{\n  key: \"Mod-z\",\n  run: undo,\n  preventDefault: true\n}, {\n  key: \"Mod-y\",\n  mac: \"Mod-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  linux: \"Ctrl-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  key: \"Mod-u\",\n  run: undoSelection,\n  preventDefault: true\n}, {\n  key: \"Alt-u\",\n  mac: \"Mod-Shift-u\",\n  run: redoSelection,\n  preventDefault: true\n}];\nfunction updateSel(sel, by) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n  return state.update({\n    selection,\n    scrollIntoView: true,\n    userEvent: \"select\"\n  });\n}\nfunction moveSel({\n  state,\n  dispatch\n}, how) {\n  let selection = updateSel(state.selection, how);\n  if (selection.eq(state.selection)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\nfunction rangeEnd(range, forward) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n  return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nfunction moveBySubword(view, range, forward) {\n  let categorize = view.state.charCategorizer(range.from);\n  return view.moveByChar(range, forward, start => {\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space,\n      pos = range.from;\n    let done = false,\n      sawUpper = false,\n      sawLower = false;\n    let step = next => {\n      if (done) return false;\n      pos += forward ? next.length : -next.length;\n      let nextCat = categorize(next),\n        ahead;\n      if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n      if (cat != nextCat) return false;\n      if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n        if (next.toLowerCase() == next) {\n          if (!forward && sawUpper) return false;\n          sawLower = true;\n        } else if (sawLower) {\n          if (forward) return false;\n          done = true;\n        } else {\n          if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n          sawUpper = true;\n        }\n      }\n      return true;\n    };\n    step(start);\n    return step;\n  });\n}\nfunction cursorBySubword(view, forward) {\n  return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n  if (node.type.prop(bracketProp)) return true;\n  let len = node.to - node.from;\n  return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n  let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n  let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n  // Scan forward through child nodes to see if there's an interesting\n  // node ahead.\n  for (let at = start.head;;) {\n    let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n    if (!next) break;\n    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;\n  }\n  let bracket = pos.type.prop(bracketProp),\n    match,\n    newPos;\n  if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n  return moveSel(view, range => {\n    if (!range.empty) return rangeEnd(range, forward);\n    let moved = view.moveVertically(range, forward);\n    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n  });\n}\n/**\nMove the selection one line up.\n*/\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction pageHeight(view) {\n  return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);\n}\nfunction cursorByPage(view, forward) {\n  let {\n      state\n    } = view,\n    selection = updateSel(state.selection, range => {\n      return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);\n    });\n  if (selection.eq(state.selection)) return false;\n  let startPos = view.coordsAtPos(state.selection.main.head);\n  let scrollRect = view.scrollDOM.getBoundingClientRect();\n  let effect;\n  if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n    y: \"start\",\n    yMargin: startPos.top - scrollRect.top\n  });\n  view.dispatch(setSel(state, selection), {\n    effects: effect\n  });\n  return true;\n}\n/**\nMove the selection one page up.\n*/\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n  let line = view.lineBlockAt(start.head),\n    moved = view.moveToLineBoundary(start, forward);\n  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n  if (!forward && moved.head == line.from && line.length) {\n    let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n    if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n  }\n  return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/\nconst cursorLineStart = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\nconst cursorLineEnd = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n  let found = false,\n    selection = updateSel(state.selection, range => {\n      let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n      if (!matching || !matching.end) return range;\n      found = true;\n      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n      return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n  if (!found) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\nconst cursorMatchingBracket = ({\n  state,\n  dispatch\n}) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\nconst selectMatchingBracket = ({\n  state,\n  dispatch\n}) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n  let selection = updateSel(view.state.selection, range => {\n    let head = how(range);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n  });\n  if (selection.eq(view.state.selection)) return false;\n  view.dispatch(setSel(view.state, selection));\n  return true;\n}\nfunction selectByChar(view, forward) {\n  return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n  return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\nconst selectGroupBackward = view => selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n  return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward, pageHeight(view)));\n}\n/**\nMove the selection head one page up.\n*/\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/\nconst selectLineStart = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\nconst selectLineEnd = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\nconst cursorDocStart = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: 0\n  }));\n  return true;\n};\n/**\nMove the selection to the end of the document.\n*/\nconst cursorDocEnd = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.doc.length\n  }));\n  return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\nconst selectDocStart = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: 0\n  }));\n  return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\nconst selectDocEnd = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: state.doc.length\n  }));\n  return true;\n};\n/**\nSelect the entire document.\n*/\nconst selectAll = ({\n  state,\n  dispatch\n}) => {\n  dispatch(state.update({\n    selection: {\n      anchor: 0,\n      head: state.doc.length\n    },\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\nconst selectLine = ({\n  state,\n  dispatch\n}) => {\n  let ranges = selectedLineBlocks(state).map(({\n    from,\n    to\n  }) => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n  dispatch(state.update({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\nconst selectParentSyntax = ({\n  state,\n  dispatch\n}) => {\n  let selection = updateSel(state.selection, range => {\n    var _a;\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(range.head, 1);\n    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent))) context = context.parent;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(context.to, context.from);\n  });\n  dispatch(setSel(state, selection));\n  return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\nconst simplifySelection = ({\n  state,\n  dispatch\n}) => {\n  let cur = state.selection,\n    selection = null;\n  if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)]);\n  if (!selection) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\nfunction deleteBy(target, by) {\n  if (target.state.readOnly) return false;\n  let event = \"delete.selection\",\n    {\n      state\n    } = target;\n  let changes = state.changeByRange(range => {\n    let {\n      from,\n      to\n    } = range;\n    if (from == to) {\n      let towards = by(from);\n      if (towards < from) {\n        event = \"delete.backward\";\n        towards = skipAtomic(target, towards, false);\n      } else if (towards > from) {\n        event = \"delete.forward\";\n        towards = skipAtomic(target, towards, true);\n      }\n      from = Math.min(from, towards);\n      to = Math.max(to, towards);\n    } else {\n      from = skipAtomic(target, from, false);\n      to = skipAtomic(target, to, true);\n    }\n    return from == to ? {\n      range\n    } : {\n      changes: {\n        from,\n        to\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from)\n    };\n  });\n  if (changes.changes.empty) return false;\n  target.dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: event,\n    effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n  }));\n  return true;\n}\nfunction skipAtomic(target, pos, forward) {\n  if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map(f => f(target))) ranges.between(pos, pos, (from, to) => {\n    if (from < pos && to > pos) pos = forward ? to : from;\n  });\n  return pos;\n}\nconst deleteByChar = (target, forward) => deleteBy(target, pos => {\n  let {\n      state\n    } = target,\n    line = state.doc.lineAt(pos),\n    before,\n    targetPos;\n  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n    if (before[before.length - 1] == \"\\t\") return pos - 1;\n    let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize),\n      drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n    for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++) pos--;\n    targetPos = pos;\n  } else {\n    targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n  }\n  return targetPos;\n});\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/\nconst deleteCharBackward = view => deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/\nconst deleteCharForward = view => deleteByChar(view, true);\nconst deleteByGroup = (target, forward) => deleteBy(target, start => {\n  let pos = start,\n    {\n      state\n    } = target,\n    line = state.doc.lineAt(pos);\n  let categorize = state.charCategorizer(pos);\n  for (let cat = null;;) {\n    if (pos == (forward ? line.to : line.from)) {\n      if (pos == start && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n      break;\n    }\n    let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n    let nextCat = categorize(nextChar);\n    if (cat != null && nextCat != cat) break;\n    if (nextChar != \" \" || pos != start) cat = nextCat;\n    pos = next;\n  }\n  return pos;\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n  let lineEnd = view.lineBlockAt(pos).to;\n  return pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\nconst deleteToLineStart = view => deleteBy(view, pos => {\n  let lineStart = view.lineBlockAt(pos).from;\n  return pos > lineStart ? lineStart : Math.max(0, pos - 1);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\nconst deleteTrailingWhitespace = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = [];\n  for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n    iter.next();\n    if (iter.lineBreak || iter.done) {\n      let trailing = prev.search(/\\s+$/);\n      if (trailing > -1) changes.push({\n        from: pos - (prev.length - trailing),\n        to: pos\n      });\n      if (iter.done) break;\n      prev = \"\";\n    } else {\n      prev = iter.value;\n    }\n    pos += iter.value.length;\n  }\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\nconst splitLine = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\"\", \"\"])\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\nconst transposeChars = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n      range\n    };\n    let pos = range.from,\n      line = state.doc.lineAt(pos);\n    let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n    let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n    return {\n      changes: {\n        from,\n        to,\n        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"move.character\"\n  }));\n  return true;\n};\nfunction selectedLineBlocks(state) {\n  let blocks = [],\n    upto = -1;\n  for (let range of state.selection.ranges) {\n    let startLine = state.doc.lineAt(range.from),\n      endLine = state.doc.lineAt(range.to);\n    if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n    if (upto >= startLine.number) {\n      let prev = blocks[blocks.length - 1];\n      prev.to = endLine.to;\n      prev.ranges.push(range);\n    } else {\n      blocks.push({\n        from: startLine.from,\n        to: endLine.to,\n        ranges: [range]\n      });\n    }\n    upto = endLine.number + 1;\n  }\n  return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [],\n    ranges = [];\n  for (let block of selectedLineBlocks(state)) {\n    if (forward ? block.to == state.doc.length : block.from == 0) continue;\n    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n    let size = nextLine.length + 1;\n    if (forward) {\n      changes.push({\n        from: block.to,\n        to: nextLine.to\n      }, {\n        from: block.from,\n        insert: nextLine.text + state.lineBreak\n      });\n      for (let r of block.ranges) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n    } else {\n      changes.push({\n        from: nextLine.from,\n        to: block.from\n      }, {\n        from: block.to,\n        insert: state.lineBreak + nextLine.text\n      });\n      for (let r of block.ranges) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n    }\n  }\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n    userEvent: \"move.line\"\n  }));\n  return true;\n}\n/**\nMove the selected lines up one line.\n*/\nconst moveLineUp = ({\n  state,\n  dispatch\n}) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\nconst moveLineDown = ({\n  state,\n  dispatch\n}) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [];\n  for (let block of selectedLineBlocks(state)) {\n    if (forward) changes.push({\n      from: block.from,\n      insert: state.doc.slice(block.from, block.to) + state.lineBreak\n    });else changes.push({\n      from: block.to,\n      insert: state.lineBreak + state.doc.slice(block.from, block.to)\n    });\n  }\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    userEvent: \"input.copyline\"\n  }));\n  return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\nconst copyLineUp = ({\n  state,\n  dispatch\n}) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\nconst copyLineDown = ({\n  state,\n  dispatch\n}) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\nconst deleteLine = view => {\n  if (view.state.readOnly) return false;\n  let {\n      state\n    } = view,\n    changes = state.changes(selectedLineBlocks(state).map(({\n      from,\n      to\n    }) => {\n      if (from > 0) from--;else if (to < state.doc.length) to++;\n      return {\n        from,\n        to\n      };\n    }));\n  let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: true,\n    userEvent: \"delete.line\"\n  });\n  return true;\n};\n/**\nReplace the selection with a newline.\n*/\nconst insertNewline = ({\n  state,\n  dispatch\n}) => {\n  dispatch(state.update(state.replaceSelection(state.lineBreak), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\nfunction isBetweenBrackets(state, pos) {\n  if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n    from: pos,\n    to: pos\n  };\n  let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n  let before = context.childBefore(pos),\n    after = context.childAfter(pos),\n    closedBy;\n  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from) return {\n    from: before.to,\n    to: after.from\n  };\n  return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n  return ({\n    state,\n    dispatch\n  }) => {\n    if (state.readOnly) return false;\n    let changes = state.changeByRange(range => {\n      let {\n          from,\n          to\n        } = range,\n        line = state.doc.lineAt(from);\n      let explode = !atEof && from == to && isBetweenBrackets(state, from);\n      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n      let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        simulateBreak: from,\n        simulateDoubleBreak: !!explode\n      });\n      let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n      if (indent == null) indent = /^\\s*/.exec(state.doc.lineAt(from).text)[0].length;\n      while (to < line.to && /\\s/.test(line.text[to - line.from])) to++;\n      if (explode) ({\n        from,\n        to\n      } = explode);else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n      let insert = [\"\", (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)];\n      if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n      return {\n        changes: {\n          from,\n          to,\n          insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n      };\n    });\n    dispatch(state.update(changes, {\n      scrollIntoView: true,\n      userEvent: \"input\"\n    }));\n    return true;\n  };\n}\nfunction changeBySelectedLine(state, f) {\n  let atLine = -1;\n  return state.changeByRange(range => {\n    let changes = [];\n    for (let pos = range.from; pos <= range.to;) {\n      let line = state.doc.lineAt(pos);\n      if (line.number > atLine && (range.empty || range.to > line.from)) {\n        f(line, changes, range);\n        atLine = line.number;\n      }\n      pos = line.to + 1;\n    }\n    let changeSet = state.changes(changes);\n    return {\n      changes,\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n    };\n  });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\nconst indentSelection = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let updated = Object.create(null);\n  let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n    overrideIndentation: start => {\n      let found = updated[start];\n      return found == null ? -1 : found;\n    }\n  });\n  let changes = changeBySelectedLine(state, (line, changes, range) => {\n    let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n    if (indent == null) return;\n    if (!/\\S/.test(line.text)) indent = 0;\n    let cur = /^\\s*/.exec(line.text)[0];\n    let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n    if (cur != norm || range.from < line.from + cur.length) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  });\n  if (!changes.changes.empty) dispatch(state.update(changes, {\n    userEvent: \"indent\"\n  }));\n  return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\nconst indentMore = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    changes.push({\n      from: line.from,\n      insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n    });\n  }), {\n    userEvent: \"input.indent\"\n  }));\n  return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\nconst indentLess = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    let space = /^\\s*/.exec(line.text)[0];\n    if (!space) return;\n    let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize),\n      keep = 0;\n    let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;\n    changes.push({\n      from: line.from + keep,\n      to: line.from + space.length,\n      insert: insert.slice(keep)\n    });\n  }), {\n    userEvent: \"delete.dedent\"\n  }));\n  return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\nconst insertTab = ({\n  state,\n  dispatch\n}) => {\n  if (state.selection.ranges.some(r => !r.empty)) return indentMore({\n    state,\n    dispatch\n  });\n  dispatch(state.update(state.replaceSelection(\"\\t\"), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\nconst emacsStyleKeymap = [{\n  key: \"Ctrl-b\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Ctrl-f\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Ctrl-p\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  key: \"Ctrl-n\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  key: \"Ctrl-a\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"Ctrl-e\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"Ctrl-d\",\n  run: deleteCharForward\n}, {\n  key: \"Ctrl-h\",\n  run: deleteCharBackward\n}, {\n  key: \"Ctrl-k\",\n  run: deleteToLineEnd\n}, {\n  key: \"Ctrl-Alt-h\",\n  run: deleteGroupBackward\n}, {\n  key: \"Ctrl-o\",\n  run: splitLine\n}, {\n  key: \"Ctrl-t\",\n  run: transposeChars\n}, {\n  key: \"Ctrl-v\",\n  run: cursorPageDown\n}];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).\n - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).\n*/\nconst standardKeymap = /*@__PURE__*/[{\n  key: \"ArrowLeft\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowLeft\",\n  mac: \"Alt-ArrowLeft\",\n  run: cursorGroupLeft,\n  shift: selectGroupLeft,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowLeft\",\n  run: cursorLineBoundaryLeft,\n  shift: selectLineBoundaryLeft,\n  preventDefault: true\n}, {\n  key: \"ArrowRight\",\n  run: cursorCharRight,\n  shift: selectCharRight,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowRight\",\n  mac: \"Alt-ArrowRight\",\n  run: cursorGroupRight,\n  shift: selectGroupRight,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowRight\",\n  run: cursorLineBoundaryRight,\n  shift: selectLineBoundaryRight,\n  preventDefault: true\n}, {\n  key: \"ArrowUp\",\n  run: cursorLineUp,\n  shift: selectLineUp,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowUp\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  mac: \"Ctrl-ArrowUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"ArrowDown\",\n  run: cursorLineDown,\n  shift: selectLineDown,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowDown\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  mac: \"Ctrl-ArrowDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"PageUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"PageDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"Home\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward,\n  preventDefault: true\n}, {\n  key: \"Mod-Home\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  key: \"End\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward,\n  preventDefault: true\n}, {\n  key: \"Mod-End\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  key: \"Enter\",\n  run: insertNewlineAndIndent\n}, {\n  key: \"Mod-a\",\n  run: selectAll\n}, {\n  key: \"Backspace\",\n  run: deleteCharBackward,\n  shift: deleteCharBackward\n}, {\n  key: \"Delete\",\n  run: deleteCharForward\n}, {\n  key: \"Mod-Backspace\",\n  mac: \"Alt-Backspace\",\n  run: deleteGroupBackward\n}, {\n  key: \"Mod-Delete\",\n  mac: \"Alt-Delete\",\n  run: deleteGroupForward\n}, {\n  mac: \"Mod-Backspace\",\n  run: deleteToLineStart\n}, {\n  mac: \"Mod-Delete\",\n  run: deleteToLineEnd\n}].concat( /*@__PURE__*/emacsStyleKeymap.map(b => ({\n  mac: b.key,\n  run: b.run,\n  shift: b.shift\n})));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n*/\nconst defaultKeymap = /*@__PURE__*/[{\n  key: \"Alt-ArrowLeft\",\n  mac: \"Ctrl-ArrowLeft\",\n  run: cursorSyntaxLeft,\n  shift: selectSyntaxLeft\n}, {\n  key: \"Alt-ArrowRight\",\n  mac: \"Ctrl-ArrowRight\",\n  run: cursorSyntaxRight,\n  shift: selectSyntaxRight\n}, {\n  key: \"Alt-ArrowUp\",\n  run: moveLineUp\n}, {\n  key: \"Shift-Alt-ArrowUp\",\n  run: copyLineUp\n}, {\n  key: \"Alt-ArrowDown\",\n  run: moveLineDown\n}, {\n  key: \"Shift-Alt-ArrowDown\",\n  run: copyLineDown\n}, {\n  key: \"Escape\",\n  run: simplifySelection\n}, {\n  key: \"Mod-Enter\",\n  run: insertBlankLine\n}, {\n  key: \"Alt-l\",\n  mac: \"Ctrl-l\",\n  run: selectLine\n}, {\n  key: \"Mod-i\",\n  run: selectParentSyntax,\n  preventDefault: true\n}, {\n  key: \"Mod-[\",\n  run: indentLess\n}, {\n  key: \"Mod-]\",\n  run: indentMore\n}, {\n  key: \"Mod-Alt-\\\\\",\n  run: indentSelection\n}, {\n  key: \"Shift-Mod-k\",\n  run: deleteLine\n}, {\n  key: \"Shift-Mod-\\\\\",\n  run: cursorMatchingBracket\n}, {\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\nconst indentWithTab = {\n  key: \"Tab\",\n  run: indentMore,\n  shift: indentLess\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9jb21tYW5kcy9kaXN0L2luZGV4LmpzPzJmODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIEVkaXRvclNlbGVjdGlvbiwgVHJhbnNhY3Rpb24sIENoYW5nZVNldCwgQ2hhbmdlRGVzYywgU3RhdGVFZmZlY3QsIFRleHQsIGZpbmRDbHVzdGVyQnJlYWssIGNvdW50Q29sdW1uLCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3LCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEluZGVudENvbnRleHQsIGdldEluZGVudGF0aW9uLCBpbmRlbnRTdHJpbmcsIG1hdGNoQnJhY2tldHMsIHN5bnRheFRyZWUsIGdldEluZGVudFVuaXQsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCB1c2UgbGluZSBjb21tZW50c1xuaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGluZyBiYWNrIHRvIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUNvbW1lbnQgPSB0YXJnZXQgPT4ge1xuICAgIGxldCBjb25maWcgPSBnZXRDb25maWcodGFyZ2V0LnN0YXRlKTtcbiAgICByZXR1cm4gY29uZmlnLmxpbmUgPyB0b2dnbGVMaW5lQ29tbWVudCh0YXJnZXQpIDogY29uZmlnLmJsb2NrID8gdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lKHRhcmdldCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBjb21tYW5kKGYsIG9wdGlvbikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGYob3B0aW9uLCBzdGF0ZSk7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh0cikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cblRoZSBsaW5lIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlTGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZUNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG4qL1xuY29uc3QgbGluZVVuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuVGhlIGJsb2NrIGNvbW1lbnQgc3ludGF4IGlzIHRha2VuIGZyb20gdGhlXG5bYGNvbW1lbnRUb2tlbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgYmxvY2tVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgbGluZXMgYXJvdW5kIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZ1xuYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lID0gLypAX19QVVJFX18qL2NvbW1hbmQoKG8sIHMpID0+IGNoYW5nZUJsb2NrQ29tbWVudChvLCBzLCBzZWxlY3RlZExpbmVSYW5nZXMocykpLCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbmZ1bmN0aW9uIGdldENvbmZpZyhzdGF0ZSwgcG9zID0gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkge1xuICAgIGxldCBkYXRhID0gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjb21tZW50VG9rZW5zXCIsIHBvcyk7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID8gZGF0YVswXSA6IHt9O1xufVxuY29uc3QgU2VhcmNoTWFyZ2luID0gNTA7XG4vKipcbkRldGVybWluZXMgaWYgdGhlIGdpdmVuIHJhbmdlIGlzIGJsb2NrLWNvbW1lbnRlZCBpbiB0aGUgZ2l2ZW5cbnN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHsgb3BlbiwgY2xvc2UgfSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20gLSBTZWFyY2hNYXJnaW4sIGZyb20pO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyBTZWFyY2hNYXJnaW4pO1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IC9cXHMqJC8uZXhlYyh0ZXh0QmVmb3JlKVswXS5sZW5ndGgsIHNwYWNlQWZ0ZXIgPSAvXlxccyovLmV4ZWModGV4dEFmdGVyKVswXS5sZW5ndGg7XG4gICAgbGV0IGJlZm9yZU9mZiA9IHRleHRCZWZvcmUubGVuZ3RoIC0gc3BhY2VCZWZvcmU7XG4gICAgaWYgKHRleHRCZWZvcmUuc2xpY2UoYmVmb3JlT2ZmIC0gb3Blbi5sZW5ndGgsIGJlZm9yZU9mZikgPT0gb3BlbiAmJlxuICAgICAgICB0ZXh0QWZ0ZXIuc2xpY2Uoc3BhY2VBZnRlciwgc3BhY2VBZnRlciArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gLSBzcGFjZUJlZm9yZSwgbWFyZ2luOiBzcGFjZUJlZm9yZSAmJiAxIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvICsgc3BhY2VBZnRlciwgbWFyZ2luOiBzcGFjZUFmdGVyICYmIDEgfSB9O1xuICAgIH1cbiAgICBsZXQgc3RhcnRUZXh0LCBlbmRUZXh0O1xuICAgIGlmICh0byAtIGZyb20gPD0gMiAqIFNlYXJjaE1hcmdpbikge1xuICAgICAgICBzdGFydFRleHQgPSBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIFNlYXJjaE1hcmdpbik7XG4gICAgICAgIGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyh0byAtIFNlYXJjaE1hcmdpbiwgdG8pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRTcGFjZSA9IC9eXFxzKi8uZXhlYyhzdGFydFRleHQpWzBdLmxlbmd0aCwgZW5kU3BhY2UgPSAvXFxzKiQvLmV4ZWMoZW5kVGV4dClbMF0ubGVuZ3RoO1xuICAgIGxldCBlbmRPZmYgPSBlbmRUZXh0Lmxlbmd0aCAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoO1xuICAgIGlmIChzdGFydFRleHQuc2xpY2Uoc3RhcnRTcGFjZSwgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSA9PSBvcGVuICYmXG4gICAgICAgIGVuZFRleHQuc2xpY2UoZW5kT2ZmLCBlbmRPZmYgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tICsgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChzdGFydFRleHQuY2hhckF0KHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkpID8gMSA6IDAgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3QoZW5kVGV4dC5jaGFyQXQoZW5kT2ZmIC0gMSkpID8gMSA6IDAgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGVkTGluZVJhbmdlcyhzdGF0ZSkge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyLmZyb20pO1xuICAgICAgICBsZXQgdG9MaW5lID0gci50byA8PSBmcm9tTGluZS50byA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvKTtcbiAgICAgICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0udG8gPiBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgcmFuZ2VzW2xhc3RdLnRvID0gdG9MaW5lLnRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGZyb21MaW5lLmZyb20sIHRvOiB0b0xpbmUudG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBibG9jayBjb21tZW50cyBpblxuLy8gbGFuZ3VhZ2VzIHRoYXQgc3VwcG9ydCB0aGVtLlxuZnVuY3Rpb24gY2hhbmdlQmxvY2tDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgdG9rZW5zID0gcmFuZ2VzLm1hcChyID0+IGdldENvbmZpZyhzdGF0ZSwgci5mcm9tKS5ibG9jayk7XG4gICAgaWYgKCF0b2tlbnMuZXZlcnkoYyA9PiBjKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNvbW1lbnRzID0gcmFuZ2VzLm1hcCgociwgaSkgPT4gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgdG9rZW5zW2ldLCByLmZyb20sIHIudG8pKTtcbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgIWNvbW1lbnRzLmV2ZXJ5KGMgPT4gYykpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogc3RhdGUuY2hhbmdlcyhyYW5nZXMubWFwKChyYW5nZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiByYW5nZS5mcm9tLCBpbnNlcnQ6IHRva2Vuc1tpXS5vcGVuICsgXCIgXCIgfSwgeyBmcm9tOiByYW5nZS50bywgaW5zZXJ0OiBcIiBcIiArIHRva2Vuc1tpXS5jbG9zZSB9XTtcbiAgICAgICAgICAgIH0pKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgY29tbWVudHMuc29tZShjID0+IGMpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb21tZW50OyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWVudCA9IGNvbW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldLCB7IG9wZW4sIGNsb3NlIH0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG9wZW4ucG9zIC0gdG9rZW4ub3Blbi5sZW5ndGgsIHRvOiBvcGVuLnBvcyArIG9wZW4ubWFyZ2luIH0sIHsgZnJvbTogY2xvc2UucG9zIC0gY2xvc2UubWFyZ2luLCB0bzogY2xvc2UucG9zICsgdG9rZW4uY2xvc2UubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgbGluZSBjb21tZW50cy5cbmZ1bmN0aW9uIGNoYW5nZUxpbmVDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsZXQgcHJldkxpbmUgPSAtMTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydEkgPSBsaW5lcy5sZW5ndGgsIG1pbkluZGVudCA9IDFlOTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gcHJldkxpbmUgJiYgKGZyb20gPT0gdG8gfHwgdG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcHJldkxpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gZ2V0Q29uZmlnKHN0YXRlLCBwb3MpLmxpbmU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgZW1wdHkgPSBpbmRlbnQgPT0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnRleHQuc2xpY2UoaW5kZW50LCBpbmRlbnQgKyB0b2tlbi5sZW5ndGgpID09IHRva2VuID8gaW5kZW50IDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGluZGVudCA8IGxpbmUudGV4dC5sZW5ndGggJiYgaW5kZW50IDwgbWluSW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBtaW5JbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGxpbmUsIGNvbW1lbnQsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbkluZGVudCA8IDFlOSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZW50IDwgbGluZXNbaV0ubGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0uaW5kZW50ID0gbWluSW5kZW50O1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IHN0YXJ0SSArIDEpXG4gICAgICAgICAgICBsaW5lc1tzdGFydEldLnNpbmdsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50IDwgMCAmJiAoIWwuZW1wdHkgfHwgbC5zaW5nbGUpKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGUgfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChzaW5nbGUgfHwgIWVtcHR5KVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGluZGVudCwgaW5zZXJ0OiB0b2tlbiArIFwiIFwiIH0pO1xuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogY2hhbmdlU2V0LCBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5tYXAoY2hhbmdlU2V0LCAxKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA+PSAwKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIGNvbW1lbnQsIHRva2VuIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoY29tbWVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBsaW5lLmZyb20gKyBjb21tZW50LCB0byA9IGZyb20gKyB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0gPT0gXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGZyb21IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGFubm90YXRpb24gdGhhdCB3aWxsIHByZXZlbnQgdGhhdCB0cmFuc2FjdGlvbiBmcm9tXG5iZWluZyBjb21iaW5lZCB3aXRoIG90aGVyIHRyYW5zYWN0aW9ucyBpbiB0aGUgdW5kbyBoaXN0b3J5LiBHaXZlblxuYFwiYmVmb3JlXCJgLCBpdCdsbCBwcmV2ZW50IG1lcmdpbmcgd2l0aCBwcmV2aW91cyB0cmFuc2FjdGlvbnMuIFdpdGhcbmBcImFmdGVyXCJgLCBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucyB3b24ndCBiZSBjb21iaW5lZCB3aXRoIHRoaXNcbm9uZS4gV2l0aCBgXCJmdWxsXCJgLCB0aGUgdHJhbnNhY3Rpb24gaXMgaXNvbGF0ZWQgb24gYm90aCBzaWRlcy5cbiovXG5jb25zdCBpc29sYXRlSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UaGlzIGZhY2V0IHByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyB0aGF0LCBnaXZlbiBhXG50cmFuc2FjdGlvbiwgcHJvdmlkZSBhIHNldCBvZiBlZmZlY3RzIHRoYXQgdGhlIGhpc3Rvcnkgc2hvdWxkXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cbmludGVncmF0ZSBzb21lIGtpbmRzIG9mIGVmZmVjdHMgaW4gdGhlIGhpc3RvcnksIHNvIHRoYXQgdGhleSBjYW5cbmJlIHVuZG9uZSAoYW5kIHJlZG9uZSBhZ2FpbikuXG4qL1xuY29uc3QgaW52ZXJ0ZWRFZmZlY3RzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaGlzdG9yeUNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChfdCwgaXNBZGphY2VudCkgPT4gaXNBZGphY2VudCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluRGVwdGg6IE1hdGgubWF4LFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogTWF0aC5taW4sXG4gICAgICAgICAgICBqb2luVG9FdmVudDogKGEsIGIpID0+ICh0ciwgYWRqKSA9PiBhKHRyLCBhZGopIHx8IGIodHIsIGFkailcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBjaGFuZ2VFbmQoY2hhbmdlcykge1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKF8sIHRvKSA9PiBlbmQgPSB0byk7XG4gICAgcmV0dXJuIGVuZDtcbn1cbmNvbnN0IGhpc3RvcnlGaWVsZF8gPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIEhpc3RvcnlTdGF0ZS5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGhpc3RvcnlDb25maWcpO1xuICAgICAgICBsZXQgZnJvbUhpc3QgPSB0ci5hbm5vdGF0aW9uKGZyb21IaXN0b3J5KTtcbiAgICAgICAgaWYgKGZyb21IaXN0KSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdHIuZG9jQ2hhbmdlZCA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY2hhbmdlRW5kKHRyLmNoYW5nZXMpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0ciwgc2VsZWN0aW9uKSwgZnJvbSA9IGZyb21IaXN0LnNpZGU7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gc3RhdGUudW5kb25lIDogc3RhdGUuZG9uZTtcbiAgICAgICAgICAgIGlmIChpdGVtKVxuICAgICAgICAgICAgICAgIG90aGVyID0gdXBkYXRlQnJhbmNoKG90aGVyLCBvdGhlci5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgaXRlbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3RoZXIgPSBhZGRTZWxlY3Rpb24ob3RoZXIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBmcm9tSGlzdC5yZXN0IDogb3RoZXIsIGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBvdGhlciA6IGZyb21IaXN0LnJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc29sYXRlID0gdHIuYW5ub3RhdGlvbihpc29sYXRlSGlzdG9yeSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJiZWZvcmVcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiAhdHIuY2hhbmdlcy5lbXB0eSA/IHN0YXRlLmFkZE1hcHBpbmcodHIuY2hhbmdlcy5kZXNjKSA6IHN0YXRlO1xuICAgICAgICBsZXQgZXZlbnQgPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnRpbWUpLCB1c2VyRXZlbnQgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKTtcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRTZWxlY3Rpb24odHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICB0b0pTT04odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSwgdW5kb25lOiB2YWx1ZS51bmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSkgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoanNvbi5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pLCBqc29uLnVuZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSk7XG4gICAgfVxufSk7XG4vKipcbkNyZWF0ZSBhIGhpc3RvcnkgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXG4gICAgICAgIGhpc3RvcnlDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICAgICAgICAgIGJlZm9yZWlucHV0KGUsIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgXTtcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHVzZWQgdG8gc3RvcmUgdGhlIGhpc3RvcnkgZGF0YS4gU2hvdWxkIHByb2JhYmx5XG5vbmx5IGJlIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xuW3NlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIG9yXG5bZGVzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHN0YXRlIG9iamVjdHMgaW4gYSB3YXlcbnRoYXQgcHJlc2VydmVzIGhpc3RvcnkuXG4qL1xuY29uc3QgaGlzdG9yeUZpZWxkID0gaGlzdG9yeUZpZWxkXztcbmZ1bmN0aW9uIGNtZChzaWRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHsgc3RhdGUsIGRpc3BhdGNoIH0pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBoaXN0b3J5U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdG9yeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBoaXN0b3J5U3RhdGUucG9wKHNpZGUsIHN0YXRlLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblVuZG8gYSBzaW5nbGUgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXBcbndhcyBhdmFpbGFibGUuXG4qL1xuY29uc3QgdW5kbyA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuUmVkbyBhIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwIHdhc1xuYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHJlZG8gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuVW5kbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHVuZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCB0cnVlKTtcbi8qKlxuUmVkbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHJlZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIHRydWUpO1xuZnVuY3Rpb24gZGVwdGgoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgbGV0IGhpc3RTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBoaXN0U3RhdGUuZG9uZSA6IGhpc3RTdGF0ZS51bmRvbmU7XG4gICAgICAgIHJldHVybiBicmFuY2gubGVuZ3RoIC0gKGJyYW5jaC5sZW5ndGggJiYgIWJyYW5jaFswXS5jaGFuZ2VzID8gMSA6IDApO1xuICAgIH07XG59XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCB1bmRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8pO1xuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgcmVkb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8pO1xuLy8gSGlzdG9yeSBldmVudHMgc3RvcmUgZ3JvdXBzIG9mIGNoYW5nZXMgb3IgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmVcbi8vIHVuZG9uZS9yZWRvbmUgdG9nZXRoZXIuXG5jbGFzcyBIaXN0RXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBjaGFuZ2VzIGluIHRoaXMgZXZlbnQuIE5vcm1hbCBldmVudHMgaG9sZCBhdCBsZWFzdCBvbmVcbiAgICAvLyBjaGFuZ2Ugb3IgZWZmZWN0LiBCdXQgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBzdG9yZSBzZWxlY3Rpb25cbiAgICAvLyBldmVudHMgYmVmb3JlIHRoZSBmaXJzdCBjaGFuZ2UsIGluIHdoaWNoIGNhc2UgYSBzcGVjaWFsIHR5cGUgb2ZcbiAgICAvLyBpbnN0YW5jZSBpcyBjcmVhdGVkIHdoaWNoIGRvZXNuJ3QgaG9sZCBhbnkgY2hhbmdlcywgd2l0aFxuICAgIC8vIGNoYW5nZXMgPT0gc3RhcnRTZWxlY3Rpb24gPT0gdW5kZWZpbmVkXG4gICAgY2hhbmdlcywgXG4gICAgLy8gVGhlIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICBlZmZlY3RzLCBcbiAgICAvLyBBY2N1bXVsYXRlZCBtYXBwaW5nIChmcm9tIGFkZFRvSGlzdG9yeT09ZmFsc2UpIHRoYXQgc2hvdWxkIGJlXG4gICAgLy8gYXBwbGllZCB0byBldmVudHMgYmVsb3cgdGhpcyBvbmUuXG4gICAgbWFwcGVkLCBcbiAgICAvLyBUaGUgc2VsZWN0aW9uIGJlZm9yZSB0aGlzIGV2ZW50XG4gICAgc3RhcnRTZWxlY3Rpb24sIFxuICAgIC8vIFN0b3JlcyBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciB0aGlzIGV2ZW50LCB0byBiZSB1c2VkIGZvclxuICAgIC8vIHNlbGVjdGlvbiB1bmRvL3JlZG8uXG4gICAgc2VsZWN0aW9uc0FmdGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMubWFwcGVkID0gbWFwcGVkO1xuICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0aW9uID0gc3RhcnRTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uc0FmdGVyID0gc2VsZWN0aW9uc0FmdGVyO1xuICAgIH1cbiAgICBzZXRTZWxBZnRlcihhZnRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0aGlzLmNoYW5nZXMsIHRoaXMuZWZmZWN0cywgdGhpcy5tYXBwZWQsIHRoaXMuc3RhcnRTZWxlY3Rpb24sIGFmdGVyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IChfYSA9IHRoaXMuY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpLFxuICAgICAgICAgICAgbWFwcGVkOiAoX2IgPSB0aGlzLm1hcHBlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSlNPTigpLFxuICAgICAgICAgICAgc3RhcnRTZWxlY3Rpb246IChfYyA9IHRoaXMuc3RhcnRTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0pTT04oKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbnNBZnRlcjogdGhpcy5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy50b0pTT04oKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQoanNvbi5jaGFuZ2VzICYmIENoYW5nZVNldC5mcm9tSlNPTihqc29uLmNoYW5nZXMpLCBbXSwganNvbi5tYXBwZWQgJiYgQ2hhbmdlRGVzYy5mcm9tSlNPTihqc29uLm1hcHBlZCksIGpzb24uc3RhcnRTZWxlY3Rpb24gJiYgRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc3RhcnRTZWxlY3Rpb24pLCBqc29uLnNlbGVjdGlvbnNBZnRlci5tYXAoRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKSk7XG4gICAgfVxuICAgIC8vIFRoaXMgZG9lcyBub3QgY2hlY2sgYGFkZFRvSGlzdG9yeWAgYW5kIHN1Y2gsIGl0IGFzc3VtZXMgdGhlXG4gICAgLy8gdHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGFuIGl0ZW0uIFJldHVybnMgbnVsbCB3aGVuXG4gICAgLy8gdGhlcmUgYXJlIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0ciwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gbm9uZTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0IG9mIHRyLnN0YXJ0U3RhdGUuZmFjZXQoaW52ZXJ0ZWRFZmZlY3RzKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGludmVydCh0cik7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBlZmZlY3RzID0gZWZmZWN0cy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoICYmIHRyLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodHIuY2hhbmdlcy5pbnZlcnQodHIuc3RhcnRTdGF0ZS5kb2MpLCBlZmZlY3RzLCB1bmRlZmluZWQsIHNlbGVjdGlvbiB8fCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgbm9uZSk7XG4gICAgfVxuICAgIHN0YXRpYyBzZWxlY3Rpb24oc2VsZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh1bmRlZmluZWQsIG5vbmUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzZWxlY3Rpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVCcmFuY2goYnJhbmNoLCB0bywgbWF4TGVuLCBuZXdFdmVudCkge1xuICAgIGxldCBzdGFydCA9IHRvICsgMSA+IG1heExlbiArIDIwID8gdG8gLSBtYXhMZW4gLSAxIDogMDtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKHN0YXJ0LCB0byk7XG4gICAgbmV3QnJhbmNoLnB1c2gobmV3RXZlbnQpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG5mdW5jdGlvbiBpc0FkamFjZW50KGEsIGIpIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIGlzQWRqYWNlbnQgPSBmYWxzZTtcbiAgICBhLml0ZXJDaGFuZ2VkUmFuZ2VzKChmLCB0KSA9PiByYW5nZXMucHVzaChmLCB0KSk7XG4gICAgYi5pdGVyQ2hhbmdlZFJhbmdlcygoX2YsIF90LCBmLCB0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2krK10sIHRvID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICBpZiAodCA+PSBmcm9tICYmIGYgPD0gdG8pXG4gICAgICAgICAgICAgICAgaXNBZGphY2VudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNBZGphY2VudDtcbn1cbmZ1bmN0aW9uIGVxU2VsZWN0aW9uU2hhcGUoYSwgYikge1xuICAgIHJldHVybiBhLnJhbmdlcy5sZW5ndGggPT0gYi5yYW5nZXMubGVuZ3RoICYmXG4gICAgICAgIGEucmFuZ2VzLmZpbHRlcigociwgaSkgPT4gci5lbXB0eSAhPSBiLnJhbmdlc1tpXS5lbXB0eSkubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gY29uYyhhLCBiKSB7XG4gICAgcmV0dXJuICFhLmxlbmd0aCA/IGIgOiAhYi5sZW5ndGggPyBhIDogYS5jb25jYXQoYik7XG59XG5jb25zdCBub25lID0gW107XG5jb25zdCBNYXhTZWxlY3Rpb25zUGVyRXZlbnQgPSAyMDA7XG5mdW5jdGlvbiBhZGRTZWxlY3Rpb24oYnJhbmNoLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtIaXN0RXZlbnQuc2VsZWN0aW9uKFtzZWxlY3Rpb25dKV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGFzdEV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHNlbHMgPSBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLnNsaWNlKE1hdGgubWF4KDAsIGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gTWF4U2VsZWN0aW9uc1BlckV2ZW50KSk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCAmJiBzZWxzW3NlbHMubGVuZ3RoIC0gMV0uZXEoc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgIHNlbHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdXBkYXRlQnJhbmNoKGJyYW5jaCwgYnJhbmNoLmxlbmd0aCAtIDEsIDFlOSwgbGFzdEV2ZW50LnNldFNlbEFmdGVyKHNlbHMpKTtcbiAgICB9XG59XG4vLyBBc3N1bWVzIHRoZSB0b3AgaXRlbSBoYXMgb25lIG9yIG1vcmUgc2VsZWN0aW9uQWZ0ZXIgdmFsdWVzXG5mdW5jdGlvbiBwb3BTZWxlY3Rpb24oYnJhbmNoKSB7XG4gICAgbGV0IGxhc3QgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2UoKTtcbiAgICBuZXdCcmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdID0gbGFzdC5zZXRTZWxBZnRlcihsYXN0LnNlbGVjdGlvbnNBZnRlci5zbGljZSgwLCBsYXN0LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbi8vIEFkZCBhIG1hcHBpbmcgdG8gdGhlIHRvcCBldmVudCBpbiB0aGUgZ2l2ZW4gYnJhbmNoLiBJZiB0aGlzIG1hcHNcbi8vIGF3YXkgYWxsIHRoZSBjaGFuZ2VzIGFuZCBlZmZlY3RzIGluIHRoYXQgaXRlbSwgZHJvcCBpdCBhbmRcbi8vIHByb3BhZ2F0ZSB0aGUgbWFwcGluZyB0byB0aGUgbmV4dCBpdGVtLlxuZnVuY3Rpb24gYWRkTWFwcGluZ1RvQnJhbmNoKGJyYW5jaCwgbWFwcGluZykge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICBsZXQgbGVuZ3RoID0gYnJhbmNoLmxlbmd0aCwgc2VsZWN0aW9ucyA9IG5vbmU7XG4gICAgd2hpbGUgKGxlbmd0aCkge1xuICAgICAgICBsZXQgZXZlbnQgPSBtYXBFdmVudChicmFuY2hbbGVuZ3RoIC0gMV0sIG1hcHBpbmcsIHNlbGVjdGlvbnMpO1xuICAgICAgICBpZiAoZXZlbnQuY2hhbmdlcyAmJiAhZXZlbnQuY2hhbmdlcy5lbXB0eSB8fCBldmVudC5lZmZlY3RzLmxlbmd0aCkgeyAvLyBFdmVudCBzdXJ2aXZlZCBtYXBwaW5nXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYnJhbmNoLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHRbbGVuZ3RoIC0gMV0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIERyb3AgdGhpcyBldmVudCwgc2luY2UgdGhlcmUncyBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgbGVmdFxuICAgICAgICAgICAgbWFwcGluZyA9IGV2ZW50Lm1hcHBlZDtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IGV2ZW50LnNlbGVjdGlvbnNBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9ucy5sZW5ndGggPyBbSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKV0gOiBub25lO1xufVxuZnVuY3Rpb24gbWFwRXZlbnQoZXZlbnQsIG1hcHBpbmcsIGV4dHJhU2VsZWN0aW9ucykge1xuICAgIGxldCBzZWxlY3Rpb25zID0gY29uYyhldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoID8gZXZlbnQuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKSA6IG5vbmUsIGV4dHJhU2VsZWN0aW9ucyk7XG4gICAgLy8gQ2hhbmdlLWxlc3MgZXZlbnRzIGRvbid0IHN0b3JlIG1hcHBpbmdzICh0aGV5IGFyZSBhbHdheXMgdGhlIGxhc3QgZXZlbnQgaW4gYSBicmFuY2gpXG4gICAgaWYgKCFldmVudC5jaGFuZ2VzKVxuICAgICAgICByZXR1cm4gSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKTtcbiAgICBsZXQgbWFwcGVkQ2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMubWFwKG1hcHBpbmcpLCBiZWZvcmUgPSBtYXBwaW5nLm1hcERlc2MoZXZlbnQuY2hhbmdlcywgdHJ1ZSk7XG4gICAgbGV0IGZ1bGxNYXBwaW5nID0gZXZlbnQubWFwcGVkID8gZXZlbnQubWFwcGVkLmNvbXBvc2VEZXNjKGJlZm9yZSkgOiBiZWZvcmU7XG4gICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQobWFwcGVkQ2hhbmdlcywgU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhldmVudC5lZmZlY3RzLCBtYXBwaW5nKSwgZnVsbE1hcHBpbmcsIGV2ZW50LnN0YXJ0U2VsZWN0aW9uLm1hcChiZWZvcmUpLCBzZWxlY3Rpb25zKTtcbn1cbmNvbnN0IGpvaW5hYmxlVXNlckV2ZW50ID0gL14oaW5wdXRcXC50eXBlfGRlbGV0ZSkoJHxcXC4pLztcbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2VGltZSA9IDAsIHByZXZVc2VyRXZlbnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2VXNlckV2ZW50ID0gcHJldlVzZXJFdmVudDtcbiAgICB9XG4gICAgaXNvbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldlRpbWUgPyBuZXcgSGlzdG9yeVN0YXRlKHRoaXMuZG9uZSwgdGhpcy51bmRvbmUpIDogdGhpcztcbiAgICB9XG4gICAgYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKSB7XG4gICAgICAgIGxldCBkb25lID0gdGhpcy5kb25lLCBsYXN0RXZlbnQgPSBkb25lW2RvbmUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0RXZlbnQgJiYgbGFzdEV2ZW50LmNoYW5nZXMgJiYgIWxhc3RFdmVudC5jaGFuZ2VzLmVtcHR5ICYmIGV2ZW50LmNoYW5nZXMgJiZcbiAgICAgICAgICAgICghdXNlckV2ZW50IHx8IGpvaW5hYmxlVXNlckV2ZW50LnRlc3QodXNlckV2ZW50KSkgJiZcbiAgICAgICAgICAgICgoIWxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBjb25maWcubmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5qb2luVG9FdmVudCh0ciwgaXNBZGphY2VudChsYXN0RXZlbnQuY2hhbmdlcywgZXZlbnQuY2hhbmdlcykpKSB8fFxuICAgICAgICAgICAgICAgIC8vIEZvciBjb21wb3NlIChidXQgbm90IGNvbXBvc2Uuc3RhcnQpIGV2ZW50cywgYWx3YXlzIGpvaW4gd2l0aCBwcmV2aW91cyBldmVudFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudCA9PSBcImlucHV0LnR5cGUuY29tcG9zZVwiKSkge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCAtIDEsIGNvbmZpZy5taW5EZXB0aCwgbmV3IEhpc3RFdmVudChldmVudC5jaGFuZ2VzLmNvbXBvc2UobGFzdEV2ZW50LmNoYW5nZXMpLCBjb25jKGV2ZW50LmVmZmVjdHMsIGxhc3RFdmVudC5lZmZlY3RzKSwgbGFzdEV2ZW50Lm1hcHBlZCwgbGFzdEV2ZW50LnN0YXJ0U2VsZWN0aW9uLCBub25lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShkb25lLCBub25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRTZWxlY3Rpb24oc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIG5ld0dyb3VwRGVsYXkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbmUubGVuZ3RoID8gdGhpcy5kb25lW3RoaXMuZG9uZS5sZW5ndGggLSAxXS5zZWxlY3Rpb25zQWZ0ZXIgOiBub25lO1xuICAgICAgICBpZiAobGFzdC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IG5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgIHVzZXJFdmVudCA9PSB0aGlzLnByZXZVc2VyRXZlbnQgJiYgdXNlckV2ZW50ICYmIC9ec2VsZWN0KCR8XFwuKS8udGVzdCh1c2VyRXZlbnQpICYmXG4gICAgICAgICAgICBlcVNlbGVjdGlvblNoYXBlKGxhc3RbbGFzdC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRTZWxlY3Rpb24odGhpcy5kb25lLCBzZWxlY3Rpb24pLCB0aGlzLnVuZG9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLmRvbmUsIG1hcHBpbmcpLCBhZGRNYXBwaW5nVG9CcmFuY2godGhpcy51bmRvbmUsIG1hcHBpbmcpLCB0aGlzLnByZXZUaW1lLCB0aGlzLnByZXZVc2VyRXZlbnQpO1xuICAgIH1cbiAgICBwb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHRoaXMuZG9uZSA6IHRoaXMudW5kb25lO1xuICAgICAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBldmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3Q6IHBvcFNlbGVjdGlvbihicmFuY2gpIH0pLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwic2VsZWN0LnVuZG9cIiA6IFwic2VsZWN0LnJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc3QgPSBicmFuY2gubGVuZ3RoID09IDEgPyBub25lIDogYnJhbmNoLnNsaWNlKDAsIGJyYW5jaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChldmVudC5tYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdCA9IGFkZE1hcHBpbmdUb0JyYW5jaChyZXN0LCBldmVudC5tYXBwZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogZXZlbnQuY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnN0YXJ0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGV2ZW50LmVmZmVjdHMsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdCB9KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwidW5kb1wiIDogXCJyZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuSGlzdG9yeVN0YXRlLmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBIaXN0b3J5U3RhdGUobm9uZSwgbm9uZSk7XG4vKipcbkRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgdW5kbyBoaXN0b3J5LlxuXG4tIE1vZC16OiBbYHVuZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG8pLlxuLSBNb2QteSAoTW9kLVNoaWZ0LXogb24gbWFjT1MpICsgQ3RybC1TaGlmdC16IG9uIExpbnV4OiBbYHJlZG9gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG8pLlxuLSBNb2QtdTogW2B1bmRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvU2VsZWN0aW9uKS5cbi0gQWx0LXUgKE1vZC1TaGlmdC11IG9uIG1hY09TKTogW2ByZWRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvU2VsZWN0aW9uKS5cbiovXG5jb25zdCBoaXN0b3J5S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIk1vZC16XCIsIHJ1bjogdW5kbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QteVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbGludXg6IFwiQ3RybC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtdVwiLCBydW46IHVuZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQWx0LXVcIiwgbWFjOiBcIk1vZC1TaGlmdC11XCIsIHJ1bjogcmVkb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXTtcblxuZnVuY3Rpb24gdXBkYXRlU2VsKHNlbCwgYnkpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLm1hcChieSksIHNlbC5tYWluSW5kZXgpO1xufVxuZnVuY3Rpb24gc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pO1xufVxuZnVuY3Rpb24gbW92ZVNlbCh7IHN0YXRlLCBkaXNwYXRjaCB9LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgaG93KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gcmFuZ2UudG8gOiByYW5nZS5mcm9tKTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbmZ1bmN0aW9uIGx0ckF0Q3Vyc29yKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy50ZXh0RGlyZWN0aW9uQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSA9PSBEaXJlY3Rpb24uTFRSO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCAod2hpY2ggaXMgYmFja3dhcmQgaW5cbmxlZnQtdG8tcmlnaHQgdGV4dCwgZm9yd2FyZCBpbiByaWdodC10by1sZWZ0IHRleHQpLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckNoYXJSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBsZWZ0IGFjcm9zcyBvbmUgZ3JvdXAgb2Ygd29yZCBvclxubm9uLXdvcmQgKGJ1dCBhbHNvIG5vbi1zcGFjZSkgY2hhcmFjdGVycy5cbiovXG5jb25zdCBjdXJzb3JHcm91cExlZnQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBSaWdodCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgZm9yd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5mcm9tKTtcbiAgICByZXR1cm4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkLCBzdGFydCA9PiB7XG4gICAgICAgIGxldCBjYXQgPSBDaGFyQ2F0ZWdvcnkuU3BhY2UsIHBvcyA9IHJhbmdlLmZyb207XG4gICAgICAgIGxldCBkb25lID0gZmFsc2UsIHNhd1VwcGVyID0gZmFsc2UsIHNhd0xvd2VyID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGVwID0gKG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gbmV4dC5sZW5ndGggOiAtbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCksIGFoZWFkO1xuICAgICAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgICAgIGlmIChjYXQgIT0gbmV4dENhdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9Mb3dlckNhc2UoKSA9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9yd2FyZCAmJiBzYXdVcHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2F3TG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzYXdMb3dlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2F3VXBwZXIgJiYgZm9yd2FyZCAmJiBjYXRlZ29yaXplKGFoZWFkID0gdmlldy5zdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIDEpKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWhlYWQudG9Mb3dlckNhc2UoKSA9PSBhaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2F3VXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBzdGVwKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihzdGFydC5oZWFkKTtcbiAgICBsZXQgYnJhY2tldFByb3AgPSBmb3J3YXJkID8gTm9kZVByb3AuY2xvc2VkQnkgOiBOb2RlUHJvcC5vcGVuZWRCeTtcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xuICAgIC8vIG5vZGUgYWhlYWQuXG4gICAgZm9yIChsZXQgYXQgPSBzdGFydC5oZWFkOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gbWF0Y2guZW5kLnRvIDogbWF0Y2guZW5kLmZyb207XG4gICAgZWxzZVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gcGFnZUhlaWdodCh2aWV3KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZpZXcuZGVmYXVsdExpbmVIZWlnaHQsIE1hdGgubWluKHZpZXcuZG9tLmNsaWVudEhlaWdodCwgaW5uZXJIZWlnaHQpIC0gNSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VIZWlnaHQodmlldykpIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzdGFydFBvcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHNjcm9sbFJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZWZmZWN0O1xuICAgIGlmIChzdGFydFBvcyAmJiBzdGFydFBvcy50b3AgPiBzY3JvbGxSZWN0LnRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxSZWN0LmJvdHRvbSAmJlxuICAgICAgICBzdGFydFBvcy50b3AgLSBzY3JvbGxSZWN0LnRvcCA8PSB2aWV3LnNjcm9sbERPTS5zY3JvbGxIZWlnaHQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgLSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQpXG4gICAgICAgIGVmZmVjdCA9IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLm1haW4uaGVhZCwgeyB5OiBcInN0YXJ0XCIsIHlNYXJnaW46IHN0YXJ0UG9zLnRvcCAtIHNjcm9sbFJlY3QudG9wIH0pO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8sIC0xKSk7XG5mdW5jdGlvbiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgMSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmcgfHwgIW1hdGNoaW5nLmVuZClcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsZXQgaGVhZCA9IG1hdGNoaW5nLnN0YXJ0LmZyb20gPT0gcmFuZ2UuaGVhZCA/IG1hdGNoaW5nLmVuZC50byA6IG1hdGNoaW5nLmVuZC5mcm9tO1xuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodmlldywgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbCh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgaGVhZCA9IGhvdyhyYW5nZSk7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkLmhlYWQsIGhlYWQuZ29hbENvbHVtbiwgaGVhZC5iaWRpTGV2ZWwgfHwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHZpZXcuc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0QnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0LCB3aGlsZSBsZWF2aW5nXG50aGUgYW5jaG9yIGluIHBsYWNlLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhclJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIFtncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIHRvXG50aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RHcm91cExlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVVcCA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBzZWxlY3RMaW5lRG93biA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gc2VsZWN0QnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VIZWlnaHQodmlldykpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgdXAuXG4qL1xuY29uc3Qgc2VsZWN0UGFnZVVwID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VEb3duID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgcHJldmlvdXMgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVTdGFydCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUVuZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cbiovXG5jb25zdCBzZWxlY3RMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgbmV4dCBzeW50YWN0aWMgY29uc3RydWN0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXG5bcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2UpIHlvdSB1c2UgYnVpbGRzIHVwIGEgZnVsbFxuc3ludGF4IHRyZWUuXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50U3ludGF4ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHJhbmdlLmhlYWQsIDEpO1xuICAgICAgICB3aGlsZSAoISgoY29udGV4dC5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBjb250ZXh0LnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgKGNvbnRleHQudG8gPiByYW5nZS50byAmJiBjb250ZXh0LmZyb20gPD0gcmFuZ2UuZnJvbSkgfHxcbiAgICAgICAgICAgICEoKF9hID0gY29udGV4dC5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnQpKSlcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShjb250ZXh0LnRvLCBjb250ZXh0LmZyb20pO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TaW1wbGlmeSB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdoZW4gbXVsdGlwbGUgcmFuZ2VzIGFyZSBzZWxlY3RlZCxcbnJlZHVjZSBpdCB0byBpdHMgbWFpbiByYW5nZS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2VsZWN0aW9uIGlzXG5ub24tZW1wdHksIGNvbnZlcnQgaXQgdG8gYSBjdXJzb3Igc2VsZWN0aW9uLlxuKi9cbmNvbnN0IHNpbXBsaWZ5U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY3VyID0gc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3Rpb24gPSBudWxsO1xuICAgIGlmIChjdXIucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW2N1ci5tYWluXSk7XG4gICAgZWxzZSBpZiAoIWN1ci5tYWluLmVtcHR5KVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGN1ci5tYWluLmhlYWQpXSk7XG4gICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlbGV0ZUJ5KHRhcmdldCwgYnkpIHtcbiAgICBpZiAodGFyZ2V0LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGV2ZW50ID0gXCJkZWxldGUuc2VsZWN0aW9uXCIsIHsgc3RhdGUgfSA9IHRhcmdldDtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgICBsZXQgdG93YXJkcyA9IGJ5KGZyb20pO1xuICAgICAgICAgICAgaWYgKHRvd2FyZHMgPCBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5iYWNrd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG93YXJkcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmZvcndhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKGZyb20sIHRvd2FyZHMpO1xuICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgdG93YXJkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc2tpcEF0b21pYyh0YXJnZXQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgICAgIHRvID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0byA/IHsgcmFuZ2UgfSA6IHsgY2hhbmdlczogeyBmcm9tLCB0byB9LCByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogZXZlbnQsXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCBwb3MgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyksIGJlZm9yZSwgdGFyZ2V0UG9zO1xuICAgIGlmICghZm9yd2FyZCAmJiBwb3MgPiBsaW5lLmZyb20gJiYgcG9zIDwgbGluZS5mcm9tICsgMjAwICYmXG4gICAgICAgICEvW14gXFx0XS8udGVzdChiZWZvcmUgPSBsaW5lLnRleHQuc2xpY2UoMCwgcG9zIC0gbGluZS5mcm9tKSkpIHtcbiAgICAgICAgaWYgKGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMV0gPT0gXCJcXHRcIilcbiAgICAgICAgICAgIHJldHVybiBwb3MgLSAxO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oYmVmb3JlLCBzdGF0ZS50YWJTaXplKSwgZHJvcCA9IGNvbCAlIGdldEluZGVudFVuaXQoc3RhdGUpIHx8IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3AgJiYgYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxIC0gaV0gPT0gXCIgXCI7IGkrKylcbiAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICB0YXJnZXRQb3MgPSBwb3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRQb3MgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgaWYgKHRhcmdldFBvcyA9PSBwb3MgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0UG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgZm9yIGN1cnNvciBzZWxlY3Rpb25zLCB0aGUgY2hhcmFjdGVyXG5iZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyQmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVDaGFyRm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIHRydWUpO1xuY29uc3QgZGVsZXRlQnlHcm91cCA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgc3RhcnQgPT4ge1xuICAgIGxldCBwb3MgPSBzdGFydCwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgZm9yIChsZXQgY2F0ID0gbnVsbDs7KSB7XG4gICAgICAgIGlmIChwb3MgPT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IG5leHRDaGFyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHBvcywgbmV4dCkgLSBsaW5lLmZyb20sIE1hdGgubWF4KHBvcywgbmV4dCkgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xuICAgICAgICBpZiAoY2F0ICE9IG51bGwgJiYgbmV4dENhdCAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSBzdGFydClcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHBvcyA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcykudG87XG4gICAgcmV0dXJuIHBvcyA8IGxpbmVFbmQgPyBsaW5lRW5kIDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCBwb3MgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcG9zID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5saW5lQmxvY2tBdChwb3MpLmZyb207XG4gICAgcmV0dXJuIHBvcyA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHBvcyAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSBhbGwgd2hpdGVzcGFjZSBkaXJlY3RseSBiZWZvcmUgYSBsaW5lIGVuZCBmcm9tIHRoZVxuZG9jdW1lbnQuXG4qL1xuY29uc3QgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlci5saW5lQnJlYWsgfHwgaXRlci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZyA+IC0xKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcyAtIChwcmV2Lmxlbmd0aCAtIHRyYWlsaW5nKSwgdG86IHBvcyB9KTtcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcmV2ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBpdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBpdGVyLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHVzZXJFdmVudDogXCJkZWxldGVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIGVhY2ggc2VsZWN0aW9uIHJhbmdlIHdpdGggYSBsaW5lIGJyZWFrLCBsZWF2aW5nIHRoZSBjdXJzb3Jcbm9uIHRoZSBsaW5lIGJlZm9yZSB0aGUgYnJlYWsuXG4qL1xuY29uc3Qgc3BsaXRMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIlwiLCBcIlwiXSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20pIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkZsaXAgdGhlIGNoYXJhY3RlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3Vyc29yKHMpLlxuKi9cbmNvbnN0IHRyYW5zcG9zZUNoYXJzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8IHJhbmdlLmZyb20gPT0gMCB8fCByYW5nZS5mcm9tID09IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSBwb3MgPT0gbGluZS5mcm9tID8gcG9zIC0gMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gcG9zID09IGxpbmUudG8gPyBwb3MgKyAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKHBvcywgdG8pLmFwcGVuZChzdGF0ZS5kb2Muc2xpY2UoZnJvbSwgcG9zKSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcIm1vdmUuY2hhcmFjdGVyXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkge1xuICAgIGxldCBibG9ja3MgPSBbXSwgdXB0byA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSksIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKTtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiByYW5nZS50byA9PSBlbmRMaW5lLmZyb20pXG4gICAgICAgICAgICBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byAtIDEpO1xuICAgICAgICBpZiAodXB0byA+PSBzdGFydExpbmUubnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2LnRvID0gZW5kTGluZS50bztcbiAgICAgICAgICAgIHByZXYucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBmcm9tOiBzdGFydExpbmUuZnJvbSwgdG86IGVuZExpbmUudG8sIHJhbmdlczogW3JhbmdlXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB1cHRvID0gZW5kTGluZS5udW1iZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tzO1xufVxuZnVuY3Rpb24gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZCA/IGJsb2NrLnRvID09IHN0YXRlLmRvYy5sZW5ndGggOiBibG9jay5mcm9tID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmb3J3YXJkID8gYmxvY2sudG8gKyAxIDogYmxvY2suZnJvbSAtIDEpO1xuICAgICAgICBsZXQgc2l6ZSA9IG5leHRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgdG86IG5leHRMaW5lLnRvIH0sIHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBuZXh0TGluZS50ZXh0ICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuaGVhZCArIHNpemUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5hbmNob3IgLSBzaXplLCByLmhlYWQgLSBzaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgdXNlckV2ZW50OiBcIm1vdmUubGluZVwiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyB1cCBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyBkb3duIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvcHlsaW5lXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSB0b3AgY29weS5cbiovXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSBib3R0b20gY29weS5cbiovXG5jb25zdCBjb3B5TGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9KSk7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUpKS5tYXAoY2hhbmdlcyk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUubGluZVwiIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHN0YXRlLmxpbmVCcmVhayksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyk7XG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XG4gICAgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBiZWZvcmUudG8gPD0gcG9zICYmIGFmdGVyLmZyb20gPj0gcG9zICYmXG4gICAgICAgIChjbG9zZWRCeSA9IGJlZm9yZS50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSAmJiBjbG9zZWRCeS5pbmRleE9mKGFmdGVyLm5hbWUpID4gLTEgJiZcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBiZWZvcmUudG8sIHRvOiBhZnRlci5mcm9tIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgaW5kZW50IHRoZSBuZXdseSBjcmVhdGVkXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xud2lsbCBhbHNvIGRlbGV0ZSB0aGF0IHdoaXRlc3BhY2UuIFdoZW4gdGhlIGN1cnNvciBpcyBiZXR3ZWVuXG5tYXRjaGluZyBicmFja2V0cywgYW4gYWRkaXRpb25hbCBuZXdsaW5lIHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXJcbnRoZSBjdXJzb3IuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgYmxhbmssIGluZGVudGVkIGxpbmUgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS5cbiovXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGF0RW9mKVxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcbiAgICAgICAgICAgIGxldCBjeCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gL15cXHMqLy5leGVjKHN0YXRlLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0pKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gZXhwbG9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcbiAgICAgICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IFtcIlwiLCBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goaW5kZW50U3RyaW5nKHN0YXRlLCBjeC5saW5lSW5kZW50KGxpbmUuZnJvbSwgLTEpKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YoaW5zZXJ0KSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmZyb207IHBvcyA8PSByYW5nZS50bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBmKGxpbmUsIGNoYW5nZXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBhdExpbmUgPSBsaW5lLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChpbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihzcGFjZSwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBnZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXI6IFtgaW5zZXJ0TmV3bGluZUFuZEluZGVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0TmV3bGluZUFuZEluZGVudClcbiAtIEN0cmwtYSAoQ21kLWEgb24gbWFjT1MpOiBbYHNlbGVjdEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0QWxsKVxuIC0gQmFja3NwYWNlOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gRGVsZXRlOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtQmFja3NwYWNlIChBbHQtQmFja3NwYWNlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1EZWxldGUgKEFsdC1EZWxldGUgb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBGb3J3YXJkKVxuIC0gQ21kLUJhY2tzcGFjZSAobWFjT1MpOiBbYGRlbGV0ZVRvTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVTdGFydCkuXG4gLSBDbWQtRGVsZXRlIChtYWNPUyk6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpLlxuKi9cbmNvbnN0IHN0YW5kYXJkS2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd0xlZnRcIiwgbWFjOiBcIkFsdC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JHcm91cExlZnQsIHNoaWZ0OiBzZWxlY3RHcm91cExlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93TGVmdFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93UmlnaHRcIiwgbWFjOiBcIkFsdC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yR3JvdXBSaWdodCwgc2hpZnQ6IHNlbGVjdEdyb3VwUmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93VXBcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBtYWM6IFwiQ3RybC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogY3Vyc29yUGFnZVVwLCBzaGlmdDogc2VsZWN0UGFnZVVwIH0sXG4gICAgeyBrZXk6IFwiUGFnZURvd25cIiwgcnVuOiBjdXJzb3JQYWdlRG93biwgc2hpZnQ6IHNlbGVjdFBhZ2VEb3duIH0sXG4gICAgeyBrZXk6IFwiSG9tZVwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUhvbWVcIiwgcnVuOiBjdXJzb3JEb2NTdGFydCwgc2hpZnQ6IHNlbGVjdERvY1N0YXJ0IH0sXG4gICAgeyBrZXk6IFwiRW5kXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVuZFwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUFuZEluZGVudCB9LFxuICAgIHsga2V5OiBcIk1vZC1hXCIsIHJ1bjogc2VsZWN0QWxsIH0sXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkLCBzaGlmdDogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtQmFja3NwYWNlXCIsIG1hYzogXCJBbHQtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1EZWxldGVcIiwgbWFjOiBcIkFsdC1EZWxldGVcIiwgcnVuOiBkZWxldGVHcm91cEZvcndhcmQgfSxcbiAgICB7IG1hYzogXCJNb2QtQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlVG9MaW5lU3RhcnQgfSxcbiAgICB7IG1hYzogXCJNb2QtRGVsZXRlXCIsIHJ1bjogZGVsZXRlVG9MaW5lRW5kIH1cbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBFc2NhcGU6IFtgc2ltcGxpZnlTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNpbXBsaWZ5U2VsZWN0aW9uKVxuLSBDdHJsLUVudGVyIChDb21kLUVudGVyIG9uIG1hY09TKTogW2BpbnNlcnRCbGFua0xpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluc2VydEJsYW5rTGluZSlcbi0gQWx0LWwgKEN0cmwtbCBvbiBtYWNPUyk6IFtgc2VsZWN0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZSlcbi0gQ3RybC1pIChDbWQtaSBvbiBtYWNPUyk6IFtgc2VsZWN0UGFyZW50U3ludGF4YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYXJlbnRTeW50YXgpXG4tIEN0cmwtWyAoQ21kLVsgb24gbWFjT1MpOiBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpXG4tIEN0cmwtXSAoQ21kLV0gb24gbWFjT1MpOiBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpXG4tIEN0cmwtQWx0LVxcXFwgKENtZC1BbHQtXFxcXCBvbiBtYWNPUyk6IFtgaW5kZW50U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRTZWxlY3Rpb24pXG4tIFNoaWZ0LUN0cmwtayAoU2hpZnQtQ21kLWsgb24gbWFjT1MpOiBbYGRlbGV0ZUxpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmUpXG4tIFNoaWZ0LUN0cmwtXFxcXCAoU2hpZnQtQ21kLVxcXFwgb24gbWFjT1MpOiBbYGN1cnNvck1hdGNoaW5nQnJhY2tldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTWF0Y2hpbmdCcmFja2V0KVxuLSBDdHJsLS8gKENtZC0vIG9uIG1hY09TKTogW2B0b2dnbGVDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVDb21tZW50KS5cbi0gU2hpZnQtQWx0LWE6IFtgdG9nZ2xlQmxvY2tDb21tZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50b2dnbGVCbG9ja0NvbW1lbnQpLlxuKi9cbmNvbnN0IGRlZmF1bHRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFsdC1BcnJvd0xlZnRcIiwgbWFjOiBcIkN0cmwtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yU3ludGF4TGVmdCwgc2hpZnQ6IHNlbGVjdFN5bnRheExlZnQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dSaWdodFwiLCBtYWM6IFwiQ3RybC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yU3ludGF4UmlnaHQsIHNoaWZ0OiBzZWxlY3RTeW50YXhSaWdodCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1VwXCIsIHJ1bjogbW92ZUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd1VwXCIsIHJ1bjogY29weUxpbmVVcCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd0Rvd25cIiwgcnVuOiBtb3ZlTGluZURvd24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dEb3duXCIsIHJ1bjogY29weUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogc2ltcGxpZnlTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJNb2QtRW50ZXJcIiwgcnVuOiBpbnNlcnRCbGFua0xpbmUgfSxcbiAgICB7IGtleTogXCJBbHQtbFwiLCBtYWM6IFwiQ3RybC1sXCIsIHJ1bjogc2VsZWN0TGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1pXCIsIHJ1bjogc2VsZWN0UGFyZW50U3ludGF4LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1bXCIsIHJ1bjogaW5kZW50TGVzcyB9LFxuICAgIHsga2V5OiBcIk1vZC1dXCIsIHJ1bjogaW5kZW50TW9yZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BbHQtXFxcXFwiLCBydW46IGluZGVudFNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1rXCIsIHJ1bjogZGVsZXRlTGluZSB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LU1vZC1cXFxcXCIsIHJ1bjogY3Vyc29yTWF0Y2hpbmdCcmFja2V0IH0sXG4gICAgeyBrZXk6IFwiTW9kLS9cIiwgcnVuOiB0b2dnbGVDb21tZW50IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFcIiwgcnVuOiB0b2dnbGVCbG9ja0NvbW1lbnQgfVxuXS5jb25jYXQoc3RhbmRhcmRLZXltYXApO1xuLyoqXG5BIGJpbmRpbmcgdGhhdCBiaW5kcyBUYWIgdG8gW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSBhbmRcblNoaWZ0LVRhYiB0byBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpLlxuUGxlYXNlIHNlZSB0aGUgW1RhYiBleGFtcGxlXSguLi8uLi9leGFtcGxlcy90YWIvKSBiZWZvcmUgdXNpbmdcbnRoaXMuXG4qL1xuY29uc3QgaW5kZW50V2l0aFRhYiA9IHsga2V5OiBcIlRhYlwiLCBydW46IGluZGVudE1vcmUsIHNoaWZ0OiBpbmRlbnRMZXNzIH07XG5cbmV4cG9ydCB7IGJsb2NrQ29tbWVudCwgYmxvY2tVbmNvbW1lbnQsIGNvcHlMaW5lRG93biwgY29weUxpbmVVcCwgY3Vyc29yQ2hhckJhY2t3YXJkLCBjdXJzb3JDaGFyRm9yd2FyZCwgY3Vyc29yQ2hhckxlZnQsIGN1cnNvckNoYXJSaWdodCwgY3Vyc29yRG9jRW5kLCBjdXJzb3JEb2NTdGFydCwgY3Vyc29yR3JvdXBCYWNrd2FyZCwgY3Vyc29yR3JvdXBGb3J3YXJkLCBjdXJzb3JHcm91cExlZnQsIGN1cnNvckdyb3VwUmlnaHQsIGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBjdXJzb3JMaW5lQm91bmRhcnlSaWdodCwgY3Vyc29yTGluZURvd24sIGN1cnNvckxpbmVFbmQsIGN1cnNvckxpbmVTdGFydCwgY3Vyc29yTGluZVVwLCBjdXJzb3JNYXRjaGluZ0JyYWNrZXQsIGN1cnNvclBhZ2VEb3duLCBjdXJzb3JQYWdlVXAsIGN1cnNvclN1YndvcmRCYWNrd2FyZCwgY3Vyc29yU3Vid29yZEZvcndhcmQsIGN1cnNvclN5bnRheExlZnQsIGN1cnNvclN5bnRheFJpZ2h0LCBkZWZhdWx0S2V5bWFwLCBkZWxldGVDaGFyQmFja3dhcmQsIGRlbGV0ZUNoYXJGb3J3YXJkLCBkZWxldGVHcm91cEJhY2t3YXJkLCBkZWxldGVHcm91cEZvcndhcmQsIGRlbGV0ZUxpbmUsIGRlbGV0ZVRvTGluZUVuZCwgZGVsZXRlVG9MaW5lU3RhcnQsIGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSwgZW1hY3NTdHlsZUtleW1hcCwgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbmRlbnRMZXNzLCBpbmRlbnRNb3JlLCBpbmRlbnRTZWxlY3Rpb24sIGluZGVudFdpdGhUYWIsIGluc2VydEJsYW5rTGluZSwgaW5zZXJ0TmV3bGluZSwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgaW5zZXJ0VGFiLCBpbnZlcnRlZEVmZmVjdHMsIGlzb2xhdGVIaXN0b3J5LCBsaW5lQ29tbWVudCwgbGluZVVuY29tbWVudCwgbW92ZUxpbmVEb3duLCBtb3ZlTGluZVVwLCByZWRvLCByZWRvRGVwdGgsIHJlZG9TZWxlY3Rpb24sIHNlbGVjdEFsbCwgc2VsZWN0Q2hhckJhY2t3YXJkLCBzZWxlY3RDaGFyRm9yd2FyZCwgc2VsZWN0Q2hhckxlZnQsIHNlbGVjdENoYXJSaWdodCwgc2VsZWN0RG9jRW5kLCBzZWxlY3REb2NTdGFydCwgc2VsZWN0R3JvdXBCYWNrd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkLCBzZWxlY3RHcm91cExlZnQsIHNlbGVjdEdyb3VwUmlnaHQsIHNlbGVjdExpbmUsIHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgc2VsZWN0TGluZURvd24sIHNlbGVjdExpbmVFbmQsIHNlbGVjdExpbmVTdGFydCwgc2VsZWN0TGluZVVwLCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQsIHNlbGVjdFBhZ2VEb3duLCBzZWxlY3RQYWdlVXAsIHNlbGVjdFBhcmVudFN5bnRheCwgc2VsZWN0U3Vid29yZEJhY2t3YXJkLCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCwgc2VsZWN0U3ludGF4TGVmdCwgc2VsZWN0U3ludGF4UmlnaHQsIHNpbXBsaWZ5U2VsZWN0aW9uLCBzcGxpdExpbmUsIHN0YW5kYXJkS2V5bWFwLCB0b2dnbGVCbG9ja0NvbW1lbnQsIHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSwgdG9nZ2xlQ29tbWVudCwgdG9nZ2xlTGluZUNvbW1lbnQsIHRyYW5zcG9zZUNoYXJzLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9TZWxlY3Rpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HighlightStyle\": () => (/* binding */ HighlightStyle),\n/* harmony export */   \"IndentContext\": () => (/* binding */ IndentContext),\n/* harmony export */   \"LRLanguage\": () => (/* binding */ LRLanguage),\n/* harmony export */   \"Language\": () => (/* binding */ Language),\n/* harmony export */   \"LanguageDescription\": () => (/* binding */ LanguageDescription),\n/* harmony export */   \"LanguageSupport\": () => (/* binding */ LanguageSupport),\n/* harmony export */   \"ParseContext\": () => (/* binding */ ParseContext),\n/* harmony export */   \"StreamLanguage\": () => (/* binding */ StreamLanguage),\n/* harmony export */   \"StringStream\": () => (/* binding */ StringStream),\n/* harmony export */   \"TreeIndentContext\": () => (/* binding */ TreeIndentContext),\n/* harmony export */   \"bracketMatching\": () => (/* binding */ bracketMatching),\n/* harmony export */   \"bracketMatchingHandle\": () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   \"codeFolding\": () => (/* binding */ codeFolding),\n/* harmony export */   \"continuedIndent\": () => (/* binding */ continuedIndent),\n/* harmony export */   \"defaultHighlightStyle\": () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   \"defineLanguageFacet\": () => (/* binding */ defineLanguageFacet),\n/* harmony export */   \"delimitedIndent\": () => (/* binding */ delimitedIndent),\n/* harmony export */   \"ensureSyntaxTree\": () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   \"flatIndent\": () => (/* binding */ flatIndent),\n/* harmony export */   \"foldAll\": () => (/* binding */ foldAll),\n/* harmony export */   \"foldCode\": () => (/* binding */ foldCode),\n/* harmony export */   \"foldEffect\": () => (/* binding */ foldEffect),\n/* harmony export */   \"foldGutter\": () => (/* binding */ foldGutter),\n/* harmony export */   \"foldInside\": () => (/* binding */ foldInside),\n/* harmony export */   \"foldKeymap\": () => (/* binding */ foldKeymap),\n/* harmony export */   \"foldNodeProp\": () => (/* binding */ foldNodeProp),\n/* harmony export */   \"foldService\": () => (/* binding */ foldService),\n/* harmony export */   \"foldState\": () => (/* binding */ foldState),\n/* harmony export */   \"foldable\": () => (/* binding */ foldable),\n/* harmony export */   \"foldedRanges\": () => (/* binding */ foldedRanges),\n/* harmony export */   \"forceParsing\": () => (/* binding */ forceParsing),\n/* harmony export */   \"getIndentUnit\": () => (/* binding */ getIndentUnit),\n/* harmony export */   \"getIndentation\": () => (/* binding */ getIndentation),\n/* harmony export */   \"highlightingFor\": () => (/* binding */ highlightingFor),\n/* harmony export */   \"indentNodeProp\": () => (/* binding */ indentNodeProp),\n/* harmony export */   \"indentOnInput\": () => (/* binding */ indentOnInput),\n/* harmony export */   \"indentRange\": () => (/* binding */ indentRange),\n/* harmony export */   \"indentService\": () => (/* binding */ indentService),\n/* harmony export */   \"indentString\": () => (/* binding */ indentString),\n/* harmony export */   \"indentUnit\": () => (/* binding */ indentUnit),\n/* harmony export */   \"language\": () => (/* binding */ language),\n/* harmony export */   \"languageDataProp\": () => (/* binding */ languageDataProp),\n/* harmony export */   \"matchBrackets\": () => (/* binding */ matchBrackets),\n/* harmony export */   \"syntaxHighlighting\": () => (/* binding */ syntaxHighlighting),\n/* harmony export */   \"syntaxParserRunning\": () => (/* binding */ syntaxParserRunning),\n/* harmony export */   \"syntaxTree\": () => (/* binding */ syntaxTree),\n/* harmony export */   \"syntaxTreeAvailable\": () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   \"toggleFold\": () => (/* binding */ toggleFold),\n/* harmony export */   \"unfoldAll\": () => (/* binding */ unfoldAll),\n/* harmony export */   \"unfoldCode\": () => (/* binding */ unfoldCode),\n/* harmony export */   \"unfoldEffect\": () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/\nconst languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/\nfunction defineLanguageFacet(baseData) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: baseData ? values => values.concat(baseData) : undefined\n  });\n}\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/\nclass Language {\n  /**\n  Construct a language object. If you need to invoke this\n  directly, first define a data facet with\n  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n  to the language's outer syntax node.\n  */\n  constructor(\n  /**\n  The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n  used for this language.\n  */\n  data, parser, extraExtensions = [],\n  /**\n  A language name.\n  */\n  name = \"\") {\n    this.data = data;\n    this.name = name;\n    // Kludge to define EditorState.tree as a debugging helper,\n    // without the EditorState package actually knowing about\n    // languages and lezer trees.\n    if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n      get() {\n        return syntaxTree(this);\n      }\n    });\n    this.parser = parser;\n    this.extension = [language.of(this), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))].concat(extraExtensions);\n  }\n  /**\n  Query whether this language is active at the given position.\n  */\n  isActiveAt(state, pos, side = -1) {\n    return languageDataFacetAt(state, pos, side) == this.data;\n  }\n  /**\n  Find the document regions that were parsed using this language.\n  The returned regions will _include_ any nested languages rooted\n  in this language, when those exist.\n  */\n  findRegions(state) {\n    let lang = state.facet(language);\n    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{\n      from: 0,\n      to: state.doc.length\n    }];\n    if (!lang || !lang.allowsNesting) return [];\n    let result = [];\n    let explore = (tree, from) => {\n      if (tree.prop(languageDataProp) == this.data) {\n        result.push({\n          from,\n          to: from + tree.length\n        });\n        return;\n      }\n      let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n      if (mount) {\n        if (mount.tree.prop(languageDataProp) == this.data) {\n          if (mount.overlay) for (let r of mount.overlay) result.push({\n            from: r.from + from,\n            to: r.to + from\n          });else result.push({\n            from: from,\n            to: from + tree.length\n          });\n          return;\n        } else if (mount.overlay) {\n          let size = result.length;\n          explore(mount.tree, mount.overlay[0].from + from);\n          if (result.length > size) return;\n        }\n      }\n      for (let i = 0; i < tree.children.length; i++) {\n        let ch = tree.children[i];\n        if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n      }\n    };\n    explore(syntaxTree(state), 0);\n    return result;\n  }\n  /**\n  Indicates whether this language allows nested languages. The\n  default implementation returns true.\n  */\n  get allowsNesting() {\n    return true;\n  }\n}\n/**\n@internal\n*/\nLanguage.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction languageDataFacetAt(state, pos, side) {\n  let topLang = state.facet(language);\n  if (!topLang) return null;\n  let facet = topLang.data;\n  if (topLang.allowsNesting) {\n    for (let node = syntaxTree(state).topNode; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers)) facet = node.type.prop(languageDataProp) || facet;\n  }\n  return facet;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/\nclass LRLanguage extends Language {\n  constructor(data, parser, name) {\n    super(data, parser, [], name);\n    this.parser = parser;\n  }\n  /**\n  Define a language from a parser.\n  */\n  static define(spec) {\n    let data = defineLanguageFacet(spec.languageData);\n    return new LRLanguage(data, spec.parser.configure({\n      props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n    }), spec.name);\n  }\n  /**\n  Create a new instance of this language with a reconfigured\n  version of its parser and optionally a new name.\n  */\n  configure(options, name) {\n    return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n  }\n  get allowsNesting() {\n    return this.parser.hasWrappers();\n  }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/\nfunction syntaxTree(state) {\n  let field = state.field(Language.state, false);\n  return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\n  var _a;\n  let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n  if (!parse) return null;\n  let oldVieport = parse.viewport;\n  parse.updateViewport({\n    from: 0,\n    to: upto\n  });\n  let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n  parse.updateViewport(oldVieport);\n  return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/\nfunction syntaxTreeAvailable(state, upto = state.doc.length) {\n  var _a;\n  return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/\nfunction forceParsing(view, upto = view.viewport.to, timeout = 100) {\n  let success = ensureSyntaxTree(view.state, upto, timeout);\n  if (success != syntaxTree(view.state)) view.dispatch({});\n  return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/\nfunction syntaxParserRunning(view) {\n  var _a;\n  return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n// Lezer-style Input object for a Text document.\nclass DocInput {\n  constructor(doc) {\n    this.doc = doc;\n    this.cursorPos = 0;\n    this.string = \"\";\n    this.cursor = doc.iter();\n  }\n  get length() {\n    return this.doc.length;\n  }\n  syncTo(pos) {\n    this.string = this.cursor.next(pos - this.cursorPos).value;\n    this.cursorPos = pos + this.string.length;\n    return this.cursorPos - this.string.length;\n  }\n  chunk(pos) {\n    this.syncTo(pos);\n    return this.string;\n  }\n  get lineChunks() {\n    return true;\n  }\n  read(from, to) {\n    let stringStart = this.cursorPos - this.string.length;\n    if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);else return this.string.slice(from - stringStart, to - stringStart);\n  }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/\nclass ParseContext {\n  constructor(parser,\n  /**\n  The current editor state.\n  */\n  state,\n  /**\n  Tree fragments that can be reused by incremental re-parses.\n  */\n  fragments = [],\n  /**\n  @internal\n  */\n  tree,\n  /**\n  @internal\n  */\n  treeLen,\n  /**\n  The current editor viewport (or some overapproximation\n  thereof). Intended to be used for opportunistically avoiding\n  work (in which case\n  [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n  should be called to make sure the parser is restarted when the\n  skipped region becomes visible).\n  */\n  viewport,\n  /**\n  @internal\n  */\n  skipped,\n  /**\n  This is where skipping parsers can register a promise that,\n  when resolved, will schedule a new parse. It is cleared when\n  the parse worker picks up the promise. @internal\n  */\n  scheduleOn) {\n    this.parser = parser;\n    this.state = state;\n    this.fragments = fragments;\n    this.tree = tree;\n    this.treeLen = treeLen;\n    this.viewport = viewport;\n    this.skipped = skipped;\n    this.scheduleOn = scheduleOn;\n    this.parse = null;\n    /**\n    @internal\n    */\n    this.tempSkipped = [];\n  }\n  /**\n  @internal\n  */\n  static create(parser, state, viewport) {\n    return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n  }\n  startParse() {\n    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n  }\n  /**\n  @internal\n  */\n  work(until, upto) {\n    if (upto != null && upto >= this.state.doc.length) upto = undefined;\n    if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n      this.takeTree();\n      return true;\n    }\n    return this.withContext(() => {\n      var _a;\n      if (typeof until == \"number\") {\n        let endTime = Date.now() + until;\n        until = () => Date.now() > endTime;\n      }\n      if (!this.parse) this.parse = this.startParse();\n      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n      for (;;) {\n        let done = this.parse.advance();\n        if (done) {\n          this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n          this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n          this.tree = done;\n          this.parse = null;\n          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();else return true;\n        }\n        if (until()) return false;\n      }\n    });\n  }\n  /**\n  @internal\n  */\n  takeTree() {\n    let pos, tree;\n    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n      this.withContext(() => {\n        while (!(tree = this.parse.advance())) {}\n      });\n      this.treeLen = pos;\n      this.tree = tree;\n      this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n      this.parse = null;\n    }\n  }\n  withContext(f) {\n    let prev = currentContext;\n    currentContext = this;\n    try {\n      return f();\n    } finally {\n      currentContext = prev;\n    }\n  }\n  withoutTempSkipped(fragments) {\n    for (let r; r = this.tempSkipped.pop();) fragments = cutFragments(fragments, r.from, r.to);\n    return fragments;\n  }\n  /**\n  @internal\n  */\n  changes(changes, newState) {\n    let {\n      fragments,\n      tree,\n      treeLen,\n      viewport,\n      skipped\n    } = this;\n    this.takeTree();\n    if (!changes.empty) {\n      let ranges = [];\n      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({\n        fromA,\n        toA,\n        fromB,\n        toB\n      }));\n      fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n      tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n      treeLen = 0;\n      viewport = {\n        from: changes.mapPos(viewport.from, -1),\n        to: changes.mapPos(viewport.to, 1)\n      };\n      if (this.skipped.length) {\n        skipped = [];\n        for (let r of this.skipped) {\n          let from = changes.mapPos(r.from, 1),\n            to = changes.mapPos(r.to, -1);\n          if (from < to) skipped.push({\n            from,\n            to\n          });\n        }\n      }\n    }\n    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n  }\n  /**\n  @internal\n  */\n  updateViewport(viewport) {\n    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n    this.viewport = viewport;\n    let startLen = this.skipped.length;\n    for (let i = 0; i < this.skipped.length; i++) {\n      let {\n        from,\n        to\n      } = this.skipped[i];\n      if (from < viewport.to && to > viewport.from) {\n        this.fragments = cutFragments(this.fragments, from, to);\n        this.skipped.splice(i--, 1);\n      }\n    }\n    if (this.skipped.length >= startLen) return false;\n    this.reset();\n    return true;\n  }\n  /**\n  @internal\n  */\n  reset() {\n    if (this.parse) {\n      this.takeTree();\n      this.parse = null;\n    }\n  }\n  /**\n  Notify the parse scheduler that the given region was skipped\n  because it wasn't in view, and the parse should be restarted\n  when it comes into view.\n  */\n  skipUntilInView(from, to) {\n    this.skipped.push({\n      from,\n      to\n    });\n  }\n  /**\n  Returns a parser intended to be used as placeholder when\n  asynchronously loading a nested parser. It'll skip its input and\n  mark it as not-really-parsed, so that the next update will parse\n  it again.\n  \n  When `until` is given, a reparse will be scheduled when that\n  promise resolves.\n  */\n  static getSkippingParser(until) {\n    return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n      createParse(input, fragments, ranges) {\n        let from = ranges[0].from,\n          to = ranges[ranges.length - 1].to;\n        let parser = {\n          parsedPos: from,\n          advance() {\n            let cx = currentContext;\n            if (cx) {\n              for (let r of ranges) cx.tempSkipped.push(r);\n              if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;\n            }\n            this.parsedPos = to;\n            return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n          },\n          stoppedAt: null,\n          stopAt() {}\n        };\n        return parser;\n      }\n    }();\n  }\n  /**\n  @internal\n  */\n  isDone(upto) {\n    upto = Math.min(upto, this.state.doc.length);\n    let frags = this.fragments;\n    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n  }\n  /**\n  Get the context for the current parse, or `null` if no editor\n  parse is in progress.\n  */\n  static get() {\n    return currentContext;\n  }\n}\nfunction cutFragments(fragments, from, to) {\n  return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{\n    fromA: from,\n    toA: to,\n    fromB: from,\n    toB: to\n  }]);\n}\nclass LanguageState {\n  constructor(\n  // A mutable parse state that is used to preserve work done during\n  // the lifetime of a state when moving to the next state.\n  context) {\n    this.context = context;\n    this.tree = context.tree;\n  }\n  apply(tr) {\n    if (!tr.docChanged && this.tree == this.context.tree) return this;\n    let newCx = this.context.changes(tr.changes, tr.state);\n    // If the previous parse wasn't done, go forward only up to its\n    // end position or the end of the viewport, to avoid slowing down\n    // state updates with parse work beyond the viewport.\n    let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n    if (!newCx.work(20 /* Work.Apply */, upto)) newCx.takeTree();\n    return new LanguageState(newCx);\n  }\n  static init(state) {\n    let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);\n    let parseState = ParseContext.create(state.facet(language).parser, state, {\n      from: 0,\n      to: vpTo\n    });\n    if (!parseState.work(20 /* Work.Apply */, vpTo)) parseState.takeTree();\n    return new LanguageState(parseState);\n  }\n}\nLanguage.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create: LanguageState.init,\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(Language.setState)) return e.value;\n    if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n    return value.apply(tr);\n  }\n});\nlet requestIdle = callback => {\n  let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */);\n  return () => clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = callback => {\n  let idle = -1,\n    timeout = setTimeout(() => {\n      idle = requestIdleCallback(callback, {\n        timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */\n      });\n    }, 100 /* Work.MinPause */);\n  return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n  constructor(view) {\n    this.view = view;\n    this.working = null;\n    this.workScheduled = 0;\n    // End of the current time chunk\n    this.chunkEnd = -1;\n    // Milliseconds of budget left for this chunk\n    this.chunkBudget = -1;\n    this.work = this.work.bind(this);\n    this.scheduleWork();\n  }\n  update(update) {\n    let cx = this.view.state.field(Language.state).context;\n    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n    if (update.docChanged) {\n      if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */;\n      this.scheduleWork();\n    }\n    this.checkAsyncSchedule(cx);\n  }\n  scheduleWork() {\n    if (this.working) return;\n    let {\n        state\n      } = this.view,\n      field = state.field(Language.state);\n    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n  }\n  work(deadline) {\n    this.working = null;\n    let now = Date.now();\n    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n      // Start a new chunk\n      this.chunkEnd = now + 30000 /* Work.ChunkTime */;\n      this.chunkBudget = 3000 /* Work.ChunkBudget */;\n    }\n\n    if (this.chunkBudget <= 0) return; // No more budget\n    let {\n        state,\n        viewport: {\n          to: vpTo\n        }\n      } = this.view,\n      field = state.field(Language.state);\n    if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */)) return;\n    let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);\n    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n    let done = field.context.work(() => {\n      return isInputPending && isInputPending() || Date.now() > endTime;\n    }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));\n    this.chunkBudget -= Date.now() - now;\n    if (done || this.chunkBudget <= 0) {\n      field.context.takeTree();\n      this.view.dispatch({\n        effects: Language.setState.of(new LanguageState(field.context))\n      });\n    }\n    if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n    this.checkAsyncSchedule(field.context);\n  }\n  checkAsyncSchedule(cx) {\n    if (cx.scheduleOn) {\n      this.workScheduled++;\n      cx.scheduleOn.then(() => this.scheduleWork()).catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(() => this.workScheduled--);\n      cx.scheduleOn = null;\n    }\n  }\n  destroy() {\n    if (this.working) this.working();\n  }\n  isWorking() {\n    return !!(this.working || this.workScheduled > 0);\n  }\n}, {\n  eventHandlers: {\n    focus() {\n      this.scheduleWork();\n    }\n  }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/\nconst language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(languages) {\n    return languages.length ? languages[0] : null;\n  },\n  enables: language => [Language.state, parseWorker, _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([language], state => {\n    let lang = state.facet(language);\n    return lang && lang.name ? {\n      \"data-language\": lang.name\n    } : {};\n  })]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/\nclass LanguageSupport {\n  /**\n  Create a language support object.\n  */\n  constructor(\n  /**\n  The language object.\n  */\n  language,\n  /**\n  An optional set of supporting extensions. When nesting a\n  language in another language, the outer language is encouraged\n  to include the supporting extensions for its inner languages\n  in its own set of support extensions.\n  */\n  support = []) {\n    this.language = language;\n    this.support = support;\n    this.extension = [language, support];\n  }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/\nclass LanguageDescription {\n  constructor(\n  /**\n  The name of this language.\n  */\n  name,\n  /**\n  Alternative names for the mode (lowercased, includes `this.name`).\n  */\n  alias,\n  /**\n  File extensions associated with this language.\n  */\n  extensions,\n  /**\n  Optional filename pattern that should be associated with this\n  language.\n  */\n  filename, loadFunc,\n  /**\n  If the language has been loaded, this will hold its value.\n  */\n  support = undefined) {\n    this.name = name;\n    this.alias = alias;\n    this.extensions = extensions;\n    this.filename = filename;\n    this.loadFunc = loadFunc;\n    this.support = support;\n    this.loading = null;\n  }\n  /**\n  Start loading the the language. Will return a promise that\n  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n  object when the language successfully loads.\n  */\n  load() {\n    return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => {\n      this.loading = null;\n      throw err;\n    }));\n  }\n  /**\n  Create a language description.\n  */\n  static of(spec) {\n    let {\n      load,\n      support\n    } = spec;\n    if (!load) {\n      if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n      load = () => Promise.resolve(support);\n    }\n    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n  }\n  /**\n  Look for a language in the given array of descriptions that\n  matches the filename. Will first match\n  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n  and return the first language that matches.\n  */\n  static matchFilename(descs, filename) {\n    for (let d of descs) if (d.filename && d.filename.test(filename)) return d;\n    let ext = /\\.([^.]+)$/.exec(filename);\n    if (ext) for (let d of descs) if (d.extensions.indexOf(ext[1]) > -1) return d;\n    return null;\n  }\n  /**\n  Look for a language whose name or alias matches the the given\n  name (case-insensitively). If `fuzzy` is true, and no direct\n  matchs is found, this'll also search for a language whose name\n  or alias occurs in the string (for names shorter than three\n  characters, only when surrounded by non-word characters).\n  */\n  static matchLanguageName(descs, name, fuzzy = true) {\n    name = name.toLowerCase();\n    for (let d of descs) if (d.alias.some(a => a == name)) return d;\n    if (fuzzy) for (let d of descs) for (let a of d.alias) {\n      let found = name.indexOf(a);\n      if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n    }\n    return null;\n  }\n}\n\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/\nconst indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/\nconst indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine: values => {\n    if (!values.length) return \"  \";\n    let unit = values[0];\n    if (!unit || /\\S/.test(unit) || Array.from(unit).some(e => e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n    return unit;\n  }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/\nfunction getIndentUnit(state) {\n  let unit = state.facet(indentUnit);\n  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/\nfunction indentString(state, cols) {\n  let result = \"\",\n    ts = state.tabSize,\n    ch = state.facet(indentUnit)[0];\n  if (ch == \"\\t\") {\n    while (cols >= ts) {\n      result += \"\\t\";\n      cols -= ts;\n    }\n    ch = \" \";\n  }\n  for (let i = 0; i < cols; i++) result += ch;\n  return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/\nfunction getIndentation(context, pos) {\n  if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n  for (let service of context.state.facet(indentService)) {\n    let result = service(context, pos);\n    if (result !== undefined) return result;\n  }\n  let tree = syntaxTree(context.state);\n  return tree ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/\nfunction indentRange(state, from, to) {\n  let updated = Object.create(null);\n  let context = new IndentContext(state, {\n    overrideIndentation: start => {\n      var _a;\n      return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n    }\n  });\n  let changes = [];\n  for (let pos = from; pos <= to;) {\n    let line = state.doc.lineAt(pos);\n    pos = line.to + 1;\n    let indent = getIndentation(context, line.from);\n    if (indent == null) continue;\n    if (!/\\S/.test(line.text)) indent = 0;\n    let cur = /^\\s*/.exec(line.text)[0];\n    let norm = indentString(state, indent);\n    if (cur != norm) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  }\n  return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/\nclass IndentContext {\n  /**\n  Create an indent context.\n  */\n  constructor(\n  /**\n  The editor state.\n  */\n  state,\n  /**\n  @internal\n  */\n  options = {}) {\n    this.state = state;\n    this.options = options;\n    this.unit = getIndentUnit(state);\n  }\n  /**\n  Get a description of the line at the given position, taking\n  [simulated line\n  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  into account. If there is such a break at `pos`, the `bias`\n  argument determines whether the part of the line line before or\n  after the break is used.\n  */\n  lineAt(pos, bias = 1) {\n    let line = this.state.doc.lineAt(pos);\n    let {\n      simulateBreak,\n      simulateDoubleBreak\n    } = this.options;\n    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n      if (simulateDoubleBreak && simulateBreak == pos) return {\n        text: \"\",\n        from: pos\n      };else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n        text: line.text.slice(simulateBreak - line.from),\n        from: simulateBreak\n      };else return {\n        text: line.text.slice(0, simulateBreak - line.from),\n        from: line.from\n      };\n    }\n    return line;\n  }\n  /**\n  Get the text directly after `pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  textAfterPos(pos, bias = 1) {\n    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n  }\n  /**\n  Find the column for the given position.\n  */\n  column(pos, bias = 1) {\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    let result = this.countColumn(text, pos - from);\n    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n    if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n    return result;\n  }\n  /**\n  Find the column position (taking tabs into account) of the given\n  position in the given string.\n  */\n  countColumn(line, pos = line.length) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n  }\n  /**\n  Find the indentation column of the line at the given point.\n  */\n  lineIndent(pos, bias = 1) {\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    let override = this.options.overrideIndentation;\n    if (override) {\n      let overriden = override(from);\n      if (overriden > -1) return overriden;\n    }\n    return this.countColumn(text, text.search(/\\S|$/));\n  }\n  /**\n  Returns the [simulated line\n  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  for this context, if any.\n  */\n  get simulatedBreak() {\n    return this.options.simulateBreak || null;\n  }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/\nconst indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n  return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);\n}\nfunction ignoreClosed(cx) {\n  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n  let strategy = tree.type.prop(indentNodeProp);\n  if (strategy) return strategy;\n  let first = tree.firstChild,\n    close;\n  if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n    let last = tree.lastChild,\n      closed = last && close.indexOf(last.name) > -1;\n    return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n  }\n  return tree.parent == null ? topIndent : null;\n}\nfunction indentFrom(node, pos, base) {\n  for (; node; node = node.parent) {\n    let strategy = indentStrategy(node);\n    if (strategy) return strategy(TreeIndentContext.create(base, pos, node));\n  }\n  return null;\n}\nfunction topIndent() {\n  return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/\nclass TreeIndentContext extends IndentContext {\n  constructor(base,\n  /**\n  The position at which indentation is being computed.\n  */\n  pos,\n  /**\n  The syntax tree node to which the indentation strategy\n  applies.\n  */\n  node) {\n    super(base.state, base.options);\n    this.base = base;\n    this.pos = pos;\n    this.node = node;\n  }\n  /**\n  @internal\n  */\n  static create(base, pos, node) {\n    return new TreeIndentContext(base, pos, node);\n  }\n  /**\n  Get the text directly after `this.pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  get textAfter() {\n    return this.textAfterPos(this.pos);\n  }\n  /**\n  Get the indentation at the reference line for `this.node`, which\n  is the line on which it starts, unless there is a node that is\n  _not_ a parent of this node covering the start of that line. If\n  so, the line at the start of that node is tried, again skipping\n  on if it is covered by another such node.\n  */\n  get baseIndent() {\n    let line = this.state.doc.lineAt(this.node.from);\n    // Skip line starts that are covered by a sibling (or cousin, etc)\n    for (;;) {\n      let atBreak = this.node.resolve(line.from);\n      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;\n      if (isParent(atBreak, this.node)) break;\n      line = this.state.doc.lineAt(atBreak.from);\n    }\n    return this.lineIndent(line.from);\n  }\n  /**\n  Continue looking for indentations in the node's parent nodes,\n  and return the result of that.\n  */\n  continue() {\n    let parent = this.node.parent;\n    return parent ? indentFrom(parent, this.pos, this.base) : 0;\n  }\n}\nfunction isParent(parent, of) {\n  for (let cur = of; cur; cur = cur.parent) if (parent == cur) return true;\n  return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n  let tree = context.node;\n  let openToken = tree.childAfter(tree.from),\n    last = tree.lastChild;\n  if (!openToken) return null;\n  let sim = context.options.simulateBreak;\n  let openLine = context.state.doc.lineAt(openToken.from);\n  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n  for (let pos = openToken.to;;) {\n    let next = tree.childAfter(pos);\n    if (!next || next == last) return null;\n    if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n    pos = next.to;\n  }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/\nfunction delimitedIndent({\n  closing,\n  align = true,\n  units = 1\n}) {\n  return context => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n  let after = context.textAfter,\n    space = after.match(/^\\s*/)[0].length;\n  let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n  let aligned = align ? bracketedAligned(context) : null;\n  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n  return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/\nconst flatIndent = context => context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/\nfunction continuedIndent({\n  except,\n  units = 1\n} = {}) {\n  return context => {\n    let matchExcept = except && except.test(context.textAfter);\n    return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n  };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/\nfunction indentOnInput() {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of(tr => {\n    if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n    let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n    if (!rules.length) return tr;\n    let doc = tr.newDoc,\n      {\n        head\n      } = tr.newSelection.main,\n      line = doc.lineAt(head);\n    if (head > line.from + DontIndentBeyond) return tr;\n    let lineStart = doc.sliceString(line.from, head);\n    if (!rules.some(r => r.test(lineStart))) return tr;\n    let {\n        state\n      } = tr,\n      last = -1,\n      changes = [];\n    for (let {\n      head\n    } of state.selection.ranges) {\n      let line = state.doc.lineAt(head);\n      if (line.from == last) continue;\n      last = line.from;\n      let indent = getIndentation(state, line.from);\n      if (indent == null) continue;\n      let cur = /^\\s*/.exec(line.text)[0];\n      let norm = indentString(state, indent);\n      if (cur != norm) changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n    return changes.length ? [tr, {\n      changes,\n      sequential: true\n    }] : tr;\n  });\n}\n\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/\nconst foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/\nconst foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/\nfunction foldInside(node) {\n  let first = node.firstChild,\n    last = node.lastChild;\n  return first && first.to < last.from ? {\n    from: first.to,\n    to: last.type.isError ? node.to : last.from\n  } : null;\n}\nfunction syntaxFolding(state, start, end) {\n  let tree = syntaxTree(state);\n  if (tree.length < end) return null;\n  let inner = tree.resolveInner(end, 1);\n  let found = null;\n  for (let cur = inner; cur; cur = cur.parent) {\n    if (cur.to <= end || cur.from > end) continue;\n    if (found && cur.from < start) break;\n    let prop = cur.type.prop(foldNodeProp);\n    if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n      let value = prop(cur, state);\n      if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n    }\n  }\n  return found;\n}\nfunction isUnfinished(node) {\n  let ch = node.lastChild;\n  return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/\nfunction foldable(state, lineStart, lineEnd) {\n  for (let service of state.facet(foldService)) {\n    let result = service(state, lineStart, lineEnd);\n    if (result) return result;\n  }\n  return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n  let from = mapping.mapPos(range.from, 1),\n    to = mapping.mapPos(range.to, -1);\n  return from >= to ? undefined : {\n    from,\n    to\n  };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/\nconst foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n  map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/\nconst unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n  map: mapRange\n});\nfunction selectedLines(view) {\n  let lines = [];\n  for (let {\n    head\n  } of view.state.selection.ranges) {\n    if (lines.some(l => l.from <= head && l.to >= head)) continue;\n    lines.push(view.lineBlockAt(head));\n  }\n  return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/\nconst foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create() {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n  },\n  update(folded, tr) {\n    folded = folded.map(tr.changes);\n    for (let e of tr.effects) {\n      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) folded = folded.update({\n        add: [foldWidget.range(e.value.from, e.value.to)]\n      });else if (e.is(unfoldEffect)) folded = folded.update({\n        filter: (from, to) => e.value.from != from || e.value.to != to,\n        filterFrom: e.value.from,\n        filterTo: e.value.to\n      });\n    }\n    // Clear folded ranges that cover the selection head\n    if (tr.selection) {\n      let onSelection = false,\n        {\n          head\n        } = tr.selection.main;\n      folded.between(head, head, (a, b) => {\n        if (a < head && b > head) onSelection = true;\n      });\n      if (onSelection) folded = folded.update({\n        filterFrom: head,\n        filterTo: head,\n        filter: (a, b) => b <= head || a >= head\n      });\n    }\n    return folded;\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n  toJSON(folded, state) {\n    let ranges = [];\n    folded.between(0, state.doc.length, (from, to) => {\n      ranges.push(from, to);\n    });\n    return ranges;\n  },\n  fromJSON(value) {\n    if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n    let ranges = [];\n    for (let i = 0; i < value.length;) {\n      let from = value[i++],\n        to = value[i++];\n      if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n      ranges.push(foldWidget.range(from, to));\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n  }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/\nfunction foldedRanges(state) {\n  return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n  var _a;\n  let found = null;\n  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n    if (!found || found.from > from) found = {\n      from,\n      to\n    };\n  });\n  return found;\n}\nfunction foldExists(folded, from, to) {\n  let found = false;\n  folded.between(from, from, (a, b) => {\n    if (a == from && b == to) found = true;\n  });\n  return found;\n}\nfunction maybeEnable(state, other) {\n  return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\nconst foldCode = view => {\n  for (let line of selectedLines(view)) {\n    let range = foldable(view.state, line.from, line.to);\n    if (range) {\n      view.dispatch({\n        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])\n      });\n      return true;\n    }\n  }\n  return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\nconst unfoldCode = view => {\n  if (!view.state.field(foldState, false)) return false;\n  let effects = [];\n  for (let line of selectedLines(view)) {\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n  }\n  if (effects.length) view.dispatch({\n    effects\n  });\n  return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n  let lineFrom = view.state.doc.lineAt(range.from).number,\n    lineTo = view.state.doc.lineAt(range.to).number;\n  return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/\nconst foldAll = view => {\n  let {\n      state\n    } = view,\n    effects = [];\n  for (let pos = 0; pos < state.doc.length;) {\n    let line = view.lineBlockAt(pos),\n      range = foldable(state, line.from, line.to);\n    if (range) effects.push(foldEffect.of(range));\n    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n  }\n  if (effects.length) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\nconst unfoldAll = view => {\n  let field = view.state.field(foldState, false);\n  if (!field || !field.size) return false;\n  let effects = [];\n  field.between(0, view.state.doc.length, (from, to) => {\n    effects.push(unfoldEffect.of({\n      from,\n      to\n    }));\n  });\n  view.dispatch({\n    effects\n  });\n  return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n  // Look backwards through line blocks until we find a foldable region that\n  // intersects with the line\n  for (let line = lineBlock;;) {\n    let foldableRegion = foldable(view.state, line.from, line.to);\n    if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n    if (!line.from) return null;\n    line = view.lineBlockAt(line.from - 1);\n  }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/\nconst toggleFold = view => {\n  let effects = [];\n  for (let line of selectedLines(view)) {\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) {\n      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    } else {\n      let foldRange = foldableContainer(view, line);\n      if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n    }\n  }\n  if (effects.length > 0) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/\nconst foldKeymap = [{\n  key: \"Ctrl-Shift-[\",\n  mac: \"Cmd-Alt-[\",\n  run: foldCode\n}, {\n  key: \"Ctrl-Shift-]\",\n  mac: \"Cmd-Alt-]\",\n  run: unfoldCode\n}, {\n  key: \"Ctrl-Alt-[\",\n  run: foldAll\n}, {\n  key: \"Ctrl-Alt-]\",\n  run: unfoldAll\n}];\nconst defaultConfig = {\n  placeholderDOM: null,\n  placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(values) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n  }\n});\n/**\nCreate an extension that configures code folding.\n*/\nfunction codeFolding(config) {\n  let result = [foldState, baseTheme$1];\n  if (config) result.push(foldConfig.of(config));\n  return result;\n}\nconst foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n  widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    toDOM(view) {\n      let {\n          state\n        } = view,\n        conf = state.facet(foldConfig);\n      let onclick = event => {\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n          effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n      };\n      if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick);\n      let element = document.createElement(\"span\");\n      element.textContent = conf.placeholderText;\n      element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n      element.title = state.phrase(\"unfold\");\n      element.className = \"cm-foldPlaceholder\";\n      element.onclick = onclick;\n      return element;\n    }\n  }()\n});\nconst foldGutterDefaults = {\n  openText: \"⌄\",\n  closedText: \"›\",\n  markerDOM: null,\n  domEventHandlers: {},\n  foldingChanged: () => false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n  constructor(config, open) {\n    super();\n    this.config = config;\n    this.open = open;\n  }\n  eq(other) {\n    return this.config == other.config && this.open == other.open;\n  }\n  toDOM(view) {\n    if (this.config.markerDOM) return this.config.markerDOM(this.open);\n    let span = document.createElement(\"span\");\n    span.textContent = this.open ? this.config.openText : this.config.closedText;\n    span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n    return span;\n  }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\nfunction foldGutter(config = {}) {\n  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n  let canFold = new FoldMarker(fullConfig, true),\n    canUnfold = new FoldMarker(fullConfig, false);\n  let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.from = view.viewport.from;\n      this.markers = this.buildMarkers(view);\n    }\n    update(update) {\n      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n    }\n    buildMarkers(view) {\n      let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n      for (let line of view.viewportLineBlocks) {\n        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n        if (mark) builder.add(line.from, line.from, mark);\n      }\n      return builder.finish();\n    }\n  });\n  let {\n    domEventHandlers\n  } = fullConfig;\n  return [markers, (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n    class: \"cm-foldGutter\",\n    markers(view) {\n      var _a;\n      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n    },\n    initialSpacer() {\n      return new FoldMarker(fullConfig, false);\n    },\n    domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n      click: (view, line, event) => {\n        if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n          view.dispatch({\n            effects: unfoldEffect.of(folded)\n          });\n          return true;\n        }\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n          view.dispatch({\n            effects: foldEffect.of(range)\n          });\n          return true;\n        }\n        return false;\n      }\n    })\n  }), codeFolding()];\n}\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \".cm-foldPlaceholder\": {\n    backgroundColor: \"#eee\",\n    border: \"1px solid #ddd\",\n    color: \"#888\",\n    borderRadius: \".2em\",\n    margin: \"0 1px\",\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  },\n  \".cm-foldGutter span\": {\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  }\n});\n\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/\nclass HighlightStyle {\n  constructor(\n  /**\n  The tag styles used to create this highlight style.\n  */\n  specs, options) {\n    this.specs = specs;\n    let modSpec;\n    function def(spec) {\n      let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n      (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n      return cls;\n    }\n    const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n    const scopeOpt = options.scope;\n    this.scope = scopeOpt instanceof Language ? type => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? type => type == scopeOpt : undefined;\n    this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map(style => ({\n      tag: style.tag,\n      class: style.class || def(Object.assign({}, style, {\n        tag: null\n      }))\n    })), {\n      all\n    }).style;\n    this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n    this.themeType = options.themeType;\n  }\n  /**\n  Create a highlighter style that associates the given styles to\n  the given tags. The specs must be objects that hold a style tag\n  or array of tags in their `tag` property, and either a single\n  `class` property providing a static CSS class (for highlighter\n  that rely on external styling), or a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n  set of CSS properties (which define the styling for those tags).\n  \n  The CSS rules created for a highlighter will be emitted in the\n  order of the spec's properties. That means that for elements that\n  have multiple tags associated with them, styles defined further\n  down in the list will have a higher CSS precedence than styles\n  defined earlier.\n  */\n  static define(specs, options) {\n    return new HighlightStyle(specs, options || {});\n  }\n}\nconst highlighterFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(values) {\n    return values.length ? [values[0]] : null;\n  }\n});\nfunction getHighlighters(state) {\n  let main = state.facet(highlighterFacet);\n  return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/\nfunction syntaxHighlighting(highlighter, options) {\n  let ext = [treeHighlighter],\n    themeType;\n  if (highlighter instanceof HighlightStyle) {\n    if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n    themeType = highlighter.themeType;\n  }\n  if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));else if (themeType) ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme], state => {\n    return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [highlighter] : [];\n  }));else ext.push(highlighterFacet.of(highlighter));\n  return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/\nfunction highlightingFor(state, tags, scope) {\n  let highlighters = getHighlighters(state);\n  let result = null;\n  if (highlighters) for (let highlighter of highlighters) {\n    if (!highlighter.scope || scope && highlighter.scope(scope)) {\n      let cls = highlighter.style(tags);\n      if (cls) result = result ? result + \" \" + cls : cls;\n    }\n  }\n  return result;\n}\nclass TreeHighlighter {\n  constructor(view) {\n    this.markCache = Object.create(null);\n    this.tree = syntaxTree(view.state);\n    this.decorations = this.buildDeco(view, getHighlighters(view.state));\n  }\n  update(update) {\n    let tree = syntaxTree(update.state),\n      highlighters = getHighlighters(update.state);\n    let styleChange = highlighters != getHighlighters(update.startState);\n    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\n      this.decorations = this.decorations.map(update.changes);\n    } else if (tree != this.tree || update.viewportChanged || styleChange) {\n      this.tree = tree;\n      this.decorations = this.buildDeco(update.view, highlighters);\n    }\n  }\n  buildDeco(view, highlighters) {\n    if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    for (let {\n      from,\n      to\n    } of view.visibleRanges) {\n      (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style) => {\n        builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n          class: style\n        })));\n      }, from, to);\n    }\n    return builder.finish();\n  }\n}\nconst treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n  decorations: v => v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/\nconst defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([{\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n  color: \"#404740\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n  textDecoration: \"underline\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n  textDecoration: \"underline\",\n  fontWeight: \"bold\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n  fontStyle: \"italic\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n  fontWeight: \"bold\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n  textDecoration: \"line-through\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  color: \"#708\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName],\n  color: \"#219\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted],\n  color: \"#164\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted],\n  color: \"#a11\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)],\n  color: \"#e40\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  color: \"#00f\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  color: \"#30a\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace],\n  color: \"#085\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  color: \"#167\"\n}, {\n  tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName],\n  color: \"#256\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  color: \"#00c\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n  color: \"#940\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n  color: \"#f00\"\n}]);\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \"&.cm-focused .cm-matchingBracket\": {\n    backgroundColor: \"#328c8252\"\n  },\n  \"&.cm-focused .cm-nonmatchingBracket\": {\n    backgroundColor: \"#bb555544\"\n  }\n});\nconst DefaultScanDist = 10000,\n  DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist,\n      renderMatch: defaultRenderMatch\n    });\n  }\n});\nconst matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n  }),\n  nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n  });\nfunction defaultRenderMatch(match) {\n  let decorations = [];\n  let mark = match.matched ? matchingMark : nonmatchingMark;\n  decorations.push(mark.range(match.start.from, match.start.to));\n  if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n  return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create() {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n  },\n  update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    let decorations = [];\n    let config = tr.state.facet(bracketMatchingConfig);\n    for (let range of tr.state.selection.ranges) {\n      if (!range.empty) continue;\n      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n      if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [bracketMatchingState, baseTheme];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/\nconst bracketMatchingHandle = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n  let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n  if (byProp) return byProp;\n  if (node.name.length == 1) {\n    let index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n  return null;\n}\nfunction findHandle(node) {\n  let hasHandle = node.type.prop(bracketMatchingHandle);\n  return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n  let maxScanDistance = config.maxScanDistance || DefaultScanDist,\n    brackets = config.brackets || DefaultBrackets;\n  let tree = syntaxTree(state),\n    node = tree.resolveInner(pos, dir);\n  for (let cur = node; cur; cur = cur.parent) {\n    let matches = matchingNodes(cur.type, dir, brackets);\n    if (matches && cur.from < cur.to) {\n      let handle = findHandle(cur);\n      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n    }\n  }\n  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n  let parent = token.parent,\n    firstToken = {\n      from: handle.from,\n      to: handle.to\n    };\n  let depth = 0,\n    cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n        let endHandle = findHandle(cursor);\n        return {\n          start: firstToken,\n          end: endHandle ? {\n            from: endHandle.from,\n            to: endHandle.to\n          } : undefined,\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        if (depth == 0) {\n          let endHandle = findHandle(cursor);\n          return {\n            start: firstToken,\n            end: endHandle && endHandle.from < endHandle.to ? {\n              from: endHandle.from,\n              to: endHandle.to\n            } : undefined,\n            matched: false\n          };\n        }\n        depth--;\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  let bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  let startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),\n    depth = 0;\n  for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {\n    let text = iter.value;\n    if (dir < 0) distance += text.length;\n    let basePos = pos + distance * dir;\n    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n      let found = brackets.indexOf(text[pos]);\n      if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        // Closing\n        return {\n          start: startToken,\n          end: {\n            from: basePos + pos,\n            to: basePos + pos + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n    if (dir > 0) distance += text.length;\n  }\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n  let n = startValue;\n  for (let i = startIndex; i < end; i++) {\n    if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;else n++;\n  }\n  return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n  /**\n  Create a stream.\n  */\n  constructor(\n  /**\n  The line.\n  */\n  string, tabSize,\n  /**\n  The current indent unit size.\n  */\n  indentUnit, overrideIndent) {\n    this.string = string;\n    this.tabSize = tabSize;\n    this.indentUnit = indentUnit;\n    this.overrideIndent = overrideIndent;\n    /**\n    The current position on the line.\n    */\n    this.pos = 0;\n    /**\n    The start position of the current token.\n    */\n    this.start = 0;\n    this.lastColumnPos = 0;\n    this.lastColumnValue = 0;\n  }\n  /**\n  True if we are at the end of the line.\n  */\n  eol() {\n    return this.pos >= this.string.length;\n  }\n  /**\n  True if we are at the start of the line.\n  */\n  sol() {\n    return this.pos == 0;\n  }\n  /**\n  Get the next code unit after the current position, or undefined\n  if we're at the end of the line.\n  */\n  peek() {\n    return this.string.charAt(this.pos) || undefined;\n  }\n  /**\n  Read the next code unit and advance `this.pos`.\n  */\n  next() {\n    if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n  }\n  /**\n  Match the next character against the given string, regular\n  expression, or predicate. Consume and return it if it matches.\n  */\n  eat(match) {\n    let ch = this.string.charAt(this.pos);\n    let ok;\n    if (typeof match == \"string\") ok = ch == match;else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  }\n  /**\n  Continue matching characters that match the given string,\n  regular expression, or predicate function. Return true if any\n  characters were consumed.\n  */\n  eatWhile(match) {\n    let start = this.pos;\n    while (this.eat(match)) {}\n    return this.pos > start;\n  }\n  /**\n  Consume whitespace ahead of `this.pos`. Return true if any was\n  found.\n  */\n  eatSpace() {\n    let start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  }\n  /**\n  Move to the end of the line.\n  */\n  skipToEnd() {\n    this.pos = this.string.length;\n  }\n  /**\n  Move to directly before the given character, if found on the\n  current line.\n  */\n  skipTo(ch) {\n    let found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  }\n  /**\n  Move back `n` characters.\n  */\n  backUp(n) {\n    this.pos -= n;\n  }\n  /**\n  Get the column position at `this.pos`.\n  */\n  column() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue;\n  }\n  /**\n  Get the indentation column of the current line.\n  */\n  indentation() {\n    var _a;\n    return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n  }\n  /**\n  Match the input against the given string or regular expression\n  (which should start with a `^`). Return true or the regexp match\n  if it matches.\n  \n  Unless `consume` is set to `false`, this will move `this.pos`\n  past the matched text.\n  \n  When matching a string `caseInsensitive` can be set to true to\n  make the match case-insensitive.\n  */\n  match(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      let cased = str => caseInsensitive ? str.toLowerCase() : str;\n      let substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      } else return null;\n    } else {\n      let match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  }\n  /**\n  Get the current token.\n  */\n  current() {\n    return this.string.slice(this.start, this.pos);\n  }\n}\nfunction fullParser(spec) {\n  return {\n    name: spec.name || \"\",\n    token: spec.token,\n    blankLine: spec.blankLine || (() => {}),\n    startState: spec.startState || (() => true),\n    copyState: spec.copyState || defaultCopyState,\n    indent: spec.indent || (() => null),\n    languageData: spec.languageData || {},\n    tokenTable: spec.tokenTable || noTokens\n  };\n}\nfunction defaultCopyState(state) {\n  if (typeof state != \"object\") return state;\n  let newState = {};\n  for (let prop in state) {\n    let val = state[prop];\n    newState[prop] = val instanceof Array ? val.slice() : val;\n  }\n  return newState;\n}\nconst IndentedFrom = /*@__PURE__*/new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/\nclass StreamLanguage extends Language {\n  constructor(parser) {\n    let data = defineLanguageFacet(parser.languageData);\n    let p = fullParser(parser),\n      self;\n    let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n      createParse(input, fragments, ranges) {\n        return new Parse(self, input, fragments, ranges);\n      }\n    }();\n    super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);\n    this.topNode = docID(data);\n    self = this;\n    this.streamParser = p;\n    this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n      perNode: true\n    });\n    this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n  }\n  /**\n  Define a stream language.\n  */\n  static define(spec) {\n    return new StreamLanguage(spec);\n  }\n  getIndent(cx, pos) {\n    let tree = syntaxTree(cx.state),\n      at = tree.resolve(pos);\n    while (at && at.type != this.topNode) at = at.parent;\n    if (!at) return null;\n    let from = undefined;\n    let {\n      overrideIndentation\n    } = cx.options;\n    if (overrideIndentation) {\n      from = IndentedFrom.get(cx.state);\n      if (from != null && from < pos - 1e4) from = undefined;\n    }\n    let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos),\n      statePos,\n      state;\n    if (start) {\n      state = start.state;\n      statePos = start.pos + 1;\n    } else {\n      state = this.streamParser.startState(cx.unit);\n      statePos = 0;\n    }\n    if (pos - statePos > 10000 /* C.MaxIndentScanDist */) return null;\n    while (statePos < pos) {\n      let line = cx.state.doc.lineAt(statePos),\n        end = Math.min(pos, line.to);\n      if (line.length) {\n        let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n        let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n        while (stream.pos < end - line.from) readToken(this.streamParser.token, stream, state);\n      } else {\n        this.streamParser.blankLine(state, cx.unit);\n      }\n      if (end == pos) break;\n      statePos = line.to + 1;\n    }\n    let line = cx.lineAt(pos);\n    if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n    return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n  }\n  get allowsNesting() {\n    return false;\n  }\n}\nfunction findState(lang, tree, off, startPos, before) {\n  let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n  if (state) return {\n    state: lang.streamParser.copyState(state),\n    pos: off + tree.length\n  };\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let child = tree.children[i],\n      pos = off + tree.positions[i];\n    let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n    if (found) return found;\n  }\n  return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n  if (inside && from <= 0 && to >= tree.length) return tree;\n  if (!inside && tree.type == lang.topNode) inside = true;\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let pos = tree.positions[i],\n      child = tree.children[i],\n      inner;\n    if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n      return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n    }\n  }\n  return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n  for (let f of fragments) {\n    let from = f.from + (f.openStart ? 25 : 0),\n      to = f.to - (f.openEnd ? 25 : 0);\n    let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to),\n      tree;\n    if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n      state: found.state,\n      tree\n    };\n  }\n  return {\n    state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n    tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n  };\n}\nclass Parse {\n  constructor(lang, input, fragments, ranges) {\n    this.lang = lang;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.stoppedAt = null;\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.rangeIndex = 0;\n    this.to = ranges[ranges.length - 1].to;\n    let context = ParseContext.get(),\n      from = ranges[0].from;\n    let {\n      state,\n      tree\n    } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n    this.state = state;\n    this.parsedPos = this.chunkStart = from + tree.length;\n    for (let i = 0; i < tree.children.length; i++) {\n      this.chunks.push(tree.children[i]);\n      this.chunkPos.push(tree.positions[i]);\n    }\n    if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */) {\n      this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n      context.skipUntilInView(this.parsedPos, context.viewport.from);\n      this.parsedPos = context.viewport.from;\n    }\n    this.moveRangeIndex();\n  }\n  advance() {\n    let context = ParseContext.get();\n    let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n    let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);\n    if (context) end = Math.min(end, context.viewport.to);\n    while (this.parsedPos < end) this.parseLine(context);\n    if (this.chunkStart < this.parsedPos) this.finishChunk();\n    if (this.parsedPos >= parseEnd) return this.finish();\n    if (context && this.parsedPos >= context.viewport.to) {\n      context.skipUntilInView(this.parsedPos, parseEnd);\n      return this.finish();\n    }\n    return null;\n  }\n  stopAt(pos) {\n    this.stoppedAt = pos;\n  }\n  lineAfter(pos) {\n    let chunk = this.input.chunk(pos);\n    if (!this.input.lineChunks) {\n      let eol = chunk.indexOf(\"\\n\");\n      if (eol > -1) chunk = chunk.slice(0, eol);\n    } else if (chunk == \"\\n\") {\n      chunk = \"\";\n    }\n    return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n  }\n  nextLine() {\n    let from = this.parsedPos,\n      line = this.lineAfter(from),\n      end = from + line.length;\n    for (let index = this.rangeIndex;;) {\n      let rangeEnd = this.ranges[index].to;\n      if (rangeEnd >= end) break;\n      line = line.slice(0, rangeEnd - (end - line.length));\n      index++;\n      if (index == this.ranges.length) break;\n      let rangeStart = this.ranges[index].from;\n      let after = this.lineAfter(rangeStart);\n      line += after;\n      end = rangeStart + after.length;\n    }\n    return {\n      line,\n      end\n    };\n  }\n  skipGapsTo(pos, offset, side) {\n    for (;;) {\n      let end = this.ranges[this.rangeIndex].to,\n        offPos = pos + offset;\n      if (side > 0 ? end > offPos : end >= offPos) break;\n      let start = this.ranges[++this.rangeIndex].from;\n      offset += start - end;\n    }\n    return offset;\n  }\n  moveRangeIndex() {\n    while (this.ranges[this.rangeIndex].to < this.parsedPos) this.rangeIndex++;\n  }\n  emitToken(id, from, to, size, offset) {\n    if (this.ranges.length > 1) {\n      offset = this.skipGapsTo(from, offset, 1);\n      from += offset;\n      let len0 = this.chunk.length;\n      offset = this.skipGapsTo(to, offset, -1);\n      to += offset;\n      size += this.chunk.length - len0;\n    }\n    this.chunk.push(id, from, to, size);\n    return offset;\n  }\n  parseLine(context) {\n    let {\n        line,\n        end\n      } = this.nextLine(),\n      offset = 0,\n      {\n        streamParser\n      } = this.lang;\n    let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n    if (stream.eol()) {\n      streamParser.blankLine(this.state, stream.indentUnit);\n    } else {\n      while (!stream.eol()) {\n        let token = readToken(streamParser.token, stream, this.state);\n        if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n        if (stream.start > 10000 /* C.MaxLineLength */) break;\n      }\n    }\n    this.parsedPos = end;\n    this.moveRangeIndex();\n    if (this.parsedPos < this.to) this.parsedPos++;\n  }\n  finishChunk() {\n    let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n      buffer: this.chunk,\n      start: this.chunkStart,\n      length: this.parsedPos - this.chunkStart,\n      nodeSet,\n      topID: 0,\n      maxBufferLength: 2048 /* C.ChunkSize */,\n      reused: this.chunkReused\n    });\n    tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n    this.chunks.push(tree);\n    this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.chunkStart = this.parsedPos;\n  }\n  finish() {\n    return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n  }\n}\nfunction readToken(token, stream, state) {\n  stream.start = stream.pos;\n  for (let i = 0; i < 10; i++) {\n    let result = token(stream, state);\n    if (stream.pos > stream.start) return result;\n  }\n  throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/Object.create(null);\nconst typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];\nconst nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\nconst defaultTable = /*@__PURE__*/Object.create(null);\nfor (let [legacyName, name] of [[\"variable\", \"variableName\"], [\"variable-2\", \"variableName.special\"], [\"string-2\", \"string.special\"], [\"def\", \"variableName.definition\"], [\"tag\", \"tagName\"], [\"attribute\", \"attributeName\"], [\"type\", \"typeName\"], [\"builtin\", \"variableName.standard\"], [\"qualifier\", \"modifier\"], [\"error\", \"invalid\"], [\"header\", \"heading\"], [\"property\", \"propertyName\"]]) defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\nclass TokenTable {\n  constructor(extra) {\n    this.extra = extra;\n    this.table = Object.assign(Object.create(null), defaultTable);\n  }\n  resolve(tag) {\n    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n  }\n}\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n  if (warned.indexOf(part) > -1) return;\n  warned.push(part);\n  console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n  let tag = null;\n  for (let part of tagStr.split(\".\")) {\n    let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n    if (!value) {\n      warnForPart(part, `Unknown highlighting tag ${part}`);\n    } else if (typeof value == \"function\") {\n      if (!tag) warnForPart(part, `Modifier ${part} used at start of tag`);else tag = value(tag);\n    } else {\n      if (tag) warnForPart(part, `Tag ${part} used as modifier`);else tag = value;\n    }\n  }\n  if (!tag) return 0;\n  let name = tagStr.replace(/ /g, \"_\"),\n    type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n      id: typeArray.length,\n      name,\n      props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n        [name]: tag\n      })]\n    });\n  typeArray.push(type);\n  return type.id;\n}\nfunction docID(data) {\n  let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n    id: typeArray.length,\n    name: \"Document\",\n    props: [languageDataProp.add(() => data)]\n  });\n  typeArray.push(type);\n  return type;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmd1YWdlL2Rpc3QvaW5kZXguanM/Y2FhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCwgSXRlck1vZGUsIFRyZWUsIFRyZWVGcmFnbWVudCwgUGFyc2VyLCBOb2RlVHlwZSwgTm9kZVNldCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBFZGl0b3JTdGF0ZSwgY291bnRDb2x1bW4sIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIEVkaXRvclZpZXcsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGd1dHRlciwgR3V0dGVyTWFya2VyIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyB0YWdzLCB0YWdIaWdobGlnaHRlciwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5cbnZhciBfYTtcbi8qKlxuTm9kZSBwcm9wIHN0b3JlZCBpbiBhIHBhcnNlcidzIHRvcCBzeW50YXggbm9kZSB0byBwcm92aWRlIHRoZVxuZmFjZXQgdGhhdCBzdG9yZXMgbGFuZ3VhZ2Utc3BlY2lmaWMgZGF0YSBmb3IgdGhhdCBsYW5ndWFnZS5cbiovXG5jb25zdCBsYW5ndWFnZURhdGFQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdG8gZGVmaW5lIGEgZmFjZXQgKHRvIGJlIGFkZGVkIHRvIHRoZSB0b3Agc3ludGF4XG5ub2RlKHMpIGZvciBhIGxhbmd1YWdlIHZpYVxuW2BsYW5ndWFnZURhdGFQcm9wYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZURhdGFQcm9wKSksIHRoYXQgd2lsbCBiZVxudXNlZCB0byBhc3NvY2lhdGUgbGFuZ3VhZ2UgZGF0YSB3aXRoIHRoZSBsYW5ndWFnZS4gWW91XG5wcm9iYWJseSBvbmx5IG5lZWQgdGhpcyB3aGVuIHN1YmNsYXNzaW5nXG5bYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkuXG4qL1xuZnVuY3Rpb24gZGVmaW5lTGFuZ3VhZ2VGYWNldChiYXNlRGF0YSkge1xuICAgIHJldHVybiBGYWNldC5kZWZpbmUoe1xuICAgICAgICBjb21iaW5lOiBiYXNlRGF0YSA/IHZhbHVlcyA9PiB2YWx1ZXMuY29uY2F0KGJhc2VEYXRhKSA6IHVuZGVmaW5lZFxuICAgIH0pO1xufVxuLyoqXG5BIGxhbmd1YWdlIG9iamVjdCBtYW5hZ2VzIHBhcnNpbmcgYW5kIHBlci1sYW5ndWFnZVxuW21ldGFkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS4gUGFyc2UgZGF0YSBpc1xubWFuYWdlZCBhcyBhIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldCkgdHJlZS4gVGhlIGNsYXNzXG5jYW4gYmUgdXNlZCBkaXJlY3RseSwgdmlhIHRoZSBbYExSTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxSTGFuZ3VhZ2UpXG5zdWJjbGFzcyBmb3IgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0LykgTFIgcGFyc2Vycywgb3JcbnZpYSB0aGUgW2BTdHJlYW1MYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtTGFuZ3VhZ2UpIHN1YmNsYXNzXG5mb3Igc3RyZWFtIHBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIGxhbmd1YWdlIG9iamVjdC4gSWYgeW91IG5lZWQgdG8gaW52b2tlIHRoaXNcbiAgICBkaXJlY3RseSwgZmlyc3QgZGVmaW5lIGEgZGF0YSBmYWNldCB3aXRoXG4gICAgW2BkZWZpbmVMYW5ndWFnZUZhY2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZpbmVMYW5ndWFnZUZhY2V0KSwgYW5kIHRoZW5cbiAgICBjb25maWd1cmUgeW91ciBwYXJzZXIgdG8gW2F0dGFjaF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZURhdGFQcm9wKSBpdFxuICAgIHRvIHRoZSBsYW5ndWFnZSdzIG91dGVyIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIFtsYW5ndWFnZSBkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBmYWNldFxuICAgIHVzZWQgZm9yIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBkYXRhLCBwYXJzZXIsIGV4dHJhRXh0ZW5zaW9ucyA9IFtdLCBcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIG5hbWUuXG4gICAgKi9cbiAgICBuYW1lID0gXCJcIikge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAvLyBLbHVkZ2UgdG8gZGVmaW5lIEVkaXRvclN0YXRlLnRyZWUgYXMgYSBkZWJ1Z2dpbmcgaGVscGVyLFxuICAgICAgICAvLyB3aXRob3V0IHRoZSBFZGl0b3JTdGF0ZSBwYWNrYWdlIGFjdHVhbGx5IGtub3dpbmcgYWJvdXRcbiAgICAgICAgLy8gbGFuZ3VhZ2VzIGFuZCBsZXplciB0cmVlcy5cbiAgICAgICAgaWYgKCFFZGl0b3JTdGF0ZS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJ0cmVlXCIpKVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVkaXRvclN0YXRlLnByb3RvdHlwZSwgXCJ0cmVlXCIsIHsgZ2V0KCkgeyByZXR1cm4gc3ludGF4VHJlZSh0aGlzKTsgfSB9KTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gW1xuICAgICAgICAgICAgbGFuZ3VhZ2Uub2YodGhpcyksXG4gICAgICAgICAgICBFZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEub2YoKHN0YXRlLCBwb3MsIHNpZGUpID0+IHN0YXRlLmZhY2V0KGxhbmd1YWdlRGF0YUZhY2V0QXQoc3RhdGUsIHBvcywgc2lkZSkpKVxuICAgICAgICBdLmNvbmNhdChleHRyYUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgaXMgYWN0aXZlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGlzQWN0aXZlQXQoc3RhdGUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZURhdGFGYWNldEF0KHN0YXRlLCBwb3MsIHNpZGUpID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHRyZWUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgIGlmIChtb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VudC50cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogci5mcm9tICsgZnJvbSwgdG86IHIudG8gKyBmcm9tIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUoY2gsIHRyZWUucG9zaXRpb25zW2ldICsgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV4cGxvcmUoc3ludGF4VHJlZShzdGF0ZSksIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGxhbmd1YWdlIGFsbG93cyBuZXN0ZWQgbGFuZ3VhZ2VzLiBUaGVcbiAgICBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICAqL1xuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5MYW5ndWFnZS5zZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIGxhbmd1YWdlRGF0YUZhY2V0QXQoc3RhdGUsIHBvcywgc2lkZSkge1xuICAgIGxldCB0b3BMYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgIGlmICghdG9wTGFuZylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZhY2V0ID0gdG9wTGFuZy5kYXRhO1xuICAgIGlmICh0b3BMYW5nLmFsbG93c05lc3RpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7IG5vZGU7IG5vZGUgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKVxuICAgICAgICAgICAgZmFjZXQgPSBub2RlLnR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSB8fCBmYWNldDtcbiAgICB9XG4gICAgcmV0dXJuIGZhY2V0O1xufVxuLyoqXG5BIHN1YmNsYXNzIG9mIFtgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBmb3IgdXNlIHdpdGggTGV6ZXJcbltMUiBwYXJzZXJzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2xyLkxSUGFyc2VyKVxucGFyc2Vycy5cbiovXG5jbGFzcyBMUkxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHBhcnNlciwgbmFtZSkge1xuICAgICAgICBzdXBlcihkYXRhLCBwYXJzZXIsIFtdLCBuYW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIGxhbmd1YWdlIGZyb20gYSBwYXJzZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHNwZWMubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKGRhdGEsIHNwZWMucGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKHR5cGUgPT4gdHlwZS5pc1RvcCA/IGRhdGEgOiB1bmRlZmluZWQpXVxuICAgICAgICB9KSwgc3BlYy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbGFuZ3VhZ2Ugd2l0aCBhIHJlY29uZmlndXJlZFxuICAgIHZlcnNpb24gb2YgaXRzIHBhcnNlciBhbmQgb3B0aW9uYWxseSBhIG5ldyBuYW1lLlxuICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKG9wdGlvbnMpLCBuYW1lIHx8IHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdGhpcy5wYXJzZXIuaGFzV3JhcHBlcnMoKTsgfVxufVxuLyoqXG5HZXQgdGhlIHN5bnRheCB0cmVlIGZvciBhIHN0YXRlLCB3aGljaCBpcyB0aGUgY3VycmVudCAocG9zc2libHlcbmluY29tcGxldGUpIHBhcnNlIHRyZWUgb2YgdGhlIGFjdGl2ZVxuW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSwgb3IgdGhlIGVtcHR5IHRyZWUgaWYgdGhlcmUgaXMgbm9cbmxhbmd1YWdlIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlKHN0YXRlKSB7XG4gICAgbGV0IGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmllbGQgPyBmaWVsZC50cmVlIDogVHJlZS5lbXB0eTtcbn1cbi8qKlxuVHJ5IHRvIGdldCBhIHBhcnNlIHRyZWUgdGhhdCBzcGFucyBhdCBsZWFzdCB1cCB0byBgdXB0b2AuIFRoZVxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcbnVwIHRvIHRoYXQgcG9pbnQgaWYgdGhlIHRyZWUgaXNuJ3QgYWxyZWFkeSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJzZSA9IChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0O1xuICAgIGlmICghcGFyc2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvbGRWaWVwb3J0ID0gcGFyc2Uudmlld3BvcnQ7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQoeyBmcm9tOiAwLCB0bzogdXB0byB9KTtcbiAgICBsZXQgcmVzdWx0ID0gcGFyc2UuaXNEb25lKHVwdG8pIHx8IHBhcnNlLndvcmsodGltZW91dCwgdXB0bykgPyBwYXJzZS50cmVlIDogbnVsbDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydChvbGRWaWVwb3J0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5RdWVyaWVzIHdoZXRoZXIgdGhlcmUgaXMgYSBmdWxsIHN5bnRheCB0cmVlIGF2YWlsYWJsZSB1cCB0byB0aGVcbmdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBJZiB0aGVyZSBpc24ndCwgdGhlIGJhY2tncm91bmQgcGFyc2VcbnByb2Nlc3MgX21pZ2h0XyBzdGlsbCBiZSB3b3JraW5nIGFuZCB1cGRhdGUgdGhlIHRyZWUgZnVydGhlciwgYnV0XG50aGVyZSBpcyBubyBndWFyYW50ZWUgb2YgdGhhdOKAlHRoZSBwYXJzZXIgd2lsbCBbc3RvcFxud29ya2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhQYXJzZXJSdW5uaW5nKSB3aGVuIGl0IGhhcyBzcGVudCBhXG5jZXJ0YWluIGFtb3VudCBvZiB0aW1lIG9yIGhhcyBtb3ZlZCBiZXlvbmQgdGhlIHZpc2libGUgdmlld3BvcnQuXG5BbHdheXMgcmV0dXJucyBmYWxzZSBpZiBubyBsYW5ndWFnZSBoYXMgYmVlbiBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWVBdmFpbGFibGUoc3RhdGUsIHVwdG8gPSBzdGF0ZS5kb2MubGVuZ3RoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQuaXNEb25lKHVwdG8pKSB8fCBmYWxzZTtcbn1cbi8qKlxuTW92ZSBwYXJzaW5nIGZvcndhcmQsIGFuZCB1cGRhdGUgdGhlIGVkaXRvciBzdGF0ZSBhZnRlcndhcmRzIHRvXG5yZWZsZWN0IHRoZSBuZXcgdHJlZS4gV2lsbCB3b3JrIGZvciBhdCBtb3N0IGB0aW1lb3V0YFxubWlsbGlzZWNvbmRzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcnNlciBtYW5hZ2VkIGdldCB0byB0aGUgZ2l2ZW5cbnBvc2l0aW9uIGluIHRoYXQgdGltZS5cbiovXG5mdW5jdGlvbiBmb3JjZVBhcnNpbmcodmlldywgdXB0byA9IHZpZXcudmlld3BvcnQudG8sIHRpbWVvdXQgPSAxMDApIHtcbiAgICBsZXQgc3VjY2VzcyA9IGVuc3VyZVN5bnRheFRyZWUodmlldy5zdGF0ZSwgdXB0bywgdGltZW91dCk7XG4gICAgaWYgKHN1Y2Nlc3MgIT0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7fSk7XG4gICAgcmV0dXJuICEhc3VjY2Vzcztcbn1cbi8qKlxuVGVsbHMgeW91IHdoZXRoZXIgdGhlIGxhbmd1YWdlIHBhcnNlciBpcyBwbGFubmluZyB0byBkbyBtb3JlXG5wYXJzaW5nIHdvcmsgKGluIGEgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHBzZXVkby10aHJlYWQpIG9yIGhhc1xuc3RvcHBlZCBydW5uaW5nLCBlaXRoZXIgYmVjYXVzZSBpdCBwYXJzZWQgdGhlIGVudGlyZSBkb2N1bWVudCxcbmJlY2F1c2UgaXQgc3BlbnQgdG9vIG11Y2ggdGltZSBhbmQgd2FzIGN1dCBvZmYsIG9yIGJlY2F1c2UgdGhlcmVcbmlzIG5vIGxhbmd1YWdlIHBhcnNlciBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFBhcnNlclJ1bm5pbmcodmlldykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBhcnNlV29ya2VyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzV29ya2luZygpKSB8fCBmYWxzZTtcbn1cbi8vIExlemVyLXN0eWxlIElucHV0IG9iamVjdCBmb3IgYSBUZXh0IGRvY3VtZW50LlxuY2xhc3MgRG9jSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSAwO1xuICAgICAgICB0aGlzLnN0cmluZyA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuZG9jLmxlbmd0aDsgfVxuICAgIHN5bmNUbyhwb3MpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSB0aGlzLmN1cnNvci5uZXh0KHBvcyAtIHRoaXMuY3Vyc29yUG9zKS52YWx1ZTtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3MgKyB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmsocG9zKSB7XG4gICAgICAgIHRoaXMuc3luY1RvKHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBsZXQgc3RyaW5nU3RhcnQgPSB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKGZyb20gPCBzdHJpbmdTdGFydCB8fCB0byA+PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tIC0gc3RyaW5nU3RhcnQsIHRvIC0gc3RyaW5nU3RhcnQpO1xuICAgIH1cbn1cbmxldCBjdXJyZW50Q29udGV4dCA9IG51bGw7XG4vKipcbkEgcGFyc2UgY29udGV4dCBwcm92aWRlZCB0byBwYXJzZXJzIHdvcmtpbmcgb24gdGhlIGVkaXRvciBjb250ZW50LlxuKi9cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVHJlZSBmcmFnbWVudHMgdGhhdCBjYW4gYmUgcmV1c2VkIGJ5IGluY3JlbWVudGFsIHJlLXBhcnNlcy5cbiAgICAqL1xuICAgIGZyYWdtZW50cyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZUxlbiwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHZpZXdwb3J0IChvciBzb21lIG92ZXJhcHByb3hpbWF0aW9uXG4gICAgdGhlcmVvZikuIEludGVuZGVkIHRvIGJlIHVzZWQgZm9yIG9wcG9ydHVuaXN0aWNhbGx5IGF2b2lkaW5nXG4gICAgd29yayAoaW4gd2hpY2ggY2FzZVxuICAgIFtgc2tpcFVudGlsSW5WaWV3YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5QYXJzZUNvbnRleHQuc2tpcFVudGlsSW5WaWV3KVxuICAgIHNob3VsZCBiZSBjYWxsZWQgdG8gbWFrZSBzdXJlIHRoZSBwYXJzZXIgaXMgcmVzdGFydGVkIHdoZW4gdGhlXG4gICAgc2tpcHBlZCByZWdpb24gYmVjb21lcyB2aXNpYmxlKS5cbiAgICAqL1xuICAgIHZpZXdwb3J0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNraXBwZWQsIFxuICAgIC8qKlxuICAgIFRoaXMgaXMgd2hlcmUgc2tpcHBpbmcgcGFyc2VycyBjYW4gcmVnaXN0ZXIgYSBwcm9taXNlIHRoYXQsXG4gICAgd2hlbiByZXNvbHZlZCwgd2lsbCBzY2hlZHVsZSBhIG5ldyBwYXJzZS4gSXQgaXMgY2xlYXJlZCB3aGVuXG4gICAgdGhlIHBhcnNlIHdvcmtlciBwaWNrcyB1cCB0aGUgcHJvbWlzZS4gQGludGVybmFsXG4gICAgKi9cbiAgICBzY2hlZHVsZU9uKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLnRyZWVMZW4gPSB0cmVlTGVuO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9IHNraXBwZWQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVPbiA9IHNjaGVkdWxlT247XG4gICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGVtcFNraXBwZWQgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHBhcnNlciwgc3RhdGUsIHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHBhcnNlciwgc3RhdGUsIFtdLCBUcmVlLmVtcHR5LCAwLCB2aWV3cG9ydCwgW10sIG51bGwpO1xuICAgIH1cbiAgICBzdGFydFBhcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZXIuc3RhcnRQYXJzZShuZXcgRG9jSW5wdXQodGhpcy5zdGF0ZS5kb2MpLCB0aGlzLmZyYWdtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd29yayh1bnRpbCwgdXB0bykge1xuICAgICAgICBpZiAodXB0byAhPSBudWxsICYmIHVwdG8gPj0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdXB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMudHJlZSAhPSBUcmVlLmVtcHR5ICYmIHRoaXMuaXNEb25lKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW50aWwgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHVudGlsO1xuICAgICAgICAgICAgICAgIHVudGlsID0gKCkgPT4gRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHVwdG8pICYmXG4gICAgICAgICAgICAgICAgdXB0byA8IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdCh1cHRvKTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUoZG9uZSwgdGhpcy5mcmFnbWVudHMsIHRoaXMucGFyc2Uuc3RvcHBlZEF0ICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gKF9hID0gdGhpcy5wYXJzZS5zdG9wcGVkQXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyZWVMZW4gPCAodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bnRpbCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRha2VUcmVlKCkge1xuICAgICAgICBsZXQgcG9zLCB0cmVlO1xuICAgICAgICBpZiAodGhpcy5wYXJzZSAmJiAocG9zID0gdGhpcy5wYXJzZS5wYXJzZWRQb3MpID49IHRoaXMudHJlZUxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiBwb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgICAgIHRoaXMud2l0aENvbnRleHQoKCkgPT4geyB3aGlsZSAoISh0cmVlID0gdGhpcy5wYXJzZS5hZHZhbmNlKCkpKSB7IH0gfSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSBwb3M7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZSh0aGlzLnRyZWUsIHRoaXMuZnJhZ21lbnRzLCB0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRoQ29udGV4dChmKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgIGN1cnJlbnRDb250ZXh0ID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHByZXY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aG91dFRlbXBTa2lwcGVkKGZyYWdtZW50cykge1xuICAgICAgICBmb3IgKGxldCByOyByID0gdGhpcy50ZW1wU2tpcHBlZC5wb3AoKTspXG4gICAgICAgICAgICBmcmFnbWVudHMgPSBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCByLmZyb20sIHIudG8pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoYW5nZXMoY2hhbmdlcywgbmV3U3RhdGUpIHtcbiAgICAgICAgbGV0IHsgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICBpZiAoIWNoYW5nZXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IHJhbmdlcy5wdXNoKHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9KSk7XG4gICAgICAgICAgICBmcmFnbWVudHMgPSBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIHRyZWUgPSBUcmVlLmVtcHR5O1xuICAgICAgICAgICAgdHJlZUxlbiA9IDA7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IHsgZnJvbTogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0bzogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpIH07XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMuc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHIuZnJvbSwgMSksIHRvID0gY2hhbmdlcy5tYXBQb3Moci50bywgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHRoaXMucGFyc2VyLCBuZXdTdGF0ZSwgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCwgdGhpcy5zY2hlZHVsZU9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1cGRhdGVWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IHZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSB2aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgc3RhcnRMZW4gPSB0aGlzLnNraXBwZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2tpcHBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuc2tpcHBlZFtpXTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdmlld3BvcnQudG8gJiYgdG8gPiB2aWV3cG9ydC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBjdXRGcmFnbWVudHModGhpcy5mcmFnbWVudHMsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBwZWQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGggPj0gc3RhcnRMZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBOb3RpZnkgdGhlIHBhcnNlIHNjaGVkdWxlciB0aGF0IHRoZSBnaXZlbiByZWdpb24gd2FzIHNraXBwZWRcbiAgICBiZWNhdXNlIGl0IHdhc24ndCBpbiB2aWV3LCBhbmQgdGhlIHBhcnNlIHNob3VsZCBiZSByZXN0YXJ0ZWRcbiAgICB3aGVuIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICAqL1xuICAgIHNraXBVbnRpbEluVmlldyhmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcGFyc2VyIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgcGxhY2Vob2xkZXIgd2hlblxuICAgIGFzeW5jaHJvbm91c2x5IGxvYWRpbmcgYSBuZXN0ZWQgcGFyc2VyLiBJdCdsbCBza2lwIGl0cyBpbnB1dCBhbmRcbiAgICBtYXJrIGl0IGFzIG5vdC1yZWFsbHktcGFyc2VkLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHBhcnNlXG4gICAgaXQgYWdhaW4uXG4gICAgXG4gICAgV2hlbiBgdW50aWxgIGlzIGdpdmVuLCBhIHJlcGFyc2Ugd2lsbCBiZSBzY2hlZHVsZWQgd2hlbiB0aGF0XG4gICAgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXRTa2lwcGluZ1BhcnNlcih1bnRpbCkge1xuICAgICAgICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzWzBdLmZyb20sIHRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VyID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRQb3M6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC50ZW1wU2tpcHBlZC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnRpbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IGN4LnNjaGVkdWxlT24gPyBQcm9taXNlLmFsbChbY3guc2NoZWR1bGVPbiwgdW50aWxdKSA6IHVudGlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRBdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0KCkgeyB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlzRG9uZSh1cHRvKSB7XG4gICAgICAgIHVwdG8gPSBNYXRoLm1pbih1cHRvLCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBsZXQgZnJhZ3MgPSB0aGlzLmZyYWdtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZUxlbiA+PSB1cHRvICYmIGZyYWdzLmxlbmd0aCAmJiBmcmFnc1swXS5mcm9tID09IDAgJiYgZnJhZ3NbMF0udG8gPj0gdXB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZXh0IGZvciB0aGUgY3VycmVudCBwYXJzZSwgb3IgYG51bGxgIGlmIG5vIGVkaXRvclxuICAgIHBhcnNlIGlzIGluIHByb2dyZXNzLlxuICAgICovXG4gICAgc3RhdGljIGdldCgpIHsgcmV0dXJuIGN1cnJlbnRDb250ZXh0OyB9XG59XG5mdW5jdGlvbiBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgW3sgZnJvbUE6IGZyb20sIHRvQTogdG8sIGZyb21COiBmcm9tLCB0b0I6IHRvIH1dKTtcbn1cbmNsYXNzIExhbmd1YWdlU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIEEgbXV0YWJsZSBwYXJzZSBzdGF0ZSB0aGF0IGlzIHVzZWQgdG8gcHJlc2VydmUgd29yayBkb25lIGR1cmluZ1xuICAgIC8vIHRoZSBsaWZldGltZSBvZiBhIHN0YXRlIHdoZW4gbW92aW5nIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50cmVlID0gY29udGV4dC50cmVlO1xuICAgIH1cbiAgICBhcHBseSh0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgdGhpcy50cmVlID09IHRoaXMuY29udGV4dC50cmVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBuZXdDeCA9IHRoaXMuY29udGV4dC5jaGFuZ2VzKHRyLmNoYW5nZXMsIHRyLnN0YXRlKTtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHBhcnNlIHdhc24ndCBkb25lLCBnbyBmb3J3YXJkIG9ubHkgdXAgdG8gaXRzXG4gICAgICAgIC8vIGVuZCBwb3NpdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB2aWV3cG9ydCwgdG8gYXZvaWQgc2xvd2luZyBkb3duXG4gICAgICAgIC8vIHN0YXRlIHVwZGF0ZXMgd2l0aCBwYXJzZSB3b3JrIGJleW9uZCB0aGUgdmlld3BvcnQuXG4gICAgICAgIGxldCB1cHRvID0gdGhpcy5jb250ZXh0LnRyZWVMZW4gPT0gdHIuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IE1hdGgubWF4KHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuY29udGV4dC50cmVlTGVuKSwgbmV3Q3gudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAoIW5ld0N4LndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdXB0bykpXG4gICAgICAgICAgICBuZXdDeC50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUobmV3Q3gpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChzdGF0ZSkge1xuICAgICAgICBsZXQgdnBUbyA9IE1hdGgubWluKDMwMDAgLyogV29yay5Jbml0Vmlld3BvcnQgKi8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBsZXQgcGFyc2VTdGF0ZSA9IFBhcnNlQ29udGV4dC5jcmVhdGUoc3RhdGUuZmFjZXQobGFuZ3VhZ2UpLnBhcnNlciwgc3RhdGUsIHsgZnJvbTogMCwgdG86IHZwVG8gfSk7XG4gICAgICAgIGlmICghcGFyc2VTdGF0ZS53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHZwVG8pKVxuICAgICAgICAgICAgcGFyc2VTdGF0ZS50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUocGFyc2VTdGF0ZSk7XG4gICAgfVxufVxuTGFuZ3VhZ2Uuc3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZTogTGFuZ3VhZ2VTdGF0ZS5pbml0LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoTGFuZ3VhZ2Uuc2V0U3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdHIuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIExhbmd1YWdlU3RhdGUuaW5pdCh0ci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0cik7XG4gICAgfVxufSk7XG5sZXQgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soKSwgNTAwIC8qIFdvcmsuTWF4UGF1c2UgKi8pO1xuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG59O1xuaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9IFwidW5kZWZpbmVkXCIpXG4gICAgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgbGV0IGlkbGUgPSAtMSwgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWRsZSA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soY2FsbGJhY2ssIHsgdGltZW91dDogNTAwIC8qIFdvcmsuTWF4UGF1c2UgKi8gLSAxMDAgLyogV29yay5NaW5QYXVzZSAqLyB9KTtcbiAgICAgICAgfSwgMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8pO1xuICAgICAgICByZXR1cm4gKCkgPT4gaWRsZSA8IDAgPyBjbGVhclRpbWVvdXQodGltZW91dCkgOiBjYW5jZWxJZGxlQ2FsbGJhY2soaWRsZSk7XG4gICAgfTtcbmNvbnN0IGlzSW5wdXRQZW5kaW5nID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmICgoX2EgPSBuYXZpZ2F0b3Iuc2NoZWR1bGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzSW5wdXRQZW5kaW5nKVxuICAgID8gKCkgPT4gbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoKSA6IG51bGw7XG5jb25zdCBwYXJzZVdvcmtlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyBQYXJzZVdvcmtlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmtTY2hlZHVsZWQgPSAwO1xuICAgICAgICAvLyBFbmQgb2YgdGhlIGN1cnJlbnQgdGltZSBjaHVua1xuICAgICAgICB0aGlzLmNodW5rRW5kID0gLTE7XG4gICAgICAgIC8vIE1pbGxpc2Vjb25kcyBvZiBidWRnZXQgbGVmdCBmb3IgdGhpcyBjaHVua1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gLTE7XG4gICAgICAgIHRoaXMud29yayA9IHRoaXMud29yay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjeCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSkuY29udGV4dDtcbiAgICAgICAgaWYgKGN4LnVwZGF0ZVZpZXdwb3J0KHVwZGF0ZS52aWV3LnZpZXdwb3J0KSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPiBjeC50cmVlTGVuKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3Lmhhc0ZvY3VzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgKz0gNTAgLyogV29yay5DaGFuZ2VCb251cyAqLztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoY3gpO1xuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSAhPSBmaWVsZC5jb250ZXh0LnRyZWUgfHwgIWZpZWxkLmNvbnRleHQuaXNEb25lKHN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nID0gcmVxdWVzdElkbGUodGhpcy53b3JrKTtcbiAgICB9XG4gICAgd29yayhkZWFkbGluZSkge1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtFbmQgPCBub3cgJiYgKHRoaXMuY2h1bmtFbmQgPCAwIHx8IHRoaXMudmlldy5oYXNGb2N1cykpIHsgLy8gU3RhcnQgYSBuZXcgY2h1bmtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtFbmQgPSBub3cgKyAzMDAwMCAvKiBXb3JrLkNodW5rVGltZSAqLztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIFdvcmsuQ2h1bmtCdWRnZXQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPD0gMClcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gbW9yZSBidWRnZXRcbiAgICAgICAgbGV0IHsgc3RhdGUsIHZpZXdwb3J0OiB7IHRvOiB2cFRvIH0gfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlID09IGZpZWxkLmNvbnRleHQudHJlZSAmJiBmaWVsZC5jb250ZXh0LmlzRG9uZSh2cFRvICsgMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIE1hdGgubWluKHRoaXMuY2h1bmtCdWRnZXQsIDEwMCAvKiBXb3JrLlNsaWNlICovLCBkZWFkbGluZSAmJiAhaXNJbnB1dFBlbmRpbmcgPyBNYXRoLm1heCgyNSAvKiBXb3JrLk1pblNsaWNlICovLCBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgLSA1KSA6IDFlOSk7XG4gICAgICAgIGxldCB2aWV3cG9ydEZpcnN0ID0gZmllbGQuY29udGV4dC50cmVlTGVuIDwgdnBUbyAmJiBzdGF0ZS5kb2MubGVuZ3RoID4gdnBUbyArIDEwMDA7XG4gICAgICAgIGxldCBkb25lID0gZmllbGQuY29udGV4dC53b3JrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0lucHV0UGVuZGluZyAmJiBpc0lucHV0UGVuZGluZygpIHx8IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICB9LCB2cFRvICsgKHZpZXdwb3J0Rmlyc3QgPyAwIDogMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpO1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0IC09IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgIGlmIChkb25lIHx8IHRoaXMuY2h1bmtCdWRnZXQgPD0gMCkge1xuICAgICAgICAgICAgZmllbGQuY29udGV4dC50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogTGFuZ3VhZ2Uuc2V0U3RhdGUub2YobmV3IExhbmd1YWdlU3RhdGUoZmllbGQuY29udGV4dCkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0ID4gMCAmJiAhKGRvbmUgJiYgIXZpZXdwb3J0Rmlyc3QpKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoZmllbGQuY29udGV4dCk7XG4gICAgfVxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xuICAgICAgICBpZiAoY3guc2NoZWR1bGVPbikge1xuICAgICAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkKys7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zY2hlZHVsZVdvcmsoKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycikpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy53b3JrU2NoZWR1bGVkLS0pO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHRoaXMud29ya2luZygpO1xuICAgIH1cbiAgICBpc1dvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHsgZm9jdXMoKSB7IHRoaXMuc2NoZWR1bGVXb3JrKCk7IH0gfVxufSk7XG4vKipcblRoZSBmYWNldCB1c2VkIHRvIGFzc29jaWF0ZSBhIGxhbmd1YWdlIHdpdGggYW4gZWRpdG9yIHN0YXRlLiBVc2VkXG5ieSBgTGFuZ3VhZ2VgIG9iamVjdCdzIGBleHRlbnNpb25gIHByb3BlcnR5IChzbyB5b3UgZG9uJ3QgbmVlZCB0b1xubWFudWFsbHkgd3JhcCB5b3VyIGxhbmd1YWdlcyBpbiB0aGlzKS4gQ2FuIGJlIHVzZWQgdG8gYWNjZXNzIHRoZVxuY3VycmVudCBsYW5ndWFnZSBvbiBhIHN0YXRlLlxuKi9cbmNvbnN0IGxhbmd1YWdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShsYW5ndWFnZXMpIHsgcmV0dXJuIGxhbmd1YWdlcy5sZW5ndGggPyBsYW5ndWFnZXNbMF0gOiBudWxsOyB9LFxuICAgIGVuYWJsZXM6IGxhbmd1YWdlID0+IFtcbiAgICAgICAgTGFuZ3VhZ2Uuc3RhdGUsXG4gICAgICAgIHBhcnNlV29ya2VyLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmNvbXB1dGUoW2xhbmd1YWdlXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgICAgICByZXR1cm4gbGFuZyAmJiBsYW5nLm5hbWUgPyB7IFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLm5hbWUgfSA6IHt9O1xuICAgICAgICB9KVxuICAgIF1cbn0pO1xuLyoqXG5UaGlzIGNsYXNzIGJ1bmRsZXMgYSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIHdpdGggYW5cbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxuZW5jb3VyYWdlZCB0byBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYVxuY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIHJldHVybnMgYSBgTGFuZ3VhZ2VTdXBwb3J0YCBpbnN0YW5jZSwgYXNcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxuKi9cbmNsYXNzIExhbmd1YWdlU3VwcG9ydCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2Ugc3VwcG9ydCBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICovXG4gICAgbGFuZ3VhZ2UsIFxuICAgIC8qKlxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXG4gICAgbGFuZ3VhZ2UgaW4gYW5vdGhlciBsYW5ndWFnZSwgdGhlIG91dGVyIGxhbmd1YWdlIGlzIGVuY291cmFnZWRcbiAgICB0byBpbmNsdWRlIHRoZSBzdXBwb3J0aW5nIGV4dGVuc2lvbnMgZm9yIGl0cyBpbm5lciBsYW5ndWFnZXNcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gW10pIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtsYW5ndWFnZSwgc3VwcG9ydF07XG4gICAgfVxufVxuLyoqXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXG5hbmQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGVtLiBUaGVpciBtYWluIHJvbGUgaXMgZmluZGluZyB0aGVcbmFwcHJvcHJpYXRlIGxhbmd1YWdlIGZvciBhIGZpbGVuYW1lIG9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgbmVzdGVkXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cbiAgICAqL1xuICAgIGFsaWFzLCBcbiAgICAvKipcbiAgICBGaWxlIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBleHRlbnNpb25zLCBcbiAgICAvKipcbiAgICBPcHRpb25hbCBmaWxlbmFtZSBwYXR0ZXJuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBmaWxlbmFtZSwgbG9hZEZ1bmMsIFxuICAgIC8qKlxuICAgIElmIHRoZSBsYW5ndWFnZSBoYXMgYmVlbiBsb2FkZWQsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubG9hZEZ1bmMgPSBsb2FkRnVuYztcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgbG9hZGluZyB0aGUgdGhlIGxhbmd1YWdlLiBXaWxsIHJldHVybiBhIHByb21pc2UgdGhhdFxuICAgIHJlc29sdmVzIHRvIGEgW2BMYW5ndWFnZVN1cHBvcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlU3VwcG9ydClcbiAgICBvYmplY3Qgd2hlbiB0aGUgbGFuZ3VhZ2Ugc3VjY2Vzc2Z1bGx5IGxvYWRzLlxuICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyB8fCAodGhpcy5sb2FkaW5nID0gdGhpcy5sb2FkRnVuYygpLnRoZW4oc3VwcG9ydCA9PiB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0LCBlcnIgPT4geyB0aGlzLmxvYWRpbmcgPSBudWxsOyB0aHJvdyBlcnI7IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2UgZGVzY3JpcHRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgb2Yoc3BlYykge1xuICAgICAgICBsZXQgeyBsb2FkLCBzdXBwb3J0IH0gPSBzcGVjO1xuICAgICAgICBpZiAoIWxvYWQpIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11c3QgcGFzcyBlaXRoZXIgJ2xvYWQnIG9yICdzdXBwb3J0JyB0byBMYW5ndWFnZURlc2NyaXB0aW9uLm9mXCIpO1xuICAgICAgICAgICAgbG9hZCA9ICgpID0+IFByb21pc2UucmVzb2x2ZShzdXBwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlRGVzY3JpcHRpb24oc3BlYy5uYW1lLCAoc3BlYy5hbGlhcyB8fCBbXSkuY29uY2F0KHNwZWMubmFtZSkubWFwKHMgPT4gcy50b0xvd2VyQ2FzZSgpKSwgc3BlYy5leHRlbnNpb25zIHx8IFtdLCBzcGVjLmZpbGVuYW1lLCBsb2FkLCBzdXBwb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVzY3JpcHRpb25zIHRoYXRcbiAgICBtYXRjaGVzIHRoZSBmaWxlbmFtZS4gV2lsbCBmaXJzdCBtYXRjaFxuICAgIFtgZmlsZW5hbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZmlsZW5hbWUpIHBhdHRlcm5zLFxuICAgIGFuZCB0aGVuIFtleHRlbnNpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZXh0ZW5zaW9ucyksXG4gICAgYW5kIHJldHVybiB0aGUgZmlyc3QgbGFuZ3VhZ2UgdGhhdCBtYXRjaGVzLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoRmlsZW5hbWUoZGVzY3MsIGZpbGVuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5maWxlbmFtZSAmJiBkLmZpbGVuYW1lLnRlc3QoZmlsZW5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBsZXQgZXh0ID0gL1xcLihbXi5dKykkLy5leGVjKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgaWYgKGQuZXh0ZW5zaW9ucy5pbmRleE9mKGV4dFsxXSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWUgb3IgYWxpYXMgbWF0Y2hlcyB0aGUgdGhlIGdpdmVuXG4gICAgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZWx5KS4gSWYgYGZ1enp5YCBpcyB0cnVlLCBhbmQgbm8gZGlyZWN0XG4gICAgbWF0Y2hzIGlzIGZvdW5kLCB0aGlzJ2xsIGFsc28gc2VhcmNoIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWVcbiAgICBvciBhbGlhcyBvY2N1cnMgaW4gdGhlIHN0cmluZyAoZm9yIG5hbWVzIHNob3J0ZXIgdGhhbiB0aHJlZVxuICAgIGNoYXJhY3RlcnMsIG9ubHkgd2hlbiBzdXJyb3VuZGVkIGJ5IG5vbi13b3JkIGNoYXJhY3RlcnMpLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoTGFuZ3VhZ2VOYW1lKGRlc2NzLCBuYW1lLCBmdXp6eSA9IHRydWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmFsaWFzLnNvbWUoYSA9PiBhID09IG5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBpZiAoZnV6enkpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgb2YgZC5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBuYW1lLmluZGV4T2YoYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xICYmIChhLmxlbmd0aCA+IDIgfHwgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCAtIDFdKSAmJiAhL1xcdy8udGVzdChuYW1lW2ZvdW5kICsgYS5sZW5ndGhdKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG5GYWNldCB0aGF0IGRlZmluZXMgYSB3YXkgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG5hcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBkZXB0aCwgYXMgYSBjb2x1bW4gbnVtYmVyIChzZWVcbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSwgYXQgdGhlIHN0YXJ0IG9mIGEgZ2l2ZW5cbmxpbmUuIEEgcmV0dXJuIHZhbHVlIG9mIGBudWxsYCBpbmRpY2F0ZXMgbm8gaW5kZW50YXRpb24gY2FuIGJlXG5kZXRlcm1pbmVkLCBhbmQgdGhlIGxpbmUgc2hvdWxkIGluaGVyaXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBvbmVcbmFib3ZlIGl0LiBBIHJldHVybiB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBkZWZlcnMgdG8gdGhlIG5leHQgaW5kZW50XG5zZXJ2aWNlLlxuKi9cbmNvbnN0IGluZGVudFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuIFNob3VsZFxuYmUgYSBzdHJpbmcgY29uc2lzdGluZyBlaXRoZXIgZW50aXJlbHkgb2YgdGhlIHNhbWUgd2hpdGVzcGFjZVxuY2hhcmFjdGVyLiBXaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCI7XG4gICAgICAgIGxldCB1bml0ID0gdmFsdWVzWzBdO1xuICAgICAgICBpZiAoIXVuaXQgfHwgL1xcUy8udGVzdCh1bml0KSB8fCBBcnJheS5mcm9tKHVuaXQpLnNvbWUoZSA9PiBlICE9IHVuaXRbMF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbMF0pKTtcbiAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxufSk7XG4vKipcblJldHVybiB0aGUgX2NvbHVtbiB3aWR0aF8gb2YgYW4gaW5kZW50IHVuaXQgaW4gdGhlIHN0YXRlLlxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxuZmFjZXQsIGFuZCBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIHdoZW4gdGhhdFxuY29udGFpbnMgdGFicy5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRVbml0KHN0YXRlKSB7XG4gICAgbGV0IHVuaXQgPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxuV2lsbCB1c2UgdGFicyBmb3IgYXMgbXVjaCBvZiB0aGUgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHRoZVxuW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBmYWNldCBjb250YWluc1xudGFicy5cbiovXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RhdGUsIGNvbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplLCBjaCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpWzBdO1xuICAgIGlmIChjaCA9PSBcIlxcdFwiKSB7XG4gICAgICAgIHdoaWxlIChjb2xzID49IHRzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGNvbHMgLT0gdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSBcIiBcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbldpbGwgZmlyc3QgY29uc3VsdCBhbnkgW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKVxudGhhdCBhcmUgcmVnaXN0ZXJlZCwgYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLFxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnROb2RlUHJvcCkgYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGFcbm51bWJlciB3aGVuIGFuIGluZGVudGF0aW9uIGNvdWxkIGJlIGRldGVybWluZWQsIGFuZCBudWxsXG5vdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgcG9zKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcbiAgICAgICAgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2YgY29udGV4dC5zdGF0ZS5mYWNldChpbmRlbnRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSk7XG4gICAgcmV0dXJuIHRyZWUgPyBzeW50YXhJbmRlbnRhdGlvbihjb250ZXh0LCB0cmVlLCBwb3MpIDogbnVsbDtcbn1cbi8qKlxuQ3JlYXRlIGEgY2hhbmdlIHNldCB0aGF0IGF1dG8taW5kZW50cyBhbGwgbGluZXMgdG91Y2hlZCBieSB0aGVcbmdpdmVuIGRvY3VtZW50IHJhbmdlLlxuKi9cbmZ1bmN0aW9uIGluZGVudFJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIGxldCB1cGRhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IG92ZXJyaWRlSW5kZW50YXRpb246IHN0YXJ0ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdXBkYXRlZFtzdGFydF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xOyB9IH0pO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0pIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbn1cbi8qKlxuSW5kZW50YXRpb24gY29udGV4dHMgYXJlIHVzZWQgd2hlbiBjYWxsaW5nIFtpbmRlbnRhdGlvblxuc2VydmljZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkuIFRoZXkgcHJvdmlkZSBoZWxwZXIgdXRpbGl0aWVzXG51c2VmdWwgaW4gaW5kZW50YXRpb24gbG9naWMsIGFuZCBjYW4gc2VsZWN0aXZlbHkgb3ZlcnJpZGUgdGhlXG5pbmRlbnRhdGlvbiByZXBvcnRlZCBmb3Igc29tZSBsaW5lcy5cbiovXG5jbGFzcyBJbmRlbnRDb250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5kZW50IGNvbnRleHQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51bml0ID0gZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgdGFraW5nXG4gICAgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGludG8gYWNjb3VudC4gSWYgdGhlcmUgaXMgc3VjaCBhIGJyZWFrIGF0IGBwb3NgLCB0aGUgYGJpYXNgXG4gICAgYXJndW1lbnQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXJ0IG9mIHRoZSBsaW5lIGxpbmUgYmVmb3JlIG9yXG4gICAgYWZ0ZXIgdGhlIGJyZWFrIGlzIHVzZWQuXG4gICAgKi9cbiAgICBsaW5lQXQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgeyBzaW11bGF0ZUJyZWFrLCBzaW11bGF0ZURvdWJsZUJyZWFrIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChzaW11bGF0ZUJyZWFrICE9IG51bGwgJiYgc2ltdWxhdGVCcmVhayA+PSBsaW5lLmZyb20gJiYgc2ltdWxhdGVCcmVhayA8PSBsaW5lLnRvKSB7XG4gICAgICAgICAgICBpZiAoc2ltdWxhdGVEb3VibGVCcmVhayAmJiBzaW11bGF0ZUJyZWFrID09IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBcIlwiLCBmcm9tOiBwb3MgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGJpYXMgPCAwID8gc2ltdWxhdGVCcmVhayA8IHBvcyA6IHNpbXVsYXRlQnJlYWsgPD0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZShzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogc2ltdWxhdGVCcmVhayB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZSgwLCBzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogbGluZS5mcm9tIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgcG9zYCwgZWl0aGVyIHRoZSBlbnRpcmUgbGluZVxuICAgIG9yIHRoZSBuZXh0IDEwMCBjaGFyYWN0ZXJzLCB3aGljaGV2ZXIgaXMgc2hvcnRlci5cbiAgICAqL1xuICAgIHRleHRBZnRlclBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhayAmJiBwb3MgPT0gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UocG9zIC0gZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHBvcyArIDEwMCAtIGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBjb2x1bW4ocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCBwb3MgLSBmcm9tKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24gPyB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbihmcm9tKSA6IC0xO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBvdmVycmlkZSAtIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gcG9zaXRpb24gKHRha2luZyB0YWJzIGludG8gYWNjb3VudCkgb2YgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGNvdW50Q29sdW1uKGxpbmUsIHBvcyA9IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb3VudENvbHVtbihsaW5lLCB0aGlzLnN0YXRlLnRhYlNpemUsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgKi9cbiAgICBsaW5lSW5kZW50KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb247XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlbiA9IG92ZXJyaWRlKGZyb20pO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlbiA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBmb3IgdGhpcyBjb250ZXh0LCBpZiBhbnkuXG4gICAgKi9cbiAgICBnZXQgc2ltdWxhdGVkQnJlYWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhayB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuQSBzeW50YXggdHJlZSBub2RlIHByb3AgdXNlZCB0byBhc3NvY2lhdGUgaW5kZW50YXRpb24gc3RyYXRlZ2llc1xud2l0aCBub2RlIHR5cGVzLiBTdWNoIGEgc3RyYXRlZ3kgaXMgYSBmdW5jdGlvbiBmcm9tIGFuIGluZGVudGF0aW9uXG5jb250ZXh0IHRvIGEgY29sdW1uIG51bWJlciAoc2VlIGFsc29cbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSBvciBudWxsLCB3aGVyZSBudWxsXG5pbmRpY2F0ZXMgdGhhdCBubyBkZWZpbml0aXZlIGluZGVudGF0aW9uIGNhbiBiZSBkZXRlcm1pbmVkLlxuKi9cbmNvbnN0IGluZGVudE5vZGVQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLy8gQ29tcHV0ZSB0aGUgaW5kZW50YXRpb24gZm9yIGEgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGUgc3ludGF4IHRyZWUuXG5mdW5jdGlvbiBzeW50YXhJbmRlbnRhdGlvbihjeCwgYXN0LCBwb3MpIHtcbiAgICByZXR1cm4gaW5kZW50RnJvbShhc3QucmVzb2x2ZUlubmVyKHBvcykuZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSwgcG9zLCBjeCk7XG59XG5mdW5jdGlvbiBpZ25vcmVDbG9zZWQoY3gpIHtcbiAgICByZXR1cm4gY3gucG9zID09IGN4Lm9wdGlvbnMuc2ltdWxhdGVCcmVhayAmJiBjeC5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWs7XG59XG5mdW5jdGlvbiBpbmRlbnRTdHJhdGVneSh0cmVlKSB7XG4gICAgbGV0IHN0cmF0ZWd5ID0gdHJlZS50eXBlLnByb3AoaW5kZW50Tm9kZVByb3ApO1xuICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgIGxldCBmaXJzdCA9IHRyZWUuZmlyc3RDaGlsZCwgY2xvc2U7XG4gICAgaWYgKGZpcnN0ICYmIChjbG9zZSA9IGZpcnN0LnR5cGUucHJvcChOb2RlUHJvcC5jbG9zZWRCeSkpKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdHJlZS5sYXN0Q2hpbGQsIGNsb3NlZCA9IGxhc3QgJiYgY2xvc2UuaW5kZXhPZihsYXN0Lm5hbWUpID4gLTE7XG4gICAgICAgIHJldHVybiBjeCA9PiBkZWxpbWl0ZWRTdHJhdGVneShjeCwgdHJ1ZSwgMSwgdW5kZWZpbmVkLCBjbG9zZWQgJiYgIWlnbm9yZUNsb3NlZChjeCkgPyBsYXN0LmZyb20gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZS5wYXJlbnQgPT0gbnVsbCA/IHRvcEluZGVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbmRlbnRGcm9tKG5vZGUsIHBvcywgYmFzZSkge1xuICAgIGZvciAoOyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgbGV0IHN0cmF0ZWd5ID0gaW5kZW50U3RyYXRlZ3kobm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoYmFzZSwgcG9zLCBub2RlKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBzeW50YXggdHJlZSBub2RlIHRvIHdoaWNoIHRoZSBpbmRlbnRhdGlvbiBzdHJhdGVneVxuICAgIGFwcGxpZXMuXG4gICAgKi9cbiAgICBub2RlKSB7XG4gICAgICAgIHN1cGVyKGJhc2Uuc3RhdGUsIGJhc2Uub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHRoaXMubm9kZS5mcm9tKTtcbiAgICAgICAgLy8gU2tpcCBsaW5lIHN0YXJ0cyB0aGF0IGFyZSBjb3ZlcmVkIGJ5IGEgc2libGluZyAob3IgY291c2luLCBldGMpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEJyZWFrID0gdGhpcy5ub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgdGhpcy5ub2RlKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQoYXRCcmVhay5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5kZW50KGxpbmUuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIGxvb2tpbmcgZm9yIGluZGVudGF0aW9ucyBpbiB0aGUgbm9kZSdzIHBhcmVudCBub2RlcyxcbiAgICBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhhdC5cbiAgICAqL1xuICAgIGNvbnRpbnVlKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHBhcmVudCA/IGluZGVudEZyb20ocGFyZW50LCB0aGlzLnBvcywgdGhpcy5iYXNlKSA6IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZClcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmZyb20gPCBsaW5lRW5kID8gb3BlblRva2VuIDogbnVsbDtcbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIoZW5kLCAxKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGN1ciA9IGlubmVyOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgaWYgKGN1ci50byA8PSBlbmQgfHwgY3VyLmZyb20gPiBlbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGN1ci5mcm9tIDwgc3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IHByb3AgPSBjdXIudHlwZS5wcm9wKGZvbGROb2RlUHJvcCk7XG4gICAgICAgIGlmIChwcm9wICYmIChjdXIudG8gPCB0cmVlLmxlbmd0aCAtIDUwIHx8IHRyZWUubGVuZ3RoID09IHN0YXRlLmRvYy5sZW5ndGggfHwgIWlzVW5maW5pc2hlZChjdXIpKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcChjdXIsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5mcm9tIDw9IGVuZCAmJiB2YWx1ZS5mcm9tID49IHN0YXJ0ICYmIHZhbHVlLnRvID4gZW5kKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaXNVbmZpbmlzaGVkKG5vZGUpIHtcbiAgICBsZXQgY2ggPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gY2ggJiYgY2gudG8gPT0gbm9kZS50byAmJiBjaC50eXBlLmlzRXJyb3I7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGxpbmUgaXMgZm9sZGFibGUuIEZpcnN0IGFza3MgYW55IGZvbGRcbnNlcnZpY2VzIHJlZ2lzdGVyZWQgdGhyb3VnaFxuW2Bmb2xkU2VydmljZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZFNlcnZpY2UpLCBhbmQgaWYgbm9uZSBvZiB0aGVtIHJldHVyblxuYSByZXN1bHQsIHRyaWVzIHRvIHF1ZXJ5IHRoZSBbZm9sZCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgb2Ygc3ludGF4IG5vZGVzIHRoYXQgY292ZXIgdGhlIGVuZFxub2YgdGhlIGxpbmUuXG4qL1xuZnVuY3Rpb24gZm9sZGFibGUoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2Ygc3RhdGUuZmFjZXQoZm9sZFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN5bnRheEZvbGRpbmcoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG59XG5mdW5jdGlvbiBtYXBSYW5nZShyYW5nZSwgbWFwcGluZykge1xuICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBQb3MocmFuZ2UuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBQb3MocmFuZ2UudG8sIC0xKTtcbiAgICByZXR1cm4gZnJvbSA+PSB0byA/IHVuZGVmaW5lZCA6IHsgZnJvbSwgdG8gfTtcbn1cbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gZm9sZCB0aGVcbmdpdmVuIHJhbmdlLiAoWW91IHByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIGluIGV4Y2VwdGlvbmFsXG5jaXJjdW1zdGFuY2Vz4oCUdXN1YWxseSB5b3UnbGwganVzdCB3YW50IHRvIGxldFxuW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpIGFuZCB0aGUgW2ZvbGRcbmd1dHRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkR3V0dGVyKSBjcmVhdGUgdGhlIHRyYW5zYWN0aW9ucy4pXG4qL1xuY29uc3QgZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCB1bmZvbGRzIHRoZSBnaXZlbiByYW5nZSAoaWYgaXQgd2FzIGZvbGRlZCkuXG4qL1xuY29uc3QgdW5mb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVzKHZpZXcpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbmVzLnNvbWUobCA9PiBsLmZyb20gPD0gaGVhZCAmJiBsLnRvID49IGhlYWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxpbmVzLnB1c2godmlldy5saW5lQmxvY2tBdChoZWFkKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHRoYXQgc3RvcmVzIHRoZSBmb2xkZWQgcmFuZ2VzIChhcyBhIFtkZWNvcmF0aW9uXG5zZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSkuIENhbiBiZSBwYXNzZWQgdG9cbltgRWRpdG9yU3RhdGUudG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIGFuZFxuW2Bmcm9tSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHRvIHNlcmlhbGl6ZSB0aGUgZm9sZFxuc3RhdGUuXG4qL1xuY29uc3QgZm9sZFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZGVkLCB0cikge1xuICAgICAgICBmb2xkZWQgPSBmb2xkZWQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKGZvbGRFZmZlY3QpICYmICFmb2xkRXhpc3RzKGZvbGRlZCwgZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKSlcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgYWRkOiBbZm9sZFdpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgZmlsdGVyOiAoZnJvbSwgdG8pID0+IGUudmFsdWUuZnJvbSAhPSBmcm9tIHx8IGUudmFsdWUudG8gIT0gdG8sXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGUudmFsdWUuZnJvbSwgZmlsdGVyVG86IGUudmFsdWUudG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgZm9sZGVkIHJhbmdlcyB0aGF0IGNvdmVyIHRoZSBzZWxlY3Rpb24gaGVhZFxuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgb25TZWxlY3Rpb24gPSBmYWxzZSwgeyBoZWFkIH0gPSB0ci5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGZvbGRlZC5iZXR3ZWVuKGhlYWQsIGhlYWQsIChhLCBiKSA9PiB7IGlmIChhIDwgaGVhZCAmJiBiID4gaGVhZClcbiAgICAgICAgICAgICAgICBvblNlbGVjdGlvbiA9IHRydWU7IH0pO1xuICAgICAgICAgICAgaWYgKG9uU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUbzogaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAoYSwgYikgPT4gYiA8PSBoZWFkIHx8IGEgPj0gaGVhZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2xkZWQ7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKSxcbiAgICB0b0pTT04oZm9sZGVkLCBzdGF0ZSkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvbGRlZC5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyByYW5nZXMucHVzaChmcm9tLCB0byk7IH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG4gICAgZnJvbUpTT04odmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggJSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlW2krK10sIHRvID0gdmFsdWVbaSsrXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goZm9sZFdpZGdldC5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChyYW5nZXMsIHRydWUpO1xuICAgIH1cbn0pO1xuLyoqXG5HZXQgYSBbcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBjb250YWluaW5nIHRoZSBmb2xkZWQgcmFuZ2VzXG5pbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZm9sZGVkUmFuZ2VzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8IFJhbmdlU2V0LmVtcHR5O1xufVxuZnVuY3Rpb24gZmluZEZvbGQoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgKF9hID0gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iZXR3ZWVuKGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5mcm9tID4gZnJvbSlcbiAgICAgICAgICAgIGZvdW5kID0geyBmcm9tLCB0byB9O1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGZvbGRFeGlzdHMoZm9sZGVkLCBmcm9tLCB0bykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGZvbGRlZC5iZXR3ZWVuKGZyb20sIGZyb20sIChhLCBiKSA9PiB7IGlmIChhID09IGZyb20gJiYgYiA9PSB0bylcbiAgICAgICAgZm91bmQgPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZShzdGF0ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgPyBvdGhlciA6IG90aGVyLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoY29kZUZvbGRpbmcoKSkpO1xufVxuLyoqXG5Gb2xkIHRoZSBsaW5lcyB0aGF0IGFyZSBzZWxlY3RlZCwgaWYgcG9zc2libGUuXG4qL1xuY29uc3QgZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgW2ZvbGRFZmZlY3Qub2YocmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UpXSkgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5VbmZvbGQgZm9sZGVkIHJhbmdlcyBvbiBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCB1bmZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoID4gMDtcbn07XG5mdW5jdGlvbiBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UsIGZvbGQgPSB0cnVlKSB7XG4gICAgbGV0IGxpbmVGcm9tID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLm51bWJlciwgbGluZVRvID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKS5udW1iZXI7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYCR7dmlldy5zdGF0ZS5waHJhc2UoZm9sZCA/IFwiRm9sZGVkIGxpbmVzXCIgOiBcIlVuZm9sZGVkIGxpbmVzXCIpfSAke2xpbmVGcm9tfSAke3ZpZXcuc3RhdGUucGhyYXNlKFwidG9cIil9ICR7bGluZVRvfS5gKTtcbn1cbi8qKlxuRm9sZCBhbGwgdG9wLWxldmVsIGZvbGRhYmxlIHJhbmdlcy4gTm90ZSB0aGF0LCBpbiBtb3N0IGNhc2VzLFxuZm9sZGluZyBpbmZvcm1hdGlvbiB3aWxsIGRlcGVuZCBvbiB0aGUgW3N5bnRheFxudHJlZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKSwgYW5kIGZvbGRpbmcgZXZlcnl0aGluZyBtYXkgbm90IHdvcmtcbnJlbGlhYmx5IHdoZW4gdGhlIGRvY3VtZW50IGhhc24ndCBiZWVuIGZ1bGx5IHBhcnNlZCAoZWl0aGVyXG5iZWNhdXNlIHRoZSBlZGl0b3Igc3RhdGUgd2FzIG9ubHkganVzdCBpbml0aWFsaXplZCwgb3IgYmVjYXVzZSB0aGVcbmRvY3VtZW50IGlzIHNvIGJpZyB0aGF0IHRoZSBwYXJzZXIgZGVjaWRlZCBub3QgdG8gcGFyc2UgaXRcbmVudGlyZWx5KS5cbiovXG5jb25zdCBmb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBzdGF0ZS5kb2MubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKSwgcmFuZ2UgPSBmb2xkYWJsZShzdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGZvbGRFZmZlY3Qub2YocmFuZ2UpKTtcbiAgICAgICAgcG9zID0gKHJhbmdlID8gdmlldy5saW5lQmxvY2tBdChyYW5nZS50bykgOiBsaW5lKS50byArIDE7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuVW5mb2xkIGFsbCBmb2xkZWQgY29kZS5cbiovXG5jb25zdCB1bmZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZpZWxkLmJldHdlZW4oMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZih7IGZyb20sIHRvIH0pKTsgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCB0aGUgZm9sZGFibGUgcmVnaW9uIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGxpbmUsIGlmIG9uZSBleGlzdHNcbmZ1bmN0aW9uIGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmVCbG9jaykge1xuICAgIC8vIExvb2sgYmFja3dhcmRzIHRocm91Z2ggbGluZSBibG9ja3MgdW50aWwgd2UgZmluZCBhIGZvbGRhYmxlIHJlZ2lvbiB0aGF0XG4gICAgLy8gaW50ZXJzZWN0cyB3aXRoIHRoZSBsaW5lXG4gICAgZm9yIChsZXQgbGluZSA9IGxpbmVCbG9jazs7KSB7XG4gICAgICAgIGxldCBmb2xkYWJsZVJlZ2lvbiA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkYWJsZVJlZ2lvbiAmJiBmb2xkYWJsZVJlZ2lvbi50byA+IGxpbmVCbG9jay5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIGZvbGRhYmxlUmVnaW9uO1xuICAgICAgICBpZiAoIWxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsaW5lID0gdmlldy5saW5lQmxvY2tBdChsaW5lLmZyb20gLSAxKTtcbiAgICB9XG59XG4vKipcblRvZ2dsZSBmb2xkaW5nIGF0IGN1cnNvcnMuIFVuZm9sZHMgaWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgZm9sZFxuc3RhcnRpbmcgaW4gdGhhdCBsaW5lLCB0cmllcyB0byBmaW5kIGEgZm9sZGFibGUgcmFuZ2UgYXJvdW5kIGl0XG5vdGhlcndpc2UuXG4qL1xuY29uc3QgdG9nZ2xlRm9sZCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb2xkUmFuZ2UgPSBmb2xkYWJsZUNvbnRhaW5lcih2aWV3LCBsaW5lKTtcbiAgICAgICAgICAgIGlmIChmb2xkUmFuZ2UpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGZvbGRFZmZlY3Qub2YoZm9sZFJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRSYW5nZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcbkRlZmF1bHQgZm9sZC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cblxuIC0gQ3RybC1TaGlmdC1bIChDbWQtQWx0LVsgb24gbWFjT1MpOiBbYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkuXG4gLSBDdHJsLVNoaWZ0LV0gKENtZC1BbHQtXSBvbiBtYWNPUyk6IFtgdW5mb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQ29kZSkuXG4gLSBDdHJsLUFsdC1bOiBbYGZvbGRBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRBbGwpLlxuIC0gQ3RybC1BbHQtXTogW2B1bmZvbGRBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZEFsbCkuXG4qL1xuY29uc3QgZm9sZEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LVtcIiwgbWFjOiBcIkNtZC1BbHQtW1wiLCBydW46IGZvbGRDb2RlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1dXCIsIG1hYzogXCJDbWQtQWx0LV1cIiwgcnVuOiB1bmZvbGRDb2RlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtW1wiLCBydW46IGZvbGRBbGwgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1dXCIsIHJ1bjogdW5mb2xkQWxsIH1cbl07XG5jb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgIHBsYWNlaG9sZGVyRE9NOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxufTtcbmNvbnN0IGZvbGRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XG59KTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgY29kZSBmb2xkaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVGb2xkaW5nKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbZm9sZFN0YXRlLCBiYXNlVGhlbWUkMV07XG4gICAgaWYgKGNvbmZpZylcbiAgICAgICAgcmVzdWx0LnB1c2goZm9sZENvbmZpZy5vZihjb25maWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZm9sZFdpZGdldCA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00odmlldykge1xuICAgICAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICAgICAgICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHZpZXcucG9zQXRET00oZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNvbmYucGxhY2Vob2xkZXJET00pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmYucGxhY2Vob2xkZXJET00odmlldywgb25jbGljayk7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbmYucGxhY2Vob2xkZXJUZXh0O1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHN0YXRlLnBocmFzZShcImZvbGRlZCBjb2RlXCIpKTtcbiAgICAgICAgICAgIGVsZW1lbnQudGl0bGUgPSBzdGF0ZS5waHJhc2UoXCJ1bmZvbGRcIik7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiY20tZm9sZFBsYWNlaG9sZGVyXCI7XG4gICAgICAgICAgICBlbGVtZW50Lm9uY2xpY2sgPSBvbmNsaWNrO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9IH0pO1xuY29uc3QgZm9sZEd1dHRlckRlZmF1bHRzID0ge1xuICAgIG9wZW5UZXh0OiBcIuKMhFwiLFxuICAgIGNsb3NlZFRleHQ6IFwi4oC6XCIsXG4gICAgbWFya2VyRE9NOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9LFxuICAgIGZvbGRpbmdDaGFuZ2VkOiAoKSA9PiBmYWxzZVxufTtcbmNsYXNzIEZvbGRNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgb3Blbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY29uZmlnID09IG90aGVyLmNvbmZpZyAmJiB0aGlzLm9wZW4gPT0gb3RoZXIub3BlbjsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcmtlckRPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXJrZXJET00odGhpcy5vcGVuKTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMub3BlbiA/IHRoaXMuY29uZmlnLm9wZW5UZXh0IDogdGhpcy5jb25maWcuY2xvc2VkVGV4dDtcbiAgICAgICAgc3Bhbi50aXRsZSA9IHZpZXcuc3RhdGUucGhyYXNlKHRoaXMub3BlbiA/IFwiRm9sZCBsaW5lXCIgOiBcIlVuZm9sZCBsaW5lXCIpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCByZWdpc3RlcnMgYSBmb2xkIGd1dHRlciwgd2hpY2ggc2hvd3MgYVxuZm9sZCBzdGF0dXMgaW5kaWNhdG9yIGJlZm9yZSBmb2xkYWJsZSBsaW5lcyAod2hpY2ggY2FuIGJlIGNsaWNrZWRcbnRvIGZvbGQgb3IgdW5mb2xkIHRoZSBsaW5lKS5cbiovXG5mdW5jdGlvbiBmb2xkR3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGZ1bGxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvbGRHdXR0ZXJEZWZhdWx0cyksIGNvbmZpZyk7XG4gICAgbGV0IGNhbkZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCB0cnVlKSwgY2FuVW5mb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgIGxldCBtYXJrZXJzID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB2aWV3LnZpZXdwb3J0LmZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgIT0gdXBkYXRlLnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgc3ludGF4VHJlZSh1cGRhdGUuc3RhcnRTdGF0ZSkgIT0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgZnVsbENvbmZpZy5mb2xkaW5nQ2hhbmdlZCh1cGRhdGUpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZE1hcmtlcnModmlldykge1xuICAgICAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuVW5mb2xkXG4gICAgICAgICAgICAgICAgICAgIDogZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhbkZvbGQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChsaW5lLmZyb20sIGxpbmUuZnJvbSwgbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB7IGRvbUV2ZW50SGFuZGxlcnMgfSA9IGZ1bGxDb25maWc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya2VycyxcbiAgICAgICAgZ3V0dGVyKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWZvbGRHdXR0ZXJcIixcbiAgICAgICAgICAgIG1hcmtlcnModmlldykgeyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4obWFya2VycykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrZXJzKSB8fCBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICAgICAgICAgIGluaXRpYWxTcGFjZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvbUV2ZW50SGFuZGxlcnMpLCB7IGNsaWNrOiAodmlldywgbGluZSwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbUV2ZW50SGFuZGxlcnMuY2xpY2sgJiYgZG9tRXZlbnRIYW5kbGVycy5jbGljayh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGZvbGRFZmZlY3Qub2YocmFuZ2UpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gfSlcbiAgICAgICAgfSksXG4gICAgICAgIGNvZGVGb2xkaW5nKClcbiAgICBdO1xufVxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWZvbGRQbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZWVlXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2RkZFwiLFxuICAgICAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIuMmVtXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIDFweFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMXB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLWZvbGRHdXR0ZXIgc3BhblwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH1cbn0pO1xuXG4vKipcbkEgaGlnaGxpZ2h0IHN0eWxlIGFzc29jaWF0ZXMgQ1NTIHN0eWxlcyB3aXRoIGhpZ2xpZ2h0aW5nXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKS5cbiovXG5jbGFzcyBIaWdobGlnaHRTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRhZyBzdHlsZXMgdXNlZCB0byBjcmVhdGUgdGhpcyBoaWdobGlnaHQgc3R5bGUuXG4gICAgKi9cbiAgICBzcGVjcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgIGxldCBtb2RTcGVjO1xuICAgICAgICBmdW5jdGlvbiBkZWYoc3BlYykge1xuICAgICAgICAgICAgbGV0IGNscyA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgICAgIChtb2RTcGVjIHx8IChtb2RTcGVjID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW1wiLlwiICsgY2xzXSA9IHNwZWM7XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbCA9IHR5cGVvZiBvcHRpb25zLmFsbCA9PSBcInN0cmluZ1wiID8gb3B0aW9ucy5hbGwgOiBvcHRpb25zLmFsbCA/IGRlZihvcHRpb25zLmFsbCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlT3B0ID0gb3B0aW9ucy5zY29wZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlT3B0IGluc3RhbmNlb2YgTGFuZ3VhZ2UgPyAodHlwZSkgPT4gdHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHNjb3BlT3B0LmRhdGFcbiAgICAgICAgICAgIDogc2NvcGVPcHQgPyAodHlwZSkgPT4gdHlwZSA9PSBzY29wZU9wdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHRhZ0hpZ2hsaWdodGVyKHNwZWNzLm1hcChzdHlsZSA9PiAoe1xuICAgICAgICAgICAgdGFnOiBzdHlsZS50YWcsXG4gICAgICAgICAgICBjbGFzczogc3R5bGUuY2xhc3MgfHwgZGVmKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlLCB7IHRhZzogbnVsbCB9KSlcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgICBhbGwsXG4gICAgICAgIH0pLnN0eWxlO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZFNwZWMgPyBuZXcgU3R5bGVNb2R1bGUobW9kU3BlYykgOiBudWxsO1xuICAgICAgICB0aGlzLnRoZW1lVHlwZSA9IG9wdGlvbnMudGhlbWVUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBoaWdobGlnaHRlciBzdHlsZSB0aGF0IGFzc29jaWF0ZXMgdGhlIGdpdmVuIHN0eWxlcyB0b1xuICAgIHRoZSBnaXZlbiB0YWdzLiBUaGUgc3BlY3MgbXVzdCBiZSBvYmplY3RzIHRoYXQgaG9sZCBhIHN0eWxlIHRhZ1xuICAgIG9yIGFycmF5IG9mIHRhZ3MgaW4gdGhlaXIgYHRhZ2AgcHJvcGVydHksIGFuZCBlaXRoZXIgYSBzaW5nbGVcbiAgICBgY2xhc3NgIHByb3BlcnR5IHByb3ZpZGluZyBhIHN0YXRpYyBDU1MgY2xhc3MgKGZvciBoaWdobGlnaHRlclxuICAgIHRoYXQgcmVseSBvbiBleHRlcm5hbCBzdHlsaW5nKSwgb3IgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pLXN0eWxlXG4gICAgc2V0IG9mIENTUyBwcm9wZXJ0aWVzICh3aGljaCBkZWZpbmUgdGhlIHN0eWxpbmcgZm9yIHRob3NlIHRhZ3MpLlxuICAgIFxuICAgIFRoZSBDU1MgcnVsZXMgY3JlYXRlZCBmb3IgYSBoaWdobGlnaHRlciB3aWxsIGJlIGVtaXR0ZWQgaW4gdGhlXG4gICAgb3JkZXIgb2YgdGhlIHNwZWMncyBwcm9wZXJ0aWVzLiBUaGF0IG1lYW5zIHRoYXQgZm9yIGVsZW1lbnRzIHRoYXRcbiAgICBoYXZlIG11bHRpcGxlIHRhZ3MgYXNzb2NpYXRlZCB3aXRoIHRoZW0sIHN0eWxlcyBkZWZpbmVkIGZ1cnRoZXJcbiAgICBkb3duIGluIHRoZSBsaXN0IHdpbGwgaGF2ZSBhIGhpZ2hlciBDU1MgcHJlY2VkZW5jZSB0aGFuIHN0eWxlc1xuICAgIGRlZmluZWQgZWFybGllci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRTdHlsZShzcGVjcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgfVxufVxuY29uc3QgaGlnaGxpZ2h0ZXJGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZhbGxiYWNrSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gdmFsdWVzLmxlbmd0aCA/IFt2YWx1ZXNbMF1dIDogbnVsbDsgfVxufSk7XG5mdW5jdGlvbiBnZXRIaWdobGlnaHRlcnMoc3RhdGUpIHtcbiAgICBsZXQgbWFpbiA9IHN0YXRlLmZhY2V0KGhpZ2hsaWdodGVyRmFjZXQpO1xuICAgIHJldHVybiBtYWluLmxlbmd0aCA/IG1haW4gOiBzdGF0ZS5mYWNldChmYWxsYmFja0hpZ2hsaWdodGVyKTtcbn1cbi8qKlxuV3JhcCBhIGhpZ2hsaWdodGVyIGluIGFuIGVkaXRvciBleHRlbnNpb24gdGhhdCB1c2VzIGl0IHRvIGFwcGx5XG5zeW50YXggaGlnaGxpZ2h0aW5nIHRvIHRoZSBlZGl0b3IgY29udGVudC5cblxuV2hlbiBtdWx0aXBsZSAobm9uLWZhbGxiYWNrKSBzdHlsZXMgYXJlIHByb3ZpZGVkLCB0aGUgc3R5bGluZ1xuYXBwbGllZCBpcyB0aGUgdW5pb24gb2YgdGhlIGNsYXNzZXMgdGhleSBlbWl0LlxuKi9cbmZ1bmN0aW9uIHN5bnRheEhpZ2hsaWdodGluZyhoaWdobGlnaHRlciwgb3B0aW9ucykge1xuICAgIGxldCBleHQgPSBbdHJlZUhpZ2hsaWdodGVyXSwgdGhlbWVUeXBlO1xuICAgIGlmIChoaWdobGlnaHRlciBpbnN0YW5jZW9mIEhpZ2hsaWdodFN0eWxlKSB7XG4gICAgICAgIGlmIChoaWdobGlnaHRlci5tb2R1bGUpXG4gICAgICAgICAgICBleHQucHVzaChFZGl0b3JWaWV3LnN0eWxlTW9kdWxlLm9mKGhpZ2hsaWdodGVyLm1vZHVsZSkpO1xuICAgICAgICB0aGVtZVR5cGUgPSBoaWdobGlnaHRlci50aGVtZVR5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2spXG4gICAgICAgIGV4dC5wdXNoKGZhbGxiYWNrSGlnaGxpZ2h0ZXIub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICBlbHNlIGlmICh0aGVtZVR5cGUpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQuY29tcHV0ZU4oW0VkaXRvclZpZXcuZGFya1RoZW1lXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZhY2V0KEVkaXRvclZpZXcuZGFya1RoZW1lKSA9PSAodGhlbWVUeXBlID09IFwiZGFya1wiKSA/IFtoaWdobGlnaHRlcl0gOiBbXTtcbiAgICAgICAgfSkpO1xuICAgIGVsc2VcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5vZihoaWdobGlnaHRlcikpO1xuICAgIHJldHVybiBleHQ7XG59XG4vKipcblJldHVybnMgdGhlIENTUyBjbGFzc2VzIChpZiBhbnkpIHRoYXQgdGhlIGhpZ2hsaWdodGVycyBhY3RpdmUgaW5cbnRoZSBzdGF0ZSB3b3VsZCBhc3NpZ24gdG8gdGhlIGdpdmVuIHN0eWxlXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKSBhbmRcbihvcHRpb25hbCkgbGFuZ3VhZ2VcbltzY29wZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5IaWdobGlnaHRTdHlsZV5kZWZpbmVeb3B0aW9ucy5zY29wZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0aW5nRm9yKHN0YXRlLCB0YWdzLCBzY29wZSkge1xuICAgIGxldCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnMoc3RhdGUpO1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmIChoaWdobGlnaHRlcnMpXG4gICAgICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRlci5zY29wZSB8fCBzY29wZSAmJiBoaWdobGlnaHRlci5zY29wZShzY29wZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xzID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyBjbHMgOiBjbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgVHJlZUhpZ2hsaWdodGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubWFya0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHZpZXcsIGdldEhpZ2hsaWdodGVycyh2aWV3LnN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSksIGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBsZXQgc3R5bGVDaGFuZ2UgPSBoaWdobGlnaHRlcnMgIT0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGFydFN0YXRlKTtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8gJiYgIXN0eWxlQ2hhbmdlICYmIHRyZWUudHlwZSA9PSB0aGlzLnRyZWUudHlwZSkge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnMubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmVlICE9IHRoaXMudHJlZSB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IHN0eWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHVwZGF0ZS52aWV3LCBoaWdobGlnaHRlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkRGVjbyh2aWV3LCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgaWYgKCFoaWdobGlnaHRlcnMgfHwgIXRoaXMudHJlZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgaGlnaGxpZ2h0VHJlZSh0aGlzLnRyZWUsIGhpZ2hsaWdodGVycywgKGZyb20sIHRvLCBzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCB0aGlzLm1hcmtDYWNoZVtzdHlsZV0gfHwgKHRoaXMubWFya0NhY2hlW3N0eWxlXSA9IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiBzdHlsZSB9KSkpO1xuICAgICAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn1cbmNvbnN0IHRyZWVIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2goLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKFRyZWVIaWdobGlnaHRlciwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pKTtcbi8qKlxuQSBkZWZhdWx0IGhpZ2hsaWdodCBzdHlsZSAod29ya3Mgd2VsbCB3aXRoIGxpZ2h0IHRoZW1lcykuXG4qL1xuY29uc3QgZGVmYXVsdEhpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3MubWV0YSxcbiAgICAgICAgY29sb3I6IFwiIzQwNDc0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIixcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmlrZXRocm91Z2gsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcImxpbmUtdGhyb3VnaFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IFwiIzcwOFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgdGFncy51cmwsIHRhZ3MuY29udGVudFNlcGFyYXRvciwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjE5XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MubGl0ZXJhbCwgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiMxNjRcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5zdHJpbmcsIHRhZ3MuZGVsZXRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiNhMTFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBcIiNlNDBcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwZlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzMwYVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnR5cGVOYW1lLCB0YWdzLm5hbWVzcGFjZV0sXG4gICAgICAgIGNvbG9yOiBcIiMwODVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSxcbiAgICAgICAgY29sb3I6IFwiIzE2N1wiIH0sXG4gICAgeyB0YWc6IFsvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjU2XCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsXG4gICAgICAgIGNvbG9yOiBcIiM5NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsXG4gICAgICAgIGNvbG9yOiBcIiNmMDBcIiB9XG5dKTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMzMjhjODI1MlwiIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjYmI1NTU1NDRcIiB9XG59KTtcbmNvbnN0IERlZmF1bHRTY2FuRGlzdCA9IDEwMDAwLCBEZWZhdWx0QnJhY2tldHMgPSBcIigpW117fVwiO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFmdGVyQ3Vyc29yOiB0cnVlLFxuICAgICAgICAgICAgYnJhY2tldHM6IERlZmF1bHRCcmFja2V0cyxcbiAgICAgICAgICAgIG1heFNjYW5EaXN0YW5jZTogRGVmYXVsdFNjYW5EaXN0LFxuICAgICAgICAgICAgcmVuZGVyTWF0Y2g6IGRlZmF1bHRSZW5kZXJNYXRjaFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IG1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1tYXRjaGluZ0JyYWNrZXRcIiB9KSwgbm9ubWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW5vbm1hdGNoaW5nQnJhY2tldFwiIH0pO1xuZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1hdGNoKG1hdGNoKSB7XG4gICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgbGV0IG1hcmsgPSBtYXRjaC5tYXRjaGVkID8gbWF0Y2hpbmdNYXJrIDogbm9ubWF0Y2hpbmdNYXJrO1xuICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5zdGFydC5mcm9tLCBtYXRjaC5zdGFydC50bykpO1xuICAgIGlmIChtYXRjaC5lbmQpXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5lbmQuZnJvbSwgbWF0Y2guZW5kLnRvKSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuY29uc3QgYnJhY2tldE1hdGNoaW5nU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIERlY29yYXRpb24ubm9uZTsgfSxcbiAgICB1cGRhdGUoZGVjbywgdHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmICF0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gZGVjbztcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChicmFja2V0TWF0Y2hpbmdDb25maWcpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0ci5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgLTEsIGNvbmZpZylcbiAgICAgICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEsIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgfHwgKGNvbmZpZy5hZnRlckN1cnNvciAmJlxuICAgICAgICAgICAgICAgICAgICAobWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgMSwgY29uZmlnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhbmdlLmhlYWQgPCB0ci5zdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSwgY29uZmlnKSkpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zLmNvbmNhdChjb25maWcucmVuZGVyTWF0Y2gobWF0Y2gsIHRyLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY29yYXRpb25zLCB0cnVlKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpXG59KTtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1VuaXF1ZSA9IFtcbiAgICBicmFja2V0TWF0Y2hpbmdTdGF0ZSxcbiAgICBiYXNlVGhlbWVcbl07XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGJyYWNrZXQgbWF0Y2hpbmcuIFdoZW5ldmVyIHRoZVxuY3Vyc29yIGlzIG5leHQgdG8gYSBicmFja2V0LCB0aGF0IGJyYWNrZXQgYW5kIHRoZSBvbmUgaXQgbWF0Y2hlc1xuYXJlIGhpZ2hsaWdodGVkLiBPciwgd2hlbiBubyBtYXRjaGluZyBicmFja2V0IGlzIGZvdW5kLCBhbm90aGVyXG5oaWdobGlnaHRpbmcgc3R5bGUgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGlzLlxuKi9cbmZ1bmN0aW9uIGJyYWNrZXRNYXRjaGluZyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbYnJhY2tldE1hdGNoaW5nQ29uZmlnLm9mKGNvbmZpZyksIGJyYWNrZXRNYXRjaGluZ1VuaXF1ZV07XG59XG4vKipcbldoZW4gbGFyZ2VyIHN5bnRheCBub2Rlcywgc3VjaCBhcyBIVE1MIHRhZ3MsIGFyZSBtYXJrZWQgYXNcbm9wZW5pbmcvY2xvc2luZywgaXQgY2FuIGJlIGEgYml0IG1lc3N5IHRvIHRyZWF0IHRoZSB3aG9sZSBub2RlIGFzXG5hIG1hdGNoYWJsZSBicmFja2V0LiBUaGlzIG5vZGUgcHJvcCBhbGxvd3MgeW91IHRvIGRlZmluZSwgZm9yIHN1Y2hcbmEgbm9kZSwgYSDigJhoYW5kbGXigJnigJR0aGUgcGFydCBvZiB0aGUgbm9kZSB0aGF0IGlzIGhpZ2hsaWdodGVkLCBhbmRcbnRoYXQgdGhlIGN1cnNvciBtdXN0IGJlIG9uIHRvIGFjdGl2YXRlIGhpZ2hsaWdodGluZyBpbiB0aGUgZmlyc3RcbnBsYWNlLlxuKi9cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0hhbmRsZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbmZ1bmN0aW9uIG1hdGNoaW5nTm9kZXMobm9kZSwgZGlyLCBicmFja2V0cykge1xuICAgIGxldCBieVByb3AgPSBub2RlLnByb3AoZGlyIDwgMCA/IE5vZGVQcm9wLm9wZW5lZEJ5IDogTm9kZVByb3AuY2xvc2VkQnkpO1xuICAgIGlmIChieVByb3ApXG4gICAgICAgIHJldHVybiBieVByb3A7XG4gICAgaWYgKG5vZGUubmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICBsZXQgaW5kZXggPSBicmFja2V0cy5pbmRleE9mKG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xICYmIGluZGV4ICUgMiA9PSAoZGlyIDwgMCA/IDEgOiAwKSlcbiAgICAgICAgICAgIHJldHVybiBbYnJhY2tldHNbaW5kZXggKyBkaXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kSGFuZGxlKG5vZGUpIHtcbiAgICBsZXQgaGFzSGFuZGxlID0gbm9kZS50eXBlLnByb3AoYnJhY2tldE1hdGNoaW5nSGFuZGxlKTtcbiAgICByZXR1cm4gaGFzSGFuZGxlID8gaGFzSGFuZGxlKG5vZGUubm9kZSkgOiBub2RlO1xufVxuLyoqXG5GaW5kIHRoZSBtYXRjaGluZyBicmFja2V0IGZvciB0aGUgdG9rZW4gYXQgYHBvc2AsIHNjYW5uaW5nXG5kaXJlY3Rpb24gYGRpcmAuIE9ubHkgdGhlIGBicmFja2V0c2AgYW5kIGBtYXhTY2FuRGlzdGFuY2VgXG5wcm9wZXJ0aWVzIGFyZSB1c2VkIGZyb20gYGNvbmZpZ2AsIGlmIGdpdmVuLiBSZXR1cm5zIG51bGwgaWYgbm9cbmJyYWNrZXQgd2FzIGZvdW5kIGF0IGBwb3NgLCBvciBhIG1hdGNoIHJlc3VsdCBvdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IG1heFNjYW5EaXN0YW5jZSA9IGNvbmZpZy5tYXhTY2FuRGlzdGFuY2UgfHwgRGVmYXVsdFNjYW5EaXN0LCBicmFja2V0cyA9IGNvbmZpZy5icmFja2V0cyB8fCBEZWZhdWx0QnJhY2tldHM7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKSwgbm9kZSA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgZGlyKTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaGluZ05vZGVzKGN1ci50eXBlLCBkaXIsIGJyYWNrZXRzKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgY3VyLmZyb20gPCBjdXIudG8pIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGUgPSBmaW5kSGFuZGxlKGN1cik7XG4gICAgICAgICAgICBpZiAoaGFuZGxlICYmIChkaXIgPiAwID8gcG9zID49IGhhbmRsZS5mcm9tICYmIHBvcyA8IGhhbmRsZS50byA6IHBvcyA+IGhhbmRsZS5mcm9tICYmIHBvcyA8PSBoYW5kbGUudG8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE1hcmtlZEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY3VyLCBoYW5kbGUsIG1hdGNoZXMsIGJyYWNrZXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgbm9kZS50eXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKTtcbn1cbmZ1bmN0aW9uIG1hdGNoTWFya2VkQnJhY2tldHMoX3N0YXRlLCBfcG9zLCBkaXIsIHRva2VuLCBoYW5kbGUsIG1hdGNoaW5nLCBicmFja2V0cykge1xuICAgIGxldCBwYXJlbnQgPSB0b2tlbi5wYXJlbnQsIGZpcnN0VG9rZW4gPSB7IGZyb206IGhhbmRsZS5mcm9tLCB0bzogaGFuZGxlLnRvIH07XG4gICAgbGV0IGRlcHRoID0gMCwgY3Vyc29yID0gcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmN1cnNvcigpO1xuICAgIGlmIChjdXJzb3IgJiYgKGRpciA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUodG9rZW4uZnJvbSkgOiBjdXJzb3IuY2hpbGRBZnRlcih0b2tlbi50bykpKVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZGlyIDwgMCA/IGN1cnNvci50byA8PSB0b2tlbi5mcm9tIDogY3Vyc29yLmZyb20gPj0gdG9rZW4udG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCAmJiBtYXRjaGluZy5pbmRleE9mKGN1cnNvci50eXBlLm5hbWUpID4gLTEgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEhhbmRsZSA9IGZpbmRIYW5kbGUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIGVuZDogZW5kSGFuZGxlID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLCBtYXRjaGVkOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIGRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIC1kaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEhhbmRsZSA9IGZpbmRIYW5kbGUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRIYW5kbGUgJiYgZW5kSGFuZGxlLmZyb20gPCBlbmRIYW5kbGUudG8gPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpciA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIHRva2VuVHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cykge1xuICAgIGxldCBzdGFydENoID0gZGlyIDwgMCA/IHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcykgOiBzdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIDEpO1xuICAgIGxldCBicmFja2V0ID0gYnJhY2tldHMuaW5kZXhPZihzdGFydENoKTtcbiAgICBpZiAoYnJhY2tldCA8IDAgfHwgKGJyYWNrZXQgJSAyID09IDApICE9IChkaXIgPiAwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YXJ0VG9rZW4gPSB7IGZyb206IGRpciA8IDAgPyBwb3MgLSAxIDogcG9zLCB0bzogZGlyID4gMCA/IHBvcyArIDEgOiBwb3MgfTtcbiAgICBsZXQgaXRlciA9IHN0YXRlLmRvYy5pdGVyUmFuZ2UocG9zLCBkaXIgPiAwID8gc3RhdGUuZG9jLmxlbmd0aCA6IDApLCBkZXB0aCA9IDA7XG4gICAgZm9yIChsZXQgZGlzdGFuY2UgPSAwOyAhKGl0ZXIubmV4dCgpKS5kb25lICYmIGRpc3RhbmNlIDw9IG1heFNjYW5EaXN0YW5jZTspIHtcbiAgICAgICAgbGV0IHRleHQgPSBpdGVyLnZhbHVlO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgYmFzZVBvcyA9IHBvcyArIGRpc3RhbmNlICogZGlyO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBkaXIgPiAwID8gMCA6IHRleHQubGVuZ3RoIC0gMSwgZW5kID0gZGlyID4gMCA/IHRleHQubGVuZ3RoIDogLTE7IHBvcyAhPSBlbmQ7IHBvcyArPSBkaXIpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGJyYWNrZXRzLmluZGV4T2YodGV4dFtwb3NdKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA8IDAgfHwgdHJlZS5yZXNvbHZlSW5uZXIoYmFzZVBvcyArIHBvcywgMSkudHlwZSAhPSB0b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoKGZvdW5kICUgMiA9PSAwKSA9PSAoZGlyID4gMCkpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPT0gMSkgeyAvLyBDbG9zaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIGVuZDogeyBmcm9tOiBiYXNlUG9zICsgcG9zLCB0bzogYmFzZVBvcyArIHBvcyArIDEgfSwgbWF0Y2hlZDogKGZvdW5kID4+IDEpID09IChicmFja2V0ID4+IDEpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBpdGVyLmRvbmUgPyB7IHN0YXJ0OiBzdGFydFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9IDogbnVsbDtcbn1cblxuLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4vLyBVc2VkIG1vc3RseSB0byBmaW5kIGluZGVudGF0aW9uLlxuZnVuY3Rpb24gY291bnRDb2woc3RyaW5nLCBlbmQsIHRhYlNpemUsIHN0YXJ0SW5kZXggPSAwLCBzdGFydFZhbHVlID0gMCkge1xuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICAgIGlmIChlbmQgPT0gLTEpXG4gICAgICAgICAgICBlbmQgPSBzdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgbiA9IHN0YXJ0VmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSlcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG4rKztcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG4vKipcbkVuY2Fwc3VsYXRlcyBhIHNpbmdsZSBsaW5lIG9mIGlucHV0LiBHaXZlbiB0byBzdHJlYW0gc3ludGF4IGNvZGUsXG53aGljaCB1c2VzIGl0IHRvIHRva2VuaXplIHRoZSBjb250ZW50LlxuKi9cbmNsYXNzIFN0cmluZ1N0cmVhbSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3RyZWFtLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxpbmUuXG4gICAgKi9cbiAgICBzdHJpbmcsIHRhYlNpemUsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGluZGVudCB1bml0IHNpemUuXG4gICAgKi9cbiAgICBpbmRlbnRVbml0LCBvdmVycmlkZUluZGVudCkge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTtcbiAgICAgICAgdGhpcy5pbmRlbnRVbml0ID0gaW5kZW50VW5pdDtcbiAgICAgICAgdGhpcy5vdmVycmlkZUluZGVudCA9IG92ZXJyaWRlSW5kZW50O1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGxpbmUuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGVvbCgpIHsgcmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNvbCgpIHsgcmV0dXJuIHRoaXMucG9zID09IDA7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5leHQgY29kZSB1bml0IGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBvciB1bmRlZmluZWRcbiAgICBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgcGVlaygpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkOyB9XG4gICAgLyoqXG4gICAgUmVhZCB0aGUgbmV4dCBjb2RlIHVuaXQgYW5kIGFkdmFuY2UgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MrKyk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIHRoZSBuZXh0IGNoYXJhY3RlciBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcsIHJlZ3VsYXJcbiAgICBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUuIENvbnN1bWUgYW5kIHJldHVybiBpdCBpZiBpdCBtYXRjaGVzLlxuICAgICovXG4gICAgZWF0KG1hdGNoKSB7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBvaztcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgb2sgPSBjaCA9PSBtYXRjaDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2sgPSBjaCAmJiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHAgPyBtYXRjaC50ZXN0KGNoKSA6IG1hdGNoKGNoKSk7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBtYXRjaGluZyBjaGFyYWN0ZXJzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHN0cmluZyxcbiAgICByZWd1bGFyIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZSBmdW5jdGlvbi4gUmV0dXJuIHRydWUgaWYgYW55XG4gICAgY2hhcmFjdGVycyB3ZXJlIGNvbnN1bWVkLlxuICAgICovXG4gICAgZWF0V2hpbGUobWF0Y2gpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3VtZSB3aGl0ZXNwYWNlIGFoZWFkIG9mIGB0aGlzLnBvc2AuIFJldHVybiB0cnVlIGlmIGFueSB3YXNcbiAgICBmb3VuZC5cbiAgICAqL1xuICAgIGVhdFNwYWNlKCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpXG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvRW5kKCkgeyB0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gZGlyZWN0bHkgYmVmb3JlIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGlmIGZvdW5kIG9uIHRoZVxuICAgIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIHNraXBUbyhjaCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcyk7XG4gICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGZvdW5kO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBiYWNrIGBuYCBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgYmFja1VwKG4pIHsgdGhpcy5wb3MgLT0gbjsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBjb2x1bW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IGNvdW50Q29sKHRoaXMuc3RyaW5nLCB0aGlzLnN0YXJ0LCB0aGlzLnRhYlNpemUsIHRoaXMubGFzdENvbHVtblBvcywgdGhpcy5sYXN0Q29sdW1uVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBpbmRlbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vdmVycmlkZUluZGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY291bnRDb2wodGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIHRoZSBpbnB1dCBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAgKHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIGEgYF5gKS4gUmV0dXJuIHRydWUgb3IgdGhlIHJlZ2V4cCBtYXRjaFxuICAgIGlmIGl0IG1hdGNoZXMuXG4gICAgXG4gICAgVW5sZXNzIGBjb25zdW1lYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhpcyB3aWxsIG1vdmUgYHRoaXMucG9zYFxuICAgIHBhc3QgdGhlIG1hdGNoZWQgdGV4dC5cbiAgICBcbiAgICBXaGVuIG1hdGNoaW5nIGEgc3RyaW5nIGBjYXNlSW5zZW5zaXRpdmVgIGNhbiBiZSBzZXQgdG8gdHJ1ZSB0b1xuICAgIG1ha2UgdGhlIG1hdGNoIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgKi9cbiAgICBtYXRjaChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBjYXNlZCA9IChzdHIpID0+IGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyO1xuICAgICAgICAgICAgbGV0IHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IHRva2VuLlxuICAgICovXG4gICAgY3VycmVudCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKTsgfVxufVxuXG5mdW5jdGlvbiBmdWxsUGFyc2VyKHNwZWMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBzcGVjLm5hbWUgfHwgXCJcIixcbiAgICAgICAgdG9rZW46IHNwZWMudG9rZW4sXG4gICAgICAgIGJsYW5rTGluZTogc3BlYy5ibGFua0xpbmUgfHwgKCgpID0+IHsgfSksXG4gICAgICAgIHN0YXJ0U3RhdGU6IHNwZWMuc3RhcnRTdGF0ZSB8fCAoKCkgPT4gdHJ1ZSksXG4gICAgICAgIGNvcHlTdGF0ZTogc3BlYy5jb3B5U3RhdGUgfHwgZGVmYXVsdENvcHlTdGF0ZSxcbiAgICAgICAgaW5kZW50OiBzcGVjLmluZGVudCB8fCAoKCkgPT4gbnVsbCksXG4gICAgICAgIGxhbmd1YWdlRGF0YTogc3BlYy5sYW5ndWFnZURhdGEgfHwge30sXG4gICAgICAgIHRva2VuVGFibGU6IHNwZWMudG9rZW5UYWJsZSB8fCBub1Rva2Vuc1xuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29weVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgbGV0IG5ld1N0YXRlID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsID0gc3RhdGVbcHJvcF07XG4gICAgICAgIG5ld1N0YXRlW3Byb3BdID0gKHZhbCBpbnN0YW5jZW9mIEFycmF5ID8gdmFsLnNsaWNlKCkgOiB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG59XG5jb25zdCBJbmRlbnRlZEZyb20gPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8qKlxuQSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGNsYXNzIGJhc2VkIG9uIGEgQ29kZU1pcnJvclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxuKi9cbmNsYXNzIFN0cmVhbUxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQocGFyc2VyLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIGxldCBwID0gZnVsbFBhcnNlcihwYXJzZXIpLCBzZWxmO1xuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHNlbGYsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKGRhdGEsIGltcGwsIFtpbmRlbnRTZXJ2aWNlLm9mKChjeCwgcG9zKSA9PiB0aGlzLmdldEluZGVudChjeCwgcG9zKSldLCBwYXJzZXIubmFtZSk7XG4gICAgICAgIHRoaXMudG9wTm9kZSA9IGRvY0lEKGRhdGEpO1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnRva2VuVGFibGUgPSBwYXJzZXIudG9rZW5UYWJsZSA/IG5ldyBUb2tlblRhYmxlKHAudG9rZW5UYWJsZSkgOiBkZWZhdWx0VG9rZW5UYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RyZWFtIGxhbmd1YWdlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cbiAgICBnZXRJbmRlbnQoY3gsIHBvcykge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY3guc3RhdGUpLCBhdCA9IHRyZWUucmVzb2x2ZShwb3MpO1xuICAgICAgICB3aGlsZSAoYXQgJiYgYXQudHlwZSAhPSB0aGlzLnRvcE5vZGUpXG4gICAgICAgICAgICBhdCA9IGF0LnBhcmVudDtcbiAgICAgICAgaWYgKCFhdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHsgb3ZlcnJpZGVJbmRlbnRhdGlvbiB9ID0gY3gub3B0aW9ucztcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgIGZyb20gPSBJbmRlbnRlZEZyb20uZ2V0KGN4LnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmcm9tICE9IG51bGwgJiYgZnJvbSA8IHBvcyAtIDFlNClcbiAgICAgICAgICAgICAgICBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZpbmRTdGF0ZSh0aGlzLCB0cmVlLCAwLCBhdC5mcm9tLCBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBwb3MpLCBzdGF0ZVBvcywgc3RhdGU7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gc3RhcnQucG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShjeC51bml0KTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIC0gc3RhdGVQb3MgPiAxMDAwMCAvKiBDLk1heEluZGVudFNjYW5EaXN0ICovKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlIChzdGF0ZVBvcyA8IHBvcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBjeC5zdGF0ZS5kb2MubGluZUF0KHN0YXRlUG9zKSwgZW5kID0gTWF0aC5taW4ocG9zLCBsaW5lLnRvKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnRhdGlvbiA9IG92ZXJyaWRlSW5kZW50YXRpb24gPyBvdmVycmlkZUluZGVudGF0aW9uKGxpbmUuZnJvbSkgOiAtMTtcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGN4LnN0YXRlLnRhYlNpemUsIGN4LnVuaXQsIGluZGVudGF0aW9uIDwgMCA/IHVuZGVmaW5lZCA6IGluZGVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA8IGVuZCAtIGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRva2VuKHRoaXMuc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyLmJsYW5rTGluZShzdGF0ZSwgY3gudW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXRlUG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmUgPSBjeC5saW5lQXQocG9zKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24gJiYgZnJvbSA9PSBudWxsKVxuICAgICAgICAgICAgSW5kZW50ZWRGcm9tLnNldChjeC5zdGF0ZSwgbGluZS5mcm9tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtUGFyc2VyLmluZGVudChzdGF0ZSwgL15cXHMqKC4qKS8uZXhlYyhsaW5lLnRleHQpWzFdLCBjeCk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmZ1bmN0aW9uIGZpbmRTdGF0ZShsYW5nLCB0cmVlLCBvZmYsIHN0YXJ0UG9zLCBiZWZvcmUpIHtcbiAgICBsZXQgc3RhdGUgPSBvZmYgPj0gc3RhcnRQb3MgJiYgb2ZmICsgdHJlZS5sZW5ndGggPD0gYmVmb3JlICYmIHRyZWUucHJvcChsYW5nLnN0YXRlQWZ0ZXIpO1xuICAgIGlmIChzdGF0ZSlcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZShzdGF0ZSksIHBvczogb2ZmICsgdHJlZS5sZW5ndGggfTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBwb3MgPSBvZmYgKyB0cmVlLnBvc2l0aW9uc1tpXTtcbiAgICAgICAgbGV0IGZvdW5kID0gY2hpbGQgaW5zdGFuY2VvZiBUcmVlICYmIHBvcyA8IGJlZm9yZSAmJiBmaW5kU3RhdGUobGFuZywgY2hpbGQsIHBvcywgc3RhcnRQb3MsIGJlZm9yZSk7XG4gICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjdXRUcmVlKGxhbmcsIHRyZWUsIGZyb20sIHRvLCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlICYmIGZyb20gPD0gMCAmJiB0byA+PSB0cmVlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgaWYgKCFpbnNpZGUgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XG4gICAgICAgIGlmIChwb3MgPCB0byAmJiBjaGlsZCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChpbm5lciksIHRyZWUucG9zaXRpb25zLnNsaWNlKDAsIGkgKyAxKSwgcG9zICsgaW5uZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgc3RhcnRQb3MsIGVkaXRvclN0YXRlKSB7XG4gICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBmLmZyb20gKyAoZi5vcGVuU3RhcnQgPyAyNSA6IDApLCB0byA9IGYudG8gLSAoZi5vcGVuRW5kID8gMjUgOiAwKTtcbiAgICAgICAgbGV0IGZvdW5kID0gZnJvbSA8PSBzdGFydFBvcyAmJiB0byA+IHN0YXJ0UG9zICYmIGZpbmRTdGF0ZShsYW5nLCBmLnRyZWUsIDAgLSBmLm9mZnNldCwgc3RhcnRQb3MsIHRvKSwgdHJlZTtcbiAgICAgICAgaWYgKGZvdW5kICYmICh0cmVlID0gY3V0VHJlZShsYW5nLCBmLnRyZWUsIHN0YXJ0UG9zICsgZi5vZmZzZXQsIGZvdW5kLnBvcyArIGYub2Zmc2V0LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IGZvdW5kLnN0YXRlLCB0cmVlIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXRlOiBsYW5nLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGVkaXRvclN0YXRlID8gZ2V0SW5kZW50VW5pdChlZGl0b3JTdGF0ZSkgOiA0KSwgdHJlZTogVHJlZS5lbXB0eSB9O1xufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGxhbmcsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpLCBmcm9tID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIGxldCB7IHN0YXRlLCB0cmVlIH0gPSBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIGZyb20sIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5zdGF0ZSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0aGlzLmNodW5rU3RhcnQgPSBmcm9tICsgdHJlZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0cmVlLnBvc2l0aW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPCBjb250ZXh0LnZpZXdwb3J0LmZyb20gLSAxMDAwMDAgLyogQy5NYXhEaXN0YW5jZUJlZm9yZVZpZXdwb3J0ICovKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5sYW5nLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkpO1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIGNvbnRleHQudmlld3BvcnQuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IGNvbnRleHQudmlld3BvcnQuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gUGFyc2VDb250ZXh0LmdldCgpO1xuICAgICAgICBsZXQgcGFyc2VFbmQgPSB0aGlzLnN0b3BwZWRBdCA9PSBudWxsID8gdGhpcy50byA6IE1hdGgubWluKHRoaXMudG8sIHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBhcnNlRW5kLCB0aGlzLmNodW5rU3RhcnQgKyAyMDQ4IC8qIEMuQ2h1bmtTaXplICovKTtcbiAgICAgICAgaWYgKGNvbnRleHQpXG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNvbnRleHQudmlld3BvcnQudG8pO1xuICAgICAgICB3aGlsZSAodGhpcy5wYXJzZWRQb3MgPCBlbmQpXG4gICAgICAgICAgICB0aGlzLnBhcnNlTGluZShjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuaygpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPj0gcGFyc2VFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgdGhpcy5wYXJzZWRQb3MgPj0gY29udGV4dC52aWV3cG9ydC50bykge1xuICAgICAgICAgICAgY29udGV4dC5za2lwVW50aWxJblZpZXcodGhpcy5wYXJzZWRQb3MsIHBhcnNlRW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgIH1cbiAgICBsaW5lQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsocG9zKTtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmxpbmVDaHVua3MpIHtcbiAgICAgICAgICAgIGxldCBlb2wgPSBjaHVuay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgaWYgKGVvbCA+IC0xKVxuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UoMCwgZW9sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaHVuayA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBjaHVuayA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyArIGNodW5rLmxlbmd0aCA8PSB0aGlzLnRvID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCB0aGlzLnRvIC0gcG9zKTtcbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5wYXJzZWRQb3MsIGxpbmUgPSB0aGlzLmxpbmVBZnRlcihmcm9tKSwgZW5kID0gZnJvbSArIGxpbmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDs7KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VFbmQgPSB0aGlzLnJhbmdlc1tpbmRleF0udG87XG4gICAgICAgICAgICBpZiAocmFuZ2VFbmQgPj0gZW5kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgcmFuZ2VFbmQgLSAoZW5kIC0gbGluZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHJhbmdlU3RhcnQgPSB0aGlzLnJhbmdlc1tpbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHRoaXMubGluZUFmdGVyKHJhbmdlU3RhcnQpO1xuICAgICAgICAgICAgbGluZSArPSBhZnRlcjtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlU3RhcnQgKyBhZnRlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgZW5kIH07XG4gICAgfVxuICAgIHNraXBHYXBzVG8ocG9zLCBvZmZzZXQsIHNpZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8sIG9mZlBvcyA9IHBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChzaWRlID4gMCA/IGVuZCA+IG9mZlBvcyA6IGVuZCA+PSBvZmZQb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF0uZnJvbTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdGFydCAtIGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBtb3ZlUmFuZ2VJbmRleCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucmFuZ2VzW3RoaXMucmFuZ2VJbmRleF0udG8gPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCsrO1xuICAgIH1cbiAgICBlbWl0VG9rZW4oaWQsIGZyb20sIHRvLCBzaXplLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyhmcm9tLCBvZmZzZXQsIDEpO1xuICAgICAgICAgICAgZnJvbSArPSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgbGVuMCA9IHRoaXMuY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKHRvLCBvZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIHRvICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaHVuay5sZW5ndGggLSBsZW4wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2h1bmsucHVzaChpZCwgZnJvbSwgdG8sIHNpemUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBwYXJzZUxpbmUoY29udGV4dCkge1xuICAgICAgICBsZXQgeyBsaW5lLCBlbmQgfSA9IHRoaXMubmV4dExpbmUoKSwgb2Zmc2V0ID0gMCwgeyBzdHJlYW1QYXJzZXIgfSA9IHRoaXMubGFuZztcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZSwgY29udGV4dCA/IGNvbnRleHQuc3RhdGUudGFiU2l6ZSA6IDQsIGNvbnRleHQgPyBnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpIDogMik7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIHN0cmVhbVBhcnNlci5ibGFua0xpbmUodGhpcy5zdGF0ZSwgc3RyZWFtLmluZGVudFVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSByZWFkVG9rZW4oc3RyZWFtUGFyc2VyLnRva2VuLCBzdHJlYW0sIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbilcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5lbWl0VG9rZW4odGhpcy5sYW5nLnRva2VuVGFibGUucmVzb2x2ZSh0b2tlbiksIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnN0YXJ0LCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5wb3MsIDQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zdGFydCA+IDEwMDAwIC8qIEMuTWF4TGluZUxlbmd0aCAqLylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBlbmQ7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zIDwgdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zKys7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKCkge1xuICAgICAgICBsZXQgdHJlZSA9IFRyZWUuYnVpbGQoe1xuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmNodW5rLFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5wYXJzZWRQb3MgLSB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBub2RlU2V0LFxuICAgICAgICAgICAgdG9wSUQ6IDAsXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IDIwNDggLyogQy5DaHVua1NpemUgKi8sXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMuY2h1bmtSZXVzZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRyZWUgPSBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4sIHRyZWUucG9zaXRpb25zLCB0cmVlLmxlbmd0aCwgW1t0aGlzLmxhbmcuc3RhdGVBZnRlciwgdGhpcy5sYW5nLnN0cmVhbVBhcnNlci5jb3B5U3RhdGUodGhpcy5zdGF0ZSldXSk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQgLSB0aGlzLnJhbmdlc1swXS5mcm9tKTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSB0aGlzLnBhcnNlZFBvcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy5sYW5nLnRvcE5vZGUsIHRoaXMuY2h1bmtzLCB0aGlzLmNodW5rUG9zLCB0aGlzLnBhcnNlZFBvcyAtIHRoaXMucmFuZ2VzWzBdLmZyb20pLmJhbGFuY2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFkVG9rZW4odG9rZW4sIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIHBhcnNlciBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXCIpO1xufVxuY29uc3Qgbm9Ub2tlbnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IHR5cGVBcnJheSA9IFtOb2RlVHlwZS5ub25lXTtcbmNvbnN0IG5vZGVTZXQgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVTZXQodHlwZUFycmF5KTtcbmNvbnN0IHdhcm5lZCA9IFtdO1xuY29uc3QgZGVmYXVsdFRhYmxlID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mb3IgKGxldCBbbGVnYWN5TmFtZSwgbmFtZV0gb2YgW1xuICAgIFtcInZhcmlhYmxlXCIsIFwidmFyaWFibGVOYW1lXCJdLFxuICAgIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiXSxcbiAgICBbXCJzdHJpbmctMlwiLCBcInN0cmluZy5zcGVjaWFsXCJdLFxuICAgIFtcImRlZlwiLCBcInZhcmlhYmxlTmFtZS5kZWZpbml0aW9uXCJdLFxuICAgIFtcInRhZ1wiLCBcInRhZ05hbWVcIl0sXG4gICAgW1wiYXR0cmlidXRlXCIsIFwiYXR0cmlidXRlTmFtZVwiXSxcbiAgICBbXCJ0eXBlXCIsIFwidHlwZU5hbWVcIl0sXG4gICAgW1wiYnVpbHRpblwiLCBcInZhcmlhYmxlTmFtZS5zdGFuZGFyZFwiXSxcbiAgICBbXCJxdWFsaWZpZXJcIiwgXCJtb2RpZmllclwiXSxcbiAgICBbXCJlcnJvclwiLCBcImludmFsaWRcIl0sXG4gICAgW1wiaGVhZGVyXCIsIFwiaGVhZGluZ1wiXSxcbiAgICBbXCJwcm9wZXJ0eVwiLCBcInByb3BlcnR5TmFtZVwiXVxuXSlcbiAgICBkZWZhdWx0VGFibGVbbGVnYWN5TmFtZV0gPSAvKkBfX1BVUkVfXyovY3JlYXRlVG9rZW5UeXBlKG5vVG9rZW5zLCBuYW1lKTtcbmNsYXNzIFRva2VuVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGV4dHJhKSB7XG4gICAgICAgIHRoaXMuZXh0cmEgPSBleHRyYTtcbiAgICAgICAgdGhpcy50YWJsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgZGVmYXVsdFRhYmxlKTtcbiAgICB9XG4gICAgcmVzb2x2ZSh0YWcpIHtcbiAgICAgICAgcmV0dXJuICF0YWcgPyAwIDogdGhpcy50YWJsZVt0YWddIHx8ICh0aGlzLnRhYmxlW3RhZ10gPSBjcmVhdGVUb2tlblR5cGUodGhpcy5leHRyYSwgdGFnKSk7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdFRva2VuVGFibGUgPSAvKkBfX1BVUkVfXyovbmV3IFRva2VuVGFibGUobm9Ub2tlbnMpO1xuZnVuY3Rpb24gd2FybkZvclBhcnQocGFydCwgbXNnKSB7XG4gICAgaWYgKHdhcm5lZC5pbmRleE9mKHBhcnQpID4gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICB3YXJuZWQucHVzaChwYXJ0KTtcbiAgICBjb25zb2xlLndhcm4obXNnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuVHlwZShleHRyYSwgdGFnU3RyKSB7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgZm9yIChsZXQgcGFydCBvZiB0YWdTdHIuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IChleHRyYVtwYXJ0XSB8fCB0YWdzW3BhcnRdKTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFVua25vd24gaGlnaGxpZ2h0aW5nIHRhZyAke3BhcnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCF0YWcpXG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYE1vZGlmaWVyICR7cGFydH0gdXNlZCBhdCBzdGFydCBvZiB0YWdgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWx1ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRhZylcbiAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVGFnICR7cGFydH0gdXNlZCBhcyBtb2RpZmllcmApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdGFnKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBsZXQgbmFtZSA9IHRhZ1N0ci5yZXBsYWNlKC8gL2csIFwiX1wiKSwgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgIGlkOiB0eXBlQXJyYXkubGVuZ3RoLFxuICAgICAgICBuYW1lLFxuICAgICAgICBwcm9wczogW3N0eWxlVGFncyh7IFtuYW1lXTogdGFnIH0pXVxuICAgIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlLmlkO1xufVxuZnVuY3Rpb24gZG9jSUQoZGF0YSkge1xuICAgIGxldCB0eXBlID0gTm9kZVR5cGUuZGVmaW5lKHsgaWQ6IHR5cGVBcnJheS5sZW5ndGgsIG5hbWU6IFwiRG9jdW1lbnRcIiwgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCgoKSA9PiBkYXRhKV0gfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCB7IEhpZ2hsaWdodFN0eWxlLCBJbmRlbnRDb250ZXh0LCBMUkxhbmd1YWdlLCBMYW5ndWFnZSwgTGFuZ3VhZ2VEZXNjcmlwdGlvbiwgTGFuZ3VhZ2VTdXBwb3J0LCBQYXJzZUNvbnRleHQsIFN0cmVhbUxhbmd1YWdlLCBTdHJpbmdTdHJlYW0sIFRyZWVJbmRlbnRDb250ZXh0LCBicmFja2V0TWF0Y2hpbmcsIGJyYWNrZXRNYXRjaGluZ0hhbmRsZSwgY29kZUZvbGRpbmcsIGNvbnRpbnVlZEluZGVudCwgZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBkZWxpbWl0ZWRJbmRlbnQsIGVuc3VyZVN5bnRheFRyZWUsIGZsYXRJbmRlbnQsIGZvbGRBbGwsIGZvbGRDb2RlLCBmb2xkRWZmZWN0LCBmb2xkR3V0dGVyLCBmb2xkSW5zaWRlLCBmb2xkS2V5bWFwLCBmb2xkTm9kZVByb3AsIGZvbGRTZXJ2aWNlLCBmb2xkU3RhdGUsIGZvbGRhYmxlLCBmb2xkZWRSYW5nZXMsIGZvcmNlUGFyc2luZywgZ2V0SW5kZW50VW5pdCwgZ2V0SW5kZW50YXRpb24sIGhpZ2hsaWdodGluZ0ZvciwgaW5kZW50Tm9kZVByb3AsIGluZGVudE9uSW5wdXQsIGluZGVudFJhbmdlLCBpbmRlbnRTZXJ2aWNlLCBpbmRlbnRTdHJpbmcsIGluZGVudFVuaXQsIGxhbmd1YWdlLCBsYW5ndWFnZURhdGFQcm9wLCBtYXRjaEJyYWNrZXRzLCBzeW50YXhIaWdobGlnaHRpbmcsIHN5bnRheFBhcnNlclJ1bm5pbmcsIHN5bnRheFRyZWUsIHN5bnRheFRyZWVBdmFpbGFibGUsIHRvZ2dsZUZvbGQsIHVuZm9sZEFsbCwgdW5mb2xkQ29kZSwgdW5mb2xkRWZmZWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/legacy-modes/mode/jinja2.js":
/*!**************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/jinja2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jinja2\": () => (/* binding */ jinja2)\n/* harmony export */ });\nvar keywords = [\"and\", \"as\", \"block\", \"endblock\", \"by\", \"cycle\", \"debug\", \"else\", \"elif\", \"extends\", \"filter\", \"endfilter\", \"firstof\", \"do\", \"for\", \"endfor\", \"if\", \"endif\", \"ifchanged\", \"endifchanged\", \"ifequal\", \"endifequal\", \"ifnotequal\", \"set\", \"raw\", \"endraw\", \"endifnotequal\", \"in\", \"include\", \"load\", \"not\", \"now\", \"or\", \"parsed\", \"regroup\", \"reversed\", \"spaceless\", \"call\", \"endcall\", \"macro\", \"endmacro\", \"endspaceless\", \"ssi\", \"templatetag\", \"openblock\", \"closeblock\", \"openvariable\", \"closevariable\", \"without\", \"context\", \"openbrace\", \"closebrace\", \"opencomment\", \"closecomment\", \"widthratio\", \"url\", \"with\", \"endwith\", \"get_current_language\", \"trans\", \"endtrans\", \"noop\", \"blocktrans\", \"endblocktrans\", \"get_available_languages\", \"get_current_language_bidi\", \"pluralize\", \"autoescape\", \"endautoescape\"],\n  operator = /^[+\\-*&%=<>!?|~^]/,\n  sign = /^[:\\[\\(\\{]/,\n  atom = [\"true\", \"false\"],\n  number = /^(\\d[+\\-\\*\\/])?\\d+(\\.\\d+)?/;\nkeywords = new RegExp(\"((\" + keywords.join(\")|(\") + \"))\\\\b\");\natom = new RegExp(\"((\" + atom.join(\")|(\") + \"))\\\\b\");\nfunction tokenBase(stream, state) {\n  var ch = stream.peek();\n\n  //Comment\n  if (state.incomment) {\n    if (!stream.skipTo(\"#}\")) {\n      stream.skipToEnd();\n    } else {\n      stream.eatWhile(/\\#|}/);\n      state.incomment = false;\n    }\n    return \"comment\";\n    //Tag\n  } else if (state.intag) {\n    //After operator\n    if (state.operator) {\n      state.operator = false;\n      if (stream.match(atom)) {\n        return \"atom\";\n      }\n      if (stream.match(number)) {\n        return \"number\";\n      }\n    }\n    //After sign\n    if (state.sign) {\n      state.sign = false;\n      if (stream.match(atom)) {\n        return \"atom\";\n      }\n      if (stream.match(number)) {\n        return \"number\";\n      }\n    }\n    if (state.instring) {\n      if (ch == state.instring) {\n        state.instring = false;\n      }\n      stream.next();\n      return \"string\";\n    } else if (ch == \"'\" || ch == '\"') {\n      state.instring = ch;\n      stream.next();\n      return \"string\";\n    } else if (state.inbraces > 0 && ch == \")\") {\n      stream.next();\n      state.inbraces--;\n    } else if (ch == \"(\") {\n      stream.next();\n      state.inbraces++;\n    } else if (state.inbrackets > 0 && ch == \"]\") {\n      stream.next();\n      state.inbrackets--;\n    } else if (ch == \"[\") {\n      stream.next();\n      state.inbrackets++;\n    } else if (!state.lineTag && (stream.match(state.intag + \"}\") || stream.eat(\"-\") && stream.match(state.intag + \"}\"))) {\n      state.intag = false;\n      return \"tag\";\n    } else if (stream.match(operator)) {\n      state.operator = true;\n      return \"operator\";\n    } else if (stream.match(sign)) {\n      state.sign = true;\n    } else {\n      if (stream.column() == 1 && state.lineTag && stream.match(keywords)) {\n        //allow nospace after tag before the keyword\n        return \"keyword\";\n      }\n      if (stream.eat(\" \") || stream.sol()) {\n        if (stream.match(keywords)) {\n          return \"keyword\";\n        }\n        if (stream.match(atom)) {\n          return \"atom\";\n        }\n        if (stream.match(number)) {\n          return \"number\";\n        }\n        if (stream.sol()) {\n          stream.next();\n        }\n      } else {\n        stream.next();\n      }\n    }\n    return \"variable\";\n  } else if (stream.eat(\"{\")) {\n    if (stream.eat(\"#\")) {\n      state.incomment = true;\n      if (!stream.skipTo(\"#}\")) {\n        stream.skipToEnd();\n      } else {\n        stream.eatWhile(/\\#|}/);\n        state.incomment = false;\n      }\n      return \"comment\";\n      //Open tag\n    } else if (ch = stream.eat(/\\{|%/)) {\n      //Cache close tag\n      state.intag = ch;\n      state.inbraces = 0;\n      state.inbrackets = 0;\n      if (ch == \"{\") {\n        state.intag = \"}\";\n      }\n      stream.eat(\"-\");\n      return \"tag\";\n    }\n    //Line statements\n  } else if (stream.eat('#')) {\n    if (stream.peek() == '#') {\n      stream.skipToEnd();\n      return \"comment\";\n    } else if (!stream.eol()) {\n      state.intag = true;\n      state.lineTag = true;\n      state.inbraces = 0;\n      state.inbrackets = 0;\n      return \"tag\";\n    }\n  }\n  stream.next();\n}\n;\nconst jinja2 = {\n  name: \"jinja2\",\n  startState: function () {\n    return {\n      tokenize: tokenBase,\n      inbrackets: 0,\n      inbraces: 0\n    };\n  },\n  token: function (stream, state) {\n    var style = state.tokenize(stream, state);\n    if (stream.eol() && state.lineTag && !state.instring && state.inbraces == 0 && state.inbrackets == 0) {\n      //Close line statement at the EOL\n      state.intag = false;\n      state.lineTag = false;\n    }\n    return style;\n  },\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"{#\",\n        close: \"#}\",\n        line: \"##\"\n      }\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvamluamEyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9qaW5qYTIuanM/NzAyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIga2V5d29yZHMgPSBbXCJhbmRcIiwgXCJhc1wiLCBcImJsb2NrXCIsIFwiZW5kYmxvY2tcIiwgXCJieVwiLCBcImN5Y2xlXCIsIFwiZGVidWdcIiwgXCJlbHNlXCIsIFwiZWxpZlwiLFxuICAgICAgICAgICAgICAgIFwiZXh0ZW5kc1wiLCBcImZpbHRlclwiLCBcImVuZGZpbHRlclwiLCBcImZpcnN0b2ZcIiwgXCJkb1wiLCBcImZvclwiLFxuICAgICAgICAgICAgICAgIFwiZW5kZm9yXCIsIFwiaWZcIiwgXCJlbmRpZlwiLCBcImlmY2hhbmdlZFwiLCBcImVuZGlmY2hhbmdlZFwiLFxuICAgICAgICAgICAgICAgIFwiaWZlcXVhbFwiLCBcImVuZGlmZXF1YWxcIiwgXCJpZm5vdGVxdWFsXCIsIFwic2V0XCIsIFwicmF3XCIsIFwiZW5kcmF3XCIsXG4gICAgICAgICAgICAgICAgXCJlbmRpZm5vdGVxdWFsXCIsIFwiaW5cIiwgXCJpbmNsdWRlXCIsIFwibG9hZFwiLCBcIm5vdFwiLCBcIm5vd1wiLCBcIm9yXCIsXG4gICAgICAgICAgICAgICAgXCJwYXJzZWRcIiwgXCJyZWdyb3VwXCIsIFwicmV2ZXJzZWRcIiwgXCJzcGFjZWxlc3NcIiwgXCJjYWxsXCIsIFwiZW5kY2FsbFwiLCBcIm1hY3JvXCIsXG4gICAgICAgICAgICAgICAgXCJlbmRtYWNyb1wiLCBcImVuZHNwYWNlbGVzc1wiLCBcInNzaVwiLCBcInRlbXBsYXRldGFnXCIsIFwib3BlbmJsb2NrXCIsXG4gICAgICAgICAgICAgICAgXCJjbG9zZWJsb2NrXCIsIFwib3BlbnZhcmlhYmxlXCIsIFwiY2xvc2V2YXJpYWJsZVwiLCBcIndpdGhvdXRcIiwgXCJjb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgXCJvcGVuYnJhY2VcIiwgXCJjbG9zZWJyYWNlXCIsIFwib3BlbmNvbW1lbnRcIixcbiAgICAgICAgICAgICAgICBcImNsb3NlY29tbWVudFwiLCBcIndpZHRocmF0aW9cIiwgXCJ1cmxcIiwgXCJ3aXRoXCIsIFwiZW5kd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwiZ2V0X2N1cnJlbnRfbGFuZ3VhZ2VcIiwgXCJ0cmFuc1wiLCBcImVuZHRyYW5zXCIsIFwibm9vcFwiLCBcImJsb2NrdHJhbnNcIixcbiAgICAgICAgICAgICAgICBcImVuZGJsb2NrdHJhbnNcIiwgXCJnZXRfYXZhaWxhYmxlX2xhbmd1YWdlc1wiLFxuICAgICAgICAgICAgICAgIFwiZ2V0X2N1cnJlbnRfbGFuZ3VhZ2VfYmlkaVwiLCBcInBsdXJhbGl6ZVwiLCBcImF1dG9lc2NhcGVcIiwgXCJlbmRhdXRvZXNjYXBlXCJdLFxuICAgIG9wZXJhdG9yID0gL15bK1xcLSomJT08PiE/fH5eXS8sXG4gICAgc2lnbiA9IC9eWzpcXFtcXChcXHtdLyxcbiAgICBhdG9tID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdLFxuICAgIG51bWJlciA9IC9eKFxcZFsrXFwtXFwqXFwvXSk/XFxkKyhcXC5cXGQrKT8vO1xuXG5rZXl3b3JkcyA9IG5ldyBSZWdFeHAoXCIoKFwiICsga2V5d29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcbmF0b20gPSBuZXcgUmVnRXhwKFwiKChcIiArIGF0b20uam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcblxuZnVuY3Rpb24gdG9rZW5CYXNlIChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgLy9Db21tZW50XG4gIGlmIChzdGF0ZS5pbmNvbW1lbnQpIHtcbiAgICBpZighc3RyZWFtLnNraXBUbyhcIiN9XCIpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFwjfH0vKTtcbiAgICAgIHN0YXRlLmluY29tbWVudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgLy9UYWdcbiAgfSBlbHNlIGlmIChzdGF0ZS5pbnRhZykge1xuICAgIC8vQWZ0ZXIgb3BlcmF0b3JcbiAgICBpZihzdGF0ZS5vcGVyYXRvcikge1xuICAgICAgc3RhdGUub3BlcmF0b3IgPSBmYWxzZTtcbiAgICAgIGlmKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9XG4gICAgICBpZihzdHJlYW0ubWF0Y2gobnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9BZnRlciBzaWduXG4gICAgaWYoc3RhdGUuc2lnbikge1xuICAgICAgc3RhdGUuc2lnbiA9IGZhbHNlO1xuICAgICAgaWYoc3RyZWFtLm1hdGNoKGF0b20pKSB7XG4gICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgIH1cbiAgICAgIGlmKHN0cmVhbS5tYXRjaChudW1iZXIpKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICBpZihjaCA9PSBzdGF0ZS5pbnN0cmluZykge1xuICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH0gZWxzZSBpZihjaCA9PSBcIidcIiB8fCBjaCA9PSAnXCInKSB7XG4gICAgICBzdGF0ZS5pbnN0cmluZyA9IGNoO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuaW5icmFjZXMgPiAwICYmIGNoID09XCIpXCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICAgIHN0YXRlLmluYnJhY2VzLS07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiKFwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICBzdGF0ZS5pbmJyYWNlcysrO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5pbmJyYWNrZXRzID4gMCAmJiBjaCA9PVwiXVwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICBzdGF0ZS5pbmJyYWNrZXRzLS07XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiW1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpXG4gICAgICBzdGF0ZS5pbmJyYWNrZXRzKys7XG4gICAgfSBlbHNlIGlmICghc3RhdGUubGluZVRhZyAmJiAoc3RyZWFtLm1hdGNoKHN0YXRlLmludGFnICsgXCJ9XCIpIHx8IHN0cmVhbS5lYXQoXCItXCIpICYmIHN0cmVhbS5tYXRjaChzdGF0ZS5pbnRhZyArIFwifVwiKSkpIHtcbiAgICAgIHN0YXRlLmludGFnID0gZmFsc2U7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9IGVsc2UgaWYoc3RyZWFtLm1hdGNoKG9wZXJhdG9yKSkge1xuICAgICAgc3RhdGUub3BlcmF0b3IgPSB0cnVlO1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9IGVsc2UgaWYoc3RyZWFtLm1hdGNoKHNpZ24pKSB7XG4gICAgICBzdGF0ZS5zaWduID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmVhbS5jb2x1bW4oKSA9PSAxICYmIHN0YXRlLmxpbmVUYWcgJiYgc3RyZWFtLm1hdGNoKGtleXdvcmRzKSkge1xuICAgICAgICAvL2FsbG93IG5vc3BhY2UgYWZ0ZXIgdGFnIGJlZm9yZSB0aGUga2V5d29yZFxuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9XG4gICAgICBpZihzdHJlYW0uZWF0KFwiIFwiKSB8fCBzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYoc3RyZWFtLm1hdGNoKGtleXdvcmRzKSkge1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihzdHJlYW0ubWF0Y2goYXRvbSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc3RyZWFtLm1hdGNoKG51bWJlcikpIHtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIiNcIikpIHtcbiAgICAgIHN0YXRlLmluY29tbWVudCA9IHRydWU7XG4gICAgICBpZighc3RyZWFtLnNraXBUbyhcIiN9XCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFwjfH0vKTtcbiAgICAgICAgc3RhdGUuaW5jb21tZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAvL09wZW4gdGFnXG4gICAgfSBlbHNlIGlmIChjaCA9IHN0cmVhbS5lYXQoL1xce3wlLykpIHtcbiAgICAgIC8vQ2FjaGUgY2xvc2UgdGFnXG4gICAgICBzdGF0ZS5pbnRhZyA9IGNoO1xuICAgICAgc3RhdGUuaW5icmFjZXMgPSAwO1xuICAgICAgc3RhdGUuaW5icmFja2V0cyA9IDA7XG4gICAgICBpZihjaCA9PSBcIntcIikge1xuICAgICAgICBzdGF0ZS5pbnRhZyA9IFwifVwiO1xuICAgICAgfVxuICAgICAgc3RyZWFtLmVhdChcIi1cIik7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgLy9MaW5lIHN0YXRlbWVudHNcbiAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KCcjJykpIHtcbiAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSAnIycpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIlxuICAgIH1cbiAgICBlbHNlIGlmICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdGF0ZS5pbnRhZyA9IHRydWU7XG4gICAgICBzdGF0ZS5saW5lVGFnID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmluYnJhY2VzID0gMDtcbiAgICAgIHN0YXRlLmluYnJhY2tldHMgPSAwO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICB9XG4gIHN0cmVhbS5uZXh0KCk7XG59O1xuXG5leHBvcnQgY29uc3QgamluamEyID0ge1xuICBuYW1lOiBcImppbmphMlwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt0b2tlbml6ZTogdG9rZW5CYXNlLCBpbmJyYWNrZXRzOiAwLCBpbmJyYWNlczogMH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0cmVhbS5lb2woKSAmJiBzdGF0ZS5saW5lVGFnICYmICFzdGF0ZS5pbnN0cmluZyAmJiBzdGF0ZS5pbmJyYWNlcyA9PSAwICYmIHN0YXRlLmluYnJhY2tldHMgPT0gMCkge1xuICAgICAgLy9DbG9zZSBsaW5lIHN0YXRlbWVudCBhdCB0aGUgRU9MXG4gICAgICBzdGF0ZS5pbnRhZyA9IGZhbHNlXG4gICAgICBzdGF0ZS5saW5lVGFnID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7YmxvY2s6IHtvcGVuOiBcInsjXCIsIGNsb3NlOiBcIiN9XCIsIGxpbmU6IFwiIyNcIn19XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/jinja2.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/legacy-modes/mode/yaml.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/yaml.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"yaml\": () => (/* binding */ yaml)\n/* harmony export */ });\nvar cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\nvar keywordRegex = new RegExp(\"\\\\b((\" + cons.join(\")|(\") + \"))$\", 'i');\nconst yaml = {\n  name: \"yaml\",\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var esc = state.escaped;\n    state.escaped = false;\n    /* comments */\n    if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/)) return \"string\";\n    if (state.literal && stream.indentation() > state.keyCol) {\n      stream.skipToEnd();\n      return \"string\";\n    } else if (state.literal) {\n      state.literal = false;\n    }\n    if (stream.sol()) {\n      state.keyCol = 0;\n      state.pair = false;\n      state.pairStart = false;\n      /* document start */\n      if (stream.match('---')) {\n        return \"def\";\n      }\n      /* document end */\n      if (stream.match('...')) {\n        return \"def\";\n      }\n      /* array list item */\n      if (stream.match(/^\\s*-\\s+/)) {\n        return 'meta';\n      }\n    }\n    /* inline pairs/lists */\n    if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n      if (ch == '{') state.inlinePairs++;else if (ch == '}') state.inlinePairs--;else if (ch == '[') state.inlineList++;else state.inlineList--;\n      return 'meta';\n    }\n\n    /* list separator */\n    if (state.inlineList > 0 && !esc && ch == ',') {\n      stream.next();\n      return 'meta';\n    }\n    /* pairs separator */\n    if (state.inlinePairs > 0 && !esc && ch == ',') {\n      state.keyCol = 0;\n      state.pair = false;\n      state.pairStart = false;\n      stream.next();\n      return 'meta';\n    }\n\n    /* start of value of a pair */\n    if (state.pairStart) {\n      /* block literals */\n      if (stream.match(/^\\s*(\\||\\>)\\s*/)) {\n        state.literal = true;\n        return 'meta';\n      }\n      ;\n      /* references */\n      if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) {\n        return 'variable';\n      }\n      /* numbers */\n      if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) {\n        return 'number';\n      }\n      if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) {\n        return 'number';\n      }\n      /* keywords */\n      if (stream.match(keywordRegex)) {\n        return 'keyword';\n      }\n    }\n\n    /* pairs (associative arrays) -> key */\n    if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n      state.pair = true;\n      state.keyCol = stream.indentation();\n      return \"atom\";\n    }\n    if (state.pair && stream.match(/^:\\s*/)) {\n      state.pairStart = true;\n      return 'meta';\n    }\n\n    /* nothing found, continue */\n    state.pairStart = false;\n    state.escaped = ch == '\\\\';\n    stream.next();\n    return null;\n  },\n  startState: function () {\n    return {\n      pair: false,\n      pairStart: false,\n      keyCol: 0,\n      inlinePairs: 0,\n      inlineList: 0,\n      literal: false,\n      escaped: false\n    };\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUveWFtbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS95YW1sLmpzPzliZDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnMgPSBbJ3RydWUnLCAnZmFsc2UnLCAnb24nLCAnb2ZmJywgJ3llcycsICdubyddO1xudmFyIGtleXdvcmRSZWdleCA9IG5ldyBSZWdFeHAoXCJcXFxcYigoXCIrY29ucy5qb2luKFwiKXwoXCIpK1wiKSkkXCIsICdpJyk7XG5cbmV4cG9ydCBjb25zdCB5YW1sID0ge1xuICBuYW1lOiBcInlhbWxcIixcbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgIHZhciBlc2MgPSBzdGF0ZS5lc2NhcGVkO1xuICAgIHN0YXRlLmVzY2FwZWQgPSBmYWxzZTtcbiAgICAvKiBjb21tZW50cyAqL1xuICAgIGlmIChjaCA9PSBcIiNcIiAmJiAoc3RyZWFtLnBvcyA9PSAwIHx8IC9cXHMvLnRlc3Qoc3RyZWFtLnN0cmluZy5jaGFyQXQoc3RyZWFtLnBvcyAtIDEpKSkpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKCcoW14nXXxcXFxcLikqJz98XCIoW15cIl18XFxcXC4pKlwiPykvKSlcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuXG4gICAgaWYgKHN0YXRlLmxpdGVyYWwgJiYgc3RyZWFtLmluZGVudGF0aW9uKCkgPiBzdGF0ZS5rZXlDb2wpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTsgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saXRlcmFsKSB7IHN0YXRlLmxpdGVyYWwgPSBmYWxzZTsgfVxuICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgIHN0YXRlLmtleUNvbCA9IDA7XG4gICAgICBzdGF0ZS5wYWlyID0gZmFsc2U7XG4gICAgICBzdGF0ZS5wYWlyU3RhcnQgPSBmYWxzZTtcbiAgICAgIC8qIGRvY3VtZW50IHN0YXJ0ICovXG4gICAgICBpZihzdHJlYW0ubWF0Y2goJy0tLScpKSB7IHJldHVybiBcImRlZlwiOyB9XG4gICAgICAvKiBkb2N1bWVudCBlbmQgKi9cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goJy4uLicpKSB7IHJldHVybiBcImRlZlwiOyB9XG4gICAgICAvKiBhcnJheSBsaXN0IGl0ZW0gKi9cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqLVxccysvKSkgeyByZXR1cm4gJ21ldGEnOyB9XG4gICAgfVxuICAgIC8qIGlubGluZSBwYWlycy9saXN0cyAqL1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14oXFx7fFxcfXxcXFt8XFxdKS8pKSB7XG4gICAgICBpZiAoY2ggPT0gJ3snKVxuICAgICAgICBzdGF0ZS5pbmxpbmVQYWlycysrO1xuICAgICAgZWxzZSBpZiAoY2ggPT0gJ30nKVxuICAgICAgICBzdGF0ZS5pbmxpbmVQYWlycy0tO1xuICAgICAgZWxzZSBpZiAoY2ggPT0gJ1snKVxuICAgICAgICBzdGF0ZS5pbmxpbmVMaXN0Kys7XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlLmlubGluZUxpc3QtLTtcbiAgICAgIHJldHVybiAnbWV0YSc7XG4gICAgfVxuXG4gICAgLyogbGlzdCBzZXBhcmF0b3IgKi9cbiAgICBpZiAoc3RhdGUuaW5saW5lTGlzdCA+IDAgJiYgIWVzYyAmJiBjaCA9PSAnLCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gJ21ldGEnO1xuICAgIH1cbiAgICAvKiBwYWlycyBzZXBhcmF0b3IgKi9cbiAgICBpZiAoc3RhdGUuaW5saW5lUGFpcnMgPiAwICYmICFlc2MgJiYgY2ggPT0gJywnKSB7XG4gICAgICBzdGF0ZS5rZXlDb2wgPSAwO1xuICAgICAgc3RhdGUucGFpciA9IGZhbHNlO1xuICAgICAgc3RhdGUucGFpclN0YXJ0ID0gZmFsc2U7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuICdtZXRhJztcbiAgICB9XG5cbiAgICAvKiBzdGFydCBvZiB2YWx1ZSBvZiBhIHBhaXIgKi9cbiAgICBpZiAoc3RhdGUucGFpclN0YXJ0KSB7XG4gICAgICAvKiBibG9jayBsaXRlcmFscyAqL1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxccyooXFx8fFxcPilcXHMqLykpIHsgc3RhdGUubGl0ZXJhbCA9IHRydWU7IHJldHVybiAnbWV0YSc7IH07XG4gICAgICAvKiByZWZlcmVuY2VzICovXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxzKihcXCZ8XFwqKVthLXowLTlcXC5fLV0rXFxiL2kpKSB7IHJldHVybiAndmFyaWFibGUnOyB9XG4gICAgICAvKiBudW1iZXJzICovXG4gICAgICBpZiAoc3RhdGUuaW5saW5lUGFpcnMgPT0gMCAmJiBzdHJlYW0ubWF0Y2goL15cXHMqLT9bMC05XFwuXFwsXStcXHM/JC8pKSB7IHJldHVybiAnbnVtYmVyJzsgfVxuICAgICAgaWYgKHN0YXRlLmlubGluZVBhaXJzID4gMCAmJiBzdHJlYW0ubWF0Y2goL15cXHMqLT9bMC05XFwuXFwsXStcXHM/KD89KCx8fSkpLykpIHsgcmV0dXJuICdudW1iZXInOyB9XG4gICAgICAvKiBrZXl3b3JkcyAqL1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkUmVnZXgpKSB7IHJldHVybiAna2V5d29yZCc7IH1cbiAgICB9XG5cbiAgICAvKiBwYWlycyAoYXNzb2NpYXRpdmUgYXJyYXlzKSAtPiBrZXkgKi9cbiAgICBpZiAoIXN0YXRlLnBhaXIgJiYgc3RyZWFtLm1hdGNoKC9eXFxzKig/OlssXFxbXFxde30mKiF8PidcIiVAYF1bXlxccydcIjpdfFteLFxcW1xcXXt9IyYqIXw+J1wiJUBgXSlbXiNdKj8oPz1cXHMqOigkfFxccykpLykpIHtcbiAgICAgIHN0YXRlLnBhaXIgPSB0cnVlO1xuICAgICAgc3RhdGUua2V5Q29sID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5wYWlyICYmIHN0cmVhbS5tYXRjaCgvXjpcXHMqLykpIHsgc3RhdGUucGFpclN0YXJ0ID0gdHJ1ZTsgcmV0dXJuICdtZXRhJzsgfVxuXG4gICAgLyogbm90aGluZyBmb3VuZCwgY29udGludWUgKi9cbiAgICBzdGF0ZS5wYWlyU3RhcnQgPSBmYWxzZTtcbiAgICBzdGF0ZS5lc2NhcGVkID0gKGNoID09ICdcXFxcJyk7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhaXI6IGZhbHNlLFxuICAgICAgcGFpclN0YXJ0OiBmYWxzZSxcbiAgICAgIGtleUNvbDogMCxcbiAgICAgIGlubGluZVBhaXJzOiAwLFxuICAgICAgaW5saW5lTGlzdDogMCxcbiAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgZXNjYXBlZDogZmFsc2VcbiAgICB9O1xuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCIjXCJ9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/legacy-modes/mode/yaml.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RegExpCursor\": () => (/* binding */ RegExpCursor),\n/* harmony export */   \"SearchCursor\": () => (/* binding */ SearchCursor),\n/* harmony export */   \"SearchQuery\": () => (/* binding */ SearchQuery),\n/* harmony export */   \"closeSearchPanel\": () => (/* binding */ closeSearchPanel),\n/* harmony export */   \"findNext\": () => (/* binding */ findNext),\n/* harmony export */   \"findPrevious\": () => (/* binding */ findPrevious),\n/* harmony export */   \"getSearchQuery\": () => (/* binding */ getSearchQuery),\n/* harmony export */   \"gotoLine\": () => (/* binding */ gotoLine),\n/* harmony export */   \"highlightSelectionMatches\": () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   \"openSearchPanel\": () => (/* binding */ openSearchPanel),\n/* harmony export */   \"replaceAll\": () => (/* binding */ replaceAll),\n/* harmony export */   \"replaceNext\": () => (/* binding */ replaceNext),\n/* harmony export */   \"search\": () => (/* binding */ search),\n/* harmony export */   \"searchKeymap\": () => (/* binding */ searchKeymap),\n/* harmony export */   \"searchPanelOpen\": () => (/* binding */ searchPanelOpen),\n/* harmony export */   \"selectMatches\": () => (/* binding */ selectMatches),\n/* harmony export */   \"selectNextOccurrence\": () => (/* binding */ selectNextOccurrence),\n/* harmony export */   \"selectSelectionMatches\": () => (/* binding */ selectSelectionMatches),\n/* harmony export */   \"setSearchQuery\": () => (/* binding */ setSearchQuery)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"./node_modules/crelt/index.es.js\");\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n  /**\n  Create a text cursor. The query is the search string, `from` to\n  `to` provides the region to search.\n  \n  When `normalize` is given, it will be called, on both the query\n  string and the content it is matched against, before comparing.\n  You can, for example, create a case-insensitive search by\n  passing `s => s.toLowerCase()`.\n  \n  Text is always normalized with\n  [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n  (when supported).\n  */\n  constructor(text, query, from = 0, to = text.length, normalize, test) {\n    this.test = test;\n    /**\n    The current match (only holds a meaningful value after\n    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n    `done` is false).\n    */\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    /**\n    Whether the end of the iterated region has been reached.\n    */\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n    this.query = this.normalize(query);\n  }\n  peek() {\n    if (this.bufferPos == this.buffer.length) {\n      this.bufferStart += this.buffer.length;\n      this.iter.next();\n      if (this.iter.done) return -1;\n      this.bufferPos = 0;\n      this.buffer = this.iter.value;\n    }\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n  }\n  /**\n  Look for the next match. Updates the iterator's\n  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n  at least once before using the cursor.\n  */\n  next() {\n    while (this.matches.length) this.matches.pop();\n    return this.nextOverlapping();\n  }\n  /**\n  The `next` method will ignore matches that partially overlap a\n  previous match. This method behaves like `next`, but includes\n  such matches.\n  */\n  nextOverlapping() {\n    for (;;) {\n      let next = this.peek();\n      if (next < 0) {\n        this.done = true;\n        return this;\n      }\n      let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next),\n        start = this.bufferStart + this.bufferPos;\n      this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n      let norm = this.normalize(str);\n      for (let i = 0, pos = start;; i++) {\n        let code = norm.charCodeAt(i);\n        let match = this.match(code, pos);\n        if (match) {\n          this.value = match;\n          return this;\n        }\n        if (i == norm.length - 1) break;\n        if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n      }\n    }\n  }\n  match(code, pos) {\n    let match = null;\n    for (let i = 0; i < this.matches.length; i += 2) {\n      let index = this.matches[i],\n        keep = false;\n      if (this.query.charCodeAt(index) == code) {\n        if (index == this.query.length - 1) {\n          match = {\n            from: this.matches[i + 1],\n            to: pos + 1\n          };\n        } else {\n          this.matches[i]++;\n          keep = true;\n        }\n      }\n      if (!keep) {\n        this.matches.splice(i, 2);\n        i -= 2;\n      }\n    }\n    if (this.query.charCodeAt(0) == code) {\n      if (this.query.length == 1) match = {\n        from: pos,\n        to: pos + 1\n      };else this.matches.push(1, pos);\n    }\n    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos)) match = null;\n    return match;\n  }\n}\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function () {\n  return this;\n};\nconst empty = {\n  from: -1,\n  to: -1,\n  match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n  /**\n  Create a cursor that will search the given range in the given\n  document. `query` should be the raw pattern (as you'd pass it to\n  `new RegExp`).\n  */\n  constructor(text, query, options, from = 0, to = text.length) {\n    this.text = text;\n    this.to = to;\n    this.curLine = \"\";\n    /**\n    Set to `true` when the cursor has reached the end of the search\n    range.\n    */\n    this.done = false;\n    /**\n    Will contain an object with the extent of the match and the\n    match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n    sucessfully finds a match.\n    */\n    this.value = empty;\n    if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.test = options === null || options === void 0 ? void 0 : options.test;\n    this.iter = text.iter();\n    let startLine = text.lineAt(from);\n    this.curLineStart = startLine.from;\n    this.matchPos = toCharEnd(text, from);\n    this.getLine(this.curLineStart);\n  }\n  getLine(skip) {\n    this.iter.next(skip);\n    if (this.iter.lineBreak) {\n      this.curLine = \"\";\n    } else {\n      this.curLine = this.iter.value;\n      if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n      this.iter.next();\n    }\n  }\n  nextLine() {\n    this.curLineStart = this.curLineStart + this.curLine.length + 1;\n    if (this.curLineStart > this.to) this.curLine = \"\";else this.getLine(0);\n  }\n  /**\n  Move to the next match, if there is one.\n  */\n  next() {\n    for (let off = this.matchPos - this.curLineStart;;) {\n      this.re.lastIndex = off;\n      let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n      if (match) {\n        let from = this.curLineStart + match.index,\n          to = from + match[0].length;\n        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n        if (from == this.curLineStart + this.curLine.length) this.nextLine();\n        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n          this.value = {\n            from,\n            to,\n            match\n          };\n          return this;\n        }\n        off = this.matchPos - this.curLineStart;\n      } else if (this.curLineStart + this.curLine.length < this.to) {\n        this.nextLine();\n        off = 0;\n      } else {\n        this.done = true;\n        return this;\n      }\n    }\n  }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n  constructor(from, text) {\n    this.from = from;\n    this.text = text;\n  }\n  get to() {\n    return this.from + this.text.length;\n  }\n  static get(doc, from, to) {\n    let cached = flattened.get(doc);\n    if (!cached || cached.from >= to || cached.to <= from) {\n      let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n      flattened.set(doc, flat);\n      return flat;\n    }\n    if (cached.from == from && cached.to == to) return cached;\n    let {\n      text,\n      from: cachedFrom\n    } = cached;\n    if (cachedFrom > from) {\n      text = doc.sliceString(from, cachedFrom) + text;\n      cachedFrom = from;\n    }\n    if (cached.to < to) text += doc.sliceString(cached.to, to);\n    flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n    return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n  }\n}\nclass MultilineRegExpCursor {\n  constructor(text, query, options, from, to) {\n    this.text = text;\n    this.to = to;\n    this.done = false;\n    this.value = empty;\n    this.matchPos = toCharEnd(text, from);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.test = options === null || options === void 0 ? void 0 : options.test;\n    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n  }\n\n  chunkEnd(pos) {\n    return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n  }\n  next() {\n    for (;;) {\n      let off = this.re.lastIndex = this.matchPos - this.flat.from;\n      let match = this.re.exec(this.flat.text);\n      // Skip empty matches directly after the last match\n      if (match && !match[0] && match.index == off) {\n        this.re.lastIndex = off + 1;\n        match = this.re.exec(this.flat.text);\n      }\n      if (match) {\n        let from = this.flat.from + match.index,\n          to = from + match[0].length;\n        // If a match goes almost to the end of a noncomplete chunk, try\n        // again, since it'll likely be able to match more\n        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n          this.value = {\n            from,\n            to,\n            match\n          };\n          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n          return this;\n        }\n      }\n      if (this.flat.to == this.to) {\n        this.done = true;\n        return this;\n      }\n      // Grow the flattened doc\n      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n    }\n  }\n}\nif (typeof Symbol != \"undefined\") {\n  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\nfunction validRegExp(source) {\n  try {\n    new RegExp(source, baseFlags);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nfunction toCharEnd(text, pos) {\n  if (pos >= text.length) return pos;\n  let line = text.lineAt(pos),\n    next;\n  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000) pos++;\n  return pos;\n}\nfunction createLineDialog(view) {\n  let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n    class: \"cm-textfield\",\n    name: \"line\"\n  });\n  let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n    class: \"cm-gotoLine\",\n    onkeydown: event => {\n      if (event.keyCode == 27) {\n        // Escape\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        // Enter\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: event => {\n      event.preventDefault();\n      go();\n    }\n  }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n    class: \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n  function go() {\n    let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n    if (!match) return;\n    let {\n        state\n      } = view,\n      startLine = state.doc.lineAt(state.selection.main.head);\n    let [, sign, ln, cl, percent] = match;\n    let col = cl ? +cl.slice(1) : 0;\n    let line = ln ? +ln : startLine.number;\n    if (ln && percent) {\n      let pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    view.dispatch({\n      effects: dialogEffect.of(false),\n      selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n      scrollIntoView: true\n    });\n    view.focus();\n  }\n  return {\n    dom\n  };\n}\nconst dialogEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst dialogField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create() {\n    return true;\n  },\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(dialogEffect)) value = e.value;\n    return value;\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\nconst gotoLine = view => {\n  let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n  if (!panel) {\n    let effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects\n    });\n    panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n  }\n  if (panel) panel.dom.querySelector(\"input\").focus();\n  return true;\n};\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nconst defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100,\n  wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine(options) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: (a, b) => a || b,\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n  let ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\nconst matchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n  class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n  class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n  return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n  return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.decorations = this.getDeco(view);\n  }\n  update(update) {\n    if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n  }\n  getDeco(view) {\n    let conf = view.state.facet(highlightConfig);\n    let {\n        state\n      } = view,\n      sel = state.selection;\n    if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n    let range = sel.main,\n      query,\n      check = null;\n    if (range.empty) {\n      if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n      let word = state.wordAt(range.head);\n      if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n      check = state.charCategorizer(range.head);\n      query = state.sliceDoc(word.from, word.to);\n    } else {\n      let len = range.to - range.from;\n      if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n      if (conf.wholeWords) {\n        query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n        check = state.charCategorizer(range.head);\n        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n      } else {\n        query = state.sliceDoc(range.from, range.to).trim();\n        if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n      }\n    }\n    let deco = [];\n    for (let part of view.visibleRanges) {\n      let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n      while (!cursor.next().done) {\n        let {\n          from,\n          to\n        } = cursor.value;\n        if (!check || insideWordBoundaries(check, state, from, to)) {\n          if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n          if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        }\n      }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n  }\n}, {\n  decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n});\n// Select the words around the cursors.\nconst selectWord = ({\n  state,\n  dispatch\n}) => {\n  let {\n    selection\n  } = state;\n  let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n  if (newSel.eq(selection)) return false;\n  dispatch(state.update({\n    selection: newSel\n  }));\n  return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n  let {\n    main,\n    ranges\n  } = state.selection;\n  let word = state.wordAt(main.head),\n    fullWord = word && word.from == main.from && word.to == main.to;\n  for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n    cursor.next();\n    if (cursor.done) {\n      if (cycled) return null;\n      cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n      cycled = true;\n    } else {\n      if (cycled && ranges.some(r => r.from == cursor.value.from)) continue;\n      if (fullWord) {\n        let word = state.wordAt(cursor.value.from);\n        if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;\n      }\n      return cursor.value;\n    }\n  }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({\n  state,\n  dispatch\n}) => {\n  let {\n    ranges\n  } = state.selection;\n  if (ranges.some(sel => sel.from === sel.to)) return selectWord({\n    state,\n    dispatch\n  });\n  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n  if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText)) return false;\n  let range = findNextOccurrence(state, searchedText);\n  if (!range) return false;\n  dispatch(state.update({\n    selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n    effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n  }));\n  return true;\n};\nconst searchConfigFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n      top: false,\n      caseSensitive: false,\n      literal: false,\n      wholeWord: false,\n      createPanel: view => new SearchPanel(view)\n    });\n  }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n  return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n  /**\n  Create a query object.\n  */\n  constructor(config) {\n    this.search = config.search;\n    this.caseSensitive = !!config.caseSensitive;\n    this.literal = !!config.literal;\n    this.regexp = !!config.regexp;\n    this.replace = config.replace || \"\";\n    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n    this.unquoted = this.unquote(this.search);\n    this.wholeWord = !!config.wholeWord;\n  }\n  /**\n  @internal\n  */\n  unquote(text) {\n    return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n  }\n  /**\n  Compare this query to another query.\n  */\n  eq(other) {\n    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;\n  }\n  /**\n  @internal\n  */\n  create() {\n    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n  }\n  /**\n  Get a search cursor for this query, searching through the given\n  range in the given state.\n  */\n  getCursor(state, from = 0, to) {\n    let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n      doc: state\n    });\n    if (to == null) to = st.doc.length;\n    return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n  }\n}\nclass QueryType {\n  constructor(spec) {\n    this.spec = spec;\n  }\n}\nfunction stringCursor(spec, state, from, to) {\n  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n  return (from, to, buf, bufPos) => {\n    if (bufPos > from || bufPos + buf.length < to) {\n      bufPos = Math.max(0, from - 2);\n      buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n    }\n    return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n  };\n}\nclass StringQuery extends QueryType {\n  constructor(spec) {\n    super(spec);\n  }\n  nextMatch(state, curFrom, curTo) {\n    let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n    if (cursor.done) cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n    return cursor.done ? null : cursor.value;\n  }\n  // Searching in reverse is, rather than implementing inverted search\n  // cursor, done by scanning chunk after chunk forward.\n  prevMatchInRange(state, from, to) {\n    for (let pos = to;;) {\n      let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n      let cursor = stringCursor(this.spec, state, start, pos),\n        range = null;\n      while (!cursor.nextOverlapping().done) range = cursor.value;\n      if (range) return range;\n      if (start == from) return null;\n      pos -= 10000 /* FindPrev.ChunkSize */;\n    }\n  }\n\n  prevMatch(state, curFrom, curTo) {\n    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n  }\n  getReplacement(_result) {\n    return this.spec.unquote(this.spec.replace);\n  }\n  matchAll(state, limit) {\n    let cursor = stringCursor(this.spec, state, 0, state.doc.length),\n      ranges = [];\n    while (!cursor.next().done) {\n      if (ranges.length >= limit) return null;\n      ranges.push(cursor.value);\n    }\n    return ranges;\n  }\n  highlight(state, from, to, add) {\n    let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);\n  }\n}\nfunction regexpCursor(spec, state, from, to) {\n  return new RegExpCursor(state.doc, spec.search, {\n    ignoreCase: !spec.caseSensitive,\n    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n  }, from, to);\n}\nfunction charBefore(str, index) {\n  return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n  return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n  nextMatch(state, curFrom, curTo) {\n    let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n    if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n    return cursor.done ? null : cursor.value;\n  }\n  prevMatchInRange(state, from, to) {\n    for (let size = 1;; size++) {\n      let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n      let cursor = regexpCursor(this.spec, state, start, to),\n        range = null;\n      while (!cursor.next().done) range = cursor.value;\n      if (range && (start == from || range.from > start + 10)) return range;\n      if (start == from) return null;\n    }\n  }\n  prevMatch(state, curFrom, curTo) {\n    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n  }\n  getReplacement(result) {\n    return this.spec.unquote(this.spec.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m));\n  }\n  matchAll(state, limit) {\n    let cursor = regexpCursor(this.spec, state, 0, state.doc.length),\n      ranges = [];\n    while (!cursor.next().done) {\n      if (ranges.length >= limit) return null;\n      ranges.push(cursor.value);\n    }\n    return ranges;\n  }\n  highlight(state, from, to, add) {\n    let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);\n  }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create(state) {\n    return new SearchState(defaultQuery(state).create(), null);\n  },\n  update(value, tr) {\n    for (let effect of tr.effects) {\n      if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n    }\n    return value;\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n  let curState = state.field(searchState, false);\n  return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n  var _a;\n  return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n  constructor(query, panel) {\n    this.query = query;\n    this.panel = panel;\n  }\n}\nconst matchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch\"\n  }),\n  selectedMatchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch cm-searchMatch-selected\"\n  });\nconst searchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n  update(update) {\n    let state = update.state.field(searchState);\n    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);\n  }\n  highlight({\n    query,\n    panel\n  }) {\n    if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n    let {\n      view\n    } = this;\n    let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n      let {\n        from,\n        to\n      } = ranges[i];\n      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */) to = ranges[++i].to;\n      query.highlight(view.state, from, to, (from, to) => {\n        let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n        builder.add(from, to, selected ? selectedMatchMark : matchMark);\n      });\n    }\n    return builder.finish();\n  }\n}, {\n  decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n  return view => {\n    let state = view.state.field(searchState, false);\n    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let {\n    to\n  } = view.state.selection.main;\n  let next = query.nextMatch(view.state, to, to);\n  if (!next) return false;\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, next),\n    userEvent: \"select.search\"\n  });\n  return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let {\n      state\n    } = view,\n    {\n      from\n    } = state.selection.main;\n  let range = query.prevMatch(state, from, from);\n  if (!range) return false;\n  view.dispatch({\n    selection: {\n      anchor: range.from,\n      head: range.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, range),\n    userEvent: \"select.search\"\n  });\n  return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let ranges = query.matchAll(view.state, 1000);\n  if (!ranges || !ranges.length) return false;\n  view.dispatch({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n    userEvent: \"select.search.matches\"\n  });\n  return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({\n  state,\n  dispatch\n}) => {\n  let sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  let {\n    from,\n    to\n  } = sel.main;\n  let ranges = [],\n    main = 0;\n  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n  }\n  dispatch(state.update({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n    userEvent: \"select.search.matches\"\n  }));\n  return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let {\n      state\n    } = view,\n    {\n      from,\n      to\n    } = state.selection.main;\n  if (state.readOnly) return false;\n  let next = query.nextMatch(state, from, from);\n  if (!next) return false;\n  let changes = [],\n    selection,\n    replacement;\n  let announce = [];\n  if (next.from == from && next.to == to) {\n    replacement = state.toText(query.getReplacement(next));\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: replacement\n    });\n    next = query.nextMatch(state, next.from, next.to);\n    announce.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n  }\n  if (next) {\n    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n    selection = {\n      anchor: next.from - off,\n      head: next.to - off\n    };\n    announce.push(announceMatch(view, next));\n  }\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: !!selection,\n    effects: announce,\n    userEvent: \"input.replace\"\n  });\n  return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  if (view.state.readOnly) return false;\n  let changes = query.matchAll(view.state, 1e9).map(match => {\n    let {\n      from,\n      to\n    } = match;\n    return {\n      from,\n      to,\n      insert: query.getReplacement(match)\n    };\n  });\n  if (!changes.length) return false;\n  let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n  view.dispatch({\n    changes,\n    effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n    userEvent: \"input.replace.all\"\n  });\n  return true;\n});\nfunction createSearchPanel(view) {\n  return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n  var _a, _b, _c, _d;\n  let sel = state.selection.main;\n  let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n  if (fallback && !selText) return fallback;\n  let config = state.facet(searchConfigFacet);\n  return new SearchQuery({\n    search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n    wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config.wholeWord\n  });\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n  if (state && state.panel) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (!panel) return false;\n    let searchInput = panel.dom.querySelector(\"[main-field]\");\n    if (searchInput && searchInput != view.root.activeElement) {\n      let query = defaultQuery(view.state, state.query.spec);\n      if (query.valid) view.dispatch({\n        effects: setSearchQuery.of(query)\n      });\n      searchInput.focus();\n      searchInput.select();\n    }\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true), state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)]\n    });\n  }\n  return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Alt-g\",\n  run: gotoLine\n}, {\n  key: \"Mod-d\",\n  run: selectNextOccurrence,\n  preventDefault: true\n}];\nclass SearchPanel {\n  constructor(view) {\n    this.view = view;\n    let query = this.query = view.state.field(searchState).query.spec;\n    this.commit = this.commit.bind(this);\n    this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      value: query.search,\n      placeholder: phrase(view, \"Find\"),\n      \"aria-label\": phrase(view, \"Find\"),\n      class: \"cm-textfield\",\n      name: \"search\",\n      form: \"\",\n      \"main-field\": \"true\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      value: query.replace,\n      placeholder: phrase(view, \"Replace\"),\n      \"aria-label\": phrase(view, \"Replace\"),\n      class: \"cm-textfield\",\n      name: \"replace\",\n      form: \"\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      type: \"checkbox\",\n      name: \"case\",\n      form: \"\",\n      checked: query.caseSensitive,\n      onchange: this.commit\n    });\n    this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      type: \"checkbox\",\n      name: \"re\",\n      form: \"\",\n      checked: query.regexp,\n      onchange: this.commit\n    });\n    this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n      type: \"checkbox\",\n      name: \"word\",\n      form: \"\",\n      checked: query.wholeWord,\n      onchange: this.commit\n    });\n    function button(name, onclick, content) {\n      return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        class: \"cm-button\",\n        name,\n        onclick,\n        type: \"button\"\n      }, content);\n    }\n    this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n      onkeydown: e => this.keydown(e),\n      class: \"cm-search\"\n    }, [this.searchField, button(\"next\", () => findNext(view), [phrase(view, \"next\")]), button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]), button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.caseField, phrase(view, \"match case\")]), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.reField, phrase(view, \"regexp\")]), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [this.wordField, phrase(view, \"by word\")]), ...(view.state.readOnly ? [] : [(0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"), this.replaceField, button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]), button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])]), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n      name: \"close\",\n      onclick: () => closeSearchPanel(view),\n      \"aria-label\": phrase(view, \"close\"),\n      type: \"button\"\n    }, [\"×\"])]);\n  }\n  commit() {\n    let query = new SearchQuery({\n      search: this.searchField.value,\n      caseSensitive: this.caseField.checked,\n      regexp: this.reField.checked,\n      wholeWord: this.wordField.checked,\n      replace: this.replaceField.value\n    });\n    if (!query.eq(this.query)) {\n      this.query = query;\n      this.view.dispatch({\n        effects: setSearchQuery.of(query)\n      });\n    }\n  }\n  keydown(e) {\n    if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n      e.preventDefault();\n    } else if (e.keyCode == 13 && e.target == this.searchField) {\n      e.preventDefault();\n      (e.shiftKey ? findPrevious : findNext)(this.view);\n    } else if (e.keyCode == 13 && e.target == this.replaceField) {\n      e.preventDefault();\n      replaceNext(this.view);\n    }\n  }\n  update(update) {\n    for (let tr of update.transactions) for (let effect of tr.effects) {\n      if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n    }\n  }\n  setQuery(query) {\n    this.query = query;\n    this.searchField.value = query.search;\n    this.replaceField.value = query.replace;\n    this.caseField.checked = query.caseSensitive;\n    this.reField.checked = query.regexp;\n    this.wordField.checked = query.wholeWord;\n  }\n  mount() {\n    this.searchField.select();\n  }\n  get pos() {\n    return 80;\n  }\n  get top() {\n    return this.view.state.facet(searchConfigFacet).top;\n  }\n}\nfunction phrase(view, phrase) {\n  return view.state.phrase(phrase);\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, {\n  from,\n  to\n}) {\n  let line = view.state.doc.lineAt(from),\n    lineEnd = view.state.doc.lineAt(to).to;\n  let start = Math.max(line.from, from - AnnounceMargin),\n    end = Math.min(lineEnd, to + AnnounceMargin);\n  let text = view.state.sliceDoc(start, end);\n  if (start != line.from) {\n    for (let i = 0; i < AnnounceMargin; i++) if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n      text = text.slice(i);\n      break;\n    }\n  }\n  if (end != lineEnd) {\n    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--) if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n      text = text.slice(0, i);\n      break;\n    }\n  }\n  return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button, & label\": {\n      margin: \".2em .6em .2em 0\"\n    },\n    \"& input[type=checkbox]\": {\n      marginRight: \".2em\"\n    },\n    \"& label\": {\n      fontSize: \"80%\",\n      whiteSpace: \"pre\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nconst searchExtensions = [searchState, /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.lowest(searchHighlighter), baseTheme];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzPzlhZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBnZXRQYW5lbCwgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgY29kZVBvaW50QXQsIGZyb21Db2RlUG9pbnQsIGNvZGVQb2ludFNpemUsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBDaGFyQ2F0ZWdvcnksIFJhbmdlU2V0QnVpbGRlciwgUHJlYywgRWRpdG9yU3RhdGUsIGZpbmRDbHVzdGVyQnJlYWsgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY29uc3QgYmFzaWNOb3JtYWxpemUgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPT0gXCJmdW5jdGlvblwiXG4gICAgPyB4ID0+IHgubm9ybWFsaXplKFwiTkZLRFwiKSA6IHggPT4geDtcbi8qKlxuQSBzZWFyY2ggY3Vyc29yIHByb3ZpZGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGV4dCBtYXRjaGVzIGluIGFcbmRvY3VtZW50LlxuKi9cbmNsYXNzIFNlYXJjaEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXG4gICAgYHRvYCBwcm92aWRlcyB0aGUgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICBcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcbiAgICBzdHJpbmcgYW5kIHRoZSBjb250ZW50IGl0IGlzIG1hdGNoZWQgYWdhaW5zdCwgYmVmb3JlIGNvbXBhcmluZy5cbiAgICBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgY3JlYXRlIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2ggYnlcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXG4gICAgXG4gICAgVGV4dCBpcyBhbHdheXMgbm9ybWFsaXplZCB3aXRoXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXG4gICAgKHdoZW4gc3VwcG9ydGVkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcbiAgICAgICAgW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLm5leHQpIGhhcyBiZWVuIGNhbGxlZCBhbmQgd2hlblxuICAgICAgICBgZG9uZWAgaXMgZmFsc2UpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemUgPyB4ID0+IG5vcm1hbGl6ZShiYXNpY05vcm1hbGl6ZSh4KSkgOiBiYXNpY05vcm1hbGl6ZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTdGFydCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRBdCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciB0aGUgbmV4dCBtYXRjaC4gVXBkYXRlcyB0aGUgaXRlcmF0b3Inc1xuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxuICAgIFtgZG9uZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5kb25lKSBwcm9wZXJ0aWVzLiBTaG91bGQgYmUgY2FsbGVkXG4gICAgYXQgbGVhc3Qgb25jZSBiZWZvcmUgdXNpbmcgdGhlIGN1cnNvci5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGBuZXh0YCBtZXRob2Qgd2lsbCBpZ25vcmUgbWF0Y2hlcyB0aGF0IHBhcnRpYWxseSBvdmVybGFwIGFcbiAgICBwcmV2aW91cyBtYXRjaC4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIGBuZXh0YCwgYnV0IGluY2x1ZGVzXG4gICAgc3VjaCBtYXRjaGVzLlxuICAgICovXG4gICAgbmV4dE92ZXJsYXBwaW5nKCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHIgPSBmcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHN0cik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IG5vcm0uY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKGNvZGUsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09IG5vcm0ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBpIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChpKSA9PSBjb2RlKVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChjb2RlLCBwb3MpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubWF0Y2hlc1tpXSwga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdChpbmRleCkgPT0gY29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnF1ZXJ5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHRoaXMubWF0Y2hlc1tpICsgMV0sIHRvOiBwb3MgKyAxIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNbaV0rKztcbiAgICAgICAgICAgICAgICAgICAga2VlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdCgwKSA9PSBjb2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogcG9zLCB0bzogcG9zICsgMSB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKDEsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoICYmIHRoaXMudGVzdCAmJiAhdGhpcy50ZXN0KG1hdGNoLmZyb20sIG1hdGNoLnRvLCB0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpKVxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIilcbiAgICBTZWFyY2hDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8qQF9fUFVSRV9fKi8vLiovLmV4ZWMoXCJcIikgfTtcbmNvbnN0IGJhc2VGbGFncyA9IFwiZ21cIiArICgveC8udW5pY29kZSA9PSBudWxsID8gXCJcIiA6IFwidVwiKTtcbi8qKlxuVGhpcyBjbGFzcyBpcyBzaW1pbGFyIHRvIFtgU2VhcmNoQ3Vyc29yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yKVxuYnV0IHNlYXJjaGVzIGZvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIGluc3RlYWQgb2YgYSBwbGFpblxuc3RyaW5nLlxuKi9cbmNsYXNzIFJlZ0V4cEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGdpdmVuIHJhbmdlIGluIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBgcXVlcnlgIHNob3VsZCBiZSB0aGUgcmF3IHBhdHRlcm4gKGFzIHlvdSdkIHBhc3MgaXQgdG9cbiAgICBgbmV3IFJlZ0V4cGApLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIFNldCB0byBgdHJ1ZWAgd2hlbiB0aGUgY3Vyc29yIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlYXJjaFxuICAgICAgICByYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaWxsIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggdGhlIGV4dGVudCBvZiB0aGUgbWF0Y2ggYW5kIHRoZVxuICAgICAgICBtYXRjaCBvYmplY3Qgd2hlbiBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5SZWdFeHBDdXJzb3IubmV4dClcbiAgICAgICAgc3VjZXNzZnVsbHkgZmluZHMgYSBtYXRjaC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICBpZiAoL1xcXFxbc1dEbnJdfFxcbnxcXHJ8XFxbXFxeLy50ZXN0KHF1ZXJ5KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyKCk7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSB0ZXh0LmxpbmVBdChmcm9tKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSBzdGFydExpbmUuZnJvbTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5nZXRMaW5lKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0TGluZShza2lwKSB7XG4gICAgICAgIHRoaXMuaXRlci5uZXh0KHNraXApO1xuICAgICAgICBpZiAodGhpcy5pdGVyLmxpbmVCcmVhaykge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuY3VyTGluZS5zbGljZSgwLCB0aGlzLnRvIC0gdGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKDApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG1hdGNoLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoUG9zIDw9IHRoaXMudG8gJiYgdGhpcy5yZS5leGVjKHRoaXMuY3VyTGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgdG8gfHwgZnJvbSA+IHRoaXMudmFsdWUudG8pICYmICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBmbGF0dGVuZWQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFJldXNhYmxlIChwYXJ0aWFsbHkpIGZsYXR0ZW5lZCBkb2N1bWVudCBzdHJpbmdzXG5jbGFzcyBGbGF0dGVuZWREb2Mge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIHN0YXRpYyBnZXQoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgY2FjaGVkID0gZmxhdHRlbmVkLmdldChkb2MpO1xuICAgICAgICBpZiAoIWNhY2hlZCB8fCBjYWNoZWQuZnJvbSA+PSB0byB8fCBjYWNoZWQudG8gPD0gZnJvbSkge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIGRvYy5zbGljZVN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC5mcm9tID09IGZyb20gJiYgY2FjaGVkLnRvID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbTogY2FjaGVkRnJvbSB9ID0gY2FjaGVkO1xuICAgICAgICBpZiAoY2FjaGVkRnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgIHRleHQgPSBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgY2FjaGVkRnJvbSkgKyB0ZXh0O1xuICAgICAgICAgICAgY2FjaGVkRnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC50byA8IHRvKVxuICAgICAgICAgICAgdGV4dCArPSBkb2Muc2xpY2VTdHJpbmcoY2FjaGVkLnRvLCB0byk7XG4gICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBuZXcgRmxhdHRlbmVkRG9jKGNhY2hlZEZyb20sIHRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgdGV4dC5zbGljZShmcm9tIC0gY2FjaGVkRnJvbSwgdG8gLSBjYWNoZWRGcm9tKSk7XG4gICAgfVxufVxuY2xhc3MgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGV4dCwgZnJvbSwgdGhpcy5jaHVua0VuZChmcm9tICsgNTAwMCAvKiBDaHVuay5CYXNlICovKSk7XG4gICAgfVxuICAgIGNodW5rRW5kKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID49IHRoaXMudG8gPyB0aGlzLnRvIDogdGhpcy50ZXh0LmxpbmVBdChwb3MpLnRvO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgb2ZmID0gdGhpcy5yZS5sYXN0SW5kZXggPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5mbGF0LmZyb207XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBtYXRjaGVzIGRpcmVjdGx5IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgIW1hdGNoWzBdICYmIG1hdGNoLmluZGV4ID09IG9mZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmICsgMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZmxhdC5mcm9tICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIGdvZXMgYWxtb3N0IHRvIHRoZSBlbmQgb2YgYSBub25jb21wbGV0ZSBjaHVuaywgdHJ5XG4gICAgICAgICAgICAgICAgLy8gYWdhaW4sIHNpbmNlIGl0J2xsIGxpa2VseSBiZSBhYmxlIHRvIG1hdGNoIG1vcmVcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZmxhdC50byA+PSB0aGlzLnRvIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDw9IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdyb3cgdGhlIGZsYXR0ZW5lZCBkb2NcbiAgICAgICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGhpcy50ZXh0LCB0aGlzLmZsYXQuZnJvbSwgdGhpcy5jaHVua0VuZCh0aGlzLmZsYXQuZnJvbSArIHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAqIDIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBNdWx0aWxpbmVSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzb3VyY2UsIGJhc2VGbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQ2hhckVuZCh0ZXh0LCBwb3MpIHtcbiAgICBpZiAocG9zID49IHRleHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBsaW5lID0gdGV4dC5saW5lQXQocG9zKSwgbmV4dDtcbiAgICB3aGlsZSAocG9zIDwgbGluZS50byAmJiAobmV4dCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyAtIGxpbmUuZnJvbSkpID49IDB4REMwMCAmJiBuZXh0IDwgMHhFMDAwKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcbiAgICBsZXQgaW5wdXQgPSBlbHQoXCJpbnB1dFwiLCB7IGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLCBuYW1lOiBcImxpbmVcIiB9KTtcbiAgICBsZXQgZG9tID0gZWx0KFwiZm9ybVwiLCB7XG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXG4gICAgICAgIG9ua2V5ZG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9XG4gICAgfSwgZWx0KFwibGFiZWxcIiwgdmlldy5zdGF0ZS5waHJhc2UoXCJHbyB0byBsaW5lXCIpLCBcIjogXCIsIGlucHV0KSwgXCIgXCIsIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpKTtcbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gL14oWystXSk/KFxcZCspPyg6XFxkKyk/KCUpPyQvLmV4ZWMoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgbGV0IFssIHNpZ24sIGxuLCBjbCwgcGVyY2VudF0gPSBtYXRjaDtcbiAgICAgICAgbGV0IGNvbCA9IGNsID8gK2NsLnNsaWNlKDEpIDogMDtcbiAgICAgICAgbGV0IGxpbmUgPSBsbiA/ICtsbiA6IHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIGlmIChsbiAmJiBwZXJjZW50KSB7XG4gICAgICAgICAgICBsZXQgcGMgPSBsaW5lIC8gMTAwO1xuICAgICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICAgICAgcGMgPSBwYyAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIChzdGFydExpbmUubnVtYmVyIC8gc3RhdGUuZG9jLmxpbmVzKTtcbiAgICAgICAgICAgIGxpbmUgPSBNYXRoLnJvdW5kKHN0YXRlLmRvYy5saW5lcyAqIHBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsbiAmJiBzaWduKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZSAqIChzaWduID09IFwiLVwiID8gLTEgOiAxKSArIHN0YXJ0TGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvY0xpbmUgPSBzdGF0ZS5kb2MubGluZShNYXRoLm1heCgxLCBNYXRoLm1pbihzdGF0ZS5kb2MubGluZXMsIGxpbmUpKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkb2NMaW5lLmZyb20gKyBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2wsIGRvY0xpbmUubGVuZ3RoKSkpLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tIH07XG59XG5jb25zdCBkaWFsb2dFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBkaWFsb2dGaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKGRpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwgPyBjcmVhdGVMaW5lRGlhbG9nIDogbnVsbClcbn0pO1xuLyoqXG5Db21tYW5kIHRoYXQgc2hvd3MgYSBkaWFsb2cgYXNraW5nIHRoZSB1c2VyIGZvciBhIGxpbmUgbnVtYmVyLCBhbmRcbndoZW4gYSB2YWxpZCBwb3NpdGlvbiBpcyBwcm92aWRlZCwgbW92ZXMgdGhlIGN1cnNvciB0byB0aGF0IGxpbmUuXG5cblN1cHBvcnRzIGxpbmUgbnVtYmVycywgcmVsYXRpdmUgbGluZSBvZmZzZXRzIHByZWZpeGVkIHdpdGggYCtgIG9yXG5gLWAsIGRvY3VtZW50IHBlcmNlbnRhZ2VzIHN1ZmZpeGVkIHdpdGggYCVgLCBhbmQgYW4gb3B0aW9uYWxcbmNvbHVtbiBwb3NpdGlvbiBieSBhZGRpbmcgYDpgIGFuZCBhIHNlY29uZCBudW1iZXIgYWZ0ZXIgdGhlIGxpbmVcbm51bWJlci5cblxuVGhlIGRpYWxvZyBjYW4gYmUgc3R5bGVkIHdpdGggdGhlIGBwYW5lbC5nb3RvTGluZWAgdGhlbWVcbnNlbGVjdG9yLlxuKi9cbmNvbnN0IGdvdG9MaW5lID0gdmlldyA9PiB7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgaWYgKCFwYW5lbCkge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IFtkaWFsb2dFZmZlY3Qub2YodHJ1ZSldO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChkaWFsb2dGaWVsZCwgZmFsc2UpID09IG51bGwpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtkaWFsb2dGaWVsZCwgYmFzZVRoZW1lJDFdKSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgICAgICBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIH1cbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tZ290b0xpbmVcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7IGZvbnRTaXplOiBcIjgwJVwiIH1cbiAgICB9XG59KTtcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogZmFsc2UsXG4gICAgbWluU2VsZWN0aW9uTGVuZ3RoOiAxLFxuICAgIG1heE1hdGNoZXM6IDEwMCxcbiAgICB3aG9sZVdvcmRzOiBmYWxzZVxufTtcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhvcHRpb25zLCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucywge1xuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcbiAgICAgICAgICAgIG1pblNlbGVjdGlvbkxlbmd0aDogTWF0aC5taW4sXG4gICAgICAgICAgICBtYXhNYXRjaGVzOiBNYXRoLm1pblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuVGhpcyBleHRlbnNpb24gaGlnaGxpZ2h0cyB0ZXh0IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0aW9uLiBJdCB1c2VzXG50aGUgYFwiY20tc2VsZWN0aW9uTWF0Y2hcImAgY2xhc3MgZm9yIHRoZSBoaWdobGlnaHRpbmcuIFdoZW5cbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXG5pdHNlbGYgd2lsbCBiZSBoaWdobGlnaHRlZCB3aXRoIGBcImNtLXNlbGVjdGlvbk1hdGNoLW1haW5cImAuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFtkZWZhdWx0VGhlbWUsIG1hdGNoSGlnaGxpZ2h0ZXJdO1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xuICAgIHJldHVybiBleHQ7XG59XG5jb25zdCBtYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcbmNvbnN0IG1haW5NYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2ggY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiIH0pO1xuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBvdXRzaWRlIHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIG5vbi13b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKGZyb20gPT0gMCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tIC0gMSwgZnJvbSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAodG8gPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSB3b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkXG4gICAgICAgICYmIGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvIC0gMSwgdG8pKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZDtcbn1cbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGlmICghd29yZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxlbiA8IGNvbmYubWluU2VsZWN0aW9uTGVuZ3RoIHx8IGxlbiA+IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pOyAvLyBUT0RPOiBhbGxvdyBhbmQgaW5jbHVkZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlP1xuICAgICAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICYmIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHBhcnQuZnJvbSwgcGFydC50byk7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVjayB8fCBpbnNpZGVXb3JkQm91bmRhcmllcyhjaGVjaywgc3RhdGUsIGZyb20sIHRvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgZnJvbSA8PSByYW5nZS5mcm9tICYmIHRvID49IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1haW5NYXRjaERlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+PSByYW5nZS50byB8fCB0byA8PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKG1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjby5sZW5ndGggPiBjb25mLm1heE1hdGNoZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuY29uc3QgZGVmYXVsdFRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjOTlmZjc3ODBcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoIC5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiIH1cbn0pO1xuLy8gU2VsZWN0IHRoZSB3b3JkcyBhcm91bmQgdGhlIGN1cnNvcnMuXG5jb25zdCBzZWxlY3RXb3JkID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgIGxldCBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbGVjdGlvbi5yYW5nZXMubWFwKHJhbmdlID0+IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKSB8fCBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQpKSwgc2VsZWN0aW9uLm1haW5JbmRleCk7XG4gICAgaWYgKG5ld1NlbC5lcShzZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBuZXdTZWwgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgbmV4dCBvY2N1cnJlbmNlIG9mIHF1ZXJ5IHJlbGF0aXZlIHRvIGxhc3QgY3Vyc29yLiBXcmFwIGFyb3VuZFxuLy8gdGhlIGRvY3VtZW50IGlmIHRoZXJlIGFyZSBubyBtb3JlIG1hdGNoZXMuXG5mdW5jdGlvbiBmaW5kTmV4dE9jY3VycmVuY2Uoc3RhdGUsIHF1ZXJ5KSB7XG4gICAgbGV0IHsgbWFpbiwgcmFuZ2VzIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHdvcmQgPSBzdGF0ZS53b3JkQXQobWFpbi5oZWFkKSwgZnVsbFdvcmQgPSB3b3JkICYmIHdvcmQuZnJvbSA9PSBtYWluLmZyb20gJiYgd29yZC50byA9PSBtYWluLnRvO1xuICAgIGZvciAobGV0IGN5Y2xlZCA9IGZhbHNlLCBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG8pOzspIHtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY3Vyc29yID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHF1ZXJ5LCAwLCBNYXRoLm1heCgwLCByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLmZyb20gLSAxKSk7XG4gICAgICAgICAgICBjeWNsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN5Y2xlZCAmJiByYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBjdXJzb3IudmFsdWUuZnJvbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoZnVsbFdvcmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChjdXJzb3IudmFsdWUuZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3JkIHx8IHdvcmQuZnJvbSAhPSBjdXJzb3IudmFsdWUuZnJvbSB8fCB3b3JkLnRvICE9IGN1cnNvci52YWx1ZS50bylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5TZWxlY3QgbmV4dCBvY2N1cnJlbmNlIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gRXhwYW5kIHNlbGVjdGlvblxudG8gdGhlIHN1cnJvdW5kaW5nIHdvcmQgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5LlxuKi9cbmNvbnN0IHNlbGVjdE5leHRPY2N1cnJlbmNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgeyByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAocmFuZ2VzLnNvbWUoc2VsID0+IHNlbC5mcm9tID09PSBzZWwudG8pKVxuICAgICAgICByZXR1cm4gc2VsZWN0V29yZCh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBsZXQgc2VhcmNoZWRUZXh0ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2VzWzBdLmZyb20sIHJhbmdlc1swXS50byk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHN0YXRlLnNsaWNlRG9jKHIuZnJvbSwgci50bykgIT0gc2VhcmNoZWRUZXh0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCByYW5nZSA9IGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgc2VhcmNoZWRUZXh0KTtcbiAgICBpZiAoIXJhbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24uYWRkUmFuZ2UoRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20sIHJhbmdlLnRvKSwgZmFsc2UpLFxuICAgICAgICBlZmZlY3RzOiBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHJhbmdlLnRvKVxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlYXJjaENvbmZpZ0ZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHRvcDogZmFsc2UsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGxpdGVyYWw6IGZhbHNlLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiBmYWxzZSxcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiB2aWV3ID0+IG5ldyBTZWFyY2hQYW5lbCh2aWV3KVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuQWRkIHNlYXJjaCBzdGF0ZSB0byB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24sIGFuZCBvcHRpb25hbGx5XG5jb25maWd1cmUgdGhlIHNlYXJjaCBleHRlbnNpb24uXG4oW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIHdpbGwgYXV0b21hdGljYWxseVxuZW5hYmxlIHRoaXMgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvbikuXG4qL1xuZnVuY3Rpb24gc2VhcmNoKGNvbmZpZykge1xuICAgIHJldHVybiBjb25maWcgPyBbc2VhcmNoQ29uZmlnRmFjZXQub2YoY29uZmlnKSwgc2VhcmNoRXh0ZW5zaW9uc10gOiBzZWFyY2hFeHRlbnNpb25zO1xufVxuLyoqXG5BIHNlYXJjaCBxdWVyeS4gUGFydCBvZiB0aGUgZWRpdG9yJ3Mgc2VhcmNoIHN0YXRlLlxuKi9cbmNsYXNzIFNlYXJjaFF1ZXJ5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBxdWVyeSBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBjb25maWcuc2VhcmNoO1xuICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSAhIWNvbmZpZy5jYXNlU2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLmxpdGVyYWwgPSAhIWNvbmZpZy5saXRlcmFsO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9ICEhY29uZmlnLnJlZ2V4cDtcbiAgICAgICAgdGhpcy5yZXBsYWNlID0gY29uZmlnLnJlcGxhY2UgfHwgXCJcIjtcbiAgICAgICAgdGhpcy52YWxpZCA9ICEhdGhpcy5zZWFyY2ggJiYgKCF0aGlzLnJlZ2V4cCB8fCB2YWxpZFJlZ0V4cCh0aGlzLnNlYXJjaCkpO1xuICAgICAgICB0aGlzLnVucXVvdGVkID0gdGhpcy51bnF1b3RlKHRoaXMuc2VhcmNoKTtcbiAgICAgICAgdGhpcy53aG9sZVdvcmQgPSAhIWNvbmZpZy53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdW5xdW90ZSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdGVyYWwgPyB0ZXh0IDpcbiAgICAgICAgICAgIHRleHQucmVwbGFjZSgvXFxcXChbbnJ0XFxcXF0pL2csIChfLCBjaCkgPT4gY2ggPT0gXCJuXCIgPyBcIlxcblwiIDogY2ggPT0gXCJyXCIgPyBcIlxcclwiIDogY2ggPT0gXCJ0XCIgPyBcIlxcdFwiIDogXCJcXFxcXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcXVlcnkgdG8gYW5vdGhlciBxdWVyeS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaCA9PSBvdGhlci5zZWFyY2ggJiYgdGhpcy5yZXBsYWNlID09IG90aGVyLnJlcGxhY2UgJiZcbiAgICAgICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9PSBvdGhlci5jYXNlU2Vuc2l0aXZlICYmIHRoaXMucmVnZXhwID09IG90aGVyLnJlZ2V4cCAmJlxuICAgICAgICAgICAgdGhpcy53aG9sZVdvcmQgPT0gb3RoZXIud2hvbGVXb3JkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gbmV3IFJlZ0V4cFF1ZXJ5KHRoaXMpIDogbmV3IFN0cmluZ1F1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBzZWFyY2ggY3Vyc29yIGZvciB0aGlzIHF1ZXJ5LCBzZWFyY2hpbmcgdGhyb3VnaCB0aGUgZ2l2ZW5cbiAgICByYW5nZSBpbiB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXRDdXJzb3Ioc3RhdGUsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBsZXQgc3QgPSBzdGF0ZS5kb2MgPyBzdGF0ZSA6IEVkaXRvclN0YXRlLmNyZWF0ZSh7IGRvYzogc3RhdGUgfSk7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSBzdC5kb2MubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyByZWdleHBDdXJzb3IodGhpcywgc3QsIGZyb20sIHRvKSA6IHN0cmluZ0N1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pO1xuICAgIH1cbn1cbmNsYXNzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ0N1cnNvcihzcGVjLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHNwZWMudW5xdW90ZWQsIGZyb20sIHRvLCBzcGVjLmNhc2VTZW5zaXRpdmUgPyB1bmRlZmluZWQgOiB4ID0+IHgudG9Mb3dlckNhc2UoKSwgc3BlYy53aG9sZVdvcmQgPyBzdHJpbmdXb3JkVGVzdChzdGF0ZS5kb2MsIHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gc3RyaW5nV29yZFRlc3QoZG9jLCBjYXRlZ29yaXplcikge1xuICAgIHJldHVybiAoZnJvbSwgdG8sIGJ1ZiwgYnVmUG9zKSA9PiB7XG4gICAgICAgIGlmIChidWZQb3MgPiBmcm9tIHx8IGJ1ZlBvcyArIGJ1Zi5sZW5ndGggPCB0bykge1xuICAgICAgICAgICAgYnVmUG9zID0gTWF0aC5tYXgoMCwgZnJvbSAtIDIpO1xuICAgICAgICAgICAgYnVmID0gZG9jLnNsaWNlU3RyaW5nKGJ1ZlBvcywgTWF0aC5taW4oZG9jLmxlbmd0aCwgdG8gKyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbiAgICB9O1xufVxuY2xhc3MgU3RyaW5nUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoc3BlYyk7XG4gICAgfVxuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBjdXJGcm9tKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VhcmNoaW5nIGluIHJldmVyc2UgaXMsIHJhdGhlciB0aGFuIGltcGxlbWVudGluZyBpbnZlcnRlZCBzZWFyY2hcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0bzs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHBvcyksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHRPdmVybGFwcGluZygpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwb3MgLT0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSk7IH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBNYXRoLm1pbih0byArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgsIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnZXhwQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy5zZWFyY2gsIHtcbiAgICAgICAgaWdub3JlQ2FzZTogIXNwZWMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgdGVzdDogc3BlYy53aG9sZVdvcmQgPyByZWdleHBXb3JkVGVzdChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkXG4gICAgfSwgZnJvbSwgdG8pO1xufVxuZnVuY3Rpb24gY2hhckJlZm9yZShzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgsIGZhbHNlKSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gY2hhckFmdGVyKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4LCBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cFdvcmRUZXN0KGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChfZnJvbSwgX3RvLCBtYXRjaCkgPT4gIW1hdGNoWzBdLmxlbmd0aCB8fFxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlLnJlcGxhY2UoL1xcJChbJCZcXGQrXSkvZywgKG0sIGkpID0+IGkgPT0gXCIkXCIgPyBcIiRcIlxuICAgICAgICAgICAgOiBpID09IFwiJlwiID8gcmVzdWx0Lm1hdGNoWzBdXG4gICAgICAgICAgICAgICAgOiBpICE9IFwiMFwiICYmICtpIDwgcmVzdWx0Lm1hdGNoLmxlbmd0aCA/IHJlc3VsdC5tYXRjaFtpXVxuICAgICAgICAgICAgICAgICAgICA6IG0pKTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8sIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuLyoqXG5BIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LiBOb3RlIHRoYXRcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbihieSBpbmNsdWRpbmcgW2BzZWFyY2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2gpIGluIHlvdXIgY29uZmlndXJhdGlvbiBvclxuYnkgcnVubmluZyBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgYXQgbGVhc3Rcbm9uY2UpLlxuKi9cbmNvbnN0IHNldFNlYXJjaFF1ZXJ5ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZWFyY2hTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKVxufSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gZ2V0U2VhcmNoUXVlcnkoc3RhdGUpIHtcbiAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xufVxuLyoqXG5RdWVyeSB3aGV0aGVyIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBpbiB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaFBhbmVsT3BlbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYW5lbCkgIT0gbnVsbDtcbn1cbmNsYXNzIFNlYXJjaFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoIGNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCIgfSk7XG5jb25zdCBzZWFyY2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQodmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzLCBsID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3LnN0YXRlLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHZpZXcuc3RhdGUsIHRvLCB0byk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgZWZmZWN0czogYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgaW5zdGFuY2Ugb2YgdGhlIHNlYXJjaCBxdWVyeSxcbmJlZm9yZSB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi4gV2lsbCB3cmFwIHBhc3QgdGhlIHN0YXJ0XG5vZiB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgc2VhcmNoaW5nIGF0IHRoZSBlbmQgYWdhaW4uXG4qL1xuY29uc3QgZmluZFByZXZpb3VzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCByYW5nZSA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFyYW5nZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiByYW5nZS5mcm9tLCBoZWFkOiByYW5nZS50byB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgZWZmZWN0czogYW5ub3VuY2VNYXRjaCh2aWV3LCByYW5nZSksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoZXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuKi9cbmNvbnN0IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpOyAhY3VyLm5leHQoKS5kb25lOykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjdXIudmFsdWUuZnJvbSA9PSBmcm9tKVxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShjdXIudmFsdWUuZnJvbSwgY3VyLnZhbHVlLnRvKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHN0YXRlLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdLCBzZWxlY3Rpb24sIHJlcGxhY2VtZW50O1xuICAgIGxldCBhbm5vdW5jZSA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUudG9UZXh0KHF1ZXJ5LmdldFJlcGxhY2VtZW50KG5leHQpKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dC5mcm9tLCB0bzogbmV4dC50bywgaW5zZXJ0OiByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICAgICAgYW5ub3VuY2UucHVzaChFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcInJlcGxhY2VkIG1hdGNoIG9uIGxpbmUgJFwiLCBzdGF0ZS5kb2MubGluZUF0KGZyb20pLm51bWJlcikgKyBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBsZXQgb2ZmID0gY2hhbmdlcy5sZW5ndGggPT0gMCB8fCBjaGFuZ2VzWzBdLmZyb20gPj0gbmV4dC50byA/IDAgOiBuZXh0LnRvIC0gbmV4dC5mcm9tIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgICAgICBzZWxlY3Rpb24gPSB7IGFuY2hvcjogbmV4dC5mcm9tIC0gb2ZmLCBoZWFkOiBuZXh0LnRvIC0gb2ZmIH07XG4gICAgICAgIGFubm91bmNlLnB1c2goYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLCBzZWxlY3Rpb24sXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiAhIXNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogYW5ub3VuY2UsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5SZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeSB3aXRoIHRoZSBnaXZlblxucmVwbGFjZW1lbnQuXG4qL1xuY29uc3QgcmVwbGFjZUFsbCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMWU5KS5tYXAobWF0Y2ggPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gbWF0Y2g7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCBpbnNlcnQ6IHF1ZXJ5LmdldFJlcGxhY2VtZW50KG1hdGNoKSB9O1xuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYW5ub3VuY2VUZXh0ID0gdmlldy5zdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCAkIG1hdGNoZXNcIiwgY2hhbmdlcy5sZW5ndGgpICsgXCIuXCI7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYW5ub3VuY2VUZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2UuYWxsXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFuZWwodmlldykge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5jcmVhdGVQYW5lbCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRRdWVyeShzdGF0ZSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBzZWxUZXh0ID0gc2VsLmVtcHR5IHx8IHNlbC50byA+IHNlbC5mcm9tICsgMTAwID8gXCJcIiA6IHN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBzZWwudG8pO1xuICAgIGlmIChmYWxsYmFjayAmJiAhc2VsVGV4dClcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIGxldCBjb25maWcgPSBzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgIHNlYXJjaDogKChfYSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25maWcubGl0ZXJhbCkgPyBzZWxUZXh0IDogc2VsVGV4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogKF9iID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmNhc2VTZW5zaXRpdmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbmZpZy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICBsaXRlcmFsOiAoX2MgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29uZmlnLmxpdGVyYWwsXG4gICAgICAgIHdob2xlV29yZDogKF9kID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLndob2xlV29yZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogY29uZmlnLndob2xlV29yZFxuICAgIH0pO1xufVxuLyoqXG5NYWtlIHN1cmUgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGFuZCBmb2N1c2VkLlxuKi9cbmNvbnN0IG9wZW5TZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUucGFuZWwpIHtcbiAgICAgICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgICAgICBpZiAoIXBhbmVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIlttYWluLWZpZWxkXVwiKTtcbiAgICAgICAgaWYgKHNlYXJjaElucHV0ICYmIHNlYXJjaElucHV0ICE9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUucXVlcnkuc3BlYyk7XG4gICAgICAgICAgICBpZiAocXVlcnkudmFsaWQpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlYXJjaFF1ZXJ5Lm9mKHF1ZXJ5KSB9KTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB0b2dnbGVQYW5lbC5vZih0cnVlKSxcbiAgICAgICAgICAgICAgICBzdGF0ZSA/IHNldFNlYXJjaFF1ZXJ5Lm9mKGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKSkgOiBTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2Yoc2VhcmNoRXh0ZW5zaW9ucylcbiAgICAgICAgICAgIF0gfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIHNlYXJjaCBwYW5lbC5cbiovXG5jb25zdCBjbG9zZVNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLnBhbmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgIGlmIChwYW5lbCAmJiBwYW5lbC5kb20uY29udGFpbnModmlldy5yb290LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZVBhbmVsLm9mKGZhbHNlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkRlZmF1bHQgc2VhcmNoLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBNb2QtZjogW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpXG4gLSBGMywgTW9kLWc6IFtgZmluZE5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kTmV4dClcbiAtIFNoaWZ0LUYzLCBTaGlmdC1Nb2QtZzogW2BmaW5kUHJldmlvdXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5maW5kUHJldmlvdXMpXG4gLSBBbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiQWx0LWdcIiwgcnVuOiBnb3RvTGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1kXCIsIHJ1bjogc2VsZWN0TmV4dE9jY3VycmVuY2UsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG5dO1xuY2xhc3MgU2VhcmNoUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpLnF1ZXJ5LnNwZWM7XG4gICAgICAgIHRoaXMuY29tbWl0ID0gdGhpcy5jb21taXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5zZWFyY2gsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInNlYXJjaFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIFwibWFpbi1maWVsZFwiOiBcInRydWVcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5yZXBsYWNlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FzZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJjYXNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LnJlZ2V4cCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JkRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcIndvcmRcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS53aG9sZVdvcmQsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGJ1dHRvbihuYW1lLCBvbmNsaWNrLCBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2ssIHR5cGU6IFwiYnV0dG9uXCIgfSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBvbmtleWRvd246IChlKSA9PiB0aGlzLmtleWRvd24oZSksIGNsYXNzOiBcImNtLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmllbGQsXG4gICAgICAgICAgICBidXR0b24oXCJuZXh0XCIsICgpID0+IGZpbmROZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwibmV4dFwiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwicHJldlwiLCAoKSA9PiBmaW5kUHJldmlvdXModmlldyksIFtwaHJhc2UodmlldywgXCJwcmV2aW91c1wiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwic2VsZWN0XCIsICgpID0+IHNlbGVjdE1hdGNoZXModmlldyksIFtwaHJhc2UodmlldywgXCJhbGxcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLmNhc2VGaWVsZCwgcGhyYXNlKHZpZXcsIFwibWF0Y2ggY2FzZVwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMucmVGaWVsZCwgcGhyYXNlKHZpZXcsIFwicmVnZXhwXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy53b3JkRmllbGQsIHBocmFzZSh2aWV3LCBcImJ5IHdvcmRcIildKSxcbiAgICAgICAgICAgIC4uLnZpZXcuc3RhdGUucmVhZE9ubHkgPyBbXSA6IFtcbiAgICAgICAgICAgICAgICBlbHQoXCJiclwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlXCIsICgpID0+IHJlcGxhY2VOZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZVwiKV0pLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VBbGxcIiwgKCkgPT4gcmVwbGFjZUFsbCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2UgYWxsXCIpXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZVNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJjbG9zZVwiKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgICAgICB9LCBbXCLDl1wiXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZWdleHA6IHRoaXMucmVGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndvcmRGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3LnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7bGluZS5udW1iZXJ9LmApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93ZXN0KHNlYXJjaEhpZ2hsaWdodGVyKSxcbiAgICBiYXNlVGhlbWVcbl07XG5cbmV4cG9ydCB7IFJlZ0V4cEN1cnNvciwgU2VhcmNoQ3Vyc29yLCBTZWFyY2hRdWVyeSwgY2xvc2VTZWFyY2hQYW5lbCwgZmluZE5leHQsIGZpbmRQcmV2aW91cywgZ2V0U2VhcmNoUXVlcnksIGdvdG9MaW5lLCBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBvcGVuU2VhcmNoUGFuZWwsIHJlcGxhY2VBbGwsIHJlcGxhY2VOZXh0LCBzZWFyY2gsIHNlYXJjaEtleW1hcCwgc2VhcmNoUGFuZWxPcGVuLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/search/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Annotation\": () => (/* binding */ Annotation),\n/* harmony export */   \"AnnotationType\": () => (/* binding */ AnnotationType),\n/* harmony export */   \"ChangeDesc\": () => (/* binding */ ChangeDesc),\n/* harmony export */   \"ChangeSet\": () => (/* binding */ ChangeSet),\n/* harmony export */   \"CharCategory\": () => (/* binding */ CharCategory),\n/* harmony export */   \"Compartment\": () => (/* binding */ Compartment),\n/* harmony export */   \"EditorSelection\": () => (/* binding */ EditorSelection),\n/* harmony export */   \"EditorState\": () => (/* binding */ EditorState),\n/* harmony export */   \"Facet\": () => (/* binding */ Facet),\n/* harmony export */   \"Line\": () => (/* binding */ Line),\n/* harmony export */   \"MapMode\": () => (/* binding */ MapMode),\n/* harmony export */   \"Prec\": () => (/* binding */ Prec),\n/* harmony export */   \"Range\": () => (/* binding */ Range),\n/* harmony export */   \"RangeSet\": () => (/* binding */ RangeSet),\n/* harmony export */   \"RangeSetBuilder\": () => (/* binding */ RangeSetBuilder),\n/* harmony export */   \"RangeValue\": () => (/* binding */ RangeValue),\n/* harmony export */   \"SelectionRange\": () => (/* binding */ SelectionRange),\n/* harmony export */   \"StateEffect\": () => (/* binding */ StateEffect),\n/* harmony export */   \"StateEffectType\": () => (/* binding */ StateEffectType),\n/* harmony export */   \"StateField\": () => (/* binding */ StateField),\n/* harmony export */   \"Text\": () => (/* binding */ Text),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"codePointAt\": () => (/* binding */ codePointAt),\n/* harmony export */   \"codePointSize\": () => (/* binding */ codePointSize),\n/* harmony export */   \"combineConfig\": () => (/* binding */ combineConfig),\n/* harmony export */   \"countColumn\": () => (/* binding */ countColumn),\n/* harmony export */   \"findClusterBreak\": () => (/* binding */ findClusterBreak),\n/* harmony export */   \"findColumn\": () => (/* binding */ findColumn),\n/* harmony export */   \"fromCodePoint\": () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/**\nThe data structure for documents. @nonabstract\n*/\nclass Text {\n  /**\n  @internal\n  */\n  constructor() {}\n  /**\n  Get the line description around the given position.\n  */\n  lineAt(pos) {\n    if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n    return this.lineInner(pos, false, 1, 0);\n  }\n  /**\n  Get the description for the given (1-based) line number.\n  */\n  line(n) {\n    if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n    return this.lineInner(n, true, 1, 0);\n  }\n  /**\n  Replace a range of the text with the given content.\n  */\n  replace(from, to, text) {\n    let parts = [];\n    this.decompose(0, from, parts, 2 /* Open.To */);\n    if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);\n    this.decompose(to, this.length, parts, 1 /* Open.From */);\n    return TextNode.from(parts, this.length - (to - from) + text.length);\n  }\n  /**\n  Append another document to this one.\n  */\n  append(other) {\n    return this.replace(this.length, this.length, other);\n  }\n  /**\n  Retrieve the text between the given points.\n  */\n  slice(from, to = this.length) {\n    let parts = [];\n    this.decompose(from, to, parts, 0);\n    return TextNode.from(parts, to - from);\n  }\n  /**\n  Test whether this text is equal to another instance.\n  */\n  eq(other) {\n    if (other == this) return true;\n    if (other.length != this.length || other.lines != this.lines) return false;\n    let start = this.scanIdentical(other, 1),\n      end = this.length - this.scanIdentical(other, -1);\n    let a = new RawTextCursor(this),\n      b = new RawTextCursor(other);\n    for (let skip = start, pos = start;;) {\n      a.next(skip);\n      b.next(skip);\n      skip = 0;\n      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n      pos += a.value.length;\n      if (a.done || pos >= end) return true;\n    }\n  }\n  /**\n  Iterate over the text. When `dir` is `-1`, iteration happens\n  from end to start. This will return lines and the breaks between\n  them as separate strings.\n  */\n  iter(dir = 1) {\n    return new RawTextCursor(this, dir);\n  }\n  /**\n  Iterate over a range of the text. When `from` > `to`, the\n  iterator will run in reverse.\n  */\n  iterRange(from, to = this.length) {\n    return new PartialTextCursor(this, from, to);\n  }\n  /**\n  Return a cursor that iterates over the given range of lines,\n  _without_ returning the line breaks between, and yielding empty\n  strings for empty lines.\n  \n  When `from` and `to` are given, they should be 1-based line numbers.\n  */\n  iterLines(from, to) {\n    let inner;\n    if (from == null) {\n      inner = this.iter();\n    } else {\n      if (to == null) to = this.lines + 1;\n      let start = this.line(from).from;\n      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n    }\n    return new LineCursor(inner);\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this.sliceString(0);\n  }\n  /**\n  Convert the document to an array of lines (which can be\n  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n  */\n  toJSON() {\n    let lines = [];\n    this.flatten(lines);\n    return lines;\n  }\n  /**\n  Create a `Text` instance for the given array of lines.\n  */\n  static of(text) {\n    if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n    if (text.length == 1 && !text[0]) return Text.empty;\n    return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n  }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n  constructor(text, length = textLength(text)) {\n    super();\n    this.text = text;\n    this.length = length;\n  }\n  get lines() {\n    return this.text.length;\n  }\n  get children() {\n    return null;\n  }\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0;; i++) {\n      let string = this.text[i],\n        end = offset + string.length;\n      if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n      offset = end + 1;\n      line++;\n    }\n  }\n  decompose(from, to, target, open) {\n    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n    if (open & 1 /* Open.From */) {\n      let prev = target.pop();\n      let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n      if (joined.length <= 32 /* Tree.Branch */) {\n        target.push(new TextLeaf(joined, prev.length + text.length));\n      } else {\n        let mid = joined.length >> 1;\n        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n      }\n    } else {\n      target.push(text);\n    }\n  }\n  replace(from, to, text) {\n    if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n    let newLen = this.length + text.length - (to - from);\n    if (lines.length <= 32 /* Tree.Branch */) return new TextLeaf(lines, newLen);\n    return TextNode.from(TextLeaf.split(lines, []), newLen);\n  }\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    let result = \"\";\n    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n      let line = this.text[i],\n        end = pos + line.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n      pos = end + 1;\n    }\n    return result;\n  }\n  flatten(target) {\n    for (let line of this.text) target.push(line);\n  }\n  scanIdentical() {\n    return 0;\n  }\n  static split(text, target) {\n    let part = [],\n      len = -1;\n    for (let line of text) {\n      part.push(line);\n      len += line.length + 1;\n      if (part.length == 32 /* Tree.Branch */) {\n        target.push(new TextLeaf(part, len));\n        part = [];\n        len = -1;\n      }\n    }\n    if (len > -1) target.push(new TextLeaf(part, len));\n    return target;\n  }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n  constructor(children, length) {\n    super();\n    this.children = children;\n    this.length = length;\n    this.lines = 0;\n    for (let child of children) this.lines += child.lines;\n  }\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0;; i++) {\n      let child = this.children[i],\n        end = offset + child.length,\n        endLine = line + child.lines - 1;\n      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n      offset = end + 1;\n      line = endLine + 1;\n    }\n  }\n  decompose(from, to, target, open) {\n    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (from <= end && to >= pos) {\n        let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));\n        if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);\n      }\n      pos = end + 1;\n    }\n  }\n  replace(from, to, text) {\n    if (text.lines < this.lines) for (let i = 0, pos = 0; i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      // Fast path: if the change only affects one child and the\n      // child's size remains in the acceptable range, only update\n      // that child\n      if (from >= pos && to <= end) {\n        let updated = child.replace(from - pos, to - pos, text);\n        let totalLines = this.lines - child.lines + updated.lines;\n        if (updated.lines < totalLines >> 5 /* Tree.BranchShift */ - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */ + 1) {\n          let copy = this.children.slice();\n          copy[i] = updated;\n          return new TextNode(copy, this.length - (to - from) + text.length);\n        }\n        return super.replace(pos, end, updated);\n      }\n      pos = end + 1;\n    }\n    return super.replace(from, to, text);\n  }\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    let result = \"\";\n    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n      pos = end + 1;\n    }\n    return result;\n  }\n  flatten(target) {\n    for (let child of this.children) child.flatten(target);\n  }\n  scanIdentical(other, dir) {\n    if (!(other instanceof TextNode)) return 0;\n    let length = 0;\n    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];\n    for (;; iA += dir, iB += dir) {\n      if (iA == eA || iB == eB) return length;\n      let chA = this.children[iA],\n        chB = other.children[iB];\n      if (chA != chB) return length + chA.scanIdentical(chB, dir);\n      length += chA.length + 1;\n    }\n  }\n  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n    let lines = 0;\n    for (let ch of children) lines += ch.lines;\n    if (lines < 32 /* Tree.Branch */) {\n      let flat = [];\n      for (let ch of children) ch.flatten(flat);\n      return new TextLeaf(flat, length);\n    }\n    let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */),\n      maxChunk = chunk << 1,\n      minChunk = chunk >> 1;\n    let chunked = [],\n      currentLines = 0,\n      currentLen = -1,\n      currentChunk = [];\n    function add(child) {\n      let last;\n      if (child.lines > maxChunk && child instanceof TextNode) {\n        for (let node of child.children) add(node);\n      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n        flush();\n        chunked.push(child);\n      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */) {\n        currentLines += child.lines;\n        currentLen += child.length + 1;\n        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n      } else {\n        if (currentLines + child.lines > chunk) flush();\n        currentLines += child.lines;\n        currentLen += child.length + 1;\n        currentChunk.push(child);\n      }\n    }\n    function flush() {\n      if (currentLines == 0) return;\n      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n      currentLen = -1;\n      currentLines = currentChunk.length = 0;\n    }\n    for (let child of children) add(child);\n    flush();\n    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n  }\n}\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n  let length = -1;\n  for (let line of text) length += line.length + 1;\n  return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n    let line = text[i],\n      end = pos + line.length;\n    if (end >= from) {\n      if (end > to) line = line.slice(0, to - pos);\n      if (pos < from) line = line.slice(from - pos);\n      if (first) {\n        target[target.length - 1] += line;\n        first = false;\n      } else target.push(line);\n    }\n    pos = end + 1;\n  }\n  return target;\n}\nfunction sliceText(text, from, to) {\n  return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n  constructor(text, dir = 1) {\n    this.dir = dir;\n    this.done = false;\n    this.lineBreak = false;\n    this.value = \"\";\n    this.nodes = [text];\n    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\n  }\n  nextInner(skip, dir) {\n    this.done = this.lineBreak = false;\n    for (;;) {\n      let last = this.nodes.length - 1;\n      let top = this.nodes[last],\n        offsetValue = this.offsets[last],\n        offset = offsetValue >> 1;\n      let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n      if (offset == (dir > 0 ? size : 0)) {\n        if (last == 0) {\n          this.done = true;\n          this.value = \"\";\n          return this;\n        }\n        if (dir > 0) this.offsets[last - 1]++;\n        this.nodes.pop();\n        this.offsets.pop();\n      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n        this.offsets[last] += dir;\n        if (skip == 0) {\n          this.lineBreak = true;\n          this.value = \"\\n\";\n          return this;\n        }\n        skip--;\n      } else if (top instanceof TextLeaf) {\n        // Move to the next string\n        let next = top.text[offset + (dir < 0 ? -1 : 0)];\n        this.offsets[last] += dir;\n        if (next.length > Math.max(0, skip)) {\n          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n          return this;\n        }\n        skip -= next.length;\n      } else {\n        let next = top.children[offset + (dir < 0 ? -1 : 0)];\n        if (skip > next.length) {\n          skip -= next.length;\n          this.offsets[last] += dir;\n        } else {\n          if (dir < 0) this.offsets[last]--;\n          this.nodes.push(next);\n          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n        }\n      }\n    }\n  }\n  next(skip = 0) {\n    if (skip < 0) {\n      this.nextInner(-skip, -this.dir);\n      skip = this.value.length;\n    }\n    return this.nextInner(skip, this.dir);\n  }\n}\nclass PartialTextCursor {\n  constructor(text, start, end) {\n    this.value = \"\";\n    this.done = false;\n    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n    this.pos = start > end ? text.length : 0;\n    this.from = Math.min(start, end);\n    this.to = Math.max(start, end);\n  }\n  nextInner(skip, dir) {\n    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n      this.value = \"\";\n      this.done = true;\n      return this;\n    }\n    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n    if (skip > limit) skip = limit;\n    limit -= skip;\n    let {\n      value\n    } = this.cursor.next(skip);\n    this.pos += (value.length + skip) * dir;\n    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n    this.done = !this.value;\n    return this;\n  }\n  next(skip = 0) {\n    if (skip < 0) skip = Math.max(skip, this.from - this.pos);else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n    return this.nextInner(skip, this.cursor.dir);\n  }\n  get lineBreak() {\n    return this.cursor.lineBreak && this.value != \"\";\n  }\n}\nclass LineCursor {\n  constructor(inner) {\n    this.inner = inner;\n    this.afterBreak = true;\n    this.value = \"\";\n    this.done = false;\n  }\n  next(skip = 0) {\n    let {\n      done,\n      lineBreak,\n      value\n    } = this.inner.next(skip);\n    if (done) {\n      this.done = true;\n      this.value = \"\";\n    } else if (lineBreak) {\n      if (this.afterBreak) {\n        this.value = \"\";\n      } else {\n        this.afterBreak = true;\n        this.next();\n      }\n    } else {\n      this.value = value;\n      this.afterBreak = false;\n    }\n    return this;\n  }\n  get lineBreak() {\n    return false;\n  }\n}\nif (typeof Symbol != \"undefined\") {\n  Text.prototype[Symbol.iterator] = function () {\n    return this.iter();\n  };\n  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/\nclass Line {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The position of the start of the line.\n  */\n  from,\n  /**\n  The position at the end of the line (_before_ the line break,\n  or at the end of document for the last line).\n  */\n  to,\n  /**\n  This line's line number (1-based).\n  */\n  number,\n  /**\n  The line's content.\n  */\n  text) {\n    this.from = from;\n    this.to = to;\n    this.number = number;\n    this.text = text;\n  }\n  /**\n  The length of the line (not including any line break after it).\n  */\n  get length() {\n    return this.to - this.from;\n  }\n}\n\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = /*@__PURE__*/\"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++) extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n  for (let i = 1; i < extend.length; i += 2) if (extend[i] > code) return extend[i - 1] <= code;\n  return false;\n}\nfunction isRegionalIndicator(code) {\n  return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/\nfunction findClusterBreak(str, pos, forward = true, includeExtending = true) {\n  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\n}\nfunction nextClusterBreak(str, pos, includeExtending) {\n  if (pos == str.length) return pos;\n  // If pos is in the middle of a surrogate pair, move to its start\n  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n  let prev = codePointAt(str, pos);\n  pos += codePointSize(prev);\n  while (pos < str.length) {\n    let next = codePointAt(str, pos);\n    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\n      pos += codePointSize(next);\n      prev = next;\n    } else if (isRegionalIndicator(next)) {\n      let countBefore = 0,\n        i = pos - 2;\n      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n        countBefore++;\n        i -= 2;\n      }\n      if (countBefore % 2 == 0) break;else pos += 2;\n    } else {\n      break;\n    }\n  }\n  return pos;\n}\nfunction prevClusterBreak(str, pos, includeExtending) {\n  while (pos > 0) {\n    let found = nextClusterBreak(str, pos - 2, includeExtending);\n    if (found < pos) return found;\n    pos--;\n  }\n  return 0;\n}\nfunction surrogateLow(ch) {\n  return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n  return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/\nfunction codePointAt(str, pos) {\n  let code0 = str.charCodeAt(pos);\n  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n  let code1 = str.charCodeAt(pos + 1);\n  if (!surrogateLow(code1)) return code0;\n  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/\nfunction fromCodePoint(code) {\n  if (code <= 0xffff) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up a JavaScript string.\n*/\nfunction codePointSize(code) {\n  return code < 0x10000 ? 1 : 2;\n}\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/\nvar MapMode = /*@__PURE__*/function (MapMode) {\n  /**\n  Map a position to a valid new position, even when its context\n  was deleted.\n  */\n  MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n  /**\n  Return null if deletion happens across the position.\n  */\n  MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n  /**\n  Return null if the character _before_ the position is deleted.\n  */\n  MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n  /**\n  Return null if the character _after_ the position is deleted.\n  */\n  MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n  return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/\nclass ChangeDesc {\n  // Sections are encoded as pairs of integers. The first is the\n  // length in the current document, and the second is -1 for\n  // unaffected sections, and the length of the replacement content\n  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n  // 0), and a replacement two positive numbers.\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  sections) {\n    this.sections = sections;\n  }\n  /**\n  The length of the document before the change.\n  */\n  get length() {\n    let result = 0;\n    for (let i = 0; i < this.sections.length; i += 2) result += this.sections[i];\n    return result;\n  }\n  /**\n  The length of the document after the change.\n  */\n  get newLength() {\n    let result = 0;\n    for (let i = 0; i < this.sections.length; i += 2) {\n      let ins = this.sections[i + 1];\n      result += ins < 0 ? this.sections[i] : ins;\n    }\n    return result;\n  }\n  /**\n  False when there are actual changes in this set.\n  */\n  get empty() {\n    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n  }\n  /**\n  Iterate over the unchanged parts left by these changes. `posA`\n  provides the position of the range in the old document, `posB`\n  the new position in the changed document.\n  */\n  iterGaps(f) {\n    for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++];\n      if (ins < 0) {\n        f(posA, posB, len);\n        posB += len;\n      } else {\n        posB += ins;\n      }\n      posA += len;\n    }\n  }\n  /**\n  Iterate over the ranges changed by these changes. (See\n  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n  variant that also provides you with the inserted text.)\n  `fromA`/`toA` provides the extent of the change in the starting\n  document, `fromB`/`toB` the extent of the replacement in the\n  changed document.\n  \n  When `individual` is true, adjacent changes (which are kept\n  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n  reported separately.\n  */\n  iterChangedRanges(f, individual = false) {\n    iterChanges(this, f, individual);\n  }\n  /**\n  Get a description of the inverted form of these changes.\n  */\n  get invertedDesc() {\n    let sections = [];\n    for (let i = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++];\n      if (ins < 0) sections.push(len, ins);else sections.push(ins, len);\n    }\n    return new ChangeDesc(sections);\n  }\n  /**\n  Compute the combined effect of applying another set of changes\n  after this one. The length of the document after this set should\n  match the length before `other`.\n  */\n  composeDesc(other) {\n    return this.empty ? other : other.empty ? this : composeSets(this, other);\n  }\n  /**\n  Map this description, which should start with the same document\n  as `other`, over another set of changes, so that it can be\n  applied after it. When `before` is true, map as if the changes\n  in `other` happened before the ones in `this`.\n  */\n  mapDesc(other, before = false) {\n    return other.empty ? this : mapSet(this, other, before);\n  }\n  mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n    let posA = 0,\n      posB = 0;\n    for (let i = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++],\n        endA = posA + len;\n      if (ins < 0) {\n        if (endA > pos) return posB + (pos - posA);\n        posB += len;\n      } else {\n        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n        if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n        posB += ins;\n      }\n      posA = endA;\n    }\n    if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n    return posB;\n  }\n  /**\n  Check whether these changes touch a given range. When one of the\n  changes entirely covers the range, the string `\"cover\"` is\n  returned.\n  */\n  touchesRange(from, to = from) {\n    for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++],\n        end = pos + len;\n      if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n      pos = end;\n    }\n    return false;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let result = \"\";\n    for (let i = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++];\n      result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n    }\n    return result;\n  }\n  /**\n  Serialize this change desc to a JSON-representable value.\n  */\n  toJSON() {\n    return this.sections;\n  }\n  /**\n  Create a change desc from its JSON representation (as produced\n  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n  */\n  static fromJSON(json) {\n    if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != \"number\")) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n    return new ChangeDesc(json);\n  }\n  /**\n  @internal\n  */\n  static create(sections) {\n    return new ChangeDesc(sections);\n  }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/\nclass ChangeSet extends ChangeDesc {\n  constructor(sections,\n  /**\n  @internal\n  */\n  inserted) {\n    super(sections);\n    this.inserted = inserted;\n  }\n  /**\n  Apply the changes to a document, returning the modified\n  document.\n  */\n  apply(doc) {\n    if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n    return doc;\n  }\n  mapDesc(other, before = false) {\n    return mapSet(this, other, before, true);\n  }\n  /**\n  Given the document as it existed _before_ the changes, return a\n  change set that represents the inverse of this set, which could\n  be used to go from the document created by the changes back to\n  the document as it existed before the changes.\n  */\n  invert(doc) {\n    let sections = this.sections.slice(),\n      inserted = [];\n    for (let i = 0, pos = 0; i < sections.length; i += 2) {\n      let len = sections[i],\n        ins = sections[i + 1];\n      if (ins >= 0) {\n        sections[i] = ins;\n        sections[i + 1] = len;\n        let index = i >> 1;\n        while (inserted.length < index) inserted.push(Text.empty);\n        inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n      }\n      pos += len;\n    }\n    return new ChangeSet(sections, inserted);\n  }\n  /**\n  Combine two subsequent change sets into a single set. `other`\n  must start in the document produced by `this`. If `this` goes\n  `docA` → `docB` and `other` represents `docB` → `docC`, the\n  returned value will represent the change `docA` → `docC`.\n  */\n  compose(other) {\n    return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n  }\n  /**\n  Given another change set starting in the same document, maps this\n  change set over the other, producing a new change set that can be\n  applied to the document produced by applying `other`. When\n  `before` is `true`, order changes as if `this` comes before\n  `other`, otherwise (the default) treat `other` as coming first.\n  \n  Given two changes `A` and `B`, `A.compose(B.map(A))` and\n  `B.compose(A.map(B, true))` will produce the same document. This\n  provides a basic form of [operational\n  transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n  and can be used for collaborative editing.\n  */\n  map(other, before = false) {\n    return other.empty ? this : mapSet(this, other, before, true);\n  }\n  /**\n  Iterate over the changed ranges in the document, calling `f` for\n  each, with the range in the original document (`fromA`-`toA`)\n  and the range that replaces it in the new document\n  (`fromB`-`toB`).\n  \n  When `individual` is true, adjacent changes are reported\n  separately.\n  */\n  iterChanges(f, individual = false) {\n    iterChanges(this, f, individual);\n  }\n  /**\n  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n  set.\n  */\n  get desc() {\n    return ChangeDesc.create(this.sections);\n  }\n  /**\n  @internal\n  */\n  filter(ranges) {\n    let resultSections = [],\n      resultInserted = [],\n      filteredSections = [];\n    let iter = new SectionIter(this);\n    done: for (let i = 0, pos = 0;;) {\n      let next = i == ranges.length ? 1e9 : ranges[i++];\n      while (pos < next || pos == next && iter.len == 0) {\n        if (iter.done) break done;\n        let len = Math.min(iter.len, next - pos);\n        addSection(filteredSections, len, -1);\n        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n        addSection(resultSections, len, ins);\n        if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n        iter.forward(len);\n        pos += len;\n      }\n      let end = ranges[i++];\n      while (pos < end) {\n        if (iter.done) break done;\n        let len = Math.min(iter.len, end - pos);\n        addSection(resultSections, len, -1);\n        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n        iter.forward(len);\n        pos += len;\n      }\n    }\n    return {\n      changes: new ChangeSet(resultSections, resultInserted),\n      filtered: ChangeDesc.create(filteredSections)\n    };\n  }\n  /**\n  Serialize this change set to a JSON-representable value.\n  */\n  toJSON() {\n    let parts = [];\n    for (let i = 0; i < this.sections.length; i += 2) {\n      let len = this.sections[i],\n        ins = this.sections[i + 1];\n      if (ins < 0) parts.push(len);else if (ins == 0) parts.push([len]);else parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n    }\n    return parts;\n  }\n  /**\n  Create a change set for the given changes, for a document of the\n  given length, using `lineSep` as line separator.\n  */\n  static of(changes, length, lineSep) {\n    let sections = [],\n      inserted = [],\n      pos = 0;\n    let total = null;\n    function flush(force = false) {\n      if (!force && !sections.length) return;\n      if (pos < length) addSection(sections, length - pos, -1);\n      let set = new ChangeSet(sections, inserted);\n      total = total ? total.compose(set.map(total)) : set;\n      sections = [];\n      inserted = [];\n      pos = 0;\n    }\n    function process(spec) {\n      if (Array.isArray(spec)) {\n        for (let sub of spec) process(sub);\n      } else if (spec instanceof ChangeSet) {\n        if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n        flush();\n        total = total ? total.compose(spec.map(total)) : spec;\n      } else {\n        let {\n          from,\n          to = from,\n          insert\n        } = spec;\n        if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n        let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n        let insLen = insText.length;\n        if (from == to && insLen == 0) return;\n        if (from < pos) flush();\n        if (from > pos) addSection(sections, from - pos, -1);\n        addSection(sections, to - from, insLen);\n        addInsert(inserted, sections, insText);\n        pos = to;\n      }\n    }\n    process(changes);\n    flush(!total);\n    return total;\n  }\n  /**\n  Create an empty changeset of the given length.\n  */\n  static empty(length) {\n    return new ChangeSet(length ? [length, -1] : [], []);\n  }\n  /**\n  Create a changeset from its JSON representation (as produced by\n  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n  */\n  static fromJSON(json) {\n    if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n    let sections = [],\n      inserted = [];\n    for (let i = 0; i < json.length; i++) {\n      let part = json[i];\n      if (typeof part == \"number\") {\n        sections.push(part, -1);\n      } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n        throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n      } else if (part.length == 1) {\n        sections.push(part[0], 0);\n      } else {\n        while (inserted.length < i) inserted.push(Text.empty);\n        inserted[i] = Text.of(part.slice(1));\n        sections.push(part[0], inserted[i].length);\n      }\n    }\n    return new ChangeSet(sections, inserted);\n  }\n  /**\n  @internal\n  */\n  static createSet(sections, inserted) {\n    return new ChangeSet(sections, inserted);\n  }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n  if (len == 0 && ins <= 0) return;\n  let last = sections.length - 2;\n  if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;else if (forceJoin) {\n    sections[last] += len;\n    sections[last + 1] += ins;\n  } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n  if (value.length == 0) return;\n  let index = sections.length - 2 >> 1;\n  if (index < values.length) {\n    values[values.length - 1] = values[values.length - 1].append(value);\n  } else {\n    while (values.length < index) values.push(Text.empty);\n    values.push(value);\n  }\n}\nfunction iterChanges(desc, f, individual) {\n  let inserted = desc.inserted;\n  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n    let len = desc.sections[i++],\n      ins = desc.sections[i++];\n    if (ins < 0) {\n      posA += len;\n      posB += len;\n    } else {\n      let endA = posA,\n        endB = posB,\n        text = Text.empty;\n      for (;;) {\n        endA += len;\n        endB += ins;\n        if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n        len = desc.sections[i++];\n        ins = desc.sections[i++];\n      }\n      f(posA, endA, posB, endB, text);\n      posA = endA;\n      posB = endB;\n    }\n  }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n  // Produce a copy of setA that applies to the document after setB\n  // has been applied (assuming both start at the same document).\n  let sections = [],\n    insert = mkSet ? [] : null;\n  let a = new SectionIter(setA),\n    b = new SectionIter(setB);\n  // Iterate over both sets in parallel. inserted tracks, for changes\n  // in A that have to be processed piece-by-piece, whether their\n  // content has been inserted already, and refers to the section\n  // index.\n  for (let inserted = -1;;) {\n    if (a.ins == -1 && b.ins == -1) {\n      // Move across ranges skipped by both sets.\n      let len = Math.min(a.len, b.len);\n      addSection(sections, len, -1);\n      a.forward(len);\n      b.forward(len);\n    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n      // If there's a change in B that comes before the next change in\n      // A (ordered by start pos, then len, then before flag), skip\n      // that (and process any changes in A it covers).\n      let len = b.len;\n      addSection(sections, b.ins, -1);\n      while (len) {\n        let piece = Math.min(a.len, len);\n        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n          addSection(sections, 0, a.ins);\n          if (insert) addInsert(insert, sections, a.text);\n          inserted = a.i;\n        }\n        a.forward(piece);\n        len -= piece;\n      }\n      b.next();\n    } else if (a.ins >= 0) {\n      // Process the part of a change in A up to the start of the next\n      // non-deletion change in B (if overlapping).\n      let len = 0,\n        left = a.len;\n      while (left) {\n        if (b.ins == -1) {\n          let piece = Math.min(left, b.len);\n          len += piece;\n          left -= piece;\n          b.forward(piece);\n        } else if (b.ins == 0 && b.len < left) {\n          left -= b.len;\n          b.next();\n        } else {\n          break;\n        }\n      }\n      addSection(sections, len, inserted < a.i ? a.ins : 0);\n      if (insert && inserted < a.i) addInsert(insert, sections, a.text);\n      inserted = a.i;\n      a.forward(a.len - left);\n    } else if (a.done && b.done) {\n      return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n    } else {\n      throw new Error(\"Mismatched change set lengths\");\n    }\n  }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n  let sections = [];\n  let insert = mkSet ? [] : null;\n  let a = new SectionIter(setA),\n    b = new SectionIter(setB);\n  for (let open = false;;) {\n    if (a.done && b.done) {\n      return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n    } else if (a.ins == 0) {\n      // Deletion in A\n      addSection(sections, a.len, 0, open);\n      a.next();\n    } else if (b.len == 0 && !b.done) {\n      // Insertion in B\n      addSection(sections, 0, b.ins, open);\n      if (insert) addInsert(insert, sections, b.text);\n      b.next();\n    } else if (a.done || b.done) {\n      throw new Error(\"Mismatched change set lengths\");\n    } else {\n      let len = Math.min(a.len2, b.len),\n        sectionLen = sections.length;\n      if (a.ins == -1) {\n        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n        addSection(sections, len, insB, open);\n        if (insert && insB) addInsert(insert, sections, b.text);\n      } else if (b.ins == -1) {\n        addSection(sections, a.off ? 0 : a.len, len, open);\n        if (insert) addInsert(insert, sections, a.textBit(len));\n      } else {\n        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n        if (insert && !b.off) addInsert(insert, sections, b.text);\n      }\n      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n      a.forward2(len);\n      b.forward(len);\n    }\n  }\n}\nclass SectionIter {\n  constructor(set) {\n    this.set = set;\n    this.i = 0;\n    this.next();\n  }\n  next() {\n    let {\n      sections\n    } = this.set;\n    if (this.i < sections.length) {\n      this.len = sections[this.i++];\n      this.ins = sections[this.i++];\n    } else {\n      this.len = 0;\n      this.ins = -2;\n    }\n    this.off = 0;\n  }\n  get done() {\n    return this.ins == -2;\n  }\n  get len2() {\n    return this.ins < 0 ? this.len : this.ins;\n  }\n  get text() {\n    let {\n        inserted\n      } = this.set,\n      index = this.i - 2 >> 1;\n    return index >= inserted.length ? Text.empty : inserted[index];\n  }\n  textBit(len) {\n    let {\n        inserted\n      } = this.set,\n      index = this.i - 2 >> 1;\n    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n  }\n  forward(len) {\n    if (len == this.len) this.next();else {\n      this.len -= len;\n      this.off += len;\n    }\n  }\n  forward2(len) {\n    if (this.ins == -1) this.forward(len);else if (len == this.ins) this.next();else {\n      this.ins -= len;\n      this.off += len;\n    }\n  }\n}\n\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/\nclass SelectionRange {\n  constructor(\n  /**\n  The lower boundary of the range.\n  */\n  from,\n  /**\n  The upper boundary of the range.\n  */\n  to, flags) {\n    this.from = from;\n    this.to = to;\n    this.flags = flags;\n  }\n  /**\n  The anchor of the range—the side that doesn't move when you\n  extend it.\n  */\n  get anchor() {\n    return this.flags & 16 /* RangeFlag.Inverted */ ? this.to : this.from;\n  }\n  /**\n  The head of the range, which is moved when the range is\n  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n  */\n  get head() {\n    return this.flags & 16 /* RangeFlag.Inverted */ ? this.from : this.to;\n  }\n  /**\n  True when `anchor` and `head` are at the same position.\n  */\n  get empty() {\n    return this.from == this.to;\n  }\n  /**\n  If this is a cursor that is explicitly associated with the\n  character on one of its sides, this returns the side. -1 means\n  the character before its position, 1 the character after, and 0\n  means no association.\n  */\n  get assoc() {\n    return this.flags & 4 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 8 /* RangeFlag.AssocAfter */ ? 1 : 0;\n  }\n  /**\n  The bidirectional text level associated with this cursor, if\n  any.\n  */\n  get bidiLevel() {\n    let level = this.flags & 3 /* RangeFlag.BidiLevelMask */;\n    return level == 3 ? null : level;\n  }\n  /**\n  The goal column (stored vertical offset) associated with a\n  cursor. This is used to preserve the vertical position when\n  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n  lines of different length.\n  */\n  get goalColumn() {\n    let value = this.flags >> 5 /* RangeFlag.GoalColumnOffset */;\n    return value == 33554431 /* RangeFlag.NoGoalColumn */ ? undefined : value;\n  }\n  /**\n  Map this range through a change, producing a valid range in the\n  updated document.\n  */\n  map(change, assoc = -1) {\n    let from, to;\n    if (this.empty) {\n      from = to = change.mapPos(this.from, assoc);\n    } else {\n      from = change.mapPos(this.from, 1);\n      to = change.mapPos(this.to, -1);\n    }\n    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n  }\n  /**\n  Extend this range to cover at least `from` to `to`.\n  */\n  extend(from, to = from) {\n    if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n    return EditorSelection.range(this.anchor, head);\n  }\n  /**\n  Compare this range to another range.\n  */\n  eq(other) {\n    return this.anchor == other.anchor && this.head == other.head;\n  }\n  /**\n  Return a JSON-serializable object representing the range.\n  */\n  toJSON() {\n    return {\n      anchor: this.anchor,\n      head: this.head\n    };\n  }\n  /**\n  Convert a JSON representation of a range to a `SelectionRange`\n  instance.\n  */\n  static fromJSON(json) {\n    if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n    return EditorSelection.range(json.anchor, json.head);\n  }\n  /**\n  @internal\n  */\n  static create(from, to, flags) {\n    return new SelectionRange(from, to, flags);\n  }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/\nclass EditorSelection {\n  constructor(\n  /**\n  The ranges in the selection, sorted by position. Ranges cannot\n  overlap (but they may touch, if they aren't empty).\n  */\n  ranges,\n  /**\n  The index of the _main_ range in the selection (which is\n  usually the range that was added last).\n  */\n  mainIndex) {\n    this.ranges = ranges;\n    this.mainIndex = mainIndex;\n  }\n  /**\n  Map a selection through a change. Used to adjust the selection\n  position for changes.\n  */\n  map(change, assoc = -1) {\n    if (change.empty) return this;\n    return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\n  }\n  /**\n  Compare this selection to another selection.\n  */\n  eq(other) {\n    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n    for (let i = 0; i < this.ranges.length; i++) if (!this.ranges[i].eq(other.ranges[i])) return false;\n    return true;\n  }\n  /**\n  Get the primary selection range. Usually, you should make sure\n  your code applies to _all_ ranges, by using methods like\n  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n  */\n  get main() {\n    return this.ranges[this.mainIndex];\n  }\n  /**\n  Make sure the selection only has one range. Returns a selection\n  holding only the main range from this selection.\n  */\n  asSingle() {\n    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);\n  }\n  /**\n  Extend this selection with an extra range.\n  */\n  addRange(range, main = true) {\n    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n  }\n  /**\n  Replace a given range with another range, and then normalize the\n  selection to merge and sort ranges if necessary.\n  */\n  replaceRange(range, which = this.mainIndex) {\n    let ranges = this.ranges.slice();\n    ranges[which] = range;\n    return EditorSelection.create(ranges, this.mainIndex);\n  }\n  /**\n  Convert this selection to an object that can be serialized to\n  JSON.\n  */\n  toJSON() {\n    return {\n      ranges: this.ranges.map(r => r.toJSON()),\n      main: this.mainIndex\n    };\n  }\n  /**\n  Create a selection from a JSON representation.\n  */\n  static fromJSON(json) {\n    if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n    return new EditorSelection(json.ranges.map(r => SelectionRange.fromJSON(r)), json.main);\n  }\n  /**\n  Create a selection holding a single range.\n  */\n  static single(anchor, head = anchor) {\n    return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n  }\n  /**\n  Sort and merge the given set of ranges, creating a valid\n  selection.\n  */\n  static create(ranges, mainIndex = 0) {\n    if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n    for (let pos = 0, i = 0; i < ranges.length; i++) {\n      let range = ranges[i];\n      if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);\n      pos = range.to;\n    }\n    return new EditorSelection(ranges, mainIndex);\n  }\n  /**\n  Create a cursor selection range at the given position. You can\n  safely ignore the optional arguments in most situations.\n  */\n  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* RangeFlag.AssocBefore */ : 8 /* RangeFlag.AssocAfter */) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */);\n  }\n  /**\n  Create a selection range.\n  */\n  static range(anchor, head, goalColumn, bidiLevel) {\n    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* RangeFlag.NoGoalColumn */) << 5 /* RangeFlag.GoalColumnOffset */ | (bidiLevel == null ? 3 : Math.min(2, bidiLevel));\n    return head < anchor ? SelectionRange.create(head, anchor, 16 /* RangeFlag.Inverted */ | 8 /* RangeFlag.AssocAfter */ | flags) : SelectionRange.create(anchor, head, (head > anchor ? 4 /* RangeFlag.AssocBefore */ : 0) | flags);\n  }\n  /**\n  @internal\n  */\n  static normalized(ranges, mainIndex = 0) {\n    let main = ranges[mainIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    mainIndex = ranges.indexOf(main);\n    for (let i = 1; i < ranges.length; i++) {\n      let range = ranges[i],\n        prev = ranges[i - 1];\n      if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n        let from = prev.from,\n          to = Math.max(range.to, prev.to);\n        if (i <= mainIndex) mainIndex--;\n        ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n      }\n    }\n    return new EditorSelection(ranges, mainIndex);\n  }\n}\nfunction checkSelection(selection, docLength) {\n  for (let range of selection.ranges) if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n*/\nclass Facet {\n  constructor(\n  /**\n  @internal\n  */\n  combine,\n  /**\n  @internal\n  */\n  compareInput,\n  /**\n  @internal\n  */\n  compare, isStatic, enables) {\n    this.combine = combine;\n    this.compareInput = compareInput;\n    this.compare = compare;\n    this.isStatic = isStatic;\n    /**\n    @internal\n    */\n    this.id = nextID++;\n    this.default = combine([]);\n    this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n  }\n  /**\n  Define a new facet.\n  */\n  static define(config = {}) {\n    return new Facet(config.combine || (a => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n  }\n  /**\n  Returns an extension that adds the given value to this facet.\n  */\n  of(value) {\n    return new FacetProvider([], this, 0 /* Provider.Static */, value);\n  }\n  /**\n  Create an extension that computes a value for the facet from a\n  state. You must take care to declare the parts of the state that\n  this value depends on, since your function is only called again\n  for a new state when one of those parts changed.\n  \n  In cases where your value depends only on a single field, you'll\n  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n  */\n  compute(deps, get) {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n    return new FacetProvider(deps, this, 1 /* Provider.Single */, get);\n  }\n  /**\n  Create an extension that computes zero or more values for this\n  facet from a state.\n  */\n  computeN(deps, get) {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n    return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);\n  }\n  from(field, get) {\n    if (!get) get = x => x;\n    return this.compute([field], state => get(state.field(field)));\n  }\n}\nfunction sameArray(a, b) {\n  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n  constructor(dependencies, facet, type, value) {\n    this.dependencies = dependencies;\n    this.facet = facet;\n    this.type = type;\n    this.value = value;\n    this.id = nextID++;\n  }\n  dynamicSlot(addresses) {\n    var _a;\n    let getter = this.value;\n    let compare = this.facet.compareInput;\n    let id = this.id,\n      idx = addresses[id] >> 1,\n      multi = this.type == 2 /* Provider.Multi */;\n    let depDoc = false,\n      depSel = false,\n      depAddrs = [];\n    for (let dep of this.dependencies) {\n      if (dep == \"doc\") depDoc = true;else if (dep == \"selection\") depSel = true;else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n    }\n    return {\n      create(state) {\n        state.values[idx] = getter(state);\n        return 1 /* SlotStatus.Changed */;\n      },\n\n      update(state, tr) {\n        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {\n          let newVal = getter(state);\n          if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n            state.values[idx] = newVal;\n            return 1 /* SlotStatus.Changed */;\n          }\n        }\n\n        return 0;\n      },\n      reconfigure: (state, oldState) => {\n        let newVal,\n          oldAddr = oldState.config.address[id];\n        if (oldAddr != null) {\n          let oldVal = getAddr(oldState, oldAddr);\n          if (this.dependencies.every(dep => {\n            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n            state.values[idx] = oldVal;\n            return 0;\n          }\n        } else {\n          newVal = getter(state);\n        }\n        state.values[idx] = newVal;\n        return 1 /* SlotStatus.Changed */;\n      }\n    };\n  }\n}\n\nfunction compareArray(a, b, compare) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (!compare(a[i], b[i])) return false;\n  return true;\n}\nfunction ensureAll(state, addrs) {\n  let changed = false;\n  for (let addr of addrs) if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */) changed = true;\n  return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n  let providerAddrs = providers.map(p => addresses[p.id]);\n  let providerTypes = providers.map(p => p.type);\n  let dynamic = providerAddrs.filter(p => !(p & 1));\n  let idx = addresses[facet.id] >> 1;\n  function get(state) {\n    let values = [];\n    for (let i = 0; i < providerAddrs.length; i++) {\n      let value = getAddr(state, providerAddrs[i]);\n      if (providerTypes[i] == 2 /* Provider.Multi */) for (let val of value) values.push(val);else values.push(value);\n    }\n    return facet.combine(values);\n  }\n  return {\n    create(state) {\n      for (let addr of providerAddrs) ensureAddr(state, addr);\n      state.values[idx] = get(state);\n      return 1 /* SlotStatus.Changed */;\n    },\n\n    update(state, tr) {\n      if (!ensureAll(state, dynamic)) return 0;\n      let value = get(state);\n      if (facet.compare(value, state.values[idx])) return 0;\n      state.values[idx] = value;\n      return 1 /* SlotStatus.Changed */;\n    },\n\n    reconfigure(state, oldState) {\n      let depChanged = ensureAll(state, providerAddrs);\n      let oldProviders = oldState.config.facets[facet.id],\n        oldValue = oldState.facet(facet);\n      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n        state.values[idx] = oldValue;\n        return 0;\n      }\n      let value = get(state);\n      if (facet.compare(value, oldValue)) {\n        state.values[idx] = oldValue;\n        return 0;\n      }\n      state.values[idx] = value;\n      return 1 /* SlotStatus.Changed */;\n    }\n  };\n}\n\nconst initField = /*@__PURE__*/Facet.define({\n  static: true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/\nclass StateField {\n  constructor(\n  /**\n  @internal\n  */\n  id, createF, updateF, compareF,\n  /**\n  @internal\n  */\n  spec) {\n    this.id = id;\n    this.createF = createF;\n    this.updateF = updateF;\n    this.compareF = compareF;\n    this.spec = spec;\n    /**\n    @internal\n    */\n    this.provides = undefined;\n  }\n  /**\n  Define a state field.\n  */\n  static define(config) {\n    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n    if (config.provide) field.provides = config.provide(field);\n    return field;\n  }\n  create(state) {\n    let init = state.facet(initField).find(i => i.field == this);\n    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n  }\n  /**\n  @internal\n  */\n  slot(addresses) {\n    let idx = addresses[this.id] >> 1;\n    return {\n      create: state => {\n        state.values[idx] = this.create(state);\n        return 1 /* SlotStatus.Changed */;\n      },\n\n      update: (state, tr) => {\n        let oldVal = state.values[idx];\n        let value = this.updateF(oldVal, tr);\n        if (this.compareF(oldVal, value)) return 0;\n        state.values[idx] = value;\n        return 1 /* SlotStatus.Changed */;\n      },\n\n      reconfigure: (state, oldState) => {\n        if (oldState.config.address[this.id] != null) {\n          state.values[idx] = oldState.field(this);\n          return 0;\n        }\n        state.values[idx] = this.create(state);\n        return 1 /* SlotStatus.Changed */;\n      }\n    };\n  }\n  /**\n  Returns an extension that enables this field and overrides the\n  way it is initialized. Can be useful when you need to provide a\n  non-default starting value for the field.\n  */\n  init(create) {\n    return [this, initField.of({\n      field: this,\n      create\n    })];\n  }\n  /**\n  State field instances can be used as\n  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n  given state.\n  */\n  get extension() {\n    return this;\n  }\n}\nconst Prec_ = {\n  lowest: 4,\n  low: 3,\n  default: 2,\n  high: 1,\n  highest: 0\n};\nfunction prec(value) {\n  return ext => new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/\nconst Prec = {\n  /**\n  The highest precedence level, for extensions that should end up\n  near the start of the precedence ordering.\n  */\n  highest: /*@__PURE__*/prec(Prec_.highest),\n  /**\n  A higher-than-default precedence, for extensions that should\n  come before those with default precedence.\n  */\n  high: /*@__PURE__*/prec(Prec_.high),\n  /**\n  The default precedence, which is also used for extensions\n  without an explicit precedence.\n  */\n  default: /*@__PURE__*/prec(Prec_.default),\n  /**\n  A lower-than-default precedence.\n  */\n  low: /*@__PURE__*/prec(Prec_.low),\n  /**\n  The lowest precedence level. Meant for things that should end up\n  near the end of the extension order.\n  */\n  lowest: /*@__PURE__*/prec(Prec_.lowest)\n};\nclass PrecExtension {\n  constructor(inner, prec) {\n    this.inner = inner;\n    this.prec = prec;\n  }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/\nclass Compartment {\n  /**\n  Create an instance of this compartment to add to your [state\n  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n  */\n  of(ext) {\n    return new CompartmentInstance(this, ext);\n  }\n  /**\n  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n  reconfigures this compartment.\n  */\n  reconfigure(content) {\n    return Compartment.reconfigure.of({\n      compartment: this,\n      extension: content\n    });\n  }\n  /**\n  Get the current content of the compartment in the state, or\n  `undefined` if it isn't present.\n  */\n  get(state) {\n    return state.config.compartments.get(this);\n  }\n}\nclass CompartmentInstance {\n  constructor(compartment, inner) {\n    this.compartment = compartment;\n    this.inner = inner;\n  }\n}\nclass Configuration {\n  constructor(base, compartments, dynamicSlots, address, staticValues, facets) {\n    this.base = base;\n    this.compartments = compartments;\n    this.dynamicSlots = dynamicSlots;\n    this.address = address;\n    this.staticValues = staticValues;\n    this.facets = facets;\n    this.statusTemplate = [];\n    while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0 /* SlotStatus.Unresolved */);\n  }\n\n  staticFacet(facet) {\n    let addr = this.address[facet.id];\n    return addr == null ? facet.default : this.staticValues[addr >> 1];\n  }\n  static resolve(base, compartments, oldState) {\n    let fields = [];\n    let facets = Object.create(null);\n    let newCompartments = new Map();\n    for (let ext of flatten(base, compartments, newCompartments)) {\n      if (ext instanceof StateField) fields.push(ext);else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n    }\n    let address = Object.create(null);\n    let staticValues = [];\n    let dynamicSlots = [];\n    for (let field of fields) {\n      address[field.id] = dynamicSlots.length << 1;\n      dynamicSlots.push(a => field.slot(a));\n    }\n    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n    for (let id in facets) {\n      let providers = facets[id],\n        facet = providers[0].facet;\n      let oldProviders = oldFacets && oldFacets[id] || [];\n      if (providers.every(p => p.type == 0 /* Provider.Static */)) {\n        address[facet.id] = staticValues.length << 1 | 1;\n        if (sameArray(oldProviders, providers)) {\n          staticValues.push(oldState.facet(facet));\n        } else {\n          let value = facet.combine(providers.map(p => p.value));\n          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n        }\n      } else {\n        for (let p of providers) {\n          if (p.type == 0 /* Provider.Static */) {\n            address[p.id] = staticValues.length << 1 | 1;\n            staticValues.push(p.value);\n          } else {\n            address[p.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => p.dynamicSlot(a));\n          }\n        }\n        address[facet.id] = dynamicSlots.length << 1;\n        dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n      }\n    }\n    let dynamic = dynamicSlots.map(f => f(address));\n    return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n  }\n}\nfunction flatten(extension, compartments, newCompartments) {\n  let result = [[], [], [], [], []];\n  let seen = new Map();\n  function inner(ext, prec) {\n    let known = seen.get(ext);\n    if (known != null) {\n      if (known <= prec) return;\n      let found = result[known].indexOf(ext);\n      if (found > -1) result[known].splice(found, 1);\n      if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n    }\n    seen.set(ext, prec);\n    if (Array.isArray(ext)) {\n      for (let e of ext) inner(e, prec);\n    } else if (ext instanceof CompartmentInstance) {\n      if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n      let content = compartments.get(ext.compartment) || ext.inner;\n      newCompartments.set(ext.compartment, content);\n      inner(content, prec);\n    } else if (ext instanceof PrecExtension) {\n      inner(ext.inner, ext.prec);\n    } else if (ext instanceof StateField) {\n      result[prec].push(ext);\n      if (ext.provides) inner(ext.provides, prec);\n    } else if (ext instanceof FacetProvider) {\n      result[prec].push(ext);\n      if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);\n    } else {\n      let content = ext.extension;\n      if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n      inner(content, prec);\n    }\n  }\n  inner(extension, Prec_.default);\n  return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n  if (addr & 1) return 2 /* SlotStatus.Computed */;\n  let idx = addr >> 1;\n  let status = state.status[idx];\n  if (status == 4 /* SlotStatus.Computing */) throw new Error(\"Cyclic dependency between fields and/or facets\");\n  if (status & 2 /* SlotStatus.Computed */) return status;\n  state.status[idx] = 4 /* SlotStatus.Computing */;\n  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n  return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = /*@__PURE__*/Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/Facet.define({\n  combine: values => values.some(v => v),\n  static: true\n});\nconst lineSeparator = /*@__PURE__*/Facet.define({\n  combine: values => values.length ? values[0] : undefined,\n  static: true\n});\nconst changeFilter = /*@__PURE__*/Facet.define();\nconst transactionFilter = /*@__PURE__*/Facet.define();\nconst transactionExtender = /*@__PURE__*/Facet.define();\nconst readOnly = /*@__PURE__*/Facet.define({\n  combine: values => values.length ? values[0] : false\n});\n\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/\nclass Annotation {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The annotation type.\n  */\n  type,\n  /**\n  The value of this annotation.\n  */\n  value) {\n    this.type = type;\n    this.value = value;\n  }\n  /**\n  Define a new type of annotation.\n  */\n  static define() {\n    return new AnnotationType();\n  }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/\nclass AnnotationType {\n  /**\n  Create an instance of this annotation.\n  */\n  of(value) {\n    return new Annotation(this, value);\n  }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/\nclass StateEffectType {\n  /**\n  @internal\n  */\n  constructor(\n  // The `any` types in these function types are there to work\n  // around TypeScript issue #37631, where the type guard on\n  // `StateEffect.is` mysteriously stops working when these properly\n  // have type `Value`.\n  /**\n  @internal\n  */\n  map) {\n    this.map = map;\n  }\n  /**\n  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n  type.\n  */\n  of(value) {\n    return new StateEffect(this, value);\n  }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/\nclass StateEffect {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  type,\n  /**\n  The value of this effect.\n  */\n  value) {\n    this.type = type;\n    this.value = value;\n  }\n  /**\n  Map this effect through a position mapping. Will return\n  `undefined` when that ends up deleting the effect.\n  */\n  map(mapping) {\n    let mapped = this.type.map(this.value, mapping);\n    return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n  }\n  /**\n  Tells you whether this effect object is of a given\n  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n  */\n  is(type) {\n    return this.type == type;\n  }\n  /**\n  Define a new effect type. The type parameter indicates the type\n  of values that his effect holds.\n  */\n  static define(spec = {}) {\n    return new StateEffectType(spec.map || (v => v));\n  }\n  /**\n  Map an array of effects through a change set.\n  */\n  static mapEffects(effects, mapping) {\n    if (!effects.length) return effects;\n    let result = [];\n    for (let effect of effects) {\n      let mapped = effect.map(mapping);\n      if (mapped) result.push(mapped);\n    }\n    return result;\n  }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/\nclass Transaction {\n  constructor(\n  /**\n  The state from which the transaction starts.\n  */\n  startState,\n  /**\n  The document changes made by this transaction.\n  */\n  changes,\n  /**\n  The selection set by this transaction, or undefined if it\n  doesn't explicitly set a selection.\n  */\n  selection,\n  /**\n  The effects added to the transaction.\n  */\n  effects,\n  /**\n  @internal\n  */\n  annotations,\n  /**\n  Whether the selection should be scrolled into view after this\n  transaction is dispatched.\n  */\n  scrollIntoView) {\n    this.startState = startState;\n    this.changes = changes;\n    this.selection = selection;\n    this.effects = effects;\n    this.annotations = annotations;\n    this.scrollIntoView = scrollIntoView;\n    /**\n    @internal\n    */\n    this._doc = null;\n    /**\n    @internal\n    */\n    this._state = null;\n    if (selection) checkSelection(selection, changes.newLength);\n    if (!annotations.some(a => a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n  }\n  /**\n  @internal\n  */\n  static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n    return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n  }\n  /**\n  The new document produced by the transaction. Contrary to\n  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n  force the entire new state to be computed right away, so it is\n  recommended that [transaction\n  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n  when they need to look at the new document.\n  */\n  get newDoc() {\n    return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n  }\n  /**\n  The new selection produced by the transaction. If\n  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n  current selection through the changes made by the transaction.\n  */\n  get newSelection() {\n    return this.selection || this.startState.selection.map(this.changes);\n  }\n  /**\n  The new state created by the transaction. Computed on demand\n  (but retained for subsequent access), so it is recommended not to\n  access it in [transaction\n  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n  */\n  get state() {\n    if (!this._state) this.startState.applyTransaction(this);\n    return this._state;\n  }\n  /**\n  Get the value of the given annotation type, if any.\n  */\n  annotation(type) {\n    for (let ann of this.annotations) if (ann.type == type) return ann.value;\n    return undefined;\n  }\n  /**\n  Indicates whether the transaction changed the document.\n  */\n  get docChanged() {\n    return !this.changes.empty;\n  }\n  /**\n  Indicates whether this transaction reconfigures the state\n  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n  with a top-level configuration\n  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n  */\n  get reconfigured() {\n    return this.startState.config != this.state.config;\n  }\n  /**\n  Returns true if the transaction has a [user\n  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n  or more specific than `event`. For example, if the transaction\n  has `\"select.pointer\"` as user event, `\"select\"` and\n  `\"select.pointer\"` will match it.\n  */\n  isUserEvent(event) {\n    let e = this.annotation(Transaction.userEvent);\n    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n  }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/\nTransaction.time = /*@__PURE__*/Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/\nTransaction.remote = /*@__PURE__*/Annotation.define();\nfunction joinRanges(a, b) {\n  let result = [];\n  for (let iA = 0, iB = 0;;) {\n    let from, to;\n    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n      from = a[iA++];\n      to = a[iA++];\n    } else if (iB < b.length) {\n      from = b[iB++];\n      to = b[iB++];\n    } else return result;\n    if (!result.length || result[result.length - 1] < from) result.push(from, to);else if (result[result.length - 1] < to) result[result.length - 1] = to;\n  }\n}\nfunction mergeTransaction(a, b, sequential) {\n  var _a;\n  let mapForA, mapForB, changes;\n  if (sequential) {\n    mapForA = b.changes;\n    mapForB = ChangeSet.empty(b.changes.length);\n    changes = a.changes.compose(b.changes);\n  } else {\n    mapForA = b.changes.map(a.changes);\n    mapForB = a.changes.mapDesc(b.changes, true);\n    changes = a.changes.compose(mapForA);\n  }\n  return {\n    changes,\n    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n    scrollIntoView: a.scrollIntoView || b.scrollIntoView\n  };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n  let sel = spec.selection,\n    annotations = asArray(spec.annotations);\n  if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n  return {\n    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n    effects: asArray(spec.effects),\n    annotations,\n    scrollIntoView: !!spec.scrollIntoView\n  };\n}\nfunction resolveTransaction(state, specs, filter) {\n  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n  if (specs.length && specs[0].filter === false) filter = false;\n  for (let i = 1; i < specs.length; i++) {\n    if (specs[i].filter === false) filter = false;\n    let seq = !!specs[i].sequential;\n    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n  }\n  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n  return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n  let state = tr.startState;\n  // Change filters\n  let result = true;\n  for (let filter of state.facet(changeFilter)) {\n    let value = filter(tr);\n    if (value === false) {\n      result = false;\n      break;\n    }\n    if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n  }\n  if (result !== true) {\n    let changes, back;\n    if (result === false) {\n      back = tr.changes.invertedDesc;\n      changes = ChangeSet.empty(state.doc.length);\n    } else {\n      let filtered = tr.changes.filter(result);\n      changes = filtered.changes;\n      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n    }\n    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n  }\n  // Transaction filters\n  let filters = state.facet(transactionFilter);\n  for (let i = filters.length - 1; i >= 0; i--) {\n    let filtered = filters[i](tr);\n    if (filtered instanceof Transaction) tr = filtered;else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];else tr = resolveTransaction(state, asArray(filtered), false);\n  }\n  return tr;\n}\nfunction extendTransaction(tr) {\n  let state = tr.startState,\n    extenders = state.facet(transactionExtender),\n    spec = tr;\n  for (let i = extenders.length - 1; i >= 0; i--) {\n    let extension = extenders[i](tr);\n    if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n  }\n  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n  return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/\nvar CharCategory = /*@__PURE__*/function (CharCategory) {\n  /**\n  Word characters.\n  */\n  CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n  /**\n  Whitespace.\n  */\n  CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n  /**\n  Anything else.\n  */\n  CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n  return CharCategory;\n}(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n  wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n  if (wordChar) return wordChar.test(str);\n  for (let i = 0; i < str.length; i++) {\n    let ch = str[i];\n    if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n  }\n  return false;\n}\nfunction makeCategorizer(wordChars) {\n  return char => {\n    if (!/\\S/.test(char)) return CharCategory.Space;\n    if (hasWordChar(char)) return CharCategory.Word;\n    for (let i = 0; i < wordChars.length; i++) if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n    return CharCategory.Other;\n  };\n}\n\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/\nclass EditorState {\n  constructor(\n  /**\n  @internal\n  */\n  config,\n  /**\n  The current document.\n  */\n  doc,\n  /**\n  The current selection.\n  */\n  selection,\n  /**\n  @internal\n  */\n  values, computeSlot, tr) {\n    this.config = config;\n    this.doc = doc;\n    this.selection = selection;\n    this.values = values;\n    this.status = config.statusTemplate.slice();\n    this.computeSlot = computeSlot;\n    // Fill in the computed state immediately, so that further queries\n    // for it made during the update return this state\n    if (tr) tr._state = this;\n    for (let i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1);\n    this.computeSlot = null;\n  }\n  field(field, require = true) {\n    let addr = this.config.address[field.id];\n    if (addr == null) {\n      if (require) throw new RangeError(\"Field is not present in this state\");\n      return undefined;\n    }\n    ensureAddr(this, addr);\n    return getAddr(this, addr);\n  }\n  /**\n  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n  can be passed. Unless\n  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n  are assumed to start in the _current_ document (not the document\n  produced by previous specs), and its\n  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n  to the document created by its _own_ changes. The resulting\n  transaction contains the combined effect of all the different\n  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n  specs take precedence over earlier ones.\n  */\n  update(...specs) {\n    return resolveTransaction(this, specs, true);\n  }\n  /**\n  @internal\n  */\n  applyTransaction(tr) {\n    let conf = this.config,\n      {\n        base,\n        compartments\n      } = conf;\n    for (let effect of tr.effects) {\n      if (effect.is(Compartment.reconfigure)) {\n        if (conf) {\n          compartments = new Map();\n          conf.compartments.forEach((val, key) => compartments.set(key, val));\n          conf = null;\n        }\n        compartments.set(effect.value.compartment, effect.value.extension);\n      } else if (effect.is(StateEffect.reconfigure)) {\n        conf = null;\n        base = effect.value;\n      } else if (effect.is(StateEffect.appendConfig)) {\n        conf = null;\n        base = asArray(base).concat(effect.value);\n      }\n    }\n    let startValues;\n    if (!conf) {\n      conf = Configuration.resolve(base, compartments, this);\n      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);\n      startValues = intermediateState.values;\n    } else {\n      startValues = tr.startState.values.slice();\n    }\n    new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);\n  }\n  /**\n  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n  replaces every selection range with the given content.\n  */\n  replaceSelection(text) {\n    if (typeof text == \"string\") text = this.toText(text);\n    return this.changeByRange(range => ({\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: text\n      },\n      range: EditorSelection.cursor(range.from + text.length)\n    }));\n  }\n  /**\n  Create a set of changes and a new selection by running the given\n  function for each range in the active selection. The function\n  can return an optional set of changes (in the coordinate space\n  of the start document), plus an updated range (in the coordinate\n  space of the document produced by the call's own changes). This\n  method will merge all the changes and ranges into a single\n  changeset and selection, and return it as a [transaction\n  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n  */\n  changeByRange(f) {\n    let sel = this.selection;\n    let result1 = f(sel.ranges[0]);\n    let changes = this.changes(result1.changes),\n      ranges = [result1.range];\n    let effects = asArray(result1.effects);\n    for (let i = 1; i < sel.ranges.length; i++) {\n      let result = f(sel.ranges[i]);\n      let newChanges = this.changes(result.changes),\n        newMapped = newChanges.map(changes);\n      for (let j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped);\n      let mapBy = changes.mapDesc(newChanges, true);\n      ranges.push(result.range.map(mapBy));\n      changes = changes.compose(newMapped);\n      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n    }\n    return {\n      changes,\n      selection: EditorSelection.create(ranges, sel.mainIndex),\n      effects\n    };\n  }\n  /**\n  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n  description, taking the state's document length and line\n  separator into account.\n  */\n  changes(spec = []) {\n    if (spec instanceof ChangeSet) return spec;\n    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n  }\n  /**\n  Using the state's [line\n  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n  */\n  toText(string) {\n    return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n  }\n  /**\n  Return the given range of the document as a string.\n  */\n  sliceDoc(from = 0, to = this.doc.length) {\n    return this.doc.sliceString(from, to, this.lineBreak);\n  }\n  /**\n  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n  */\n  facet(facet) {\n    let addr = this.config.address[facet.id];\n    if (addr == null) return facet.default;\n    ensureAddr(this, addr);\n    return getAddr(this, addr);\n  }\n  /**\n  Convert this state to a JSON-serializable object. When custom\n  fields should be serialized, you can pass them in as an object\n  mapping property names (in the resulting object, which should\n  not use `doc` or `selection`) to fields.\n  */\n  toJSON(fields) {\n    let result = {\n      doc: this.sliceDoc(),\n      selection: this.selection.toJSON()\n    };\n    if (fields) for (let prop in fields) {\n      let value = fields[prop];\n      if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n    }\n    return result;\n  }\n  /**\n  Deserialize a state from its JSON representation. When custom\n  fields should be deserialized, pass the same object you passed\n  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n  third argument.\n  */\n  static fromJSON(json, config = {}, fields) {\n    if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n    let fieldInit = [];\n    if (fields) for (let prop in fields) {\n      if (Object.prototype.hasOwnProperty.call(json, prop)) {\n        let field = fields[prop],\n          value = json[prop];\n        fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n      }\n    }\n    return EditorState.create({\n      doc: json.doc,\n      selection: EditorSelection.fromJSON(json.selection),\n      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n    });\n  }\n  /**\n  Create a new state. You'll usually only need this when\n  initializing an editor—updated states are created by applying\n  transactions.\n  */\n  static create(config = {}) {\n    let configuration = Configuration.resolve(config.extensions || [], new Map());\n    let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n    let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n    checkSelection(selection, doc.length);\n    if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n    return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);\n  }\n  /**\n  The size (in columns) of a tab in the document, determined by\n  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n  */\n  get tabSize() {\n    return this.facet(EditorState.tabSize);\n  }\n  /**\n  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n  string for this state.\n  */\n  get lineBreak() {\n    return this.facet(EditorState.lineSeparator) || \"\\n\";\n  }\n  /**\n  Returns true when the editor is\n  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n  */\n  get readOnly() {\n    return this.facet(readOnly);\n  }\n  /**\n  Look up a translation for the given phrase (via the\n  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n  original string if no translation is found.\n  \n  If additional arguments are passed, they will be inserted in\n  place of markers like `$1` (for the first value) and `$2`, etc.\n  A single `$` is equivalent to `$1`, and `$$` will produce a\n  literal dollar sign.\n  */\n  phrase(phrase, ...insert) {\n    for (let map of this.facet(EditorState.phrases)) if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n      phrase = map[phrase];\n      break;\n    }\n    if (insert.length) phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i) => {\n      if (i == \"$\") return \"$\";\n      let n = +(i || 1);\n      return !n || n > insert.length ? m : insert[n - 1];\n    });\n    return phrase;\n  }\n  /**\n  Find the values for a given language data field, provided by the\n  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n  \n  Examples of language data fields are...\n  \n  - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n    comment syntax.\n  - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n    for providing language-specific completion sources.\n  - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n    characters that should be considered part of words in this\n    language.\n  - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n    bracket closing behavior.\n  */\n  languageDataAt(name, pos, side = -1) {\n    let values = [];\n    for (let provider of this.facet(languageData)) {\n      for (let result of provider(this, pos, side)) {\n        if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n      }\n    }\n    return values;\n  }\n  /**\n  Return a function that can categorize strings (expected to\n  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n  into one of:\n  \n   - Word (contains an alphanumeric character or a character\n     explicitly listed in the local language's `\"wordChars\"`\n     language data, which should be a string)\n   - Space (contains only whitespace)\n   - Other (anything else)\n  */\n  charCategorizer(at) {\n    return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n  }\n  /**\n  Find the word at the given position, meaning the range\n  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n  around it. If no word characters are adjacent to the position,\n  this returns null.\n  */\n  wordAt(pos) {\n    let {\n      text,\n      from,\n      length\n    } = this.doc.lineAt(pos);\n    let cat = this.charCategorizer(pos);\n    let start = pos - from,\n      end = pos - from;\n    while (start > 0) {\n      let prev = findClusterBreak(text, start, false);\n      if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n      start = prev;\n    }\n    while (end < length) {\n      let next = findClusterBreak(text, end);\n      if (cat(text.slice(end, next)) != CharCategory.Word) break;\n      end = next;\n    }\n    return start == end ? null : EditorSelection.range(start + from, end + from);\n  }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/\nEditorState.tabSize = /*@__PURE__*/Facet.define({\n  combine: values => values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/\nEditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/\nEditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/\nEditorState.phrases = /*@__PURE__*/Facet.define({\n  compare(a, b) {\n    let kA = Object.keys(a),\n      kB = Object.keys(b);\n    return kA.length == kB.length && kA.every(k => a[k] == b[k]);\n  }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/\nEditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/\nEditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/\nEditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\n\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/\nfunction combineConfig(configs, defaults,\n// Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n  let result = {};\n  for (let config of configs) for (let key of Object.keys(config)) {\n    let value = config[key],\n      current = result[key];\n    if (current === undefined) result[key] = value;else if (current === value || value === undefined) ; // No conflict\n    else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);else throw new Error(\"Config merge conflict for field \" + key);\n  }\n  for (let key in defaults) if (result[key] === undefined) result[key] = defaults[key];\n  return result;\n}\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n  /**\n  Compare this value with another value. Used when comparing\n  rangesets. The default implementation compares by identity.\n  Unless you are only creating a fixed number of unique instances\n  of your value type, it is a good idea to implement this\n  properly.\n  */\n  eq(other) {\n    return this == other;\n  }\n  /**\n  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n  */\n  range(from, to = from) {\n    return Range.create(from, to, this);\n  }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n  constructor(\n  /**\n  The range's start position.\n  */\n  from,\n  /**\n  Its end position.\n  */\n  to,\n  /**\n  The value associated with this range.\n  */\n  value) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n  }\n  /**\n  @internal\n  */\n  static create(from, to, value) {\n    return new Range(from, to, value);\n  }\n}\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n  constructor(from, to, value,\n  // Chunks are marked with the largest point that occurs\n  // in them (or -1 for no points), so that scans that are\n  // only interested in points (such as the\n  // heightmap-related logic) can skip range-only chunks.\n  maxPoint) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n  get length() {\n    return this.to[this.to.length - 1];\n  }\n  // Find the index of the given position and side. Use the ranges'\n  // `from` pos when `end == false`, `to` when `end == true`.\n  findIndex(pos, side, end, startAt = 0) {\n    let arr = end ? this.to : this.from;\n    for (let lo = startAt, hi = arr.length;;) {\n      if (lo == hi) return lo;\n      let mid = lo + hi >> 1;\n      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n      if (mid == lo) return diff >= 0 ? lo : hi;\n      if (diff >= 0) hi = mid;else lo = mid + 1;\n    }\n  }\n  between(offset, from, to, f) {\n    for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n  }\n  map(offset, changes) {\n    let value = [],\n      from = [],\n      to = [],\n      newPos = -1,\n      maxPoint = -1;\n    for (let i = 0; i < this.value.length; i++) {\n      let val = this.value[i],\n        curFrom = this.from[i] + offset,\n        curTo = this.to[i] + offset,\n        newFrom,\n        newTo;\n      if (curFrom == curTo) {\n        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n        if (mapped == null) continue;\n        newFrom = newTo = mapped;\n        if (val.startSide != val.endSide) {\n          newTo = changes.mapPos(curFrom, val.endSide);\n          if (newTo < newFrom) continue;\n        }\n      } else {\n        newFrom = changes.mapPos(curFrom, val.startSide);\n        newTo = changes.mapPos(curTo, val.endSide);\n        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n      }\n      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n      if (newPos < 0) newPos = newFrom;\n      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n      value.push(val);\n      from.push(newFrom - newPos);\n      to.push(newTo - newPos);\n    }\n    return {\n      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n      pos: newPos\n    };\n  }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n  constructor(\n  /**\n  @internal\n  */\n  chunkPos,\n  /**\n  @internal\n  */\n  chunk,\n  /**\n  @internal\n  */\n  nextLayer,\n  /**\n  @internal\n  */\n  maxPoint) {\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  /**\n  @internal\n  */\n  static create(chunkPos, chunk, nextLayer, maxPoint) {\n    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n  }\n  /**\n  @internal\n  */\n  get length() {\n    let last = this.chunk.length - 1;\n    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n  }\n  /**\n  The number of ranges in the set.\n  */\n  get size() {\n    if (this.isEmpty) return 0;\n    let size = this.nextLayer.size;\n    for (let chunk of this.chunk) size += chunk.value.length;\n    return size;\n  }\n  /**\n  @internal\n  */\n  chunkEnd(index) {\n    return this.chunkPos[index] + this.chunk[index].length;\n  }\n  /**\n  Update the range set, optionally adding new ranges or filtering\n  out existing ones.\n  \n  (Note: The type parameter is just there as a kludge to work\n  around TypeScript variance issues that prevented `RangeSet<X>`\n  from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n  `Y`.)\n  */\n  update(updateSpec) {\n    let {\n      add = [],\n      sort = false,\n      filterFrom = 0,\n      filterTo = this.length\n    } = updateSpec;\n    let filter = updateSpec.filter;\n    if (add.length == 0 && !filter) return this;\n    if (sort) add = add.slice().sort(cmpRange);\n    if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n    let cur = new LayerCursor(this, null, -1).goto(0),\n      i = 0,\n      spill = [];\n    let builder = new RangeSetBuilder();\n    while (cur.value || i < add.length) {\n      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n        let range = add[i++];\n        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n        cur.nextChunk();\n      } else {\n        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));\n        }\n        cur.next();\n      }\n    }\n    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n      add: spill,\n      filter,\n      filterFrom,\n      filterTo\n    }));\n  }\n  /**\n  Map this range set through a set of changes, return the new set.\n  */\n  map(changes) {\n    if (changes.empty || this.isEmpty) return this;\n    let chunks = [],\n      chunkPos = [],\n      maxPoint = -1;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n        chunk = this.chunk[i];\n      let touch = changes.touchesRange(start, start + chunk.length);\n      if (touch === false) {\n        maxPoint = Math.max(maxPoint, chunk.maxPoint);\n        chunks.push(chunk);\n        chunkPos.push(changes.mapPos(start));\n      } else if (touch === true) {\n        let {\n          mapped,\n          pos\n        } = chunk.map(start, changes);\n        if (mapped) {\n          maxPoint = Math.max(maxPoint, mapped.maxPoint);\n          chunks.push(mapped);\n          chunkPos.push(pos);\n        }\n      }\n    }\n    let next = this.nextLayer.map(changes);\n    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n  }\n  /**\n  Iterate over the ranges that touch the region `from` to `to`,\n  calling `f` for each. There is no guarantee that the ranges will\n  be reported in any specific order. When the callback returns\n  `false`, iteration stops.\n  */\n  between(from, to, f) {\n    if (this.isEmpty) return;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n        chunk = this.chunk[i];\n      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n    }\n    this.nextLayer.between(from, to, f);\n  }\n  /**\n  Iterate over the ranges in this set, in order, including all\n  ranges that end at or after `from`.\n  */\n  iter(from = 0) {\n    return HeapCursor.from([this]).goto(from);\n  }\n  /**\n  @internal\n  */\n  get isEmpty() {\n    return this.nextLayer == this;\n  }\n  /**\n  Iterate over the ranges in a collection of sets, in order,\n  starting from `from`.\n  */\n  static iter(sets, from = 0) {\n    return HeapCursor.from(sets).goto(from);\n  }\n  /**\n  Iterate over two groups of sets, calling methods on `comparator`\n  to notify it of possible differences.\n  */\n  static compare(oldSets, newSets,\n  /**\n  This indicates how the underlying data changed between these\n  ranges, and is needed to synchronize the iteration. `from` and\n  `to` are coordinates in the _new_ space, after these changes.\n  */\n  textDiff, comparator,\n  /**\n  Can be used to ignore all non-point ranges, and points below\n  the given size. When -1, all ranges are compared.\n  */\n  minPointSize = -1) {\n    let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let sharedChunks = findSharedChunks(a, b, textDiff);\n    let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n    let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n  }\n  /**\n  Compare the contents of two groups of range sets, returning true\n  if they are equivalent in the given range.\n  */\n  static eq(oldSets, newSets, from = 0, to) {\n    if (to == null) to = 1000000000 /* C.Far */ - 1;\n    let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n    let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n    if (a.length != b.length) return false;\n    if (!a.length) return true;\n    let sharedChunks = findSharedChunks(a, b);\n    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),\n      sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n    for (;;) {\n      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n      if (sideA.to > to) return true;\n      sideA.next();\n      sideB.next();\n    }\n  }\n  /**\n  Iterate over a group of range sets at the same time, notifying\n  the iterator about the ranges covering every given piece of\n  content. Returns the open count (see\n  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n  of the iteration.\n  */\n  static spans(sets, from, to, iterator,\n  /**\n  When given and greater than -1, only points of at least this\n  size are taken into account.\n  */\n  minPointSize = -1) {\n    let cursor = new SpanCursor(sets, null, minPointSize).goto(from),\n      pos = from;\n    let openRanges = cursor.openStart;\n    for (;;) {\n      let curTo = Math.min(cursor.to, to);\n      if (cursor.point) {\n        let active = cursor.activeForPoint(cursor.to);\n        let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);\n        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n        openRanges = Math.min(cursor.openEnd(curTo), active.length);\n      } else if (curTo > pos) {\n        iterator.span(pos, curTo, cursor.active, openRanges);\n        openRanges = cursor.openEnd(curTo);\n      }\n      if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n      pos = cursor.to;\n      cursor.next();\n    }\n  }\n  /**\n  Create a range set for the given range or array of ranges. By\n  default, this expects the ranges to be _sorted_ (by start\n  position and, if two start at the same position,\n  `value.startSide`). You can pass `true` as second argument to\n  cause the method to sort them.\n  */\n  static of(ranges, sort = false) {\n    let build = new RangeSetBuilder();\n    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges) build.add(range.from, range.to, range.value);\n    return build.finish();\n  }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n  if (ranges.length > 1) for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n    let cur = ranges[i];\n    if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n    prev = cur;\n  }\n  return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/\nclass RangeSetBuilder {\n  /**\n  Create an empty builder.\n  */\n  constructor() {\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000 /* C.Far */;\n    this.lastTo = -1000000000 /* C.Far */;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n  finishChunk(newArrays) {\n    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n    this.chunkPos.push(this.chunkStart);\n    this.chunkStart = -1;\n    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n    this.maxPoint = -1;\n    if (newArrays) {\n      this.from = [];\n      this.to = [];\n      this.value = [];\n    }\n  }\n  /**\n  Add a range. Ranges should be added in sorted (by `from` and\n  `value.startSide`) order.\n  */\n  add(from, to, value) {\n    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n  }\n  /**\n  @internal\n  */\n  addInner(from, to, value) {\n    let diff = from - this.lastTo || value.startSide - this.last.endSide;\n    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n    if (diff < 0) return false;\n    if (this.from.length == 250 /* C.ChunkSize */) this.finishChunk(true);\n    if (this.chunkStart < 0) this.chunkStart = from;\n    this.from.push(from - this.chunkStart);\n    this.to.push(to - this.chunkStart);\n    this.last = value;\n    this.lastFrom = from;\n    this.lastTo = to;\n    this.value.push(value);\n    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n    return true;\n  }\n  /**\n  @internal\n  */\n  addChunk(from, chunk) {\n    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n    if (this.from.length) this.finishChunk(true);\n    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n    this.chunks.push(chunk);\n    this.chunkPos.push(from);\n    let last = chunk.value.length - 1;\n    this.last = chunk.value[last];\n    this.lastFrom = chunk.from[last] + from;\n    this.lastTo = chunk.to[last] + from;\n    return true;\n  }\n  /**\n  Finish the range set. Returns the new set. The builder can't be\n  used anymore after this has been called.\n  */\n  finish() {\n    return this.finishInner(RangeSet.empty);\n  }\n  /**\n  @internal\n  */\n  finishInner(next) {\n    if (this.from.length) this.finishChunk(false);\n    if (this.chunks.length == 0) return next;\n    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n    this.from = null; // Make sure further `add` calls produce errors\n    return result;\n  }\n}\nfunction findSharedChunks(a, b, textDiff) {\n  let inA = new Map();\n  for (let set of a) for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n  let shared = new Set();\n  for (let set of b) for (let i = 0; i < set.chunk.length; i++) {\n    let known = inA.get(set.chunk[i]);\n    if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n  }\n  return shared;\n}\nclass LayerCursor {\n  constructor(layer, skip, minPoint, rank = 0) {\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  get endSide() {\n    return this.value ? this.value.endSide : 0;\n  }\n  goto(pos, side = -1000000000 /* C.Far */) {\n    this.chunkIndex = this.rangeIndex = 0;\n    this.gotoInner(pos, side, false);\n    return this;\n  }\n  gotoInner(pos, side, forward) {\n    while (this.chunkIndex < this.layer.chunk.length) {\n      let next = this.layer.chunk[this.chunkIndex];\n      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n      this.chunkIndex++;\n      forward = false;\n    }\n    if (this.chunkIndex < this.layer.chunk.length) {\n      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n    }\n    this.next();\n  }\n  forward(pos, side) {\n    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n  }\n  next() {\n    for (;;) {\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = 1000000000 /* C.Far */;\n        this.value = null;\n        break;\n      } else {\n        let chunkPos = this.layer.chunkPos[this.chunkIndex],\n          chunk = this.layer.chunk[this.chunkIndex];\n        let from = chunkPos + chunk.from[this.rangeIndex];\n        this.from = from;\n        this.to = chunkPos + chunk.to[this.rangeIndex];\n        this.value = chunk.value[this.rangeIndex];\n        this.setRangeIndex(this.rangeIndex + 1);\n        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n      }\n    }\n  }\n  setRangeIndex(index) {\n    if (index == this.layer.chunk[this.chunkIndex].value.length) {\n      this.chunkIndex++;\n      if (this.skip) {\n        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;\n      }\n      this.rangeIndex = 0;\n    } else {\n      this.rangeIndex = index;\n    }\n  }\n  nextChunk() {\n    this.chunkIndex++;\n    this.rangeIndex = 0;\n    this.next();\n  }\n  compare(other) {\n    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n  }\n}\nclass HeapCursor {\n  constructor(heap) {\n    this.heap = heap;\n  }\n  static from(sets, skip = null, minPoint = -1) {\n    let heap = [];\n    for (let i = 0; i < sets.length; i++) {\n      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n      }\n    }\n    return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  goto(pos, side = -1000000000 /* C.Far */) {\n    for (let cur of this.heap) cur.goto(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    for (let cur of this.heap) cur.forward(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n  }\n  next() {\n    if (this.heap.length == 0) {\n      this.from = this.to = 1000000000 /* C.Far */;\n      this.value = null;\n      this.rank = -1;\n    } else {\n      let top = this.heap[0];\n      this.from = top.from;\n      this.to = top.to;\n      this.value = top.value;\n      this.rank = top.rank;\n      if (top.value) top.next();\n      heapBubble(this.heap, 0);\n    }\n  }\n}\nfunction heapBubble(heap, index) {\n  for (let cur = heap[index];;) {\n    let childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    let child = heap[childIndex];\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\nclass SpanCursor {\n  constructor(sets, skip, minPoint) {\n    this.minPoint = minPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1;\n    // A currently active point range, if any\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000 /* C.Far */;\n    this.endSide = 0;\n    // The amount of open active ranges at the start of the iterator.\n    // Not including points.\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n  goto(pos, side = -1000000000 /* C.Far */) {\n    this.cursor.goto(pos, side);\n    this.active.length = this.activeTo.length = this.activeRank.length = 0;\n    this.minActive = -1;\n    this.to = pos;\n    this.endSide = side;\n    this.openStart = -1;\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);\n    this.cursor.forward(pos, side);\n  }\n  removeActive(index) {\n    remove(this.active, index);\n    remove(this.activeTo, index);\n    remove(this.activeRank, index);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  addActive(trackOpen) {\n    let i = 0,\n      {\n        value,\n        to,\n        rank\n      } = this.cursor;\n    while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;\n    insert(this.active, i, value);\n    insert(this.activeTo, i, to);\n    insert(this.activeRank, i, rank);\n    if (trackOpen) insert(trackOpen, i, this.cursor.from);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  // After calling this, if `this.point` != null, the next range is a\n  // point. Otherwise, it's a regular range, covered by `this.active`.\n  next() {\n    let from = this.to,\n      wasPoint = this.point;\n    this.point = null;\n    let trackOpen = this.openStart < 0 ? [] : null;\n    for (;;) {\n      let a = this.minActive;\n      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[a] > from) {\n          this.to = this.activeTo[a];\n          this.endSide = this.active[a].endSide;\n          break;\n        }\n        this.removeActive(a);\n        if (trackOpen) remove(trackOpen, a);\n      } else if (!this.cursor.value) {\n        this.to = this.endSide = 1000000000 /* C.Far */;\n        break;\n      } else if (this.cursor.from > from) {\n        this.to = this.cursor.from;\n        this.endSide = this.cursor.startSide;\n        break;\n      } else {\n        let nextVal = this.cursor.value;\n        if (!nextVal.point) {\n          // Opening a range\n          this.addActive(trackOpen);\n          this.cursor.next();\n        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n          // Ignore any non-empty points that end precisely at the end of the prev point\n          this.cursor.next();\n        } else {\n          // New point\n          this.point = nextVal;\n          this.pointFrom = this.cursor.from;\n          this.pointRank = this.cursor.rank;\n          this.to = this.cursor.to;\n          this.endSide = nextVal.endSide;\n          this.cursor.next();\n          this.forward(this.to, this.endSide);\n          break;\n        }\n      }\n    }\n    if (trackOpen) {\n      this.openStart = 0;\n      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--) this.openStart++;\n    }\n  }\n  activeForPoint(to) {\n    if (!this.active.length) return this.active;\n    let active = [];\n    for (let i = this.active.length - 1; i >= 0; i--) {\n      if (this.activeRank[i] < this.pointRank) break;\n      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n    }\n    return active.reverse();\n  }\n  openEnd(to) {\n    let open = 0;\n    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++;\n    return open;\n  }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n  a.goto(startA);\n  b.goto(startB);\n  let endB = startB + length;\n  let pos = startB,\n    dPos = startB - startA;\n  for (;;) {\n    let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    let end = diff < 0 ? a.to + dPos : b.to,\n      clipEnd = Math.min(end, endB);\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n  return true;\n}\nfunction remove(array, index) {\n  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];\n  array.pop();\n}\nfunction insert(array, index, value) {\n  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];\n  array[index] = value;\n}\nfunction findMinIndex(value, array) {\n  let found = -1,\n    foundPos = 1000000000 /* C.Far */;\n  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n    found = i;\n    foundPos = array[i];\n  }\n  return found;\n}\n\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/\nfunction countColumn(string, tabSize, to = string.length) {\n  let n = 0;\n  for (let i = 0; i < to;) {\n    if (string.charCodeAt(i) == 9) {\n      n += tabSize - n % tabSize;\n      i++;\n    } else {\n      n++;\n      i = findClusterBreak(string, i);\n    }\n  }\n  return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/\nfunction findColumn(string, col, tabSize, strict) {\n  for (let i = 0, n = 0;;) {\n    if (n >= col) return i;\n    if (i == string.length) break;\n    n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n    i = findClusterBreak(string, i);\n  }\n  return strict === true ? -1 : string.length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanM/ZTFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgZG9jdW1lbnRzLiBAbm9uYWJzdHJhY3RcbiovXG5jbGFzcyBUZXh0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBsaW5lQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtwb3N9IGluIGRvY3VtZW50IG9mIGxlbmd0aCAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIocG9zLCBmYWxzZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgKi9cbiAgICBsaW5lKG4pIHtcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPiB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKG4sIHRydWUsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIHRleHQgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKDAsIGZyb20sIHBhcnRzLCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0ZXh0LmRlY29tcG9zZSgwLCB0ZXh0Lmxlbmd0aCwgcGFydHMsIDEgLyogT3Blbi5Gcm9tICovIHwgMiAvKiBPcGVuLlRvICovKTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UodG8sIHRoaXMubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIGFub3RoZXIgZG9jdW1lbnQgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHRleHQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoZnJvbSwgdG8sIHBhcnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20ocGFydHMsIHRvIC0gZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIHRleHQgaXMgZXF1YWwgdG8gYW5vdGhlciBpbnN0YW5jZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggIT0gdGhpcy5sZW5ndGggfHwgb3RoZXIubGluZXMgIT0gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAxKSwgZW5kID0gdGhpcy5sZW5ndGggLSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIC0xKTtcbiAgICAgICAgbGV0IGEgPSBuZXcgUmF3VGV4dEN1cnNvcih0aGlzKSwgYiA9IG5ldyBSYXdUZXh0Q3Vyc29yKG90aGVyKTtcbiAgICAgICAgZm9yIChsZXQgc2tpcCA9IHN0YXJ0LCBwb3MgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICBhLm5leHQoc2tpcCk7XG4gICAgICAgICAgICBiLm5leHQoc2tpcCk7XG4gICAgICAgICAgICBza2lwID0gMDtcbiAgICAgICAgICAgIGlmIChhLmxpbmVCcmVhayAhPSBiLmxpbmVCcmVhayB8fCBhLmRvbmUgIT0gYi5kb25lIHx8IGEudmFsdWUgIT0gYi52YWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBwb3MgKz0gYS52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5kb25lIHx8IHBvcyA+PSBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0ZXh0LiBXaGVuIGBkaXJgIGlzIGAtMWAsIGl0ZXJhdGlvbiBoYXBwZW5zXG4gICAgZnJvbSBlbmQgdG8gc3RhcnQuIFRoaXMgd2lsbCByZXR1cm4gbGluZXMgYW5kIHRoZSBicmVha3MgYmV0d2VlblxuICAgIHRoZW0gYXMgc2VwYXJhdGUgc3RyaW5ncy5cbiAgICAqL1xuICAgIGl0ZXIoZGlyID0gMSkgeyByZXR1cm4gbmV3IFJhd1RleHRDdXJzb3IodGhpcywgZGlyKTsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIHJhbmdlIG9mIHRoZSB0ZXh0LiBXaGVuIGBmcm9tYCA+IGB0b2AsIHRoZVxuICAgIGl0ZXJhdG9yIHdpbGwgcnVuIGluIHJldmVyc2UuXG4gICAgKi9cbiAgICBpdGVyUmFuZ2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gbmV3IFBhcnRpYWxUZXh0Q3Vyc29yKHRoaXMsIGZyb20sIHRvKTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGN1cnNvciB0aGF0IGl0ZXJhdGVzIG92ZXIgdGhlIGdpdmVuIHJhbmdlIG9mIGxpbmVzLFxuICAgIF93aXRob3V0XyByZXR1cm5pbmcgdGhlIGxpbmUgYnJlYWtzIGJldHdlZW4sIGFuZCB5aWVsZGluZyBlbXB0eVxuICAgIHN0cmluZ3MgZm9yIGVtcHR5IGxpbmVzLlxuICAgIFxuICAgIFdoZW4gYGZyb21gIGFuZCBgdG9gIGFyZSBnaXZlbiwgdGhleSBzaG91bGQgYmUgMS1iYXNlZCBsaW5lIG51bWJlcnMuXG4gICAgKi9cbiAgICBpdGVyTGluZXMoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGlubmVyO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSB0aGlzLmxpbmVzICsgMTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMubGluZShmcm9tKS5mcm9tO1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXJSYW5nZShzdGFydCwgTWF0aC5tYXgoc3RhcnQsIHRvID09IHRoaXMubGluZXMgKyAxID8gdGhpcy5sZW5ndGggOiB0byA8PSAxID8gMCA6IHRoaXMubGluZSh0byAtIDEpLnRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ3Vyc29yKGlubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuc2xpY2VTdHJpbmcoMCk7IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoZSBkb2N1bWVudCB0byBhbiBhcnJheSBvZiBsaW5lcyAod2hpY2ggY2FuIGJlXG4gICAgZGVzZXJpYWxpemVkIGFnYWluIHZpYSBbYFRleHQub2ZgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHReb2YpKS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuZmxhdHRlbihsaW5lcyk7XG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBkb2N1bWVudCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxpbmVcIik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLyA/IG5ldyBUZXh0TGVhZih0ZXh0KSA6IFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQodGV4dCwgW10pKTtcbiAgICB9XG59XG4vLyBMZWF2ZXMgc3RvcmUgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmdzLiBUaGVyZSBhcmUgYWx3YXlzIGxpbmUgYnJlYWtzXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXG4vLyBjb250YWluZWQgaW4gVGV4dE5vZGUgaW5zdGFuY2VzIGZvciBiaWdnZXIgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dExlYWYgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGluZXMoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBsaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG9mZnNldCwgZW5kLCBsaW5lLCBzdHJpbmcpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBsZXQgdGV4dCA9IGZyb20gPD0gMCAmJiB0byA+PSB0aGlzLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcbiAgICAgICAgaWYgKG9wZW4gJiAxIC8qIE9wZW4uRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIGxldCBsaW5lcyA9IGFwcGVuZFRleHQodGhpcy50ZXh0LCBhcHBlbmRUZXh0KHRleHQudGV4dCwgc2xpY2VUZXh0KHRoaXMudGV4dCwgMCwgZnJvbSkpLCB0byk7XG4gICAgICAgIGxldCBuZXdMZW4gPSB0aGlzLmxlbmd0aCArIHRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGxpbmVzLCBuZXdMZW4pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdChsaW5lcywgW10pLCBuZXdMZW4pO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBpZiAodGV4dC5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgY2hhbmdlIG9ubHkgYWZmZWN0cyBvbmUgY2hpbGQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoaWxkJ3Mgc2l6ZSByZW1haW5zIGluIHRoZSBhY2NlcHRhYmxlIHJhbmdlLCBvbmx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwb3MgJiYgdG8gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2hpbGQucmVwbGFjZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGluZXMgPCAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoY29weSwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShwb3MsIGVuZCwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQuc2xpY2VTdHJpbmcoZnJvbSAtIHBvcywgdG8gLSBwb3MsIGxpbmVTZXApO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgY2hpbGQuZmxhdHRlbih0YXJnZXQpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKG90aGVyLCBkaXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBUZXh0Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBbaUEsIGlCLCBlQSwgZUJdID0gZGlyID4gMCA/IFswLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoXVxuICAgICAgICAgICAgOiBbdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxLCBvdGhlci5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgLTFdO1xuICAgICAgICBmb3IgKDs7IGlBICs9IGRpciwgaUIgKz0gZGlyKSB7XG4gICAgICAgICAgICBpZiAoaUEgPT0gZUEgfHwgaUIgPT0gZUIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaEEgPSB0aGlzLmNoaWxkcmVuW2lBXSwgY2hCID0gb3RoZXIuY2hpbGRyZW5baUJdO1xuICAgICAgICAgICAgaWYgKGNoQSAhPSBjaEIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIGNoQS5zY2FuSWRlbnRpY2FsKGNoQiwgZGlyKTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaEEubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbShjaGlsZHJlbiwgbGVuZ3RoID0gY2hpbGRyZW4ucmVkdWNlKChsLCBjaCkgPT4gbCArIGNoLmxlbmd0aCArIDEsIC0xKSkge1xuICAgICAgICBsZXQgbGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGxpbmVzICs9IGNoLmxpbmVzO1xuICAgICAgICBpZiAobGluZXMgPCAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLmZsYXR0ZW4oZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZWFmKGZsYXQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNodW5rID0gTWF0aC5tYXgoMzIgLyogVHJlZS5CcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyksIG1heENodW5rID0gY2h1bmsgPDwgMSwgbWluQ2h1bmsgPSBjaHVuayA+PiAxO1xuICAgICAgICBsZXQgY2h1bmtlZCA9IFtdLCBjdXJyZW50TGluZXMgPSAwLCBjdXJyZW50TGVuID0gLTEsIGN1cnJlbnRDaHVuayA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGQoY2hpbGQpIHtcbiAgICAgICAgICAgIGxldCBsYXN0O1xuICAgICAgICAgICAgaWYgKGNoaWxkLmxpbmVzID4gbWF4Q2h1bmsgJiYgY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgY2hpbGQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGFkZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLmxpbmVzID4gbWluQ2h1bmsgJiYgKGN1cnJlbnRMaW5lcyA+IG1pbkNodW5rIHx8ICFjdXJyZW50TGluZXMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjaHVua2VkLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJiBjdXJyZW50TGluZXMgJiZcbiAgICAgICAgICAgICAgICAobGFzdCA9IGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgVGV4dExlYWYgJiZcbiAgICAgICAgICAgICAgICBjaGlsZC5saW5lcyArIGxhc3QubGluZXMgPD0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVua1tjdXJyZW50Q2h1bmsubGVuZ3RoIC0gMV0gPSBuZXcgVGV4dExlYWYobGFzdC50ZXh0LmNvbmNhdChjaGlsZC50ZXh0KSwgbGFzdC5sZW5ndGggKyAxICsgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgKyBjaGlsZC5saW5lcyA+IGNodW5rKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNodW5rZWQucHVzaChjdXJyZW50Q2h1bmsubGVuZ3RoID09IDEgPyBjdXJyZW50Q2h1bmtbMF0gOiBUZXh0Tm9kZS5mcm9tKGN1cnJlbnRDaHVuaywgY3VycmVudExlbikpO1xuICAgICAgICAgICAgY3VycmVudExlbiA9IC0xO1xuICAgICAgICAgICAgY3VycmVudExpbmVzID0gY3VycmVudENodW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBhZGQoY2hpbGQpO1xuICAgICAgICBmbHVzaCgpO1xuICAgICAgICByZXR1cm4gY2h1bmtlZC5sZW5ndGggPT0gMSA/IGNodW5rZWRbMF0gOiBuZXcgVGV4dE5vZGUoY2h1bmtlZCwgbGVuZ3RoKTtcbiAgICB9XG59XG5UZXh0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBUZXh0TGVhZihbXCJcIl0sIDApO1xuZnVuY3Rpb24gdGV4dExlbmd0aCh0ZXh0KSB7XG4gICAgbGV0IGxlbmd0aCA9IC0xO1xuICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dClcbiAgICAgICAgbGVuZ3RoICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0ZXh0LCB0YXJnZXQsIGZyb20gPSAwLCB0byA9IDFlOSkge1xuICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwLCBmaXJzdCA9IHRydWU7IGkgPCB0ZXh0Lmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICBsZXQgbGluZSA9IHRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFt0YXJnZXQubGVuZ3RoIC0gMV0gKz0gbGluZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzbGljZVRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gYXBwZW5kVGV4dCh0ZXh0LCBbXCJcIl0sIGZyb20sIHRvKTtcbn1cbmNsYXNzIFJhd1RleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGRpciA9IDEpIHtcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0ZXh0XTtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gW2RpciA+IDAgPyAxIDogKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRleHQudGV4dC5sZW5ndGggOiB0ZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMV07XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5ub2Rlc1tsYXN0XSwgb2Zmc2V0VmFsdWUgPSB0aGlzLm9mZnNldHNbbGFzdF0sIG9mZnNldCA9IG9mZnNldFZhbHVlID4+IDE7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdG9wLnRleHQubGVuZ3RoIDogdG9wLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gKGRpciA+IDAgPyBzaXplIDogMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0IC0gMV0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvZmZzZXRWYWx1ZSAmIDEpID09IChkaXIgPiAwID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AudGV4dFtvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoID4gTWF0aC5tYXgoMCwgc2tpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNraXAgPT0gMCA/IG5leHQgOiBkaXIgPiAwID8gbmV4dC5zbGljZShza2lwKSA6IG5leHQuc2xpY2UoMCwgbmV4dC5sZW5ndGggLSBza2lwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC5jaGlsZHJlbltvZmZzZXQgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID4gbmV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnB1c2goZGlyID4gMCA/IDEgOiAobmV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gbmV4dC50ZXh0Lmxlbmd0aCA6IG5leHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dElubmVyKC1za2lwLCAoLXRoaXMuZGlyKSk7XG4gICAgICAgICAgICBza2lwID0gdGhpcy52YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuZGlyKTtcbiAgICB9XG59XG5jbGFzcyBQYXJ0aWFsVGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbmV3IFJhd1RleHRDdXJzb3IodGV4dCwgc3RhcnQgPiBlbmQgPyAtMSA6IDEpO1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0ID4gZW5kID8gdGV4dC5sZW5ndGggOiAwO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1pbihzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy50byA9IE1hdGgubWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIGlmIChkaXIgPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCArPSBNYXRoLm1heCgwLCBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLnRvIDogdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBsZXQgbGltaXQgPSBkaXIgPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChza2lwID4gbGltaXQpXG4gICAgICAgICAgICBza2lwID0gbGltaXQ7XG4gICAgICAgIGxpbWl0IC09IHNraXA7XG4gICAgICAgIGxldCB7IHZhbHVlIH0gPSB0aGlzLmN1cnNvci5uZXh0KHNraXApO1xuICAgICAgICB0aGlzLnBvcyArPSAodmFsdWUubGVuZ3RoICsgc2tpcCkgKiBkaXI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5sZW5ndGggPD0gbGltaXQgPyB2YWx1ZSA6IGRpciA8IDAgPyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBsaW1pdCkgOiB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgIHRoaXMuZG9uZSA9ICF0aGlzLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBpZiAoc2tpcCA8IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5tYXgoc2tpcCwgdGhpcy5mcm9tIC0gdGhpcy5wb3MpO1xuICAgICAgICBlbHNlIGlmIChza2lwID4gMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1pbihza2lwLCB0aGlzLnRvIC0gdGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5jdXJzb3IuZGlyKTtcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhayAmJiB0aGlzLnZhbHVlICE9IFwiXCI7IH1cbn1cbmNsYXNzIExpbmVDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlubmVyKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGxldCB7IGRvbmUsIGxpbmVCcmVhaywgdmFsdWUgfSA9IHRoaXMuaW5uZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgVGV4dC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaXRlcigpOyB9O1xuICAgIFJhd1RleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBQYXJ0aWFsVGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIExpbmVDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuLyoqXG5UaGlzIHR5cGUgZGVzY3JpYmVzIGEgbGluZSBpbiB0aGUgZG9jdW1lbnQuIEl0IGlzIGNyZWF0ZWRcbm9uLWRlbWFuZCB3aGVuIGxpbmVzIGFyZSBbcXVlcmllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0LmxpbmVBdCkuXG4qL1xuY2xhc3MgTGluZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgKF9iZWZvcmVfIHRoZSBsaW5lIGJyZWFrLFxuICAgIG9yIGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgZm9yIHRoZSBsYXN0IGxpbmUpLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoaXMgbGluZSdzIGxpbmUgbnVtYmVyICgxLWJhc2VkKS5cbiAgICAqL1xuICAgIG51bWJlciwgXG4gICAgLyoqXG4gICAgVGhlIGxpbmUncyBjb250ZW50LlxuICAgICovXG4gICAgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIChub3QgaW5jbHVkaW5nIGFueSBsaW5lIGJyZWFrIGFmdGVyIGl0KS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvIC0gdGhpcy5mcm9tOyB9XG59XG5cbi8vIENvbXByZXNzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdyYXBoZW1lX0NsdXN0ZXJfQnJlYWs9RXh0ZW5kXG4vLyBpbmZvcm1hdGlvbiBmcm9tXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxuLy8gRWFjaCBwYWlyIG9mIGVsZW1lbnRzIHJlcHJlc2VudHMgYSByYW5nZSwgYXMgYW4gb2ZmZXQgZnJvbSB0aGVcbi8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cbmxldCBleHRlbmQgPSAvKkBfX1BVUkVfXyovXCJsYywzNCw3biw3LDdiLDE5LCwsLDIsLDIsLCwyMCxiLDFjLGwsZywsMnQsNywyLDYsMiwyLCw0LHosLHUsciwyaixiLDFtLDksOSwsbyw0LCw5LCwzLCw1LDE3LDMsM2IsZiwsdywxaiwsLCw0LDgsNCwsMyw3LGEsMix0LCwxbSwsLCwyLDQsOCwsOSwsYSwyLHEsLDIsMiwxbCwsNCwyLDQsMiwyLDMsMywsdSwyLDMsLGIsMiwxbCwsNCw1LCwyLDQsLGssMixtLDYsLCwxbSwsLDIsLDQsOCwsNywzLGEsMix1LCwxbiwsLCxjLCw5LCwxNCwsMywsMWwsMyw1LDMsLDQsNywyLGIsMix0LCwxbSwsMiwsMiwsMywsNSwyLDcsMixiLDIscywyLDFsLDIsLCwyLDQsOCwsOSwsYSwyLHQsLDIwLCw0LCwyLDMsLCw4LCwyOSwsMiw3LGMsOCwycSwsMiw5LGIsNiwyMiwyLHIsLCwsLCwxaixlLCw1LCwyLDUsYiwsMTAsOSwsMnUsNCwsNiwsMiwyLDIscCwyLDQsMyxnLDQsZCwsMiwyLDYsLGYsLGpqLDMscWEsMyx0LDMsdCwyLHUsMiwxcywyLCw3LDgsLDIsYiw5LCwxOSwzLDNiLDIseSwsM2EsMyw0LDIsOSwsNiwzLDYzLDIsMiwsMW0sLCw3LCwsLCwyLDgsNixhLDIsLDFjLGgsMXIsNCwxYyw3LCwsNSwsMTQsOSxjLDIsdyw0LDIsMiwsMywxaywsLDIsMywsLDMsMW0sOCwyLDIsNDgsMywsZCwsNyw0LCw2LCwzLDIsNWksMW0sLDUsZWssLDVmLHgsMmRhLDMsM3gsLDJvLHcsZmUsNiwyeCwyLG45dyw0LCxhLHcsMiwyOCwyLDdrLCwzLCw0LCxwLDIsNSwsNDcsMixxLGksZCwsMTIsOCxwLGIsMWEsMywxYywsMiw0LDIsMiwxMywsMXYsNiwyLDIsMiwyLGMsLDgsLDFiLCwxZiwsLDMsMiwyLDUsMiwsLDE2LDIsOCwsNm0sLDIsLDQsLGZuNCwsa2gsZyxnLGcsYTYsMixndCwsNmEsLDQ1LDUsMWFlLDMsLDIsNSw0LDE0LDMsNCwsNGwsMixmeCw0LGFyLDIsNDksYiw0dywsMWksZiwxaywzLDFkLDQsMiwyLDF4LDMsMTAsNSwsOCwxcSwsYywyLDFnLDksYSw0LDIsLDJuLDMsMiwsLDIsNiwsNGcsLDMsOCxsLDIsMWwsMiwsLCwsbSwsZSw3LDMsNSw1Ziw4LDIsMywsLG4sLDI5LCwyLDYsLCwyLCwsMiwsMiw2aiwsMiw0LDYsMiwsMixyLDIsMmQsOCwyLCwsMiwyeSwsLCwyLDYsLCwydCwzLDIsNCwsNSw3Nyw5LCwyLDZ0LCxhLDIsLCw0LCw0MCw0LDIsMiw0LCx3LGEsMTQsNiwyLDQsOCwsOSw2LDIsMywxYSxkLCwyLGJhLDcsLDYsLCwyYSxtLDIsNywsMiwsMiwzZSw2LDMsLCwyLCw3LCwsMjAsMiwzLCwsLDluLDIsZjBiLDUsMW4sNyx0NCwsMXIsNCwyOSwsZjVrLDIsNDNxLCwsMyw0LDUsOCw4LDIsNyx1LDQsNDQsMywxaXosMWosNCwxZSw4LCxlLCxtLDUsLGYsMTFzLDcsLGgsMiw3LCwyLCw1LDc5LDcsYzUsNCwxNXMsNywzMSw3LDI0MCw1LGd4N2ssMm8sM2ssNm9cIi5zcGxpdChcIixcIikubWFwKHMgPT4gcyA/IHBhcnNlSW50KHMsIDM2KSA6IDEpO1xuLy8gQ29udmVydCBvZmZzZXRzIGludG8gYWJzb2x1dGUgdmFsdWVzXG5mb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkrKylcbiAgICBleHRlbmRbaV0gKz0gZXh0ZW5kW2kgLSAxXTtcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjb2RlKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGlmIChleHRlbmRbaV0gPiBjb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFtpIC0gMV0gPD0gY29kZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweDFGMUU2ICYmIGNvZGUgPD0gMHgxRjFGRjtcbn1cbmNvbnN0IFpXSiA9IDB4MjAwZDtcbi8qKlxuUmV0dXJucyBhIG5leHQgZ3JhcGhlbWUgY2x1c3RlciBicmVhayBfYWZ0ZXJfIChub3QgZXF1YWwgdG8pXG5gcG9zYCwgaWYgYGZvcndhcmRgIGlzIHRydWUsIG9yIGJlZm9yZSBvdGhlcndpc2UuIFJldHVybnMgYHBvc2Bcbml0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXG5Nb3ZlcyBhY3Jvc3Mgc3Vycm9nYXRlIHBhaXJzLCBleHRlbmRpbmcgY2hhcmFjdGVycyAod2hlblxuYGluY2x1ZGVFeHRlbmRpbmdgIGlzIHRydWUpLCBjaGFyYWN0ZXJzIGpvaW5lZCB3aXRoIHplcm8td2lkdGhcbmpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxuKi9cbmZ1bmN0aW9uIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGZvcndhcmQgPSB0cnVlLCBpbmNsdWRlRXh0ZW5kaW5nID0gdHJ1ZSkge1xuICAgIHJldHVybiAoZm9yd2FyZCA/IG5leHRDbHVzdGVyQnJlYWsgOiBwcmV2Q2x1c3RlckJyZWFrKShzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZyk7XG59XG5mdW5jdGlvbiBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgaWYgKHBvcyA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIC8vIElmIHBvcyBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgc3Vycm9nYXRlIHBhaXIsIG1vdmUgdG8gaXRzIHN0YXJ0XG4gICAgaWYgKHBvcyAmJiBzdXJyb2dhdGVMb3coc3RyLmNoYXJDb2RlQXQocG9zKSkgJiYgc3Vycm9nYXRlSGlnaChzdHIuY2hhckNvZGVBdChwb3MgLSAxKSkpXG4gICAgICAgIHBvcy0tO1xuICAgIGxldCBwcmV2ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKHByZXYpO1xuICAgIHdoaWxlIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocHJldiA9PSBaV0ogfHwgbmV4dCA9PSBaV0ogfHwgaW5jbHVkZUV4dGVuZGluZyAmJiBpc0V4dGVuZGluZ0NoYXIobmV4dCkpIHtcbiAgICAgICAgICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgcHJldiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdpb25hbEluZGljYXRvcihuZXh0KSkge1xuICAgICAgICAgICAgbGV0IGNvdW50QmVmb3JlID0gMCwgaSA9IHBvcyAtIDI7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZVBvaW50QXQoc3RyLCBpKSkpIHtcbiAgICAgICAgICAgICAgICBjb3VudEJlZm9yZSsrO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudEJlZm9yZSAlIDIgPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBwcmV2Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgICAgbGV0IGZvdW5kID0gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcyAtIDIsIGluY2x1ZGVFeHRlbmRpbmcpO1xuICAgICAgICBpZiAoZm91bmQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIHBvcy0tO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDA7IH1cbi8qKlxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXG5bYGNvZGVQb2ludEF0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0KVxuc3RyaW5nIG1ldGhvZCkuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgICBsZXQgY29kZTAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgbGV0IGNvZGUxID0gc3RyLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgcmV0dXJuICgoY29kZTAgLSAweGQ4MDApIDw8IDEwKSArIChjb2RlMSAtIDB4ZGMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG5HaXZlbiBhIFVuaWNvZGUgY29kZXBvaW50LCByZXR1cm4gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHRoYXRcbnJlc3ByZXNlbnRzIGl0IChsaWtlXG5bYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbiovXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMTAyMykgKyAweGRjMDApO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHBvc2l0aW9ucyBhIGNoYXJhY3RlciB0YWtlcyB1cCBhIEphdmFTY3JpcHQgc3RyaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludFNpemUoY29kZSkgeyByZXR1cm4gY29kZSA8IDB4MTAwMDAgPyAxIDogMjsgfVxuXG5jb25zdCBEZWZhdWx0U3BsaXQgPSAvXFxyXFxuP3xcXG4vO1xuLyoqXG5EaXN0aW5ndWlzaGVzIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkLlxuKi9cbnZhciBNYXBNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwTW9kZSkge1xuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRvIGEgdmFsaWQgbmV3IHBvc2l0aW9uLCBldmVuIHdoZW4gaXRzIGNvbnRleHRcbiAgICB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiBkZWxldGlvbiBoYXBwZW5zIGFjcm9zcyB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2JlZm9yZV8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0JlZm9yZVwiXSA9IDJdID0gXCJUcmFja0JlZm9yZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQWZ0ZXJcIl0gPSAzXSA9IFwiVHJhY2tBZnRlclwiO1xucmV0dXJuIE1hcE1vZGV9KShNYXBNb2RlIHx8IChNYXBNb2RlID0ge30pKTtcbi8qKlxuQSBjaGFuZ2UgZGVzY3JpcHRpb24gaXMgYSB2YXJpYW50IG9mIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldClcbnRoYXQgZG9lc24ndCBzdG9yZSB0aGUgaW5zZXJ0ZWQgdGV4dC4gQXMgc3VjaCwgaXQgY2FuJ3QgYmVcbmFwcGxpZWQsIGJ1dCBpcyBjaGVhcGVyIHRvIHN0b3JlIGFuZCBtYW5pcHVsYXRlLlxuKi9cbmNsYXNzIENoYW5nZURlc2Mge1xuICAgIC8vIFNlY3Rpb25zIGFyZSBlbmNvZGVkIGFzIHBhaXJzIG9mIGludGVnZXJzLiBUaGUgZmlyc3QgaXMgdGhlXG4gICAgLy8gbGVuZ3RoIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LCBhbmQgdGhlIHNlY29uZCBpcyAtMSBmb3JcbiAgICAvLyB1bmFmZmVjdGVkIHNlY3Rpb25zLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgcmVwbGFjZW1lbnQgY29udGVudFxuICAgIC8vIG90aGVyd2lzZS4gU28gYW4gaW5zZXJ0aW9uIHdvdWxkIGJlICgwLCBuPjApLCBhIGRlbGV0aW9uIChuPjAsXG4gICAgLy8gMCksIGFuZCBhIHJlcGxhY2VtZW50IHR3byBwb3NpdGl2ZSBudW1iZXJzLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnNlY3Rpb25zW2ldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlucyA8IDAgPyB0aGlzLnNlY3Rpb25zW2ldIDogaW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZhbHNlIHdoZW4gdGhlcmUgYXJlIGFjdHVhbCBjaGFuZ2VzIGluIHRoaXMgc2V0LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB1bmNoYW5nZWQgcGFydHMgbGVmdCBieSB0aGVzZSBjaGFuZ2VzLiBgcG9zQWBcbiAgICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxuICAgIHRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBgZnJvbUFgL2B0b0FgIHByb3ZpZGVzIHRoZSBleHRlbnQgb2YgdGhlIGNoYW5nZSBpbiB0aGUgc3RhcnRpbmdcbiAgICBkb2N1bWVudCwgYGZyb21CYC9gdG9CYCB0aGUgZXh0ZW50IG9mIHRoZSByZXBsYWNlbWVudCBpbiB0aGVcbiAgICBjaGFuZ2VkIGRvY3VtZW50LlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgKHdoaWNoIGFyZSBrZXB0XG4gICAgc2VwYXJhdGUgZm9yIFtwb3NpdGlvbiBtYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MubWFwUG9zKSkgYXJlXG4gICAgcmVwb3J0ZWQgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VkUmFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGludmVydGVkIGZvcm0gb2YgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIGdldCBpbnZlcnRlZERlc2MoKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChpbnMsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFwcGx5aW5nIGFub3RoZXIgc2V0IG9mIGNoYW5nZXNcbiAgICBhZnRlciB0aGlzIG9uZS4gVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhpcyBzZXQgc2hvdWxkXG4gICAgbWF0Y2ggdGhlIGxlbmd0aCBiZWZvcmUgYG90aGVyYC5cbiAgICAqL1xuICAgIGNvbXBvc2VEZXNjKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlcik7IH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBkZXNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHNhbWUgZG9jdW1lbnRcbiAgICBhcyBgb3RoZXJgLCBvdmVyIGFub3RoZXIgc2V0IG9mIGNoYW5nZXMsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgYXBwbGllZCBhZnRlciBpdC4gV2hlbiBgYmVmb3JlYCBpcyB0cnVlLCBtYXAgYXMgaWYgdGhlIGNoYW5nZXNcbiAgICBpbiBgb3RoZXJgIGhhcHBlbmVkIGJlZm9yZSB0aGUgb25lcyBpbiBgdGhpc2AuXG4gICAgKi9cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUpOyB9XG4gICAgbWFwUG9zKHBvcywgYXNzb2MgPSAtMSwgbW9kZSA9IE1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBNYXBNb2RlLlNpbXBsZSAmJiBlbmRBID49IHBvcyAmJlxuICAgICAgICAgICAgICAgICAgICAobW9kZSA9PSBNYXBNb2RlLlRyYWNrRGVsICYmIHBvc0EgPCBwb3MgJiYgZW5kQSA+IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0FmdGVyICYmIGVuZEEgPiBwb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcyB8fCBlbmRBID09IHBvcyAmJiBhc3NvYyA8IDAgJiYgIWxlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA9PSBwb3NBIHx8IGFzc29jIDwgMCA/IHBvc0IgOiBwb3NCICsgaW5zO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+IHBvc0EpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IGlzIG91dCBvZiByYW5nZSBmb3IgY2hhbmdlc2V0IG9mIGxlbmd0aCAke3Bvc0F9YCk7XG4gICAgICAgIHJldHVybiBwb3NCO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXG4gICAgY2hhbmdlcyBlbnRpcmVseSBjb3ZlcnMgdGhlIHJhbmdlLCB0aGUgc3RyaW5nIGBcImNvdmVyXCJgIGlzXG4gICAgcmV0dXJuZWQuXG4gICAgKi9cbiAgICB0b3VjaGVzUmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGggJiYgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmQgPSBwb3MgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zID49IDAgJiYgcG9zIDw9IHRvICYmIGVuZCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPCBmcm9tICYmIGVuZCA+IHRvID8gXCJjb3ZlclwiIDogdHJ1ZTtcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IChyZXN1bHQgPyBcIiBcIiA6IFwiXCIpICsgbGVuICsgKGlucyA+PSAwID8gXCI6XCIgKyBpbnMgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2UgZGVzYyB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2UgZGVzYyBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZFxuICAgIGJ5IFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikgfHwganNvbi5sZW5ndGggJSAyIHx8IGpzb24uc29tZShhID0+IHR5cGVvZiBhICE9IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlRGVzY1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc2VjdGlvbnMpIHsgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTsgfVxufVxuLyoqXG5BIGNoYW5nZSBzZXQgcmVwcmVzZW50cyBhIGdyb3VwIG9mIG1vZGlmaWNhdGlvbnMgdG8gYSBkb2N1bWVudC4gSXRcbnN0b3JlcyB0aGUgZG9jdW1lbnQgbGVuZ3RoLCBhbmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBkb2N1bWVudHNcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cbiovXG5jbGFzcyBDaGFuZ2VTZXQgZXh0ZW5kcyBDaGFuZ2VEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRlZCkge1xuICAgICAgICBzdXBlcihzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSBpbnNlcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPSBkb2MubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBjaGFuZ2Ugc2V0IHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCAoZnJvbUEsIHRvQSwgZnJvbUIsIF90b0IsIHRleHQpID0+IGRvYyA9IGRvYy5yZXBsYWNlKGZyb21CLCBmcm9tQiArICh0b0EgLSBmcm9tQSksIHRleHQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBfYmVmb3JlXyB0aGUgY2hhbmdlcywgcmV0dXJuIGFcbiAgICBjaGFuZ2Ugc2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBvZiB0aGlzIHNldCwgd2hpY2ggY291bGRcbiAgICBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgdGhlIGNoYW5nZXMgYmFjayB0b1xuICAgIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIGJlZm9yZSB0aGUgY2hhbmdlcy5cbiAgICAqL1xuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5zbGljZSgpLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gc2VjdGlvbnNbaV0sIGlucyA9IHNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gaW5zO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2kgKyAxXSA9IGxlbjtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBpID4+IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2gobGVuID8gZG9jLnNsaWNlKHBvcywgcG9zICsgbGVuKSA6IFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXG4gICAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICAgIGBkb2NBYCDihpIgYGRvY0JgIGFuZCBgb3RoZXJgIHJlcHJlc2VudHMgYGRvY0JgIOKGkiBgZG9jQ2AsIHRoZVxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIOKGkiBgZG9jQ2AuXG4gICAgKi9cbiAgICBjb21wb3NlKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlciwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiBhbm90aGVyIGNoYW5nZSBzZXQgc3RhcnRpbmcgaW4gdGhlIHNhbWUgZG9jdW1lbnQsIG1hcHMgdGhpc1xuICAgIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxuICAgIGBiZWZvcmVgIGlzIGB0cnVlYCwgb3JkZXIgY2hhbmdlcyBhcyBpZiBgdGhpc2AgY29tZXMgYmVmb3JlXG4gICAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gICAgXG4gICAgR2l2ZW4gdHdvIGNoYW5nZXMgYEFgIGFuZCBgQmAsIGBBLmNvbXBvc2UoQi5tYXAoQSkpYCBhbmRcbiAgICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxuICAgIHRyYW5zZm9ybWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRpb25hbF90cmFuc2Zvcm1hdGlvbiksXG4gICAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICAgKi9cbiAgICBtYXAob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXG4gICAgZWFjaCwgd2l0aCB0aGUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IChgZnJvbUFgLWB0b0FgKVxuICAgIGFuZCB0aGUgcmFuZ2UgdGhhdCByZXBsYWNlcyBpdCBpbiB0aGUgbmV3IGRvY3VtZW50XG4gICAgKGBmcm9tQmAtYHRvQmApLlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgYXJlIHJlcG9ydGVkXG4gICAgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcbiAgICBzZXQuXG4gICAgKi9cbiAgICBnZXQgZGVzYygpIHsgcmV0dXJuIENoYW5nZURlc2MuY3JlYXRlKHRoaXMuc2VjdGlvbnMpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXIocmFuZ2VzKSB7XG4gICAgICAgIGxldCByZXN1bHRTZWN0aW9ucyA9IFtdLCByZXN1bHRJbnNlcnRlZCA9IFtdLCBmaWx0ZXJlZFNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBpdGVyID0gbmV3IFNlY3Rpb25JdGVyKHRoaXMpO1xuICAgICAgICBkb25lOiBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gcmFuZ2VzLmxlbmd0aCA/IDFlOSA6IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5leHQgfHwgcG9zID09IG5leHQgJiYgaXRlci5sZW4gPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBuZXh0IC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCBpbnMgPSBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMDtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIGlucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucyA+IDApXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChyZXN1bHRJbnNlcnRlZCwgcmVzdWx0U2VjdGlvbnMsIGl0ZXIudGV4dCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgZW5kIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDApO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogbmV3IENoYW5nZVNldChyZXN1bHRTZWN0aW9ucywgcmVzdWx0SW5zZXJ0ZWQpLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IENoYW5nZURlc2MuY3JlYXRlKGZpbHRlcmVkU2VjdGlvbnMpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBzZXQgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2ldLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobGVuKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucyA9PSAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0uY29uY2F0KHRoaXMuaW5zZXJ0ZWRbaSA+PiAxXS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIHNldCBmb3IgdGhlIGdpdmVuIGNoYW5nZXMsIGZvciBhIGRvY3VtZW50IG9mIHRoZVxuICAgIGdpdmVuIGxlbmd0aCwgdXNpbmcgYGxpbmVTZXBgIGFzIGxpbmUgc2VwYXJhdG9yLlxuICAgICovXG4gICAgc3RhdGljIG9mKGNoYW5nZXMsIGxlbmd0aCwgbGluZVNlcCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXSwgcG9zID0gMDtcbiAgICAgICAgbGV0IHRvdGFsID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gZmx1c2goZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiAhc2VjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuZ3RoIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc2V0Lm1hcCh0b3RhbCkpIDogc2V0O1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGluc2VydGVkID0gW107XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3BlYykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2Ygc3BlYylcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhzdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbmd0aCAhPSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3RoIChnb3QgJHtzcGVjLmxlbmd0aH0sIGV4cGVjdGVkICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNwZWMubWFwKHRvdGFsKSkgOiBzcGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gPSBmcm9tLCBpbnNlcnQgfSA9IHNwZWM7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiB0byB8fCBmcm9tIDwgMCB8fCB0byA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY2hhbmdlIHJhbmdlICR7ZnJvbX0gdG8gJHt0b30gKGluIGRvYyBvZiBsZW5ndGggJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGxldCBpbnNUZXh0ID0gIWluc2VydCA/IFRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyBUZXh0Lm9mKGluc2VydC5zcGxpdChsaW5lU2VwIHx8IERlZmF1bHRTcGxpdCkpIDogaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGxldCBpbnNMZW4gPSBpbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBpbnNMZW4gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBmcm9tIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgdG8gLSBmcm9tLCBpbnNMZW4pO1xuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnRlZCwgc2VjdGlvbnMsIGluc1RleHQpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MoY2hhbmdlcyk7XG4gICAgICAgIGZsdXNoKCF0b3RhbCk7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGNoYW5nZXNldCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICovXG4gICAgc3RhdGljIGVtcHR5KGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChsZW5ndGggPyBbbGVuZ3RoLCAtMV0gOiBbXSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2VzZXQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWQgYnlcbiAgICBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0LnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0ganNvbltpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXJ0KSB8fCB0eXBlb2YgcGFydFswXSAhPSBcIm51bWJlclwiIHx8IHBhcnQuc29tZSgoZSwgaSkgPT4gaSAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGkpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRbaV0gPSBUZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgaW5zZXJ0ZWRbaV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnMsIGZvcmNlSm9pbiA9IGZhbHNlKSB7XG4gICAgaWYgKGxlbiA9PSAwICYmIGlucyA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxhc3QgPSBzZWN0aW9ucy5sZW5ndGggLSAyO1xuICAgIGlmIChsYXN0ID49IDAgJiYgaW5zIDw9IDAgJiYgaW5zID09IHNlY3Rpb25zW2xhc3QgKyAxXSlcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgIGVsc2UgaWYgKGxlbiA9PSAwICYmIHNlY3Rpb25zW2xhc3RdID09IDApXG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgZWxzZSBpZiAoZm9yY2VKb2luKSB7XG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbn1cbmZ1bmN0aW9uIGFkZEluc2VydCh2YWx1ZXMsIHNlY3Rpb25zLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBpbmRleCA9IChzZWN0aW9ucy5sZW5ndGggLSAyKSA+PiAxO1xuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uYXBwZW5kKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJDaGFuZ2VzKGRlc2MsIGYsIGluZGl2aWR1YWwpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xuICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7IGkgPCBkZXNjLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXSwgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbmRBID0gcG9zQSwgZW5kQiA9IHBvc0IsIHRleHQgPSBUZXh0LmVtcHR5O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGVuZEEgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGVuZEIgKz0gaW5zO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmFwcGVuZChpbnNlcnRlZFsoaSAtIDIpID4+IDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXZpZHVhbCB8fCBpID09IGRlc2Muc2VjdGlvbnMubGVuZ3RoIHx8IGRlc2Muc2VjdGlvbnNbaSArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgICAgIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYocG9zQSwgZW5kQSwgcG9zQiwgZW5kQiwgdGV4dCk7XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgICAgIHBvc0IgPSBlbmRCO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwU2V0KHNldEEsIHNldEIsIGJlZm9yZSwgbWtTZXQgPSBmYWxzZSkge1xuICAgIC8vIFByb2R1Y2UgYSBjb3B5IG9mIHNldEEgdGhhdCBhcHBsaWVzIHRvIHRoZSBkb2N1bWVudCBhZnRlciBzZXRCXG4gICAgLy8gaGFzIGJlZW4gYXBwbGllZCAoYXNzdW1pbmcgYm90aCBzdGFydCBhdCB0aGUgc2FtZSBkb2N1bWVudCkuXG4gICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBib3RoIHNldHMgaW4gcGFyYWxsZWwuIGluc2VydGVkIHRyYWNrcywgZm9yIGNoYW5nZXNcbiAgICAvLyBpbiBBIHRoYXQgaGF2ZSB0byBiZSBwcm9jZXNzZWQgcGllY2UtYnktcGllY2UsIHdoZXRoZXIgdGhlaXJcbiAgICAvLyBjb250ZW50IGhhcyBiZWVuIGluc2VydGVkIGFscmVhZHksIGFuZCByZWZlcnMgdG8gdGhlIHNlY3Rpb25cbiAgICAvLyBpbmRleC5cbiAgICBmb3IgKGxldCBpbnNlcnRlZCA9IC0xOzspIHtcbiAgICAgICAgaWYgKGEuaW5zID09IC0xICYmIGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGFjcm9zcyByYW5nZXMgc2tpcHBlZCBieSBib3RoIHNldHMuXG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4sIGIubGVuKTtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmlucyA+PSAwICYmIChhLmlucyA8IDAgfHwgaW5zZXJ0ZWQgPT0gYS5pIHx8IGEub2ZmID09IDAgJiYgKGIubGVuIDwgYS5sZW4gfHwgYi5sZW4gPT0gYS5sZW4gJiYgIWJlZm9yZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY2hhbmdlIGluIEIgdGhhdCBjb21lcyBiZWZvcmUgdGhlIG5leHQgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyBBIChvcmRlcmVkIGJ5IHN0YXJ0IHBvcywgdGhlbiBsZW4sIHRoZW4gYmVmb3JlIGZsYWcpLCBza2lwXG4gICAgICAgICAgICAvLyB0aGF0IChhbmQgcHJvY2VzcyBhbnkgY2hhbmdlcyBpbiBBIGl0IGNvdmVycykuXG4gICAgICAgICAgICBsZXQgbGVuID0gYi5sZW47XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBiLmlucywgLTEpO1xuICAgICAgICAgICAgd2hpbGUgKGxlbikge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGEubGVuLCBsZW4pO1xuICAgICAgICAgICAgICAgIGlmIChhLmlucyA+PSAwICYmIGluc2VydGVkIDwgYS5pICYmIGEubGVuIDw9IHBpZWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGEuaW5zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYS5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA+PSAwKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBwYXJ0IG9mIGEgY2hhbmdlIGluIEEgdXAgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBub24tZGVsZXRpb24gY2hhbmdlIGluIEIgKGlmIG92ZXJsYXBwaW5nKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSAwLCBsZWZ0ID0gYS5sZW47XG4gICAgICAgICAgICB3aGlsZSAobGVmdCkge1xuICAgICAgICAgICAgICAgIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihsZWZ0LCBiLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBwaWVjZTtcbiAgICAgICAgICAgICAgICAgICAgYi5mb3J3YXJkKHBpZWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gMCAmJiBiLmxlbiA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSBiLmxlbjtcbiAgICAgICAgICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc2VydGVkIDwgYS5pID8gYS5pbnMgOiAwKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zZXJ0ZWQgPCBhLmkpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGEuaTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChhLmxlbiAtIGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU2V0cyhzZXRBLCBzZXRCLCBta1NldCA9IGZhbHNlKSB7XG4gICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgbGV0IGluc2VydCA9IG1rU2V0ID8gW10gOiBudWxsO1xuICAgIGxldCBhID0gbmV3IFNlY3Rpb25JdGVyKHNldEEpLCBiID0gbmV3IFNlY3Rpb25JdGVyKHNldEIpO1xuICAgIGZvciAobGV0IG9wZW4gPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAwKSB7IC8vIERlbGV0aW9uIGluIEFcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEubGVuLCAwLCBvcGVuKTtcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIubGVuID09IDAgJiYgIWIuZG9uZSkgeyAvLyBJbnNlcnRpb24gaW4gQlxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZG9uZSB8fCBiLmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuMiwgYi5sZW4pLCBzZWN0aW9uTGVuID0gc2VjdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc0IgPSBiLmlucyA9PSAtMSA/IC0xIDogYi5vZmYgPyAwIDogYi5pbnM7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNCLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc0IpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgbGVuLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0Qml0KGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGIub2ZmID8gMCA6IGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ICYmICFiLm9mZilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuID0gKGEuaW5zID4gbGVuIHx8IGIuaW5zID49IDAgJiYgYi5sZW4gPiBsZW4pICYmIChvcGVuIHx8IHNlY3Rpb25zLmxlbmd0aCA+IHNlY3Rpb25MZW4pO1xuICAgICAgICAgICAgYS5mb3J3YXJkMihsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTZWN0aW9uSXRlciB7XG4gICAgY29uc3RydWN0b3Ioc2V0KSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IHsgc2VjdGlvbnMgfSA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAodGhpcy5pIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGdldCBkb25lKCkgeyByZXR1cm4gdGhpcy5pbnMgPT0gLTI7IH1cbiAgICBnZXQgbGVuMigpIHsgcmV0dXJuIHRoaXMuaW5zIDwgMCA/IHRoaXMubGVuIDogdGhpcy5pbnM7IH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoID8gVGV4dC5lbXB0eSA6IGluc2VydGVkW2luZGV4XTtcbiAgICB9XG4gICAgdGV4dEJpdChsZW4pIHtcbiAgICAgICAgbGV0IHsgaW5zZXJ0ZWQgfSA9IHRoaXMuc2V0LCBpbmRleCA9ICh0aGlzLmkgLSAyKSA+PiAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gaW5zZXJ0ZWQubGVuZ3RoICYmICFsZW4gPyBUZXh0LmVtcHR5XG4gICAgICAgICAgICA6IGluc2VydGVkW2luZGV4XS5zbGljZSh0aGlzLm9mZiwgbGVuID09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLm9mZiArIGxlbik7XG4gICAgfVxuICAgIGZvcndhcmQobGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yd2FyZDIobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmlucyA9PSAtMSlcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPT0gdGhpcy5pbnMpXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucyAtPSBsZW47XG4gICAgICAgICAgICB0aGlzLm9mZiArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuQSBzaW5nbGUgc2VsZWN0aW9uIHJhbmdlLiBXaGVuXG5bYGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5hbGxvd011bHRpcGxlU2VsZWN0aW9ucylcbmlzIGVuYWJsZWQsIGEgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTZWxlY3Rpb24pIG1heSBob2xkXG5tdWx0aXBsZSByYW5nZXMuIEJ5IGRlZmF1bHQsIHNlbGVjdGlvbnMgaG9sZCBleGFjdGx5IG9uZSByYW5nZS5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNob3Igb2YgdGhlIHJhbmdl4oCUdGhlIHNpZGUgdGhhdCBkb2Vzbid0IG1vdmUgd2hlbiB5b3VcbiAgICBleHRlbmQgaXQuXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDE2IC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBUaGUgaGVhZCBvZiB0aGUgcmFuZ2UsIHdoaWNoIGlzIG1vdmVkIHdoZW4gdGhlIHJhbmdlIGlzXG4gICAgW2V4dGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmV4dGVuZCkuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLmZyb20gOiB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIGBhbmNob3JgIGFuZCBgaGVhZGAgYXJlIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mcm9tID09IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgY3Vyc29yIHRoYXQgaXMgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgY2hhcmFjdGVyIG9uIG9uZSBvZiBpdHMgc2lkZXMsIHRoaXMgcmV0dXJucyB0aGUgc2lkZS4gLTEgbWVhbnNcbiAgICB0aGUgY2hhcmFjdGVyIGJlZm9yZSBpdHMgcG9zaXRpb24sIDEgdGhlIGNoYXJhY3RlciBhZnRlciwgYW5kIDBcbiAgICBtZWFucyBubyBhc3NvY2lhdGlvbi5cbiAgICAqL1xuICAgIGdldCBhc3NvYygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiA0IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA/IC0xIDogdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiAzIC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xuICAgICAgICByZXR1cm4gbGV2ZWwgPT0gMyA/IG51bGwgOiBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGdvYWwgY29sdW1uIChzdG9yZWQgdmVydGljYWwgb2Zmc2V0KSBhc3NvY2lhdGVkIHdpdGggYVxuICAgIGN1cnNvci4gVGhpcyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aGVuXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICAgIGxpbmVzIG9mIGRpZmZlcmVudCBsZW5ndGguXG4gICAgKi9cbiAgICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5mbGFncyA+PiA1IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgYXNzb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCAxKTtcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07IH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlIHRvIGEgYFNlbGVjdGlvblJhbmdlYFxuICAgIGluc3RhbmNlLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmhlYWQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBTZWxlY3Rpb25SYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShqc29uLmFuY2hvciwganNvbi5oZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCBmbGFncykge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCBmbGFncyk7XG4gICAgfVxufVxuLyoqXG5BbiBlZGl0b3Igc2VsZWN0aW9uIGhvbGRzIG9uZSBvciBtb3JlIHNlbGVjdGlvbiByYW5nZXMuXG4qL1xuY2xhc3MgRWRpdG9yU2VsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2VzIGluIHRoZSBzZWxlY3Rpb24sIHNvcnRlZCBieSBwb3NpdGlvbi4gUmFuZ2VzIGNhbm5vdFxuICAgIG92ZXJsYXAgKGJ1dCB0aGV5IG1heSB0b3VjaCwgaWYgdGhleSBhcmVuJ3QgZW1wdHkpLlxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgaW5kZXggb2YgdGhlIF9tYWluXyByYW5nZSBpbiB0aGUgc2VsZWN0aW9uICh3aGljaCBpc1xuICAgIHVzdWFsbHkgdGhlIHJhbmdlIHRoYXQgd2FzIGFkZGVkIGxhc3QpLlxuICAgICovXG4gICAgbWFpbkluZGV4KSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLm1haW5JbmRleCA9IG1haW5JbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgc2VsZWN0aW9uIHRocm91Z2ggYSBjaGFuZ2UuIFVzZWQgdG8gYWRqdXN0IHRoZSBzZWxlY3Rpb25cbiAgICBwb3NpdGlvbiBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnJhbmdlcy5tYXAociA9PiByLm1hcChjaGFuZ2UsIGFzc29jKSksIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHNlbGVjdGlvbiB0byBhbm90aGVyIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggIT0gb3RoZXIucmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5tYWluSW5kZXggIT0gb3RoZXIubWFpbkluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lcShvdGhlci5yYW5nZXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ubm9ybWFsaXplZChyYW5nZXMuc2xpY2UoKSwgbWFpbkluZGV4KTtcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHNlbGVjdGlvbiByYW5nZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFlvdSBjYW5cbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGN1cnNvcihwb3MsIGFzc29jID0gMCwgYmlkaUxldmVsLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gMyA6IE1hdGgubWluKDIsIGJpZGlMZXZlbCkpIHxcbiAgICAgICAgICAgICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMzM1NTQ0MzEgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNSAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgcmFuZ2UoYW5jaG9yLCBoZWFkLCBnb2FsQ29sdW1uLCBiaWRpTGV2ZWwpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAzMzU1NDQzMSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA1IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyAzIDogTWF0aC5taW4oMiwgYmlkaUxldmVsKSk7XG4gICAgICAgIHJldHVybiBoZWFkIDwgYW5jaG9yID8gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKGhlYWQsIGFuY2hvciwgMTYgLyogUmFuZ2VGbGFnLkludmVydGVkICovIHwgOCAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyB8IGZsYWdzKVxuICAgICAgICAgICAgOiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoYW5jaG9yLCBoZWFkLCAoaGVhZCA+IGFuY2hvciA/IDQgLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkgfCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIGVuYWJsZXMpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5jb21wYXJlSW5wdXQgPSBjb21wYXJlSW5wdXQ7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbWJpbmUoW10pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcbiAgICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gICAgdGhpcyB2YWx1ZSBkZXBlbmRzIG9uLCBzaW5jZSB5b3VyIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGFnYWluXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXG4gICAgXG4gICAgSW4gY2FzZXMgd2hlcmUgeW91ciB2YWx1ZSBkZXBlbmRzIG9ubHkgb24gYSBzaW5nbGUgZmllbGQsIHlvdSdsbFxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxuICAgICovXG4gICAgY29tcHV0ZShkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMSAvKiBQcm92aWRlci5TaW5nbGUgKi8sIGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyB6ZXJvIG9yIG1vcmUgdmFsdWVzIGZvciB0aGlzXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxuICAgICovXG4gICAgY29tcHV0ZU4oZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDIgLyogUHJvdmlkZXIuTXVsdGkgKi8sIGdldCk7XG4gICAgfVxuICAgIGZyb20oZmllbGQsIGdldCkge1xuICAgICAgICBpZiAoIWdldClcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShbZmllbGRdLCBzdGF0ZSA9PiBnZXQoc3RhdGUuZmllbGQoZmllbGQpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8IGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGUgPT09IGJbaV0pO1xufVxuY2xhc3MgRmFjZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLCBmYWNldCwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgfVxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmlkLCBpZHggPSBhZGRyZXNzZXNbaWRdID4+IDEsIG11bHRpID0gdGhpcy50eXBlID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi87XG4gICAgICAgIGxldCBkZXBEb2MgPSBmYWxzZSwgZGVwU2VsID0gZmFsc2UsIGRlcEFkZHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcCA9PSBcImRvY1wiKVxuICAgICAgICAgICAgICAgIGRlcERvYyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBkZXBTZWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoKCgoX2EgPSBhZGRyZXNzZXNbZGVwLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgJiAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8IGVuc3VyZUFsbChzdGF0ZSwgZGVwQWRkcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyAhY29tcGFyZUFycmF5KG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0sIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBnZXRBZGRyKG9sZFN0YXRlLCBvbGRBZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwIGluc3RhbmNlb2YgRmFjZXQgPyBvbGRTdGF0ZS5mYWNldChkZXApID09PSBzdGF0ZS5mYWNldChkZXApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkID8gb2xkU3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgPT0gc3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQWxsKHN0YXRlLCBhZGRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcbiAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpICYgMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi8pXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICBmdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEFkZHIoc3RhdGUsIHByb3ZpZGVyQWRkcnNbaV0pO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyVHlwZXNbaV0gPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNldC5jb21iaW5lKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxuICAgICAgICAgICAgICAgIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29uZmlndXJlKHN0YXRlLCBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZFN0YXRlLmNvbmZpZy5mYWNldHNbZmFjZXQuaWRdLCBvbGRWYWx1ZSA9IG9sZFN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIGlmIChvbGRQcm92aWRlcnMgJiYgIWRlcENoYW5nZWQgJiYgc2FtZUFycmF5KHByb3ZpZGVycywgb2xkUHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXG4gICAgd2l0aG91dCBhbiBleHBsaWNpdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93KSxcbiAgICAvKipcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgZW5kIG9mIHRoZSBleHRlbnNpb24gb3JkZXIuXG4gICAgKi9cbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcbn07XG5jbGFzcyBQcmVjRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucHJlYyA9IHByZWM7XG4gICAgfVxufVxuLyoqXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXG5keW5hbWljLiBCeSBbd3JhcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQub2YpIHBhcnQgb2YgeW91clxuY29uZmlndXJhdGlvbiBpbiBhIGNvbXBhcnRtZW50LCB5b3UgY2FuIGxhdGVyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxudHJhbnNhY3Rpb24uXG4qL1xuY2xhc3MgQ29tcGFydG1lbnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXG4gICAgKi9cbiAgICBvZihleHQpIHsgcmV0dXJuIG5ldyBDb21wYXJ0bWVudEluc3RhbmNlKHRoaXMsIGV4dCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdGhhdFxuICAgIHJlY29uZmlndXJlcyB0aGlzIGNvbXBhcnRtZW50LlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gQ29tcGFydG1lbnQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBjb250ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcnRtZW50LCBpbm5lcikge1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50ID0gY29tcGFydG1lbnQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBjb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XG4gICAgICAgIHRoaXMuZHluYW1pY1Nsb3RzID0gZHluYW1pY1Nsb3RzO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcbiAgICAgICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaCgwIC8qIFNsb3RTdGF0dXMuVW5yZXNvbHZlZCAqLyk7XG4gICAgfVxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgcmV0dXJuIGFkZHIgPT0gbnVsbCA/IGZhY2V0LmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIG9sZFN0YXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBuZXdDb21wYXJ0bWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiBmbGF0dGVuKGJhc2UsIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSkge1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZHJlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XG4gICAgICAgIGxldCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUuZmFjZXQoZmFjZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhY2V0LmNvbWJpbmUocHJvdmlkZXJzLm1hcChwID0+IHAudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUgJiYgZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkU3RhdGUuZmFjZXQoZmFjZXQpKSA/IG9sZFN0YXRlLmZhY2V0KGZhY2V0KSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY1Nsb3RzLm1hcChmID0+IGYoYWRkcmVzcykpO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtbXSwgW10sIFtdLCBbXSwgW11dO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xuICAgICAgICBsZXQga25vd24gPSBzZWVuLmdldChleHQpO1xuICAgICAgICBpZiAoa25vd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gcmVzdWx0W2tub3duXS5pbmRleE9mKGV4dCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgICAgICByZXN1bHRba25vd25dLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zZXQoZXh0LCBwcmVjKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBleHQpXG4gICAgICAgICAgICAgICAgaW5uZXIoZSwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NvbXBhcnRtZW50cy5oYXMoZXh0LmNvbXBhcnRtZW50KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGNvbXBhcnRtZW50cy5nZXQoZXh0LmNvbXBhcnRtZW50KSB8fCBleHQuaW5uZXI7XG4gICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuc2V0KGV4dC5jb21wYXJ0bWVudCwgY29udGVudCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQcmVjRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5wcm92aWRlcylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQucHJvdmlkZXMsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIEZhY2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LmZhY2V0LmV4dGVuc2lvbnMsIFByZWNfLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBleHQuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIoZXh0ZW5zaW9uLCBQcmVjXy5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikge1xuICAgIGlmIChhZGRyICYgMSlcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLylcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICBzdGF0ZS5zdGF0dXNbaWR4XSA9IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb21wdXRlU2xvdChzdGF0ZSwgc3RhdGUuY29uZmlnLmR5bmFtaWNTbG90c1tpZHhdKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh2ID0+IHYpLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBsaW5lU2VwYXJhdG9yID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25FeHRlbmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXG4qL1xuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSwgb3IgaW1tZWRpYXRlbHlcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXG5bYEVkaXRvclZpZXcuZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXG4gICAgKi9cbiAgICBzdGFydFN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBjaGFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgaXRcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBUaGUgZWZmZWN0cyBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlZmZlY3RzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFubm90YXRpb25zLCBcbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXG4gICAgdHJhbnNhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb2MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgY2hhbmdlcy5uZXdMZW5ndGgpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zLnNvbWUoKGEpID0+IGEudHlwZSA9PSBUcmFuc2FjdGlvbi50aW1lKSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xuICAgIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB3aGVuIHBvc3NpYmxlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlKVxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiB0eXBlLCBpZiBhbnkuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgYW5uIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBpZiAoYW5uLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxuICAgIHdpdGggYSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvblxuICAgIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAgICovXG4gICAgZ2V0IHJlY29uZmlndXJlZCgpIHsgcmV0dXJuIHRoaXMuc3RhcnRTdGF0ZS5jb25maWcgIT0gdGhpcy5zdGF0ZS5jb25maWc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gICAgZXZlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSBhbm5vdGF0aW9uIHRoYXQgaXMgZXF1YWwgdG9cbiAgICBvciBtb3JlIHNwZWNpZmljIHRoYW4gYGV2ZW50YC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gICAgYFwic2VsZWN0LnBvaW50ZXJcImAgd2lsbCBtYXRjaCBpdC5cbiAgICAqL1xuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIHJldHVybiAhIShlICYmIChlID09IGV2ZW50IHx8IGUubGVuZ3RoID4gZXZlbnQubGVuZ3RoICYmIGUuc2xpY2UoMCwgZXZlbnQubGVuZ3RoKSA9PSBldmVudCAmJiBlW2V2ZW50Lmxlbmd0aF0gPT0gXCIuXCIpKTtcbiAgICB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XG5hZGRlZCB0byBldmVyeSB0cmFuc2FjdGlvbiwgaG9sZGluZyBgRGF0ZS5ub3coKWAuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbnZhciBDaGFyQ2F0ZWdvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbnJldHVybiBDaGFyQ2F0ZWdvcnl9KShDaGFyQ2F0ZWdvcnkgfHwgKENoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XG59XG5jYXRjaCAoXykgeyB9XG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcbiAgICBpZiAod29yZENoYXIpXG4gICAgICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KHN0cik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoID0gc3RyW2ldO1xuICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiYgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3JpemVyKHdvcmRDaGFycykge1xuICAgIHJldHVybiAoY2hhcikgPT4ge1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsdWVzLCBjb21wdXRlU2xvdCwgdHIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBjb21wdXRlU2xvdDtcbiAgICAgICAgLy8gRmlsbCBpbiB0aGUgY29tcHV0ZWQgc3RhdGUgaW1tZWRpYXRlbHksIHNvIHRoYXQgZnVydGhlciBxdWVyaWVzXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXG4gICAgICAgIGlmICh0cilcbiAgICAgICAgICAgIHRyLl9zdGF0ZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBpIDw8IDEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmaWVsZC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgICBzdGF0ZS4gQW55IG51bWJlciBvZiBbdHJhbnNhY3Rpb24gc3BlY3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKVxuICAgIGNhbiBiZSBwYXNzZWQuIFVubGVzc1xuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gICAgW2NoYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmNoYW5nZXMpIChpZiBhbnkpIG9mIGVhY2ggc3BlY1xuICAgIGFyZSBhc3N1bWVkIHRvIHN0YXJ0IGluIHRoZSBfY3VycmVudF8gZG9jdW1lbnQgKG5vdCB0aGUgZG9jdW1lbnRcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgICBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGFuZFxuICAgIFtlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSBhcmUgYXNzdW1lZCB0byByZWZlclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gICAgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhbGwgdGhlIGRpZmZlcmVudFxuICAgIHNwZWNzLiBGb3IgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSwgbGF0ZXJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICAgKi9cbiAgICB1cGRhdGUoLi4uc3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cikge1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoQ29tcGFydG1lbnQucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFydG1lbnRzID0gbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZi5jb21wYXJ0bWVudHMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGNvbXBhcnRtZW50cy5zZXQoa2V5LCB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cy5zZXQoZWZmZWN0LnZhbHVlLmNvbXBhcnRtZW50LCBlZmZlY3QudmFsdWUuZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gYXNBcnJheShiYXNlKS5jb25jYXQoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRWYWx1ZXM7XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IGludGVybWVkaWF0ZVN0YXRlID0gbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgY29uZi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QucmVjb25maWd1cmUoc3RhdGUsIHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gaW50ZXJtZWRpYXRlU3RhdGUudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB0ci5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0ci5uZXdEb2MsIHRyLm5ld1NlbGVjdGlvbiwgc3RhcnRWYWx1ZXMsIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC51cGRhdGUoc3RhdGUsIHRyKSwgdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb24gc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpIHRoYXRcbiAgICByZXBsYWNlcyBldmVyeSBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiAoeyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgdGV4dC5sZW5ndGgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGNoYW5nZXMgYW5kIGEgbmV3IHNlbGVjdGlvbiBieSBydW5uaW5nIHRoZSBnaXZlblxuICAgIGZ1bmN0aW9uIGZvciBlYWNoIHJhbmdlIGluIHRoZSBhY3RpdmUgc2VsZWN0aW9uLiBUaGUgZnVuY3Rpb25cbiAgICBjYW4gcmV0dXJuIGFuIG9wdGlvbmFsIHNldCBvZiBjaGFuZ2VzIChpbiB0aGUgY29vcmRpbmF0ZSBzcGFjZVxuICAgIG9mIHRoZSBzdGFydCBkb2N1bWVudCksIHBsdXMgYW4gdXBkYXRlZCByYW5nZSAoaW4gdGhlIGNvb3JkaW5hdGVcbiAgICBzcGFjZSBvZiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIGNhbGwncyBvd24gY2hhbmdlcykuIFRoaXNcbiAgICBtZXRob2Qgd2lsbCBtZXJnZSBhbGwgdGhlIGNoYW5nZXMgYW5kIHJhbmdlcyBpbnRvIGEgc2luZ2xlXG4gICAgY2hhbmdlc2V0IGFuZCBzZWxlY3Rpb24sIGFuZCByZXR1cm4gaXQgYXMgYSBbdHJhbnNhY3Rpb25cbiAgICBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYyksIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG9cbiAgICBbYHVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiAgICAqL1xuICAgIGNoYW5nZUJ5UmFuZ2UoZikge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGxldCByZXN1bHQxID0gZihzZWwucmFuZ2VzWzBdKTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0MS5jaGFuZ2VzKSwgcmFuZ2VzID0gW3Jlc3VsdDEucmFuZ2VdO1xuICAgICAgICBsZXQgZWZmZWN0cyA9IGFzQXJyYXkocmVzdWx0MS5lZmZlY3RzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihzZWwucmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIGxldCBuZXdDaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdC5jaGFuZ2VzKSwgbmV3TWFwcGVkID0gbmV3Q2hhbmdlcy5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSByYW5nZXNbal0ubWFwKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBsZXQgbWFwQnkgPSBjaGFuZ2VzLm1hcERlc2MobmV3Q2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyZXN1bHQucmFuZ2UubWFwKG1hcEJ5KSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb21wb3NlKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBlZmZlY3RzID0gU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhlZmZlY3RzLCBuZXdNYXBwZWQpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGFzQXJyYXkocmVzdWx0LmVmZmVjdHMpLCBtYXBCeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCksXG4gICAgICAgICAgICBlZmZlY3RzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldCkgZnJvbSB0aGUgZ2l2ZW4gY2hhbmdlXG4gICAgZGVzY3JpcHRpb24sIHRha2luZyB0aGUgc3RhdGUncyBkb2N1bWVudCBsZW5ndGggYW5kIGxpbmVcbiAgICBzZXBhcmF0b3IgaW50byBhY2NvdW50LlxuICAgICovXG4gICAgY2hhbmdlcyhzcGVjID0gW10pIHtcbiAgICAgICAgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpXG4gICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgcmV0dXJuIENoYW5nZVNldC5vZihzcGVjLCB0aGlzLmRvYy5sZW5ndGgsIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2luZyB0aGUgc3RhdGUncyBbbGluZVxuICAgIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcbiAgICBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIHRvVGV4dChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFRleHQub2Yoc3RyaW5nLnNwbGl0KHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLlxuICAgICovXG4gICAgc2xpY2VEb2MoZnJvbSA9IDAsIHRvID0gdGhpcy5kb2MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgdGhpcy5saW5lQnJlYWspO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0KS5cbiAgICAqL1xuICAgIGZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQuZGVmYXVsdDtcbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzdGF0ZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsIHlvdSBjYW4gcGFzcyB0aGVtIGluIGFzIGFuIG9iamVjdFxuICAgIG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgKGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LCB3aGljaCBzaG91bGRcbiAgICBub3QgdXNlIGBkb2NgIG9yIGBzZWxlY3Rpb25gKSB0byBmaWVsZHMuXG4gICAgKi9cbiAgICB0b0pTT04oZmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmllbGRzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRlRmllbGQgJiYgdGhpcy5jb25maWcuYWRkcmVzc1t2YWx1ZS5pZF0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWUuc3BlYy50b0pTT04odGhpcy5maWVsZChmaWVsZHNbcHJvcF0pLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgZGVzZXJpYWxpemVkLCBwYXNzIHRoZSBzYW1lIG9iamVjdCB5b3UgcGFzc2VkXG4gICAgdG8gW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgd2hlbiBzZXJpYWxpemluZyBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24sIGNvbmZpZyA9IHt9LCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmRvYyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclN0YXRlXCIpO1xuICAgICAgICBsZXQgZmllbGRJbml0ID0gW107XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdLCB2YWx1ZSA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5pdC5wdXNoKGZpZWxkLmluaXQoc3RhdGUgPT4gZmllbGQuc3BlYy5mcm9tSlNPTih2YWx1ZSwgc3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIGRvYzoganNvbi5kb2MsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnNlbGVjdGlvbiksXG4gICAgICAgICAgICBleHRlbnNpb25zOiBjb25maWcuZXh0ZW5zaW9ucyA/IGZpZWxkSW5pdC5jb25jYXQoW2NvbmZpZy5leHRlbnNpb25zXSkgOiBmaWVsZEluaXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS4gWW91J2xsIHVzdWFsbHkgb25seSBuZWVkIHRoaXMgd2hlblxuICAgIGluaXRpYWxpemluZyBhbiBlZGl0b3LigJR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xuICAgIHRyYW5zYWN0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uLnJlc29sdmUoY29uZmlnLmV4dGVuc2lvbnMgfHwgW10sIG5ldyBNYXApO1xuICAgICAgICBsZXQgZG9jID0gY29uZmlnLmRvYyBpbnN0YW5jZW9mIFRleHQgPyBjb25maWcuZG9jXG4gICAgICAgICAgICA6IFRleHQub2YoKGNvbmZpZy5kb2MgfHwgXCJcIikuc3BsaXQoY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9ICFjb25maWcuc2VsZWN0aW9uID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSgwKVxuICAgICAgICAgICAgOiBjb25maWcuc2VsZWN0aW9uIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gY29uZmlnLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjb25maWcuc2VsZWN0aW9uLmFuY2hvciwgY29uZmlnLnNlbGVjdGlvbi5oZWFkKTtcbiAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2MubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSlcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKGNvbmZpZ3VyYXRpb24sIGRvYywgc2VsZWN0aW9uLCBjb25maWd1cmF0aW9uLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5jcmVhdGUoc3RhdGUpLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgKGluIGNvbHVtbnMpIG9mIGEgdGFiIGluIHRoZSBkb2N1bWVudCwgZGV0ZXJtaW5lZCBieVxuICAgIHRoZSBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIGZhY2V0LlxuICAgICovXG4gICAgZ2V0IHRhYlNpemUoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnRhYlNpemUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcm9wZXIgW2xpbmUtYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvcilcbiAgICBzdHJpbmcgZm9yIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBcIlxcblwiOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnJlYWRPbmx5KSB0byBiZSByZWFkLW9ubHkuXG4gICAgKi9cbiAgICBnZXQgcmVhZE9ubHkoKSB7IHJldHVybiB0aGlzLmZhY2V0KHJlYWRPbmx5KTsgfVxuICAgIC8qKlxuICAgIExvb2sgdXAgYSB0cmFuc2xhdGlvbiBmb3IgdGhlIGdpdmVuIHBocmFzZSAodmlhIHRoZVxuICAgIFtgcGhyYXNlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecGhyYXNlcykgZmFjZXQpLCBvciByZXR1cm4gdGhlXG4gICAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxuICAgIFxuICAgIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwYXNzZWQsIHRoZXkgd2lsbCBiZSBpbnNlcnRlZCBpblxuICAgIHBsYWNlIG9mIG1hcmtlcnMgbGlrZSBgJDFgIChmb3IgdGhlIGZpcnN0IHZhbHVlKSBhbmQgYCQyYCwgZXRjLlxuICAgIEEgc2luZ2xlIGAkYCBpcyBlcXVpdmFsZW50IHRvIGAkMWAsIGFuZCBgJCRgIHdpbGwgcHJvZHVjZSBhXG4gICAgbGl0ZXJhbCBkb2xsYXIgc2lnbi5cbiAgICAqL1xuICAgIHBocmFzZShwaHJhc2UsIC4uLmluc2VydCkge1xuICAgICAgICBmb3IgKGxldCBtYXAgb2YgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBwaHJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcGhyYXNlID0gbWFwW3BocmFzZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnQubGVuZ3RoKVxuICAgICAgICAgICAgcGhyYXNlID0gcGhyYXNlLnJlcGxhY2UoL1xcJChcXCR8XFxkKikvZywgKG0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBcIiRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICAgICAgICAgIGxldCBuID0gKyhpIHx8IDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhbiB8fCBuID4gaW5zZXJ0Lmxlbmd0aCA/IG0gOiBpbnNlcnRbbiAtIDFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZSBkYXRhIGZpZWxkLCBwcm92aWRlZCBieSB0aGVcbiAgICB0aGUgW2BsYW5ndWFnZURhdGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxhbmd1YWdlRGF0YSkgZmFjZXQuXG4gICAgXG4gICAgRXhhbXBsZXMgb2YgbGFuZ3VhZ2UgZGF0YSBmaWVsZHMgYXJlLi4uXG4gICAgXG4gICAgLSBbYFwiY29tbWVudFRva2Vuc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBmb3Igc3BlY2lmeWluZ1xuICAgICAgY29tbWVudCBzeW50YXguXG4gICAgLSBbYFwiYXV0b2NvbXBsZXRlXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbl5jb25maWcub3ZlcnJpZGUpXG4gICAgICBmb3IgcHJvdmlkaW5nIGxhbmd1YWdlLXNwZWNpZmljIGNvbXBsZXRpb24gc291cmNlcy5cbiAgICAtIFtgXCJ3b3JkQ2hhcnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBmb3IgYWRkaW5nXG4gICAgICBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB3b3JkcyBpbiB0aGlzXG4gICAgICBsYW5ndWFnZS5cbiAgICAtIFtgXCJjbG9zZUJyYWNrZXRzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5DbG9zZUJyYWNrZXRDb25maWcpIGNvbnRyb2xzXG4gICAgICBicmFja2V0IGNsb3NpbmcgYmVoYXZpb3IuXG4gICAgKi9cbiAgICBsYW5ndWFnZURhdGFBdChuYW1lLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIHRoaXMuZmFjZXQobGFuZ3VhZ2VEYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0IG9mIHByb3ZpZGVyKHRoaXMsIHBvcywgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdFtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gY2F0ZWdvcml6ZSBzdHJpbmdzIChleHBlY3RlZCB0b1xuICAgIHJlcHJlc2VudCBhIHNpbmdsZSBbZ3JhcGhlbWUgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKSlcbiAgICBpbnRvIG9uZSBvZjpcbiAgICBcbiAgICAgLSBXb3JkIChjb250YWlucyBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIG9yIGEgY2hhcmFjdGVyXG4gICAgICAgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGxvY2FsIGxhbmd1YWdlJ3MgYFwid29yZENoYXJzXCJgXG4gICAgICAgbGFuZ3VhZ2UgZGF0YSwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nKVxuICAgICAtIFNwYWNlIChjb250YWlucyBvbmx5IHdoaXRlc3BhY2UpXG4gICAgIC0gT3RoZXIgKGFueXRoaW5nIGVsc2UpXG4gICAgKi9cbiAgICBjaGFyQ2F0ZWdvcml6ZXIoYXQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDYXRlZ29yaXplcih0aGlzLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGF0KS5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIG1lYW5pbmcgdGhlIHJhbmdlXG4gICAgY29udGFpbmluZyBhbGwgW3dvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpIGNoYXJhY3RlcnNcbiAgICBhcm91bmQgaXQuIElmIG5vIHdvcmQgY2hhcmFjdGVycyBhcmUgYWRqYWNlbnQgdG8gdGhlIHBvc2l0aW9uLFxuICAgIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICovXG4gICAgd29yZEF0KHBvcykge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tLCBsZW5ndGggfSA9IHRoaXMuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgY2F0ID0gdGhpcy5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gZnJvbSwgZW5kID0gcG9zIC0gZnJvbTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UocHJldiwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXJ0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgZW5kKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShlbmQsIG5leHQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09IGVuZCA/IG51bGwgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoc3RhcnQgKyBmcm9tLCBlbmQgKyBmcm9tKTtcbiAgICB9XG59XG4vKipcbkEgZmFjZXQgdGhhdCwgd2hlbiBlbmFibGVkLCBjYXVzZXMgdGhlIGVkaXRvciB0byBhbGxvdyBtdWx0aXBsZVxucmFuZ2VzIHRvIGJlIHNlbGVjdGVkLiBCZSBjYXJlZnVsIHRob3VnaCwgYmVjYXVzZSBieSBkZWZhdWx0IHRoZVxuZWRpdG9yIHJlbGllcyBvbiB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24sIHdoaWNoIGNhbm5vdCBoYW5kbGVcbm11bHRpcGxlIHNlbGVjdGlvbnMuIEFuIGV4dGVuc2lvbiBsaWtlXG5bYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY2FuIGJlIHVzZWQgdG8gbWFrZVxuc2Vjb25kYXJ5IHNlbGVjdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlci5cbiovXG5FZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zO1xuLyoqXG5Db25maWd1cmVzIHRoZSB0YWIgc2l6ZSB0byB1c2UgaW4gdGhpcyBzdGF0ZS4gVGhlIGZpcnN0XG4oaGlnaGVzdC1wcmVjZWRlbmNlKSB2YWx1ZSBvZiB0aGUgZmFjZXQgaXMgdXNlZC4gSWYgbm8gdmFsdWUgaXNcbmdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIDQuXG4qL1xuRWRpdG9yU3RhdGUudGFiU2l6ZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogNFxufSk7XG4vKipcblRoZSBsaW5lIHNlcGFyYXRvciB0byB1c2UuIEJ5IGRlZmF1bHQsIGFueSBvZiBgXCJcXG5cImAsIGBcIlxcclxcblwiYFxuYW5kIGBcIlxcclwiYCBpcyB0cmVhdGVkIGFzIGEgc2VwYXJhdG9yIHdoZW4gc3BsaXR0aW5nIGxpbmVzLCBhbmRcbmxpbmVzIGFyZSBqb2luZWQgd2l0aCBgXCJcXG5cImAuXG5cbldoZW4geW91IGNvbmZpZ3VyZSBhIHZhbHVlIGhlcmUsIG9ubHkgdGhhdCBwcmVjaXNlIHNlcGFyYXRvclxud2lsbCBiZSB1c2VkLCBhbGxvd2luZyB5b3UgdG8gcm91bmQtdHJpcCBkb2N1bWVudHMgdGhyb3VnaCB0aGVcbmVkaXRvciB3aXRob3V0IG5vcm1hbGl6aW5nIGxpbmUgc2VwYXJhdG9ycy5cbiovXG5FZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yID0gbGluZVNlcGFyYXRvcjtcbi8qKlxuVGhpcyBmYWNldCBjb250cm9scyB0aGUgdmFsdWUgb2YgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZ2V0dGVyLCB3aGljaCBpc1xuY29uc3VsdGVkIGJ5IGNvbW1hbmRzIGFuZCBleHRlbnNpb25zIHRoYXQgaW1wbGVtZW50IGVkaXRpbmdcbmZ1bmN0aW9uYWxpdHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhleSBzaG91bGQgYXBwbHkuIEl0XG5kZWZhdWx0cyB0byBmYWxzZSwgYnV0IHdoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpc1xuYHRydWVgLCBzdWNoIGZ1bmN0aW9uYWxpdHkgZGlzYWJsZXMgaXRzZWxmLlxuXG5Ob3QgdG8gYmUgY29uZnVzZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmVkaXRhYmxlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdGFibGUpLCB3aGljaFxuY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yJ3MgRE9NIGlzIHNldCB0byBiZSBlZGl0YWJsZSAoYW5kXG50aHVzIGZvY3VzYWJsZSkuXG4qL1xuRWRpdG9yU3RhdGUucmVhZE9ubHkgPSByZWFkT25seTtcbi8qKlxuUmVnaXN0ZXJzIHRyYW5zbGF0aW9uIHBocmFzZXMuIFRoZVxuW2BwaHJhc2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnBocmFzZSkgbWV0aG9kIHdpbGwgbG9vayB0aHJvdWdoXG5hbGwgb2JqZWN0cyByZWdpc3RlcmVkIHdpdGggdGhpcyBmYWNldCB0byBmaW5kIHRyYW5zbGF0aW9ucyBmb3Jcbml0cyBhcmd1bWVudC5cbiovXG5FZGl0b3JTdGF0ZS5waHJhc2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGxldCBrQSA9IE9iamVjdC5rZXlzKGEpLCBrQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga0EubGVuZ3RoID09IGtCLmxlbmd0aCAmJiBrQS5ldmVyeShrID0+IGFba10gPT0gYltrXSk7XG4gICAgfVxufSk7XG4vKipcbkEgZmFjZXQgdXNlZCB0byByZWdpc3RlciBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIHByb3ZpZGVycy5cbiovXG5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEgPSBsYW5ndWFnZURhdGE7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgY2hhbmdlIGZpbHRlcnMsIHdoaWNoIGFyZSBjYWxsZWQgZm9yIGVhY2hcbnRyYW5zYWN0aW9uICh1bmxlc3MgZXhwbGljaXRseVxuW2Rpc2FibGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpKSwgYW5kIGNhbiBzdXBwcmVzc1xucGFydCBvZiB0aGUgdHJhbnNhY3Rpb24ncyBjaGFuZ2VzLlxuXG5TdWNoIGEgZnVuY3Rpb24gY2FuIHJldHVybiBgdHJ1ZWAgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0XG53YW50IHRvIGRvIGFueXRoaW5nLCBgZmFsc2VgIHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgY2hhbmdlcyBpblxudGhlIHRyYW5zYWN0aW9uLCBvciBhIHNldCBvZiByYW5nZXMgaW4gd2hpY2ggY2hhbmdlcyBzaG91bGQgYmVcbnN1cHByZXNzZWQuIFN1Y2ggcmFuZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLFxud2l0aCBlYWNoIHBhaXIgb2YgdHdvIG51bWJlcnMgaW5kaWNhdGluZyB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhXG5yYW5nZS4gU28gZm9yIGV4YW1wbGUgYFsxMCwgMjAsIDEwMCwgMTEwXWAgc3VwcHJlc3NlcyBjaGFuZ2VzXG5iZXR3ZWVuIDEwIGFuZCAyMCwgYW5kIGJldHdlZW4gMTAwIGFuZCAxMTAuXG4qL1xuRWRpdG9yU3RhdGUuY2hhbmdlRmlsdGVyID0gY2hhbmdlRmlsdGVyO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGEgaG9vayB0aGF0IGdldHMgYSBjaGFuY2UgdG8gdXBkYXRlIG9yXG5yZXBsYWNlIHRyYW5zYWN0aW9uIHNwZWNzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLiBUaGlzIHdpbGxcbm9ubHkgYmUgYXBwbGllZCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZVxuW2BmaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpIHNldCB0byBgZmFsc2VgLiBZb3VcbmNhbiBlaXRoZXIgcmV0dXJuIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHNwZWMgKHBvc3NpYmx5IHRoZSBpbnB1dFxudHJhbnNhY3Rpb24pLCBvciBhbiBhcnJheSBvZiBzcGVjcyAod2hpY2ggd2lsbCBiZSBjb21iaW5lZCBpblxudGhlIHNhbWUgd2F5IGFzIHRoZSBhcmd1bWVudHMgdG9cbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpKS5cblxuV2hlbiBwb3NzaWJsZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gYXZvaWQgYWNjZXNzaW5nXG5bYFRyYW5zYWN0aW9uLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSkgaW4gYSBmaWx0ZXIsXG5zaW5jZSBpdCB3aWxsIGZvcmNlIGNyZWF0aW9uIG9mIGEgc3RhdGUgdGhhdCB3aWxsIHRoZW4gYmVcbmRpc2NhcmRlZCBhZ2FpbiwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFjdHVhbGx5IGZpbHRlcmVkLlxuXG4oVGhpcyBmdW5jdGlvbmFsaXR5IHNob3VsZCBiZSB1c2VkIHdpdGggY2FyZS4gSW5kaXNjcmltaW5hdGVseVxubW9kaWZ5aW5nIHRyYW5zYWN0aW9uIGlzIGxpa2VseSB0byBicmVhayBzb21ldGhpbmcgb3IgZGVncmFkZVxudGhlIHVzZXIgZXhwZXJpZW5jZS4pXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIgPSB0cmFuc2FjdGlvbkZpbHRlcjtcbi8qKlxuVGhpcyBpcyBhIG1vcmUgbGltaXRlZCBmb3JtIG9mXG5bYHRyYW5zYWN0aW9uRmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlciksXG53aGljaCBjYW4gb25seSBhZGRcblthbm5vdGF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuYW5ub3RhdGlvbnMpIGFuZFxuW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpLiBfQnV0XywgdGhpcyB0eXBlXG5vZiBmaWx0ZXIgcnVucyBldmVuIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZGlzYWJsZWQgcmVndWxhclxuW2ZpbHRlcmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSwgbWFraW5nIGl0IHN1aXRhYmxlXG5mb3IgZWZmZWN0cyB0aGF0IGRvbid0IG5lZWQgdG8gdG91Y2ggdGhlIGNoYW5nZXMgb3Igc2VsZWN0aW9uLFxuYnV0IGRvIHdhbnQgdG8gcHJvY2VzcyBldmVyeSB0cmFuc2FjdGlvbi5cblxuRXh0ZW5kZXJzIHJ1biBfYWZ0ZXJfIGZpbHRlcnMsIHdoZW4gYm90aCBhcmUgcHJlc2VudC5cbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkV4dGVuZGVyID0gdHJhbnNhY3Rpb25FeHRlbmRlcjtcbkNvbXBhcnRtZW50LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vKipcblV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbWJpbmluZyBiZWhhdmlvcnMgdG8gZmlsbCBpbiBhIGNvbmZpZ1xub2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgcHJvdmlkZWQgY29uZmlncy4gYGRlZmF1bHRzYCBzaG91bGQgaG9sZFxuZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBvcHRpb25hbCBmaWVsZHMgaW4gYENvbmZpZ2AuXG5cblRoZSBmdW5jdGlvbiB3aWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuRWFjaCByYW5nZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggbXVzdCBpbmhlcml0IGZyb21cbnRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xuICAgIHJhbmdlc2V0cy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgVW5sZXNzIHlvdSBhcmUgb25seSBjcmVhdGluZyBhIGZpeGVkIG51bWJlciBvZiB1bmlxdWUgaW5zdGFuY2VzXG4gICAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xuICAgIHByb3Blcmx5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIHdpdGggdGhpcyB2YWx1ZS5cbiAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkgeyByZXR1cm4gUmFuZ2UuY3JlYXRlKGZyb20sIHRvLCB0aGlzKTsgfVxufVxuUmFuZ2VWYWx1ZS5wcm90b3R5cGUuc3RhcnRTaWRlID0gUmFuZ2VWYWx1ZS5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tEZWw7XG4vKipcbkEgcmFuZ2UgYXNzb2NpYXRlcyBhIHZhbHVlIHdpdGggYSByYW5nZSBvZiBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgSXRzIGVuZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmFuZ2UuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY21wUmFuZ2UoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS52YWx1ZS5zdGFydFNpZGUgLSBiLnZhbHVlLnN0YXJ0U2lkZTtcbn1cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgdmFsdWUsIFxuICAgIC8vIENodW5rcyBhcmUgbWFya2VkIHdpdGggdGhlIGxhcmdlc3QgcG9pbnQgdGhhdCBvY2N1cnNcbiAgICAvLyBpbiB0aGVtIChvciAtMSBmb3Igbm8gcG9pbnRzKSwgc28gdGhhdCBzY2FucyB0aGF0IGFyZVxuICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBwb2ludHMgKHN1Y2ggYXMgdGhlXG4gICAgLy8gaGVpZ2h0bWFwLXJlbGF0ZWQgbG9naWMpIGNhbiBza2lwIHJhbmdlLW9ubHkgY2h1bmtzLlxuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvW3RoaXMudG8ubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuIFVzZSB0aGUgcmFuZ2VzJ1xuICAgIC8vIGBmcm9tYCBwb3Mgd2hlbiBgZW5kID09IGZhbHNlYCwgYHRvYCB3aGVuIGBlbmQgPT0gdHJ1ZWAuXG4gICAgZmluZEluZGV4KHBvcywgc2lkZSwgZW5kLCBzdGFydEF0ID0gMCkge1xuICAgICAgICBsZXQgYXJyID0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbG8gPSBzdGFydEF0LCBoaSA9IGFyci5sZW5ndGg7Oykge1xuICAgICAgICAgICAgaWYgKGxvID09IGhpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICAgICAgICAgIGxldCBkaWZmID0gYXJyW21pZF0gLSBwb3MgfHwgKGVuZCA/IHRoaXMudmFsdWVbbWlkXS5lbmRTaWRlIDogdGhpcy52YWx1ZVttaWRdLnN0YXJ0U2lkZSkgLSBzaWRlO1xuICAgICAgICAgICAgaWYgKG1pZCA9PSBsbylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcbiAgICAgICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4ob2Zmc2V0LCBmcm9tLCB0bywgZikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maW5kSW5kZXgoZnJvbSwgLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIHRydWUpLCBlID0gdGhpcy5maW5kSW5kZXgodG8sIDEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIGZhbHNlLCBpKTsgaSA8IGU7IGkrKylcbiAgICAgICAgICAgIGlmIChmKHRoaXMuZnJvbVtpXSArIG9mZnNldCwgdGhpcy50b1tpXSArIG9mZnNldCwgdGhpcy52YWx1ZVtpXSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwKG9mZnNldCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBbXSwgZnJvbSA9IFtdLCB0byA9IFtdLCBuZXdQb3MgPSAtMSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZVtpXSwgY3VyRnJvbSA9IHRoaXMuZnJvbVtpXSArIG9mZnNldCwgY3VyVG8gPSB0aGlzLnRvW2ldICsgb2Zmc2V0LCBuZXdGcm9tLCBuZXdUbztcbiAgICAgICAgICAgIGlmIChjdXJGcm9tID09IGN1clRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUsIHZhbC5tYXBNb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnN0YXJ0U2lkZSAhPSB2YWwuZW5kU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RvIDwgbmV3RnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1clRvLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zyb20gPiBuZXdUbyB8fCBuZXdGcm9tID09IG5ld1RvICYmIHZhbC5zdGFydFNpZGUgPiAwICYmIHZhbC5lbmRTaWRlIDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChuZXdUbyAtIG5ld0Zyb20gfHwgdmFsLmVuZFNpZGUgLSB2YWwuc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobmV3UG9zIDwgMClcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBuZXdGcm9tO1xuICAgICAgICAgICAgaWYgKHZhbC5wb2ludClcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBuZXdUbyAtIG5ld0Zyb20pO1xuICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpO1xuICAgICAgICAgICAgZnJvbS5wdXNoKG5ld0Zyb20gLSBuZXdQb3MpO1xuICAgICAgICAgICAgdG8ucHVzaChuZXdUbyAtIG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwcGVkOiB2YWx1ZS5sZW5ndGggPyBuZXcgQ2h1bmsoZnJvbSwgdG8sIHZhbHVlLCBtYXhQb2ludCkgOiBudWxsLCBwb3M6IG5ld1BvcyB9O1xuICAgIH1cbn1cbi8qKlxuQSByYW5nZSBzZXQgc3RvcmVzIGEgY29sbGVjdGlvbiBvZiBbcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBpbiBhXG53YXkgdGhhdCBtYWtlcyB0aGVtIGVmZmljaWVudCB0byBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0Lm1hcCkgYW5kXG5bdXBkYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0LnVwZGF0ZSkuIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGRhdGFcbnN0cnVjdHVyZS5cbiovXG5jbGFzcyBSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua1BvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVuaywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0TGF5ZXIsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IGNodW5rUG9zO1xuICAgICAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbmV4dExheWVyO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaHVuay5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbGFzdCA8IDAgPyAwIDogTWF0aC5tYXgodGhpcy5jaHVua0VuZChsYXN0KSwgdGhpcy5uZXh0TGF5ZXIubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiByYW5nZXMgaW4gdGhlIHNldC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5uZXh0TGF5ZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgY2h1bmsgb2YgdGhpcy5jaHVuaylcbiAgICAgICAgICAgIHNpemUgKz0gY2h1bmsudmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua0VuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua1Bvc1tpbmRleF0gKyB0aGlzLmNodW5rW2luZGV4XS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgcmFuZ2Ugc2V0LCBvcHRpb25hbGx5IGFkZGluZyBuZXcgcmFuZ2VzIG9yIGZpbHRlcmluZ1xuICAgIG91dCBleGlzdGluZyBvbmVzLlxuICAgIFxuICAgIChOb3RlOiBUaGUgdHlwZSBwYXJhbWV0ZXIgaXMganVzdCB0aGVyZSBhcyBhIGtsdWRnZSB0byB3b3JrXG4gICAgYXJvdW5kIFR5cGVTY3JpcHQgdmFyaWFuY2UgaXNzdWVzIHRoYXQgcHJldmVudGVkIGBSYW5nZVNldDxYPmBcbiAgICBmcm9tIGJlaW5nIGEgc3VidHlwZSBvZiBgUmFuZ2VTZXQ8WT5gIHdoZW4gYFhgIGlzIGEgc3VidHlwZSBvZlxuICAgIGBZYC4pXG4gICAgKi9cbiAgICB1cGRhdGUodXBkYXRlU3BlYykge1xuICAgICAgICBsZXQgeyBhZGQgPSBbXSwgc29ydCA9IGZhbHNlLCBmaWx0ZXJGcm9tID0gMCwgZmlsdGVyVG8gPSB0aGlzLmxlbmd0aCB9ID0gdXBkYXRlU3BlYztcbiAgICAgICAgbGV0IGZpbHRlciA9IHVwZGF0ZVNwZWMuZmlsdGVyO1xuICAgICAgICBpZiAoYWRkLmxlbmd0aCA9PSAwICYmICFmaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHNvcnQpXG4gICAgICAgICAgICBhZGQgPSBhZGQuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBhZGQubGVuZ3RoID8gUmFuZ2VTZXQub2YoYWRkKSA6IHRoaXM7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgTGF5ZXJDdXJzb3IodGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGkgPSAwLCBzcGlsbCA9IFtdO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKGN1ci52YWx1ZSB8fCBpIDwgYWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgPCBhZGQubGVuZ3RoICYmIChjdXIuZnJvbSAtIGFkZFtpXS5mcm9tIHx8IGN1ci5zdGFydFNpZGUgLSBhZGRbaV0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gYWRkW2krK107XG4gICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnJhbmdlSW5kZXggPT0gMSAmJiBjdXIuY2h1bmtJbmRleCA8IHRoaXMuY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKGkgPT0gYWRkLmxlbmd0aCB8fCB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSA8IGFkZFtpXS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSB8fCBmaWx0ZXJUbyA8IHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdKSAmJlxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2h1bmsodGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0sIHRoaXMuY2h1bmtbY3VyLmNodW5rSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGN1ci5uZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiBjdXIudG8gfHwgZmlsdGVyVG8gPCBjdXIuZnJvbSB8fCBmaWx0ZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2goUmFuZ2UuY3JlYXRlKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaElubmVyKHRoaXMubmV4dExheWVyLmlzRW1wdHkgJiYgIXNwaWxsLmxlbmd0aCA/IFJhbmdlU2V0LmVtcHR5XG4gICAgICAgICAgICA6IHRoaXMubmV4dExheWVyLnVwZGF0ZSh7IGFkZDogc3BpbGwsIGZpbHRlciwgZmlsdGVyRnJvbSwgZmlsdGVyVG8gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSBzZXQgdGhyb3VnaCBhIHNldCBvZiBjaGFuZ2VzLCByZXR1cm4gdGhlIG5ldyBzZXQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNodW5rcyA9IFtdLCBjaHVua1BvcyA9IFtdLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGxldCB0b3VjaCA9IGNoYW5nZXMudG91Y2hlc1JhbmdlKHN0YXJ0LCBzdGFydCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodG91Y2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKGNoYW5nZXMubWFwUG9zKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hcHBlZCwgcG9zIH0gPSBjaHVuay5tYXAoc3RhcnQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbWFwcGVkLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dExheWVyLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIGNodW5rcy5sZW5ndGggPT0gMCA/IG5leHQgOiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rcywgbmV4dCB8fCBSYW5nZVNldC5lbXB0eSwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyB0aGF0IHRvdWNoIHRoZSByZWdpb24gYGZyb21gIHRvIGB0b2AsXG4gICAgY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxuICAgIGJlIHJlcG9ydGVkIGluIGFueSBzcGVjaWZpYyBvcmRlci4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGBmYWxzZWAsIGl0ZXJhdGlvbiBzdG9wcy5cbiAgICAqL1xuICAgIGJldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBpZiAodG8gPj0gc3RhcnQgJiYgZnJvbSA8PSBzdGFydCArIGNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNodW5rLmJldHdlZW4oc3RhcnQsIGZyb20gLSBzdGFydCwgdG8gLSBzdGFydCwgZikgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMYXllci5iZXR3ZWVuKGZyb20sIHRvLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gdGhpcyBzZXQsIGluIG9yZGVyLCBpbmNsdWRpbmcgYWxsXG4gICAgcmFuZ2VzIHRoYXQgZW5kIGF0IG9yIGFmdGVyIGBmcm9tYC5cbiAgICAqL1xuICAgIGl0ZXIoZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShbdGhpc10pLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7IHJldHVybiB0aGlzLm5leHRMYXllciA9PSB0aGlzOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gYSBjb2xsZWN0aW9uIG9mIHNldHMsIGluIG9yZGVyLFxuICAgIHN0YXJ0aW5nIGZyb20gYGZyb21gLlxuICAgICovXG4gICAgc3RhdGljIGl0ZXIoc2V0cywgZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShzZXRzKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdHdvIGdyb3VwcyBvZiBzZXRzLCBjYWxsaW5nIG1ldGhvZHMgb24gYGNvbXBhcmF0b3JgXG4gICAgdG8gbm90aWZ5IGl0IG9mIHBvc3NpYmxlIGRpZmZlcmVuY2VzLlxuICAgICovXG4gICAgc3RhdGljIGNvbXBhcmUob2xkU2V0cywgbmV3U2V0cywgXG4gICAgLyoqXG4gICAgVGhpcyBpbmRpY2F0ZXMgaG93IHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlZCBiZXR3ZWVuIHRoZXNlXG4gICAgcmFuZ2VzLCBhbmQgaXMgbmVlZGVkIHRvIHN5bmNocm9uaXplIHRoZSBpdGVyYXRpb24uIGBmcm9tYCBhbmRcbiAgICBgdG9gIGFyZSBjb29yZGluYXRlcyBpbiB0aGUgX25ld18gc3BhY2UsIGFmdGVyIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICB0ZXh0RGlmZiwgY29tcGFyYXRvciwgXG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gaWdub3JlIGFsbCBub24tcG9pbnQgcmFuZ2VzLCBhbmQgcG9pbnRzIGJlbG93XG4gICAgdGhlIGdpdmVuIHNpemUuIFdoZW4gLTEsIGFsbCByYW5nZXMgYXJlIGNvbXBhcmVkLlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICB0ZXh0RGlmZi5pdGVyR2FwcygoZnJvbUEsIGZyb21CLCBsZW5ndGgpID0+IGNvbXBhcmUoc2lkZUEsIGZyb21BLCBzaWRlQiwgZnJvbUIsIGxlbmd0aCwgY29tcGFyYXRvcikpO1xuICAgICAgICBpZiAodGV4dERpZmYuZW1wdHkgJiYgdGV4dERpZmYubGVuZ3RoID09IDApXG4gICAgICAgICAgICBjb21wYXJlKHNpZGVBLCAwLCBzaWRlQiwgMCwgMCwgY29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIGNvbnRlbnRzIG9mIHR3byBncm91cHMgb2YgcmFuZ2Ugc2V0cywgcmV0dXJuaW5nIHRydWVcbiAgICBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBlcShvbGRTZXRzLCBuZXdTZXRzLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi8gLSAxO1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgbmV3U2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG9sZFNldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pLCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvICE9IHNpZGVCLnRvIHx8XG4gICAgICAgICAgICAgICAgIXNhbWVWYWx1ZXMoc2lkZUEuYWN0aXZlLCBzaWRlQi5hY3RpdmUpIHx8XG4gICAgICAgICAgICAgICAgc2lkZUEucG9pbnQgJiYgKCFzaWRlQi5wb2ludCB8fCAhc2lkZUEucG9pbnQuZXEoc2lkZUIucG9pbnQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpZGVBLm5leHQoKTtcbiAgICAgICAgICAgIHNpZGVCLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSBncm91cCBvZiByYW5nZSBzZXRzIGF0IHRoZSBzYW1lIHRpbWUsIG5vdGlmeWluZ1xuICAgIHRoZSBpdGVyYXRvciBhYm91dCB0aGUgcmFuZ2VzIGNvdmVyaW5nIGV2ZXJ5IGdpdmVuIHBpZWNlIG9mXG4gICAgY29udGVudC4gUmV0dXJucyB0aGUgb3BlbiBjb3VudCAoc2VlXG4gICAgW2BTcGFuSXRlcmF0b3Iuc3BhbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3Bhbkl0ZXJhdG9yLnNwYW4pKSBhdCB0aGUgZW5kXG4gICAgb2YgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBzcGFucyhzZXRzLCBmcm9tLCB0bywgaXRlcmF0b3IsIFxuICAgIC8qKlxuICAgIFdoZW4gZ2l2ZW4gYW5kIGdyZWF0ZXIgdGhhbiAtMSwgb25seSBwb2ludHMgb2YgYXQgbGVhc3QgdGhpc1xuICAgIHNpemUgYXJlIHRha2VuIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU3BhbkN1cnNvcihzZXRzLCBudWxsLCBtaW5Qb2ludFNpemUpLmdvdG8oZnJvbSksIHBvcyA9IGZyb207XG4gICAgICAgIGxldCBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5TdGFydDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGN1clRvID0gTWF0aC5taW4oY3Vyc29yLnRvLCB0byk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnBvaW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IGN1cnNvci5hY3RpdmVGb3JQb2ludChjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGxldCBvcGVuQ291bnQgPSBjdXJzb3IucG9pbnRGcm9tIDwgZnJvbSA/IGFjdGl2ZS5sZW5ndGggKyAxIDogTWF0aC5taW4oYWN0aXZlLmxlbmd0aCwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucG9pbnQocG9zLCBjdXJUbywgY3Vyc29yLnBvaW50LCBhY3RpdmUsIG9wZW5Db3VudCwgY3Vyc29yLnBvaW50UmFuayk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IE1hdGgubWluKGN1cnNvci5vcGVuRW5kKGN1clRvKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJUbyA+IHBvcykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3BlblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuRW5kKGN1clRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblJhbmdlcyArIChjdXJzb3IucG9pbnQgJiYgY3Vyc29yLnRvID4gdG8gPyAxIDogMCk7XG4gICAgICAgICAgICBwb3MgPSBjdXJzb3IudG87XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICBkZWZhdWx0LCB0aGlzIGV4cGVjdHMgdGhlIHJhbmdlcyB0byBiZSBfc29ydGVkXyAoYnkgc3RhcnRcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgY2F1c2UgdGhlIG1ldGhvZCB0byBzb3J0IHRoZW0uXG4gICAgKi9cbiAgICBzdGF0aWMgb2YocmFuZ2VzLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXG4qL1xuUmFuZ2VTZXQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFJhbmdlU2V0KFtdLCBbXSwgbnVsbCwgLTEpO1xuZnVuY3Rpb24gbGF6eVNvcnQocmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBmb3IgKGxldCBwcmV2ID0gcmFuZ2VzWzBdLCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbXBSYW5nZShwcmV2LCBjdXIpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblJhbmdlU2V0LmVtcHR5Lm5leHRMYXllciA9IFJhbmdlU2V0LmVtcHR5O1xuLyoqXG5BIHJhbmdlIHNldCBidWlsZGVyIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBoZWxwcyBidWlsZCB1cCBhXG5bcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBkaXJlY3RseSwgd2l0aG91dCBmaXJzdCBhbGxvY2F0aW5nXG5hbiBhcnJheSBvZiBbYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgb2JqZWN0cy5cbiovXG5jbGFzcyBSYW5nZVNldEJ1aWxkZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBidWlsZGVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5sYXN0VG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBudWxsO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuayhuZXdBcnJheXMpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgQ2h1bmsodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnZhbHVlLCB0aGlzLm1heFBvaW50KSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIHRoaXMubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIGlmIChuZXdBcnJheXMpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHJhbmdlLiBSYW5nZXMgc2hvdWxkIGJlIGFkZGVkIGluIHNvcnRlZCAoYnkgYGZyb21gIGFuZFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKSBvcmRlci5cbiAgICAqL1xuICAgIGFkZChmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkpXG4gICAgICAgICAgICAodGhpcy5uZXh0TGF5ZXIgfHwgKHRoaXMubmV4dExheWVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcikpLmFkZChmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZElubmVyKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IGZyb20gLSB0aGlzLmxhc3RUbyB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZTtcbiAgICAgICAgaWYgKGRpZmYgPD0gMCAmJiAoZnJvbSAtIHRoaXMubGFzdEZyb20gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2VzIG11c3QgYmUgYWRkZWQgc29ydGVkIGJ5IGBmcm9tYCBwb3NpdGlvbiBhbmQgYHN0YXJ0U2lkZWBcIik7XG4gICAgICAgIGlmIChkaWZmIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGggPT0gMjUwIC8qIEMuQ2h1bmtTaXplICovKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmZyb20ucHVzaChmcm9tIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy50by5wdXNoKHRvIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5sYXN0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUucG9pbnQpXG4gICAgICAgICAgICB0aGlzLm1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5tYXhQb2ludCwgdG8gLSBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkQ2h1bmsoZnJvbSwgY2h1bmspIHtcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xuICAgICAgICBsZXQgbGFzdCA9IGNodW5rLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubGFzdCA9IGNodW5rLnZhbHVlW2xhc3RdO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gY2h1bmsudG9bbGFzdF0gKyBmcm9tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluaXNoIHRoZSByYW5nZSBzZXQuIFJldHVybnMgdGhlIG5ldyBzZXQuIFRoZSBidWlsZGVyIGNhbid0IGJlXG4gICAgdXNlZCBhbnltb3JlIGFmdGVyIHRoaXMgaGFzIGJlZW4gY2FsbGVkLlxuICAgICovXG4gICAgZmluaXNoKCkgeyByZXR1cm4gdGhpcy5maW5pc2hJbm5lcihSYW5nZVNldC5lbXB0eSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmlzaElubmVyKG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYW5nZVNldC5jcmVhdGUodGhpcy5jaHVua1BvcywgdGhpcy5jaHVua3MsIHRoaXMubmV4dExheWVyID8gdGhpcy5uZXh0TGF5ZXIuZmluaXNoSW5uZXIobmV4dCkgOiBuZXh0LCB0aGlzLnNldE1heFBvaW50KTtcbiAgICAgICAgdGhpcy5mcm9tID0gbnVsbDsgLy8gTWFrZSBzdXJlIGZ1cnRoZXIgYGFkZGAgY2FsbHMgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKSB7XG4gICAgbGV0IGluQSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0LmNodW5rW2ldLm1heFBvaW50IDw9IDApXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XG4gICAgbGV0IHNoYXJlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBrbm93biA9IGluQS5nZXQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgICAgIGlmIChrbm93biAhPSBudWxsICYmICh0ZXh0RGlmZiA/IHRleHREaWZmLm1hcFBvcyhrbm93bikgOiBrbm93bikgPT0gc2V0LmNodW5rUG9zW2ldICYmXG4gICAgICAgICAgICAgICAgISh0ZXh0RGlmZiA9PT0gbnVsbCB8fCB0ZXh0RGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dERpZmYudG91Y2hlc1JhbmdlKGtub3duLCBrbm93biArIHNldC5jaHVua1tpXS5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICBzaGFyZWQuYWRkKHNldC5jaHVua1tpXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gc2hhcmVkO1xufVxuY2xhc3MgTGF5ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheWVyLCBza2lwLCBtaW5Qb2ludCwgcmFuayA9IDApIHtcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ2V0IGVuZFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5lbmRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4ID0gdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnb3RvSW5uZXIocG9zLCBzaWRlLCBmb3J3YXJkKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoISh0aGlzLnNraXAgJiYgdGhpcy5za2lwLmhhcyhuZXh0KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF5ZXIuY2h1bmtFbmQodGhpcy5jaHVua0luZGV4KSA8IHBvcyB8fFxuICAgICAgICAgICAgICAgIG5leHQubWF4UG9pbnQgPCB0aGlzLm1pblBvaW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgZm9yd2FyZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlSW5kZXggPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0uZmluZEluZGV4KHBvcyAtIHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgc2lkZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWZvcndhcmQgfHwgdGhpcy5yYW5nZUluZGV4IDwgcmFuZ2VJbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgocmFuZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2h1bmtQb3MgPSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIGNodW5rID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2h1bmtQb3MgKyBjaHVuay5mcm9tW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gY2h1bmtQb3MgKyBjaHVuay50b1t0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaHVuay52YWx1ZVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleCh0aGlzLnJhbmdlSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5Qb2ludCA8IDAgfHwgdGhpcy52YWx1ZS5wb2ludCAmJiB0aGlzLnRvIC0gdGhpcy5mcm9tID49IHRoaXMubWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJhbmdlSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCAmJiB0aGlzLnNraXAuaGFzKHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRDaHVuaygpIHtcbiAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20gLSBvdGhlci5mcm9tIHx8IHRoaXMuc3RhcnRTaWRlIC0gb3RoZXIuc3RhcnRTaWRlIHx8IHRoaXMucmFuayAtIG90aGVyLnJhbmsgfHxcbiAgICAgICAgICAgIHRoaXMudG8gLSBvdGhlci50byB8fCB0aGlzLmVuZFNpZGUgLSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbn1cbmNsYXNzIEhlYXBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYXApIHtcbiAgICAgICAgdGhpcy5oZWFwID0gaGVhcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oc2V0cywgc2tpcCA9IG51bGwsIG1pblBvaW50ID0gLTEpIHtcbiAgICAgICAgbGV0IGhlYXAgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjdXIgPSBzZXRzW2ldOyAhY3VyLmlzRW1wdHk7IGN1ciA9IGN1ci5uZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLm1heFBvaW50ID49IG1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBoZWFwLnB1c2gobmV3IExheWVyQ3Vyc29yKGN1ciwgc2tpcCwgbWluUG9pbnQsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhcC5sZW5ndGggPT0gMSA/IGhlYXBbMF0gOiBuZXcgSGVhcEN1cnNvcihoZWFwKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLnZhbHVlLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMuaGVhcFswXTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRvcC5mcm9tO1xuICAgICAgICAgICAgdGhpcy50byA9IHRvcC50bztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0b3AudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSB0b3AucmFuaztcbiAgICAgICAgICAgIGlmICh0b3AudmFsdWUpXG4gICAgICAgICAgICAgICAgdG9wLm5leHQoKTtcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhlYXBCdWJibGUoaGVhcCwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBoZWFwW2luZGV4XTs7KSB7XG4gICAgICAgIGxldCBjaGlsZEluZGV4ID0gKGluZGV4IDw8IDEpICsgMTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggPj0gaGVhcC5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGNoaWxkID0gaGVhcFtjaGlsZEluZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkSW5kZXggKyAxIDwgaGVhcC5sZW5ndGggJiYgY2hpbGQuY29tcGFyZShoZWFwW2NoaWxkSW5kZXggKyAxXSkgPj0gMCkge1xuICAgICAgICAgICAgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLmNvbXBhcmUoY2hpbGQpIDwgMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFwW2NoaWxkSW5kZXhdID0gY3VyO1xuICAgICAgICBoZWFwW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICBpbmRleCA9IGNoaWxkSW5kZXg7XG4gICAgfVxufVxuY2xhc3MgU3BhbkN1cnNvciB7XG4gICAgY29uc3RydWN0b3Ioc2V0cywgc2tpcCwgbWluUG9pbnQpIHtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVRvID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlUmFuayA9IFtdO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICAvLyBBIGN1cnJlbnRseSBhY3RpdmUgcG9pbnQgcmFuZ2UsIGlmIGFueVxuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludEZyb20gPSAwO1xuICAgICAgICB0aGlzLnBvaW50UmFuayA9IDA7XG4gICAgICAgIHRoaXMudG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gMDtcbiAgICAgICAgLy8gVGhlIGFtb3VudCBvZiBvcGVuIGFjdGl2ZSByYW5nZXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgLy8gTm90IGluY2x1ZGluZyBwb2ludHMuXG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gSGVhcEN1cnNvci5mcm9tKHNldHMsIHNraXAsIG1pblBvaW50KTtcbiAgICB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmN1cnNvci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoID0gdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIHRoaXMudG8gPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWluQWN0aXZlID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bdGhpcy5taW5BY3RpdmVdIC0gcG9zIHx8IHRoaXMuYWN0aXZlW3RoaXMubWluQWN0aXZlXS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUodGhpcy5taW5BY3RpdmUpO1xuICAgICAgICB0aGlzLmN1cnNvci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZShpbmRleCkge1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmUsIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlVG8sIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlUmFuaywgaW5kZXgpO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIGFkZEFjdGl2ZSh0cmFja09wZW4pIHtcbiAgICAgICAgbGV0IGkgPSAwLCB7IHZhbHVlLCB0bywgcmFuayB9ID0gdGhpcy5jdXJzb3I7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCAmJiB0aGlzLmFjdGl2ZVJhbmtbaV0gPD0gcmFuaylcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlLCBpLCB2YWx1ZSk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVRvLCBpLCB0byk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVJhbmssIGksIHJhbmspO1xuICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgaW5zZXJ0KHRyYWNrT3BlbiwgaSwgdGhpcy5jdXJzb3IuZnJvbSk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgY2FsbGluZyB0aGlzLCBpZiBgdGhpcy5wb2ludGAgIT0gbnVsbCwgdGhlIG5leHQgcmFuZ2UgaXMgYVxuICAgIC8vIHBvaW50LiBPdGhlcndpc2UsIGl0J3MgYSByZWd1bGFyIHJhbmdlLCBjb3ZlcmVkIGJ5IGB0aGlzLmFjdGl2ZWAuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvLCB3YXNQb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhY2tPcGVuID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMubWluQWN0aXZlO1xuICAgICAgICAgICAgaWYgKGEgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1thXSAtIHRoaXMuY3Vyc29yLmZyb20gfHwgdGhpcy5hY3RpdmVbYV0uZW5kU2lkZSAtIHRoaXMuY3Vyc29yLnN0YXJ0U2lkZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9bYV0gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmFjdGl2ZVRvW2FdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUoYSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHRyYWNrT3BlbiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJzb3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5lbmRTaWRlID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yLmZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWwgPSB0aGlzLmN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRWYWwucG9pbnQpIHsgLy8gT3BlbmluZyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZlKHRyYWNrT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzUG9pbnQgJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBub24tZW1wdHkgcG9pbnRzIHRoYXQgZW5kIHByZWNpc2VseSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ID0gbmV4dFZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRyYWNrT3Blbi5sZW5ndGggLSAxOyBpID49IDAgJiYgdHJhY2tPcGVuW2ldIDwgZnJvbTsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlRm9yUG9pbnQodG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSYW5rW2ldIDwgdGhpcy5wb2ludFJhbmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1tpXSA+IHRvIHx8IHRoaXMuYWN0aXZlVG9baV0gPT0gdG8gJiYgdGhpcy5hY3RpdmVbaV0uZW5kU2lkZSA+PSB0aGlzLnBvaW50LmVuZFNpZGUpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBvcGVuRW5kKHRvKSB7XG4gICAgICAgIGxldCBvcGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRoaXMuYWN0aXZlVG9baV0gPiB0bzsgaS0tKVxuICAgICAgICAgICAgb3BlbisrO1xuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIHN0YXJ0QSwgYiwgc3RhcnRCLCBsZW5ndGgsIGNvbXBhcmF0b3IpIHtcbiAgICBhLmdvdG8oc3RhcnRBKTtcbiAgICBiLmdvdG8oc3RhcnRCKTtcbiAgICBsZXQgZW5kQiA9IHN0YXJ0QiArIGxlbmd0aDtcbiAgICBsZXQgcG9zID0gc3RhcnRCLCBkUG9zID0gc3RhcnRCIC0gc3RhcnRBO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGRpZmYgPSAoYS50byArIGRQb3MpIC0gYi50byB8fCBhLmVuZFNpZGUgLSBiLmVuZFNpZGU7XG4gICAgICAgIGxldCBlbmQgPSBkaWZmIDwgMCA/IGEudG8gKyBkUG9zIDogYi50bywgY2xpcEVuZCA9IE1hdGgubWluKGVuZCwgZW5kQik7XG4gICAgICAgIGlmIChhLnBvaW50IHx8IGIucG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghKGEucG9pbnQgJiYgYi5wb2ludCAmJiAoYS5wb2ludCA9PSBiLnBvaW50IHx8IGEucG9pbnQuZXEoYi5wb2ludCkpICYmXG4gICAgICAgICAgICAgICAgc2FtZVZhbHVlcyhhLmFjdGl2ZUZvclBvaW50KGEudG8gKyBkUG9zKSwgYi5hY3RpdmVGb3JQb2ludChiLnRvKSkpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVBvaW50KHBvcywgY2xpcEVuZCwgYS5wb2ludCwgYi5wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xpcEVuZCA+IHBvcyAmJiAhc2FtZVZhbHVlcyhhLmFjdGl2ZSwgYi5hY3RpdmUpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVJhbmdlKHBvcywgY2xpcEVuZCwgYS5hY3RpdmUsIGIuYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gZW5kQilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIGlmIChkaWZmIDw9IDApXG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgaWYgKGRpZmYgPj0gMClcbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVWYWx1ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGFbaV0gIT0gYltpXSAmJiAhYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXgsIGUgPSBhcnJheS5sZW5ndGggLSAxOyBpIDwgZTsgaSsrKVxuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgKyAxXTtcbiAgICBhcnJheS5wb3AoKTtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGktLSlcbiAgICAgICAgYXJyYXlbaSArIDFdID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBmaW5kTWluSW5kZXgodmFsdWUsIGFycmF5KSB7XG4gICAgbGV0IGZvdW5kID0gLTEsIGZvdW5kUG9zID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoKGFycmF5W2ldIC0gZm91bmRQb3MgfHwgdmFsdWVbaV0uZW5kU2lkZSAtIHZhbHVlW2ZvdW5kXS5lbmRTaWRlKSA8IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gaTtcbiAgICAgICAgICAgIGZvdW5kUG9zID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbi8qKlxuQ291bnQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGludG8gdGhlIHN0cmluZyxcbnRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LlxuKi9cbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgdGFiU2l6ZSwgdG8gPSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG87KSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KSB7XG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGNvbHVtbiBwb3NpdGlvbiBpbiBhXG5zdHJpbmcsIHRha2luZyBleHRlbmRpbmcgY2hhcmFjdGVycyBhbmQgdGFiIHNpemUgaW50byBhY2NvdW50LiBCeVxuZGVmYXVsdCwgdGhlIHN0cmluZyBsZW5ndGggaXMgcmV0dXJuZWQgd2hlbiBpdCBpcyB0b28gc2hvcnQgdG9cbnJlYWNoIHRoZSBjb2x1bW4uIFBhc3MgYHN0cmljdGAgdHJ1ZSB0byBtYWtlIGl0IHJldHVybiAtMSBpbiB0aGF0XG5zaXR1YXRpb24uXG4qL1xuZnVuY3Rpb24gZmluZENvbHVtbihzdHJpbmcsIGNvbCwgdGFiU2l6ZSwgc3RyaWN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSAwOzspIHtcbiAgICAgICAgaWYgKG4gPj0gY29sKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIGlmIChpID09IHN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbiArPSBzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5ID8gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSkgOiAxO1xuICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWN0ID09PSB0cnVlID8gLTEgOiBzdHJpbmcubGVuZ3RoO1xufVxuXG5leHBvcnQgeyBBbm5vdGF0aW9uLCBBbm5vdGF0aW9uVHlwZSwgQ2hhbmdlRGVzYywgQ2hhbmdlU2V0LCBDaGFyQ2F0ZWdvcnksIENvbXBhcnRtZW50LCBFZGl0b3JTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBGYWNldCwgTGluZSwgTWFwTW9kZSwgUHJlYywgUmFuZ2UsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFJhbmdlVmFsdWUsIFNlbGVjdGlvblJhbmdlLCBTdGF0ZUVmZmVjdCwgU3RhdGVFZmZlY3RUeXBlLCBTdGF0ZUZpZWxkLCBUZXh0LCBUcmFuc2FjdGlvbiwgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIGNvdW50Q29sdW1uLCBmaW5kQ2x1c3RlckJyZWFrLCBmaW5kQ29sdW1uLCBmcm9tQ29kZVBvaW50IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BidiSpan\": () => (/* binding */ BidiSpan),\n/* harmony export */   \"BlockInfo\": () => (/* binding */ BlockInfo),\n/* harmony export */   \"BlockType\": () => (/* binding */ BlockType),\n/* harmony export */   \"Decoration\": () => (/* binding */ Decoration),\n/* harmony export */   \"Direction\": () => (/* binding */ Direction),\n/* harmony export */   \"EditorView\": () => (/* binding */ EditorView),\n/* harmony export */   \"GutterMarker\": () => (/* binding */ GutterMarker),\n/* harmony export */   \"MatchDecorator\": () => (/* binding */ MatchDecorator),\n/* harmony export */   \"RectangleMarker\": () => (/* binding */ RectangleMarker),\n/* harmony export */   \"ViewPlugin\": () => (/* binding */ ViewPlugin),\n/* harmony export */   \"ViewUpdate\": () => (/* binding */ ViewUpdate),\n/* harmony export */   \"WidgetType\": () => (/* binding */ WidgetType),\n/* harmony export */   \"__test\": () => (/* binding */ __test),\n/* harmony export */   \"closeHoverTooltips\": () => (/* binding */ closeHoverTooltips),\n/* harmony export */   \"crosshairCursor\": () => (/* binding */ crosshairCursor),\n/* harmony export */   \"drawSelection\": () => (/* binding */ drawSelection),\n/* harmony export */   \"dropCursor\": () => (/* binding */ dropCursor),\n/* harmony export */   \"getPanel\": () => (/* binding */ getPanel),\n/* harmony export */   \"getTooltip\": () => (/* binding */ getTooltip),\n/* harmony export */   \"gutter\": () => (/* binding */ gutter),\n/* harmony export */   \"gutterLineClass\": () => (/* binding */ gutterLineClass),\n/* harmony export */   \"gutters\": () => (/* binding */ gutters),\n/* harmony export */   \"hasHoverTooltips\": () => (/* binding */ hasHoverTooltips),\n/* harmony export */   \"highlightActiveLine\": () => (/* binding */ highlightActiveLine),\n/* harmony export */   \"highlightActiveLineGutter\": () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   \"highlightSpecialChars\": () => (/* binding */ highlightSpecialChars),\n/* harmony export */   \"highlightTrailingWhitespace\": () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   \"highlightWhitespace\": () => (/* binding */ highlightWhitespace),\n/* harmony export */   \"hoverTooltip\": () => (/* binding */ hoverTooltip),\n/* harmony export */   \"keymap\": () => (/* binding */ keymap),\n/* harmony export */   \"layer\": () => (/* binding */ layer),\n/* harmony export */   \"lineNumberMarkers\": () => (/* binding */ lineNumberMarkers),\n/* harmony export */   \"lineNumbers\": () => (/* binding */ lineNumbers),\n/* harmony export */   \"logException\": () => (/* binding */ logException),\n/* harmony export */   \"panels\": () => (/* binding */ panels),\n/* harmony export */   \"placeholder\": () => (/* binding */ placeholder),\n/* harmony export */   \"rectangularSelection\": () => (/* binding */ rectangularSelection),\n/* harmony export */   \"repositionTooltips\": () => (/* binding */ repositionTooltips),\n/* harmony export */   \"runScopeHandlers\": () => (/* binding */ runScopeHandlers),\n/* harmony export */   \"scrollPastEnd\": () => (/* binding */ scrollPastEnd),\n/* harmony export */   \"showPanel\": () => (/* binding */ showPanel),\n/* harmony export */   \"showTooltip\": () => (/* binding */ showTooltip),\n/* harmony export */   \"tooltips\": () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.es.js\");\n\n\n\nfunction getSelection(root) {\n  let target;\n  // Browsers differ on whether shadow roots have a getSelection\n  // method. If it exists, use that, otherwise, call it on the\n  // document.\n  if (root.nodeType == 11) {\n    // Shadow root\n    target = root.getSelection ? root : root.ownerDocument;\n  } else {\n    target = root;\n  }\n  return target.getSelection();\n}\nfunction contains(dom, node) {\n  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction deepActiveElement(doc) {\n  let elt = doc.activeElement;\n  while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;\n  return elt;\n}\nfunction hasSelection(dom, selection) {\n  if (!selection.anchorNode) return false;\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return contains(dom, selection.anchorNode);\n  } catch (_) {\n    return false;\n  }\n}\nfunction clientRectsFor(dom) {\n  if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();else if (dom.nodeType == 1) return dom.getClientRects();else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node) return index;\n  }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) return true;\n    if (off == (dir < 0 ? 0 : maxOffset(node))) {\n      if (node.nodeName == \"DIV\") return false;\n      let parent = node.parentNode;\n      if (!parent || parent.nodeType != 1) return false;\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n      off = dir < 0 ? maxOffset(node) : 0;\n    } else {\n      return false;\n    }\n  }\n}\nfunction maxOffset(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nconst Rect0 = {\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\nfunction flattenRect(rect, left) {\n  let x = left ? rect.left : rect.right;\n  return {\n    left: x,\n    right: x,\n    top: rect.top,\n    bottom: rect.bottom\n  };\n}\nfunction windowRect(win) {\n  return {\n    left: 0,\n    right: win.innerWidth,\n    top: 0,\n    bottom: win.innerHeight\n  };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n  let doc = dom.ownerDocument,\n    win = doc.defaultView || window;\n  for (let cur = dom; cur;) {\n    if (cur.nodeType == 1) {\n      // Element\n      let bounding,\n        top = cur == doc.body;\n      if (top) {\n        bounding = windowRect(win);\n      } else {\n        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n          cur = cur.assignedSlot || cur.parentNode;\n          continue;\n        }\n        let rect = cur.getBoundingClientRect();\n        // Make sure scrollbar width isn't included in the rectangle\n        bounding = {\n          left: rect.left,\n          right: rect.left + cur.clientWidth,\n          top: rect.top,\n          bottom: rect.top + cur.clientHeight\n        };\n      }\n      let moveX = 0,\n        moveY = 0;\n      if (y == \"nearest\") {\n        if (rect.top < bounding.top) {\n          moveY = -(bounding.top - rect.top + yMargin);\n          if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;\n        } else if (rect.bottom > bounding.bottom) {\n          moveY = rect.bottom - bounding.bottom + yMargin;\n          if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);\n        }\n      } else {\n        let rectHeight = rect.bottom - rect.top,\n          boundingHeight = bounding.bottom - bounding.top;\n        let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n        moveY = targetTop - bounding.top;\n      }\n      if (x == \"nearest\") {\n        if (rect.left < bounding.left) {\n          moveX = -(bounding.left - rect.left + xMargin);\n          if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;\n        } else if (rect.right > bounding.right) {\n          moveX = rect.right - bounding.right + xMargin;\n          if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);\n        }\n      } else {\n        let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n        moveX = targetLeft - bounding.left;\n      }\n      if (moveX || moveY) {\n        if (top) {\n          win.scrollBy(moveX, moveY);\n        } else {\n          let movedX = 0,\n            movedY = 0;\n          if (moveY) {\n            let start = cur.scrollTop;\n            cur.scrollTop += moveY;\n            movedY = cur.scrollTop - start;\n          }\n          if (moveX) {\n            let start = cur.scrollLeft;\n            cur.scrollLeft += moveX;\n            movedX = cur.scrollLeft - start;\n          }\n          rect = {\n            left: rect.left - movedX,\n            top: rect.top - movedY,\n            right: rect.right - movedX,\n            bottom: rect.bottom - movedY\n          };\n          if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n          if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n        }\n      }\n      if (top) break;\n      cur = cur.assignedSlot || cur.parentNode;\n    } else if (cur.nodeType == 11) {\n      // A shadow root\n      cur = cur.host;\n    } else {\n      break;\n    }\n  }\n}\nfunction scrollableParent(dom) {\n  let doc = dom.ownerDocument;\n  for (let cur = dom.parentNode; cur;) {\n    if (cur == doc.body) {\n      break;\n    } else if (cur.nodeType == 1) {\n      if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth) return cur;\n      cur = cur.assignedSlot || cur.parentNode;\n    } else if (cur.nodeType == 11) {\n      cur = cur.host;\n    } else {\n      break;\n    }\n  }\n  return null;\n}\nclass DOMSelectionState {\n  constructor() {\n    this.anchorNode = null;\n    this.anchorOffset = 0;\n    this.focusNode = null;\n    this.focusOffset = 0;\n  }\n  eq(domSel) {\n    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n  }\n  setRange(range) {\n    this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);\n  }\n  set(anchorNode, anchorOffset, focusNode, focusOffset) {\n    this.anchorNode = anchorNode;\n    this.anchorOffset = anchorOffset;\n    this.focusNode = focusNode;\n    this.focusOffset = focusOffset;\n  }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive(); // in IE\n  if (preventScrollSupported) return dom.focus(preventScrollSupported);\n  let stack = [];\n  for (let cur = dom; cur; cur = cur.parentNode) {\n    stack.push(cur, cur.scrollTop, cur.scrollLeft);\n    if (cur == cur.ownerDocument) break;\n  }\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {\n        preventScroll: true\n      };\n      return true;\n    }\n  } : undefined);\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    for (let i = 0; i < stack.length;) {\n      let elt = stack[i++],\n        top = stack[i++],\n        left = stack[i++];\n      if (elt.scrollTop != top) elt.scrollTop = top;\n      if (elt.scrollLeft != left) elt.scrollLeft = left;\n    }\n  }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n  let range = scratchRange || (scratchRange = document.createRange());\n  range.setEnd(node, to);\n  range.setStart(node, from);\n  return range;\n}\nfunction dispatchKey(elt, name, code) {\n  let options = {\n    key: name,\n    code: name,\n    keyCode: code,\n    which: code,\n    cancelable: true\n  };\n  let down = new KeyboardEvent(\"keydown\", options);\n  down.synthetic = true;\n  elt.dispatchEvent(down);\n  let up = new KeyboardEvent(\"keyup\", options);\n  up.synthetic = true;\n  elt.dispatchEvent(up);\n  return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n  while (node) {\n    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n    node = node.assignedSlot || node.parentNode;\n  }\n  return null;\n}\nfunction clearAttributes(node) {\n  while (node.attributes.length) node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n  let node = selection.focusNode,\n    offset = selection.focusOffset;\n  if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n  for (;;) {\n    if (offset) {\n      if (node.nodeType != 1) return false;\n      let prev = node.childNodes[offset - 1];\n      if (prev.contentEditable == \"false\") offset--;else {\n        node = prev;\n        offset = maxOffset(node);\n      }\n    } else if (node == doc) {\n      return true;\n    } else {\n      offset = domIndex(node);\n      node = node.parentNode;\n    }\n  }\n}\nclass DOMPos {\n  constructor(node, offset, precise = true) {\n    this.node = node;\n    this.offset = offset;\n    this.precise = precise;\n  }\n  static before(dom, precise) {\n    return new DOMPos(dom.parentNode, domIndex(dom), precise);\n  }\n  static after(dom, precise) {\n    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n  }\n}\nconst noChildren = [];\nclass ContentView {\n  constructor() {\n    this.parent = null;\n    this.dom = null;\n    this.dirty = 2 /* Dirty.Node */;\n  }\n\n  get overrideDOMText() {\n    return null;\n  }\n  get posAtStart() {\n    return this.parent ? this.parent.posBefore(this) : 0;\n  }\n  get posAtEnd() {\n    return this.posAtStart + this.length;\n  }\n  posBefore(view) {\n    let pos = this.posAtStart;\n    for (let child of this.children) {\n      if (child == view) return pos;\n      pos += child.length + child.breakAfter;\n    }\n    throw new RangeError(\"Invalid child in posBefore\");\n  }\n  posAfter(view) {\n    return this.posBefore(view) + view.length;\n  }\n  // Will return a rectangle directly before (when side < 0), after\n  // (side > 0) or directly on (when the browser supports it) the\n  // given position.\n  coordsAt(_pos, _side) {\n    return null;\n  }\n  sync(view, track) {\n    if (this.dirty & 2 /* Dirty.Node */) {\n      let parent = this.dom;\n      let prev = null,\n        next;\n      for (let child of this.children) {\n        if (child.dirty) {\n          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n            let contentView = ContentView.get(next);\n            if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);\n          }\n          child.sync(view, track);\n          child.dirty = 0 /* Dirty.Not */;\n        }\n\n        next = prev ? prev.nextSibling : parent.firstChild;\n        if (track && !track.written && track.node == parent && next != child.dom) track.written = true;\n        if (child.dom.parentNode == parent) {\n          while (next && next != child.dom) next = rm$1(next);\n        } else {\n          parent.insertBefore(child.dom, next);\n        }\n        prev = child.dom;\n      }\n      next = prev ? prev.nextSibling : parent.firstChild;\n      if (next && track && track.node == parent) track.written = true;\n      while (next) next = rm$1(next);\n    } else if (this.dirty & 1 /* Dirty.Child */) {\n      for (let child of this.children) if (child.dirty) {\n        child.sync(view, track);\n        child.dirty = 0 /* Dirty.Not */;\n      }\n    }\n  }\n\n  reuseDOM(_dom) {}\n  localPosFromDOM(node, offset) {\n    let after;\n    if (node == this.dom) {\n      after = this.dom.childNodes[offset];\n    } else {\n      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n      for (;;) {\n        let parent = node.parentNode;\n        if (parent == this.dom) break;\n        if (bias == 0 && parent.firstChild != parent.lastChild) {\n          if (node == parent.firstChild) bias = -1;else bias = 1;\n        }\n        node = parent;\n      }\n      if (bias < 0) after = node;else after = node.nextSibling;\n    }\n    if (after == this.dom.firstChild) return 0;\n    while (after && !ContentView.get(after)) after = after.nextSibling;\n    if (!after) return this.length;\n    for (let i = 0, pos = 0;; i++) {\n      let child = this.children[i];\n      if (child.dom == after) return pos;\n      pos += child.length + child.breakAfter;\n    }\n  }\n  domBoundsAround(from, to, offset = 0) {\n    let fromI = -1,\n      fromStart = -1,\n      toI = -1,\n      toEnd = -1;\n    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n      if (end >= from && fromI == -1) {\n        fromI = i;\n        fromStart = pos;\n      }\n      if (pos > to && child.dom.parentNode == this.dom) {\n        toI = i;\n        toEnd = prevEnd;\n        break;\n      }\n      prevEnd = end;\n      pos = end + child.breakAfter;\n    }\n    return {\n      from: fromStart,\n      to: toEnd < 0 ? offset + this.length : toEnd,\n      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n    };\n  }\n  markDirty(andParent = false) {\n    this.dirty |= 2 /* Dirty.Node */;\n    this.markParentsDirty(andParent);\n  }\n  markParentsDirty(childList) {\n    for (let parent = this.parent; parent; parent = parent.parent) {\n      if (childList) parent.dirty |= 2 /* Dirty.Node */;\n      if (parent.dirty & 1 /* Dirty.Child */) return;\n      parent.dirty |= 1 /* Dirty.Child */;\n      childList = false;\n    }\n  }\n  setParent(parent) {\n    if (this.parent != parent) {\n      this.parent = parent;\n      if (this.dirty) this.markParentsDirty(true);\n    }\n  }\n  setDOM(dom) {\n    if (this.dom) this.dom.cmView = null;\n    this.dom = dom;\n    dom.cmView = this;\n  }\n  get rootView() {\n    for (let v = this;;) {\n      let parent = v.parent;\n      if (!parent) return v;\n      v = parent;\n    }\n  }\n  replaceChildren(from, to, children = noChildren) {\n    this.markDirty();\n    for (let i = from; i < to; i++) {\n      let child = this.children[i];\n      if (child.parent == this) child.destroy();\n    }\n    this.children.splice(from, to - from, ...children);\n    for (let i = 0; i < children.length; i++) children[i].setParent(this);\n  }\n  ignoreMutation(_rec) {\n    return false;\n  }\n  ignoreEvent(_event) {\n    return false;\n  }\n  childCursor(pos = this.length) {\n    return new ChildCursor(this.children, pos, this.children.length);\n  }\n  childPos(pos, bias = 1) {\n    return this.childCursor().findPos(pos, bias);\n  }\n  toString() {\n    let name = this.constructor.name.replace(\"View\", \"\");\n    return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n  }\n  static get(node) {\n    return node.cmView;\n  }\n  get isEditable() {\n    return true;\n  }\n  merge(from, to, source, hasStart, openStart, openEnd) {\n    return false;\n  }\n  become(other) {\n    return false;\n  }\n  canReuseDOM(other) {\n    return other.constructor == this.constructor;\n  }\n  // When this is a zero-length view with a side, this should return a\n  // number <= 0 to indicate it is before its position, or a\n  // number > 0 when after its position.\n  getSide() {\n    return 0;\n  }\n  destroy() {\n    this.parent = null;\n  }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n  let next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\nclass ChildCursor {\n  constructor(children, pos, i) {\n    this.children = children;\n    this.pos = pos;\n    this.i = i;\n    this.off = 0;\n  }\n  findPos(pos, bias = 1) {\n    for (;;) {\n      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n        this.off = pos - this.pos;\n        return this;\n      }\n      let next = this.children[--this.i];\n      this.pos -= next.length + next.breakAfter;\n    }\n  }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n  let {\n    children\n  } = parent;\n  let before = children.length ? children[fromI] : null;\n  let last = insert.length ? insert[insert.length - 1] : null;\n  let breakAtEnd = last ? last.breakAfter : breakAtStart;\n  // Change within a single child\n  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n  if (toI < children.length) {\n    let after = children[toI];\n    // Make sure the end of the child after the update is preserved in `after`\n    if (after && toOff < after.length) {\n      // If we're splitting a child, separate part of it to avoid that\n      // being mangled when updating the child before the update.\n      if (fromI == toI) {\n        after = after.split(toOff);\n        toOff = 0;\n      }\n      // If the element after the replacement should be merged with\n      // the last replacing element, update `content`\n      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n        insert[insert.length - 1] = after;\n      } else {\n        // Remove the start of the after element, if necessary, and\n        // add it to `content`.\n        if (toOff) after.merge(0, toOff, null, false, 0, openEnd);\n        insert.push(after);\n      }\n    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n      // The element at `toI` is entirely covered by this range.\n      // Preserve its line break, if any.\n      if (last) last.breakAfter = 1;else breakAtStart = 1;\n    }\n    // Since we've handled the next element from the current elements\n    // now, make sure `toI` points after that.\n    toI++;\n  }\n  if (before) {\n    before.breakAfter = breakAtStart;\n    if (fromOff > 0) {\n      if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n        before.breakAfter = insert.shift().breakAfter;\n      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n        before.merge(fromOff, before.length, null, false, openStart, 0);\n      }\n      fromI++;\n    }\n  }\n  // Try to merge widgets on the boundaries of the replacement\n  while (fromI < toI && insert.length) {\n    if (children[toI - 1].become(insert[insert.length - 1])) {\n      toI--;\n      insert.pop();\n      openEnd = insert.length ? 0 : openStart;\n    } else if (children[fromI].become(insert[0])) {\n      fromI++;\n      insert.shift();\n      openStart = insert.length ? 0 : openEnd;\n    } else {\n      break;\n    }\n  }\n  if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n  if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n  let cur = parent.childCursor();\n  let {\n    i: toI,\n    off: toOff\n  } = cur.findPos(to, 1);\n  let {\n    i: fromI,\n    off: fromOff\n  } = cur.findPos(from, -1);\n  let dLen = from - to;\n  for (let view of insert) dLen += view.length;\n  parent.length += dLen;\n  replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n  userAgent: \"\",\n  vendor: \"\",\n  platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n  documentElement: {\n    style: {}\n  }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = (\"webkitFontSmoothing\" in doc.documentElement.style);\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && ( /*@__PURE__*/ /Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n  mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n  windows: /*@__PURE__*/ /Win/.test(nav.platform),\n  linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n  ie,\n  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n  gecko,\n  gecko_version: gecko ? +( /*@__PURE__*/ /Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n  chrome: !!chrome,\n  chrome_version: chrome ? +chrome[1] : 0,\n  ios,\n  android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n  webkit,\n  safari,\n  webkit_version: webkit ? +( /*@__PURE__*/ /\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n  tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n  constructor(text) {\n    super();\n    this.text = text;\n  }\n  get length() {\n    return this.text.length;\n  }\n  createDOM(textDOM) {\n    this.setDOM(textDOM || document.createTextNode(this.text));\n  }\n  sync(view, track) {\n    if (!this.dom) this.createDOM();\n    if (this.dom.nodeValue != this.text) {\n      if (track && track.node == this.dom) track.written = true;\n      this.dom.nodeValue = this.text;\n    }\n  }\n  reuseDOM(dom) {\n    if (dom.nodeType == 3) this.createDOM(dom);\n  }\n  merge(from, to, source) {\n    if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen)) return false;\n    this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n    this.markDirty();\n    return true;\n  }\n  split(from) {\n    let result = new TextView(this.text.slice(from));\n    this.text = this.text.slice(0, from);\n    this.markDirty();\n    return result;\n  }\n  localPosFromDOM(node, offset) {\n    return node == this.dom ? offset : offset ? this.text.length : 0;\n  }\n  domAtPos(pos) {\n    return new DOMPos(this.dom, pos);\n  }\n  domBoundsAround(_from, _to, offset) {\n    return {\n      from: offset,\n      to: offset + this.length,\n      startDOM: this.dom,\n      endDOM: this.dom.nextSibling\n    };\n  }\n  coordsAt(pos, side) {\n    return textCoords(this.dom, pos, side);\n  }\n}\nclass MarkView extends ContentView {\n  constructor(mark, children = [], length = 0) {\n    super();\n    this.mark = mark;\n    this.children = children;\n    this.length = length;\n    for (let ch of children) ch.setParent(this);\n  }\n  setAttrs(dom) {\n    clearAttributes(dom);\n    if (this.mark.class) dom.className = this.mark.class;\n    if (this.mark.attrs) for (let name in this.mark.attrs) dom.setAttribute(name, this.mark.attrs[name]);\n    return dom;\n  }\n  reuseDOM(node) {\n    if (node.nodeName == this.mark.tagName.toUpperCase()) {\n      this.setDOM(node);\n      this.dirty |= 4 /* Dirty.Attrs */ | 2 /* Dirty.Node */;\n    }\n  }\n\n  sync(view, track) {\n    if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));else if (this.dirty & 4 /* Dirty.Attrs */) this.setAttrs(this.dom);\n    super.sync(view, track);\n  }\n  merge(from, to, source, _hasStart, openStart, openEnd) {\n    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);\n    this.markDirty();\n    return true;\n  }\n  split(from) {\n    let result = [],\n      off = 0,\n      detachFrom = -1,\n      i = 0;\n    for (let elt of this.children) {\n      let end = off + elt.length;\n      if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n      if (detachFrom < 0 && off >= from) detachFrom = i;\n      off = end;\n      i++;\n    }\n    let length = this.length - from;\n    this.length = from;\n    if (detachFrom > -1) {\n      this.children.length = detachFrom;\n      this.markDirty();\n    }\n    return new MarkView(this.mark, result, length);\n  }\n  domAtPos(pos) {\n    return inlineDOMAtPos(this, pos);\n  }\n  coordsAt(pos, side) {\n    return coordsInChildren(this, pos, side);\n  }\n}\nfunction textCoords(text, pos, side) {\n  let length = text.nodeValue.length;\n  if (pos > length) pos = length;\n  let from = pos,\n    to = pos,\n    flatten = 0;\n  if (pos == 0 && side < 0 || pos == length && side >= 0) {\n    if (!(browser.chrome || browser.gecko)) {\n      // These browsers reliably return valid rectangles for empty ranges\n      if (pos) {\n        from--;\n        flatten = 1;\n      } // FIXME this is wrong in RTL text\n      else if (to < length) {\n        to++;\n        flatten = -1;\n      }\n    }\n  } else {\n    if (side < 0) from--;else if (to < length) to++;\n  }\n  let rects = textRange(text, from, to).getClientRects();\n  if (!rects.length) return Rect0;\n  let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n  if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, r => r.width) || rect;\n  return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n  constructor(widget, length, side) {\n    super();\n    this.widget = widget;\n    this.length = length;\n    this.side = side;\n    this.prevWidget = null;\n  }\n  static create(widget, length, side) {\n    return new (widget.customView || WidgetView)(widget, length, side);\n  }\n  split(from) {\n    let result = WidgetView.create(this.widget, this.length - from, this.side);\n    this.length -= from;\n    return result;\n  }\n  sync(view) {\n    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n      this.prevWidget = null;\n      this.setDOM(this.widget.toDOM(view));\n      this.dom.contentEditable = \"false\";\n    }\n  }\n  getSide() {\n    return this.side;\n  }\n  merge(from, to, source, hasStart, openStart, openEnd) {\n    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    this.length = from + (source ? source.length : 0) + (this.length - to);\n    return true;\n  }\n  become(other) {\n    if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n      if (this.widget.constructor == other.widget.constructor) {\n        if (!this.widget.eq(other.widget)) this.markDirty(true);\n        if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n        this.widget = other.widget;\n        return true;\n      }\n    }\n    return false;\n  }\n  ignoreMutation() {\n    return true;\n  }\n  ignoreEvent(event) {\n    return this.widget.ignoreEvent(event);\n  }\n  get overrideDOMText() {\n    if (this.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    let top = this;\n    while (top.parent) top = top.parent;\n    let {\n        view\n      } = top,\n      text = view && view.state.doc,\n      start = this.posAtStart;\n    return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n  }\n  domAtPos(pos) {\n    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n  }\n  domBoundsAround() {\n    return null;\n  }\n  coordsAt(pos, side) {\n    let rects = this.dom.getClientRects(),\n      rect = null;\n    if (!rects.length) return Rect0;\n    for (let i = pos > 0 ? rects.length - 1 : 0;; i += pos > 0 ? -1 : 1) {\n      rect = rects[i];\n      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n    }\n    return this.length ? rect : flattenRect(rect, this.side > 0);\n  }\n  get isEditable() {\n    return false;\n  }\n  destroy() {\n    super.destroy();\n    if (this.dom) this.widget.destroy(this.dom);\n  }\n}\nclass CompositionView extends WidgetView {\n  domAtPos(pos) {\n    let {\n      topView,\n      text\n    } = this.widget;\n    if (!topView) return new DOMPos(text, Math.min(pos, text.nodeValue.length));\n    return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), p => new DOMPos(text, Math.min(p, text.nodeValue.length)));\n  }\n  sync() {\n    this.setDOM(this.widget.toDOM());\n  }\n  localPosFromDOM(node, offset) {\n    let {\n      topView,\n      text\n    } = this.widget;\n    if (!topView) return Math.min(offset, this.length);\n    return posFromDOMInCompositionTree(node, offset, topView, text);\n  }\n  ignoreMutation() {\n    return false;\n  }\n  get overrideDOMText() {\n    return null;\n  }\n  coordsAt(pos, side) {\n    let {\n      topView,\n      text\n    } = this.widget;\n    if (!topView) return textCoords(text, pos, side);\n    return scanCompositionTree(pos, side, topView, text, (v, pos, side) => v.coordsAt(pos, side), (pos, side) => textCoords(text, pos, side));\n  }\n  destroy() {\n    var _a;\n    super.destroy();\n    (_a = this.widget.topView) === null || _a === void 0 ? void 0 : _a.destroy();\n  }\n  get isEditable() {\n    return true;\n  }\n  canReuseDOM() {\n    return true;\n  }\n}\n// Uses the old structure of a chunk of content view frozen for\n// composition to try and find a reasonable DOM location for the given\n// offset.\nfunction scanCompositionTree(pos, side, view, text, enterView, fromText) {\n  if (view instanceof MarkView) {\n    for (let child = view.dom.firstChild; child; child = child.nextSibling) {\n      let desc = ContentView.get(child);\n      if (!desc) return fromText(pos, side);\n      let hasComp = contains(child, text);\n      let len = desc.length + (hasComp ? text.nodeValue.length : 0);\n      if (pos < len || pos == len && desc.getSide() <= 0) return hasComp ? scanCompositionTree(pos, side, desc, text, enterView, fromText) : enterView(desc, pos, side);\n      pos -= len;\n    }\n    return enterView(view, view.length, -1);\n  } else if (view.dom == text) {\n    return fromText(pos, side);\n  } else {\n    return enterView(view, pos, side);\n  }\n}\nfunction posFromDOMInCompositionTree(node, offset, view, text) {\n  if (view instanceof MarkView) {\n    for (let child of view.children) {\n      let pos = 0,\n        hasComp = contains(child.dom, text);\n      if (contains(child.dom, node)) return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));\n      pos += hasComp ? text.nodeValue.length : child.length;\n    }\n  } else if (view.dom == text) {\n    return Math.min(offset, text.nodeValue.length);\n  }\n  return view.localPosFromDOM(node, offset);\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n  constructor(side) {\n    super();\n    this.side = side;\n  }\n  get length() {\n    return 0;\n  }\n  merge() {\n    return false;\n  }\n  become(other) {\n    return other instanceof WidgetBufferView && other.side == this.side;\n  }\n  split() {\n    return new WidgetBufferView(this.side);\n  }\n  sync() {\n    if (!this.dom) {\n      let dom = document.createElement(\"img\");\n      dom.className = \"cm-widgetBuffer\";\n      dom.setAttribute(\"aria-hidden\", \"true\");\n      this.setDOM(dom);\n    }\n  }\n  getSide() {\n    return this.side;\n  }\n  domAtPos(pos) {\n    return DOMPos.before(this.dom);\n  }\n  localPosFromDOM() {\n    return 0;\n  }\n  domBoundsAround() {\n    return null;\n  }\n  coordsAt(pos) {\n    let imgRect = this.dom.getBoundingClientRect();\n    // Since the <img> height doesn't correspond to text height, try\n    // to borrow the height from some sibling node.\n    let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);\n    return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? {\n      left: imgRect.left,\n      right: imgRect.right,\n      top: siblingRect.top,\n      bottom: siblingRect.bottom\n    } : imgRect;\n  }\n  get overrideDOMText() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n  }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineSiblingRect(view, side) {\n  let parent = view.parent,\n    index = parent ? parent.children.indexOf(view) : -1;\n  while (parent && index >= 0) {\n    if (side < 0 ? index > 0 : index < parent.children.length) {\n      let next = parent.children[index + side];\n      if (next instanceof TextView) {\n        let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);\n        if (nextRect) return nextRect;\n      }\n      index += side;\n    } else if (parent instanceof MarkView && parent.parent) {\n      index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);\n      parent = parent.parent;\n    } else {\n      let last = parent.dom.lastChild;\n      if (last && last.nodeName == \"BR\") return last.getClientRects()[0];\n      break;\n    }\n  }\n  return undefined;\n}\nfunction inlineDOMAtPos(parent, pos) {\n  let dom = parent.dom,\n    {\n      children\n    } = parent,\n    i = 0;\n  for (let off = 0; i < children.length; i++) {\n    let child = children[i],\n      end = off + child.length;\n    if (end == off && child.getSide() <= 0) continue;\n    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n    if (pos <= off) break;\n    off = end;\n  }\n  for (let j = i; j > 0; j--) {\n    let prev = children[j - 1];\n    if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);\n  }\n  for (let j = i; j < children.length; j++) {\n    let next = children[j];\n    if (next.dom.parentNode == dom) return next.domAtPos(0);\n  }\n  return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n  let last,\n    {\n      children\n    } = parent;\n  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n    joinInlineInto(last, view.children[0], open - 1);\n  } else {\n    children.push(view);\n    view.setParent(parent);\n  }\n  parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n  let before = null,\n    beforePos = -1,\n    after = null,\n    afterPos = -1;\n  function scan(view, pos) {\n    for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {\n      let child = view.children[i],\n        end = off + child.length;\n      if (end >= pos) {\n        if (child.children.length) {\n          scan(child, pos - off);\n        } else if (!after && (end > pos || off == end && child.getSide() > 0)) {\n          after = child;\n          afterPos = pos - off;\n        } else if (off < pos || off == end && child.getSide() < 0) {\n          before = child;\n          beforePos = pos - off;\n        }\n      }\n      off = end;\n    }\n  }\n  scan(view, pos);\n  let target = (side < 0 ? before : after) || before || after;\n  if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n  return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n  let last = view.dom.lastChild;\n  if (!last) return view.dom.getBoundingClientRect();\n  let rects = clientRectsFor(last);\n  return rects[rects.length - 1] || null;\n}\nfunction combineAttrs(source, target) {\n  for (let name in source) {\n    if (name == \"class\" && target.class) target.class += \" \" + source.class;else if (name == \"style\" && target.style) target.style += \";\" + source.style;else target[name] = source[name];\n  }\n  return target;\n}\nfunction attrsEq(a, b) {\n  if (a == b) return true;\n  if (!a || !b) return false;\n  let keysA = Object.keys(a),\n    keysB = Object.keys(b);\n  if (keysA.length != keysB.length) return false;\n  for (let key of keysA) {\n    if (keysB.indexOf(key) == -1 || a[key] !== b[key]) return false;\n  }\n  return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n  let changed = null;\n  if (prev) for (let name in prev) if (!(attrs && name in attrs)) dom.removeAttribute(changed = name);\n  if (attrs) for (let name in attrs) if (!(prev && prev[name] == attrs[name])) dom.setAttribute(changed = name, attrs[name]);\n  return !!changed;\n}\n\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/\nclass WidgetType {\n  /**\n  Compare this instance to another instance of the same type.\n  (TypeScript can't express this, but only instances of the same\n  specific class will be passed to this method.) This is used to\n  avoid redrawing widgets when they are replaced by a new\n  decoration of the same type. The default implementation just\n  returns `false`, which will cause new instances of the widget to\n  always be redrawn.\n  */\n  eq(widget) {\n    return false;\n  }\n  /**\n  Update a DOM element created by a widget of the same type (but\n  different, non-`eq` content) to reflect this widget. May return\n  true to indicate that it could update, false to indicate it\n  couldn't (in which case the widget will be redrawn). The default\n  implementation just returns false.\n  */\n  updateDOM(dom, view) {\n    return false;\n  }\n  /**\n  @internal\n  */\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  /**\n  The estimated height this widget will have, to be used when\n  estimating the height of content that hasn't been drawn. May\n  return -1 to indicate you don't know. The default implementation\n  returns -1.\n  */\n  get estimatedHeight() {\n    return -1;\n  }\n  /**\n  Can be used to configure which kinds of events inside the widget\n  should be ignored by the editor. The default is to ignore all\n  events.\n  */\n  ignoreEvent(event) {\n    return true;\n  }\n  /**\n  @internal\n  */\n  get customView() {\n    return null;\n  }\n  /**\n  This is called when the an instance of the widget is removed\n  from the editor view.\n  */\n  destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/\nvar BlockType = /*@__PURE__*/function (BlockType) {\n  /**\n  A line of text.\n  */\n  BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n  /**\n  A block widget associated with the position after it.\n  */\n  BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n  /**\n  A block widget associated with the position before it.\n  */\n  BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n  /**\n  A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n  */\n  BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n  return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/\nclass Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n  constructor(\n  /**\n  @internal\n  */\n  startSide,\n  /**\n  @internal\n  */\n  endSide,\n  /**\n  @internal\n  */\n  widget,\n  /**\n  The config object used to create this decoration. You can\n  include additional properties in there to store metadata about\n  your decoration.\n  */\n  spec) {\n    super();\n    this.startSide = startSide;\n    this.endSide = endSide;\n    this.widget = widget;\n    this.spec = spec;\n  }\n  /**\n  @internal\n  */\n  get heightRelevant() {\n    return false;\n  }\n  /**\n  Create a mark decoration, which influences the styling of the\n  content in its range. Nested mark decorations will cause nested\n  DOM elements to be created. Nesting order is determined by\n  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n  the higher-precedence decorations creating the inner DOM nodes.\n  Such elements are split on line boundaries and on the boundaries\n  of lower-precedence decorations.\n  */\n  static mark(spec) {\n    return new MarkDecoration(spec);\n  }\n  /**\n  Create a widget decoration, which displays a DOM element at the\n  given position.\n  */\n  static widget(spec) {\n    let side = spec.side || 0,\n      block = !!spec.block;\n    side += block ? side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */ : side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */;\n    return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n  }\n  /**\n  Create a replace decoration which replaces the given range with\n  a widget, or simply hides it.\n  */\n  static replace(spec) {\n    let block = !!spec.block,\n      startSide,\n      endSide;\n    if (spec.isBlockGap) {\n      startSide = -500000000 /* Side.GapStart */;\n      endSide = 400000000 /* Side.GapEnd */;\n    } else {\n      let {\n        start,\n        end\n      } = getInclusive(spec, block);\n      startSide = (start ? block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */) - 1;\n      endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */) + 1;\n    }\n    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n  }\n  /**\n  Create a line decoration, which can add DOM attributes to the\n  line starting at the given position.\n  */\n  static line(spec) {\n    return new LineDecoration(spec);\n  }\n  /**\n  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n  decorated range or ranges. If the ranges aren't already sorted,\n  pass `true` for `sort` to make the library sort them for you.\n  */\n  static set(of, sort = false) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\n  }\n  /**\n  @internal\n  */\n  hasHeight() {\n    return this.widget ? this.widget.estimatedHeight > -1 : false;\n  }\n}\n/**\nThe empty set of decorations.\n*/\nDecoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n  constructor(spec) {\n    let {\n      start,\n      end\n    } = getInclusive(spec);\n    super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);\n    this.tagName = spec.tagName || \"span\";\n    this.class = spec.class || \"\";\n    this.attrs = spec.attributes || null;\n  }\n  eq(other) {\n    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);\n  }\n  range(from, to = from) {\n    if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n    return super.range(from, to);\n  }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n  constructor(spec) {\n    super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);\n  }\n  eq(other) {\n    return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n  }\n  range(from, to = from) {\n    if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n    return super.range(from, to);\n  }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n  constructor(spec, startSide, endSide, block, widget, isReplace) {\n    super(startSide, endSide, widget, spec);\n    this.block = block;\n    this.isReplace = isReplace;\n    this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\n  }\n  // Only relevant when this.block == true\n  get type() {\n    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n  }\n  get heightRelevant() {\n    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;\n  }\n  eq(other) {\n    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n  }\n  range(from, to = from) {\n    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n    if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n    return super.range(from, to);\n  }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n  let {\n    inclusiveStart: start,\n    inclusiveEnd: end\n  } = spec;\n  if (start == null) start = spec.inclusive;\n  if (end == null) end = spec.inclusive;\n  return {\n    start: start !== null && start !== void 0 ? start : block,\n    end: end !== null && end !== void 0 ? end : block\n  };\n}\nfunction widgetsEq(a, b) {\n  return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n  let last = ranges.length - 1;\n  if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);else ranges.push(from, to);\n}\nclass LineView extends ContentView {\n  constructor() {\n    super(...arguments);\n    this.children = [];\n    this.length = 0;\n    this.prevAttrs = undefined;\n    this.attrs = null;\n    this.breakAfter = 0;\n  }\n  // Consumes source\n  merge(from, to, source, hasStart, openStart, openEnd) {\n    if (source) {\n      if (!(source instanceof LineView)) return false;\n      if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n    }\n\n    if (hasStart) this.setDeco(source ? source.attrs : null);\n    mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);\n    return true;\n  }\n  split(at) {\n    let end = new LineView();\n    end.breakAfter = this.breakAfter;\n    if (this.length == 0) return end;\n    let {\n      i,\n      off\n    } = this.childPos(at);\n    if (off) {\n      end.append(this.children[i].split(off), 0);\n      this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n      i++;\n    }\n    for (let j = i; j < this.children.length; j++) end.append(this.children[j], 0);\n    while (i > 0 && this.children[i - 1].length == 0) this.children[--i].destroy();\n    this.children.length = i;\n    this.markDirty();\n    this.length = at;\n    return end;\n  }\n  transferDOM(other) {\n    if (!this.dom) return;\n    this.markDirty();\n    other.setDOM(this.dom);\n    other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n    this.prevAttrs = undefined;\n    this.dom = null;\n  }\n  setDeco(attrs) {\n    if (!attrsEq(this.attrs, attrs)) {\n      if (this.dom) {\n        this.prevAttrs = this.attrs;\n        this.markDirty();\n      }\n      this.attrs = attrs;\n    }\n  }\n  append(child, openStart) {\n    joinInlineInto(this, child, openStart);\n  }\n  // Only called when building a line view in ContentBuilder\n  addLineDeco(deco) {\n    let attrs = deco.spec.attributes,\n      cls = deco.spec.class;\n    if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n    if (cls) this.attrs = combineAttrs({\n      class: cls\n    }, this.attrs || {});\n  }\n  domAtPos(pos) {\n    return inlineDOMAtPos(this, pos);\n  }\n  reuseDOM(node) {\n    if (node.nodeName == \"DIV\") {\n      this.setDOM(node);\n      this.dirty |= 4 /* Dirty.Attrs */ | 2 /* Dirty.Node */;\n    }\n  }\n\n  sync(view, track) {\n    var _a;\n    if (!this.dom) {\n      this.setDOM(document.createElement(\"div\"));\n      this.dom.className = \"cm-line\";\n      this.prevAttrs = this.attrs ? null : undefined;\n    } else if (this.dirty & 4 /* Dirty.Attrs */) {\n      clearAttributes(this.dom);\n      this.dom.className = \"cm-line\";\n      this.prevAttrs = this.attrs ? null : undefined;\n    }\n    if (this.prevAttrs !== undefined) {\n      updateAttrs(this.dom, this.prevAttrs, this.attrs);\n      this.dom.classList.add(\"cm-line\");\n      this.prevAttrs = undefined;\n    }\n    super.sync(view, track);\n    let last = this.dom.lastChild;\n    while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild;\n    if (!last || !this.length || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {\n      let hack = document.createElement(\"BR\");\n      hack.cmIgnore = true;\n      this.dom.appendChild(hack);\n    }\n  }\n  measureTextSize() {\n    if (this.children.length == 0 || this.length > 20) return null;\n    let totalWidth = 0;\n    for (let child of this.children) {\n      if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;\n      let rects = clientRectsFor(child.dom);\n      if (rects.length != 1) return null;\n      totalWidth += rects[0].width;\n    }\n    return !totalWidth ? null : {\n      lineHeight: this.dom.getBoundingClientRect().height,\n      charWidth: totalWidth / this.length\n    };\n  }\n  coordsAt(pos, side) {\n    return coordsInChildren(this, pos, side);\n  }\n  become(_other) {\n    return false;\n  }\n  get type() {\n    return BlockType.Text;\n  }\n  static find(docView, pos) {\n    for (let i = 0, off = 0; i < docView.children.length; i++) {\n      let block = docView.children[i],\n        end = off + block.length;\n      if (end >= pos) {\n        if (block instanceof LineView) return block;\n        if (end > pos) break;\n      }\n      off = end + block.breakAfter;\n    }\n    return null;\n  }\n}\nclass BlockWidgetView extends ContentView {\n  constructor(widget, length, type) {\n    super();\n    this.widget = widget;\n    this.length = length;\n    this.type = type;\n    this.breakAfter = 0;\n    this.prevWidget = null;\n  }\n  merge(from, to, source, _takeDeco, openStart, openEnd) {\n    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    this.length = from + (source ? source.length : 0) + (this.length - to);\n    return true;\n  }\n  domAtPos(pos) {\n    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n  }\n  split(at) {\n    let len = this.length - at;\n    this.length = at;\n    let end = new BlockWidgetView(this.widget, len, this.type);\n    end.breakAfter = this.breakAfter;\n    return end;\n  }\n  get children() {\n    return noChildren;\n  }\n  sync(view) {\n    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n      this.prevWidget = null;\n      this.setDOM(this.widget.toDOM(view));\n      this.dom.contentEditable = \"false\";\n    }\n  }\n  get overrideDOMText() {\n    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n  }\n  domBoundsAround() {\n    return null;\n  }\n  become(other) {\n    if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {\n      if (!other.widget.eq(this.widget)) this.markDirty(true);\n      if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n      this.widget = other.widget;\n      this.length = other.length;\n      this.breakAfter = other.breakAfter;\n      return true;\n    }\n    return false;\n  }\n  ignoreMutation() {\n    return true;\n  }\n  ignoreEvent(event) {\n    return this.widget.ignoreEvent(event);\n  }\n  destroy() {\n    super.destroy();\n    if (this.dom) this.widget.destroy(this.dom);\n  }\n}\nclass ContentBuilder {\n  constructor(doc, pos, end, disallowBlockEffectsFor) {\n    this.doc = doc;\n    this.pos = pos;\n    this.end = end;\n    this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n    this.content = [];\n    this.curLine = null;\n    this.breakAtStart = 0;\n    this.pendingBuffer = 0 /* Buf.No */;\n    this.bufferMarks = [];\n    // Set to false directly after a widget that covers the position after it\n    this.atCursorPos = true;\n    this.openStart = -1;\n    this.openEnd = -1;\n    this.text = \"\";\n    this.textOff = 0;\n    this.cursor = doc.iter();\n    this.skip = pos;\n  }\n  posCovered() {\n    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n    let last = this.content[this.content.length - 1];\n    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n  }\n  getLine() {\n    if (!this.curLine) {\n      this.content.push(this.curLine = new LineView());\n      this.atCursorPos = true;\n    }\n    return this.curLine;\n  }\n  flushBuffer(active = this.bufferMarks) {\n    if (this.pendingBuffer) {\n      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n      this.pendingBuffer = 0 /* Buf.No */;\n    }\n  }\n\n  addBlockWidget(view) {\n    this.flushBuffer();\n    this.curLine = null;\n    this.content.push(view);\n  }\n  finish(openEnd) {\n    if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();else this.pendingBuffer = 0 /* Buf.No */;\n    if (!this.posCovered()) this.getLine();\n  }\n  buildText(length, active, openStart) {\n    while (length > 0) {\n      if (this.textOff == this.text.length) {\n        let {\n          value,\n          lineBreak,\n          done\n        } = this.cursor.next(this.skip);\n        this.skip = 0;\n        if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n        if (lineBreak) {\n          if (!this.posCovered()) this.getLine();\n          if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;else this.breakAtStart = 1;\n          this.flushBuffer();\n          this.curLine = null;\n          this.atCursorPos = true;\n          length--;\n          continue;\n        } else {\n          this.text = value;\n          this.textOff = 0;\n        }\n      }\n      let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);\n      this.flushBuffer(active.slice(active.length - openStart));\n      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n      this.atCursorPos = true;\n      this.textOff += take;\n      length -= take;\n      openStart = 0;\n    }\n  }\n  span(from, to, active, openStart) {\n    this.buildText(to - from, active, openStart);\n    this.pos = to;\n    if (this.openStart < 0) this.openStart = openStart;\n  }\n  point(from, to, deco, active, openStart, index) {\n    if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n      if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n      if (to > this.doc.lineAt(this.pos).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n    }\n    let len = to - from;\n    if (deco instanceof PointDecoration) {\n      if (deco.block) {\n        let {\n          type\n        } = deco;\n        if (type == BlockType.WidgetAfter && !this.posCovered()) this.getLine();\n        this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\n      } else {\n        let view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, len ? 0 : deco.startSide);\n        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n        let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n        let line = this.getLine();\n        if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore) this.pendingBuffer = 0 /* Buf.No */;\n        this.flushBuffer(active);\n        if (cursorBefore) {\n          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n          openStart = active.length + Math.max(0, openStart - active.length);\n        }\n        line.append(wrapMarks(view, active), openStart);\n        this.atCursorPos = cursorAfter;\n        this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;\n        if (this.pendingBuffer) this.bufferMarks = active.slice();\n      }\n    } else if (this.doc.lineAt(this.pos).from == this.pos) {\n      // Line decoration\n      this.getLine().addLineDeco(deco);\n    }\n    if (len) {\n      // Advance the iterator past the replaced content\n      if (this.textOff + len <= this.text.length) {\n        this.textOff += len;\n      } else {\n        this.skip += len - (this.text.length - this.textOff);\n        this.text = \"\";\n        this.textOff = 0;\n      }\n      this.pos = to;\n    }\n    if (this.openStart < 0) this.openStart = openStart;\n  }\n  static build(text, from, to, decorations, dynamicDecorationMap) {\n    let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n    builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\n    if (builder.openStart < 0) builder.openStart = builder.openEnd;\n    builder.finish(builder.openEnd);\n    return builder;\n  }\n}\nfunction wrapMarks(view, active) {\n  for (let mark of active) view = new MarkView(mark, [view], view.length);\n  return view;\n}\nclass NullWidget extends WidgetType {\n  constructor(tag) {\n    super();\n    this.tag = tag;\n  }\n  eq(other) {\n    return other.tag == this.tag;\n  }\n  toDOM() {\n    return document.createElement(this.tag);\n  }\n  updateDOM(elt) {\n    return elt.nodeName.toLowerCase() == this.tag;\n  }\n}\nconst clickAddsSelectionRange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst exceptionSink = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst updateListener = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst inputHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.some(x => x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.some(x => x)\n});\nclass ScrollTarget {\n  constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5) {\n    this.range = range;\n    this.y = y;\n    this.x = x;\n    this.yMargin = yMargin;\n    this.xMargin = xMargin;\n  }\n  map(changes) {\n    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);\n  }\n}\nconst scrollIntoView = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n  map: (t, ch) => t.map(ch)\n});\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/\nfunction logException(state, exception, context) {\n  let handler = state.facet(exceptionSink);\n  if (handler.length) handler[0](exception);else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);else if (context) console.error(context + \":\", exception);else console.error(exception);\n}\nconst editable = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/\nclass ViewPlugin {\n  constructor(\n  /**\n  @internal\n  */\n  id,\n  /**\n  @internal\n  */\n  create,\n  /**\n  @internal\n  */\n  domEventHandlers, buildExtensions) {\n    this.id = id;\n    this.create = create;\n    this.domEventHandlers = domEventHandlers;\n    this.extension = buildExtensions(this);\n  }\n  /**\n  Define a plugin from a constructor function that creates the\n  plugin's value, given an editor view.\n  */\n  static define(create, spec) {\n    const {\n      eventHandlers,\n      provide,\n      decorations: deco\n    } = spec || {};\n    return new ViewPlugin(nextPluginID++, create, eventHandlers, plugin => {\n      let ext = [viewPlugin.of(plugin)];\n      if (deco) ext.push(decorations.of(view => {\n        let pluginInst = view.plugin(plugin);\n        return pluginInst ? deco(pluginInst) : Decoration.none;\n      }));\n      if (provide) ext.push(provide(plugin));\n      return ext;\n    });\n  }\n  /**\n  Create a plugin for a class whose constructor takes a single\n  editor view as argument.\n  */\n  static fromClass(cls, spec) {\n    return ViewPlugin.define(view => new cls(view), spec);\n  }\n}\nclass PluginInstance {\n  constructor(spec) {\n    this.spec = spec;\n    // When starting an update, all plugins have this field set to the\n    // update object, indicating they need to be updated. When finished\n    // updating, it is set to `false`. Retrieving a plugin that needs to\n    // be updated with `view.plugin` forces an eager update.\n    this.mustUpdate = null;\n    // This is null when the plugin is initially created, but\n    // initialized on the first update.\n    this.value = null;\n  }\n  update(view) {\n    if (!this.value) {\n      if (this.spec) {\n        try {\n          this.value = this.spec.create(view);\n        } catch (e) {\n          logException(view.state, e, \"CodeMirror plugin crashed\");\n          this.deactivate();\n        }\n      }\n    } else if (this.mustUpdate) {\n      let update = this.mustUpdate;\n      this.mustUpdate = null;\n      if (this.value.update) {\n        try {\n          this.value.update(update);\n        } catch (e) {\n          logException(update.state, e, \"CodeMirror plugin crashed\");\n          if (this.value.destroy) try {\n            this.value.destroy();\n          } catch (_) {}\n          this.deactivate();\n        }\n      }\n    }\n    return this;\n  }\n  destroy(view) {\n    var _a;\n    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n      try {\n        this.value.destroy();\n      } catch (e) {\n        logException(view.state, e, \"CodeMirror plugin crashed\");\n      }\n    }\n  }\n  deactivate() {\n    this.spec = this.value = null;\n  }\n}\nconst editorAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst contentAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst atomicRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst scrollMargins = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst styleModule = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ChangedRange {\n  constructor(fromA, toA, fromB, toB) {\n    this.fromA = fromA;\n    this.toA = toA;\n    this.fromB = fromB;\n    this.toB = toB;\n  }\n  join(other) {\n    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n  }\n  addToSet(set) {\n    let i = set.length,\n      me = this;\n    for (; i > 0; i--) {\n      let range = set[i - 1];\n      if (range.fromA > me.toA) continue;\n      if (range.toA < me.fromA) break;\n      me = me.join(range);\n      set.splice(i - 1, 1);\n    }\n    set.splice(i, 0, me);\n    return set;\n  }\n  static extendWithRanges(diff, ranges) {\n    if (ranges.length == 0) return diff;\n    let result = [];\n    for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n      let next = dI == diff.length ? null : diff[dI],\n        off = posA - posB;\n      let end = next ? next.fromB : 1e9;\n      while (rI < ranges.length && ranges[rI] < end) {\n        let from = ranges[rI],\n          to = ranges[rI + 1];\n        let fromB = Math.max(posB, from),\n          toB = Math.min(end, to);\n        if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n        if (to > end) break;else rI += 2;\n      }\n      if (!next) return result;\n      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n      posA = next.toA;\n      posB = next.toB;\n    }\n  }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/\nclass ViewUpdate {\n  constructor(\n  /**\n  The editor view that the update is associated with.\n  */\n  view,\n  /**\n  The new editor state.\n  */\n  state,\n  /**\n  The transactions involved in the update. May be empty.\n  */\n  transactions) {\n    this.view = view;\n    this.state = state;\n    this.transactions = transactions;\n    /**\n    @internal\n    */\n    this.flags = 0;\n    this.startState = view.state;\n    this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\n    for (let tr of transactions) this.changes = this.changes.compose(tr.changes);\n    let changedRanges = [];\n    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n    this.changedRanges = changedRanges;\n    let focus = view.hasFocus;\n    if (focus != view.inputState.notifiedFocused) {\n      view.inputState.notifiedFocused = focus;\n      this.flags |= 1 /* UpdateFlag.Focus */;\n    }\n  }\n  /**\n  @internal\n  */\n  static create(view, state, transactions) {\n    return new ViewUpdate(view, state, transactions);\n  }\n  /**\n  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n  update.\n  */\n  get viewportChanged() {\n    return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;\n  }\n  /**\n  Indicates whether the height of a block element in the editor\n  changed in this update.\n  */\n  get heightChanged() {\n    return (this.flags & 2 /* UpdateFlag.Height */) > 0;\n  }\n  /**\n  Returns true when the document was modified or the size of the\n  editor, or elements within the editor, changed.\n  */\n  get geometryChanged() {\n    return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;\n  }\n  /**\n  True when this update indicates a focus change.\n  */\n  get focusChanged() {\n    return (this.flags & 1 /* UpdateFlag.Focus */) > 0;\n  }\n  /**\n  Whether the document changed in this update.\n  */\n  get docChanged() {\n    return !this.changes.empty;\n  }\n  /**\n  Whether the selection was explicitly set in this update.\n  */\n  get selectionSet() {\n    return this.transactions.some(tr => tr.selection);\n  }\n  /**\n  @internal\n  */\n  get empty() {\n    return this.flags == 0 && this.transactions.length == 0;\n  }\n}\n\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/\nvar Direction = /*@__PURE__*/function (Direction) {\n  // (These are chosen to match the base levels, in bidi algorithm\n  // terms, of spans in that direction.)\n  /**\n  Left-to-right.\n  */\n  Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n  /**\n  Right-to-left.\n  */\n  Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n  return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR,\n  RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n  let result = [];\n  for (let i = 0; i < str.length; i++) result.push(1 << +str[i]);\n  return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/Object.create(null),\n  BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\"()\", \"[]\", \"{}\"]) {\n  let l = /*@__PURE__*/p.charCodeAt(0),\n    r = /*@__PURE__*/p.charCodeAt(1);\n  Brackets[l] = r;\n  Brackets[r] = -l;\n}\nfunction charType(ch) {\n  return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ : 0x2000 <= ch && ch <= 0x200b ? 256 /* T.NI */ : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ : ch == 0x200c ? 256 /* T.NI */ : 1 /* T.L */;\n}\n\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/\nclass BidiSpan {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The start of the span (relative to the start of the line).\n  */\n  from,\n  /**\n  The end of the span.\n  */\n  to,\n  /**\n  The [\"bidi\n  level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n  of the span (in this context, 0 means\n  left-to-right, 1 means right-to-left, 2 means left-to-right\n  number inside right-to-left text).\n  */\n  level) {\n    this.from = from;\n    this.to = to;\n    this.level = level;\n  }\n  /**\n  The direction of this span.\n  */\n  get dir() {\n    return this.level % 2 ? RTL : LTR;\n  }\n  /**\n  @internal\n  */\n  side(end, dir) {\n    return this.dir == dir == end ? this.to : this.from;\n  }\n  /**\n  @internal\n  */\n  static find(order, index, level, assoc) {\n    let maybe = -1;\n    for (let i = 0; i < order.length; i++) {\n      let span = order[i];\n      if (span.from <= index && span.to >= index) {\n        if (span.level == level) return i;\n        // When multiple spans match, if assoc != 0, take the one that\n        // covers that side, otherwise take the one with the minimum\n        // level.\n        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n      }\n    }\n    if (maybe < 0) throw new RangeError(\"Index out of range\");\n    return maybe;\n  }\n}\n// Reused array of character types\nconst types = [];\nfunction computeOrder(line, direction) {\n  let len = line.length,\n    outerType = direction == LTR ? 1 /* T.L */ : 2 /* T.R */,\n    oppositeType = direction == LTR ? 2 /* T.R */ : 1 /* T.L */;\n  if (!line || outerType == 1 /* T.L */ && !BidiRE.test(line)) return trivialOrder(len);\n  // W1. Examine each non-spacing mark (NSM) in the level run, and\n  // change the type of the NSM to the type of the previous\n  // character. If the NSM is at the start of the level run, it will\n  // get the type of sor.\n  // W2. Search backwards from each instance of a European number\n  // until the first strong type (R, L, AL, or sor) is found. If an\n  // AL is found, change the type of the European number to Arabic\n  // number.\n  // W3. Change all ALs to R.\n  // (Left after this: L, R, EN, AN, ET, CS, NI)\n  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n    let type = charType(line.charCodeAt(i));\n    if (type == 512 /* T.NSM */) type = prev;else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */) type = 16 /* T.AN */;\n    types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;\n    if (type & 7 /* T.Strong */) prevStrong = type;\n    prev = type;\n  }\n  // W5. A sequence of European terminators adjacent to European\n  // numbers changes to all European numbers.\n  // W6. Otherwise, separators and terminators change to Other\n  // Neutral.\n  // W7. Search backwards from each instance of a European number\n  // until the first strong type (R, L, or sor) is found. If an L is\n  // found, then change the type of the European number to L.\n  // (Left after this: L, R, EN+AN, NI)\n  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n    let type = types[i];\n    if (type == 128 /* T.CS */) {\n      if (i < len - 1 && prev == types[i + 1] && prev & 24 /* T.Num */) type = types[i] = prev;else types[i] = 256 /* T.NI */;\n    } else if (type == 64 /* T.ET */) {\n      let end = i + 1;\n      while (end < len && types[end] == 64 /* T.ET */) end++;\n      let replace = i && prev == 8 /* T.EN */ || end < len && types[end] == 8 /* T.EN */ ? prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */ : 256 /* T.NI */;\n      for (let j = i; j < end; j++) types[j] = replace;\n      i = end - 1;\n    } else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {\n      types[i] = 1 /* T.L */;\n    }\n\n    prev = type;\n    if (type & 7 /* T.Strong */) prevStrong = type;\n  }\n  // N0. Process bracket pairs in an isolating run sequence\n  // sequentially in the logical order of the text positions of the\n  // opening paired brackets using the logic given below. Within this\n  // scope, bidirectional types EN and AN are treated as R.\n  for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {\n    // Keeps [startIndex, type, strongSeen] triples for each open\n    // bracket on BracketStack.\n    if (br = Brackets[ch = line.charCodeAt(i)]) {\n      if (br < 0) {\n        // Closing bracket\n        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n          if (BracketStack[sJ + 1] == -br) {\n            let flags = BracketStack[sJ + 2];\n            let type = flags & 2 /* Bracketed.EmbedInside */ ? outerType : !(flags & 4 /* Bracketed.OppositeInside */) ? 0 : flags & 1 /* Bracketed.OppositeBefore */ ? oppositeType : outerType;\n            if (type) types[i] = types[BracketStack[sJ]] = type;\n            sI = sJ;\n            break;\n          }\n        }\n      } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {\n        break;\n      } else {\n        BracketStack[sI++] = i;\n        BracketStack[sI++] = ch;\n        BracketStack[sI++] = context;\n      }\n    } else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {\n      let embed = type == outerType;\n      context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;\n      for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n        let cur = BracketStack[sJ + 2];\n        if (cur & 2 /* Bracketed.EmbedInside */) break;\n        if (embed) {\n          BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;\n        } else {\n          if (cur & 4 /* Bracketed.OppositeInside */) break;\n          BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;\n        }\n      }\n    }\n  }\n  // N1. A sequence of neutrals takes the direction of the\n  // surrounding strong text if the text on both sides has the same\n  // direction. European and Arabic numbers act as if they were R in\n  // terms of their influence on neutrals. Start-of-level-run (sor)\n  // and end-of-level-run (eor) are used at level run boundaries.\n  // N2. Any remaining neutrals take the embedding direction.\n  // (Left after this: L, R, EN+AN)\n  for (let i = 0; i < len; i++) {\n    if (types[i] == 256 /* T.NI */) {\n      let end = i + 1;\n      while (end < len && types[end] == 256 /* T.NI */) end++;\n      let beforeL = (i ? types[i - 1] : outerType) == 1 /* T.L */;\n      let afterL = (end < len ? types[end] : outerType) == 1 /* T.L */;\n      let replace = beforeL == afterL ? beforeL ? 1 /* T.L */ : 2 /* T.R */ : outerType;\n      for (let j = i; j < end; j++) types[j] = replace;\n      i = end - 1;\n    }\n  }\n  // Here we depart from the documented algorithm, in order to avoid\n  // building up an actual levels array. Since there are only three\n  // levels (0, 1, 2) in an implementation that doesn't take\n  // explicit embedding into account, we can build up the order on\n  // the fly, without following the level-based algorithm.\n  let order = [];\n  if (outerType == 1 /* T.L */) {\n    for (let i = 0; i < len;) {\n      let start = i,\n        rtl = types[i++] != 1 /* T.L */;\n      while (i < len && rtl == (types[i] != 1 /* T.L */)) i++;\n      if (rtl) {\n        for (let j = i; j > start;) {\n          let end = j,\n            l = types[--j] != 2 /* T.R */;\n          while (j > start && l == (types[j - 1] != 2 /* T.R */)) j--;\n          order.push(new BidiSpan(j, end, l ? 2 : 1));\n        }\n      } else {\n        order.push(new BidiSpan(start, i, 0));\n      }\n    }\n  } else {\n    for (let i = 0; i < len;) {\n      let start = i,\n        rtl = types[i++] == 2 /* T.R */;\n      while (i < len && rtl == (types[i] == 2 /* T.R */)) i++;\n      order.push(new BidiSpan(start, i, rtl ? 1 : 2));\n    }\n  }\n  return order;\n}\nfunction trivialOrder(length) {\n  return [new BidiSpan(0, length, 0)];\n}\nlet movedOver = \"\";\nfunction moveVisually(line, order, dir, start, forward) {\n  var _a;\n  let startIndex = start.head - line.from,\n    spanI = -1;\n  if (startIndex == 0) {\n    if (!forward || !line.length) return null;\n    if (order[0].level != dir) {\n      startIndex = order[0].side(false, dir);\n      spanI = 0;\n    }\n  } else if (startIndex == line.length) {\n    if (forward) return null;\n    let last = order[order.length - 1];\n    if (last.level != dir) {\n      startIndex = last.side(true, dir);\n      spanI = order.length - 1;\n    }\n  }\n  if (spanI < 0) spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n  let span = order[spanI];\n  // End of span. (But not end of line--that was checked for above.)\n  if (startIndex == span.side(forward, dir)) {\n    span = order[spanI += forward ? 1 : -1];\n    startIndex = span.side(!forward, dir);\n  }\n  let indexForward = forward == (span.dir == dir);\n  let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, indexForward);\n  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n  if (nextIndex != span.side(forward, dir)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n  if (!nextSpan && span.level != dir) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n  if (nextSpan && nextSpan.level < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);\n}\nconst LineBreakPlaceholder = \"\\uffff\";\nclass DOMReader {\n  constructor(points, state) {\n    this.points = points;\n    this.text = \"\";\n    this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\n  }\n  append(text) {\n    this.text += text;\n  }\n  lineBreak() {\n    this.text += LineBreakPlaceholder;\n  }\n  readRange(start, end) {\n    if (!start) return this;\n    let parent = start.parentNode;\n    for (let cur = start;;) {\n      this.findPointBefore(parent, cur);\n      this.readNode(cur);\n      let next = cur.nextSibling;\n      if (next == end) break;\n      let view = ContentView.get(cur),\n        nextView = ContentView.get(next);\n      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore)) this.lineBreak();\n      cur = next;\n    }\n    this.findPointBefore(parent, end);\n    return this;\n  }\n  readTextNode(node) {\n    let text = node.nodeValue;\n    for (let point of this.points) if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n    for (let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;) {\n      let nextBreak = -1,\n        breakSize = 1,\n        m;\n      if (this.lineSeparator) {\n        nextBreak = text.indexOf(this.lineSeparator, off);\n        breakSize = this.lineSeparator.length;\n      } else if (m = re.exec(text)) {\n        nextBreak = m.index;\n        breakSize = m[0].length;\n      }\n      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n      if (nextBreak < 0) break;\n      this.lineBreak();\n      if (breakSize > 1) for (let point of this.points) if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n      off = nextBreak + breakSize;\n    }\n  }\n  readNode(node) {\n    if (node.cmIgnore) return;\n    let view = ContentView.get(node);\n    let fromView = view && view.overrideDOMText;\n    if (fromView != null) {\n      this.findPointInside(node, fromView.length);\n      for (let i = fromView.iter(); !i.next().done;) {\n        if (i.lineBreak) this.lineBreak();else this.append(i.value);\n      }\n    } else if (node.nodeType == 3) {\n      this.readTextNode(node);\n    } else if (node.nodeName == \"BR\") {\n      if (node.nextSibling) this.lineBreak();\n    } else if (node.nodeType == 1) {\n      this.readRange(node.firstChild, null);\n    }\n  }\n  findPointBefore(node, next) {\n    for (let point of this.points) if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n  }\n  findPointInside(node, maxLen) {\n    for (let point of this.points) if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + Math.min(maxLen, point.offset);\n  }\n}\nfunction isBlockElement(node) {\n  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n  constructor(node, offset) {\n    this.node = node;\n    this.offset = offset;\n    this.pos = -1;\n  }\n}\nclass DocView extends ContentView {\n  constructor(view) {\n    super();\n    this.view = view;\n    this.compositionDeco = Decoration.none;\n    this.decorations = [];\n    this.dynamicDecorationMap = [];\n    // Track a minimum width for the editor. When measuring sizes in\n    // measureVisibleLineHeights, this is updated to point at the width\n    // of a given element and its extent in the document. When a change\n    // happens in that range, these are reset. That way, once we've seen\n    // a line/element of a given length, we keep the editor wide enough\n    // to fit at least that element, until it is changed, at which point\n    // we forget it again.\n    this.minWidth = 0;\n    this.minWidthFrom = 0;\n    this.minWidthTo = 0;\n    // Track whether the DOM selection was set in a lossy way, so that\n    // we don't mess it up when reading it back it\n    this.impreciseAnchor = null;\n    this.impreciseHead = null;\n    this.forceSelection = false;\n    // Used by the resize observer to ignore resizes that we caused\n    // ourselves\n    this.lastUpdate = Date.now();\n    this.setDOM(view.contentDOM);\n    this.children = [new LineView()];\n    this.children[0].setParent(this);\n    this.updateDeco();\n    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);\n  }\n  get length() {\n    return this.view.state.doc.length;\n  }\n  // Update the document view to a given state. scrollIntoView can be\n  // used as a hint to compute a new viewport that includes that\n  // position, if we know the editor is going to scroll that position\n  // into view.\n  update(update) {\n    let changedRanges = update.changedRanges;\n    if (this.minWidth > 0 && changedRanges.length) {\n      if (!changedRanges.every(({\n        fromA,\n        toA\n      }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n      } else {\n        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n      }\n    }\n    if (this.view.inputState.composing < 0) this.compositionDeco = Decoration.none;else if (update.transactions.length || this.dirty) this.compositionDeco = computeCompositionDeco(this.view, update.changes);\n    // When the DOM nodes around the selection are moved to another\n    // parent, Chrome sometimes reports a different selection through\n    // getSelection than the one that it actually shows to the user.\n    // This forces a selection update when lines are joined to work\n    // around that. Issue #54\n    if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n    let prevDeco = this.decorations,\n      deco = this.updateDeco();\n    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n    if (this.dirty == 0 /* Dirty.Not */ && changedRanges.length == 0) {\n      return false;\n    } else {\n      this.updateInner(changedRanges, update.startState.doc.length);\n      if (update.transactions.length) this.lastUpdate = Date.now();\n      return true;\n    }\n  }\n  // Used by update and the constructor do perform the actual DOM\n  // update\n  updateInner(changes, oldLength) {\n    this.view.viewState.mustMeasureContent = true;\n    this.updateChildren(changes, oldLength);\n    let {\n      observer\n    } = this.view;\n    observer.ignore(() => {\n      // Lock the height during redrawing, since Chrome sometimes\n      // messes with the scroll position during DOM mutation (though\n      // no relayout is triggered and I cannot imagine how it can\n      // recompute the scroll position without a layout)\n      this.dom.style.height = this.view.viewState.contentHeight + \"px\";\n      this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n      // Chrome will sometimes, when DOM mutations occur directly\n      // around the selection, get confused and report a different\n      // selection from the one it displays (issue #218). This tries\n      // to detect that situation.\n      let track = browser.chrome || browser.ios ? {\n        node: observer.selectionRange.focusNode,\n        written: false\n      } : undefined;\n      this.sync(this.view, track);\n      this.dirty = 0 /* Dirty.Not */;\n      if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;\n      this.dom.style.height = \"\";\n    });\n    let gaps = [];\n    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let child of this.children) if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n    observer.updateGaps(gaps);\n  }\n  updateChildren(changes, oldLength) {\n    let cursor = this.childCursor(oldLength);\n    for (let i = changes.length - 1;; i--) {\n      let next = i >= 0 ? changes[i] : null;\n      if (!next) break;\n      let {\n        fromA,\n        toA,\n        fromB,\n        toB\n      } = next;\n      let {\n        content,\n        breakAtStart,\n        openStart,\n        openEnd\n      } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);\n      let {\n        i: toI,\n        off: toOff\n      } = cursor.findPos(toA, 1);\n      let {\n        i: fromI,\n        off: fromOff\n      } = cursor.findPos(fromA, -1);\n      replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n    }\n  }\n  // Sync the DOM selection to this.state.selection\n  updateSelection(mustRead = false, fromPointer = false) {\n    if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n    if (!(fromPointer || this.mayControlSelection())) return;\n    let force = this.forceSelection;\n    this.forceSelection = false;\n    let main = this.view.state.selection.main;\n    // FIXME need to handle the case where the selection falls inside a block range\n    let anchor = this.domAtPos(main.anchor);\n    let head = main.empty ? anchor : this.domAtPos(main.head);\n    // Always reset on Firefox when next to an uneditable node to\n    // avoid invisible cursor bugs (#111)\n    if (browser.gecko && main.empty && betweenUneditable(anchor)) {\n      let dummy = document.createTextNode(\"\");\n      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n      anchor = head = new DOMPos(dummy, 0);\n      force = true;\n    }\n    let domSel = this.view.observer.selectionRange;\n    // If the selection is already here, or in an equivalent position, don't touch it\n    if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n      this.view.observer.ignore(() => {\n        // Chrome Android will hide the virtual keyboard when tapping\n        // inside an uneditable node, and not bring it back when we\n        // move the cursor to its proper position. This tries to\n        // restore the keyboard by cycling focus.\n        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {\n          this.dom.blur();\n          this.dom.focus({\n            preventScroll: true\n          });\n        }\n        let rawSel = getSelection(this.view.root);\n        if (!rawSel) ;else if (main.empty) {\n          // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n          if (browser.gecko) {\n            let nextTo = nextToUneditable(anchor.node, anchor.offset);\n            if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {\n              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);\n              if (text) anchor = new DOMPos(text, nextTo == 1 /* NextTo.Before */ ? 0 : text.nodeValue.length);\n            }\n          }\n          rawSel.collapse(anchor.node, anchor.offset);\n          if (main.bidiLevel != null && domSel.cursorBidiLevel != null) domSel.cursorBidiLevel = main.bidiLevel;\n        } else if (rawSel.extend) {\n          // Selection.extend can be used to create an 'inverted' selection\n          // (one where the focus is before the anchor), but not all\n          // browsers support it yet.\n          rawSel.collapse(anchor.node, anchor.offset);\n          // Safari will ignore the call above when the editor is\n          // hidden, and then raise an error on the call to extend\n          // (#940).\n          try {\n            rawSel.extend(head.node, head.offset);\n          } catch (_) {}\n        } else {\n          // Primitive (IE) way\n          let range = document.createRange();\n          if (main.anchor > main.head) [anchor, head] = [head, anchor];\n          range.setEnd(head.node, head.offset);\n          range.setStart(anchor.node, anchor.offset);\n          rawSel.removeAllRanges();\n          rawSel.addRange(range);\n        }\n      });\n      this.view.observer.setSelectionRange(anchor, head);\n    }\n    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n  }\n  enforceCursorAssoc() {\n    if (this.compositionDeco.size) return;\n    let {\n        view\n      } = this,\n      cursor = view.state.selection.main;\n    let sel = getSelection(view.root);\n    let {\n      anchorNode,\n      anchorOffset\n    } = view.observer.selectionRange;\n    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n    let line = LineView.find(this, cursor.head);\n    if (!line) return;\n    let lineStart = line.posAtStart;\n    if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n    let before = this.coordsAt(cursor.head, -1),\n      after = this.coordsAt(cursor.head, 1);\n    if (!before || !after || before.bottom > after.top) return;\n    let dom = this.domAtPos(cursor.head + cursor.assoc);\n    sel.collapse(dom.node, dom.offset);\n    sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n    // This can go wrong in corner cases like single-character lines,\n    // so check and reset if necessary.\n    view.observer.readSelectionRange();\n    let newRange = view.observer.selectionRange;\n    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n  }\n  mayControlSelection() {\n    let active = this.view.root.activeElement;\n    return active == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active && this.dom.contains(active));\n  }\n  nearest(dom) {\n    for (let cur = dom; cur;) {\n      let domView = ContentView.get(cur);\n      if (domView && domView.rootView == this) return domView;\n      cur = cur.parentNode;\n    }\n    return null;\n  }\n  posFromDOM(node, offset) {\n    let view = this.nearest(node);\n    if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n    return view.localPosFromDOM(node, offset) + view.posAtStart;\n  }\n  domAtPos(pos) {\n    let {\n      i,\n      off\n    } = this.childCursor().findPos(pos, -1);\n    for (; i < this.children.length - 1;) {\n      let child = this.children[i];\n      if (off < child.length || child instanceof LineView) break;\n      i++;\n      off = 0;\n    }\n    return this.children[i].domAtPos(off);\n  }\n  coordsAt(pos, side) {\n    for (let off = this.length, i = this.children.length - 1;; i--) {\n      let child = this.children[i],\n        start = off - child.breakAfter - child.length;\n      if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2)) return child.coordsAt(pos - start, side);\n      off = start;\n    }\n  }\n  measureVisibleLineHeights(viewport) {\n    let result = [],\n      {\n        from,\n        to\n      } = viewport;\n    let contentWidth = this.view.contentDOM.clientWidth;\n    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n    let widest = -1,\n      ltr = this.view.textDirection == Direction.LTR;\n    for (let pos = 0, i = 0; i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (end > to) break;\n      if (pos >= from) {\n        let childRect = child.dom.getBoundingClientRect();\n        result.push(childRect.height);\n        if (isWider) {\n          let last = child.dom.lastChild;\n          let rects = last ? clientRectsFor(last) : [];\n          if (rects.length) {\n            let rect = rects[rects.length - 1];\n            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n            if (width > widest) {\n              widest = width;\n              this.minWidth = contentWidth;\n              this.minWidthFrom = pos;\n              this.minWidthTo = end;\n            }\n          }\n        }\n      }\n      pos = end + child.breakAfter;\n    }\n    return result;\n  }\n  textDirectionAt(pos) {\n    let {\n      i\n    } = this.childPos(pos, 1);\n    return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n  }\n  measureTextSize() {\n    for (let child of this.children) {\n      if (child instanceof LineView) {\n        let measure = child.measureTextSize();\n        if (measure) return measure;\n      }\n    }\n    // If no workable line exists, force a layout of a measurable element\n    let dummy = document.createElement(\"div\"),\n      lineHeight,\n      charWidth;\n    dummy.className = \"cm-line\";\n    dummy.style.width = \"99999px\";\n    dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n    this.view.observer.ignore(() => {\n      this.dom.appendChild(dummy);\n      let rect = clientRectsFor(dummy.firstChild)[0];\n      lineHeight = dummy.getBoundingClientRect().height;\n      charWidth = rect ? rect.width / 27 : 7;\n      dummy.remove();\n    });\n    return {\n      lineHeight,\n      charWidth\n    };\n  }\n  childCursor(pos = this.length) {\n    // Move back to start of last element when possible, so that\n    // `ChildCursor.findPos` doesn't have to deal with the edge case\n    // of being after the last element.\n    let i = this.children.length;\n    if (i) pos -= this.children[--i].length;\n    return new ChildCursor(this.children, pos, i);\n  }\n  computeBlockGapDeco() {\n    let deco = [],\n      vs = this.view.viewState;\n    for (let pos = 0, i = 0;; i++) {\n      let next = i == vs.viewports.length ? null : vs.viewports[i];\n      let end = next ? next.from - 1 : this.length;\n      if (end > pos) {\n        let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;\n        deco.push(Decoration.replace({\n          widget: new BlockGapWidget(height),\n          block: true,\n          inclusive: true,\n          isBlockGap: true\n        }).range(pos, end));\n      }\n      if (!next) break;\n      pos = next.to + 1;\n    }\n    return Decoration.set(deco);\n  }\n  updateDeco() {\n    let allDeco = this.view.state.facet(decorations).map((d, i) => {\n      let dynamic = this.dynamicDecorationMap[i] = typeof d == \"function\";\n      return dynamic ? d(this.view) : d;\n    });\n    for (let i = allDeco.length; i < allDeco.length + 3; i++) this.dynamicDecorationMap[i] = false;\n    return this.decorations = [...allDeco, this.compositionDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];\n  }\n  scrollIntoView(target) {\n    let {\n      range\n    } = target;\n    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),\n      other;\n    if (!rect) return;\n    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n      left: Math.min(rect.left, other.left),\n      top: Math.min(rect.top, other.top),\n      right: Math.max(rect.right, other.right),\n      bottom: Math.max(rect.bottom, other.bottom)\n    };\n    let mLeft = 0,\n      mRight = 0,\n      mTop = 0,\n      mBottom = 0;\n    for (let margins of this.view.state.facet(scrollMargins).map(f => f(this.view))) if (margins) {\n      let {\n        left,\n        right,\n        top,\n        bottom\n      } = margins;\n      if (left != null) mLeft = Math.max(mLeft, left);\n      if (right != null) mRight = Math.max(mRight, right);\n      if (top != null) mTop = Math.max(mTop, top);\n      if (bottom != null) mBottom = Math.max(mBottom, bottom);\n    }\n    let targetRect = {\n      left: rect.left - mLeft,\n      top: rect.top - mTop,\n      right: rect.right + mRight,\n      bottom: rect.bottom + mBottom\n    };\n    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);\n  }\n}\nfunction betweenUneditable(pos) {\n  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n  constructor(height) {\n    super();\n    this.height = height;\n  }\n  toDOM() {\n    let elt = document.createElement(\"div\");\n    this.updateDOM(elt);\n    return elt;\n  }\n  eq(other) {\n    return other.height == this.height;\n  }\n  updateDOM(elt) {\n    elt.style.height = this.height + \"px\";\n    return true;\n  }\n  get estimatedHeight() {\n    return this.height;\n  }\n}\nfunction compositionSurroundingNode(view) {\n  let sel = view.observer.selectionRange;\n  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n  if (!textNode) return null;\n  let cView = view.docView.nearest(textNode);\n  if (!cView) return null;\n  if (cView instanceof LineView) {\n    let topNode = textNode;\n    while (topNode.parentNode != cView.dom) topNode = topNode.parentNode;\n    let prev = topNode.previousSibling;\n    while (prev && !ContentView.get(prev)) prev = prev.previousSibling;\n    let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n    return {\n      from: pos,\n      to: pos,\n      node: topNode,\n      text: textNode\n    };\n  } else {\n    for (;;) {\n      let {\n        parent\n      } = cView;\n      if (!parent) return null;\n      if (parent instanceof LineView) break;\n      cView = parent;\n    }\n    let from = cView.posAtStart;\n    return {\n      from,\n      to: from + cView.length,\n      node: cView.dom,\n      text: textNode\n    };\n  }\n}\nfunction computeCompositionDeco(view, changes) {\n  let surrounding = compositionSurroundingNode(view);\n  if (!surrounding) return Decoration.none;\n  let {\n    from,\n    to,\n    node,\n    text: textNode\n  } = surrounding;\n  let newFrom = changes.mapPos(from, 1),\n    newTo = Math.max(newFrom, changes.mapPos(to, -1));\n  let {\n      state\n    } = view,\n    text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state).readRange(node.firstChild, null).text;\n  if (newTo - newFrom < text.length) {\n    if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text.length), LineBreakPlaceholder) == text) newTo = newFrom + text.length;else if (state.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text) newFrom = newTo - text.length;else return Decoration.none;\n  } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {\n    return Decoration.none;\n  }\n  let topView = ContentView.get(node);\n  if (topView instanceof CompositionView) topView = topView.widget.topView;else if (topView) topView.parent = null;\n  return Decoration.set(Decoration.replace({\n    widget: new CompositionWidget(node, textNode, topView),\n    inclusive: true\n  }).range(newFrom, newTo));\n}\nclass CompositionWidget extends WidgetType {\n  constructor(top, text, topView) {\n    super();\n    this.top = top;\n    this.text = text;\n    this.topView = topView;\n  }\n  eq(other) {\n    return this.top == other.top && this.text == other.text;\n  }\n  toDOM() {\n    return this.top;\n  }\n  ignoreEvent() {\n    return false;\n  }\n  get customView() {\n    return CompositionView;\n  }\n}\nfunction nearbyTextNode(node, offset, side) {\n  for (;;) {\n    if (node.nodeType == 3) return node;\n    if (node.nodeType == 1 && offset > 0 && side <= 0) {\n      node = node.childNodes[offset - 1];\n      offset = maxOffset(node);\n    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      return null;\n    }\n  }\n}\nfunction nextToUneditable(node, offset) {\n  if (node.nodeType != 1) return 0;\n  return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */ : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */ : 0);\n}\nclass DecorationComparator$1 {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange(from, to) {\n    addRange(from, to, this.changes);\n  }\n  comparePoint(from, to) {\n    addRange(from, to, this.changes);\n  }\n}\nfunction findChangedDeco(a, b, diff) {\n  let comp = new DecorationComparator$1();\n  _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\n  return comp.changes;\n}\nfunction inUneditable(node, inside) {\n  for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {\n    if (cur.nodeType == 1 && cur.contentEditable == 'false') {\n      return true;\n    }\n  }\n  return false;\n}\nfunction groupAt(state, pos, bias = 1) {\n  let categorize = state.charCategorizer(pos);\n  let line = state.doc.lineAt(pos),\n    linePos = pos - line.from;\n  if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n  if (linePos == 0) bias = 1;else if (linePos == line.length) bias = -1;\n  let from = linePos,\n    to = linePos;\n  if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\n  let cat = categorize(line.text.slice(from, to));\n  while (from > 0) {\n    let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\n    if (categorize(line.text.slice(prev, from)) != cat) break;\n    from = prev;\n  }\n  while (to < line.length) {\n    let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\n    if (categorize(line.text.slice(to, next)) != cat) break;\n    to = next;\n  }\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n  return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n  return top < rect.top ? {\n    top,\n    left: rect.left,\n    right: rect.right,\n    bottom: rect.bottom\n  } : rect;\n}\nfunction upBot(rect, bottom) {\n  return bottom > rect.bottom ? {\n    top: rect.top,\n    left: rect.left,\n    right: rect.right,\n    bottom\n  } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n  let closest,\n    closestRect,\n    closestX,\n    closestY,\n    closestOverlap = false;\n  let above, below, aboveRect, belowRect;\n  for (let child = parent.firstChild; child; child = child.nextSibling) {\n    let rects = clientRectsFor(child);\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i];\n      if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n      let dx = getdx(x, rect),\n        dy = getdy(y, rect);\n      if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n      if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n        closest = child;\n        closestRect = rect;\n        closestX = dx;\n        closestY = dy;\n        let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;\n        closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);\n      }\n      if (dx == 0) {\n        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n          above = child;\n          aboveRect = rect;\n        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n          below = child;\n          belowRect = rect;\n        }\n      } else if (aboveRect && yOverlap(aboveRect, rect)) {\n        aboveRect = upBot(aboveRect, rect.bottom);\n      } else if (belowRect && yOverlap(belowRect, rect)) {\n        belowRect = upTop(belowRect, rect.top);\n      }\n    }\n  }\n  if (aboveRect && aboveRect.bottom >= y) {\n    closest = above;\n    closestRect = aboveRect;\n  } else if (belowRect && belowRect.top <= y) {\n    closest = below;\n    closestRect = belowRect;\n  }\n  if (!closest) return {\n    node: parent,\n    offset: 0\n  };\n  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n  if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n  if (closestOverlap && closest.contentEditable != \"false\") return domPosAtCoords(closest, clipX, y);\n  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n  return {\n    node: parent,\n    offset\n  };\n}\nfunction domPosInText(node, x, y) {\n  let len = node.nodeValue.length;\n  let closestOffset = -1,\n    closestDY = 1e9,\n    generalSide = 0;\n  for (let i = 0; i < len; i++) {\n    let rects = textRange(node, i, i + 1).getClientRects();\n    for (let j = 0; j < rects.length; j++) {\n      let rect = rects[j];\n      if (rect.top == rect.bottom) continue;\n      if (!generalSide) generalSide = x - rect.left;\n      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n        let right = x >= (rect.left + rect.right) / 2,\n          after = right;\n        if (browser.chrome || browser.gecko) {\n          // Check for RTL on browsers that support getting client\n          // rects for empty ranges.\n          let rectBefore = textRange(node, i).getBoundingClientRect();\n          if (rectBefore.left == rect.right) after = !right;\n        }\n        if (dy <= 0) return {\n          node,\n          offset: i + (after ? 1 : 0)\n        };\n        closestOffset = i + (after ? 1 : 0);\n        closestDY = dy;\n      }\n    }\n  }\n  return {\n    node,\n    offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n  };\n}\nfunction posAtCoords(view, {\n  x,\n  y\n}, precise, bias = -1) {\n  var _a;\n  let content = view.contentDOM.getBoundingClientRect(),\n    docTop = content.top + view.viewState.paddingTop;\n  let block,\n    {\n      docHeight\n    } = view.viewState;\n  let yOffset = y - docTop;\n  if (yOffset < 0) return 0;\n  if (yOffset > docHeight) return view.state.doc.length;\n  // Scan for a text block near the queried y position\n  for (let halfLine = view.defaultLineHeight / 2, bounced = false;;) {\n    block = view.elementAtHeight(yOffset);\n    if (block.type == BlockType.Text) break;\n    for (;;) {\n      // Move the y position out of this block\n      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n      if (yOffset >= 0 && yOffset <= docHeight) break;\n      // If the document consists entirely of replaced widgets, we\n      // won't find a text block, so return 0\n      if (bounced) return precise ? null : 0;\n      bounced = true;\n      bias = -bias;\n    }\n  }\n  y = docTop + yOffset;\n  let lineStart = block.from;\n  // If this is outside of the rendered viewport, we can't determine a position\n  if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n  if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n  // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n  let doc = view.dom.ownerDocument;\n  let root = view.root.elementFromPoint ? view.root : doc;\n  let element = root.elementFromPoint(x, y);\n  if (element && !view.contentDOM.contains(element)) element = null;\n  // If the element is unexpected, clip x at the sides of the content area and try again\n  if (!element) {\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n  }\n  // There's visible editor content under the point, so we can try\n  // using caret(Position|Range)FromPoint as a shortcut\n  let node,\n    offset = -1;\n  if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n    if (doc.caretPositionFromPoint) {\n      let pos = doc.caretPositionFromPoint(x, y);\n      if (pos) ({\n        offsetNode: node,\n        offset\n      } = pos);\n    } else if (doc.caretRangeFromPoint) {\n      let range = doc.caretRangeFromPoint(x, y);\n      if (range) {\n        ({\n          startContainer: node,\n          startOffset: offset\n        } = range);\n        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;\n      }\n    }\n  }\n  // No luck, do our own (potentially expensive) search\n  if (!node || !view.docView.dom.contains(node)) {\n    let line = LineView.find(view.docView, lineStart);\n    if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n    ({\n      node,\n      offset\n    } = domPosAtCoords(line.dom, x, y));\n  }\n  return view.docView.posFromDOM(node, offset);\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n    let line = Math.floor((y - block.top) / view.defaultLineHeight);\n    into += line * view.viewState.heightOracle.lineLength;\n  }\n  let content = view.state.sliceDoc(block.from, block.to);\n  return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n  let len;\n  if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n  for (let next = node.nextSibling; next; next = next.nextSibling) if (next.nodeType != 1 || next.nodeName != \"BR\") return false;\n  return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n  if (offset != 0) return false;\n  for (let cur = node;;) {\n    let parent = cur.parentNode;\n    if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;\n    if (parent.classList.contains(\"cm-line\")) break;\n    cur = parent;\n  }\n  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n  return x - rect.left > 5;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n  let line = view.state.doc.lineAt(start.head);\n  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n  if (coords) {\n    let editorRect = view.dom.getBoundingClientRect();\n    let direction = view.textDirectionAt(line.from);\n    let pos = view.posAtCoords({\n      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n      y: (coords.top + coords.bottom) / 2\n    });\n    if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\n  }\n  let lineView = LineView.find(view.docView, start.head);\n  let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(end, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n  let line = view.state.doc.lineAt(start.head),\n    spans = view.bidiSpans(line);\n  let direction = view.textDirectionAt(line.from);\n  for (let cur = start, check = null;;) {\n    let next = moveVisually(line, spans, direction, cur, forward),\n      char = movedOver;\n    if (!next) {\n      if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n      char = \"\\n\";\n      line = view.state.doc.line(line.number + (forward ? 1 : -1));\n      spans = view.bidiSpans(line);\n      next = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.from : line.to);\n    }\n    if (!check) {\n      if (!by) return next;\n      check = by(char);\n    } else if (!check(char)) {\n      return cur;\n    }\n    cur = next;\n  }\n}\nfunction byGroup(view, pos, start) {\n  let categorize = view.state.charCategorizer(pos);\n  let cat = categorize(start);\n  return next => {\n    let nextCat = categorize(next);\n    if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space) cat = nextCat;\n    return cat == nextCat;\n  };\n}\nfunction moveVertically(view, start, forward, distance) {\n  let startPos = start.head,\n    dir = forward ? 1 : -1;\n  if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\n  let goal = start.goalColumn,\n    startY;\n  let rect = view.contentDOM.getBoundingClientRect();\n  let startCoords = view.coordsAtPos(startPos),\n    docTop = view.documentTop;\n  if (startCoords) {\n    if (goal == null) goal = startCoords.left - rect.left;\n    startY = dir < 0 ? startCoords.top : startCoords.bottom;\n  } else {\n    let line = view.viewState.lineBlockAt(startPos);\n    if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n    startY = (dir < 0 ? line.top : line.bottom) + docTop;\n  }\n  let resolvedGoal = rect.left + goal;\n  let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;\n  for (let extra = 0;; extra += 10) {\n    let curY = startY + (dist + extra) * dir;\n    let pos = posAtCoords(view, {\n      x: resolvedGoal,\n      y: curY\n    }, false, dir);\n    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, start.assoc, undefined, goal);\n  }\n}\nfunction skipAtoms(view, oldPos, pos) {\n  let atoms = view.state.facet(atomicRanges).map(f => f(view));\n  for (;;) {\n    let moved = false;\n    for (let set of atoms) {\n      set.between(pos.from - 1, pos.from + 1, (from, to, value) => {\n        if (pos.from > from && pos.from < to) {\n          pos = oldPos.head > pos.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(from, 1) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to, -1);\n          moved = true;\n        }\n      });\n    }\n    if (!moved) return pos;\n  }\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n  constructor(view) {\n    this.lastKeyCode = 0;\n    this.lastKeyTime = 0;\n    this.lastTouchTime = 0;\n    this.lastFocusTime = 0;\n    this.lastScrollTop = 0;\n    this.lastScrollLeft = 0;\n    this.chromeScrollHack = -1;\n    // On iOS, some keys need to have their default behavior happen\n    // (after which we retroactively handle them and reset the DOM) to\n    // avoid messing up the virtual keyboard state.\n    this.pendingIOSKey = undefined;\n    this.lastSelectionOrigin = null;\n    this.lastSelectionTime = 0;\n    this.lastEscPress = 0;\n    this.lastContextMenu = 0;\n    this.scrollHandlers = [];\n    this.registeredEvents = [];\n    this.customHandlers = [];\n    // -1 means not in a composition. Otherwise, this counts the number\n    // of changes made during the composition. The count is used to\n    // avoid treating the start state of the composition, before any\n    // changes have been made, as part of the composition.\n    this.composing = -1;\n    // Tracks whether the next change should be marked as starting the\n    // composition (null means no composition, true means next is the\n    // first, false means first has already been marked for this\n    // composition)\n    this.compositionFirstChange = null;\n    this.compositionEndedAt = 0;\n    this.mouseSelection = null;\n    let handleEvent = (handler, event) => {\n      if (this.ignoreDuringComposition(event)) return;\n      if (event.type == \"keydown\" && this.keydown(view, event)) return;\n      if (this.mustFlushObserver(event)) view.observer.forceFlush();\n      if (this.runCustomHandlers(event.type, view, event)) event.preventDefault();else handler(view, event);\n    };\n    for (let type in handlers) {\n      let handler = handlers[type];\n      view.contentDOM.addEventListener(type, event => {\n        if (eventBelongsToEditor(view, event)) handleEvent(handler, event);\n      }, handlerOptions[type]);\n      this.registeredEvents.push(type);\n    }\n    view.scrollDOM.addEventListener(\"mousedown\", event => {\n      if (event.target == view.scrollDOM && event.clientY > view.contentDOM.getBoundingClientRect().bottom) handleEvent(handlers.mousedown, event);\n    });\n    if (browser.chrome && browser.chrome_version == 102) {\n      // FIXME remove at some point\n      // On Chrome 102, viewport updates somehow stop wheel-based\n      // scrolling. Turning off pointer events during the scroll seems\n      // to avoid the issue.\n      view.scrollDOM.addEventListener(\"wheel\", () => {\n        if (this.chromeScrollHack < 0) view.contentDOM.style.pointerEvents = \"none\";else window.clearTimeout(this.chromeScrollHack);\n        this.chromeScrollHack = setTimeout(() => {\n          this.chromeScrollHack = -1;\n          view.contentDOM.style.pointerEvents = \"\";\n        }, 100);\n      }, {\n        passive: true\n      });\n    }\n    this.notifiedFocused = view.hasFocus;\n    // On Safari adding an input event handler somehow prevents an\n    // issue where the composition vanishes when you press enter.\n    if (browser.safari) view.contentDOM.addEventListener(\"input\", () => null);\n  }\n  setSelectionOrigin(origin) {\n    this.lastSelectionOrigin = origin;\n    this.lastSelectionTime = Date.now();\n  }\n  ensureHandlers(view, plugins) {\n    var _a;\n    let handlers;\n    this.customHandlers = [];\n    for (let plugin of plugins) if (handlers = (_a = plugin.update(view).spec) === null || _a === void 0 ? void 0 : _a.domEventHandlers) {\n      this.customHandlers.push({\n        plugin: plugin.value,\n        handlers\n      });\n      for (let type in handlers) if (this.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\n        this.registeredEvents.push(type);\n        view.contentDOM.addEventListener(type, event => {\n          if (!eventBelongsToEditor(view, event)) return;\n          if (this.runCustomHandlers(type, view, event)) event.preventDefault();\n        });\n      }\n    }\n  }\n  runCustomHandlers(type, view, event) {\n    for (let set of this.customHandlers) {\n      let handler = set.handlers[type];\n      if (handler) {\n        try {\n          if (handler.call(set.plugin, event, view) || event.defaultPrevented) return true;\n        } catch (e) {\n          logException(view.state, e);\n        }\n      }\n    }\n    return false;\n  }\n  runScrollHandlers(view, event) {\n    this.lastScrollTop = view.scrollDOM.scrollTop;\n    this.lastScrollLeft = view.scrollDOM.scrollLeft;\n    for (let set of this.customHandlers) {\n      let handler = set.handlers.scroll;\n      if (handler) {\n        try {\n          handler.call(set.plugin, event, view);\n        } catch (e) {\n          logException(view.state, e);\n        }\n      }\n    }\n  }\n  keydown(view, event) {\n    // Must always run, even if a custom handler handled the event\n    this.lastKeyCode = event.keyCode;\n    this.lastKeyTime = Date.now();\n    if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000) return true;\n    // Chrome for Android usually doesn't fire proper key events, but\n    // occasionally does, usually surrounded by a bunch of complicated\n    // composition changes. When an enter or backspace key event is\n    // seen, hold off on handling DOM events for a bit, and then\n    // dispatch it.\n    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n      view.observer.delayAndroidKey(event.key, event.keyCode);\n      return true;\n    }\n    // Prevent the default behavior of Enter on iOS makes the\n    // virtual keyboard get stuck in the wrong (lowercase)\n    // state. So we let it go through, and then, in\n    // applyDOMChange, notify key handlers of it and reset to\n    // the state they produce.\n    let pending;\n    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n      this.pendingIOSKey = pending || event;\n      setTimeout(() => this.flushIOSKey(view), 250);\n      return true;\n    }\n    return false;\n  }\n  flushIOSKey(view) {\n    let key = this.pendingIOSKey;\n    if (!key) return false;\n    this.pendingIOSKey = undefined;\n    return dispatchKey(view.contentDOM, key.key, key.keyCode);\n  }\n  ignoreDuringComposition(event) {\n    if (!/^key/.test(event.type)) return false;\n    if (this.composing > 0) return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On some input method editors (IMEs), the Enter key is used to\n    // confirm character selection. On Safari, when Enter is pressed,\n    // compositionend and keydown events are sometimes emitted in the\n    // wrong order. The key event should still be ignored, even when\n    // it happens after the compositionend event.\n    if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {\n      this.compositionEndedAt = 0;\n      return true;\n    }\n    return false;\n  }\n  mustFlushObserver(event) {\n    return event.type == \"keydown\" && event.keyCode != 229;\n  }\n  startMouseSelection(mouseSelection) {\n    if (this.mouseSelection) this.mouseSelection.destroy();\n    this.mouseSelection = mouseSelection;\n  }\n  update(update) {\n    if (this.mouseSelection) this.mouseSelection.update(update);\n    if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n  }\n  destroy() {\n    if (this.mouseSelection) this.mouseSelection.destroy();\n  }\n}\nconst PendingKeys = [{\n  key: \"Backspace\",\n  keyCode: 8,\n  inputType: \"deleteContentBackward\"\n}, {\n  key: \"Enter\",\n  keyCode: 13,\n  inputType: \"insertParagraph\"\n}, {\n  key: \"Delete\",\n  keyCode: 46,\n  inputType: \"deleteContentForward\"\n}];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\nfunction dragScrollSpeed(dist) {\n  return dist * 0.7 + 8;\n}\nclass MouseSelection {\n  constructor(view, startEvent, style, mustSelect) {\n    this.view = view;\n    this.style = style;\n    this.mustSelect = mustSelect;\n    this.scrollSpeed = {\n      x: 0,\n      y: 0\n    };\n    this.scrolling = -1;\n    this.lastEvent = startEvent;\n    this.scrollParent = scrollableParent(view.contentDOM);\n    let doc = view.contentDOM.ownerDocument;\n    doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    this.extend = startEvent.shiftKey;\n    this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n    this.dragMove = dragMovesSelection(view, startEvent);\n    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n  }\n  start(event) {\n    // When clicking outside of the selection, immediately apply the\n    // effect of starting the selection\n    if (this.dragging === false) {\n      event.preventDefault();\n      this.select(event);\n    }\n  }\n  move(event) {\n    var _a;\n    if (event.buttons == 0) return this.destroy();\n    if (this.dragging !== false) return;\n    this.select(this.lastEvent = event);\n    let sx = 0,\n      sy = 0;\n    let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {\n      left: 0,\n      top: 0,\n      right: this.view.win.innerWidth,\n      bottom: this.view.win.innerHeight\n    };\n    if (event.clientX <= rect.left) sx = -dragScrollSpeed(rect.left - event.clientX);else if (event.clientX >= rect.right) sx = dragScrollSpeed(event.clientX - rect.right);\n    if (event.clientY <= rect.top) sy = -dragScrollSpeed(rect.top - event.clientY);else if (event.clientY >= rect.bottom) sy = dragScrollSpeed(event.clientY - rect.bottom);\n    this.setScrollSpeed(sx, sy);\n  }\n  up(event) {\n    if (this.dragging == null) this.select(this.lastEvent);\n    if (!this.dragging) event.preventDefault();\n    this.destroy();\n  }\n  destroy() {\n    this.setScrollSpeed(0, 0);\n    let doc = this.view.contentDOM.ownerDocument;\n    doc.removeEventListener(\"mousemove\", this.move);\n    doc.removeEventListener(\"mouseup\", this.up);\n    this.view.inputState.mouseSelection = null;\n  }\n  setScrollSpeed(sx, sy) {\n    this.scrollSpeed = {\n      x: sx,\n      y: sy\n    };\n    if (sx || sy) {\n      if (this.scrolling < 0) this.scrolling = setInterval(() => this.scroll(), 50);\n    } else if (this.scrolling > -1) {\n      clearInterval(this.scrolling);\n      this.scrolling = -1;\n    }\n  }\n  scroll() {\n    if (this.scrollParent) {\n      this.scrollParent.scrollLeft += this.scrollSpeed.x;\n      this.scrollParent.scrollTop += this.scrollSpeed.y;\n    } else {\n      this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);\n    }\n    if (this.dragging === false) this.select(this.lastEvent);\n  }\n  select(event) {\n    let selection = this.style.get(event, this.extend, this.multiple);\n    if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc) this.view.dispatch({\n      selection,\n      userEvent: \"select.pointer\"\n    });\n    this.mustSelect = false;\n  }\n  update(update) {\n    if (update.docChanged && this.dragging) this.dragging = this.dragging.map(update.changes);\n    if (this.style.update(update)) setTimeout(() => this.select(this.lastEvent), 20);\n  }\n}\nfunction addsSelectionRange(view, event) {\n  let facet = view.state.facet(clickAddsSelectionRange);\n  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n  let facet = view.state.facet(dragMovesSelection$1);\n  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n  let {\n    main\n  } = view.state.selection;\n  if (main.empty) return false;\n  // On boundary clicks, check whether the coordinates are inside the\n  // selection's client rectangles\n  let sel = getSelection(view.root);\n  if (!sel || sel.rangeCount == 0) return true;\n  let rects = sel.getRangeAt(0).getClientRects();\n  for (let i = 0; i < rects.length; i++) {\n    let rect = rects[i];\n    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n  }\n  return false;\n}\nfunction eventBelongsToEditor(view, event) {\n  if (!event.bubbles) return true;\n  if (event.defaultPrevented) return false;\n  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n  return true;\n}\nconst handlers = /*@__PURE__*/Object.create(null);\nconst handlerOptions = /*@__PURE__*/Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n  let parent = view.dom.parentNode;\n  if (!parent) return;\n  let target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(() => {\n    view.focus();\n    target.remove();\n    doPaste(view, target.value);\n  }, 50);\n}\nfunction doPaste(view, input) {\n  let {\n      state\n    } = view,\n    changes,\n    i = 1,\n    text = state.toText(input);\n  let byLine = text.lines == state.selection.ranges.length;\n  let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\n  if (linewise) {\n    let lastLine = -1;\n    changes = state.changeByRange(range => {\n      let line = state.doc.lineAt(range.from);\n      if (line.from == lastLine) return {\n        range\n      };\n      lastLine = line.from;\n      let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n      return {\n        changes: {\n          from: line.from,\n          insert\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length)\n      };\n    });\n  } else if (byLine) {\n    changes = state.changeByRange(range => {\n      let line = text.line(i++);\n      return {\n        changes: {\n          from: range.from,\n          to: range.to,\n          insert: line.text\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length)\n      };\n    });\n  } else {\n    changes = state.replaceSelection(text);\n  }\n  view.dispatch(changes, {\n    userEvent: \"input.paste\",\n    scrollIntoView: true\n  });\n}\nhandlers.keydown = (view, event) => {\n  view.inputState.setSelectionOrigin(\"select\");\n  if (event.keyCode == 27) view.inputState.lastEscPress = Date.now();else if (modifierCodes.indexOf(event.keyCode) < 0) view.inputState.lastEscPress = 0;\n};\nhandlers.touchstart = (view, e) => {\n  view.inputState.lastTouchTime = Date.now();\n  view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.touchmove = view => {\n  view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlerOptions.touchstart = handlerOptions.touchmove = {\n  passive: true\n};\nhandlers.mousedown = (view, event) => {\n  view.observer.flush();\n  if (view.inputState.lastTouchTime > Date.now() - 2000) return; // Ignore touch interaction\n  let style = null;\n  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\n    style = makeStyle(view, event);\n    if (style) break;\n  }\n  if (!style && event.button == 0) style = basicMouseSelection(view, event);\n  if (style) {\n    let mustFocus = view.root.activeElement != view.contentDOM;\n    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n    if (mustFocus) view.observer.ignore(() => focusPreventScroll(view.contentDOM));\n    if (view.inputState.mouseSelection) view.inputState.mouseSelection.start(event);\n  }\n};\nfunction rangeForClick(view, pos, bias, type) {\n  if (type == 1) {\n    // Single click\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\n  } else if (type == 2) {\n    // Double click\n    return groupAt(view.state, pos, bias);\n  } else {\n    // Triple click\n    let visual = LineView.find(view.docView, pos),\n      line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n    let from = visual ? visual.posAtStart : line.from,\n      to = visual ? visual.posAtEnd : line.to;\n    if (to < view.state.doc.length && to == line.to) to++;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n  }\n}\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n  let line = LineView.find(view.docView, pos);\n  if (!line) return 1;\n  let off = pos - line.posAtStart;\n  // Line boundaries point into the line\n  if (off == 0) return 1;\n  if (off == line.length) return -1;\n  // Positions on top of an element point at that element\n  let before = line.coordsAt(off, -1);\n  if (before && inside(x, y, before)) return -1;\n  let after = line.coordsAt(off, 1);\n  if (after && inside(x, y, after)) return 1;\n  // This is probably a line wrap point. Pick before if the point is\n  // beside it.\n  return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n  let pos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  return {\n    pos,\n    bias: findPositionSide(view, pos, event.clientX, event.clientY)\n  };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null,\n  lastMouseDownCount = 0,\n  lastMouseDownTime = 0;\nfunction getClickType(event) {\n  if (!BadMouseDetail) return event.detail;\n  let last = lastMouseDown,\n    lastTime = lastMouseDownTime;\n  lastMouseDown = event;\n  lastMouseDownTime = Date.now();\n  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n  let start = queryPos(view, event),\n    type = getClickType(event);\n  let startSel = view.state.selection;\n  return {\n    update(update) {\n      if (update.docChanged) {\n        start.pos = update.changes.mapPos(start.pos);\n        startSel = startSel.map(update.changes);\n      }\n    },\n    get(event, extend, multiple) {\n      let cur = queryPos(view, event);\n      let range = rangeForClick(view, cur.pos, cur.bias, type);\n      if (start.pos != cur.pos && !extend) {\n        let startRange = rangeForClick(view, start.pos, start.bias, type);\n        let from = Math.min(startRange.from, range.from),\n          to = Math.max(startRange.to, range.to);\n        range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\n      }\n      if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some(r => r.eq(range))) return removeRange(startSel, range);else if (multiple) return startSel.addRange(range);else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([range]);\n    }\n  };\n}\nfunction removeRange(sel, range) {\n  for (let i = 0;; i++) {\n    if (sel.ranges[i].eq(range)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n  }\n}\nhandlers.dragstart = (view, event) => {\n  let {\n    selection: {\n      main\n    }\n  } = view.state;\n  let {\n    mouseSelection\n  } = view.inputState;\n  if (mouseSelection) mouseSelection.dragging = main;\n  if (event.dataTransfer) {\n    event.dataTransfer.setData(\"Text\", view.state.sliceDoc(main.from, main.to));\n    event.dataTransfer.effectAllowed = \"copyMove\";\n  }\n};\nfunction dropText(view, event, text, direct) {\n  if (!text) return;\n  let dropPos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  event.preventDefault();\n  let {\n    mouseSelection\n  } = view.inputState;\n  let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {\n    from: mouseSelection.dragging.from,\n    to: mouseSelection.dragging.to\n  } : null;\n  let ins = {\n    from: dropPos,\n    insert: text\n  };\n  let changes = view.state.changes(del ? [del, ins] : ins);\n  view.focus();\n  view.dispatch({\n    changes,\n    selection: {\n      anchor: changes.mapPos(dropPos, -1),\n      head: changes.mapPos(dropPos, 1)\n    },\n    userEvent: del ? \"move.drop\" : \"input.drop\"\n  });\n}\nhandlers.drop = (view, event) => {\n  if (!event.dataTransfer) return;\n  if (view.state.readOnly) return event.preventDefault();\n  let files = event.dataTransfer.files;\n  if (files && files.length) {\n    // For a file drop, read the file's text.\n    event.preventDefault();\n    let text = Array(files.length),\n      read = 0;\n    let finishFile = () => {\n      if (++read == files.length) dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);\n    };\n    for (let i = 0; i < files.length; i++) {\n      let reader = new FileReader();\n      reader.onerror = finishFile;\n      reader.onload = () => {\n        if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n        finishFile();\n      };\n      reader.readAsText(files[i]);\n    }\n  } else {\n    dropText(view, event, event.dataTransfer.getData(\"Text\"), true);\n  }\n};\nhandlers.paste = (view, event) => {\n  if (view.state.readOnly) return event.preventDefault();\n  view.observer.flush();\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  if (data) {\n    doPaste(view, data.getData(\"text/plain\"));\n    event.preventDefault();\n  } else {\n    capturePaste(view);\n  }\n};\nfunction captureCopy(view, text) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  let parent = view.dom.parentNode;\n  if (!parent) return;\n  let target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.value = text;\n  target.focus();\n  target.selectionEnd = text.length;\n  target.selectionStart = 0;\n  setTimeout(() => {\n    target.remove();\n    view.focus();\n  }, 50);\n}\nfunction copiedRange(state) {\n  let content = [],\n    ranges = [],\n    linewise = false;\n  for (let range of state.selection.ranges) if (!range.empty) {\n    content.push(state.sliceDoc(range.from, range.to));\n    ranges.push(range);\n  }\n  if (!content.length) {\n    // Nothing selected, do a line-wise copy\n    let upto = -1;\n    for (let {\n      from\n    } of state.selection.ranges) {\n      let line = state.doc.lineAt(from);\n      if (line.number > upto) {\n        content.push(line.text);\n        ranges.push({\n          from: line.from,\n          to: Math.min(state.doc.length, line.to + 1)\n        });\n      }\n      upto = line.number;\n    }\n    linewise = true;\n  }\n  return {\n    text: content.join(state.lineBreak),\n    ranges,\n    linewise\n  };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event) => {\n  let {\n    text,\n    ranges,\n    linewise\n  } = copiedRange(view.state);\n  if (!text && !linewise) return;\n  lastLinewiseCopy = linewise ? text : null;\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  if (data) {\n    event.preventDefault();\n    data.clearData();\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, text);\n  }\n  if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n    changes: ranges,\n    scrollIntoView: true,\n    userEvent: \"delete.cut\"\n  });\n};\nfunction updateForFocusChange(view) {\n  setTimeout(() => {\n    if (view.hasFocus != view.inputState.notifiedFocused) view.update([]);\n  }, 10);\n}\nhandlers.focus = view => {\n  view.inputState.lastFocusTime = Date.now();\n  // When focusing reset the scroll position, move it back to where it was\n  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n  }\n  updateForFocusChange(view);\n};\nhandlers.blur = view => {\n  view.observer.clearSelectionRange();\n  updateForFocusChange(view);\n};\nhandlers.compositionstart = handlers.compositionupdate = view => {\n  if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n  if (view.inputState.composing < 0) {\n    // FIXME possibly set a timeout to clear it again on Android\n    view.inputState.composing = 0;\n  }\n};\nhandlers.compositionend = view => {\n  view.inputState.composing = -1;\n  view.inputState.compositionEndedAt = Date.now();\n  view.inputState.compositionFirstChange = null;\n  if (browser.chrome && browser.android) view.observer.flushSoon();\n  setTimeout(() => {\n    // Force the composition state to be cleared if it hasn't already been\n    if (view.inputState.composing < 0 && view.docView.compositionDeco.size) view.update([]);\n  }, 50);\n};\nhandlers.contextmenu = view => {\n  view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event) => {\n  var _a;\n  // Because Chrome Android doesn't fire useful key events, use\n  // beforeinput to detect backspace (and possibly enter and delete,\n  // but those usually don't even seem to fire beforeinput events at\n  // the moment) and fake a key event for it.\n  //\n  // (preventDefault on beforeinput, though supported in the spec,\n  // seems to do nothing at all on Chrome).\n  let pending;\n  if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {\n    view.observer.delayAndroidKey(pending.key, pending.keyCode);\n    if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n      let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\n      setTimeout(() => {\n        var _a;\n        // Backspacing near uneditable nodes on Chrome Android sometimes\n        // closes the virtual keyboard. This tries to crudely detect\n        // that and refocus to get it back.\n        if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n          view.contentDOM.blur();\n          view.focus();\n        }\n      }, 100);\n    }\n  }\n};\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\", \"break-spaces\"];\nclass HeightOracle {\n  constructor(lineWrapping) {\n    this.lineWrapping = lineWrapping;\n    this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    this.heightSamples = {};\n    this.lineHeight = 14;\n    this.charWidth = 7;\n    this.lineLength = 30;\n    // Used to track, during updateHeight, if any actual heights changed\n    this.heightChanged = false;\n  }\n  heightForGap(from, to) {\n    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n    if (this.lineWrapping) lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);\n    return this.lineHeight * lines;\n  }\n  heightForLine(length) {\n    if (!this.lineWrapping) return this.lineHeight;\n    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n    return lines * this.lineHeight;\n  }\n  setDoc(doc) {\n    this.doc = doc;\n    return this;\n  }\n  mustRefreshForWrapping(whiteSpace) {\n    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n  }\n  mustRefreshForHeights(lineHeights) {\n    let newHeight = false;\n    for (let i = 0; i < lineHeights.length; i++) {\n      let h = lineHeights[i];\n      if (h < 0) {\n        i++;\n      } else if (!this.heightSamples[Math.floor(h * 10)]) {\n        // Round to .1 pixels\n        newHeight = true;\n        this.heightSamples[Math.floor(h * 10)] = true;\n      }\n    }\n    return newHeight;\n  }\n  refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {\n    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n    this.lineWrapping = lineWrapping;\n    this.lineHeight = lineHeight;\n    this.charWidth = charWidth;\n    this.lineLength = lineLength;\n    if (changed) {\n      this.heightSamples = {};\n      for (let i = 0; i < knownHeights.length; i++) {\n        let h = knownHeights[i];\n        if (h < 0) i++;else this.heightSamples[Math.floor(h * 10)] = true;\n      }\n    }\n    return changed;\n  }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n  constructor(from, heights) {\n    this.from = from;\n    this.heights = heights;\n    this.index = 0;\n  }\n  get more() {\n    return this.index < this.heights.length;\n  }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/\nclass BlockInfo {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The start of the element in the document.\n  */\n  from,\n  /**\n  The length of the element.\n  */\n  length,\n  /**\n  The top position of the element (relative to the top of the\n  document).\n  */\n  top,\n  /**\n  Its height.\n  */\n  height,\n  /**\n  The type of element this is. When querying lines, this may be\n  an array of all the blocks that make up the line.\n  */\n  type) {\n    this.from = from;\n    this.length = length;\n    this.top = top;\n    this.height = height;\n    this.type = type;\n  }\n  /**\n  The end of the element as a document position.\n  */\n  get to() {\n    return this.from + this.length;\n  }\n  /**\n  The bottom position of the element.\n  */\n  get bottom() {\n    return this.top + this.height;\n  }\n  /**\n  @internal\n  */\n  join(other) {\n    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);\n    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n  }\n}\nvar QueryType = /*@__PURE__*/function (QueryType) {\n  QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n  QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n  QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n  return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n  constructor(length,\n  // The number of characters covered\n  height,\n  // Height of this part of the document\n  flags = 2 /* Flag.Outdated */) {\n    this.length = length;\n    this.height = height;\n    this.flags = flags;\n  }\n  get outdated() {\n    return (this.flags & 2 /* Flag.Outdated */) > 0;\n  }\n  set outdated(value) {\n    this.flags = (value ? 2 /* Flag.Outdated */ : 0) | this.flags & ~2 /* Flag.Outdated */;\n  }\n  setHeight(oracle, height) {\n    if (this.height != height) {\n      if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;\n      this.height = height;\n    }\n  }\n  // Base case is to replace a leaf node, which simply builds a tree\n  // from the new nodes and returns that (HeightMapBranch and\n  // HeightMapGap override this to actually use from/to)\n  replace(_from, _to, nodes) {\n    return HeightMap.of(nodes);\n  }\n  // Again, these are base cases, and are overridden for branch and gap nodes.\n  decomposeLeft(_to, result) {\n    result.push(this);\n  }\n  decomposeRight(_from, result) {\n    result.push(this);\n  }\n  applyChanges(decorations, oldDoc, oracle, changes) {\n    let me = this;\n    for (let i = changes.length - 1; i >= 0; i--) {\n      let {\n        fromA,\n        toA,\n        fromB,\n        toB\n      } = changes[i];\n      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n      toB += end.to - toA;\n      toA = end.to;\n      while (i > 0 && start.from <= changes[i - 1].toA) {\n        fromA = changes[i - 1].fromA;\n        fromB = changes[i - 1].fromB;\n        i--;\n        if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n      }\n      fromB += start.from - fromA;\n      fromA = start.from;\n      let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n      me = me.replace(fromA, toA, nodes);\n    }\n    return me.updateHeight(oracle, 0);\n  }\n  static empty() {\n    return new HeightMapText(0, 0);\n  }\n  // nodes uses null values to indicate the position of line breaks.\n  // There are never line breaks at the start or end of the array, or\n  // two line breaks next to each other, and the array isn't allowed\n  // to be empty (same restrictions as return value from the builder).\n  static of(nodes) {\n    if (nodes.length == 1) return nodes[0];\n    let i = 0,\n      j = nodes.length,\n      before = 0,\n      after = 0;\n    for (;;) {\n      if (i == j) {\n        if (before > after * 2) {\n          let split = nodes[i - 1];\n          if (split.break) nodes.splice(--i, 1, split.left, null, split.right);else nodes.splice(--i, 1, split.left, split.right);\n          j += 1 + split.break;\n          before -= split.size;\n        } else if (after > before * 2) {\n          let split = nodes[j];\n          if (split.break) nodes.splice(j, 1, split.left, null, split.right);else nodes.splice(j, 1, split.left, split.right);\n          j += 2 + split.break;\n          after -= split.size;\n        } else {\n          break;\n        }\n      } else if (before < after) {\n        let next = nodes[i++];\n        if (next) before += next.size;\n      } else {\n        let next = nodes[--j];\n        if (next) after += next.size;\n      }\n    }\n    let brk = 0;\n    if (nodes[i - 1] == null) {\n      brk = 1;\n      i--;\n    } else if (nodes[i] == null) {\n      brk = 1;\n      j++;\n    }\n    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n  }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n  constructor(length, height, type) {\n    super(length, height);\n    this.type = type;\n  }\n  blockAt(_height, _doc, top, offset) {\n    return new BlockInfo(offset, this.length, top, this.height, this.type);\n  }\n  lineAt(_value, _type, doc, top, offset) {\n    return this.blockAt(0, doc, top, offset);\n  }\n  forEachLine(from, to, doc, top, offset, f) {\n    if (from <= offset + this.length && to >= offset) f(this.blockAt(0, doc, top, offset));\n  }\n  updateHeight(oracle, offset = 0, _force = false, measured) {\n    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return `block(${this.length})`;\n  }\n}\nclass HeightMapText extends HeightMapBlock {\n  constructor(length, height) {\n    super(length, height, BlockType.Text);\n    this.collapsed = 0; // Amount of collapsed content in the line\n    this.widgetHeight = 0; // Maximum inline widget height\n  }\n\n  replace(_from, _to, nodes) {\n    let node = nodes[0];\n    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */) && Math.abs(this.length - node.length) < 10) {\n      if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);else node.height = this.height;\n      if (!this.outdated) node.outdated = false;\n      return node;\n    } else {\n      return HeightMap.of(nodes);\n    }\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n  }\n}\nclass HeightMapGap extends HeightMap {\n  constructor(length) {\n    super(length, 0);\n  }\n  lines(doc, offset) {\n    let firstLine = doc.lineAt(offset).number,\n      lastLine = doc.lineAt(offset + this.length).number;\n    return {\n      firstLine,\n      lastLine,\n      lineHeight: this.height / (lastLine - firstLine + 1)\n    };\n  }\n  blockAt(height, doc, top, offset) {\n    let {\n      firstLine,\n      lastLine,\n      lineHeight\n    } = this.lines(doc, offset);\n    let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n    let {\n      from,\n      length\n    } = doc.line(firstLine + line);\n    return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);\n  }\n  lineAt(value, type, doc, top, offset) {\n    if (type == QueryType.ByHeight) return this.blockAt(value, doc, top, offset);\n    if (type == QueryType.ByPosNoHeight) {\n      let {\n        from,\n        to\n      } = doc.lineAt(value);\n      return new BlockInfo(from, to - from, 0, 0, BlockType.Text);\n    }\n    let {\n      firstLine,\n      lineHeight\n    } = this.lines(doc, offset);\n    let {\n      from,\n      length,\n      number\n    } = doc.lineAt(value);\n    return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n  }\n  forEachLine(from, to, doc, top, offset, f) {\n    let {\n      firstLine,\n      lineHeight\n    } = this.lines(doc, offset);\n    for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {\n      let line = doc.lineAt(pos);\n      if (pos == from) top += lineHeight * (line.number - firstLine);\n      f(new BlockInfo(line.from, line.length, top, lineHeight, BlockType.Text));\n      top += lineHeight;\n      pos = line.to + 1;\n    }\n  }\n  replace(from, to, nodes) {\n    let after = this.length - to;\n    if (after > 0) {\n      let last = nodes[nodes.length - 1];\n      if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);else nodes.push(null, new HeightMapGap(after - 1));\n    }\n    if (from > 0) {\n      let first = nodes[0];\n      if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);else nodes.unshift(new HeightMapGap(from - 1), null);\n    }\n    return HeightMap.of(nodes);\n  }\n  decomposeLeft(to, result) {\n    result.push(new HeightMapGap(to - 1), null);\n  }\n  decomposeRight(from, result) {\n    result.push(null, new HeightMapGap(this.length - from - 1));\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    let end = offset + this.length;\n    if (measured && measured.from <= offset + this.length && measured.more) {\n      // Fill in part of this gap with measured lines. We know there\n      // can't be widgets or collapsed ranges in those lines, because\n      // they would already have been added to the heightmap (gaps\n      // only contain plain text).\n      let nodes = [],\n        pos = Math.max(offset, measured.from),\n        singleHeight = -1;\n      let wasChanged = oracle.heightChanged;\n      if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n      while (pos <= end && measured.more) {\n        let len = oracle.doc.lineAt(pos).length;\n        if (nodes.length) nodes.push(null);\n        let height = measured.heights[measured.index++];\n        if (singleHeight == -1) singleHeight = height;else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n        let line = new HeightMapText(len, height);\n        line.outdated = false;\n        nodes.push(line);\n        pos += len + 1;\n      }\n      if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n      let result = HeightMap.of(nodes);\n      oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;\n      return result;\n    } else if (force || this.outdated) {\n      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n      this.outdated = false;\n    }\n    return this;\n  }\n  toString() {\n    return `gap(${this.length})`;\n  }\n}\nclass HeightMapBranch extends HeightMap {\n  constructor(left, brk, right) {\n    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));\n    this.left = left;\n    this.right = right;\n    this.size = left.size + right.size;\n  }\n  get break() {\n    return this.flags & 1 /* Flag.Break */;\n  }\n  blockAt(height, doc, top, offset) {\n    let mid = top + this.left.height;\n    return height < mid ? this.left.blockAt(height, doc, top, offset) : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n  }\n  lineAt(value, type, doc, top, offset) {\n    let rightTop = top + this.left.height,\n      rightOffset = offset + this.left.length + this.break;\n    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n    let base = left ? this.left.lineAt(value, type, doc, top, offset) : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n    if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n    if (left) return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));else return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n  }\n  forEachLine(from, to, doc, top, offset, f) {\n    let rightTop = top + this.left.height,\n      rightOffset = offset + this.left.length + this.break;\n    if (this.break) {\n      if (from < rightOffset) this.left.forEachLine(from, to, doc, top, offset, f);\n      if (to >= rightOffset) this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n    } else {\n      let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n      if (from < mid.from) this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n      if (mid.to >= from && mid.from <= to) f(mid);\n      if (to > mid.to) this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n    }\n  }\n  replace(from, to, nodes) {\n    let rightStart = this.left.length + this.break;\n    if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n    if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n    let result = [];\n    if (from > 0) this.decomposeLeft(from, result);\n    let left = result.length;\n    for (let node of nodes) result.push(node);\n    if (from > 0) mergeGaps(result, left - 1);\n    if (to < this.length) {\n      let right = result.length;\n      this.decomposeRight(to, result);\n      mergeGaps(result, right);\n    }\n    return HeightMap.of(result);\n  }\n  decomposeLeft(to, result) {\n    let left = this.left.length;\n    if (to <= left) return this.left.decomposeLeft(to, result);\n    result.push(this.left);\n    if (this.break) {\n      left++;\n      if (to >= left) result.push(null);\n    }\n    if (to > left) this.right.decomposeLeft(to - left, result);\n  }\n  decomposeRight(from, result) {\n    let left = this.left.length,\n      right = left + this.break;\n    if (from >= right) return this.right.decomposeRight(from - right, result);\n    if (from < left) this.left.decomposeRight(from, result);\n    if (this.break && from < right) result.push(null);\n    result.push(this.right);\n  }\n  balanced(left, right) {\n    if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n    this.left = left;\n    this.right = right;\n    this.height = left.height + right.height;\n    this.outdated = left.outdated || right.outdated;\n    this.size = left.size + right.size;\n    this.length = left.length + this.break + right.length;\n    return this;\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    let {\n        left,\n        right\n      } = this,\n      rightStart = offset + left.length + this.break,\n      rebalance = null;\n    if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);else left.updateHeight(oracle, offset, force);\n    if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);else right.updateHeight(oracle, rightStart, force);\n    if (rebalance) return this.balanced(left, right);\n    this.height = this.left.height + this.right.height;\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return this.left + (this.break ? \" \" : \"-\") + this.right;\n  }\n}\nfunction mergeGaps(nodes, around) {\n  let before, after;\n  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n  constructor(pos, oracle) {\n    this.pos = pos;\n    this.oracle = oracle;\n    this.nodes = [];\n    this.lineStart = -1;\n    this.lineEnd = -1;\n    this.covering = null;\n    this.writtenTo = pos;\n  }\n  get isCovered() {\n    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n  }\n  span(_from, to) {\n    if (this.lineStart > -1) {\n      let end = Math.min(to, this.lineEnd),\n        last = this.nodes[this.nodes.length - 1];\n      if (last instanceof HeightMapText) last.length += end - this.pos;else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n      this.writtenTo = end;\n      if (to > end) {\n        this.nodes.push(null);\n        this.writtenTo++;\n        this.lineStart = -1;\n      }\n    }\n    this.pos = to;\n  }\n  point(from, to, deco) {\n    if (from < to || deco.heightRelevant) {\n      let height = deco.widget ? deco.widget.estimatedHeight : 0;\n      if (height < 0) height = this.oracle.lineHeight;\n      let len = to - from;\n      if (deco.block) {\n        this.addBlock(new HeightMapBlock(len, height, deco.type));\n      } else if (len || height >= relevantWidgetHeight) {\n        this.addLineDeco(height, len);\n      }\n    } else if (to > from) {\n      this.span(from, to);\n    }\n    if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n  }\n  enterLine() {\n    if (this.lineStart > -1) return;\n    let {\n      from,\n      to\n    } = this.oracle.doc.lineAt(this.pos);\n    this.lineStart = from;\n    this.lineEnd = to;\n    if (this.writtenTo < from) {\n      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n      this.nodes.push(null);\n    }\n    if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n    this.writtenTo = this.pos;\n  }\n  blankContent(from, to) {\n    let gap = new HeightMapGap(to - from);\n    if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */;\n    return gap;\n  }\n  ensureLine() {\n    this.enterLine();\n    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n    if (last instanceof HeightMapText) return last;\n    let line = new HeightMapText(0, -1);\n    this.nodes.push(line);\n    return line;\n  }\n  addBlock(block) {\n    this.enterLine();\n    if (block.type == BlockType.WidgetAfter && !this.isCovered) this.ensureLine();\n    this.nodes.push(block);\n    this.writtenTo = this.pos = this.pos + block.length;\n    if (block.type != BlockType.WidgetBefore) this.covering = block;\n  }\n  addLineDeco(height, length) {\n    let line = this.ensureLine();\n    line.length += length;\n    line.collapsed += length;\n    line.widgetHeight = Math.max(line.widgetHeight, height);\n    this.writtenTo = this.pos = this.pos + length;\n  }\n  finish(from) {\n    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n    let pos = from;\n    for (let node of this.nodes) {\n      if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n      pos += node ? node.length : 1;\n    }\n    return this.nodes;\n  }\n  // Always called with a region that on both sides either stretches\n  // to a line break or the end of the document.\n  // The returned array uses null to indicate line breaks, but never\n  // starts or ends in a line break, or has multiple line breaks next\n  // to each other.\n  static build(oracle, decorations, from, to) {\n    let builder = new NodeBuilder(from, oracle);\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\n    return builder.finish(from);\n  }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n  let comp = new DecorationComparator();\n  _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\n  return comp.changes;\n}\nclass DecorationComparator {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange() {}\n  comparePoint(from, to, a, b) {\n    if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n  }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n  let rect = dom.getBoundingClientRect();\n  let doc = dom.ownerDocument,\n    win = doc.defaultView || window;\n  let left = Math.max(0, rect.left),\n    right = Math.min(win.innerWidth, rect.right);\n  let top = Math.max(0, rect.top),\n    bottom = Math.min(win.innerHeight, rect.bottom);\n  for (let parent = dom.parentNode; parent && parent != doc.body;) {\n    if (parent.nodeType == 1) {\n      let elt = parent;\n      let style = window.getComputedStyle(elt);\n      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n        let parentRect = elt.getBoundingClientRect();\n        left = Math.max(left, parentRect.left);\n        right = Math.min(right, parentRect.right);\n        top = Math.max(top, parentRect.top);\n        bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);\n      }\n      parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n    } else if (parent.nodeType == 11) {\n      // Shadow root\n      parent = parent.host;\n    } else {\n      break;\n    }\n  }\n  return {\n    left: left - rect.left,\n    right: Math.max(left, right) - rect.left,\n    top: top - (rect.top + paddingTop),\n    bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n  };\n}\nfunction fullPixelRange(dom, paddingTop) {\n  let rect = dom.getBoundingClientRect();\n  return {\n    left: 0,\n    right: rect.right - rect.left,\n    top: paddingTop,\n    bottom: rect.bottom - (rect.top + paddingTop)\n  };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n  constructor(from, to, size) {\n    this.from = from;\n    this.to = to;\n    this.size = size;\n  }\n  static same(a, b) {\n    if (a.length != b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      let gA = a[i],\n        gB = b[i];\n      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n    }\n    return true;\n  }\n  draw(wrapping) {\n    return Decoration.replace({\n      widget: new LineGapWidget(this.size, wrapping)\n    }).range(this.from, this.to);\n  }\n}\nclass LineGapWidget extends WidgetType {\n  constructor(size, vertical) {\n    super();\n    this.size = size;\n    this.vertical = vertical;\n  }\n  eq(other) {\n    return other.size == this.size && other.vertical == this.vertical;\n  }\n  toDOM() {\n    let elt = document.createElement(\"div\");\n    if (this.vertical) {\n      elt.style.height = this.size + \"px\";\n    } else {\n      elt.style.width = this.size + \"px\";\n      elt.style.height = \"2px\";\n      elt.style.display = \"inline-block\";\n    }\n    return elt;\n  }\n  get estimatedHeight() {\n    return this.vertical ? this.size : -1;\n  }\n}\nclass ViewState {\n  constructor(state) {\n    this.state = state;\n    // These are contentDOM-local coordinates\n    this.pixelViewport = {\n      left: 0,\n      right: window.innerWidth,\n      top: 0,\n      bottom: 0\n    };\n    this.inView = true;\n    this.paddingTop = 0;\n    this.paddingBottom = 0;\n    this.contentDOMWidth = 0;\n    this.contentDOMHeight = 0;\n    this.editorHeight = 0;\n    this.editorWidth = 0;\n    // See VP.MaxDOMHeight\n    this.scaler = IdScaler;\n    this.scrollTarget = null;\n    // Briefly set to true when printing, to disable viewport limiting\n    this.printing = false;\n    // Flag set when editor content was redrawn, so that the next\n    // measure stage knows it must read DOM layout\n    this.mustMeasureContent = true;\n    this.defaultTextDirection = Direction.LTR;\n    this.visibleRanges = [];\n    // Cursor 'assoc' is only significant when the cursor is on a line\n    // wrap point, where it must stick to the character that it is\n    // associated with. Since browsers don't provide a reasonable\n    // interface to set or query this, when a selection is set that\n    // might cause this to be significant, this flag is set. The next\n    // measure phase will check whether the cursor is on a line-wrapping\n    // boundary and, if so, reset it to make sure it is positioned in\n    // the right place.\n    this.mustEnforceCursorAssoc = false;\n    let guessWrapping = state.facet(contentAttributes).some(v => typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n    this.heightOracle = new HeightOracle(guessWrapping);\n    this.stateDeco = state.facet(decorations).filter(d => typeof d != \"function\");\n    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n    this.viewport = this.getViewport(0, null);\n    this.updateViewportLines();\n    this.updateForViewport();\n    this.lineGaps = this.ensureLineGaps([]);\n    this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\n    this.computeVisibleRanges();\n  }\n  updateForViewport() {\n    let viewports = [this.viewport],\n      {\n        main\n      } = this.state.selection;\n    for (let i = 0; i <= 1; i++) {\n      let pos = i ? main.head : main.anchor;\n      if (!viewports.some(({\n        from,\n        to\n      }) => pos >= from && pos <= to)) {\n        let {\n          from,\n          to\n        } = this.lineBlockAt(pos);\n        viewports.push(new Viewport(from, to));\n      }\n    }\n    this.viewports = viewports.sort((a, b) => a.from - b.from);\n    this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);\n  }\n  updateViewportLines() {\n    this.viewportLines = [];\n    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, block => {\n      this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));\n    });\n  }\n  update(update, scrollTarget = null) {\n    this.state = update.state;\n    let prevDeco = this.stateDeco;\n    this.stateDeco = this.state.facet(decorations).filter(d => typeof d != \"function\");\n    let contentChanges = update.changedRanges;\n    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\n    let prevHeight = this.heightMap.height;\n    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n    if (this.heightMap.height != prevHeight) update.flags |= 2 /* UpdateFlag.Height */;\n    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n    let updateLines = !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */ || viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n    this.viewport = viewport;\n    this.updateForViewport();\n    if (updateLines) this.updateViewportLines();\n    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n    update.flags |= this.computeVisibleRanges();\n    if (scrollTarget) this.scrollTarget = scrollTarget;\n    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n  }\n  measure(view) {\n    let dom = view.contentDOM,\n      style = window.getComputedStyle(dom);\n    let oracle = this.heightOracle;\n    let whiteSpace = style.whiteSpace;\n    this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;\n    this.contentDOMHeight = dom.clientHeight;\n    this.mustMeasureContent = false;\n    let result = 0,\n      bias = 0;\n    // Vertical padding\n    let paddingTop = parseInt(style.paddingTop) || 0,\n      paddingBottom = parseInt(style.paddingBottom) || 0;\n    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n      this.paddingTop = paddingTop;\n      this.paddingBottom = paddingBottom;\n      result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;\n    }\n\n    if (this.editorWidth != view.scrollDOM.clientWidth) {\n      if (oracle.lineWrapping) measureContent = true;\n      this.editorWidth = view.scrollDOM.clientWidth;\n      result |= 8 /* UpdateFlag.Geometry */;\n    }\n    // Pixel viewport\n    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n    let dTop = pixelViewport.top - this.pixelViewport.top,\n      dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n    this.pixelViewport = pixelViewport;\n    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n    if (inView != this.inView) {\n      this.inView = inView;\n      if (inView) measureContent = true;\n    }\n    if (!this.inView && !this.scrollTarget) return 0;\n    let contentWidth = dom.clientWidth;\n    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n      this.contentDOMWidth = contentWidth;\n      this.editorHeight = view.scrollDOM.clientHeight;\n      result |= 8 /* UpdateFlag.Geometry */;\n    }\n\n    if (measureContent) {\n      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n      if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n        let {\n          lineHeight,\n          charWidth\n        } = view.docView.measureTextSize();\n        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);\n        if (refresh) {\n          view.docView.minWidth = 0;\n          result |= 8 /* UpdateFlag.Geometry */;\n        }\n      }\n\n      if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n      oracle.heightChanged = false;\n      for (let vp of this.viewports) {\n        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n      }\n      if (oracle.heightChanged) result |= 2 /* UpdateFlag.Height */;\n    }\n\n    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n    if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);\n    this.updateForViewport();\n    if (result & 2 /* UpdateFlag.Height */ || viewportChange) this.updateViewportLines();\n    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n    result |= this.computeVisibleRanges();\n    if (this.mustEnforceCursorAssoc) {\n      this.mustEnforceCursorAssoc = false;\n      // This is done in the read stage, because moving the selection\n      // to a line end is going to trigger a layout anyway, so it\n      // can't be a pure write. It should be rare that it does any\n      // writing.\n      view.docView.enforceCursorAssoc();\n    }\n    return result;\n  }\n  get visibleTop() {\n    return this.scaler.fromDOM(this.pixelViewport.top);\n  }\n  get visibleBottom() {\n    return this.scaler.fromDOM(this.pixelViewport.bottom);\n  }\n  getViewport(bias, scrollTarget) {\n    // This will divide VP.Margin between the top and the\n    // bottom, depending on the bias (the change in viewport position\n    // since the last update). It'll hold a number between 0 and 1\n    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));\n    let map = this.heightMap,\n      doc = this.state.doc,\n      {\n        visibleTop,\n        visibleBottom\n      } = this;\n    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, doc, 0, 0).to);\n    // If scrollTarget is given, make sure the viewport includes that position\n    if (scrollTarget) {\n      let {\n        head\n      } = scrollTarget.range;\n      if (head < viewport.from || head > viewport.to) {\n        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n        let block = map.lineAt(head, QueryType.ByPos, doc, 0, 0),\n          topPos;\n        if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;else topPos = block.bottom - viewHeight;\n        viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n      }\n    }\n    return viewport;\n  }\n  mapViewport(viewport, changes) {\n    let from = changes.mapPos(viewport.from, -1),\n      to = changes.mapPos(viewport.to, 1);\n    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n  }\n  // Checks if a given viewport covers the visible part of the\n  // document and not too much beyond that.\n  viewportIsAppropriate({\n    from,\n    to\n  }, bias = 0) {\n    if (!this.inView) return true;\n    let {\n      top\n    } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\n    let {\n      bottom\n    } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\n    let {\n      visibleTop,\n      visibleBottom\n    } = this;\n    return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) && top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */;\n  }\n\n  mapLineGaps(gaps, changes) {\n    if (!gaps.length || changes.empty) return gaps;\n    let mapped = [];\n    for (let gap of gaps) if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n    return mapped;\n  }\n  // Computes positions in the viewport where the start or end of a\n  // line should be hidden, trying to reuse existing line gaps when\n  // appropriate to avoid unneccesary redraws.\n  // Uses crude character-counting for the positioning and sizing,\n  // since actual DOM coordinates aren't always available and\n  // predictable. Relies on generous margins (see LG.Margin) to hide\n  // the artifacts this might produce from the user.\n  ensureLineGaps(current, mayMeasure) {\n    let wrapping = this.heightOracle.lineWrapping;\n    let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */,\n      halfMargin = margin >> 1,\n      doubleMargin = margin << 1;\n    // The non-wrapping logic won't work at all in predominantly right-to-left text.\n    if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n    let gaps = [];\n    let addGap = (from, to, line, structure) => {\n      if (to - from < halfMargin) return;\n      let sel = this.state.selection.main,\n        avoid = [sel.from];\n      if (!sel.empty) avoid.push(sel.to);\n      for (let pos of avoid) {\n        if (pos > from && pos < to) {\n          addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);\n          addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);\n          return;\n        }\n      }\n      let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some(pos => gap.from < pos && gap.to > pos));\n      if (!gap) {\n        // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {\n          let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\n          if (lineStart > from) to = lineStart;\n        }\n        gap = new LineGap(from, to, this.gapSize(line, from, to, structure));\n      }\n      gaps.push(gap);\n    };\n    for (let line of this.viewportLines) {\n      if (line.length < doubleMargin) continue;\n      let structure = lineStructure(line.from, line.to, this.stateDeco);\n      if (structure.total < doubleMargin) continue;\n      let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n      let viewFrom, viewTo;\n      if (wrapping) {\n        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n        let top, bot;\n        if (target != null) {\n          let targetFrac = findFraction(structure, target);\n          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n          top = targetFrac - spaceFrac;\n          bot = targetFrac + spaceFrac;\n        } else {\n          top = (this.visibleTop - line.top - marginHeight) / line.height;\n          bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n        }\n        viewFrom = findPosition(structure, top);\n        viewTo = findPosition(structure, bot);\n      } else {\n        let totalWidth = structure.total * this.heightOracle.charWidth;\n        let marginWidth = margin * this.heightOracle.charWidth;\n        let left, right;\n        if (target != null) {\n          let targetFrac = findFraction(structure, target);\n          let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;\n          left = targetFrac - spaceFrac;\n          right = targetFrac + spaceFrac;\n        } else {\n          left = (this.pixelViewport.left - marginWidth) / totalWidth;\n          right = (this.pixelViewport.right + marginWidth) / totalWidth;\n        }\n        viewFrom = findPosition(structure, left);\n        viewTo = findPosition(structure, right);\n      }\n      if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n      if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n    }\n    return gaps;\n  }\n  gapSize(line, from, to, structure) {\n    let fraction = findFraction(structure, to) - findFraction(structure, from);\n    if (this.heightOracle.lineWrapping) {\n      return line.height * fraction;\n    } else {\n      return structure.total * this.heightOracle.charWidth * fraction;\n    }\n  }\n  updateLineGaps(gaps) {\n    if (!LineGap.same(gaps, this.lineGaps)) {\n      this.lineGaps = gaps;\n      this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\n    }\n  }\n  computeVisibleRanges() {\n    let deco = this.stateDeco;\n    if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n    let ranges = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n      span(from, to) {\n        ranges.push({\n          from,\n          to\n        });\n      },\n      point() {}\n    }, 20);\n    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);\n    this.visibleRanges = ranges;\n    return changed ? 4 /* UpdateFlag.Viewport */ : 0;\n  }\n  lineBlockAt(pos) {\n    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);\n  }\n  lineBlockAtHeight(height) {\n    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);\n  }\n  elementAtHeight(height) {\n    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);\n  }\n  get docHeight() {\n    return this.scaler.toDOM(this.heightMap.height);\n  }\n  get contentHeight() {\n    return this.docHeight + this.paddingTop + this.paddingBottom;\n  }\n}\nclass Viewport {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n}\nfunction lineStructure(from, to, stateDeco) {\n  let ranges = [],\n    pos = from,\n    total = 0;\n  _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\n    span() {},\n    point(from, to) {\n      if (from > pos) {\n        ranges.push({\n          from: pos,\n          to: from\n        });\n        total += from - pos;\n      }\n      pos = to;\n    }\n  }, 20); // We're only interested in collapsed ranges of a significant size\n  if (pos < to) {\n    ranges.push({\n      from: pos,\n      to\n    });\n    total += to - pos;\n  }\n  return {\n    total,\n    ranges\n  };\n}\nfunction findPosition({\n  total,\n  ranges\n}, ratio) {\n  if (ratio <= 0) return ranges[0].from;\n  if (ratio >= 1) return ranges[ranges.length - 1].to;\n  let dist = Math.floor(total * ratio);\n  for (let i = 0;; i++) {\n    let {\n        from,\n        to\n      } = ranges[i],\n      size = to - from;\n    if (dist <= size) return from + dist;\n    dist -= size;\n  }\n}\nfunction findFraction(structure, pos) {\n  let counted = 0;\n  for (let {\n    from,\n    to\n  } of structure.ranges) {\n    if (pos <= to) {\n      counted += pos - from;\n      break;\n    }\n    counted += to - from;\n  }\n  return counted / structure.total;\n}\nfunction find(array, f) {\n  for (let val of array) if (f(val)) return val;\n  return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n  toDOM(n) {\n    return n;\n  },\n  fromDOM(n) {\n    return n;\n  },\n  scale: 1\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n  constructor(doc, heightMap, viewports) {\n    let vpHeight = 0,\n      base = 0,\n      domBase = 0;\n    this.viewports = viewports.map(({\n      from,\n      to\n    }) => {\n      let top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;\n      let bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;\n      vpHeight += bottom - top;\n      return {\n        from,\n        to,\n        top,\n        bottom,\n        domTop: 0,\n        domBottom: 0\n      };\n    });\n    this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);\n    for (let obj of this.viewports) {\n      obj.domTop = domBase + (obj.top - base) * this.scale;\n      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n      base = obj.bottom;\n    }\n  }\n  toDOM(n) {\n    for (let i = 0, base = 0, domBase = 0;; i++) {\n      let vp = i < this.viewports.length ? this.viewports[i] : null;\n      if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n      if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n      base = vp.bottom;\n      domBase = vp.domBottom;\n    }\n  }\n  fromDOM(n) {\n    for (let i = 0, base = 0, domBase = 0;; i++) {\n      let vp = i < this.viewports.length ? this.viewports[i] : null;\n      if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n      if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n      base = vp.bottom;\n      domBase = vp.domBottom;\n    }\n  }\n}\nfunction scaleBlock(block, scaler) {\n  if (scaler.scale == 1) return block;\n  let bTop = scaler.toDOM(block.top),\n    bBottom = scaler.toDOM(block.bottom);\n  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(b => scaleBlock(b, scaler)) : block.type);\n}\nconst theme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: strs => strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(),\n  baseLightID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(),\n  baseDarkID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n  \"&light\": \".\" + baseLightID,\n  \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n  return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n    finish(sel) {\n      return /&/.test(sel) ? sel.replace(/&\\w*/, m => {\n        if (m == \"&\") return main;\n        if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n        return scopes[m];\n      }) : main + \" \" + sel;\n    }\n  });\n}\nconst baseTheme$1 = /*@__PURE__*/buildTheme(\".\" + baseThemeID, {\n  \"&\": {\n    position: \"relative !important\",\n    boxSizing: \"border-box\",\n    \"&.cm-focused\": {\n      // Provide a simple default outline to make sure a focused\n      // editor is visually distinct. Can't leave the default behavior\n      // because that will apply to the content element, which is\n      // inside the scrollable container and doesn't include the\n      // gutters. We also can't use an 'auto' outline, since those\n      // are, for some reason, drawn behind the element content, which\n      // will cause things like the active line background to cover\n      // the outline (#297).\n      outline: \"1px dotted #212121\"\n    },\n    display: \"flex !important\",\n    flexDirection: \"column\"\n  },\n  \".cm-scroller\": {\n    display: \"flex !important\",\n    alignItems: \"flex-start !important\",\n    fontFamily: \"monospace\",\n    lineHeight: 1.4,\n    height: \"100%\",\n    overflowX: \"auto\",\n    position: \"relative\",\n    zIndex: 0\n  },\n  \".cm-content\": {\n    margin: 0,\n    flexGrow: 2,\n    flexShrink: 0,\n    display: \"block\",\n    whiteSpace: \"pre\",\n    wordWrap: \"normal\",\n    boxSizing: \"border-box\",\n    padding: \"4px 0\",\n    outline: \"none\",\n    \"&[contenteditable=true]\": {\n      WebkitUserModify: \"read-write-plaintext-only\"\n    }\n  },\n  \".cm-lineWrapping\": {\n    whiteSpace_fallback: \"pre-wrap\",\n    whiteSpace: \"break-spaces\",\n    wordBreak: \"break-word\",\n    overflowWrap: \"anywhere\",\n    flexShrink: 1\n  },\n  \"&light .cm-content\": {\n    caretColor: \"black\"\n  },\n  \"&dark .cm-content\": {\n    caretColor: \"white\"\n  },\n  \".cm-line\": {\n    display: \"block\",\n    padding: \"0 2px 0 6px\"\n  },\n  \".cm-layer\": {\n    contain: \"size style\",\n    \"& > *\": {\n      position: \"absolute\"\n    }\n  },\n  \"&light .cm-selectionBackground\": {\n    background: \"#d9d9d9\"\n  },\n  \"&dark .cm-selectionBackground\": {\n    background: \"#222\"\n  },\n  \"&light.cm-focused .cm-selectionBackground\": {\n    background: \"#d7d4f0\"\n  },\n  \"&dark.cm-focused .cm-selectionBackground\": {\n    background: \"#233\"\n  },\n  \".cm-cursorLayer\": {\n    pointerEvents: \"none\"\n  },\n  \"&.cm-focused .cm-cursorLayer\": {\n    animation: \"steps(1) cm-blink 1.2s infinite\"\n  },\n  // Two animations defined so that we can switch between them to\n  // restart the animation without forcing another style\n  // recomputation.\n  \"@keyframes cm-blink\": {\n    \"0%\": {},\n    \"50%\": {\n      opacity: 0\n    },\n    \"100%\": {}\n  },\n  \"@keyframes cm-blink2\": {\n    \"0%\": {},\n    \"50%\": {\n      opacity: 0\n    },\n    \"100%\": {}\n  },\n  \".cm-cursor, .cm-dropCursor\": {\n    borderLeft: \"1.2px solid black\",\n    marginLeft: \"-0.6px\",\n    pointerEvents: \"none\"\n  },\n  \".cm-cursor\": {\n    display: \"none\"\n  },\n  \"&dark .cm-cursor\": {\n    borderLeftColor: \"#444\"\n  },\n  \".cm-dropCursor\": {\n    position: \"absolute\"\n  },\n  \"&.cm-focused .cm-cursor\": {\n    display: \"block\"\n  },\n  \"&light .cm-activeLine\": {\n    backgroundColor: \"#cceeff44\"\n  },\n  \"&dark .cm-activeLine\": {\n    backgroundColor: \"#99eeff33\"\n  },\n  \"&light .cm-specialChar\": {\n    color: \"red\"\n  },\n  \"&dark .cm-specialChar\": {\n    color: \"#f78\"\n  },\n  \".cm-gutters\": {\n    flexShrink: 0,\n    display: \"flex\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    left: 0,\n    zIndex: 200\n  },\n  \"&light .cm-gutters\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"#6c6c6c\",\n    borderRight: \"1px solid #ddd\"\n  },\n  \"&dark .cm-gutters\": {\n    backgroundColor: \"#333338\",\n    color: \"#ccc\"\n  },\n  \".cm-gutter\": {\n    display: \"flex !important\",\n    flexDirection: \"column\",\n    flexShrink: 0,\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    overflow: \"hidden\"\n  },\n  \".cm-gutterElement\": {\n    boxSizing: \"border-box\"\n  },\n  \".cm-lineNumbers .cm-gutterElement\": {\n    padding: \"0 3px 0 5px\",\n    minWidth: \"20px\",\n    textAlign: \"right\",\n    whiteSpace: \"nowrap\"\n  },\n  \"&light .cm-activeLineGutter\": {\n    backgroundColor: \"#e2f2ff\"\n  },\n  \"&dark .cm-activeLineGutter\": {\n    backgroundColor: \"#222227\"\n  },\n  \".cm-panels\": {\n    boxSizing: \"border-box\",\n    position: \"sticky\",\n    left: 0,\n    right: 0\n  },\n  \"&light .cm-panels\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"black\"\n  },\n  \"&light .cm-panels-top\": {\n    borderBottom: \"1px solid #ddd\"\n  },\n  \"&light .cm-panels-bottom\": {\n    borderTop: \"1px solid #ddd\"\n  },\n  \"&dark .cm-panels\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  },\n  \".cm-tab\": {\n    display: \"inline-block\",\n    overflow: \"hidden\",\n    verticalAlign: \"bottom\"\n  },\n  \".cm-widgetBuffer\": {\n    verticalAlign: \"text-top\",\n    height: \"1em\",\n    width: 0,\n    display: \"inline\"\n  },\n  \".cm-placeholder\": {\n    color: \"#888\",\n    display: \"inline-block\",\n    verticalAlign: \"top\"\n  },\n  \".cm-highlightSpace:before\": {\n    content: \"attr(data-display)\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    color: \"#888\"\n  },\n  \".cm-highlightTab\": {\n    backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n    backgroundSize: \"auto 100%\",\n    backgroundPosition: \"right 90%\",\n    backgroundRepeat: \"no-repeat\"\n  },\n  \".cm-trailingSpace\": {\n    backgroundColor: \"#ff332255\"\n  },\n  \".cm-button\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    padding: \".2em 1em\",\n    borderRadius: \"1px\"\n  },\n  \"&light .cm-button\": {\n    backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n    }\n  },\n  \"&dark .cm-button\": {\n    backgroundImage: \"linear-gradient(#393939, #111)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#111, #333)\"\n    }\n  },\n  \".cm-textfield\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    border: \"1px solid silver\",\n    padding: \".2em .5em\"\n  },\n  \"&light .cm-textfield\": {\n    backgroundColor: \"white\"\n  },\n  \"&dark .cm-textfield\": {\n    border: \"1px solid #555\",\n    backgroundColor: \"inherit\"\n  }\n}, lightDarkIDs);\nclass DOMChange {\n  constructor(view, start, end, typeOver) {\n    this.typeOver = typeOver;\n    this.bounds = null;\n    this.text = \"\";\n    let {\n      impreciseHead: iHead,\n      impreciseAnchor: iAnchor\n    } = view.docView;\n    if (view.state.readOnly && start > -1) {\n      // Ignore changes when the editor is read-only\n      this.newSel = null;\n    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n      let reader = new DOMReader(selPoints, view.state);\n      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n      this.text = reader.text;\n      this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n    } else {\n      let domSel = view.observer.selectionRange;\n      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n      this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\n    }\n  }\n}\nfunction applyDOMChange(view, domChange) {\n  let change;\n  let {\n      newSel\n    } = domChange,\n    sel = view.state.selection.main;\n  if (domChange.bounds) {\n    let {\n      from,\n      to\n    } = domChange.bounds;\n    let preferredPos = sel.from,\n      preferredSide = null;\n    // Prefer anchoring to end when Backspace is pressed (or, on\n    // Android, when something was deleted)\n    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to - from) {\n      preferredPos = sel.to;\n      preferredSide = \"end\";\n    }\n    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n    if (diff) {\n      // Chrome inserts two newlines when pressing shift-enter at the\n      // end of a line. DomChange drops one of those.\n      if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n      change = {\n        from: from + diff.from,\n        to: from + diff.toA,\n        insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n      };\n    }\n  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n    newSel = null;\n  }\n  if (!change && !newSel) return false;\n  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n    // Heuristic to notice typing over a selected character\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: view.state.doc.slice(sel.from, sel.to)\n    };\n  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n    // If the change is inside the selection and covers most of it,\n    // assume it is a selection replace (with identical characters at\n    // the start/end not included in the diff)\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n    };\n  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString())) {\n    // Detect insert-period-on-double-space Mac and Android behavior,\n    // and transform it into a regular space insert.\n    if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"])\n    };\n  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n    // In Chrome, if you insert a space at the start of a wrapped\n    // line, it will actually insert a newline and a space, causing a\n    // bogus new line to be created in CodeMirror (#968)\n    if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"])\n    };\n  }\n  if (change) {\n    let startState = view.state;\n    if (browser.ios && view.inputState.flushIOSKey(view)) return true;\n    // Android browsers don't fire reasonable key events for enter,\n    // backspace, or delete. So this detects changes that look like\n    // they're caused by those keys, and reinterprets them as key\n    // events. (Some of these keys are also handled by beforeinput\n    // events and the pendingAndroidKey mechanism, but that's not\n    // reliable in all situations.)\n    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n    let text = change.insert.toString();\n    if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text))) return true;\n    if (view.inputState.composing >= 0) view.inputState.composing++;\n    let tr;\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n      let changes = startState.changes(change);\n      let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n      // Try to apply a composition change to all cursors\n      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {\n        let replaced = view.state.sliceDoc(change.from, change.to);\n        let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);\n        let offset = sel.to - change.to,\n          size = sel.to - sel.from;\n        tr = startState.changeByRange(range => {\n          if (range.from == sel.from && range.to == sel.to) return {\n            changes,\n            range: mainSel || range.map(changes)\n          };\n          let to = range.to - offset,\n            from = to - replaced.length;\n          if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||\n          // Unfortunately, there's no way to make multiple\n          // changes in the same node work without aborting\n          // composition, so cursors in the composition range are\n          // ignored.\n          compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n            range\n          };\n          let rangeChanges = startState.changes({\n              from,\n              to,\n              insert: change.insert\n            }),\n            selOff = range.to - sel.to;\n          return {\n            changes: rangeChanges,\n            range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n          };\n        });\n      } else {\n        tr = {\n          changes,\n          selection: mainSel && startState.selection.replaceRange(mainSel)\n        };\n      }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing) {\n      userEvent += \".compose\";\n      if (view.inputState.compositionFirstChange) {\n        userEvent += \".start\";\n        view.inputState.compositionFirstChange = false;\n      }\n    }\n    view.dispatch(tr, {\n      scrollIntoView: true,\n      userEvent\n    });\n    return true;\n  } else if (newSel && !newSel.main.eq(sel)) {\n    let scrollIntoView = false,\n      userEvent = \"select\";\n    if (view.inputState.lastSelectionTime > Date.now() - 50) {\n      if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n      userEvent = view.inputState.lastSelectionOrigin;\n    }\n    view.dispatch({\n      selection: newSel,\n      scrollIntoView,\n      userEvent\n    });\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n  let minLen = Math.min(a.length, b.length);\n  let from = 0;\n  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;\n  if (from == minLen && a.length == b.length) return null;\n  let toA = a.length,\n    toB = b.length;\n  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n    toA--;\n    toB--;\n  }\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, from - Math.min(toA, toB));\n    preferredPos -= toA + adjust - from;\n  }\n  if (toA < from && a.length < b.length) {\n    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n    from -= move;\n    toB = from + (toB - toA);\n    toA = from;\n  } else if (toB < from) {\n    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n    from -= move;\n    toA = from + (toA - toB);\n    toB = from;\n  }\n  return {\n    from,\n    toA,\n    toB\n  };\n}\nfunction selectionPoints(view) {\n  let result = [];\n  if (view.root.activeElement != view.contentDOM) return result;\n  let {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset\n  } = view.observer.selectionRange;\n  if (anchorNode) {\n    result.push(new DOMPoint(anchorNode, anchorOffset));\n    if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n  }\n  return result;\n}\nfunction selectionFromPoints(points, base) {\n  if (points.length == 0) return null;\n  let anchor = points[0].pos,\n    head = points.length == 2 ? points[1].pos : anchor;\n  return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\n}\nconst observeOptions = {\n  childList: true,\n  characterData: true,\n  subtree: true,\n  attributes: true,\n  characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n  constructor(view) {\n    this.view = view;\n    this.active = false;\n    // The known selection. Kept in our own object, as opposed to just\n    // directly accessing the selection because:\n    //  - Safari doesn't report the right selection in shadow DOM\n    //  - Reading from the selection forces a DOM layout\n    //  - This way, we can ignore selectionchange events if we have\n    //    already seen the 'new' selection\n    this.selectionRange = new DOMSelectionState();\n    // Set when a selection change is detected, cleared on flush\n    this.selectionChanged = false;\n    this.delayedFlush = -1;\n    this.resizeTimeout = -1;\n    this.queue = [];\n    this.delayedAndroidKey = null;\n    this.flushingAndroidKey = -1;\n    this.lastChange = 0;\n    this.scrollTargets = [];\n    this.intersection = null;\n    this.resizeScroll = null;\n    this.resizeContent = null;\n    this.intersecting = false;\n    this.gapIntersection = null;\n    this.gaps = [];\n    // Timeout for scheduling check of the parents that need scroll handlers\n    this.parentCheck = -1;\n    this.dom = view.contentDOM;\n    this.observer = new MutationObserver(mutations => {\n      for (let mut of mutations) this.queue.push(mut);\n      // IE11 will sometimes (on typing over a selection or\n      // backspacing out a single character text node) call the\n      // observer callback before actually updating the DOM.\n      //\n      // Unrelatedly, iOS Safari will, when ending a composition,\n      // sometimes first clear it, deliver the mutations, and then\n      // reinsert the finished text. CodeMirror's handling of the\n      // deletion will prevent the reinsertion from happening,\n      // breaking composition.\n      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(m => m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();else this.flush();\n    });\n    if (useCharData) this.onCharData = event => {\n      this.queue.push({\n        target: event.target,\n        type: \"characterData\",\n        oldValue: event.prevValue\n      });\n      this.flushSoon();\n    };\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onResize = this.onResize.bind(this);\n    this.onPrint = this.onPrint.bind(this);\n    this.onScroll = this.onScroll.bind(this);\n    if (typeof ResizeObserver == \"function\") {\n      this.resizeScroll = new ResizeObserver(() => {\n        var _a;\n        if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n      });\n      this.resizeScroll.observe(view.scrollDOM);\n      this.resizeContent = new ResizeObserver(() => this.view.requestMeasure());\n      this.resizeContent.observe(view.contentDOM);\n    }\n    this.addWindowListeners(this.win = view.win);\n    this.start();\n    if (typeof IntersectionObserver == \"function\") {\n      this.intersection = new IntersectionObserver(entries => {\n        if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n          this.intersecting = !this.intersecting;\n          if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n        }\n      }, {});\n      this.intersection.observe(this.dom);\n      this.gapIntersection = new IntersectionObserver(entries => {\n        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n      }, {});\n    }\n    this.listenForScroll();\n    this.readSelectionRange();\n  }\n  onScrollChanged(e) {\n    this.view.inputState.runScrollHandlers(this.view, e);\n    if (this.intersecting) this.view.measure();\n  }\n  onScroll(e) {\n    if (this.intersecting) this.flush(false);\n    this.onScrollChanged(e);\n  }\n  onResize() {\n    if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(() => {\n      this.resizeTimeout = -1;\n      this.view.requestMeasure();\n    }, 50);\n  }\n  onPrint() {\n    this.view.viewState.printing = true;\n    this.view.measure();\n    setTimeout(() => {\n      this.view.viewState.printing = false;\n      this.view.requestMeasure();\n    }, 500);\n  }\n  updateGaps(gaps) {\n    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {\n      this.gapIntersection.disconnect();\n      for (let gap of gaps) this.gapIntersection.observe(gap);\n      this.gaps = gaps;\n    }\n  }\n  onSelectionChange(event) {\n    let wasChanged = this.selectionChanged;\n    if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n    let {\n        view\n      } = this,\n      sel = this.selectionRange;\n    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;\n    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n    if (context && context.ignoreEvent(event)) {\n      if (!wasChanged) this.selectionChanged = false;\n      return;\n    }\n    // Deletions on IE11 fire their events in the wrong order, giving\n    // us a selection change event before the DOM changes are\n    // reported.\n    // Chrome Android has a similar issue when backspacing out a\n    // selection (#645).\n    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&\n    // (Selection.isCollapsed isn't reliable on IE)\n    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();else this.flush(false);\n  }\n  readSelectionRange() {\n    let {\n      view\n    } = this;\n    // The Selection object is broken in shadow roots in Safari. See\n    // https://github.com/codemirror/dev/issues/414\n    let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);\n    if (!range || this.selectionRange.eq(range)) return false;\n    let local = hasSelection(this.dom, range);\n    // Detect the situation where the browser has, on focus, moved the\n    // selection to the start of the content element. Reset it to the\n    // position from the editor state.\n    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n      this.view.inputState.lastFocusTime = 0;\n      view.docView.updateSelection();\n      return false;\n    }\n    this.selectionRange.setRange(range);\n    if (local) this.selectionChanged = true;\n    return true;\n  }\n  setSelectionRange(anchor, head) {\n    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n    this.selectionChanged = false;\n  }\n  clearSelectionRange() {\n    this.selectionRange.set(null, 0, null, 0);\n  }\n  listenForScroll() {\n    this.parentCheck = -1;\n    let i = 0,\n      changed = null;\n    for (let dom = this.dom; dom;) {\n      if (dom.nodeType == 1) {\n        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;else if (!changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) changed.push(dom);\n        dom = dom.assignedSlot || dom.parentNode;\n      } else if (dom.nodeType == 11) {\n        // Shadow root\n        dom = dom.host;\n      } else {\n        break;\n      }\n    }\n    if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n    if (changed) {\n      for (let dom of this.scrollTargets) dom.removeEventListener(\"scroll\", this.onScroll);\n      for (let dom of this.scrollTargets = changed) dom.addEventListener(\"scroll\", this.onScroll);\n    }\n  }\n  ignore(f) {\n    if (!this.active) return f();\n    try {\n      this.stop();\n      return f();\n    } finally {\n      this.start();\n      this.clear();\n    }\n  }\n  start() {\n    if (this.active) return;\n    this.observer.observe(this.dom, observeOptions);\n    if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    this.active = true;\n  }\n  stop() {\n    if (!this.active) return;\n    this.active = false;\n    this.observer.disconnect();\n    if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n  }\n  // Throw away any pending changes\n  clear() {\n    this.processRecords();\n    this.queue.length = 0;\n    this.selectionChanged = false;\n  }\n  // Chrome Android, especially in combination with GBoard, not only\n  // doesn't reliably fire regular key events, but also often\n  // surrounds the effect of enter or backspace with a bunch of\n  // composition events that, when interrupted, cause text duplication\n  // or other kinds of corruption. This hack makes the editor back off\n  // from handling DOM changes for a moment when such a key is\n  // detected (via beforeinput or keydown), and then tries to flush\n  // them or, if that has no effect, dispatches the given key.\n  delayAndroidKey(key, keyCode) {\n    var _a;\n    if (!this.delayedAndroidKey) {\n      let flush = () => {\n        let key = this.delayedAndroidKey;\n        if (key) {\n          this.clearDelayedAndroidKey();\n          if (!this.flush() && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n        }\n      };\n      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n    }\n    // Since backspace beforeinput is sometimes signalled spuriously,\n    // Enter always takes precedence.\n    if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n      key,\n      keyCode,\n      // Only run the key handler when no changes are detected if\n      // this isn't coming right after another change, in which case\n      // it is probably part of a weird chain of updates, and should\n      // be ignored if it returns the DOM to its previous state.\n      force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n    };\n  }\n  clearDelayedAndroidKey() {\n    this.win.cancelAnimationFrame(this.flushingAndroidKey);\n    this.delayedAndroidKey = null;\n    this.flushingAndroidKey = -1;\n  }\n  flushSoon() {\n    if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(() => {\n      this.delayedFlush = -1;\n      this.flush();\n    });\n  }\n  forceFlush() {\n    if (this.delayedFlush >= 0) {\n      this.view.win.cancelAnimationFrame(this.delayedFlush);\n      this.delayedFlush = -1;\n    }\n    this.flush();\n  }\n  processRecords() {\n    let records = this.queue;\n    for (let mut of this.observer.takeRecords()) records.push(mut);\n    if (records.length) this.queue = [];\n    let from = -1,\n      to = -1,\n      typeOver = false;\n    for (let record of records) {\n      let range = this.readMutation(record);\n      if (!range) continue;\n      if (range.typeOver) typeOver = true;\n      if (from == -1) {\n        ({\n          from,\n          to\n        } = range);\n      } else {\n        from = Math.min(range.from, from);\n        to = Math.max(range.to, to);\n      }\n    }\n    return {\n      from,\n      to,\n      typeOver\n    };\n  }\n  readChange() {\n    let {\n      from,\n      to,\n      typeOver\n    } = this.processRecords();\n    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n    if (from < 0 && !newSel) return null;\n    if (from > -1) this.lastChange = Date.now();\n    this.view.inputState.lastFocusTime = 0;\n    this.selectionChanged = false;\n    return new DOMChange(this.view, from, to, typeOver);\n  }\n  // Apply pending changes, if any\n  flush(readSelection = true) {\n    // Completely hold off flushing when pending keys are set—the code\n    // managing those will make sure processRecords is called and the\n    // view is resynchronized after\n    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n    if (readSelection) this.readSelectionRange();\n    let domChange = this.readChange();\n    if (!domChange) return false;\n    let startState = this.view.state;\n    let handled = applyDOMChange(this.view, domChange);\n    // The view wasn't updated\n    if (this.view.state == startState) this.view.update([]);\n    return handled;\n  }\n  readMutation(rec) {\n    let cView = this.view.docView.nearest(rec.target);\n    if (!cView || cView.ignoreMutation(rec)) return null;\n    cView.markDirty(rec.type == \"attributes\");\n    if (rec.type == \"attributes\") cView.dirty |= 4 /* Dirty.Attrs */;\n    if (rec.type == \"childList\") {\n      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n      return {\n        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n        typeOver: false\n      };\n    } else if (rec.type == \"characterData\") {\n      return {\n        from: cView.posAtStart,\n        to: cView.posAtEnd,\n        typeOver: rec.target.nodeValue == rec.oldValue\n      };\n    } else {\n      return null;\n    }\n  }\n  setWindow(win) {\n    if (win != this.win) {\n      this.removeWindowListeners(this.win);\n      this.win = win;\n      this.addWindowListeners(this.win);\n    }\n  }\n  addWindowListeners(win) {\n    win.addEventListener(\"resize\", this.onResize);\n    win.addEventListener(\"beforeprint\", this.onPrint);\n    win.addEventListener(\"scroll\", this.onScroll);\n    win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  removeWindowListeners(win) {\n    win.removeEventListener(\"scroll\", this.onScroll);\n    win.removeEventListener(\"resize\", this.onResize);\n    win.removeEventListener(\"beforeprint\", this.onPrint);\n    win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  destroy() {\n    var _a, _b, _c, _d;\n    this.stop();\n    (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n    (_d = this.resizeContent) === null || _d === void 0 ? void 0 : _d.disconnect();\n    for (let dom of this.scrollTargets) dom.removeEventListener(\"scroll\", this.onScroll);\n    this.removeWindowListeners(this.win);\n    clearTimeout(this.parentCheck);\n    clearTimeout(this.resizeTimeout);\n    this.win.cancelAnimationFrame(this.delayedFlush);\n    this.win.cancelAnimationFrame(this.flushingAndroidKey);\n  }\n}\nfunction findChild(cView, dom, dir) {\n  while (dom) {\n    let curView = ContentView.get(dom);\n    if (curView && curView.parent == cView) return curView;\n    let parent = dom.parentNode;\n    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n  }\n  return null;\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view) {\n  let found = null;\n  // Because Safari (at least in 2018-2021) doesn't provide regular\n  // access to the selection inside a shadowroot, we have to perform a\n  // ridiculous hack to get at it—using `execCommand` to trigger a\n  // `beforeInput` event so that we can read the target range from the\n  // event.\n  function read(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    found = event.getTargetRanges()[0];\n  }\n  view.contentDOM.addEventListener(\"beforeinput\", read, true);\n  view.dom.ownerDocument.execCommand(\"indent\");\n  view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n  if (!found) return null;\n  let anchorNode = found.startContainer,\n    anchorOffset = found.startOffset;\n  let focusNode = found.endContainer,\n    focusOffset = found.endOffset;\n  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n  // Since such a range doesn't distinguish between anchor and head,\n  // use a heuristic that flips it around if its end matches the\n  // current anchor.\n  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n  return {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset\n  };\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/\nclass EditorView {\n  /**\n  Construct a new view. You'll want to either provide a `parent`\n  option, or put `view.dom` into your document after creating a\n  view, so that the user can see the editor.\n  */\n  constructor(config = {}) {\n    this.plugins = [];\n    this.pluginMap = new Map();\n    this.editorAttrs = {};\n    this.contentAttrs = {};\n    this.bidiCache = [];\n    this.destroyed = false;\n    /**\n    @internal\n    */\n    this.updateState = 2 /* UpdateState.Updating */;\n    /**\n    @internal\n    */\n    this.measureScheduled = -1;\n    /**\n    @internal\n    */\n    this.measureRequests = [];\n    this.contentDOM = document.createElement(\"div\");\n    this.scrollDOM = document.createElement(\"div\");\n    this.scrollDOM.tabIndex = -1;\n    this.scrollDOM.className = \"cm-scroller\";\n    this.scrollDOM.appendChild(this.contentDOM);\n    this.announceDOM = document.createElement(\"div\");\n    this.announceDOM.style.cssText = \"position: fixed; top: -10000px\";\n    this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n    this.dom = document.createElement(\"div\");\n    this.dom.appendChild(this.announceDOM);\n    this.dom.appendChild(this.scrollDOM);\n    this._dispatch = config.dispatch || (tr => this.update([tr]));\n    this.dispatch = this.dispatch.bind(this);\n    this._root = config.root || getRoot(config.parent) || document;\n    this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\n    this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));\n    for (let plugin of this.plugins) plugin.update(this);\n    this.observer = new DOMObserver(this);\n    this.inputState = new InputState(this);\n    this.inputState.ensureHandlers(this, this.plugins);\n    this.docView = new DocView(this);\n    this.mountStyles();\n    this.updateAttrs();\n    this.updateState = 0 /* UpdateState.Idle */;\n    this.requestMeasure();\n    if (config.parent) config.parent.appendChild(this.dom);\n  }\n  /**\n  The current editor state.\n  */\n  get state() {\n    return this.viewState.state;\n  }\n  /**\n  To be able to display large documents without consuming too much\n  memory or overloading the browser, CodeMirror only draws the\n  code that is visible (plus a margin around it) to the DOM. This\n  property tells you the extent of the current drawn viewport, in\n  document positions.\n  */\n  get viewport() {\n    return this.viewState.viewport;\n  }\n  /**\n  When there are, for example, large collapsed ranges in the\n  viewport, its size can be a lot bigger than the actual visible\n  content. Thus, if you are doing something like styling the\n  content in the viewport, it is preferable to only do so for\n  these ranges, which are the subset of the viewport that is\n  actually drawn.\n  */\n  get visibleRanges() {\n    return this.viewState.visibleRanges;\n  }\n  /**\n  Returns false when the editor is entirely scrolled out of view\n  or otherwise hidden.\n  */\n  get inView() {\n    return this.viewState.inView;\n  }\n  /**\n  Indicates whether the user is currently composing text via\n  [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n  one change has been made in the current composition.\n  */\n  get composing() {\n    return this.inputState.composing > 0;\n  }\n  /**\n  Indicates whether the user is currently in composing state. Note\n  that on some platforms, like Android, this will be the case a\n  lot, since just putting the cursor on a word starts a\n  composition there.\n  */\n  get compositionStarted() {\n    return this.inputState.composing >= 0;\n  }\n  /**\n  The document or shadow root that the view lives in.\n  */\n  get root() {\n    return this._root;\n  }\n  /**\n  @internal\n  */\n  get win() {\n    return this.dom.ownerDocument.defaultView || window;\n  }\n  dispatch(...input) {\n    this._dispatch(input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input[0] : this.state.update(...input));\n  }\n  /**\n  Update the view for the given array of transactions. This will\n  update the visible document and selection to match the state\n  produced by the transactions, and notify view plugins of the\n  change. You should usually call\n  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n  as a primitive.\n  */\n  update(transactions) {\n    if (this.updateState != 0 /* UpdateState.Idle */) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n    let redrawn = false,\n      attrsChanged = false,\n      update;\n    let state = this.state;\n    for (let tr of transactions) {\n      if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n      state = tr.state;\n    }\n    if (this.destroyed) {\n      this.viewState.state = state;\n      return;\n    }\n    // If there was a pending DOM change, eagerly read it and try to\n    // apply it after the given transactions.\n    let pendingKey = this.observer.delayedAndroidKey,\n      domChange = null;\n    if (pendingKey) {\n      this.observer.clearDelayedAndroidKey();\n      domChange = this.observer.readChange();\n      // Only try to apply DOM changes if the transactions didn't\n      // change the doc or selection.\n      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n    } else {\n      this.observer.clear();\n    }\n    // When the phrases change, redraw the editor\n    if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases)) return this.setState(state);\n    update = ViewUpdate.create(this, state, transactions);\n    let scrollTarget = this.viewState.scrollTarget;\n    try {\n      this.updateState = 2 /* UpdateState.Updating */;\n      for (let tr of transactions) {\n        if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n        if (tr.scrollIntoView) {\n          let {\n            main\n          } = tr.state.selection;\n          scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n        }\n        for (let e of tr.effects) if (e.is(scrollIntoView)) scrollTarget = e.value;\n      }\n      this.viewState.update(update, scrollTarget);\n      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n      if (!update.empty) {\n        this.updatePlugins(update);\n        this.inputState.update(update);\n      }\n      redrawn = this.docView.update(update);\n      if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n      attrsChanged = this.updateAttrs();\n      this.showAnnouncements(transactions);\n      this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent(\"select.pointer\")));\n    } finally {\n      this.updateState = 0 /* UpdateState.Idle */;\n    }\n\n    if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n    if (!update.empty) for (let listener of this.state.facet(updateListener)) listener(update);\n    if (domChange) {\n      if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n    }\n  }\n  /**\n  Reset the view to the given state. (This will cause the entire\n  document to be redrawn and all view plugins to be reinitialized,\n  so you should probably only use it when the new state isn't\n  derived from the old state. Otherwise, use\n  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n  */\n  setState(newState) {\n    if (this.updateState != 0 /* UpdateState.Idle */) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n    if (this.destroyed) {\n      this.viewState.state = newState;\n      return;\n    }\n    this.updateState = 2 /* UpdateState.Updating */;\n    let hadFocus = this.hasFocus;\n    try {\n      for (let plugin of this.plugins) plugin.destroy(this);\n      this.viewState = new ViewState(newState);\n      this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));\n      this.pluginMap.clear();\n      for (let plugin of this.plugins) plugin.update(this);\n      this.docView = new DocView(this);\n      this.inputState.ensureHandlers(this, this.plugins);\n      this.mountStyles();\n      this.updateAttrs();\n      this.bidiCache = [];\n    } finally {\n      this.updateState = 0 /* UpdateState.Idle */;\n    }\n\n    if (hadFocus) this.focus();\n    this.requestMeasure();\n  }\n  updatePlugins(update) {\n    let prevSpecs = update.startState.facet(viewPlugin),\n      specs = update.state.facet(viewPlugin);\n    if (prevSpecs != specs) {\n      let newPlugins = [];\n      for (let spec of specs) {\n        let found = prevSpecs.indexOf(spec);\n        if (found < 0) {\n          newPlugins.push(new PluginInstance(spec));\n        } else {\n          let plugin = this.plugins[found];\n          plugin.mustUpdate = update;\n          newPlugins.push(plugin);\n        }\n      }\n      for (let plugin of this.plugins) if (plugin.mustUpdate != update) plugin.destroy(this);\n      this.plugins = newPlugins;\n      this.pluginMap.clear();\n      this.inputState.ensureHandlers(this, this.plugins);\n    } else {\n      for (let p of this.plugins) p.mustUpdate = update;\n    }\n    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);\n  }\n  /**\n  @internal\n  */\n  measure(flush = true) {\n    if (this.destroyed) return;\n    if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);\n    this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n    if (flush) this.observer.forceFlush();\n    let updated = null;\n    let {\n      scrollHeight,\n      scrollTop,\n      clientHeight\n    } = this.scrollDOM;\n    let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;\n    try {\n      for (let i = 0;; i++) {\n        this.updateState = 1 /* UpdateState.Measuring */;\n        let oldViewport = this.viewport;\n        let refBlock = this.viewState.lineBlockAtHeight(refHeight);\n        let changed = this.viewState.measure(this);\n        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n        if (i > 5) {\n          console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n          break;\n        }\n        let measuring = [];\n        // Only run measure requests in this cycle when the viewport didn't change\n        if (!(changed & 4 /* UpdateFlag.Viewport */)) [this.measureRequests, measuring] = [measuring, this.measureRequests];\n        let measured = measuring.map(m => {\n          try {\n            return m.read(this);\n          } catch (e) {\n            logException(this.state, e);\n            return BadMeasure;\n          }\n        });\n        let update = ViewUpdate.create(this, this.state, []),\n          redrawn = false,\n          scrolled = false;\n        update.flags |= changed;\n        if (!updated) updated = update;else updated.flags |= changed;\n        this.updateState = 2 /* UpdateState.Updating */;\n        if (!update.empty) {\n          this.updatePlugins(update);\n          this.inputState.update(update);\n          this.updateAttrs();\n          redrawn = this.docView.update(update);\n        }\n        for (let i = 0; i < measuring.length; i++) if (measured[i] != BadMeasure) {\n          try {\n            let m = measuring[i];\n            if (m.write) m.write(measured[i], this);\n          } catch (e) {\n            logException(this.state, e);\n          }\n        }\n        if (this.viewState.editorHeight) {\n          if (this.viewState.scrollTarget) {\n            this.docView.scrollIntoView(this.viewState.scrollTarget);\n            this.viewState.scrollTarget = null;\n            scrolled = true;\n          } else {\n            let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;\n            if (diff > 1 || diff < -1) {\n              this.scrollDOM.scrollTop += diff;\n              scrolled = true;\n            }\n          }\n        }\n        if (redrawn) this.docView.updateSelection(true);\n        if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0) break;\n      }\n    } finally {\n      this.updateState = 0 /* UpdateState.Idle */;\n      this.measureScheduled = -1;\n    }\n    if (updated && !updated.empty) for (let listener of this.state.facet(updateListener)) listener(updated);\n  }\n  /**\n  Get the CSS classes for the currently active editor themes.\n  */\n  get themeClasses() {\n    return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n  }\n  updateAttrs() {\n    let editorAttrs = attrsFromFacet(this, editorAttributes, {\n      class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n    });\n    let contentAttrs = {\n      spellcheck: \"false\",\n      autocorrect: \"off\",\n      autocapitalize: \"off\",\n      translate: \"no\",\n      contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n      class: \"cm-content\",\n      style: `${browser.tabSize}: ${this.state.tabSize}`,\n      role: \"textbox\",\n      \"aria-multiline\": \"true\"\n    };\n    if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n    attrsFromFacet(this, contentAttributes, contentAttrs);\n    let changed = this.observer.ignore(() => {\n      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n      return changedContent || changedEditor;\n    });\n    this.editorAttrs = editorAttrs;\n    this.contentAttrs = contentAttrs;\n    return changed;\n  }\n  showAnnouncements(trs) {\n    let first = true;\n    for (let tr of trs) for (let effect of tr.effects) if (effect.is(EditorView.announce)) {\n      if (first) this.announceDOM.textContent = \"\";\n      first = false;\n      let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n      div.textContent = effect.value;\n    }\n  }\n  mountStyles() {\n    this.styleModules = this.state.facet(styleModule);\n    style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());\n  }\n  readMeasured() {\n    if (this.updateState == 2 /* UpdateState.Updating */) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n    if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1) this.measure(false);\n  }\n  /**\n  Schedule a layout measurement, optionally providing callbacks to\n  do custom DOM measuring followed by a DOM write phase. Using\n  this is preferable reading DOM layout directly from, for\n  example, an event handler, because it'll make sure measuring and\n  drawing done by other components is synchronized, avoiding\n  unnecessary DOM layout computations.\n  */\n  requestMeasure(request) {\n    if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());\n    if (request) {\n      if (this.measureRequests.indexOf(request) > -1) return;\n      if (request.key != null) for (let i = 0; i < this.measureRequests.length; i++) {\n        if (this.measureRequests[i].key === request.key) {\n          this.measureRequests[i] = request;\n          return;\n        }\n      }\n      this.measureRequests.push(request);\n    }\n  }\n  /**\n  Get the value of a specific plugin, if present. Note that\n  plugins that crash can be dropped from a view, so even when you\n  know you registered a given plugin, it is recommended to check\n  the return value of this method.\n  */\n  plugin(plugin) {\n    let known = this.pluginMap.get(plugin);\n    if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);\n    return known && known.update(this).value;\n  }\n  /**\n  The top position of the document, in screen coordinates. This\n  may be negative when the editor is scrolled down. Points\n  directly to the top of the first line, not above the padding.\n  */\n  get documentTop() {\n    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n  }\n  /**\n  Reports the padding above and below the document.\n  */\n  get documentPadding() {\n    return {\n      top: this.viewState.paddingTop,\n      bottom: this.viewState.paddingBottom\n    };\n  }\n  /**\n  Find the text line or block widget at the given vertical\n  position (which is interpreted as relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n  */\n  elementAtHeight(height) {\n    this.readMeasured();\n    return this.viewState.elementAtHeight(height);\n  }\n  /**\n  Find the line block (see\n  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n  height, again interpreted relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n  */\n  lineBlockAtHeight(height) {\n    this.readMeasured();\n    return this.viewState.lineBlockAtHeight(height);\n  }\n  /**\n  Get the extent and vertical position of all [line\n  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n  are relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n  */\n  get viewportLineBlocks() {\n    return this.viewState.viewportLines;\n  }\n  /**\n  Find the line block around the given document position. A line\n  block is a range delimited on both sides by either a\n  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\n  start/end of the document. It will usually just hold a line of\n  text, but may be broken into multiple textblocks by block\n  widgets.\n  */\n  lineBlockAt(pos) {\n    return this.viewState.lineBlockAt(pos);\n  }\n  /**\n  The editor's total content height.\n  */\n  get contentHeight() {\n    return this.viewState.contentHeight;\n  }\n  /**\n  Move a cursor position by [grapheme\n  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n  the motion is away from the line start, or towards it. In\n  bidirectional text, the line is traversed in visual order, using\n  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n  When the start position was the last one on the line, the\n  returned position will be across the line break. If there is no\n  further line, the original position is returned.\n  \n  By default, this method moves over a single cluster. The\n  optional `by` argument can be used to move across more. It will\n  be called with the first cluster as argument, and should return\n  a predicate that determines, for each subsequent cluster,\n  whether it should also be moved over.\n  */\n  moveByChar(start, forward, by) {\n    return skipAtoms(this, start, moveByChar(this, start, forward, by));\n  }\n  /**\n  Move a cursor position across the next group of either\n  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n  non-whitespace characters.\n  */\n  moveByGroup(start, forward) {\n    return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));\n  }\n  /**\n  Move to the next line boundary in the given direction. If\n  `includeWrap` is true, line wrapping is on, and there is a\n  further wrap point on the current line, the wrap point will be\n  returned. Otherwise this function will return the start or end\n  of the line.\n  */\n  moveToLineBoundary(start, forward, includeWrap = true) {\n    return moveToLineBoundary(this, start, forward, includeWrap);\n  }\n  /**\n  Move a cursor position vertically. When `distance` isn't given,\n  it defaults to moving to the next line (including wrapped\n  lines). Otherwise, `distance` should provide a positive distance\n  in pixels.\n  \n  When `start` has a\n  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n  motion will use that as a target horizontal position. Otherwise,\n  the cursor's own horizontal position is used. The returned\n  cursor will have its goal column set to whichever column was\n  used.\n  */\n  moveVertically(start, forward, distance) {\n    return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n  }\n  /**\n  Find the DOM parent node and offset (child offset if `node` is\n  an element, character offset when it is a text node) at the\n  given document position.\n  \n  Note that for positions that aren't currently in\n  `visibleRanges`, the resulting DOM position isn't necessarily\n  meaningful (it may just point before or after a placeholder\n  element).\n  */\n  domAtPos(pos) {\n    return this.docView.domAtPos(pos);\n  }\n  /**\n  Find the document position at the given DOM node. Can be useful\n  for associating positions with DOM events. Will raise an error\n  when `node` isn't part of the editor content.\n  */\n  posAtDOM(node, offset = 0) {\n    return this.docView.posFromDOM(node, offset);\n  }\n  posAtCoords(coords, precise = true) {\n    this.readMeasured();\n    return posAtCoords(this, coords, precise);\n  }\n  /**\n  Get the screen coordinates at the given document position.\n  `side` determines whether the coordinates are based on the\n  element before (-1) or after (1) the position (if no element is\n  available on the given side, the method will transparently use\n  another strategy to get reasonable coordinates).\n  */\n  coordsAtPos(pos, side = 1) {\n    this.readMeasured();\n    let rect = this.docView.coordsAt(pos, side);\n    if (!rect || rect.left == rect.right) return rect;\n    let line = this.state.doc.lineAt(pos),\n      order = this.bidiSpans(line);\n    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n    return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n  }\n  /**\n  The default width of a character in the editor. May not\n  accurately reflect the width of all characters (given variable\n  width fonts or styling of invididual ranges).\n  */\n  get defaultCharacterWidth() {\n    return this.viewState.heightOracle.charWidth;\n  }\n  /**\n  The default height of a line in the editor. May not be accurate\n  for all lines.\n  */\n  get defaultLineHeight() {\n    return this.viewState.heightOracle.lineHeight;\n  }\n  /**\n  The text direction\n  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n  CSS property) of the editor's content element.\n  */\n  get textDirection() {\n    return this.viewState.defaultTextDirection;\n  }\n  /**\n  Find the text direction of the block at the given position, as\n  assigned by CSS. If\n  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n  isn't enabled, or the given position is outside of the viewport,\n  this will always return the same as\n  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n  this may trigger a DOM layout.\n  */\n  textDirectionAt(pos) {\n    let perLine = this.state.facet(perLineTextDirection);\n    if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n    this.readMeasured();\n    return this.docView.textDirectionAt(pos);\n  }\n  /**\n  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n  (as determined by the\n  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n  CSS property of its content element).\n  */\n  get lineWrapping() {\n    return this.viewState.heightOracle.lineWrapping;\n  }\n  /**\n  Returns the bidirectional text structure of the given line\n  (which should be in the current document) as an array of span\n  objects. The order of these spans matches the [text\n  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n  left-to-right, the leftmost spans come first, otherwise the\n  rightmost spans come first.\n  */\n  bidiSpans(line) {\n    if (line.length > MaxBidiLine) return trivialOrder(line.length);\n    let dir = this.textDirectionAt(line.from);\n    for (let entry of this.bidiCache) if (entry.from == line.from && entry.dir == dir) return entry.order;\n    let order = computeOrder(line.text, dir);\n    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));\n    return order;\n  }\n  /**\n  Check whether the editor has focus.\n  */\n  get hasFocus() {\n    var _a;\n    // Safari return false for hasFocus when the context menu is open\n    // or closing, which leads us to ignore selection changes from the\n    // context menu because it looks like the editor isn't focused.\n    // This kludges around that.\n    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n  }\n  /**\n  Put focus on the editor.\n  */\n  focus() {\n    this.observer.ignore(() => {\n      focusPreventScroll(this.contentDOM);\n      this.docView.updateSelection();\n    });\n  }\n  /**\n  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n  necessary when moving the editor's existing DOM to a new window or shadow root.\n  */\n  setRoot(root) {\n    if (this._root != root) {\n      this._root = root;\n      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n      this.mountStyles();\n    }\n  }\n  /**\n  Clean up this editor view, removing its element from the\n  document, unregistering event handlers, and notifying\n  plugins. The view instance can no longer be used after\n  calling this.\n  */\n  destroy() {\n    for (let plugin of this.plugins) plugin.destroy(this);\n    this.plugins = [];\n    this.inputState.destroy();\n    this.dom.remove();\n    this.observer.destroy();\n    if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);\n    this.destroyed = true;\n  }\n  /**\n  Returns an effect that can be\n  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n  cause it to scroll the given position or range into view.\n  */\n  static scrollIntoView(pos, options = {}) {\n    return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n  }\n  /**\n  Returns an extension that can be used to add DOM event handlers.\n  The value should be an object mapping event names to handler\n  functions. For any given event, such functions are ordered by\n  extension precedence, and the first handler to return true will\n  be assumed to have handled that event, and no other handlers or\n  built-in behavior will be activated for it. These are registered\n  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n  for `scroll` handlers, which will be called any time the\n  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n  its parent nodes is scrolled.\n  */\n  static domEventHandlers(handlers) {\n    return ViewPlugin.define(() => ({}), {\n      eventHandlers: handlers\n    });\n  }\n  /**\n  Create a theme extension. The first argument can be a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n  style spec providing the styles for the theme. These will be\n  prefixed with a generated class for the style.\n  \n  Because the selectors will be prefixed with a scope class, rule\n  that directly match the editor's [wrapper\n  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n  added—need to be explicitly differentiated by adding an `&` to\n  the selector for that element—for example\n  `&.cm-focused`.\n  \n  When `dark` is set to true, the theme will be marked as dark,\n  which will cause the `&dark` rules from [base\n  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n  `&light` when a light theme is active).\n  */\n  static theme(spec, options) {\n    let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];\n    if (options && options.dark) result.push(darkTheme.of(true));\n    return result;\n  }\n  /**\n  Create an extension that adds styles to the base theme. Like\n  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n  place of the editor wrapper element when directly targeting\n  that. You can also use `&dark` or `&light` instead to only\n  target editors with a dark or light theme.\n  */\n  static baseTheme(spec) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n  }\n  /**\n  Retrieve an editor view instance from the view's DOM\n  representation.\n  */\n  static findFromDOM(dom) {\n    var _a;\n    let content = dom.querySelector(\".cm-content\");\n    let cView = content && ContentView.get(content) || ContentView.get(dom);\n    return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n  }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/\nEditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n*/\nEditorView.inputHandler = inputHandler;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/\nEditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/\nEditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/\nEditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/\nEditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/\nEditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nways—directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/\nEditorView.decorations = decorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/\nEditorView.atomicRanges = atomicRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/\nEditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/\nEditorView.darkTheme = darkTheme;\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/\nEditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/\nEditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/\nEditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({\n  \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/\nEditorView.announce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n  constructor(from, to, dir, order) {\n    this.from = from;\n    this.to = to;\n    this.dir = dir;\n    this.order = order;\n  }\n  static update(cache, changes) {\n    if (changes.empty) return cache;\n    let result = [],\n      lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n      let entry = cache[i];\n      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));\n    }\n    return result;\n  }\n}\nfunction attrsFromFacet(view, facet, base) {\n  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {\n    let source = sources[i],\n      value = typeof source == \"function\" ? source(view) : source;\n    if (value) combineAttrs(value, base);\n  }\n  return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result == \"Space\") result = \" \";\n  let alt, ctrl, shift, meta;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {\n      if (platform == \"mac\") meta = true;else ctrl = true;\n    } else throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n  if (alt) result = \"Alt-\" + result;\n  if (ctrl) result = \"Ctrl-\" + result;\n  if (meta) result = \"Meta-\" + result;\n  if (shift) result = \"Shift-\" + result;\n  return result;\n}\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name;\n  if (event.ctrlKey) name = \"Ctrl-\" + name;\n  if (event.metaKey) name = \"Meta-\" + name;\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n  return name;\n}\nconst handleKeyEvents = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec[\"default\"]( /*@__PURE__*/EditorView.domEventHandlers({\n  keydown(event, view) {\n    return runHandlers(getKeymap(view.state), event, view, \"editor\");\n  }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/\nconst keymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n  let bindings = state.facet(keymap);\n  let map = Keymaps.get(bindings);\n  if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));\n  return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/\nfunction runScopeHandlers(view, event, scope) {\n  return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n  let bound = Object.create(null);\n  let isPrefix = Object.create(null);\n  let checkPrefix = (name, is) => {\n    let current = isPrefix[name];\n    if (current == null) isPrefix[name] = is;else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n  };\n  let add = (scope, key, command, preventDefault) => {\n    var _a, _b;\n    let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n    let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\n    for (let i = 1; i < parts.length; i++) {\n      let prefix = parts.slice(0, i).join(\" \");\n      checkPrefix(prefix, true);\n      if (!scopeObj[prefix]) scopeObj[prefix] = {\n        preventDefault: true,\n        run: [view => {\n          let ourObj = storedPrefix = {\n            view,\n            prefix,\n            scope\n          };\n          setTimeout(() => {\n            if (storedPrefix == ourObj) storedPrefix = null;\n          }, PrefixTimeout);\n          return true;\n        }]\n      };\n    }\n    let full = parts.join(\" \");\n    checkPrefix(full, false);\n    let binding = scopeObj[full] || (scopeObj[full] = {\n      preventDefault: false,\n      run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n    });\n    if (command) binding.run.push(command);\n    if (preventDefault) binding.preventDefault = true;\n  };\n  for (let b of bindings) {\n    let scopes = b.scope ? b.scope.split(\" \") : [\"editor\"];\n    if (b.any) for (let scope of scopes) {\n      let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n      if (!scopeObj._any) scopeObj._any = {\n        preventDefault: false,\n        run: []\n      };\n      for (let key in scopeObj) scopeObj[key].run.push(b.any);\n    }\n    let name = b[platform] || b.key;\n    if (!name) continue;\n    for (let scope of scopes) {\n      add(scope, name, b.run, b.preventDefault);\n      if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault);\n    }\n  }\n  return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n  let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n  let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0),\n    isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\n  let prefix = \"\",\n    fallthrough = false;\n  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n    prefix = storedPrefix.prefix + \" \";\n    if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0) storedPrefix = null;\n  }\n  let ran = new Set();\n  let runFor = binding => {\n    if (binding) {\n      for (let cmd of binding.run) if (!ran.has(cmd)) {\n        ran.add(cmd);\n        if (cmd(view, event)) return true;\n      }\n      if (binding.preventDefault) fallthrough = true;\n    }\n    return false;\n  };\n  let scopeObj = map[scope],\n    baseName,\n    shiftName;\n  if (scopeObj) {\n    if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) return true;\n    if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&\n    // Ctrl-Alt may be used for AltGr on Windows\n    !(browser.windows && event.ctrlKey && event.altKey) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) return true;else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) return true;\n    } else if (isChar && event.shiftKey) {\n      if (runFor(scopeObj[prefix + modifiers(name, event, true)])) return true;\n    }\n    if (runFor(scopeObj._any)) return true;\n  }\n  return fallthrough;\n}\n\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/\nclass RectangleMarker {\n  /**\n  Create a marker with the given class and dimensions. If `width`\n  is null, the DOM element will get no width style.\n  */\n  constructor(className, left, top, width, height) {\n    this.className = className;\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n  }\n  draw() {\n    let elt = document.createElement(\"div\");\n    elt.className = this.className;\n    this.adjust(elt);\n    return elt;\n  }\n  update(elt, prev) {\n    if (prev.className != this.className) return false;\n    this.adjust(elt);\n    return true;\n  }\n  adjust(elt) {\n    elt.style.left = this.left + \"px\";\n    elt.style.top = this.top + \"px\";\n    if (this.width != null) elt.style.width = this.width + \"px\";\n    elt.style.height = this.height + \"px\";\n  }\n  eq(p) {\n    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n  }\n  /**\n  Create a set of rectangles for the given selection range,\n  assigning them theclass`className`. Will create a single\n  rectangle for empty ranges, and a set of selection-style\n  rectangles covering the range's content (in a bidi-aware\n  way) for non-empty ones.\n  */\n  static forRange(view, className, range) {\n    if (range.empty) {\n      let pos = view.coordsAtPos(range.head, range.assoc || 1);\n      if (!pos) return [];\n      let base = getBase(view);\n      return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];\n    } else {\n      return rectanglesForRange(view, className, range);\n    }\n  }\n}\nfunction getBase(view) {\n  let rect = view.scrollDOM.getBoundingClientRect();\n  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n  return {\n    left: left - view.scrollDOM.scrollLeft,\n    top: rect.top - view.scrollDOM.scrollTop\n  };\n}\nfunction wrappedLine(view, pos, inside) {\n  let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n  return {\n    from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n    to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n    type: BlockType.Text\n  };\n}\nfunction blockAt(view, pos) {\n  let line = view.lineBlockAt(pos);\n  if (Array.isArray(line.type)) for (let l of line.type) {\n    if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;\n  }\n  return line;\n}\nfunction rectanglesForRange(view, className, range) {\n  if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n  let from = Math.max(range.from, view.viewport.from),\n    to = Math.min(range.to, view.viewport.to);\n  let ltr = view.textDirection == Direction.LTR;\n  let content = view.contentDOM,\n    contentRect = content.getBoundingClientRect(),\n    base = getBase(view);\n  let lineStyle = window.getComputedStyle(content.firstChild);\n  let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));\n  let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);\n  let startBlock = blockAt(view, from),\n    endBlock = blockAt(view, to);\n  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n  if (view.lineWrapping) {\n    if (visualStart) visualStart = wrappedLine(view, from, visualStart);\n    if (visualEnd) visualEnd = wrappedLine(view, to, visualEnd);\n  }\n  if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n    return pieces(drawForLine(range.from, range.to, visualStart));\n  } else {\n    let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n    let between = [];\n    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n    return pieces(top).concat(between).concat(pieces(bottom));\n  }\n  function piece(left, top, right, bottom) {\n    return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);\n  }\n\n  function pieces({\n    top,\n    bottom,\n    horizontal\n  }) {\n    let pieces = [];\n    for (let i = 0; i < horizontal.length; i += 2) pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n    return pieces;\n  }\n  // Gets passed from/to in line-local positions\n  function drawForLine(from, to, line) {\n    let top = 1e9,\n      bottom = -1e9,\n      horizontal = [];\n    function addSpan(from, fromOpen, to, toOpen, dir) {\n      // Passing 2/-2 is a kludge to force the view to return\n      // coordinates on the proper side of block widgets, since\n      // normalizing the side there, though appropriate for most\n      // coordsAtPos queries, would break selection drawing.\n      let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n      let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n      top = Math.min(fromCoords.top, toCoords.top, top);\n      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n      if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n    }\n    let start = from !== null && from !== void 0 ? from : line.from,\n      end = to !== null && to !== void 0 ? to : line.to;\n    // Split the range by visible range and document line\n    for (let r of view.visibleRanges) if (r.to > start && r.from < end) {\n      for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {\n        let docLine = view.state.doc.lineAt(pos);\n        for (let span of view.bidiSpans(docLine)) {\n          let spanFrom = span.from + docLine.from,\n            spanTo = span.to + docLine.from;\n          if (spanFrom >= endPos) break;\n          if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n        }\n        pos = docLine.to + 1;\n        if (pos >= endPos) break;\n      }\n    }\n    if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n    return {\n      top,\n      bottom,\n      horizontal\n    };\n  }\n  function drawForWidget(block, top) {\n    let y = contentRect.top + (top ? block.top : block.bottom);\n    return {\n      top: y,\n      bottom: y,\n      horizontal: []\n    };\n  }\n}\nfunction sameMarker(a, b) {\n  return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n  constructor(view, layer) {\n    this.view = view;\n    this.layer = layer;\n    this.drawn = [];\n    this.measureReq = {\n      read: this.measure.bind(this),\n      write: this.draw.bind(this)\n    };\n    this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n    this.dom.classList.add(\"cm-layer\");\n    if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n    if (layer.class) this.dom.classList.add(layer.class);\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.setOrder(view.state);\n    view.requestMeasure(this.measureReq);\n    if (layer.mount) layer.mount(this.dom, view);\n  }\n  update(update) {\n    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n    if (this.layer.update(update, this.dom) || update.geometryChanged) update.view.requestMeasure(this.measureReq);\n  }\n  setOrder(state) {\n    let pos = 0,\n      order = state.facet(layerOrder);\n    while (pos < order.length && order[pos] != this.layer) pos++;\n    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n  }\n  measure() {\n    return this.layer.markers(this.view);\n  }\n  draw(markers) {\n    if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {\n      let old = this.dom.firstChild,\n        oldI = 0;\n      for (let marker of markers) {\n        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n          old = old.nextSibling;\n          oldI++;\n        } else {\n          this.dom.insertBefore(marker.draw(), old);\n        }\n      }\n      while (old) {\n        let next = old.nextSibling;\n        old.remove();\n        old = next;\n      }\n      this.drawn = markers;\n    }\n  }\n  destroy() {\n    if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n    this.dom.remove();\n  }\n}\nconst layerOrder = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine a layer.\n*/\nfunction layer(config) {\n  return [ViewPlugin.define(v => new LayerView(v, config)), layerOrder.of(config)];\n}\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n      cursorBlinkRate: 1200,\n      drawRangeCursor: true\n    }, {\n      cursorBlinkRate: (a, b) => Math.min(a, b),\n      drawRangeCursor: (a, b) => a || b\n    });\n  }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/\nfunction drawSelection(config = {}) {\n  return [selectionConfig.of(config), cursorLayer, selectionLayer, hideNativeSelection, nativeSelectionHidden.of(true)];\n}\nfunction configChanged(update) {\n  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/layer({\n  above: true,\n  markers(view) {\n    let {\n        state\n      } = view,\n      conf = state.facet(selectionConfig);\n    let cursors = [];\n    for (let r of state.selection.ranges) {\n      let prim = r == state.selection.main;\n      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n        let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n        let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n        for (let piece of RectangleMarker.forRange(view, className, cursor)) cursors.push(piece);\n      }\n    }\n    return cursors;\n  },\n  update(update, dom) {\n    if (update.transactions.some(tr => tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n    let confChange = configChanged(update);\n    if (confChange) setBlinkRate(update.state, dom);\n    return update.docChanged || update.selectionSet || confChange;\n  },\n  mount(dom, view) {\n    setBlinkRate(view.state, dom);\n  },\n  class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/layer({\n  above: false,\n  markers(view) {\n    return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b) => a.concat(b));\n  },\n  update(update, dom) {\n    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n  },\n  class: \"cm-selectionLayer\"\n});\nconst themeSpec = {\n  \".cm-line\": {\n    \"& ::selection\": {\n      backgroundColor: \"transparent !important\"\n    },\n    \"&::selection\": {\n      backgroundColor: \"transparent !important\"\n    }\n  }\n};\nif (CanHidePrimary) themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\nconst hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest( /*@__PURE__*/EditorView.theme(themeSpec));\nconst setDropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n  map(pos, mapping) {\n    return pos == null ? null : mapping.mapPos(pos);\n  }\n});\nconst dropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n  create() {\n    return null;\n  },\n  update(pos, tr) {\n    if (pos != null) pos = tr.changes.mapPos(pos);\n    return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);\n  }\n});\nconst drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.cursor = null;\n    this.measureReq = {\n      read: this.readPos.bind(this),\n      write: this.drawCursor.bind(this)\n    };\n  }\n  update(update) {\n    var _a;\n    let cursorPos = update.state.field(dropCursorPos);\n    if (cursorPos == null) {\n      if (this.cursor != null) {\n        (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n        this.cursor = null;\n      }\n    } else {\n      if (!this.cursor) {\n        this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursor.className = \"cm-dropCursor\";\n      }\n      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n    }\n  }\n  readPos() {\n    let pos = this.view.state.field(dropCursorPos);\n    let rect = pos != null && this.view.coordsAtPos(pos);\n    if (!rect) return null;\n    let outer = this.view.scrollDOM.getBoundingClientRect();\n    return {\n      left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,\n      top: rect.top - outer.top + this.view.scrollDOM.scrollTop,\n      height: rect.bottom - rect.top\n    };\n  }\n  drawCursor(pos) {\n    if (this.cursor) {\n      if (pos) {\n        this.cursor.style.left = pos.left + \"px\";\n        this.cursor.style.top = pos.top + \"px\";\n        this.cursor.style.height = pos.height + \"px\";\n      } else {\n        this.cursor.style.left = \"-100000px\";\n      }\n    }\n  }\n  destroy() {\n    if (this.cursor) this.cursor.remove();\n  }\n  setDropPos(pos) {\n    if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n      effects: setDropCursorPos.of(pos)\n    });\n  }\n}, {\n  eventHandlers: {\n    dragover(event) {\n      this.setDropPos(this.view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n      }));\n    },\n    dragleave(event) {\n      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n    },\n    dragend() {\n      this.setDropPos(null);\n    },\n    drop() {\n      this.setDropPos(null);\n    }\n  }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/\nfunction dropCursor() {\n  return [dropCursorPos, drawDropCursor];\n}\nfunction iterMatches(doc, re, from, to, f) {\n  re.lastIndex = 0;\n  for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {\n    if (!cursor.lineBreak) while (m = re.exec(cursor.value)) f(pos + m.index, m);\n  }\n}\nfunction matchRanges(view, maxLength) {\n  let visible = view.visibleRanges;\n  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n  let result = [];\n  for (let {\n    from,\n    to\n  } of visible) {\n    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n    if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;else result.push({\n      from,\n      to\n    });\n  }\n  return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/\nclass MatchDecorator {\n  /**\n  Create a decorator.\n  */\n  constructor(config) {\n    const {\n      regexp,\n      decoration,\n      decorate,\n      boundary,\n      maxLength = 1000\n    } = config;\n    if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n    this.regexp = regexp;\n    if (decorate) {\n      this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);\n    } else if (typeof decoration == \"function\") {\n      this.addMatch = (match, view, from, add) => {\n        let deco = decoration(match, view, from);\n        if (deco) add(from, from + match[0].length, deco);\n      };\n    } else if (decoration) {\n      this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);\n    } else {\n      throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n    }\n    this.boundary = boundary;\n    this.maxLength = maxLength;\n  }\n  /**\n  Compute the full set of decorations for matches in the given\n  view's viewport. You'll want to call this when initializing your\n  plugin.\n  */\n  createDeco(view) {\n    let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(),\n      add = build.add.bind(build);\n    for (let {\n      from,\n      to\n    } of matchRanges(view, this.maxLength)) iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));\n    return build.finish();\n  }\n  /**\n  Update a set of decorations for a view update. `deco` _must_ be\n  the set of decorations produced by _this_ `MatchDecorator` for\n  the view state before the update.\n  */\n  updateDeco(update, deco) {\n    let changeFrom = 1e9,\n      changeTo = -1;\n    if (update.docChanged) update.changes.iterChanges((_f, _t, from, to) => {\n      if (to > update.view.viewport.from && from < update.view.viewport.to) {\n        changeFrom = Math.min(from, changeFrom);\n        changeTo = Math.max(to, changeTo);\n      }\n    });\n    if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n    if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n    return deco;\n  }\n  updateRange(view, deco, updateFrom, updateTo) {\n    for (let r of view.visibleRanges) {\n      let from = Math.max(r.from, updateFrom),\n        to = Math.min(r.to, updateTo);\n      if (to > from) {\n        let fromLine = view.state.doc.lineAt(from),\n          toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n        let start = Math.max(r.from, fromLine.from),\n          end = Math.min(r.to, toLine.to);\n        if (this.boundary) {\n          for (; from > fromLine.from; from--) if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n            start = from;\n            break;\n          }\n          for (; to < toLine.to; to++) if (this.boundary.test(toLine.text[to - toLine.from])) {\n            end = to;\n            break;\n          }\n        }\n        let ranges = [],\n          m;\n        let add = (from, to, deco) => ranges.push(deco.range(from, to));\n        if (fromLine == toLine) {\n          this.regexp.lastIndex = start - fromLine.from;\n          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) this.addMatch(m, view, m.index + fromLine.from, add);\n        } else {\n          iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));\n        }\n        deco = deco.update({\n          filterFrom: start,\n          filterTo: end,\n          filter: (from, to) => from < start || to > end,\n          add: ranges\n        });\n      }\n    }\n    return deco;\n  }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/new RegExp(\"[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]\", UnicodeRegexpSupport);\nconst Names = {\n  0: \"null\",\n  7: \"bell\",\n  8: \"backspace\",\n  10: \"newline\",\n  11: \"vertical tab\",\n  13: \"carriage return\",\n  27: \"escape\",\n  8203: \"zero width space\",\n  8204: \"zero width non-joiner\",\n  8205: \"zero width joiner\",\n  8206: \"left-to-right mark\",\n  8207: \"right-to-left mark\",\n  8232: \"line separator\",\n  8237: \"left-to-right override\",\n  8238: \"right-to-left override\",\n  8294: \"left-to-right isolate\",\n  8295: \"right-to-left isolate\",\n  8297: \"pop directional isolate\",\n  8233: \"paragraph separator\",\n  65279: \"zero width no-break space\",\n  65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n  var _a;\n  if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n    let styles = document.body.style;\n    _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n  }\n  return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(configs) {\n    let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n      render: null,\n      specialChars: Specials,\n      addSpecialChars: null\n    });\n    if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n    if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n    return config;\n  }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/\nfunction highlightSpecialChars(\n/**\nConfiguration options.\n*/\nconfig = {}) {\n  return [specialCharConfig.of(config), specialCharPlugin()];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n  return _plugin || (_plugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.decorations = Decoration.none;\n      this.decorationCache = Object.create(null);\n      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n      this.decorations = this.decorator.createDeco(view);\n    }\n    makeDecorator(conf) {\n      return new MatchDecorator({\n        regexp: conf.specialChars,\n        decoration: (m, view, pos) => {\n          let {\n            doc\n          } = view.state;\n          let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\n          if (code == 9) {\n            let line = doc.lineAt(pos);\n            let size = view.state.tabSize,\n              col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\n            return Decoration.replace({\n              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth)\n            });\n          }\n          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n            widget: new SpecialCharWidget(conf, code)\n          }));\n        },\n        boundary: conf.replaceTabs ? undefined : /[^]/\n      });\n    }\n    update(update) {\n      let conf = update.state.facet(specialCharConfig);\n      if (update.startState.facet(specialCharConfig) != conf) {\n        this.decorator = this.makeDecorator(conf);\n        this.decorations = this.decorator.createDeco(update.view);\n      } else {\n        this.decorations = this.decorator.updateDeco(update, this.decorations);\n      }\n    }\n  }, {\n    decorations: v => v.decorations\n  }));\n}\nconst DefaultPlaceholder = \"\\u2022\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n  if (code >= 32) return DefaultPlaceholder;\n  if (code == 10) return \"\\u2424\";\n  return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n  constructor(options, code) {\n    super();\n    this.options = options;\n    this.code = code;\n  }\n  eq(other) {\n    return other.code == this.code;\n  }\n  toDOM(view) {\n    let ph = placeholder$1(this.code);\n    let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n    let custom = this.options.render && this.options.render(this.code, desc, ph);\n    if (custom) return custom;\n    let span = document.createElement(\"span\");\n    span.textContent = ph;\n    span.title = desc;\n    span.setAttribute(\"aria-label\", desc);\n    span.className = \"cm-specialChar\";\n    return span;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\nclass TabWidget extends WidgetType {\n  constructor(width) {\n    super();\n    this.width = width;\n  }\n  eq(other) {\n    return other.width == this.width;\n  }\n  toDOM() {\n    let span = document.createElement(\"span\");\n    span.textContent = \"\\t\";\n    span.className = \"cm-tab\";\n    span.style.width = this.width + \"px\";\n    return span;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\nconst plugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor() {\n    this.height = 1000;\n    this.attrs = {\n      style: \"padding-bottom: 1000px\"\n    };\n  }\n  update(update) {\n    let {\n      view\n    } = update;\n    let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;\n    if (height != this.height) {\n      this.height = height;\n      this.attrs = {\n        style: `padding-bottom: ${height}px`\n      };\n    }\n  }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/\nfunction scrollPastEnd() {\n  return [plugin, contentAttributes.of(view => {\n    var _a;\n    return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n  })];\n}\n\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/\nfunction highlightActiveLine() {\n  return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/Decoration.line({\n  class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.decorations = this.getDeco(view);\n  }\n  update(update) {\n    if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n  }\n  getDeco(view) {\n    let lastLineStart = -1,\n      deco = [];\n    for (let r of view.state.selection.ranges) {\n      let line = view.lineBlockAt(r.head);\n      if (line.from > lastLineStart) {\n        deco.push(lineDeco.range(line.from));\n        lastLineStart = line.from;\n      }\n    }\n    return Decoration.set(deco);\n  }\n}, {\n  decorations: v => v.decorations\n});\nclass Placeholder extends WidgetType {\n  constructor(content) {\n    super();\n    this.content = content;\n  }\n  toDOM() {\n    let wrap = document.createElement(\"span\");\n    wrap.className = \"cm-placeholder\";\n    wrap.style.pointerEvents = \"none\";\n    wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n    if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);else wrap.setAttribute(\"aria-hidden\", \"true\");\n    return wrap;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/\nfunction placeholder(content) {\n  return ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.placeholder = Decoration.set([Decoration.widget({\n        widget: new Placeholder(content),\n        side: 1\n      }).range(0)]);\n    }\n    get decorations() {\n      return this.view.state.doc.length ? Decoration.none : this.placeholder;\n    }\n  }, {\n    decorations: v => v.decorations\n  });\n}\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n  let startLine = Math.min(a.line, b.line),\n    endLine = Math.max(a.line, b.line);\n  let ranges = [];\n  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n    let startOff = Math.min(a.off, b.off),\n      endOff = Math.max(a.off, b.off);\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\n    }\n  } else {\n    let startCol = Math.min(a.col, b.col),\n      endCol = Math.max(a.col, b.col);\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\n      if (start < 0) {\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\n      } else {\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\n      }\n    }\n  }\n  return ranges;\n}\nfunction absoluteColumn(view, x) {\n  let ref = view.coordsAtPos(view.viewport.from);\n  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n  let offset = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  let line = view.state.doc.lineAt(offset),\n    off = offset - line.from;\n  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n  return {\n    line: line.number,\n    col,\n    off\n  };\n}\nfunction rectangleSelectionStyle(view, event) {\n  let start = getPos(view, event),\n    startSel = view.state.selection;\n  if (!start) return null;\n  return {\n    update(update) {\n      if (update.docChanged) {\n        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n        let newLine = update.state.doc.lineAt(newStart);\n        start = {\n          line: newLine.number,\n          col: start.col,\n          off: Math.min(start.off, newLine.length)\n        };\n        startSel = startSel.map(update.changes);\n      }\n    },\n    get(event, _extend, multiple) {\n      let cur = getPos(view, event);\n      if (!cur) return startSel;\n      let ranges = rectangleFor(view.state, start, cur);\n      if (!ranges.length) return startSel;\n      if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\n    }\n  };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/\nfunction rectangularSelection(options) {\n  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n  Alt: [18, e => e.altKey],\n  Control: [17, e => e.ctrlKey],\n  Shift: [16, e => e.shiftKey],\n  Meta: [91, e => e.metaKey]\n};\nconst showCrosshair = {\n  style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/\nfunction crosshairCursor(options = {}) {\n  let [code, getter] = keys[options.key || \"Alt\"];\n  let plugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.isDown = false;\n    }\n    set(isDown) {\n      if (this.isDown != isDown) {\n        this.isDown = isDown;\n        this.view.update([]);\n      }\n    }\n  }, {\n    eventHandlers: {\n      keydown(e) {\n        this.set(e.keyCode == code || getter(e));\n      },\n      keyup(e) {\n        if (e.keyCode == code || !getter(e)) this.set(false);\n      },\n      mousemove(e) {\n        this.set(getter(e));\n      }\n    }\n  });\n  return [plugin, EditorView.contentAttributes.of(view => {\n    var _a;\n    return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n  })];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n  constructor(view, facet, createTooltipView) {\n    this.facet = facet;\n    this.createTooltipView = createTooltipView;\n    this.input = view.state.facet(facet);\n    this.tooltips = this.input.filter(t => t);\n    this.tooltipViews = this.tooltips.map(createTooltipView);\n  }\n  update(update) {\n    var _a;\n    let input = update.state.facet(this.facet);\n    let tooltips = input.filter(x => x);\n    if (input === this.input) {\n      for (let t of this.tooltipViews) if (t.update) t.update(update);\n      return false;\n    }\n    let tooltipViews = [];\n    for (let i = 0; i < tooltips.length; i++) {\n      let tip = tooltips[i],\n        known = -1;\n      if (!tip) continue;\n      for (let i = 0; i < this.tooltips.length; i++) {\n        let other = this.tooltips[i];\n        if (other && other.create == tip.create) known = i;\n      }\n      if (known < 0) {\n        tooltipViews[i] = this.createTooltipView(tip);\n      } else {\n        let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n        if (tooltipView.update) tooltipView.update(update);\n      }\n    }\n    for (let t of this.tooltipViews) if (tooltipViews.indexOf(t) < 0) {\n      t.dom.remove();\n      (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    this.input = input;\n    this.tooltips = tooltips;\n    this.tooltipViews = tooltipViews;\n    return true;\n  }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/\nfunction tooltips(config = {}) {\n  return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n  let {\n    win\n  } = view;\n  return {\n    top: 0,\n    left: 0,\n    bottom: win.innerHeight,\n    right: win.innerWidth\n  };\n}\nconst tooltipConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => {\n    var _a, _b, _c;\n    return {\n      position: browser.ios ? \"absolute\" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n      parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n      tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n    };\n  }\n});\nconst knownHeight = /*@__PURE__*/new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.inView = true;\n    this.lastTransaction = 0;\n    this.measureTimeout = -1;\n    let config = view.state.facet(tooltipConfig);\n    this.position = config.position;\n    this.parent = config.parent;\n    this.classes = view.themeClasses;\n    this.createContainer();\n    this.measureReq = {\n      read: this.readMeasure.bind(this),\n      write: this.writeMeasure.bind(this),\n      key: this\n    };\n    this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));\n    this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver(entries => {\n      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n    }, {\n      threshold: [1]\n    }) : null;\n    this.observeIntersection();\n    view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n    this.maybeMeasure();\n  }\n  createContainer() {\n    if (this.parent) {\n      this.container = document.createElement(\"div\");\n      this.container.style.position = \"relative\";\n      this.container.className = this.view.themeClasses;\n      this.parent.appendChild(this.container);\n    } else {\n      this.container = this.view.dom;\n    }\n  }\n  observeIntersection() {\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n      for (let tooltip of this.manager.tooltipViews) this.intersectionObserver.observe(tooltip.dom);\n    }\n  }\n  measureSoon() {\n    if (this.measureTimeout < 0) this.measureTimeout = setTimeout(() => {\n      this.measureTimeout = -1;\n      this.maybeMeasure();\n    }, 50);\n  }\n  update(update) {\n    if (update.transactions.length) this.lastTransaction = Date.now();\n    let updated = this.manager.update(update);\n    if (updated) this.observeIntersection();\n    let shouldMeasure = updated || update.geometryChanged;\n    let newConfig = update.state.facet(tooltipConfig);\n    if (newConfig.position != this.position) {\n      this.position = newConfig.position;\n      for (let t of this.manager.tooltipViews) t.dom.style.position = this.position;\n      shouldMeasure = true;\n    }\n    if (newConfig.parent != this.parent) {\n      if (this.parent) this.container.remove();\n      this.parent = newConfig.parent;\n      this.createContainer();\n      for (let t of this.manager.tooltipViews) this.container.appendChild(t.dom);\n      shouldMeasure = true;\n    } else if (this.parent && this.view.themeClasses != this.classes) {\n      this.classes = this.container.className = this.view.themeClasses;\n    }\n    if (shouldMeasure) this.maybeMeasure();\n  }\n  createTooltip(tooltip) {\n    let tooltipView = tooltip.create(this.view);\n    tooltipView.dom.classList.add(\"cm-tooltip\");\n    if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n      let arrow = document.createElement(\"div\");\n      arrow.className = \"cm-tooltip-arrow\";\n      tooltipView.dom.appendChild(arrow);\n    }\n    tooltipView.dom.style.position = this.position;\n    tooltipView.dom.style.top = Outside;\n    this.container.appendChild(tooltipView.dom);\n    if (tooltipView.mount) tooltipView.mount(this.view);\n    return tooltipView;\n  }\n  destroy() {\n    var _a, _b;\n    this.view.win.removeEventListener(\"resize\", this.measureSoon);\n    for (let tooltipView of this.manager.tooltipViews) {\n      tooltipView.dom.remove();\n      (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n    }\n    (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    clearTimeout(this.measureTimeout);\n  }\n  readMeasure() {\n    let editor = this.view.dom.getBoundingClientRect();\n    return {\n      editor,\n      parent: this.parent ? this.container.getBoundingClientRect() : editor,\n      pos: this.manager.tooltips.map((t, i) => {\n        let tv = this.manager.tooltipViews[i];\n        return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n      }),\n      size: this.manager.tooltipViews.map(({\n        dom\n      }) => dom.getBoundingClientRect()),\n      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)\n    };\n  }\n  writeMeasure(measured) {\n    var _a;\n    let {\n      editor,\n      space\n    } = measured;\n    let others = [];\n    for (let i = 0; i < this.manager.tooltips.length; i++) {\n      let tooltip = this.manager.tooltips[i],\n        tView = this.manager.tooltipViews[i],\n        {\n          dom\n        } = tView;\n      let pos = measured.pos[i],\n        size = measured.size[i];\n      // Hide tooltips that are outside of the editor.\n      if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - .1 || pos.left > Math.min(editor.right, space.right) + .1) {\n        dom.style.top = Outside;\n        continue;\n      }\n      let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n      let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;\n      let width = size.right - size.left,\n        height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n      let offset = tView.offset || noOffset,\n        ltr = this.view.textDirection == Direction.LTR;\n      let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);\n      let above = !!tooltip.above;\n      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = !above;\n      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n      if (spaceVert < height && tView.resize !== false) {\n        if (spaceVert < this.view.defaultLineHeight) {\n          dom.style.top = Outside;\n          continue;\n        }\n        knownHeight.set(tView, height);\n        dom.style.height = (height = spaceVert) + \"px\";\n      } else if (dom.style.height) {\n        dom.style.height = \"\";\n      }\n      let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n      let right = left + width;\n      if (tView.overlap !== true) for (let r of others) if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n      if (this.position == \"absolute\") {\n        dom.style.top = top - measured.parent.top + \"px\";\n        dom.style.left = left - measured.parent.left + \"px\";\n      } else {\n        dom.style.top = top + \"px\";\n        dom.style.left = left + \"px\";\n      }\n      if (arrow) arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */)}px`;\n      if (tView.overlap !== true) others.push({\n        left,\n        top,\n        right,\n        bottom: top + height\n      });\n      dom.classList.toggle(\"cm-tooltip-above\", above);\n      dom.classList.toggle(\"cm-tooltip-below\", !above);\n      if (tView.positioned) tView.positioned(measured.space);\n    }\n  }\n  maybeMeasure() {\n    if (this.manager.tooltips.length) {\n      if (this.view.inView) this.view.requestMeasure(this.measureReq);\n      if (this.inView != this.view.inView) {\n        this.inView = this.view.inView;\n        if (!this.inView) for (let tv of this.manager.tooltipViews) tv.dom.style.top = Outside;\n      }\n    }\n  }\n}, {\n  eventHandlers: {\n    scroll() {\n      this.maybeMeasure();\n    }\n  }\n});\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-tooltip\": {\n    zIndex: 100,\n    boxSizing: \"border-box\"\n  },\n  \"&light .cm-tooltip\": {\n    border: \"1px solid #bbb\",\n    backgroundColor: \"#f5f5f5\"\n  },\n  \"&light .cm-tooltip-section:not(:first-child)\": {\n    borderTop: \"1px solid #bbb\"\n  },\n  \"&dark .cm-tooltip\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  },\n  \".cm-tooltip-arrow\": {\n    height: `${7 /* Arrow.Size */}px`,\n    width: `${7 /* Arrow.Size */ * 2}px`,\n    position: \"absolute\",\n    zIndex: -1,\n    overflow: \"hidden\",\n    \"&:before, &:after\": {\n      content: \"''\",\n      position: \"absolute\",\n      width: 0,\n      height: 0,\n      borderLeft: `${7 /* Arrow.Size */}px solid transparent`,\n      borderRight: `${7 /* Arrow.Size */}px solid transparent`\n    },\n    \".cm-tooltip-above &\": {\n      bottom: `-${7 /* Arrow.Size */}px`,\n      \"&:before\": {\n        borderTop: `${7 /* Arrow.Size */}px solid #bbb`\n      },\n      \"&:after\": {\n        borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,\n        bottom: \"1px\"\n      }\n    },\n    \".cm-tooltip-below &\": {\n      top: `-${7 /* Arrow.Size */}px`,\n      \"&:before\": {\n        borderBottom: `${7 /* Arrow.Size */}px solid #bbb`\n      },\n      \"&:after\": {\n        borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,\n        top: \"1px\"\n      }\n    }\n  },\n  \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n    \"&:before\": {\n      borderTopColor: \"#333338\",\n      borderBottomColor: \"#333338\"\n    },\n    \"&:after\": {\n      borderTopColor: \"transparent\",\n      borderBottomColor: \"transparent\"\n    }\n  }\n});\nconst noOffset = {\n  x: 0,\n  y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/\nconst showTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  enables: [tooltipPlugin, baseTheme]\n});\nconst showHoverTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass HoverTooltipHost {\n  constructor(view) {\n    this.view = view;\n    this.mounted = false;\n    this.dom = document.createElement(\"div\");\n    this.dom.classList.add(\"cm-tooltip-hover\");\n    this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));\n  }\n  // Needs to be static so that host tooltip instances always match\n  static create(view) {\n    return new HoverTooltipHost(view);\n  }\n  createHostedView(tooltip) {\n    let hostedView = tooltip.create(this.view);\n    hostedView.dom.classList.add(\"cm-tooltip-section\");\n    this.dom.appendChild(hostedView.dom);\n    if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n    return hostedView;\n  }\n  mount(view) {\n    for (let hostedView of this.manager.tooltipViews) {\n      if (hostedView.mount) hostedView.mount(view);\n    }\n    this.mounted = true;\n  }\n  positioned(space) {\n    for (let hostedView of this.manager.tooltipViews) {\n      if (hostedView.positioned) hostedView.positioned(space);\n    }\n  }\n  update(update) {\n    this.manager.update(update);\n  }\n}\nconst showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {\n  let tooltips = state.facet(showHoverTooltip).filter(t => t);\n  if (tooltips.length === 0) return null;\n  return {\n    pos: Math.min(...tooltips.map(t => t.pos)),\n    end: Math.max(...tooltips.filter(t => t.end != null).map(t => t.end)),\n    create: HoverTooltipHost.create,\n    above: tooltips[0].above,\n    arrow: tooltips.some(t => t.arrow)\n  };\n});\nclass HoverPlugin {\n  constructor(view, source, field, setHover, hoverTime) {\n    this.view = view;\n    this.source = source;\n    this.field = field;\n    this.setHover = setHover;\n    this.hoverTime = hoverTime;\n    this.hoverTimeout = -1;\n    this.restartTimeout = -1;\n    this.pending = null;\n    this.lastMove = {\n      x: 0,\n      y: 0,\n      target: view.dom,\n      time: 0\n    };\n    this.checkHover = this.checkHover.bind(this);\n    view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n    view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n  }\n  update() {\n    if (this.pending) {\n      this.pending = null;\n      clearTimeout(this.restartTimeout);\n      this.restartTimeout = setTimeout(() => this.startHover(), 20);\n    }\n  }\n  get active() {\n    return this.view.state.field(this.field);\n  }\n  checkHover() {\n    this.hoverTimeout = -1;\n    if (this.active) return;\n    let hovered = Date.now() - this.lastMove.time;\n    if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);else this.startHover();\n  }\n  startHover() {\n    clearTimeout(this.restartTimeout);\n    let {\n      lastMove\n    } = this;\n    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;\n    if (pos == null) return;\n    let posCoords = this.view.coordsAtPos(pos);\n    if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth) return;\n    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n    let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n    let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);\n    if (open === null || open === void 0 ? void 0 : open.then) {\n      let pending = this.pending = {\n        pos\n      };\n      open.then(result => {\n        if (this.pending == pending) {\n          this.pending = null;\n          if (result) this.view.dispatch({\n            effects: this.setHover.of(result)\n          });\n        }\n      }, e => logException(this.view.state, e, \"hover tooltip\"));\n    } else if (open) {\n      this.view.dispatch({\n        effects: this.setHover.of(open)\n      });\n    }\n  }\n  mousemove(event) {\n    var _a;\n    this.lastMove = {\n      x: event.clientX,\n      y: event.clientY,\n      target: event.target,\n      time: Date.now()\n    };\n    if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n    let tooltip = this.active;\n    if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {\n      let {\n          pos\n        } = tooltip || this.pending,\n        end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\n      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6 /* Hover.MaxDist */)) {\n        this.view.dispatch({\n          effects: this.setHover.of(null)\n        });\n        this.pending = null;\n      }\n    }\n  }\n  mouseleave(e) {\n    clearTimeout(this.hoverTimeout);\n    this.hoverTimeout = -1;\n    if (this.active && !isInTooltip(e.relatedTarget)) this.view.dispatch({\n      effects: this.setHover.of(null)\n    });\n  }\n  destroy() {\n    clearTimeout(this.hoverTimeout);\n    this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n    this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n  }\n}\nfunction isInTooltip(elt) {\n  for (let cur = elt; cur; cur = cur.parentNode) if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\")) return true;\n  return false;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n  let range = document.createRange();\n  let fromDOM = view.domAtPos(from),\n    toDOM = view.domAtPos(to);\n  range.setEnd(toDOM.node, toDOM.offset);\n  range.setStart(fromDOM.node, fromDOM.offset);\n  let rects = range.getClientRects();\n  range.detach();\n  for (let i = 0; i < rects.length; i++) {\n    let rect = rects[i];\n    let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n    if (dist <= margin) return true;\n  }\n  return false;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/\nfunction hoverTooltip(source, options = {}) {\n  let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n  let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() {\n      return null;\n    },\n    update(value, tr) {\n      if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value))) return null;\n      if (value && tr.docChanged) {\n        let newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n        if (newPos == null) return null;\n        let copy = Object.assign(Object.create(null), value);\n        copy.pos = newPos;\n        if (value.end != null) copy.end = tr.changes.mapPos(value.end);\n        value = copy;\n      }\n      for (let effect of tr.effects) {\n        if (effect.is(setHover)) value = effect.value;\n        if (effect.is(closeHoverTooltipEffect)) value = null;\n      }\n      return value;\n    },\n    provide: f => showHoverTooltip.from(f)\n  });\n  return [hoverState, ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)), showHoverTooltipHost];\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/\nfunction getTooltip(view, tooltip) {\n  let plugin = view.plugin(tooltipPlugin);\n  if (!plugin) return null;\n  let found = plugin.manager.tooltips.indexOf(tooltip);\n  return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/\nfunction hasHoverTooltips(state) {\n  return state.facet(showHoverTooltip).some(x => x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/\nconst closeHoverTooltips = /*@__PURE__*/closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/\nfunction repositionTooltips(view) {\n  var _a;\n  (_a = view.plugin(tooltipPlugin)) === null || _a === void 0 ? void 0 : _a.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(configs) {\n    let topContainer, bottomContainer;\n    for (let c of configs) {\n      topContainer = topContainer || c.topContainer;\n      bottomContainer = bottomContainer || c.bottomContainer;\n    }\n    return {\n      topContainer,\n      bottomContainer\n    };\n  }\n});\n/**\nConfigures the panel-managing extension.\n*/\nfunction panels(config) {\n  return config ? [panelConfig.of(config)] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/\nfunction getPanel(view, panel) {\n  let plugin = view.plugin(panelPlugin);\n  let index = plugin ? plugin.specs.indexOf(panel) : -1;\n  return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.input = view.state.facet(showPanel);\n    this.specs = this.input.filter(s => s);\n    this.panels = this.specs.map(spec => spec(view));\n    let conf = view.state.facet(panelConfig);\n    this.top = new PanelGroup(view, true, conf.topContainer);\n    this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n    this.top.sync(this.panels.filter(p => p.top));\n    this.bottom.sync(this.panels.filter(p => !p.top));\n    for (let p of this.panels) {\n      p.dom.classList.add(\"cm-panel\");\n      if (p.mount) p.mount();\n    }\n  }\n  update(update) {\n    let conf = update.state.facet(panelConfig);\n    if (this.top.container != conf.topContainer) {\n      this.top.sync([]);\n      this.top = new PanelGroup(update.view, true, conf.topContainer);\n    }\n    if (this.bottom.container != conf.bottomContainer) {\n      this.bottom.sync([]);\n      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n    }\n    this.top.syncClasses();\n    this.bottom.syncClasses();\n    let input = update.state.facet(showPanel);\n    if (input != this.input) {\n      let specs = input.filter(x => x);\n      let panels = [],\n        top = [],\n        bottom = [],\n        mount = [];\n      for (let spec of specs) {\n        let known = this.specs.indexOf(spec),\n          panel;\n        if (known < 0) {\n          panel = spec(update.view);\n          mount.push(panel);\n        } else {\n          panel = this.panels[known];\n          if (panel.update) panel.update(update);\n        }\n        panels.push(panel);\n        (panel.top ? top : bottom).push(panel);\n      }\n      this.specs = specs;\n      this.panels = panels;\n      this.top.sync(top);\n      this.bottom.sync(bottom);\n      for (let p of mount) {\n        p.dom.classList.add(\"cm-panel\");\n        if (p.mount) p.mount();\n      }\n    } else {\n      for (let p of this.panels) if (p.update) p.update(update);\n    }\n  }\n  destroy() {\n    this.top.sync([]);\n    this.bottom.sync([]);\n  }\n}, {\n  provide: plugin => EditorView.scrollMargins.of(view => {\n    let value = view.plugin(plugin);\n    return value && {\n      top: value.top.scrollMargin(),\n      bottom: value.bottom.scrollMargin()\n    };\n  })\n});\nclass PanelGroup {\n  constructor(view, top, container) {\n    this.view = view;\n    this.top = top;\n    this.container = container;\n    this.dom = undefined;\n    this.classes = \"\";\n    this.panels = [];\n    this.syncClasses();\n  }\n  sync(panels) {\n    for (let p of this.panels) if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n    this.panels = panels;\n    this.syncDOM();\n  }\n  syncDOM() {\n    if (this.panels.length == 0) {\n      if (this.dom) {\n        this.dom.remove();\n        this.dom = undefined;\n      }\n      return;\n    }\n    if (!this.dom) {\n      this.dom = document.createElement(\"div\");\n      this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n      this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n      let parent = this.container || this.view.dom;\n      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n    }\n    let curDOM = this.dom.firstChild;\n    for (let panel of this.panels) {\n      if (panel.dom.parentNode == this.dom) {\n        while (curDOM != panel.dom) curDOM = rm(curDOM);\n        curDOM = curDOM.nextSibling;\n      } else {\n        this.dom.insertBefore(panel.dom, curDOM);\n      }\n    }\n    while (curDOM) curDOM = rm(curDOM);\n  }\n  scrollMargin() {\n    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n  }\n  syncClasses() {\n    if (!this.container || this.classes == this.view.themeClasses) return;\n    for (let cls of this.classes.split(\" \")) if (cls) this.container.classList.remove(cls);\n    for (let cls of (this.classes = this.view.themeClasses).split(\" \")) if (cls) this.container.classList.add(cls);\n  }\n}\nfunction rm(node) {\n  let next = node.nextSibling;\n  node.remove();\n  return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/\nconst showPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  enables: panelPlugin\n});\n\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\nclass GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n  /**\n  @internal\n  */\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  /**\n  Compare this marker to another marker of the same type.\n  */\n  eq(other) {\n    return false;\n  }\n  /**\n  Called if the marker has a `toDOM` method and its representation\n  was removed from a gutter.\n  */\n  destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\nconst gutterLineClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst defaults = {\n  class: \"\",\n  renderEmptyElements: false,\n  elementStyle: \"\",\n  markers: () => _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\n  lineMarker: () => null,\n  lineMarkerChange: null,\n  initialSpacer: null,\n  updateSpacer: null,\n  domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\nfunction gutter(config) {\n  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst unfixGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.some(x => x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\nfunction gutters(config) {\n  let result = [gutterView];\n  if (config && config.fixed === false) result.push(unfixGutters.of(true));\n  return result;\n}\nconst gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.prevViewport = view.viewport;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutters\";\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.dom.style.minHeight = this.view.contentHeight + \"px\";\n    this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n    for (let gutter of this.gutters) this.dom.appendChild(gutter.dom);\n    this.fixed = !view.state.facet(unfixGutters);\n    if (this.fixed) {\n      // FIXME IE11 fallback, which doesn't support position: sticky,\n      // by using position: relative + event handlers that realign the\n      // gutter (or just force fixed=false on IE11?)\n      this.dom.style.position = \"sticky\";\n    }\n    this.syncGutters(false);\n    view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n  }\n  update(update) {\n    if (this.updateGutters(update)) {\n      // Detach during sync when the viewport changed significantly\n      // (such as during scrolling), since for large updates that is\n      // faster.\n      let vpA = this.prevViewport,\n        vpB = update.view.viewport;\n      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n    }\n    if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n    if (this.view.state.facet(unfixGutters) != !this.fixed) {\n      this.fixed = !this.fixed;\n      this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n    }\n    this.prevViewport = update.view.viewport;\n  }\n  syncGutters(detach) {\n    let after = this.dom.nextSibling;\n    if (detach) this.dom.remove();\n    let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n    let classSet = [];\n    let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n    for (let line of this.view.viewportLineBlocks) {\n      let text;\n      if (Array.isArray(line.type)) {\n        for (let b of line.type) if (b.type == BlockType.Text) {\n          text = b;\n          break;\n        }\n      } else {\n        text = line.type == BlockType.Text ? line : undefined;\n      }\n      if (!text) continue;\n      if (classSet.length) classSet = [];\n      advanceCursor(lineClasses, classSet, line.from);\n      for (let cx of contexts) cx.line(this.view, text, classSet);\n    }\n    for (let cx of contexts) cx.finish();\n    if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n  }\n  updateGutters(update) {\n    let prev = update.startState.facet(activeGutters),\n      cur = update.state.facet(activeGutters);\n    let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n    if (prev == cur) {\n      for (let gutter of this.gutters) if (gutter.update(update)) change = true;\n    } else {\n      change = true;\n      let gutters = [];\n      for (let conf of cur) {\n        let known = prev.indexOf(conf);\n        if (known < 0) {\n          gutters.push(new SingleGutterView(this.view, conf));\n        } else {\n          this.gutters[known].update(update);\n          gutters.push(this.gutters[known]);\n        }\n      }\n      for (let g of this.gutters) {\n        g.dom.remove();\n        if (gutters.indexOf(g) < 0) g.destroy();\n      }\n      for (let g of gutters) this.dom.appendChild(g.dom);\n      this.gutters = gutters;\n    }\n    return change;\n  }\n  destroy() {\n    for (let view of this.gutters) view.destroy();\n    this.dom.remove();\n  }\n}, {\n  provide: plugin => EditorView.scrollMargins.of(view => {\n    let value = view.plugin(plugin);\n    if (!value || value.gutters.length == 0 || !value.fixed) return null;\n    return view.textDirection == Direction.LTR ? {\n      left: value.dom.offsetWidth\n    } : {\n      right: value.dom.offsetWidth\n    };\n  })\n});\nfunction asArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\nfunction advanceCursor(cursor, collect, pos) {\n  while (cursor.value && cursor.from <= pos) {\n    if (cursor.from == pos) collect.push(cursor.value);\n    cursor.next();\n  }\n}\nclass UpdateContext {\n  constructor(gutter, viewport, height) {\n    this.gutter = gutter;\n    this.height = height;\n    this.i = 0;\n    this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\n  }\n  line(view, line, extraMarkers) {\n    let localMarkers = [];\n    advanceCursor(this.cursor, localMarkers, line.from);\n    if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n    if (forLine) localMarkers.unshift(forLine);\n    let gutter = this.gutter;\n    if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n    let above = line.top - this.height;\n    if (this.i == gutter.elements.length) {\n      let newElt = new GutterElement(view, line.height, above, localMarkers);\n      gutter.elements.push(newElt);\n      gutter.dom.appendChild(newElt.dom);\n    } else {\n      gutter.elements[this.i].update(view, line.height, above, localMarkers);\n    }\n    this.height = line.bottom;\n    this.i++;\n  }\n  finish() {\n    let gutter = this.gutter;\n    while (gutter.elements.length > this.i) {\n      let last = gutter.elements.pop();\n      gutter.dom.removeChild(last.dom);\n      last.destroy();\n    }\n  }\n}\nclass SingleGutterView {\n  constructor(view, config) {\n    this.view = view;\n    this.config = config;\n    this.elements = [];\n    this.spacer = null;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n    for (let prop in config.domEventHandlers) {\n      this.dom.addEventListener(prop, event => {\n        let target = event.target,\n          y;\n        if (target != this.dom && this.dom.contains(target)) {\n          while (target.parentNode != this.dom) target = target.parentNode;\n          let rect = target.getBoundingClientRect();\n          y = (rect.top + rect.bottom) / 2;\n        } else {\n          y = event.clientY;\n        }\n        let line = view.lineBlockAtHeight(y - view.documentTop);\n        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n      });\n    }\n    this.markers = asArray(config.markers(view));\n    if (config.initialSpacer) {\n      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n      this.dom.appendChild(this.spacer.dom);\n      this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n    }\n  }\n  update(update) {\n    let prevMarkers = this.markers;\n    this.markers = asArray(this.config.markers(update.view));\n    if (this.spacer && this.config.updateSpacer) {\n      let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n      if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [updated]);\n    }\n    let vp = update.view.viewport;\n    return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n  }\n  destroy() {\n    for (let elt of this.elements) elt.destroy();\n  }\n}\nclass GutterElement {\n  constructor(view, height, above, markers) {\n    this.height = -1;\n    this.above = 0;\n    this.markers = [];\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutterElement\";\n    this.update(view, height, above, markers);\n  }\n  update(view, height, above, markers) {\n    if (this.height != height) this.dom.style.height = (this.height = height) + \"px\";\n    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n    if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n  }\n  setMarkers(view, markers) {\n    let cls = \"cm-gutterElement\",\n      domPos = this.dom.firstChild;\n    for (let iNew = 0, iOld = 0;;) {\n      let skipTo = iOld,\n        marker = iNew < markers.length ? markers[iNew++] : null,\n        matched = false;\n      if (marker) {\n        let c = marker.elementClass;\n        if (c) cls += \" \" + c;\n        for (let i = iOld; i < this.markers.length; i++) if (this.markers[i].compare(marker)) {\n          skipTo = i;\n          matched = true;\n          break;\n        }\n      } else {\n        skipTo = this.markers.length;\n      }\n      while (iOld < skipTo) {\n        let next = this.markers[iOld++];\n        if (next.toDOM) {\n          next.destroy(domPos);\n          let after = domPos.nextSibling;\n          domPos.remove();\n          domPos = after;\n        }\n      }\n      if (!marker) break;\n      if (marker.toDOM) {\n        if (matched) domPos = domPos.nextSibling;else this.dom.insertBefore(marker.toDOM(view), domPos);\n      }\n      if (matched) iOld++;\n    }\n    this.dom.className = cls;\n    this.markers = markers;\n  }\n  destroy() {\n    this.setMarkers(null, []); // First argument not used unless creating markers\n  }\n}\n\nfunction sameMarkers(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;\n  return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\nconst lineNumberMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(values) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, {\n      formatNumber: String,\n      domEventHandlers: {}\n    }, {\n      domEventHandlers(a, b) {\n        let result = Object.assign({}, a);\n        for (let event in b) {\n          let exists = result[event],\n            add = b[event];\n          result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n        }\n        return result;\n      }\n    });\n  }\n});\nclass NumberMarker extends GutterMarker {\n  constructor(number) {\n    super();\n    this.number = number;\n  }\n  eq(other) {\n    return this.number == other.number;\n  }\n  toDOM() {\n    return document.createTextNode(this.number);\n  }\n}\nfunction formatNumber(view, number) {\n  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\n  class: \"cm-lineNumbers\",\n  renderEmptyElements: false,\n  markers(view) {\n    return view.state.facet(lineNumberMarkers);\n  },\n  lineMarker(view, line, others) {\n    if (others.some(m => m.toDOM)) return null;\n    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n  },\n  lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n  initialSpacer(view) {\n    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n  },\n  updateSpacer(spacer, update) {\n    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n    return max == spacer.number ? spacer : new NumberMarker(max);\n  },\n  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n}));\n/**\nCreate a line number gutter extension.\n*/\nfunction lineNumbers(config = {}) {\n  return [lineNumberConfig.of(config), gutters(), lineNumberGutter];\n}\nfunction maxLineNumber(lines) {\n  let last = 9;\n  while (last < lines) last = last * 10 + 9;\n  return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\n  constructor() {\n    super(...arguments);\n    this.elementClass = \"cm-activeLineGutter\";\n  }\n}();\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\n  let marks = [],\n    last = -1;\n  for (let range of state.selection.ranges) {\n    let linePos = state.doc.lineAt(range.head).from;\n    if (linePos > last) {\n      last = linePos;\n      marks.push(activeLineGutterMarker.range(linePos));\n    }\n  }\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\nfunction highlightActiveLineGutter() {\n  return activeLineGutterHighlighter;\n}\nconst WhitespaceDeco = /*@__PURE__*/new Map();\nfunction getWhitespaceDeco(space) {\n  let deco = WhitespaceDeco.get(space);\n  if (!deco) WhitespaceDeco.set(space, deco = Decoration.mark({\n    attributes: space === \"\\t\" ? {\n      class: \"cm-highlightTab\"\n    } : {\n      class: \"cm-highlightSpace\",\n      \"data-display\": space.replace(/ /g, \"·\")\n    }\n  }));\n  return deco;\n}\nfunction matcher(decorator) {\n  return ViewPlugin.define(view => ({\n    decorations: decorator.createDeco(view),\n    update(u) {\n      this.decorations = decorator.updateDeco(u, this.decorations);\n    }\n  }), {\n    decorations: v => v.decorations\n  });\n}\nconst whitespaceHighlighter = /*@__PURE__*/matcher( /*@__PURE__*/new MatchDecorator({\n  regexp: /\\t| +/g,\n  decoration: match => getWhitespaceDeco(match[0]),\n  boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/\nfunction highlightWhitespace() {\n  return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/matcher( /*@__PURE__*/new MatchDecorator({\n  regexp: /\\s+$/g,\n  decoration: /*@__PURE__*/Decoration.mark({\n    class: \"cm-trailingSpace\"\n  }),\n  boundary: /\\S/\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/\nfunction highlightTrailingWhitespace() {\n  return trailingHighlighter;\n}\n\n/**\n@internal\n*/\nconst __test = {\n  HeightMap,\n  HeightOracle,\n  MeasuredHeights,\n  QueryType,\n  ChangedRange,\n  computeOrder,\n  moveVisually\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFJQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBSUE7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3ZpZXcvZGlzdC9pbmRleC5qcz8wMmQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHQsIFJhbmdlU2V0LCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBGYWNldCwgU3RhdGVFZmZlY3QsIENoYW5nZVNldCwgZmluZENsdXN0ZXJCcmVhaywgRWRpdG9yU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgZmluZENvbHVtbiwgQ2hhckNhdGVnb3J5LCBUcmFuc2FjdGlvbiwgUHJlYywgY29kZVBvaW50QXQsIGNvZGVQb2ludFNpemUsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFJhbmdlU2V0QnVpbGRlciwgY291bnRDb2x1bW4gfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5pbXBvcnQgeyBrZXlOYW1lLCBiYXNlLCBzaGlmdCB9IGZyb20gJ3czYy1rZXluYW1lJztcblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHJvb3QpIHtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIC8vIEJyb3dzZXJzIGRpZmZlciBvbiB3aGV0aGVyIHNoYWRvdyByb290cyBoYXZlIGEgZ2V0U2VsZWN0aW9uXG4gICAgLy8gbWV0aG9kLiBJZiBpdCBleGlzdHMsIHVzZSB0aGF0LCBvdGhlcndpc2UsIGNhbGwgaXQgb24gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgaWYgKHJvb3Qubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgdGFyZ2V0ID0gcm9vdC5nZXRTZWxlY3Rpb24gPyByb290IDogcm9vdC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKGRvbSwgbm9kZSkge1xuICAgIHJldHVybiBub2RlID8gZG9tID09IG5vZGUgfHwgZG9tLmNvbnRhaW5zKG5vZGUubm9kZVR5cGUgIT0gMSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKGRvbSwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gY29udGFpbnMoZG9tLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0c0Zvcihkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2UoZG9tLCAwLCBkb20ubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGRvbS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFtdO1xufVxuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuZnVuY3Rpb24gaXNFcXVpdmFsZW50UG9zaXRpb24obm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSA/IChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkb21JbmRleChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCBkaXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG1heE9mZnNldChub2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG1heE9mZnNldChub2RlKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXhPZmZzZXQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuY29uc3QgUmVjdDAgPSB7IGxlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuZnVuY3Rpb24gZmxhdHRlblJlY3QocmVjdCwgbGVmdCkge1xuICAgIGxldCB4ID0gbGVmdCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgcmV0dXJuIHsgbGVmdDogeCwgcmlnaHQ6IHgsIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC5ib3R0b20gfTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1JlY3Qod2luKSB7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLFxuICAgICAgICB0b3A6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0IH07XG59XG5mdW5jdGlvbiBzY3JvbGxSZWN0SW50b1ZpZXcoZG9tLCByZWN0LCBzaWRlLCB4LCB5LCB4TWFyZ2luLCB5TWFyZ2luLCBsdHIpIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQsIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSkgeyAvLyBFbGVtZW50XG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHNjcm9sbGJhciB3aWR0aCBpc24ndCBpbmNsdWRlZCBpbiB0aGUgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgYm91bmRpbmcgPSB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIGN1ci5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGN1ci5jbGllbnRIZWlnaHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3ZlWCA9IDAsIG1vdmVZID0gMDtcbiAgICAgICAgICAgIGlmICh5ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QudG9wIDwgYm91bmRpbmcudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgKHJlY3QudG9wIC0gbW92ZVkpIDwgYm91bmRpbmcudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCArIG1vdmVZIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3AsIGJvdW5kaW5nSGVpZ2h0ID0gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRUb3AgPSB5ID09IFwiY2VudGVyXCIgJiYgcmVjdEhlaWdodCA8PSBib3VuZGluZ0hlaWdodCA/IHJlY3QudG9wICsgcmVjdEhlaWdodCAvIDIgLSBib3VuZGluZ0hlaWdodCAvIDIgOlxuICAgICAgICAgICAgICAgICAgICB5ID09IFwic3RhcnRcIiB8fCB5ID09IFwiY2VudGVyXCIgJiYgc2lkZSA8IDAgPyByZWN0LnRvcCAtIHlNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5ib3R0b20gLSBib3VuZGluZ0hlaWdodCArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVkgPSB0YXJnZXRUb3AgLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVggKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA8IDAgJiYgcmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgKyBtb3ZlWCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMZWZ0ID0geCA9PSBcImNlbnRlclwiID8gcmVjdC5sZWZ0ICsgKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMiAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpIC8gMiA6XG4gICAgICAgICAgICAgICAgICAgICh4ID09IFwic3RhcnRcIikgPT0gbHRyID8gcmVjdC5sZWZ0IC0geE1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnJpZ2h0IC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgKyB4TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVYID0gdGFyZ2V0TGVmdCAtIGJvdW5kaW5nLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxCeShtb3ZlWCwgbW92ZVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vdmVkWCA9IDAsIG1vdmVkWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZFkgPSBjdXIuc2Nyb2xsVG9wIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gY3VyLnNjcm9sbExlZnQgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBtb3ZlZFgsIHRvcDogcmVjdC50b3AgLSBtb3ZlZFksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIG1vdmVkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIG1vdmVkWSB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRYICYmIE1hdGguYWJzKG1vdmVkWCAtIG1vdmVYKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFkgJiYgTWF0aC5hYnMobW92ZWRZIC0gbW92ZVkpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHsgLy8gQSBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjcm9sbGFibGVQYXJlbnQoZG9tKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbS5wYXJlbnROb2RlOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gZG9jLmJvZHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA+IGN1ci5jbGllbnRIZWlnaHQgfHwgY3VyLnNjcm9sbFdpZHRoID4gY3VyLmNsaWVudFdpZHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkge1xuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIERPTVNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlcShkb21TZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yTm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiB0aGlzLmFuY2hvck9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLmZvY3VzTm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIHRoaXMuZm9jdXNPZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLnNldChyYW5nZS5hbmNob3JOb2RlLCByYW5nZS5hbmNob3JPZmZzZXQsIHJhbmdlLmZvY3VzTm9kZSwgcmFuZ2UuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICBzZXQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXIsIGN1ci5zY3JvbGxUb3AsIGN1ci5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKGN1ciA9PSBjdXIub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gc3RhY2tbaSsrXSwgdG9wID0gc3RhY2tbaSsrXSwgbGVmdCA9IHN0YWNrW2krK107XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzY3JhdGNoUmFuZ2U7XG5mdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20pO1xuICAgIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoS2V5KGVsdCwgbmFtZSwgY29kZSkge1xuICAgIGxldCBvcHRpb25zID0geyBrZXk6IG5hbWUsIGNvZGU6IG5hbWUsIGtleUNvZGU6IGNvZGUsIHdoaWNoOiBjb2RlLCBjYW5jZWxhYmxlOiB0cnVlIH07XG4gICAgbGV0IGRvd24gPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgb3B0aW9ucyk7XG4gICAgZG93bi5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KGRvd24pO1xuICAgIGxldCB1cCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgb3B0aW9ucyk7XG4gICAgdXAuc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudCh1cCk7XG4gICAgcmV0dXJuIGRvd24uZGVmYXVsdFByZXZlbnRlZCB8fCB1cC5kZWZhdWx0UHJldmVudGVkO1xufVxuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT0gOSB8fCBub2RlLm5vZGVUeXBlID09IDExICYmIG5vZGUuaG9zdCkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbGVhckF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5vZGUobm9kZS5hdHRyaWJ1dGVzWzBdKTtcbn1cbmZ1bmN0aW9uIGF0RWxlbWVudFN0YXJ0KGRvYywgc2VsZWN0aW9uKSB7XG4gICAgbGV0IG5vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JOb2RlICE9IG5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgPT0gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cbmNvbnN0IG5vQ2hpbGRyZW4gPSBbXTtcbmNsYXNzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlydHkgPSAyIC8qIERpcnR5Lk5vZGUgKi87XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodmlldykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodmlldykgKyB2aWV3Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gV2lsbCByZXR1cm4gYSByZWN0YW5nbGUgZGlyZWN0bHkgYmVmb3JlICh3aGVuIHNpZGUgPCAwKSwgYWZ0ZXJcbiAgICAvLyAoc2lkZSA+IDApIG9yIGRpcmVjdGx5IG9uICh3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIGl0KSB0aGVcbiAgICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgICBjb29yZHNBdChfcG9zLCBfc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgJiAyIC8qIERpcnR5Lk5vZGUgKi8pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbCwgbmV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5kb20gJiYgKG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50VmlldyB8fCAhY29udGVudFZpZXcucGFyZW50ICYmIGNvbnRlbnRWaWV3LmNhblJldXNlRE9NKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZXVzZURPTShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSAwIC8qIERpcnR5Lk5vdCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmICF0cmFjay53cml0dGVuICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmIDEgLyogRGlydHkuQ2hpbGQgKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IDAgLyogRGlydHkuTm90ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShfZG9tKSB7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChiaWFzID09IDAgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIgPT0gdGhpcy5kb20uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIgJiYgIUNvbnRlbnRWaWV3LmdldChhZnRlcikpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20gPT0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZnJvbUkgPSAtMSwgZnJvbVN0YXJ0ID0gLTEsIHRvSSA9IC0xLCB0b0VuZCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0LCBwcmV2RW5kID0gb2Zmc2V0OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgcG9zKTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gZnJvbSAmJiBmcm9tSSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZyb21JID0gaTtcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID4gdG8gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0b0kgPSBpO1xuICAgICAgICAgICAgICAgIHRvRW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZFbmQgPSBlbmQ7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb21TdGFydCwgdG86IHRvRW5kIDwgMCA/IG9mZnNldCArIHRoaXMubGVuZ3RoIDogdG9FbmQsXG4gICAgICAgICAgICBzdGFydERPTTogKGZyb21JID8gdGhpcy5jaGlsZHJlbltmcm9tSSAtIDFdLmRvbS5uZXh0U2libGluZyA6IG51bGwpIHx8IHRoaXMuZG9tLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBlbmRET006IHRvSSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHRvSSA+PSAwID8gdGhpcy5jaGlsZHJlblt0b0ldLmRvbSA6IG51bGwgfTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGFuZFBhcmVudCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGlydHkgfD0gMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkoYW5kUGFyZW50KTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTGlzdClcbiAgICAgICAgICAgICAgICBwYXJlbnQuZGlydHkgfD0gMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5kaXJ0eSAmIDEgLyogRGlydHkuQ2hpbGQgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyZW50LmRpcnR5IHw9IDEgLyogRGlydHkuQ2hpbGQgKi87XG4gICAgICAgICAgICBjaGlsZExpc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERPTShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5kb20uY21WaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIGRvbS5jbVZpZXcgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgcm9vdFZpZXcoKSB7XG4gICAgICAgIGZvciAobGV0IHYgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB2LnBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgdiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlQ2hpbGRyZW4oZnJvbSwgdG8sIGNoaWxkcmVuID0gbm9DaGlsZHJlbikge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGZyb20sIHRvIC0gZnJvbSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY2hpbGRyZW5baV0uc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihfcmVjKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlnbm9yZUV2ZW50KF9ldmVudCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICBjaGlsZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIGJpYXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUucmVwbGFjZShcIlZpZXdcIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBuYW1lICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyB0aGlzLmNoaWxkcmVuLmpvaW4oKSArIFwiKVwiIDpcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID8gXCJbXCIgKyAobmFtZSA9PSBcIlRleHRcIiA/IHRoaXMudGV4dCA6IHRoaXMubGVuZ3RoKSArIFwiXVwiIDogXCJcIikgK1xuICAgICAgICAgICAgKHRoaXMuYnJlYWtBZnRlciA/IFwiI1wiIDogXCJcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQobm9kZSkgeyByZXR1cm4gbm9kZS5jbVZpZXc7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7IHJldHVybiBvdGhlci5jb25zdHJ1Y3RvciA9PSB0aGlzLmNvbnN0cnVjdG9yOyB9XG4gICAgLy8gV2hlbiB0aGlzIGlzIGEgemVyby1sZW5ndGggdmlldyB3aXRoIGEgc2lkZSwgdGhpcyBzaG91bGQgcmV0dXJuIGFcbiAgICAvLyBudW1iZXIgPD0gMCB0byBpbmRpY2F0ZSBpdCBpcyBiZWZvcmUgaXRzIHBvc2l0aW9uLCBvciBhXG4gICAgLy8gbnVtYmVyID4gMCB3aGVuIGFmdGVyIGl0cyBwb3NpdGlvbi5cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG59XG5Db250ZW50Vmlldy5wcm90b3R5cGUuYnJlYWtBZnRlciA9IDA7XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybSQxKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jbGFzcyBDaGlsZEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHBvcywgaSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGZpbmRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXG4gICAgICAgICAgICAgICAgKGJpYXMgPiAwIHx8IHRoaXMuaSA9PSAwIHx8IHRoaXMuY2hpbGRyZW5bdGhpcy5pIC0gMV0uYnJlYWtBZnRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiA9IHBvcyAtIHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGxldCBiZWZvcmUgPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbltmcm9tSV0gOiBudWxsO1xuICAgIGxldCBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCA/IGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGxldCBicmVha0F0RW5kID0gbGFzdCA/IGxhc3QuYnJlYWtBZnRlciA6IGJyZWFrQXRTdGFydDtcbiAgICAvLyBDaGFuZ2Ugd2l0aGluIGEgc2luZ2xlIGNoaWxkXG4gICAgaWYgKGZyb21JID09IHRvSSAmJiBiZWZvcmUgJiYgIWJyZWFrQXRTdGFydCAmJiAhYnJlYWtBdEVuZCAmJiBpbnNlcnQubGVuZ3RoIDwgMiAmJlxuICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgdG9PZmYsIGluc2VydC5sZW5ndGggPyBsYXN0IDogbnVsbCwgZnJvbU9mZiA9PSAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHRvSSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBjaGlsZHJlblt0b0ldO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVuZCBvZiB0aGUgY2hpbGQgYWZ0ZXIgdGhlIHVwZGF0ZSBpcyBwcmVzZXJ2ZWQgaW4gYGFmdGVyYFxuICAgICAgICBpZiAoYWZ0ZXIgJiYgdG9PZmYgPCBhZnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHNwbGl0dGluZyBhIGNoaWxkLCBzZXBhcmF0ZSBwYXJ0IG9mIGl0IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgICAgIC8vIGJlaW5nIG1hbmdsZWQgd2hlbiB1cGRhdGluZyB0aGUgY2hpbGQgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoZnJvbUkgPT0gdG9JKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zcGxpdCh0b09mZik7XG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHJlcGxhY2VtZW50IHNob3VsZCBiZSBtZXJnZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcbiAgICAgICAgICAgIGlmICghYnJlYWtBdEVuZCAmJiBsYXN0ICYmIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBsYXN0LCB0cnVlLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgIGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gPSBhZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGFmdGVyIGVsZW1lbnQsIGlmIG5lY2Vzc2FyeSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IHRvIGBjb250ZW50YC5cbiAgICAgICAgICAgICAgICBpZiAodG9PZmYpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBudWxsLCBmYWxzZSwgMCwgb3BlbkVuZCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09PSBudWxsIHx8IGFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZnRlci5icmVha0FmdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhdCBgdG9JYCBpcyBlbnRpcmVseSBjb3ZlcmVkIGJ5IHRoaXMgcmFuZ2UuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpdHMgbGluZSBicmVhaywgaWYgYW55LlxuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgbGFzdC5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGhhbmRsZWQgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRzXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxuICAgICAgICB0b0krKztcbiAgICB9XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGJyZWFrQXRTdGFydDtcbiAgICAgICAgaWYgKGZyb21PZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRTdGFydCAmJiBpbnNlcnQubGVuZ3RoICYmIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBpbnNlcnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBpbnNlcnQuc2hpZnQoKS5icmVha0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbU9mZiA8IGJlZm9yZS5sZW5ndGggfHwgYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAmJiBiZWZvcmUuY2hpbGRyZW5bYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIG51bGwsIGZhbHNlLCBvcGVuU3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gbWVyZ2Ugd2lkZ2V0cyBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICB3aGlsZSAoZnJvbUkgPCB0b0kgJiYgaW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bdG9JIC0gMV0uYmVjb21lKGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICB0b0ktLTtcbiAgICAgICAgICAgIGluc2VydC5wb3AoKTtcbiAgICAgICAgICAgIG9wZW5FbmQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5TdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltmcm9tSV0uYmVjb21lKGluc2VydFswXSkpIHtcbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgICAgICBpbnNlcnQuc2hpZnQoKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlbkVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zZXJ0Lmxlbmd0aCAmJiBmcm9tSSAmJiB0b0kgPCBjaGlsZHJlbi5sZW5ndGggJiYgIWNoaWxkcmVuW2Zyb21JIC0gMV0uYnJlYWtBZnRlciAmJlxuICAgICAgICBjaGlsZHJlblt0b0ldLm1lcmdlKDAsIDAsIGNoaWxkcmVuW2Zyb21JIC0gMV0sIGZhbHNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICBmcm9tSS0tO1xuICAgIGlmIChmcm9tSSA8IHRvSSB8fCBpbnNlcnQubGVuZ3RoKVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkcmVuKGZyb21JLCB0b0ksIGluc2VydCk7XG59XG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuSW50byhwYXJlbnQsIGZyb20sIHRvLCBpbnNlcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCBjdXIgPSBwYXJlbnQuY2hpbGRDdXJzb3IoKTtcbiAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1ci5maW5kUG9zKHRvLCAxKTtcbiAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXIuZmluZFBvcyhmcm9tLCAtMSk7XG4gICAgbGV0IGRMZW4gPSBmcm9tIC0gdG87XG4gICAgZm9yIChsZXQgdmlldyBvZiBpbnNlcnQpXG4gICAgICAgIGRMZW4gKz0gdmlldy5sZW5ndGg7XG4gICAgcGFyZW50Lmxlbmd0aCArPSBkTGVuO1xuICAgIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIDAsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbmxldCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiB7IHVzZXJBZ2VudDogXCJcIiwgdmVuZG9yOiBcIlwiLCBwbGF0Zm9ybTogXCJcIiB9O1xubGV0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB7IGRvY3VtZW50RWxlbWVudDogeyBzdHlsZToge30gfSB9O1xuY29uc3QgaWVfZWRnZSA9IC8qQF9fUFVSRV9fKi8vRWRnZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC8qQF9fUFVSRV9fKi8vTVNJRSBcXGQvLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gLypAX19QVVJFX18qLy9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL2dlY2tvXFwvKFxcZCspL2kudGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IHdlYmtpdCA9IFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgLypAX19QVVJFX18qLy9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoLypAX19QVVJFX18qLy9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdi51c2VyQWdlbnQpIHx8IG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xudmFyIGJyb3dzZXIgPSB7XG4gICAgbWFjOiBpb3MgfHwgLypAX19QVVJFX18qLy9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICB3aW5kb3dzOiAvKkBfX1BVUkVfXyovL1dpbi8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGxpbnV4OiAvKkBfX1BVUkVfXyovL0xpbnV4fFgxMS8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGllLFxuICAgIGllX3ZlcnNpb246IGllX3VwdG8xMCA/IGRvYy5kb2N1bWVudE1vZGUgfHwgNiA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDAsXG4gICAgZ2Vja28sXG4gICAgZ2Vja29fdmVyc2lvbjogZ2Vja28gPyArKC8qQF9fUFVSRV9fKi8vRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICBjaHJvbWU6ICEhY2hyb21lLFxuICAgIGNocm9tZV92ZXJzaW9uOiBjaHJvbWUgPyArY2hyb21lWzFdIDogMCxcbiAgICBpb3MsXG4gICAgYW5kcm9pZDogLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdi51c2VyQWdlbnQpLFxuICAgIHdlYmtpdCxcbiAgICBzYWZhcmksXG4gICAgd2Via2l0X3ZlcnNpb246IHdlYmtpdCA/ICsoLypAX19QVVJFX18qLy9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICB0YWJTaXplOiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRhYlNpemUgIT0gbnVsbCA/IFwidGFiLXNpemVcIiA6IFwiLW1vei10YWItc2l6ZVwiXG59O1xuXG5jb25zdCBNYXhKb2luTGVuID0gMjU2O1xuY2xhc3MgVGV4dFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGNyZWF0ZURPTSh0ZXh0RE9NKSB7XG4gICAgICAgIHRoaXMuc2V0RE9NKHRleHRET00gfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbS5ub2RlVmFsdWUgIT0gdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2subm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLm5vZGVWYWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oZG9tKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgc291cmNlLmxlbmd0aCA+IE1heEpvaW5MZW4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSkgKyAoc291cmNlID8gc291cmNlLnRleHQgOiBcIlwiKSArIHRoaXMudGV4dC5zbGljZSh0byk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKGZyb20pKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBub2RlID09IHRoaXMuZG9tID8gb2Zmc2V0IDogb2Zmc2V0ID8gdGhpcy50ZXh0Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gbmV3IERPTVBvcyh0aGlzLmRvbSwgcG9zKTsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChfZnJvbSwgX3RvLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2Zmc2V0LCB0bzogb2Zmc2V0ICsgdGhpcy5sZW5ndGgsIHN0YXJ0RE9NOiB0aGlzLmRvbSwgZW5kRE9NOiB0aGlzLmRvbS5uZXh0U2libGluZyB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxufVxuY2xhc3MgTWFya1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IobWFyaywgY2hpbGRyZW4gPSBbXSwgbGVuZ3RoID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGNoLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgc2V0QXR0cnMoZG9tKSB7XG4gICAgICAgIGNsZWFyQXR0cmlidXRlcyhkb20pO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmNsYXNzKVxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IHRoaXMubWFyay5jbGFzcztcbiAgICAgICAgaWYgKHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdGhpcy5tYXJrLmF0dHJzW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgcmV1c2VET00obm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSB0aGlzLm1hcmsudGFnTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgfD0gNCAvKiBEaXJ0eS5BdHRycyAqLyB8IDIgLyogRGlydHkuTm9kZSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLnNldEF0dHJzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlydHkgJiA0IC8qIERpcnR5LkF0dHJzICovKVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRycyh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLnN5bmModmlldywgdHJhY2spO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBfaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIHNvdXJjZS5tYXJrLmVxKHRoaXMubWFyaykpIHx8XG4gICAgICAgICAgICAoZnJvbSAmJiBvcGVuU3RhcnQgPD0gMCkgfHwgKHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4gOiBbXSwgb3BlblN0YXJ0IC0gMSwgb3BlbkVuZCAtIDEpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIG9mZiA9IDAsIGRldGFjaEZyb20gPSAtMSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gb2ZmICsgZWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9mZiA8IGZyb20gPyBlbHQuc3BsaXQoZnJvbSAtIG9mZikgOiBlbHQpO1xuICAgICAgICAgICAgaWYgKGRldGFjaEZyb20gPCAwICYmIG9mZiA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIGRldGFjaEZyb20gPSBpO1xuICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbTtcbiAgICAgICAgaWYgKGRldGFjaEZyb20gPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBkZXRhY2hGcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3KHRoaXMubWFyaywgcmVzdWx0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGxlbmd0aCA9IHRleHQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBpZiAocG9zID4gbGVuZ3RoKVxuICAgICAgICBwb3MgPSBsZW5ndGg7XG4gICAgbGV0IGZyb20gPSBwb3MsIHRvID0gcG9zLCBmbGF0dGVuID0gMDtcbiAgICBpZiAocG9zID09IDAgJiYgc2lkZSA8IDAgfHwgcG9zID09IGxlbmd0aCAmJiBzaWRlID49IDApIHtcbiAgICAgICAgaWYgKCEoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykpIHsgLy8gVGhlc2UgYnJvd3NlcnMgcmVsaWFibHkgcmV0dXJuIHZhbGlkIHJlY3RhbmdsZXMgZm9yIGVtcHR5IHJhbmdlc1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gMTtcbiAgICAgICAgICAgIH0gLy8gRklYTUUgdGhpcyBpcyB3cm9uZyBpbiBSVEwgdGV4dFxuICAgICAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNpZGUgPCAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgfVxuICAgIGxldCByZWN0cyA9IHRleHRSYW5nZSh0ZXh0LCBmcm9tLCB0bykuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFJlY3QwO1xuICAgIGxldCByZWN0ID0gcmVjdHNbKGZsYXR0ZW4gPyBmbGF0dGVuIDwgMCA6IHNpZGUgPj0gMCkgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFmbGF0dGVuICYmIHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmVjdCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIHIgPT4gci53aWR0aCkgfHwgcmVjdDtcbiAgICByZXR1cm4gZmxhdHRlbiA/IGZsYXR0ZW5SZWN0KHJlY3QsIGZsYXR0ZW4gPCAwKSA6IHJlY3QgfHwgbnVsbDtcbn1cbi8vIEFsc28gdXNlZCBmb3IgY29sbGFwc2VkIHJhbmdlcyB0aGF0IGRvbid0IGhhdmUgYSBwbGFjZWhvbGRlciB3aWRnZXQhXG5jbGFzcyBXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZSh3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICByZXR1cm4gbmV3ICh3aWRnZXQuY3VzdG9tVmlldyB8fCBXaWRnZXRWaWV3KSh3aWRnZXQsIGxlbmd0aCwgc2lkZSk7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFdpZGdldFZpZXcuY3JlYXRlKHRoaXMud2lkZ2V0LCB0aGlzLmxlbmd0aCAtIGZyb20sIHRoaXMuc2lkZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IGZyb207XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5sZW5ndGggPT0gdGhpcy5sZW5ndGggJiYgb3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWRnZXQuY29uc3RydWN0b3IgPT0gb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5lcShvdGhlci53aWRnZXQpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0b3AucGFyZW50KVxuICAgICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdG9wLCB0ZXh0ID0gdmlldyAmJiB2aWV3LnN0YXRlLmRvYywgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB0ZXh0ID8gdGV4dC5zbGljZShzdGFydCwgc3RhcnQgKyB0aGlzLmxlbmd0aCkgOiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gdGhpcy5kb20uZ2V0Q2xpZW50UmVjdHMoKSwgcmVjdCA9IG51bGw7XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFJlY3QwO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zID4gMCA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwOzsgaSArPSAocG9zID4gMCA/IC0xIDogMSkpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChwb3MgPiAwID8gaSA9PSAwIDogaSA9PSByZWN0cy5sZW5ndGggLSAxIHx8IHJlY3QudG9wIDwgcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID8gcmVjdCA6IGZsYXR0ZW5SZWN0KHJlY3QsIHRoaXMuc2lkZSA+IDApO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG59XG5jbGFzcyBDb21wb3NpdGlvblZpZXcgZXh0ZW5kcyBXaWRnZXRWaWV3IHtcbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgdG9wVmlldywgdGV4dCB9ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgIGlmICghdG9wVmlldylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRE9NUG9zKHRleHQsIE1hdGgubWluKHBvcywgdGV4dC5ub2RlVmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiBzY2FuQ29tcG9zaXRpb25UcmVlKHBvcywgMCwgdG9wVmlldywgdGV4dCwgKHYsIHApID0+IHYuZG9tQXRQb3MocCksIHAgPT4gbmV3IERPTVBvcyh0ZXh0LCBNYXRoLm1pbihwLCB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpKSk7XG4gICAgfVxuICAgIHN5bmMoKSB7IHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKCkpOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyB0b3BWaWV3LCB0ZXh0IH0gPSB0aGlzLndpZGdldDtcbiAgICAgICAgaWYgKCF0b3BWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKG9mZnNldCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcG9zRnJvbURPTUluQ29tcG9zaXRpb25UcmVlKG5vZGUsIG9mZnNldCwgdG9wVmlldywgdGV4dCk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyB0b3BWaWV3LCB0ZXh0IH0gPSB0aGlzLndpZGdldDtcbiAgICAgICAgaWYgKCF0b3BWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIHNjYW5Db21wb3NpdGlvblRyZWUocG9zLCBzaWRlLCB0b3BWaWV3LCB0ZXh0LCAodiwgcG9zLCBzaWRlKSA9PiB2LmNvb3Jkc0F0KHBvcywgc2lkZSksIChwb3MsIHNpZGUpID0+IHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICAoX2EgPSB0aGlzLndpZGdldC50b3BWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjYW5SZXVzZURPTSgpIHsgcmV0dXJuIHRydWU7IH1cbn1cbi8vIFVzZXMgdGhlIG9sZCBzdHJ1Y3R1cmUgb2YgYSBjaHVuayBvZiBjb250ZW50IHZpZXcgZnJvemVuIGZvclxuLy8gY29tcG9zaXRpb24gdG8gdHJ5IGFuZCBmaW5kIGEgcmVhc29uYWJsZSBET00gbG9jYXRpb24gZm9yIHRoZSBnaXZlblxuLy8gb2Zmc2V0LlxuZnVuY3Rpb24gc2NhbkNvbXBvc2l0aW9uVHJlZShwb3MsIHNpZGUsIHZpZXcsIHRleHQsIGVudGVyVmlldywgZnJvbVRleHQpIHtcbiAgICBpZiAodmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gdmlldy5kb20uZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gQ29udGVudFZpZXcuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbVRleHQocG9zLCBzaWRlKTtcbiAgICAgICAgICAgIGxldCBoYXNDb21wID0gY29udGFpbnMoY2hpbGQsIHRleHQpO1xuICAgICAgICAgICAgbGV0IGxlbiA9IGRlc2MubGVuZ3RoICsgKGhhc0NvbXAgPyB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW4gfHwgcG9zID09IGxlbiAmJiBkZXNjLmdldFNpZGUoKSA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNDb21wID8gc2NhbkNvbXBvc2l0aW9uVHJlZShwb3MsIHNpZGUsIGRlc2MsIHRleHQsIGVudGVyVmlldywgZnJvbVRleHQpIDogZW50ZXJWaWV3KGRlc2MsIHBvcywgc2lkZSk7XG4gICAgICAgICAgICBwb3MgLT0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRlclZpZXcodmlldywgdmlldy5sZW5ndGgsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5kb20gPT0gdGV4dCkge1xuICAgICAgICByZXR1cm4gZnJvbVRleHQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBlbnRlclZpZXcodmlldywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCB2aWV3LCB0ZXh0KSB7XG4gICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldykge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB2aWV3LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gMCwgaGFzQ29tcCA9IGNvbnRhaW5zKGNoaWxkLmRvbSwgdGV4dCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMoY2hpbGQuZG9tLCBub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zICsgKGhhc0NvbXAgPyBwb3NGcm9tRE9NSW5Db21wb3NpdGlvblRyZWUobm9kZSwgb2Zmc2V0LCBjaGlsZCwgdGV4dCkgOiBjaGlsZC5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICBwb3MgKz0gaGFzQ29tcCA/IHRleHQubm9kZVZhbHVlLmxlbmd0aCA6IGNoaWxkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LmRvbSA9PSB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihvZmZzZXQsIHRleHQubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xufVxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2Zcbi8vIGJyb3dzZXIgYnVncyB0aGF0IHNob3cgdXAgd2hlbiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IG5leHQgdG9cbi8vIHVuZWRpdGFibGUgaW5saW5lIGNvbnRlbnQuXG5jbGFzcyBXaWRnZXRCdWZmZXJWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbiAgICBtZXJnZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldEJ1ZmZlclZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGU7XG4gICAgfVxuICAgIHNwbGl0KCkgeyByZXR1cm4gbmV3IFdpZGdldEJ1ZmZlclZpZXcodGhpcy5zaWRlKTsgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY20td2lkZ2V0QnVmZmVyXCI7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zKSB7XG4gICAgICAgIGxldCBpbWdSZWN0ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIFNpbmNlIHRoZSA8aW1nPiBoZWlnaHQgZG9lc24ndCBjb3JyZXNwb25kIHRvIHRleHQgaGVpZ2h0LCB0cnlcbiAgICAgICAgLy8gdG8gYm9ycm93IHRoZSBoZWlnaHQgZnJvbSBzb21lIHNpYmxpbmcgbm9kZS5cbiAgICAgICAgbGV0IHNpYmxpbmdSZWN0ID0gaW5saW5lU2libGluZ1JlY3QodGhpcywgdGhpcy5zaWRlID4gMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWJsaW5nUmVjdCAmJiBzaWJsaW5nUmVjdC50b3AgPCBpbWdSZWN0LmJvdHRvbSAmJiBzaWJsaW5nUmVjdC5ib3R0b20gPiBpbWdSZWN0LnRvcFxuICAgICAgICAgICAgPyB7IGxlZnQ6IGltZ1JlY3QubGVmdCwgcmlnaHQ6IGltZ1JlY3QucmlnaHQsIHRvcDogc2libGluZ1JlY3QudG9wLCBib3R0b206IHNpYmxpbmdSZWN0LmJvdHRvbSB9IDogaW1nUmVjdDtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgfVxufVxuVGV4dFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRCdWZmZXJWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IG5vQ2hpbGRyZW47XG5mdW5jdGlvbiBpbmxpbmVTaWJsaW5nUmVjdCh2aWV3LCBzaWRlKSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcucGFyZW50LCBpbmRleCA9IHBhcmVudCA/IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHZpZXcpIDogLTE7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgIGlmIChzaWRlIDwgMCA/IGluZGV4ID4gMCA6IGluZGV4IDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggKyBzaWRlXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVGV4dFZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFJlY3QgPSBuZXh0LmNvb3Jkc0F0KHNpZGUgPCAwID8gbmV4dC5sZW5ndGggOiAwLCBzaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFJlY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0UmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IHNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnQucGFyZW50LmNoaWxkcmVuLmluZGV4T2YocGFyZW50KSArIChzaWRlIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHBhcmVudC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5ub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3QuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpbmxpbmVET01BdFBvcyhwYXJlbnQsIHBvcykge1xuICAgIGxldCBkb20gPSBwYXJlbnQuZG9tLCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQsIGkgPSAwO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID09IG9mZiAmJiBjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocG9zID4gb2ZmICYmIHBvcyA8IGVuZCAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQXRQb3MocG9zIC0gb2ZmKTtcbiAgICAgICAgaWYgKHBvcyA8PSBvZmYpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICBsZXQgcHJldiA9IGNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgaWYgKHByZXYuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tQXRQb3MocHJldi5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgIGlmIChuZXh0LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUF0UG9zKDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERPTVBvcyhkb20sIDApO1xufVxuLy8gQXNzdW1lcyBgdmlld2AsIGlmIGEgbWFyayB2aWV3LCBoYXMgcHJlY2lzZWx5IDEgY2hpbGQuXG5mdW5jdGlvbiBqb2luSW5saW5lSW50byhwYXJlbnQsIHZpZXcsIG9wZW4pIHtcbiAgICBsZXQgbGFzdCwgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGlmIChvcGVuID4gMCAmJiB2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChsYXN0ID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgbGFzdC5tYXJrLmVxKHZpZXcubWFyaykpIHtcbiAgICAgICAgam9pbklubGluZUludG8obGFzdCwgdmlldy5jaGlsZHJlblswXSwgb3BlbiAtIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50Lmxlbmd0aCArPSB2aWV3Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvb3Jkc0luQ2hpbGRyZW4odmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZVBvcyA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyUG9zID0gLTE7XG4gICAgZnVuY3Rpb24gc2Nhbih2aWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCB2aWV3LmNoaWxkcmVuLmxlbmd0aCAmJiBvZmYgPD0gcG9zOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MgLSBvZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYWZ0ZXIgJiYgKGVuZCA+IHBvcyB8fCBvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmYgPCBwb3MgfHwgKG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbih2aWV3LCBwb3MpO1xuICAgIGxldCB0YXJnZXQgPSAoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyO1xuICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXQuY29vcmRzQXQoTWF0aC5tYXgoMCwgdGFyZ2V0ID09IGJlZm9yZSA/IGJlZm9yZVBvcyA6IGFmdGVyUG9zKSwgc2lkZSk7XG4gICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGZhbGxiYWNrUmVjdCh2aWV3KSB7XG4gICAgbGV0IGxhc3QgPSB2aWV3LmRvbS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsYXN0KVxuICAgICAgICByZXR1cm4gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XG4gICAgcmV0dXJuIHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBdHRycyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3MgKz0gXCIgXCIgKyBzb3VyY2UuY2xhc3M7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIHRhcmdldC5zdHlsZSlcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gYXR0cnNFcShhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhIHx8ICFiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGtleXNBID0gT2JqZWN0LmtleXMoYSksIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPSBrZXlzQi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRycyhkb20sIHByZXYsIGF0dHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBudWxsO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKGNoYW5nZWQgPSBuYW1lKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoY2hhbmdlZCA9IG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gISFjaGFuZ2VkO1xufVxuXG4vKipcbldpZGdldHMgYWRkZWQgdG8gdGhlIGNvbnRlbnQgYXJlIGRlc2NyaWJlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbmNsYXNzLiBVc2luZyBhIGRlc2NyaXB0aW9uIG9iamVjdCBsaWtlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG9cbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xubmVlZGVkLCBhbmQgdG8gYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgZXZlbiBpZiB0aGUgZGVjb3JhdGlvbnNcbnRoYXQgZGVmaW5lIHRoZW0gYXJlIHJlY3JlYXRlZC5cbiovXG5jbGFzcyBXaWRnZXRUeXBlIHtcbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgaW5zdGFuY2UgdG8gYW5vdGhlciBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgIChUeXBlU2NyaXB0IGNhbid0IGV4cHJlc3MgdGhpcywgYnV0IG9ubHkgaW5zdGFuY2VzIG9mIHRoZSBzYW1lXG4gICAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgICBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyB3aGVuIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgbmV3XG4gICAgZGVjb3JhdGlvbiBvZiB0aGUgc2FtZSB0eXBlLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0XG4gICAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICAgIGFsd2F5cyBiZSByZWRyYXduLlxuICAgICovXG4gICAgZXEod2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgYSB3aWRnZXQgb2YgdGhlIHNhbWUgdHlwZSAoYnV0XG4gICAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcbiAgICBjb3VsZG4ndCAoaW4gd2hpY2ggY2FzZSB0aGUgd2lkZ2V0IHdpbGwgYmUgcmVkcmF3bikuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgdXBkYXRlRE9NKGRvbSwgdmlldykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVzdGltYXRlZCBoZWlnaHQgdGhpcyB3aWRnZXQgd2lsbCBoYXZlLCB0byBiZSB1c2VkIHdoZW5cbiAgICBlc3RpbWF0aW5nIHRoZSBoZWlnaHQgb2YgY29udGVudCB0aGF0IGhhc24ndCBiZWVuIGRyYXduLiBNYXlcbiAgICByZXR1cm4gLTEgdG8gaW5kaWNhdGUgeW91IGRvbid0IGtub3cuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJucyAtMS5cbiAgICAqL1xuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiAtMTsgfVxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB3aGljaCBraW5kcyBvZiBldmVudHMgaW5zaWRlIHRoZSB3aWRnZXRcbiAgICBzaG91bGQgYmUgaWdub3JlZCBieSB0aGUgZWRpdG9yLiBUaGUgZGVmYXVsdCBpcyB0byBpZ25vcmUgYWxsXG4gICAgZXZlbnRzLlxuICAgICovXG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBjdXN0b21WaWV3KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGFuIGluc3RhbmNlIG9mIHRoZSB3aWRnZXQgaXMgcmVtb3ZlZFxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG52YXIgQmxvY2tUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2l0aFxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxuICAgIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgICBvZiBsb3dlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggZGlzcGxheXMgYSBET00gZWxlbWVudCBhdCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQoc3BlYykge1xuICAgICAgICBsZXQgc2lkZSA9IHNwZWMuc2lkZSB8fCAwLCBibG9jayA9ICEhc3BlYy5ibG9jaztcbiAgICAgICAgc2lkZSArPSBibG9jayA/IChzaWRlID4gMCA/IDMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIFNpZGUuQmxvY2tCZWZvcmUgKi8pIDogKHNpZGUgPiAwID8gMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQWZ0ZXIgKi8gOiAtMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XG4gICAgICAgIGlmIChzcGVjLmlzQmxvY2tHYXApIHtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IC01MDAwMDAwMDAgLyogU2lkZS5HYXBTdGFydCAqLztcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gKHN0YXJ0ID8gKGJsb2NrID8gLTMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovKSA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovKSAtIDE7XG4gICAgICAgICAgICBlbmRTaWRlID0gKGVuZCA/IChibG9jayA/IDIwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jRW5kICovIDogMSAvKiBTaWRlLklubGluZUluY0VuZCAqLykgOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSBSYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHNwZWMudGFnTmFtZSB8fCBcInNwYW5cIjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IHNwZWMuY2xhc3MgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuYXR0cmlidXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgb3RoZXIgaW5zdGFuY2VvZiBNYXJrRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9PSBvdGhlci50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzcyA9PSBvdGhlci5jbGFzcyAmJlxuICAgICAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5NYXJrRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcbmNsYXNzIExpbmVEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcigtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIG51bGwsIHNwZWMpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5zcGVjLmNsYXNzID09IG90aGVyLnNwZWMuY2xhc3MgJiZcbiAgICAgICAgICAgIGF0dHJzRXEodGhpcy5zcGVjLmF0dHJpYnV0ZXMsIG90aGVyLnNwZWMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZSBkZWNvcmF0aW9uIHJhbmdlcyBtdXN0IGJlIHplcm8tbGVuZ3RoXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkxpbmVEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5jbGFzcyBQb2ludERlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjLCBzdGFydFNpZGUsIGVuZFNpZGUsIGJsb2NrLCB3aWRnZXQsIGlzUmVwbGFjZSkge1xuICAgICAgICBzdXBlcihzdGFydFNpZGUsIGVuZFNpZGUsIHdpZGdldCwgc3BlYyk7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5pc1JlcGxhY2UgPSBpc1JlcGxhY2U7XG4gICAgICAgIHRoaXMubWFwTW9kZSA9ICFibG9jayA/IE1hcE1vZGUuVHJhY2tEZWwgOiBzdGFydFNpZGUgPD0gMCA/IE1hcE1vZGUuVHJhY2tCZWZvcmUgOiBNYXBNb2RlLlRyYWNrQWZ0ZXI7XG4gICAgfVxuICAgIC8vIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGlzLmJsb2NrID09IHRydWVcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTaWRlIDwgdGhpcy5lbmRTaWRlID8gQmxvY2tUeXBlLldpZGdldFJhbmdlXG4gICAgICAgICAgICA6IHRoaXMuc3RhcnRTaWRlIDw9IDAgPyBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlIDogQmxvY2tUeXBlLldpZGdldEFmdGVyO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDU7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5ibG9jayA9PSBvdGhlci5ibG9jayAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFNpZGUgPT0gb3RoZXIuc3RhcnRTaWRlICYmIHRoaXMuZW5kU2lkZSA9PSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChmcm9tID4gdG8gfHwgKGZyb20gPT0gdG8gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8PSAwKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgZm9yIHJlcGxhY2VtZW50IGRlY29yYXRpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1JlcGxhY2UgJiYgdG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2lkZ2V0IGRlY29yYXRpb25zIGNhbiBvbmx5IGhhdmUgemVyby1sZW5ndGggcmFuZ2VzXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cblBvaW50RGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrID0gZmFsc2UpIHtcbiAgICBsZXQgeyBpbmNsdXNpdmVTdGFydDogc3RhcnQsIGluY2x1c2l2ZUVuZDogZW5kIH0gPSBzcGVjO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICBzdGFydCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSB2b2lkIDAgPyBzdGFydCA6IGJsb2NrLCBlbmQ6IGVuZCAhPT0gbnVsbCAmJiBlbmQgIT09IHZvaWQgMCA/IGVuZCA6IGJsb2NrIH07XG59XG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgISEoYSAmJiBiICYmIGEuY29tcGFyZShiKSk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XG4gICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XSArIG1hcmdpbiA+PSBmcm9tKVxuICAgICAgICByYW5nZXNbbGFzdF0gPSBNYXRoLm1heChyYW5nZXNbbGFzdF0sIHRvKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbn1cblxuY2xhc3MgTGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgfVxuICAgIC8vIENvbnN1bWVzIHNvdXJjZVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgc291cmNlLnRyYW5zZmVyRE9NKHRoaXMpOyAvLyBSZXVzZSBzb3VyY2UuZG9tIHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3RhcnQpXG4gICAgICAgICAgICB0aGlzLnNldERlY28oc291cmNlID8gc291cmNlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4gOiBbXSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZFBvcyhhdCk7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltpXS5zcGxpdChvZmYpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ubWVyZ2Uob2ZmLCB0aGlzLmNoaWxkcmVuW2ldLmxlbmd0aCwgbnVsbCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltqXSwgMCk7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiB0aGlzLmNoaWxkcmVuW2kgLSAxXS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bLS1pXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgdHJhbnNmZXJET00ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgb3RoZXIuc2V0RE9NKHRoaXMuZG9tKTtcbiAgICAgICAgb3RoZXIucHJldkF0dHJzID0gdGhpcy5wcmV2QXR0cnMgPT09IHVuZGVmaW5lZCA/IHRoaXMuYXR0cnMgOiB0aGlzLnByZXZBdHRycztcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICB9XG4gICAgc2V0RGVjbyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzRXEodGhpcy5hdHRycywgYXR0cnMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQoY2hpbGQsIG9wZW5TdGFydCkge1xuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcbiAgICB9XG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBidWlsZGluZyBhIGxpbmUgdmlldyBpbiBDb250ZW50QnVpbGRlclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXMsIGNscyA9IGRlY28uc3BlYy5jbGFzcztcbiAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyhhdHRycywgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKHsgY2xhc3M6IGNscyB9LCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSB8PSA0IC8qIERpcnR5LkF0dHJzICovIHwgMiAvKiBEaXJ0eS5Ob2RlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcnR5ICYgNCAvKiBEaXJ0eS5BdHRycyAqLykge1xuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2QXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMucHJldkF0dHJzLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb20ubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobGFzdCAmJiBDb250ZW50Vmlldy5nZXQobGFzdCkgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICF0aGlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgbGFzdC5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgKChfYSA9IENvbnRlbnRWaWV3LmdldChsYXN0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpID09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKCFicm93c2VyLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVGV4dFZpZXcpKSkge1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICAgICAgICBoYWNrLmNtSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IC9bXiAtfl0vLnRlc3QoY2hpbGQudGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByZWN0c1swXS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRvdGFsV2lkdGggPyBudWxsIDoge1xuICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgICAgICAgY2hhcldpZHRoOiB0b3RhbFdpZHRoIC8gdGhpcy5sZW5ndGhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIGJlY29tZShfb3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBCbG9ja1R5cGUuVGV4dDsgfVxuICAgIHN0YXRpYyBmaW5kKGRvY1ZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IGRvY1ZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGRvY1ZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZCArIGJsb2NrLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmxlbmd0aCAtIGF0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICBsZXQgZW5kID0gbmV3IEJsb2NrV2lkZ2V0Vmlldyh0aGlzLndpZGdldCwgbGVuLCB0aGlzLnR5cGUpO1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbm9DaGlsZHJlbjsgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIG90aGVyLnR5cGUgPT0gdGhpcy50eXBlICYmXG4gICAgICAgICAgICBvdGhlci53aWRnZXQuY29uc3RydWN0b3IgPT0gdGhpcy53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmVxKHRoaXMud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbn1cblxuY2xhc3MgQ29udGVudEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgcG9zLCBlbmQsIGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IgPSBkaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBbXTtcbiAgICAgICAgLy8gU2V0IHRvIGZhbHNlIGRpcmVjdGx5IGFmdGVyIGEgd2lkZ2V0IHRoYXQgY292ZXJzIHRoZSBwb3NpdGlvbiBhZnRlciBpdFxuICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gLTE7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICAgICAgdGhpcy5za2lwID0gcG9zO1xuICAgIH1cbiAgICBwb3NDb3ZlcmVkKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmJyZWFrQXRTdGFydCAmJiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gIT0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuICFsYXN0LmJyZWFrQWZ0ZXIgJiYgIShsYXN0IGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGxhc3QudHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlKTtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKHRoaXMuY3VyTGluZSA9IG5ldyBMaW5lVmlldyk7XG4gICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJMaW5lO1xuICAgIH1cbiAgICBmbHVzaEJ1ZmZlcihhY3RpdmUgPSB0aGlzLmJ1ZmZlck1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZS5hcHBlbmQod3JhcE1hcmtzKG5ldyBXaWRnZXRCdWZmZXJWaWV3KC0xKSwgYWN0aXZlKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRCbG9ja1dpZGdldCh2aWV3KSB7XG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2godmlldyk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgJiYgb3BlbkVuZCA8PSB0aGlzLmJ1ZmZlck1hcmtzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICB9XG4gICAgYnVpbGRUZXh0KGxlbmd0aCwgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRPZmYgPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlLCBsaW5lQnJlYWssIGRvbmUgfSA9IHRoaXMuY3Vyc29yLm5leHQodGhpcy5za2lwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW4gb3V0IG9mIHRleHQgY29udGVudCB3aGVuIGRyYXdpbmcgaW5saW5lIHZpZXdzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0uYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRha2UgPSBNYXRoLm1pbih0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmLCBsZW5ndGgsIDUxMiAvKiBULkNodW5rICovKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlLnNsaWNlKGFjdGl2ZS5sZW5ndGggLSBvcGVuU3RhcnQpKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3cmFwTWFya3MobmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIHRoaXMudGV4dE9mZiArIHRha2UpKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IHRha2U7XG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Bhbihmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5idWlsZFRleHQodG8gLSBmcm9tLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0LCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcltpbmRleF0gJiYgZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgICAgIGlmICh0byA+IHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykudG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSB9ID0gZGVjbztcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiYgIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJsb2NrV2lkZ2V0KG5ldyBCbG9ja1dpZGdldFZpZXcoZGVjby53aWRnZXQgfHwgbmV3IE51bGxXaWRnZXQoXCJkaXZcIiksIGxlbiwgdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBXaWRnZXRWaWV3LmNyZWF0ZShkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcInNwYW5cIiksIGxlbiwgbGVuID8gMCA6IGRlY28uc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQmVmb3JlID0gdGhpcy5hdEN1cnNvclBvcyAmJiAhdmlldy5pc0VkaXRhYmxlICYmIG9wZW5TdGFydCA8PSBhY3RpdmUubGVuZ3RoICYmIChmcm9tIDwgdG8gfHwgZGVjby5zdGFydFNpZGUgPiAwKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQWZ0ZXIgPSAhdmlldy5pc0VkaXRhYmxlICYmIChmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCB8fCBkZWNvLnN0YXJ0U2lkZSA8PSAwKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgPT0gMiAvKiBCdWYuSWZDdXJzb3IgKi8gJiYgIWN1cnNvckJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3JCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKG5ldyBXaWRnZXRCdWZmZXJWaWV3KDEpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuU3RhcnQgPSBhY3RpdmUubGVuZ3RoICsgTWF0aC5tYXgoMCwgb3BlblN0YXJ0IC0gYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyh2aWV3LCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSBjdXJzb3JBZnRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAhY3Vyc29yQWZ0ZXIgPyAwIC8qIEJ1Zi5ObyAqLyA6IGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoID8gMSAvKiBCdWYuWWVzICovIDogMiAvKiBCdWYuSWZDdXJzb3IgKi87XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJNYXJrcyA9IGFjdGl2ZS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSA9PSB0aGlzLnBvcykgeyAvLyBMaW5lIGRlY29yYXRpb25cbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFkZExpbmVEZWNvKGRlY28pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGl0ZXJhdG9yIHBhc3QgdGhlIHJlcGxhY2VkIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRPZmYgKyBsZW4gPD0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAgKz0gbGVuIC0gKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQodGV4dCwgZnJvbSwgdG8sIGRlY29yYXRpb25zLCBkeW5hbWljRGVjb3JhdGlvbk1hcCkge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBDb250ZW50QnVpbGRlcih0ZXh0LCBmcm9tLCB0bywgZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICBidWlsZGVyLm9wZW5FbmQgPSBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIpO1xuICAgICAgICBpZiAoYnVpbGRlci5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgYnVpbGRlci5vcGVuU3RhcnQgPSBidWlsZGVyLm9wZW5FbmQ7XG4gICAgICAgIGJ1aWxkZXIuZmluaXNoKGJ1aWxkZXIub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyh2aWV3LCBhY3RpdmUpIHtcbiAgICBmb3IgKGxldCBtYXJrIG9mIGFjdGl2ZSlcbiAgICAgICAgdmlldyA9IG5ldyBNYXJrVmlldyhtYXJrLCBbdmlld10sIHZpZXcubGVuZ3RoKTtcbiAgICByZXR1cm4gdmlldztcbn1cbmNsYXNzIE51bGxXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci50YWcgPT0gdGhpcy50YWc7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWcpOyB9XG4gICAgdXBkYXRlRE9NKGVsdCkgeyByZXR1cm4gZWx0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gdGhpcy50YWc7IH1cbn1cblxuY29uc3QgY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkcmFnTW92ZXNTZWxlY3Rpb24kMSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IG1vdXNlU2VsZWN0aW9uU3R5bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBleGNlcHRpb25TaW5rID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdXBkYXRlTGlzdGVuZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBwZXJMaW5lVGV4dERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbmNvbnN0IG5hdGl2ZVNlbGVjdGlvbkhpZGRlbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbmNsYXNzIFNjcm9sbFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHkgPSBcIm5lYXJlc3RcIiwgeCA9IFwibmVhcmVzdFwiLCB5TWFyZ2luID0gNSwgeE1hcmdpbiA9IDUpIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnlNYXJnaW4gPSB5TWFyZ2luO1xuICAgICAgICB0aGlzLnhNYXJnaW4gPSB4TWFyZ2luO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5lbXB0eSA/IHRoaXMgOiBuZXcgU2Nyb2xsVGFyZ2V0KHRoaXMucmFuZ2UubWFwKGNoYW5nZXMpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4pO1xuICAgIH1cbn1cbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogKHQsIGNoKSA9PiB0Lm1hcChjaCkgfSk7XG4vKipcbkxvZyBvciByZXBvcnQgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiBpbiBjbGllbnQgY29kZS4gU2hvdWxkXG5wcm9iYWJseSBvbmx5IGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGNvZGUgdGhhdCBhbGxvd3MgY2xpZW50IGNvZGUgdG9cbnByb3ZpZGUgZnVuY3Rpb25zLCBhbmQgY2FsbHMgdGhvc2UgZnVuY3Rpb25zIGluIGEgY29udGV4dCB3aGVyZSBhblxuZXhjZXB0aW9uIGNhbid0IGJlIHByb3BhZ2F0ZWQgdG8gY2FsbGluZyBjb2RlIGluIGEgcmVhc29uYWJsZSB3YXlcbihmb3IgZXhhbXBsZSB3aGVuIGluIGFuIGV2ZW50IGhhbmRsZXIpLlxuXG5FaXRoZXIgY2FsbHMgYSBoYW5kbGVyIHJlZ2lzdGVyZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmtgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15leGNlcHRpb25TaW5rKSxcbmB3aW5kb3cub25lcnJvcmAsIGlmIGRlZmluZWQsIG9yIGBjb25zb2xlLmVycm9yYCAoaW4gd2hpY2ggY2FzZVxuaXQnbGwgcGFzcyBgY29udGV4dGAsIHdoZW4gZ2l2ZW4sIGFzIGZpcnN0IGFyZ3VtZW50KS5cbiovXG5mdW5jdGlvbiBsb2dFeGNlcHRpb24oc3RhdGUsIGV4Y2VwdGlvbiwgY29udGV4dCkge1xuICAgIGxldCBoYW5kbGVyID0gc3RhdGUuZmFjZXQoZXhjZXB0aW9uU2luayk7XG4gICAgaWYgKGhhbmRsZXIubGVuZ3RoKVxuICAgICAgICBoYW5kbGVyWzBdKGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAod2luZG93Lm9uZXJyb3IpXG4gICAgICAgIHdpbmRvdy5vbmVycm9yKFN0cmluZyhleGNlcHRpb24pLCBjb250ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmIChjb250ZXh0KVxuICAgICAgICBjb25zb2xlLmVycm9yKGNvbnRleHQgKyBcIjpcIiwgZXhjZXB0aW9uKTtcbiAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXhjZXB0aW9uKTtcbn1cbmNvbnN0IGVkaXRhYmxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdHJ1ZSB9KTtcbmxldCBuZXh0UGx1Z2luSUQgPSAwO1xuY29uc3Qgdmlld1BsdWdpbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuVmlldyBwbHVnaW5zIGFzc29jaWF0ZSBzdGF0ZWZ1bCB2YWx1ZXMgd2l0aCBhIHZpZXcuIFRoZXkgY2FuXG5pbmZsdWVuY2UgdGhlIHdheSB0aGUgY29udGVudCBpcyBkcmF3biwgYW5kIGFyZSBub3RpZmllZCBvZiB0aGluZ3NcbnRoYXQgaGFwcGVuIGluIHRoZSB2aWV3LlxuKi9cbmNsYXNzIFZpZXdQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbUV2ZW50SGFuZGxlcnMsIGJ1aWxkRXh0ZW5zaW9ucykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50SGFuZGxlcnMgPSBkb21FdmVudEhhbmRsZXJzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IGJ1aWxkRXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgcGx1Z2luIGZyb20gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlXG4gICAgcGx1Z2luJ3MgdmFsdWUsIGdpdmVuIGFuIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjcmVhdGUsIHNwZWMpIHtcbiAgICAgICAgY29uc3QgeyBldmVudEhhbmRsZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9uczogZGVjbyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UGx1Z2luKG5leHRQbHVnaW5JRCsrLCBjcmVhdGUsIGV2ZW50SGFuZGxlcnMsIHBsdWdpbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXh0ID0gW3ZpZXdQbHVnaW4ub2YocGx1Z2luKV07XG4gICAgICAgICAgICBpZiAoZGVjbylcbiAgICAgICAgICAgICAgICBleHQucHVzaChkZWNvcmF0aW9ucy5vZih2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbkluc3QgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luSW5zdCA/IGRlY28ocGx1Z2luSW5zdCkgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGUpXG4gICAgICAgICAgICAgICAgZXh0LnB1c2gocHJvdmlkZShwbHVnaW4pKTtcbiAgICAgICAgICAgIHJldHVybiBleHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4gZm9yIGEgY2xhc3Mgd2hvc2UgY29uc3RydWN0b3IgdGFrZXMgYSBzaW5nbGVcbiAgICBlZGl0b3IgdmlldyBhcyBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ2xhc3MoY2xzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBjbHModmlldyksIHNwZWMpO1xuICAgIH1cbn1cbmNsYXNzIFBsdWdpbkluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8vIFdoZW4gc3RhcnRpbmcgYW4gdXBkYXRlLCBhbGwgcGx1Z2lucyBoYXZlIHRoaXMgZmllbGQgc2V0IHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgb2JqZWN0LCBpbmRpY2F0aW5nIHRoZXkgbmVlZCB0byBiZSB1cGRhdGVkLiBXaGVuIGZpbmlzaGVkXG4gICAgICAgIC8vIHVwZGF0aW5nLCBpdCBpcyBzZXQgdG8gYGZhbHNlYC4gUmV0cmlldmluZyBhIHBsdWdpbiB0aGF0IG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIHVwZGF0ZWQgd2l0aCBgdmlldy5wbHVnaW5gIGZvcmNlcyBhbiBlYWdlciB1cGRhdGUuXG4gICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgaXMgbnVsbCB3aGVuIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIGJ1dFxuICAgICAgICAvLyBpbml0aWFsaXplZCBvbiB0aGUgZmlyc3QgdXBkYXRlLlxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVjKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3BlYy5jcmVhdGUodmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGUgPSB0aGlzLm11c3RVcGRhdGU7XG4gICAgICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHVwZGF0ZS5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KHZpZXcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxufVxuY29uc3QgZWRpdG9yQXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNvbnRlbnRBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLy8gUHJvdmlkZSBkZWNvcmF0aW9uc1xuY29uc3QgZGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhdG9taWNSYW5nZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBzY3JvbGxNYXJnaW5zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3Qgc3R5bGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBDaGFuZ2VkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpIHtcbiAgICAgICAgdGhpcy5mcm9tQSA9IGZyb21BO1xuICAgICAgICB0aGlzLnRvQSA9IHRvQTtcbiAgICAgICAgdGhpcy5mcm9tQiA9IGZyb21CO1xuICAgICAgICB0aGlzLnRvQiA9IHRvQjtcbiAgICB9XG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZWRSYW5nZShNYXRoLm1pbih0aGlzLmZyb21BLCBvdGhlci5mcm9tQSksIE1hdGgubWF4KHRoaXMudG9BLCBvdGhlci50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBvdGhlci5mcm9tQiksIE1hdGgubWF4KHRoaXMudG9CLCBvdGhlci50b0IpKTtcbiAgICB9XG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBpID0gc2V0Lmxlbmd0aCwgbWUgPSB0aGlzO1xuICAgICAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2V0W2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tQSA+IG1lLnRvQSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50b0EgPCBtZS5mcm9tQSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG1lID0gbWUuam9pbihyYW5nZSk7XG4gICAgICAgICAgICBzZXQuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuc3BsaWNlKGksIDAsIG1lKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgc3RhdGljIGV4dGVuZFdpdGhSYW5nZXMoZGlmZiwgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkSSA9IDAsIHJJID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOzsgZEkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBkSSA9PSBkaWZmLmxlbmd0aCA/IG51bGwgOiBkaWZmW2RJXSwgb2ZmID0gcG9zQSAtIHBvc0I7XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbUIgOiAxZTk7XG4gICAgICAgICAgICB3aGlsZSAockkgPCByYW5nZXMubGVuZ3RoICYmIHJhbmdlc1tySV0gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tySV0sIHRvID0gcmFuZ2VzW3JJICsgMV07XG4gICAgICAgICAgICAgICAgbGV0IGZyb21CID0gTWF0aC5tYXgocG9zQiwgZnJvbSksIHRvQiA9IE1hdGgubWluKGVuZCwgdG8pO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQiA8PSB0b0IpXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUIgKyBvZmYsIHRvQiArIG9mZiwgZnJvbUIsIHRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgckkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShuZXh0LmZyb21BLCBuZXh0LnRvQSwgbmV4dC5mcm9tQiwgbmV4dC50b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICBwb3NBID0gbmV4dC50b0E7XG4gICAgICAgICAgICBwb3NCID0gbmV4dC50b0I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblZpZXcgW3BsdWdpbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKSBhcmUgZ2l2ZW4gaW5zdGFuY2VzIG9mIHRoaXNcbmNsYXNzLCB3aGljaCBkZXNjcmliZSB3aGF0IGhhcHBlbmVkLCB3aGVuZXZlciB0aGUgdmlldyBpcyB1cGRhdGVkLlxuKi9cbmNsYXNzIFZpZXdVcGRhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IgdmlldyB0aGF0IHRoZSB1cGRhdGUgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICovXG4gICAgdmlldywgXG4gICAgLyoqXG4gICAgVGhlIG5ldyBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIHRyYW5zYWN0aW9ucyBpbnZvbHZlZCBpbiB0aGUgdXBkYXRlLiBNYXkgYmUgZW1wdHkuXG4gICAgKi9cbiAgICB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYWdzID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmNvbXBvc2UodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gY2hhbmdlZFJhbmdlcy5wdXNoKG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikpKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkUmFuZ2VzID0gY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHVwZGF0ZSBpbmRpY2F0ZXMgYSBmb2N1cyBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZm9jdXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mbGFncyA9PSAwICYmIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwOyB9XG59XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYiA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID09IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDogMSAvKiBULkwgKi87XG59XG5jb25zdCBCaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vO1xuLyoqXG5SZXByZXNlbnRzIGEgY29udGlndW91cyByYW5nZSBvZiB0ZXh0IHRoYXQgaGFzIGEgc2luZ2xlIGRpcmVjdGlvblxuKGFzIGluIGxlZnQtdG8tcmlnaHQgb3IgcmlnaHQtdG8tbGVmdCkuXG4qL1xuY2xhc3MgQmlkaVNwYW4ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBzcGFuIChyZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgW1wiYmlkaVxuICAgIGxldmVsXCJdKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvI0Jhc2ljX0Rpc3BsYXlfQWxnb3JpdGhtKVxuICAgIG9mIHRoZSBzcGFuIChpbiB0aGlzIGNvbnRleHQsIDAgbWVhbnNcbiAgICBsZWZ0LXRvLXJpZ2h0LCAxIG1lYW5zIHJpZ2h0LXRvLWxlZnQsIDIgbWVhbnMgbGVmdC10by1yaWdodFxuICAgIG51bWJlciBpbnNpZGUgcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiAgICAqL1xuICAgIGxldmVsKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGlyZWN0aW9uIG9mIHRoaXMgc3Bhbi5cbiAgICAqL1xuICAgIGdldCBkaXIoKSB7IHJldHVybiB0aGlzLmxldmVsICUgMiA/IFJUTCA6IExUUjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2lkZShlbmQsIGRpcikgeyByZXR1cm4gKHRoaXMuZGlyID09IGRpcikgPT0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmQob3JkZXIsIGluZGV4LCBsZXZlbCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IG1heWJlID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGluZGV4ICYmIHNwYW4udG8gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtdWx0aXBsZSBzcGFucyBtYXRjaCwgaWYgYXNzb2MgIT0gMCwgdGFrZSB0aGUgb25lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAvLyBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAobWF5YmUgPCAwIHx8IChhc3NvYyAhPSAwID8gKGFzc29jIDwgMCA/IHNwYW4uZnJvbSA8IGluZGV4IDogc3Bhbi50byA+IGluZGV4KSA6IG9yZGVyW21heWJlXS5sZXZlbCA+IHNwYW4ubGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gbWF5YmU7XG4gICAgfVxufVxuLy8gUmV1c2VkIGFycmF5IG9mIGNoYXJhY3RlciB0eXBlc1xuY29uc3QgdHlwZXMgPSBbXTtcbmZ1bmN0aW9uIGNvbXB1dGVPcmRlcihsaW5lLCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgbGVuID0gbGluZS5sZW5ndGgsIG91dGVyVHlwZSA9IGRpcmVjdGlvbiA9PSBMVFIgPyAxIC8qIFQuTCAqLyA6IDIgLyogVC5SICovLCBvcHBvc2l0ZVR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBpZiAoIWxpbmUgfHwgb3V0ZXJUeXBlID09IDEgLyogVC5MICovICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsZW4pO1xuICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xuICAgIC8vIG51bWJlci5cbiAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTiwgQU4sIEVULCBDUywgTkkpXG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSBvdXRlclR5cGUsIHByZXZTdHJvbmcgPSBvdXRlclR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIGlmICh0eXBlID09IDUxMiAvKiBULk5TTSAqLylcbiAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xuICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBULkFOICovO1xuICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgfVxuICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4gICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgIC8vIE5ldXRyYWwuXG4gICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSBvdXRlclR5cGUsIHByZXZTdHJvbmcgPSBvdXRlclR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xuICAgICAgICAgICAgaWYgKGkgPCBsZW4gLSAxICYmIHByZXYgPT0gdHlwZXNbaSArIDFdICYmIChwcmV2ICYgMjQgLyogVC5OdW0gKi8pKVxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDY0IC8qIFQuRVQgKi8pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSA2NCAvKiBULkVUICovKVxuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSAoaSAmJiBwcmV2ID09IDggLyogVC5FTiAqLykgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDggLyogVC5FTiAqLykgPyAocHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLyA/IDEgLyogVC5MICovIDogOCAvKiBULkVOICovKSA6IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IDEgLyogVC5MICovO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICB9XG4gICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgLy8gc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0IHBvc2l0aW9ucyBvZiB0aGVcbiAgICAvLyBvcGVuaW5nIHBhaXJlZCBicmFja2V0cyB1c2luZyB0aGUgbG9naWMgZ2l2ZW4gYmVsb3cuIFdpdGhpbiB0aGlzXG4gICAgLy8gc2NvcGUsIGJpZGlyZWN0aW9uYWwgdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgZm9yIChsZXQgaSA9IDAsIHNJID0gMCwgY29udGV4dCA9IDAsIGNoLCBiciwgdHlwZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cbiAgICAgICAgLy8gYnJhY2tldCBvbiBCcmFja2V0U3RhY2suXG4gICAgICAgIGlmIChiciA9IEJyYWNrZXRzW2NoID0gbGluZS5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQnJhY2tldFN0YWNrW3NKICsgMV0gPT0gLWJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gKGZsYWdzICYgMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi8pID8gb3V0ZXJUeXBlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZXNbQnJhY2tldFN0YWNrW3NKXV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQnJhY2tldFN0YWNrLmxlbmd0aCA9PSAxODkgLyogQnJhY2tldGVkLk1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNoO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XG4gICAgICAgICAgICBjb250ZXh0ID0gZW1iZWQgPyAwIDogMSAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVCZWZvcmUgKi87XG4gICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyICYgMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlc1tpXSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKVxuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgbGV0IGJlZm9yZUwgPSAoaSA/IHR5cGVzW2kgLSAxXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IGxlbiA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSBiZWZvcmVMID09IGFmdGVyTCA/IChiZWZvcmVMID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgIC8vIGJ1aWxkaW5nIHVwIGFuIGFjdHVhbCBsZXZlbHMgYXJyYXkuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlXG4gICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAvLyB0aGUgZmx5LCB3aXRob3V0IGZvbGxvd2luZyB0aGUgbGV2ZWwtYmFzZWQgYWxnb3JpdGhtLlxuICAgIGxldCBvcmRlciA9IFtdO1xuICAgIGlmIChvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBpLCBydGwgPSB0eXBlc1tpKytdICE9IDEgLyogVC5MICovO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgcnRsID09ICh0eXBlc1tpXSAhPSAxIC8qIFQuTCAqLykpXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gc3RhcnQ7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBqLCBsID0gdHlwZXNbLS1qXSAhPSAyIC8qIFQuUiAqLztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPiBzdGFydCAmJiBsID09ICh0eXBlc1tqIC0gMV0gIT0gMiAvKiBULlIgKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihqLCBlbmQsIGwgPyAyIDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKHN0YXJ0LCBpLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gaSwgcnRsID0gdHlwZXNbaSsrXSA9PSAyIC8qIFQuUiAqLztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuICYmIHJ0bCA9PSAodHlwZXNbaV0gPT0gMiAvKiBULlIgKi8pKVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKHN0YXJ0LCBpLCBydGwgPyAxIDogMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmRlcjtcbn1cbmZ1bmN0aW9uIHRyaXZpYWxPcmRlcihsZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcbn1cbmxldCBtb3ZlZE92ZXIgPSBcIlwiO1xuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaGVhZCAtIGxpbmUuZnJvbSwgc3BhbkkgPSAtMTtcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgIGlmICghZm9yd2FyZCB8fCAhbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG9yZGVyWzBdLmxldmVsICE9IGRpcikge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IG9yZGVyWzBdLnNpZGUoZmFsc2UsIGRpcik7XG4gICAgICAgICAgICBzcGFuSSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRJbmRleCA9PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGFzdCA9IG9yZGVyW29yZGVyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdC5sZXZlbCAhPSBkaXIpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBsYXN0LnNpZGUodHJ1ZSwgZGlyKTtcbiAgICAgICAgICAgIHNwYW5JID0gb3JkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3BhbkkgPCAwKVxuICAgICAgICBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgc3BhbiA9IG9yZGVyW3NwYW5JXTtcbiAgICAvLyBFbmQgb2Ygc3Bhbi4gKEJ1dCBub3QgZW5kIG9mIGxpbmUtLXRoYXQgd2FzIGNoZWNrZWQgZm9yIGFib3ZlLilcbiAgICBpZiAoc3RhcnRJbmRleCA9PSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSkge1xuICAgICAgICBzcGFuID0gb3JkZXJbc3BhbkkgKz0gZm9yd2FyZCA/IDEgOiAtMV07XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzcGFuLnNpZGUoIWZvcndhcmQsIGRpcik7XG4gICAgfVxuICAgIGxldCBpbmRleEZvcndhcmQgPSBmb3J3YXJkID09IChzcGFuLmRpciA9PSBkaXIpO1xuICAgIGxldCBuZXh0SW5kZXggPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgaW5kZXhGb3J3YXJkKTtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgaWYgKG5leHRJbmRleCAhPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBpbmRleEZvcndhcmQgPyAtMSA6IDEsIHNwYW4ubGV2ZWwpO1xuICAgIGxldCBuZXh0U3BhbiA9IHNwYW5JID09IChmb3J3YXJkID8gb3JkZXIubGVuZ3RoIC0gMSA6IDApID8gbnVsbCA6IG9yZGVyW3NwYW5JICsgKGZvcndhcmQgPyAxIDogLTEpXTtcbiAgICBpZiAoIW5leHRTcGFuICYmIHNwYW4ubGV2ZWwgIT0gZGlyKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgZGlyKTtcbiAgICBpZiAobmV4dFNwYW4gJiYgbmV4dFNwYW4ubGV2ZWwgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBmb3J3YXJkID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBmb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5saW5lU2VwYXJhdG9yID0gc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGFwcGVuZCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIH1cbiAgICBsaW5lQnJlYWsoKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBMaW5lQnJlYWtQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBjdXIpO1xuICAgICAgICAgICAgdGhpcy5yZWFkTm9kZShjdXIpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpLCBuZXh0VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmIG5leHRWaWV3ID8gdmlldy5icmVha0FmdGVyIDpcbiAgICAgICAgICAgICAgICAodmlldyA/IHZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KGN1cikpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0Jsb2NrRWxlbWVudChuZXh0KSAmJiAoY3VyLm5vZGVOYW1lICE9IFwiQlJcIiB8fCBjdXIuY21JZ25vcmUpKSlcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFkVGV4dE5vZGUobm9kZSkge1xuICAgICAgICBsZXQgdGV4dCA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHBvaW50Lm9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSAwLCByZSA9IHRoaXMubGluZVNlcGFyYXRvciA/IG51bGwgOiAvXFxyXFxuP3xcXG4vZzs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gLTEsIGJyZWFrU2l6ZSA9IDEsIG07XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKHRoaXMubGluZVNlcGFyYXRvciwgb2ZmKTtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobSA9IHJlLmV4ZWModGV4dCkpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmQodGV4dC5zbGljZShvZmYsIG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaykpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgaWYgKGJyZWFrU2l6ZSA+IDEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgcG9pbnQucG9zID4gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnBvcyAtPSBicmVha1NpemUgLSAxO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEJyZWFrICsgYnJlYWtTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY21JZ25vcmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpO1xuICAgICAgICBsZXQgZnJvbVZpZXcgPSB2aWV3ICYmIHZpZXcub3ZlcnJpZGVET01UZXh0O1xuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRJbnNpZGUobm9kZSwgZnJvbVZpZXcubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tVmlldy5pdGVyKCk7ICFpLm5leHQoKS5kb25lOykge1xuICAgICAgICAgICAgICAgIGlmIChpLmxpbmVCcmVhaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGkudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgdGhpcy5yZWFkVGV4dE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkJSXCIpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRQb2ludEJlZm9yZShub2RlLCBuZXh0KSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBub2RlLmNoaWxkTm9kZXNbcG9pbnQub2Zmc2V0XSA9PSBuZXh0KVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGZpbmRQb2ludEluc2lkZShub2RlLCBtYXhMZW4pIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzID8gcG9pbnQubm9kZSA9PSBub2RlIDogbm9kZS5jb250YWlucyhwb2ludC5ub2RlKSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4obWF4TGVuLCBwb2ludC5vZmZzZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwID0gW107XG4gICAgICAgIC8vIFRyYWNrIGEgbWluaW11bSB3aWR0aCBmb3IgdGhlIGVkaXRvci4gV2hlbiBtZWFzdXJpbmcgc2l6ZXMgaW5cbiAgICAgICAgLy8gbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cywgdGhpcyBpcyB1cGRhdGVkIHRvIHBvaW50IGF0IHRoZSB3aWR0aFxuICAgICAgICAvLyBvZiBhIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBleHRlbnQgaW4gdGhlIGRvY3VtZW50LiBXaGVuIGEgY2hhbmdlXG4gICAgICAgIC8vIGhhcHBlbnMgaW4gdGhhdCByYW5nZSwgdGhlc2UgYXJlIHJlc2V0LiBUaGF0IHdheSwgb25jZSB3ZSd2ZSBzZWVuXG4gICAgICAgIC8vIGEgbGluZS9lbGVtZW50IG9mIGEgZ2l2ZW4gbGVuZ3RoLCB3ZSBrZWVwIHRoZSBlZGl0b3Igd2lkZSBlbm91Z2hcbiAgICAgICAgLy8gdG8gZml0IGF0IGxlYXN0IHRoYXQgZWxlbWVudCwgdW50aWwgaXQgaXMgY2hhbmdlZCwgYXQgd2hpY2ggcG9pbnRcbiAgICAgICAgLy8gd2UgZm9yZ2V0IGl0IGFnYWluLlxuICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBET00gc2VsZWN0aW9uIHdhcyBzZXQgaW4gYSBsb3NzeSB3YXksIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgbWVzcyBpdCB1cCB3aGVuIHJlYWRpbmcgaXQgYmFjayBpdFxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgcmVzaXplIG9ic2VydmVyIHRvIGlnbm9yZSByZXNpemVzIHRoYXQgd2UgY2F1c2VkXG4gICAgICAgIC8vIG91cnNlbHZlc1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnNldERPTSh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMaW5lVmlld107XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSwgMCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDsgfVxuICAgIC8vIFVwZGF0ZSB0aGUgZG9jdW1lbnQgdmlldyB0byBhIGdpdmVuIHN0YXRlLiBzY3JvbGxJbnRvVmlldyBjYW4gYmVcbiAgICAvLyB1c2VkIGFzIGEgaGludCB0byBjb21wdXRlIGEgbmV3IHZpZXdwb3J0IHRoYXQgaW5jbHVkZXMgdGhhdFxuICAgIC8vIHBvc2l0aW9uLCBpZiB3ZSBrbm93IHRoZSBlZGl0b3IgaXMgZ29pbmcgdG8gc2Nyb2xsIHRoYXQgcG9zaXRpb25cbiAgICAvLyBpbnRvIHZpZXcuXG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDAgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFJhbmdlcy5ldmVyeSgoeyBmcm9tQSwgdG9BIH0pID0+IHRvQSA8IHRoaXMubWluV2lkdGhGcm9tIHx8IGZyb21BID4gdGhpcy5taW5XaWR0aFRvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgZWxzZSBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggfHwgdGhpcy5kaXJ0eSlcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvID0gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgRE9NIG5vZGVzIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGFyZSBtb3ZlZCB0byBhbm90aGVyXG4gICAgICAgIC8vIHBhcmVudCwgQ2hyb21lIHNvbWV0aW1lcyByZXBvcnRzIGEgZGlmZmVyZW50IHNlbGVjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGdldFNlbGVjdGlvbiB0aGFuIHRoZSBvbmUgdGhhdCBpdCBhY3R1YWxseSBzaG93cyB0byB0aGUgdXNlci5cbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgYSBzZWxlY3Rpb24gdXBkYXRlIHdoZW4gbGluZXMgYXJlIGpvaW5lZCB0byB3b3JrXG4gICAgICAgIC8vIGFyb3VuZCB0aGF0LiBJc3N1ZSAjNTRcbiAgICAgICAgaWYgKChicm93c2VyLmllIHx8IGJyb3dzZXIuY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpdGlvbkRlY28uc2l6ZSAmJiB1cGRhdGUgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5kb2MubGluZXMgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzKVxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IDAgLyogRGlydHkuTm90ICovICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIoY2hhbmdlZFJhbmdlcywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgYnkgdXBkYXRlIGFuZCB0aGUgY29uc3RydWN0b3IgZG8gcGVyZm9ybSB0aGUgYWN0dWFsIERPTVxuICAgIC8vIHVwZGF0ZVxuICAgIHVwZGF0ZUlubmVyKGNoYW5nZXMsIG9sZExlbmd0aCkge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoKTtcbiAgICAgICAgbGV0IHsgb2JzZXJ2ZXIgfSA9IHRoaXMudmlldztcbiAgICAgICAgb2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBtZXNzZXMgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBET00gbXV0YXRpb24gKHRob3VnaFxuICAgICAgICAgICAgLy8gbm8gcmVsYXlvdXQgaXMgdHJpZ2dlcmVkIGFuZCBJIGNhbm5vdCBpbWFnaW5lIGhvdyBpdCBjYW5cbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXcudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5mbGV4QmFzaXMgPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYXJvdW5kIHRoZSBzZWxlY3Rpb24sIGdldCBjb25mdXNlZCBhbmQgcmVwb3J0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gZnJvbSB0aGUgb25lIGl0IGRpc3BsYXlzIChpc3N1ZSAjMjE4KS4gVGhpcyB0cmllc1xuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5pb3MgPyB7IG5vZGU6IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSwgd3JpdHRlbjogZmFsc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3luYyh0aGlzLnZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSAwIC8qIERpcnR5Lk5vdCAqLztcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiAodHJhY2sud3JpdHRlbiB8fCBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUgIT0gdHJhY2subm9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgY2hpbGQud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIGdhcHMucHVzaChjaGlsZC5kb20pO1xuICAgICAgICBvYnNlcnZlci51cGRhdGVHYXBzKGdhcHMpO1xuICAgIH1cbiAgICB1cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMuY2hpbGRDdXJzb3Iob2xkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID49IDAgPyBjaGFuZ2VzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IG5leHQ7XG4gICAgICAgICAgICBsZXQgeyBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1cnNvci5maW5kUG9zKHRvQSwgMSk7XG4gICAgICAgICAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyhmcm9tQSwgLTEpO1xuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihtdXN0UmVhZCA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtdXN0UmVhZCB8fCAhdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKCEoZnJvbVBvaW50ZXIgfHwgdGhpcy5tYXlDb250cm9sU2VsZWN0aW9uKCkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAvLyBGSVhNRSBuZWVkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgc2VsZWN0aW9uIGZhbGxzIGluc2lkZSBhIGJsb2NrIHJhbmdlXG4gICAgICAgIGxldCBhbmNob3IgPSB0aGlzLmRvbUF0UG9zKG1haW4uYW5jaG9yKTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYWluLmVtcHR5ID8gYW5jaG9yIDogdGhpcy5kb21BdFBvcyhtYWluLmhlYWQpO1xuICAgICAgICAvLyBBbHdheXMgcmVzZXQgb24gRmlyZWZveCB3aGVuIG5leHQgdG8gYW4gdW5lZGl0YWJsZSBub2RlIHRvXG4gICAgICAgIC8vIGF2b2lkIGludmlzaWJsZSBjdXJzb3IgYnVncyAoIzExMSlcbiAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28gJiYgbWFpbi5lbXB0eSAmJiBiZXR3ZWVuVW5lZGl0YWJsZShhbmNob3IpKSB7XG4gICAgICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gYW5jaG9yLm5vZGUuaW5zZXJ0QmVmb3JlKGR1bW15LCBhbmNob3Iubm9kZS5jaGlsZE5vZGVzW2FuY2hvci5vZmZzZXRdIHx8IG51bGwpKTtcbiAgICAgICAgICAgIGFuY2hvciA9IGhlYWQgPSBuZXcgRE9NUG9zKGR1bW15LCAwKTtcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9tU2VsID0gdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGFscmVhZHkgaGVyZSwgb3IgaW4gYW4gZXF1aXZhbGVudCBwb3NpdGlvbiwgZG9uJ3QgdG91Y2ggaXRcbiAgICAgICAgaWYgKGZvcmNlIHx8ICFkb21TZWwuZm9jdXNOb2RlIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KSB8fFxuICAgICAgICAgICAgIWlzRXF1aXZhbGVudFBvc2l0aW9uKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQsIGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBBbmRyb2lkIHdpbGwgaGlkZSB0aGUgdmlydHVhbCBrZXlib2FyZCB3aGVuIHRhcHBpbmdcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gdW5lZGl0YWJsZSBub2RlLCBhbmQgbm90IGJyaW5nIGl0IGJhY2sgd2hlbiB3ZVxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGN1cnNvciB0byBpdHMgcHJvcGVyIHBvc2l0aW9uLiBUaGlzIHRyaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUga2V5Ym9hcmQgYnkgY3ljbGluZyBmb2N1cy5cbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lICYmIHRoaXMuZG9tLmNvbnRhaW5zKGRvbVNlbC5mb2N1c05vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgIGluVW5lZGl0YWJsZShkb21TZWwuZm9jdXNOb2RlLCB0aGlzLmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYXdTZWwgPSBnZXRTZWxlY3Rpb24odGhpcy52aWV3LnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmICghcmF3U2VsKSA7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjEyMDc2XG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFRvID0gbmV4dFRvVW5lZGl0YWJsZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFRvICYmIG5leHRUbyAhPSAoMSAvKiBOZXh0VG8uQmVmb3JlICovIHwgMiAvKiBOZXh0VG8uQWZ0ZXIgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBuZWFyYnlUZXh0Tm9kZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgbmV4dFRvID09IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5ldyBET01Qb3ModGV4dCwgbmV4dFRvID09IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA/IDAgOiB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmJpZGlMZXZlbCAhPSBudWxsICYmIGRvbVNlbC5jdXJzb3JCaWRpTGV2ZWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbVNlbC5jdXJzb3JCaWRpTGV2ZWwgPSBtYWluLmJpZGlMZXZlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmF3U2VsLmV4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3Rpb24uZXh0ZW5kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiAnaW52ZXJ0ZWQnIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAob25lIHdoZXJlIHRoZSBmb2N1cyBpcyBiZWZvcmUgdGhlIGFuY2hvciksIGJ1dCBub3QgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHN1cHBvcnQgaXQgeWV0LlxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGNhbGwgYWJvdmUgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGRlbiwgYW5kIHRoZW4gcmFpc2UgYW4gZXJyb3Igb24gdGhlIGNhbGwgdG8gZXh0ZW5kXG4gICAgICAgICAgICAgICAgICAgIC8vICgjOTQwKS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5leHRlbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIChJRSkgd2F5XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmFuY2hvciA+IG1haW4uaGVhZClcbiAgICAgICAgICAgICAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gW2hlYWQsIGFuY2hvcl07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IGFuY2hvci5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBoZWFkLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICBlbmZvcmNlQ3Vyc29yQXNzb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2l0aW9uRGVjby5zaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBjdXJzb3IgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICAgIC8vIFRoaXMgY2FuIGdvIHdyb25nIGluIGNvcm5lciBjYXNlcyBsaWtlIHNpbmdsZS1jaGFyYWN0ZXIgbGluZXMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGFuZCByZXNldCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIHZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBuZXdSYW5nZSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShuZXdSYW5nZS5hbmNob3JOb2RlLCBuZXdSYW5nZS5hbmNob3JPZmZzZXQpICE9IGN1cnNvci5mcm9tKVxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgfVxuICAgIG1heUNvbnRyb2xTZWxlY3Rpb24oKSB7XG4gICAgICAgIGxldCBhY3RpdmUgPSB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gYWN0aXZlID09IHRoaXMuZG9tIHx8XG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSkgJiYgIShhY3RpdmUgJiYgdGhpcy5kb20uY29udGFpbnMoYWN0aXZlKSk7XG4gICAgfVxuICAgIG5lYXJlc3QoZG9tKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOykge1xuICAgICAgICAgICAgbGV0IGRvbVZpZXcgPSBDb250ZW50Vmlldy5nZXQoY3VyKTtcbiAgICAgICAgICAgIGlmIChkb21WaWV3ICYmIGRvbVZpZXcucm9vdFZpZXcgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tVmlldztcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgdmlldyA9IHRoaXMubmVhcmVzdChub2RlKTtcbiAgICAgICAgaWYgKCF2aWV3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gZmluZCBwb3NpdGlvbiBmb3IgYSBET00gcG9zaXRpb24gb3V0c2lkZSBvZiB0aGUgZG9jdW1lbnRcIik7XG4gICAgICAgIHJldHVybiB2aWV3LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgdmlldy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIC0xKTtcbiAgICAgICAgZm9yICg7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZiA8IGNoaWxkLmxlbmd0aCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21BdFBvcyhvZmYpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5sZW5ndGgsIGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN0YXJ0ID0gb2ZmIC0gY2hpbGQuYnJlYWtBZnRlciAtIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBzdGFydCB8fFxuICAgICAgICAgICAgICAgIChwb3MgPT0gc3RhcnQgJiYgY2hpbGQudHlwZSAhPSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlICYmIGNoaWxkLnR5cGUgIT0gQmxvY2tUeXBlLldpZGdldEFmdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICghaSB8fCBzaWRlID09IDIgfHwgdGhpcy5jaGlsZHJlbltpIC0gMV0uYnJlYWtBZnRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuY2hpbGRyZW5baSAtIDFdLnR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSAmJiBzaWRlID4gLTIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmNvb3Jkc0F0KHBvcyAtIHN0YXJ0LCBzaWRlKTtcbiAgICAgICAgICAgIG9mZiA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModmlld3BvcnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCB7IGZyb20sIHRvIH0gPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMudmlldy5jb250ZW50RE9NLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgaXNXaWRlciA9IGNvbnRlbnRXaWR0aCA+IE1hdGgubWF4KHRoaXMudmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgsIHRoaXMubWluV2lkdGgpICsgMTtcbiAgICAgICAgbGV0IHdpZGVzdCA9IC0xLCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBsYXN0ID8gY2xpZW50UmVjdHNGb3IobGFzdCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGx0ciA/IHJlY3QucmlnaHQgLSBjaGlsZFJlY3QubGVmdCA6IGNoaWxkUmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCB7IGkgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy5jaGlsZHJlbltpXS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZSA9IGNoaWxkLm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcbiAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbGluZUhlaWdodCwgY2hhcldpZHRoO1xuICAgICAgICBkdW1teS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUud2lkdGggPSBcIjk5OTk5cHhcIjtcbiAgICAgICAgZHVtbXkudGV4dENvbnRlbnQgPSBcImFiYyBkZWYgZ2hpIGprbCBtbm8gcHFyIHN0dVwiO1xuICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGR1bW15KTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gY2xpZW50UmVjdHNGb3IoZHVtbXkuZmlyc3RDaGlsZClbMF07XG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gZHVtbXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgY2hhcldpZHRoID0gcmVjdCA/IHJlY3Qud2lkdGggLyAyNyA6IDc7XG4gICAgICAgICAgICBkdW1teS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCB9O1xuICAgIH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gc3RhcnQgb2YgbGFzdCBlbGVtZW50IHdoZW4gcG9zc2libGUsIHNvIHRoYXRcbiAgICAgICAgLy8gYENoaWxkQ3Vyc29yLmZpbmRQb3NgIGRvZXNuJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhlIGVkZ2UgY2FzZVxuICAgICAgICAvLyBvZiBiZWluZyBhZnRlciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICBsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHBvcyAtPSB0aGlzLmNoaWxkcmVuWy0taV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgaSk7XG4gICAgfVxuICAgIGNvbXB1dGVCbG9ja0dhcERlY28oKSB7XG4gICAgICAgIGxldCBkZWNvID0gW10sIHZzID0gdGhpcy52aWV3LnZpZXdTdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSB2cy52aWV3cG9ydHMubGVuZ3RoID8gbnVsbCA6IHZzLnZpZXdwb3J0c1tpXTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSB2cy5saW5lQmxvY2tBdChlbmQpLmJvdHRvbSAtIHZzLmxpbmVCbG9ja0F0KHBvcykudG9wO1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBCbG9ja0dhcFdpZGdldChoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Jsb2NrR2FwOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKHBvcywgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxuICAgIHVwZGF0ZURlY28oKSB7XG4gICAgICAgIGxldCBhbGxEZWNvID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBhbGxEZWNvLmxlbmd0aDsgaSA8IGFsbERlY28ubGVuZ3RoICsgMzsgaSsrKVxuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyxcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJsb2NrR2FwRGVjbygpLFxuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lR2FwRGVjb1xuICAgICAgICBdO1xuICAgIH1cbiAgICBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHRhcmdldDtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmhlYWQsIHJhbmdlLmVtcHR5ID8gcmFuZ2UuYXNzb2MgOiByYW5nZS5oZWFkID4gcmFuZ2UuYW5jaG9yID8gLTEgOiAxKSwgb3RoZXI7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiAob3RoZXIgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmFuY2hvciwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IC0xIDogMSkpKVxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgocmVjdC5yaWdodCwgb3RoZXIucmlnaHQpLCBib3R0b206IE1hdGgubWF4KHJlY3QuYm90dG9tLCBvdGhlci5ib3R0b20pIH07XG4gICAgICAgIGxldCBtTGVmdCA9IDAsIG1SaWdodCA9IDAsIG1Ub3AgPSAwLCBtQm90dG9tID0gMDtcbiAgICAgICAgZm9yIChsZXQgbWFyZ2lucyBvZiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykubWFwKGYgPT4gZih0aGlzLnZpZXcpKSlcbiAgICAgICAgICAgIGlmIChtYXJnaW5zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSBtYXJnaW5zO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1MZWZ0ID0gTWF0aC5tYXgobUxlZnQsIGxlZnQpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtUmlnaHQgPSBNYXRoLm1heChtUmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAodG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1Ub3AgPSBNYXRoLm1heChtVG9wLCB0b3ApO1xuICAgICAgICAgICAgICAgIGlmIChib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbUJvdHRvbSA9IE1hdGgubWF4KG1Cb3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gbUxlZnQsIHRvcDogcmVjdC50b3AgLSBtVG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtUmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtQm90dG9tXG4gICAgICAgIH07XG4gICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLnZpZXcuc2Nyb2xsRE9NLCB0YXJnZXRSZWN0LCByYW5nZS5oZWFkIDwgcmFuZ2UuYW5jaG9yID8gLTEgOiAxLCB0YXJnZXQueCwgdGFyZ2V0LnksIHRhcmdldC54TWFyZ2luLCB0YXJnZXQueU1hcmdpbiwgdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUik7XG4gICAgfVxufVxuZnVuY3Rpb24gYmV0d2VlblVuZWRpdGFibGUocG9zKSB7XG4gICAgcmV0dXJuIHBvcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgcG9zLm5vZGUuZmlyc3RDaGlsZCAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IHBvcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG59XG5jbGFzcyBCbG9ja0dhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTShlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuaGVpZ2h0ID09IHRoaXMuaGVpZ2h0OyB9XG4gICAgdXBkYXRlRE9NKGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2l0aW9uU3Vycm91bmRpbmdOb2RlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBsZXQgdGV4dE5vZGUgPSBzZWwuZm9jdXNOb2RlICYmIG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgMCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNWaWV3ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QodGV4dE5vZGUpO1xuICAgIGlmICghY1ZpZXcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChjVmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgIGxldCB0b3BOb2RlID0gdGV4dE5vZGU7XG4gICAgICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gY1ZpZXcuZG9tKVxuICAgICAgICAgICAgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgbGV0IHByZXYgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgd2hpbGUgKHByZXYgJiYgIUNvbnRlbnRWaWV3LmdldChwcmV2KSlcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgbGV0IHBvcyA9IHByZXYgPyBDb250ZW50Vmlldy5nZXQocHJldikucG9zQXRFbmQgOiBjVmlldy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MsIG5vZGU6IHRvcE5vZGUsIHRleHQ6IHRleHROb2RlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJlbnQgfSA9IGNWaWV3O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjVmlldyA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbSA9IGNWaWV3LnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgY1ZpZXcubGVuZ3RoLCBub2RlOiBjVmlldy5kb20sIHRleHQ6IHRleHROb2RlIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh2aWV3LCBjaGFuZ2VzKSB7XG4gICAgbGV0IHN1cnJvdW5kaW5nID0gY29tcG9zaXRpb25TdXJyb3VuZGluZ05vZGUodmlldyk7XG4gICAgaWYgKCFzdXJyb3VuZGluZylcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICBsZXQgeyBmcm9tLCB0bywgbm9kZSwgdGV4dDogdGV4dE5vZGUgfSA9IHN1cnJvdW5kaW5nO1xuICAgIGxldCBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoZnJvbSwgMSksIG5ld1RvID0gTWF0aC5tYXgobmV3RnJvbSwgY2hhbmdlcy5tYXBQb3ModG8sIC0xKSk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHRleHQgPSBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZSA6XG4gICAgICAgIG5ldyBET01SZWFkZXIoW10sIHN0YXRlKS5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKS50ZXh0O1xuICAgIGlmIChuZXdUbyAtIG5ld0Zyb20gPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5ld0Zyb20sIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIG5ld0Zyb20gKyB0ZXh0Lmxlbmd0aCksIExpbmVCcmVha1BsYWNlaG9sZGVyKSA9PSB0ZXh0KVxuICAgICAgICAgICAgbmV3VG8gPSBuZXdGcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmRvYy5zbGljZVN0cmluZyhNYXRoLm1heCgwLCBuZXdUbyAtIHRleHQubGVuZ3RoKSwgbmV3VG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSA9PSB0ZXh0KVxuICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlLmRvYy5zbGljZVN0cmluZyhuZXdGcm9tLCBuZXdUbywgTGluZUJyZWFrUGxhY2Vob2xkZXIpICE9IHRleHQpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9XG4gICAgbGV0IHRvcFZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XG4gICAgaWYgKHRvcFZpZXcgaW5zdGFuY2VvZiBDb21wb3NpdGlvblZpZXcpXG4gICAgICAgIHRvcFZpZXcgPSB0b3BWaWV3LndpZGdldC50b3BWaWV3O1xuICAgIGVsc2UgaWYgKHRvcFZpZXcpXG4gICAgICAgIHRvcFZpZXcucGFyZW50ID0gbnVsbDtcbiAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgQ29tcG9zaXRpb25XaWRnZXQobm9kZSwgdGV4dE5vZGUsIHRvcFZpZXcpLCBpbmNsdXNpdmU6IHRydWUgfSlcbiAgICAgICAgLnJhbmdlKG5ld0Zyb20sIG5ld1RvKSk7XG59XG5jbGFzcyBDb21wb3NpdGlvbldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgdGV4dCwgdG9wVmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50b3BWaWV3ID0gdG9wVmlldztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMudG9wID09IG90aGVyLnRvcCAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gdGhpcy50b3A7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGN1c3RvbVZpZXcoKSB7IHJldHVybiBDb21wb3NpdGlvblZpZXc7IH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKG5vZGUsIG9mZnNldCwgc2lkZSkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDAgJiYgc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFRvVW5lZGl0YWJsZShub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA6IDApIHxcbiAgICAgICAgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDIgLyogTmV4dFRvLkFmdGVyICovIDogMCk7XG59XG5jbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZShmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxufVxuZnVuY3Rpb24gZmluZENoYW5nZWREZWNvKGEsIGIsIGRpZmYpIHtcbiAgICBsZXQgY29tcCA9IG5ldyBEZWNvcmF0aW9uQ29tcGFyYXRvciQxO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGluVW5lZGl0YWJsZShub2RlLCBpbnNpZGUpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXIgJiYgY3VyICE9IGluc2lkZTsgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEgJiYgY3VyLmNvbnRlbnRFZGl0YWJsZSA9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXQoc3RhdGUsIHBvcywgYmlhcyA9IDEpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBsaW5lUG9zID0gcG9zIC0gbGluZS5mcm9tO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIGlmIChsaW5lUG9zID09IDApXG4gICAgICAgIGJpYXMgPSAxO1xuICAgIGVsc2UgaWYgKGxpbmVQb3MgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIGJpYXMgPSAtMTtcbiAgICBsZXQgZnJvbSA9IGxpbmVQb3MsIHRvID0gbGluZVBvcztcbiAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgIGZyb20gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcywgZmFsc2UpO1xuICAgIGVsc2VcbiAgICAgICAgdG8gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHByZXYsIGZyb20pKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZnJvbSA9IHByZXY7XG4gICAgfVxuICAgIHdoaWxlICh0byA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRvKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHRvLCBuZXh0KSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHRvID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tICsgbGluZS5mcm9tLCB0byArIGxpbmUuZnJvbSk7XG59XG4vLyBTZWFyY2ggdGhlIERPTSBmb3IgdGhlIHtub2RlLCBvZmZzZXR9IHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuXG4vLyBjb29yZGluYXRlcy4gVmVyeSBpbmVmZmljaWVudCBhbmQgY3J1ZGUsIGJ1dCBjYW4gdXN1YWxseSBiZSBhdm9pZGVkXG4vLyBieSBjYWxsaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBpbnN0ZWFkLlxuZnVuY3Rpb24gZ2V0ZHgoeCwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LmxlZnQgPiB4ID8gcmVjdC5sZWZ0IC0geCA6IE1hdGgubWF4KDAsIHggLSByZWN0LnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIGdldGR5KHksIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogTWF0aC5tYXgoMCwgeSAtIHJlY3QuYm90dG9tKTtcbn1cbmZ1bmN0aW9uIHlPdmVybGFwKGEsIGIpIHtcbiAgICByZXR1cm4gYS50b3AgPCBiLmJvdHRvbSAtIDEgJiYgYS5ib3R0b20gPiBiLnRvcCArIDE7XG59XG5mdW5jdGlvbiB1cFRvcChyZWN0LCB0b3ApIHtcbiAgICByZXR1cm4gdG9wIDwgcmVjdC50b3AgPyB7IHRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIHVwQm90KHJlY3QsIGJvdHRvbSkge1xuICAgIHJldHVybiBib3R0b20gPiByZWN0LmJvdHRvbSA/IHsgdG9wOiByZWN0LnRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gZG9tUG9zQXRDb29yZHMocGFyZW50LCB4LCB5KSB7XG4gICAgbGV0IGNsb3Nlc3QsIGNsb3Nlc3RSZWN0LCBjbG9zZXN0WCwgY2xvc2VzdFksIGNsb3Nlc3RPdmVybGFwID0gZmFsc2U7XG4gICAgbGV0IGFib3ZlLCBiZWxvdywgYWJvdmVSZWN0LCBiZWxvd1JlY3Q7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBwYXJlbnQuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RSZWN0ICYmIHlPdmVybGFwKGNsb3Nlc3RSZWN0LCByZWN0KSlcbiAgICAgICAgICAgICAgICByZWN0ID0gdXBUb3AodXBCb3QocmVjdCwgY2xvc2VzdFJlY3QuYm90dG9tKSwgY2xvc2VzdFJlY3QudG9wKTtcbiAgICAgICAgICAgIGxldCBkeCA9IGdldGR4KHgsIHJlY3QpLCBkeSA9IGdldGR5KHksIHJlY3QpO1xuICAgICAgICAgICAgaWYgKGR4ID09IDAgJiYgZHkgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubm9kZVR5cGUgPT0gMyA/IGRvbVBvc0luVGV4dChjaGlsZCwgeCwgeSkgOiBkb21Qb3NBdENvb3JkcyhjaGlsZCwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgfHwgY2xvc2VzdFkgPiBkeSB8fCBjbG9zZXN0WSA9PSBkeSAmJiBjbG9zZXN0WCA+IGR4KSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WCA9IGR4O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RZID0gZHk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBkeSA/ICh5IDwgcmVjdC50b3AgPyAtMSA6IDEpIDogZHggPyAoeCA8IHJlY3QubGVmdCA/IC0xIDogMSkgOiAwO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPdmVybGFwID0gIXNpZGUgfHwgKHNpZGUgPiAwID8gaSA8IHJlY3RzLmxlbmd0aCAtIDEgOiBpID4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh5ID4gcmVjdC5ib3R0b20gJiYgKCFhYm92ZVJlY3QgfHwgYWJvdmVSZWN0LmJvdHRvbSA8IHJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBhYm92ZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5IDwgcmVjdC50b3AgJiYgKCFiZWxvd1JlY3QgfHwgYmVsb3dSZWN0LnRvcCA+IHJlY3QudG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFib3ZlUmVjdCAmJiB5T3ZlcmxhcChhYm92ZVJlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gdXBCb3QoYWJvdmVSZWN0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgeU92ZXJsYXAoYmVsb3dSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHVwVG9wKGJlbG93UmVjdCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYm92ZVJlY3QgJiYgYWJvdmVSZWN0LmJvdHRvbSA+PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBhYm92ZTtcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBhYm92ZVJlY3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiBiZWxvd1JlY3QudG9wIDw9IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGJlbG93O1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGJlbG93UmVjdDtcbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0KVxuICAgICAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldDogMCB9O1xuICAgIGxldCBjbGlwWCA9IE1hdGgubWF4KGNsb3Nlc3RSZWN0LmxlZnQsIE1hdGgubWluKGNsb3Nlc3RSZWN0LnJpZ2h0LCB4KSk7XG4gICAgaWYgKGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGRvbVBvc0luVGV4dChjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgaWYgKGNsb3Nlc3RPdmVybGFwICYmIGNsb3Nlc3QuY29udGVudEVkaXRhYmxlICE9IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIGRvbVBvc0F0Q29vcmRzKGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBsZXQgb2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuY2hpbGROb2RlcywgY2xvc2VzdCkgK1xuICAgICAgICAoeCA+PSAoY2xvc2VzdFJlY3QubGVmdCArIGNsb3Nlc3RSZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGRvbVBvc0luVGV4dChub2RlLCB4LCB5KSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VzdE9mZnNldCA9IC0xLCBjbG9zZXN0RFkgPSAxZTksIGdlbmVyYWxTaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShub2RlLCBpLCBpICsgMSkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZ2VuZXJhbFNpZGUpXG4gICAgICAgICAgICAgICAgZ2VuZXJhbFNpZGUgPSB4IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IGR5ID0gKHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IHkgLSByZWN0LmJvdHRvbSkgLSAxO1xuICAgICAgICAgICAgaWYgKHJlY3QubGVmdCAtIDEgPD0geCAmJiByZWN0LnJpZ2h0ICsgMSA+PSB4ICYmIGR5IDwgY2xvc2VzdERZKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0geCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCBhZnRlciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBSVEwgb24gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdldHRpbmcgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3RzIGZvciBlbXB0eSByYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gdGV4dFJhbmdlKG5vZGUsIGkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9ICFyaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR5IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChhZnRlciA/IDEgOiAwKSB9O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPZmZzZXQgPSBpICsgKGFmdGVyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REWSA9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogY2xvc2VzdE9mZnNldCA+IC0xID8gY2xvc2VzdE9mZnNldCA6IGdlbmVyYWxTaWRlID4gMCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IDAgfTtcbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIHsgeCwgeSB9LCBwcmVjaXNlLCBiaWFzID0gLTEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvY1RvcCA9IGNvbnRlbnQudG9wICsgdmlldy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICBsZXQgYmxvY2ssIHsgZG9jSGVpZ2h0IH0gPSB2aWV3LnZpZXdTdGF0ZTtcbiAgICBsZXQgeU9mZnNldCA9IHkgLSBkb2NUb3A7XG4gICAgaWYgKHlPZmZzZXQgPCAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAoeU9mZnNldCA+IGRvY0hlaWdodClcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAvLyBTY2FuIGZvciBhIHRleHQgYmxvY2sgbmVhciB0aGUgcXVlcmllZCB5IHBvc2l0aW9uXG4gICAgZm9yIChsZXQgaGFsZkxpbmUgPSB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC8gMiwgYm91bmNlZCA9IGZhbHNlOzspIHtcbiAgICAgICAgYmxvY2sgPSB2aWV3LmVsZW1lbnRBdEhlaWdodCh5T2Zmc2V0KTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgLy8gTW92ZSB0aGUgeSBwb3NpdGlvbiBvdXQgb2YgdGhpcyBibG9ja1xuICAgICAgICAgICAgeU9mZnNldCA9IGJpYXMgPiAwID8gYmxvY2suYm90dG9tICsgaGFsZkxpbmUgOiBibG9jay50b3AgLSBoYWxmTGluZTtcbiAgICAgICAgICAgIGlmICh5T2Zmc2V0ID49IDAgJiYgeU9mZnNldCA8PSBkb2NIZWlnaHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgY29uc2lzdHMgZW50aXJlbHkgb2YgcmVwbGFjZWQgd2lkZ2V0cywgd2VcbiAgICAgICAgICAgIC8vIHdvbid0IGZpbmQgYSB0ZXh0IGJsb2NrLCBzbyByZXR1cm4gMFxuICAgICAgICAgICAgaWYgKGJvdW5jZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2UgPyBudWxsIDogMDtcbiAgICAgICAgICAgIGJvdW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgYmlhcyA9IC1iaWFzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHkgPSBkb2NUb3AgKyB5T2Zmc2V0O1xuICAgIGxldCBsaW5lU3RhcnQgPSBibG9jay5mcm9tO1xuICAgIC8vIElmIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGUgcmVuZGVyZWQgdmlld3BvcnQsIHdlIGNhbid0IGRldGVybWluZSBhIHBvc2l0aW9uXG4gICAgaWYgKGxpbmVTdGFydCA8IHZpZXcudmlld3BvcnQuZnJvbSlcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQuZnJvbSA9PSAwID8gMCA6IHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIGlmIChsaW5lU3RhcnQgPiB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC50byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGggPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOlxuICAgICAgICAgICAgcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgLy8gUHJlZmVyIFNoYWRvd1Jvb3RPckRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQgaWYgcHJlc2VudCwgZmFsbCBiYWNrIHRvIGRvY3VtZW50IGlmIG5vdFxuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGxldCByb290ID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQgPyB2aWV3LnJvb3QgOiBkb2M7XG4gICAgbGV0IGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgdW5leHBlY3RlZCwgY2xpcCB4IGF0IHRoZSBzaWRlcyBvZiB0aGUgY29udGVudCBhcmVhIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KGNvbnRlbnQubGVmdCArIDEsIE1hdGgubWluKGNvbnRlbnQucmlnaHQgLSAxLCB4KSk7XG4gICAgICAgIGVsZW1lbnQgPSByb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gVGhlcmUncyB2aXNpYmxlIGVkaXRvciBjb250ZW50IHVuZGVyIHRoZSBwb2ludCwgc28gd2UgY2FuIHRyeVxuICAgIC8vIHVzaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBhcyBhIHNob3J0Y3V0XG4gICAgbGV0IG5vZGUsIG9mZnNldCA9IC0xO1xuICAgIGlmIChlbGVtZW50ICYmICgoX2EgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChlbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpICE9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICAoeyBvZmZzZXROb2RlOiBub2RlLCBvZmZzZXQgfSA9IHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgKHsgc3RhcnRDb250YWluZXI6IG5vZGUsIHN0YXJ0T2Zmc2V0OiBvZmZzZXQgfSA9IHJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcuY29udGVudERPTS5jb250YWlucyhub2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLnNhZmFyaSAmJiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuY2hyb21lICYmIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbHVjaywgZG8gb3VyIG93biAocG90ZW50aWFsbHkgZXhwZW5zaXZlKSBzZWFyY2hcbiAgICBpZiAoIW5vZGUgfHwgIXZpZXcuZG9jVmlldy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHlPZmZzZXQgPiBibG9jay50b3AgKyBibG9jay5oZWlnaHQgLyAyID8gYmxvY2sudG8gOiBibG9jay5mcm9tO1xuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudFJlY3QsIGJsb2NrLCB4LCB5KSB7XG4gICAgbGV0IGludG8gPSBNYXRoLnJvdW5kKCh4IC0gY29udGVudFJlY3QubGVmdCkgKiB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCk7XG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nICYmIGJsb2NrLmhlaWdodCA+IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgKiAxLjUpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBNYXRoLmZsb29yKCh5IC0gYmxvY2sudG9wKSAvIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIGZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbi8vIEluIGNhc2Ugb2YgYSBoaWdoIGxpbmUgaGVpZ2h0LCBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHRyZWF0c1xuLy8gdGhlIHNwYWNlIGJldHdlZW4gbGluZXMgYXMgYmVsb25naW5nIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGVcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGlnbm9yZWQgKGlzc3VlICM0MDEpLlxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgbGV0IGxlbjtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzIHx8IG9mZnNldCAhPSAobGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nOyBuZXh0OyBuZXh0ID0gbmV4dC5uZXh0U2libGluZylcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgIT0gMSB8fCBuZXh0Lm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGV4dFJhbmdlKG5vZGUsIGxlbiAtIDEsIGxlbikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IHg7XG59XG4vLyBDaHJvbWUgd2lsbCBtb3ZlIHBvc2l0aW9ucyBiZXR3ZWVuIGxpbmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBsaW5lXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBpZiAob2Zmc2V0ICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOzspIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSB8fCBwYXJlbnQuZmlyc3RDaGlsZCAhPSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tbGluZVwiKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdXIgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCByZWN0ID0gbm9kZS5ub2RlVHlwZSA9PSAxID8gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICA6IHRleHRSYW5nZShub2RlLCAwLCBNYXRoLm1heChub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIDEpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geCAtIHJlY3QubGVmdCA+IDU7XG59XG5mdW5jdGlvbiBtb3ZlVG9MaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCk7XG4gICAgbGV0IGNvb3JkcyA9ICFpbmNsdWRlV3JhcCB8fCAhdmlldy5saW5lV3JhcHBpbmcgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgbGV0IGxpbmVWaWV3ID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHN0YXJ0LmhlYWQpO1xuICAgIGxldCBlbmQgPSBsaW5lVmlldyA/IChmb3J3YXJkID8gbGluZVZpZXcucG9zQXRFbmQgOiBsaW5lVmlldy5wb3NBdFN0YXJ0KSA6IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZW5kLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIG1vdmVCeUNoYXIodmlldywgc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCksIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgbGV0IGRpcmVjdGlvbiA9IHZpZXcudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhcnQsIGNoZWNrID0gbnVsbDs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVZpc3VhbGx5KGxpbmUsIHNwYW5zLCBkaXJlY3Rpb24sIGN1ciwgZm9yd2FyZCksIGNoYXIgPSBtb3ZlZE92ZXI7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgY2hhciA9IFwiXFxuXCI7XG4gICAgICAgICAgICBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZShsaW5lLm51bWJlciArIChmb3J3YXJkID8gMSA6IC0xKSk7XG4gICAgICAgICAgICBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICAgICAgbmV4dCA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUuZnJvbSA6IGxpbmUudG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgICAgIGlmICghYnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICBjaGVjayA9IGJ5KGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFjaGVjayhjaGFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ5R3JvdXAodmlldywgcG9zLCBzdGFydCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgY2F0ID0gY2F0ZWdvcml6ZShzdGFydCk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICByZXR1cm4gY2F0ID09IG5leHRDYXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVWZXJ0aWNhbGx5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkge1xuICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0LmhlYWQsIGRpciA9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgaWYgKHN0YXJ0UG9zID09IChmb3J3YXJkID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IGdvYWwgPSBzdGFydC5nb2FsQ29sdW1uLCBzdGFydFk7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHN0YXJ0Q29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhzdGFydFBvcyksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgPj4gMSk7XG4gICAgZm9yIChsZXQgZXh0cmEgPSAwOzsgZXh0cmEgKz0gMTApIHtcbiAgICAgICAgbGV0IGN1clkgPSBzdGFydFkgKyAoZGlzdCArIGV4dHJhKSAqIGRpcjtcbiAgICAgICAgbGV0IHBvcyA9IHBvc0F0Q29vcmRzKHZpZXcsIHsgeDogcmVzb2x2ZWRHb2FsLCB5OiBjdXJZIH0sIGZhbHNlLCBkaXIpO1xuICAgICAgICBpZiAoY3VyWSA8IHJlY3QudG9wIHx8IGN1clkgPiByZWN0LmJvdHRvbSB8fCAoZGlyIDwgMCA/IHBvcyA8IHN0YXJ0UG9zIDogcG9zID4gc3RhcnRQb3MpKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBzdGFydC5hc3NvYywgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBza2lwQXRvbXModmlldywgb2xkUG9zLCBwb3MpIHtcbiAgICBsZXQgYXRvbXMgPSB2aWV3LnN0YXRlLmZhY2V0KGF0b21pY1JhbmdlcykubWFwKGYgPT4gZih2aWV3KSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XG4gICAgICAgICAgICBzZXQuYmV0d2Vlbihwb3MuZnJvbSAtIDEsIHBvcy5mcm9tICsgMSwgKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3MuZnJvbSA+IGZyb20gJiYgcG9zLmZyb20gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBvbGRQb3MuaGVhZCA+IHBvcy5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tLCAxKSA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW92ZWQpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbn1cblxuLy8gVGhpcyB3aWxsIGFsc28gYmUgd2hlcmUgZHJhZ2dpbmcgaW5mbyBhbmQgc3VjaCBnb2VzXG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIHRoaXMuY2hyb21lU2Nyb2xsSGFjayA9IC0xO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmN1c3RvbUhhbmRsZXJzID0gW107XG4gICAgICAgIC8vIC0xIG1lYW5zIG5vdCBpbiBhIGNvbXBvc2l0aW9uLiBPdGhlcndpc2UsIHRoaXMgY291bnRzIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgY2hhbmdlcyBtYWRlIGR1cmluZyB0aGUgY29tcG9zaXRpb24uIFRoZSBjb3VudCBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGF2b2lkIHRyZWF0aW5nIHRoZSBzdGFydCBzdGF0ZSBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBhbnlcbiAgICAgICAgLy8gY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSwgYXMgcGFydCBvZiB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gLTE7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBuZXh0IGNoYW5nZSBzaG91bGQgYmUgbWFya2VkIGFzIHN0YXJ0aW5nIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiAobnVsbCBtZWFucyBubyBjb21wb3NpdGlvbiwgdHJ1ZSBtZWFucyBuZXh0IGlzIHRoZVxuICAgICAgICAvLyBmaXJzdCwgZmFsc2UgbWVhbnMgZmlyc3QgaGFzIGFscmVhZHkgYmVlbiBtYXJrZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gY29tcG9zaXRpb24pXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGxldCBoYW5kbGVFdmVudCA9IChoYW5kbGVyLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIHRoaXMua2V5ZG93bih2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMubXVzdEZsdXNoT2JzZXJ2ZXIoZXZlbnQpKVxuICAgICAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucnVuQ3VzdG9tSGFuZGxlcnMoZXZlbnQudHlwZSwgdmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2aWV3LCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoaGFuZGxlciwgZXZlbnQpO1xuICAgICAgICAgICAgfSwgaGFuZGxlck9wdGlvbnNbdHlwZV0pO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzLnB1c2godHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5zY3JvbGxET00uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdmlldy5zY3JvbGxET00gJiYgZXZlbnQuY2xpZW50WSA+IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pXG4gICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoaGFuZGxlcnMubW91c2Vkb3duLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5jaHJvbWVfdmVyc2lvbiA9PSAxMDIpIHsgLy8gRklYTUUgcmVtb3ZlIGF0IHNvbWUgcG9pbnRcbiAgICAgICAgICAgIC8vIE9uIENocm9tZSAxMDIsIHZpZXdwb3J0IHVwZGF0ZXMgc29tZWhvdyBzdG9wIHdoZWVsLWJhc2VkXG4gICAgICAgICAgICAvLyBzY3JvbGxpbmcuIFR1cm5pbmcgb2ZmIHBvaW50ZXIgZXZlbnRzIGR1cmluZyB0aGUgc2Nyb2xsIHNlZW1zXG4gICAgICAgICAgICAvLyB0byBhdm9pZCB0aGUgaXNzdWUuXG4gICAgICAgICAgICB2aWV3LnNjcm9sbERPTS5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNocm9tZVNjcm9sbEhhY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmNocm9tZVNjcm9sbEhhY2spO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hyb21lU2Nyb2xsSGFjayA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNocm9tZVNjcm9sbEhhY2sgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZmllZEZvY3VzZWQgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICAvLyBPbiBTYWZhcmkgYWRkaW5nIGFuIGlucHV0IGV2ZW50IGhhbmRsZXIgc29tZWhvdyBwcmV2ZW50cyBhblxuICAgICAgICAvLyBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlbiB5b3UgcHJlc3MgZW50ZXIuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSlcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbk9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgZW5zdXJlSGFuZGxlcnModmlldywgcGx1Z2lucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBoYW5kbGVycztcbiAgICAgICAgdGhpcy5jdXN0b21IYW5kbGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucylcbiAgICAgICAgICAgIGlmIChoYW5kbGVycyA9IChfYSA9IHBsdWdpbi51cGRhdGUodmlldykuc3BlYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUhhbmRsZXJzLnB1c2goeyBwbHVnaW46IHBsdWdpbi52YWx1ZSwgaGFuZGxlcnMgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZEV2ZW50cy5pbmRleE9mKHR5cGUpIDwgMCAmJiB0eXBlICE9IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBydW5DdXN0b21IYW5kbGVycyh0eXBlLCB2aWV3LCBldmVudCkge1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgdGhpcy5jdXN0b21IYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBzZXQuaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmNhbGwoc2V0LnBsdWdpbiwgZXZlbnQsIHZpZXcpIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJ1blNjcm9sbEhhbmRsZXJzKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5sYXN0U2Nyb2xsTGVmdCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQ7XG4gICAgICAgIGZvciAobGV0IHNldCBvZiB0aGlzLmN1c3RvbUhhbmRsZXJzKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IHNldC5oYW5kbGVycy5zY3JvbGw7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChzZXQucGx1Z2luLCBldmVudCwgdmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bih2aWV3LCBldmVudCkge1xuICAgICAgICAvLyBNdXN0IGFsd2F5cyBydW4sIGV2ZW4gaWYgYSBjdXN0b20gaGFuZGxlciBoYW5kbGVkIHRoZSBldmVudFxuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDkgJiYgRGF0ZS5ub3coKSA8IHRoaXMubGFzdEVzY1ByZXNzICsgMjAwMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxuICAgICAgICAvLyBvY2Nhc2lvbmFsbHkgZG9lcywgdXN1YWxseSBzdXJyb3VuZGVkIGJ5IGEgYnVuY2ggb2YgY29tcGxpY2F0ZWRcbiAgICAgICAgLy8gY29tcG9zaXRpb24gY2hhbmdlcy4gV2hlbiBhbiBlbnRlciBvciBiYWNrc3BhY2Uga2V5IGV2ZW50IGlzXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxuICAgICAgICAvLyBkaXNwYXRjaCBpdC5cbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiAhZXZlbnQuc3ludGhldGljICYmXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShldmVudC5rZXksIGV2ZW50LmtleUNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBFbnRlciBvbiBpT1MgbWFrZXMgdGhlXG4gICAgICAgIC8vIHZpcnR1YWwga2V5Ym9hcmQgZ2V0IHN0dWNrIGluIHRoZSB3cm9uZyAobG93ZXJjYXNlKVxuICAgICAgICAvLyBzdGF0ZS4gU28gd2UgbGV0IGl0IGdvIHRocm91Z2gsIGFuZCB0aGVuLCBpblxuICAgICAgICAvLyBhcHBseURPTUNoYW5nZSwgbm90aWZ5IGtleSBoYW5kbGVycyBvZiBpdCBhbmQgcmVzZXQgdG9cbiAgICAgICAgLy8gdGhlIHN0YXRlIHRoZXkgcHJvZHVjZS5cbiAgICAgICAgbGV0IHBlbmRpbmc7XG4gICAgICAgIGlmIChicm93c2VyLmlvcyAmJiAhZXZlbnQuc3ludGhldGljICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICgocGVuZGluZyA9IFBlbmRpbmdLZXlzLmZpbmQoa2V5ID0+IGtleS5rZXlDb2RlID09IGV2ZW50LmtleUNvZGUpKSAmJiAhZXZlbnQuY3RybEtleSB8fFxuICAgICAgICAgICAgICAgIEVtYWNzeVBlbmRpbmdLZXlzLmluZGV4T2YoZXZlbnQua2V5KSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZyB8fCBldmVudDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSh2aWV3KSwgMjUwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmx1c2hJT1NLZXkodmlldykge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgICAgICAvLyBPbiBzb21lIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmUgc29tZXRpbWVzIGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHdyb25nIG9yZGVyLiBUaGUga2V5IGV2ZW50IHNob3VsZCBzdGlsbCBiZSBpZ25vcmVkLCBldmVuIHdoZW5cbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhYnJvd3Nlci5pb3MgJiYgRGF0ZS5ub3coKSAtIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0IDwgMTAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG11c3RGbHVzaE9ic2VydmVyKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIGV2ZW50LmtleUNvZGUgIT0gMjI5O1xuICAgIH1cbiAgICBzdGFydE1vdXNlU2VsZWN0aW9uKG1vdXNlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBtb3VzZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG59XG5jb25zdCBQZW5kaW5nS2V5cyA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXTtcbmNvbnN0IEVtYWNzeVBlbmRpbmdLZXlzID0gXCJkdGhrb1wiO1xuLy8gS2V5IGNvZGVzIGZvciBtb2RpZmllciBrZXlzXG5jb25zdCBtb2RpZmllckNvZGVzID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XTtcbmZ1bmN0aW9uIGRyYWdTY3JvbGxTcGVlZChkaXN0KSB7XG4gICAgcmV0dXJuIGRpc3QgKiAwLjcgKyA4O1xufVxuY2xhc3MgTW91c2VTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0RXZlbnQsIHN0eWxlLCBtdXN0U2VsZWN0KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gbXVzdFNlbGVjdDtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gc2Nyb2xsYWJsZVBhcmVudCh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICBsZXQgZG9jID0gdmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHN0YXJ0RXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBhZGRzU2VsZWN0aW9uUmFuZ2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ01vdmUgPSBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KSAmJiBnZXRDbGlja1R5cGUoc3RhcnRFdmVudCkgPT0gMSA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb24sIGltbWVkaWF0ZWx5IGFwcGx5IHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQgPSBldmVudCk7XG4gICAgICAgIGxldCBzeCA9IDAsIHN5ID0gMDtcbiAgICAgICAgbGV0IHJlY3QgPSAoKF9hID0gdGhpcy5zY3JvbGxQYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSlcbiAgICAgICAgICAgIHx8IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogdGhpcy52aWV3Lndpbi5pbm5lcldpZHRoLCBib3R0b206IHRoaXMudmlldy53aW4uaW5uZXJIZWlnaHQgfTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggPD0gcmVjdC5sZWZ0KVxuICAgICAgICAgICAgc3ggPSAtZHJhZ1Njcm9sbFNwZWVkKHJlY3QubGVmdCAtIGV2ZW50LmNsaWVudFgpO1xuICAgICAgICBlbHNlIGlmIChldmVudC5jbGllbnRYID49IHJlY3QucmlnaHQpXG4gICAgICAgICAgICBzeCA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRYIC0gcmVjdC5yaWdodCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRZIDw9IHJlY3QudG9wKVxuICAgICAgICAgICAgc3kgPSAtZHJhZ1Njcm9sbFNwZWVkKHJlY3QudG9wIC0gZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkgPj0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICBzeSA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRZIC0gcmVjdC5ib3R0b20pO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKHN4LCBzeSk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIHNldFNjcm9sbFNwZWVkKHN4LCBzeSkge1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiBzeCwgeTogc3kgfTtcbiAgICAgICAgaWYgKHN4IHx8IHN5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zY3JvbGwoKSwgNTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsaW5nID4gLTEpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zY3JvbGxpbmcpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCArPSB0aGlzLnNjcm9sbFNwZWVkLng7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AgKz0gdGhpcy5zY3JvbGxTcGVlZC55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5zY3JvbGxCeSh0aGlzLnNjcm9sbFNwZWVkLngsIHRoaXMuc2Nyb2xsU3BlZWQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgIH1cbiAgICBzZWxlY3QoZXZlbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSk7XG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uKSB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uLm1haW4uYXNzb2MgIT0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgJiYgdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCksIDIwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRzU2VsZWN0aW9uUmFuZ2UodmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoZHJhZ01vdmVzU2VsZWN0aW9uJDEpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/ICFldmVudC5hbHRLZXkgOiAhZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKG1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBPbiBib3VuZGFyeSBjbGlja3MsIGNoZWNrIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgdGhlXG4gICAgLy8gc2VsZWN0aW9uJ3MgY2xpZW50IHJlY3RhbmdsZXNcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgaWYgKCFzZWwgfHwgc2VsLnJhbmdlQ291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHJlY3RzID0gc2VsLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPD0gZXZlbnQuY2xpZW50WCAmJiByZWN0LnJpZ2h0ID49IGV2ZW50LmNsaWVudFggJiZcbiAgICAgICAgICAgIHJlY3QudG9wIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gPj0gZXZlbnQuY2xpZW50WSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0LCBjVmlldzsgbm9kZSAhPSB2aWV3LmNvbnRlbnRET007IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8ICgoY1ZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSkpICYmIGNWaWV3Lmlnbm9yZUV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBoYW5kbGVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgaGFuZGxlck9wdGlvbnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3KSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgaW5wdXQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgIT0gbnVsbCAmJiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3RMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBzdGF0ZS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dC5saW5lKGkrKyk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgbGluZS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICB9KTtcbn1cbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpO1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gRGF0ZS5ub3coKTtcbiAgICBlbHNlIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gMDtcbn07XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gKHZpZXcsIGUpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5oYW5kbGVyT3B0aW9ucy50b3VjaHN0YXJ0ID0gaGFuZGxlck9wdGlvbnMudG91Y2htb3ZlID0geyBwYXNzaXZlOiB0cnVlIH07XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID4gRGF0ZS5ub3coKSAtIDIwMDApXG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIHRvdWNoIGludGVyYWN0aW9uXG4gICAgbGV0IHN0eWxlID0gbnVsbDtcbiAgICBmb3IgKGxldCBtYWtlU3R5bGUgb2Ygdmlldy5zdGF0ZS5mYWNldChtb3VzZVNlbGVjdGlvblN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IG1ha2VTdHlsZSh2aWV3LCBldmVudCk7XG4gICAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlICYmIGV2ZW50LmJ1dHRvbiA9PSAwKVxuICAgICAgICBzdHlsZSA9IGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBsZXQgbXVzdEZvY3VzID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NO1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuc3RhcnRNb3VzZVNlbGVjdGlvbihuZXcgTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQsIHN0eWxlLCBtdXN0Rm9jdXMpKTtcbiAgICAgICAgaWYgKG11c3RGb2N1cylcbiAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGZvY3VzUHJldmVudFNjcm9sbCh2aWV3LmNvbnRlbnRET00pKTtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbi5zdGFydChldmVudCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHJhbmdlRm9yQ2xpY2sodmlldywgcG9zLCBiaWFzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gMSkgeyAvLyBTaW5nbGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7IC8vIERvdWJsZSBjbGlja1xuICAgICAgICByZXR1cm4gZ3JvdXBBdCh2aWV3LnN0YXRlLCBwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gVHJpcGxlIGNsaWNrXG4gICAgICAgIGxldCB2aXN1YWwgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKSwgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdFN0YXJ0IDogbGluZS5mcm9tLCB0byA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IGxpbmUudG87XG4gICAgICAgIGlmICh0byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB0byA9PSBsaW5lLnRvKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxubGV0IGluc2lkZVkgPSAoeSwgcmVjdCkgPT4geSA+PSByZWN0LnRvcCAmJiB5IDw9IHJlY3QuYm90dG9tO1xubGV0IGluc2lkZSA9ICh4LCB5LCByZWN0KSA9PiBpbnNpZGVZKHksIHJlY3QpICYmIHggPj0gcmVjdC5sZWZ0ICYmIHggPD0gcmVjdC5yaWdodDtcbi8vIFRyeSB0byBkZXRlcm1pbmUsIGZvciB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbi8vIGdpdmVuIHBvc2l0aW9uLCB3aGV0aGVyIHRoZXkgYXJlIHJlbGF0ZWQgdG8gdGhlIGVsZW1lbnQgYmVmb3JlIG9yXG4vLyB0aGUgZWxlbWVudCBhZnRlciB0aGUgcG9zaXRpb24uXG5mdW5jdGlvbiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgeCwgeSkge1xuICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyk7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgb2ZmID0gcG9zIC0gbGluZS5wb3NBdFN0YXJ0O1xuICAgIC8vIExpbmUgYm91bmRhcmllcyBwb2ludCBpbnRvIHRoZSBsaW5lXG4gICAgaWYgKG9mZiA9PSAwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAob2ZmID09IGxpbmUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgLy8gUG9zaXRpb25zIG9uIHRvcCBvZiBhbiBlbGVtZW50IHBvaW50IGF0IHRoYXQgZWxlbWVudFxuICAgIGxldCBiZWZvcmUgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgLTEpO1xuICAgIGlmIChiZWZvcmUgJiYgaW5zaWRlKHgsIHksIGJlZm9yZSkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgYWZ0ZXIgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgMSk7XG4gICAgaWYgKGFmdGVyICYmIGluc2lkZSh4LCB5LCBhZnRlcikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBsaW5lIHdyYXAgcG9pbnQuIFBpY2sgYmVmb3JlIGlmIHRoZSBwb2ludCBpc1xuICAgIC8vIGJlc2lkZSBpdC5cbiAgICByZXR1cm4gYmVmb3JlICYmIGluc2lkZVkoeSwgYmVmb3JlKSA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICByZXR1cm4geyBwb3MsIGJpYXM6IGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSB9O1xufVxuY29uc3QgQmFkTW91c2VEZXRhaWwgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmxldCBsYXN0TW91c2VEb3duID0gbnVsbCwgbGFzdE1vdXNlRG93bkNvdW50ID0gMCwgbGFzdE1vdXNlRG93blRpbWUgPSAwO1xuZnVuY3Rpb24gZ2V0Q2xpY2tUeXBlKGV2ZW50KSB7XG4gICAgaWYgKCFCYWRNb3VzZURldGFpbClcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbDtcbiAgICBsZXQgbGFzdCA9IGxhc3RNb3VzZURvd24sIGxhc3RUaW1lID0gbGFzdE1vdXNlRG93blRpbWU7XG4gICAgbGFzdE1vdXNlRG93biA9IGV2ZW50O1xuICAgIGxhc3RNb3VzZURvd25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gbGFzdE1vdXNlRG93bkNvdW50ID0gIWxhc3QgfHwgKGxhc3RUaW1lID4gRGF0ZS5ub3coKSAtIDQwMCAmJiBNYXRoLmFicyhsYXN0LmNsaWVudFggLSBldmVudC5jbGllbnRYKSA8IDIgJiZcbiAgICAgICAgTWF0aC5hYnMobGFzdC5jbGllbnRZIC0gZXZlbnQuY2xpZW50WSkgPCAyKSA/IChsYXN0TW91c2VEb3duQ291bnQgKyAxKSAlIDMgOiAxO1xufVxuZnVuY3Rpb24gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgdHlwZSA9IGdldENsaWNrVHlwZShldmVudCk7XG4gICAgbGV0IHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQucG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHN0YXJ0LnBvcyk7XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIGV4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBxdWVyeVBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIGN1ci5wb3MsIGN1ci5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChzdGFydC5wb3MgIT0gY3VyLnBvcyAmJiAhZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0UmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIHN0YXJ0LnBvcywgc3RhcnQuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihzdGFydFJhbmdlLmZyb20sIHJhbmdlLmZyb20pLCB0byA9IE1hdGgubWF4KHN0YXJ0UmFuZ2UudG8sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGZyb20gPCByYW5nZS5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5yZXBsYWNlUmFuZ2Uoc3RhcnRTZWwubWFpbi5leHRlbmQocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIHN0YXJ0U2VsLnJhbmdlcy5zb21lKHIgPT4gci5lcShyYW5nZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVSYW5nZShzdGFydFNlbCwgcmFuZ2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVSYW5nZShzZWwsIHJhbmdlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXNbaV0uZXEocmFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5zbGljZSgwLCBpKS5jb25jYXQoc2VsLnJhbmdlcy5zbGljZShpICsgMSkpLCBzZWwubWFpbkluZGV4ID09IGkgPyAwIDogc2VsLm1haW5JbmRleCAtIChzZWwubWFpbkluZGV4ID4gaSA/IDEgOiAwKSk7XG4gICAgfVxufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uOiB7IG1haW4gfSB9ID0gdmlldy5zdGF0ZTtcbiAgICBsZXQgeyBtb3VzZVNlbGVjdGlvbiB9ID0gdmlldy5pbnB1dFN0YXRlO1xuICAgIGlmIChtb3VzZVNlbGVjdGlvbilcbiAgICAgICAgbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcgPSBtYWluO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHZpZXcuc3RhdGUuc2xpY2VEb2MobWFpbi5mcm9tLCBtYWluLnRvKSk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TW92ZVwiO1xuICAgIH1cbn07XG5mdW5jdGlvbiBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgZGlyZWN0KSB7XG4gICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRyb3BQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgeyBtb3VzZVNlbGVjdGlvbiB9ID0gdmlldy5pbnB1dFN0YXRlO1xuICAgIGxldCBkZWwgPSBkaXJlY3QgJiYgbW91c2VTZWxlY3Rpb24gJiYgbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcgJiYgbW91c2VTZWxlY3Rpb24uZHJhZ01vdmUgP1xuICAgICAgICB7IGZyb206IG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nLmZyb20sIHRvOiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZy50byB9IDogbnVsbDtcbiAgICBsZXQgaW5zID0geyBmcm9tOiBkcm9wUG9zLCBpbnNlcnQ6IHRleHQgfTtcbiAgICBsZXQgY2hhbmdlcyA9IHZpZXcuc3RhdGUuY2hhbmdlcyhkZWwgPyBbZGVsLCBpbnNdIDogaW5zKTtcbiAgICB2aWV3LmZvY3VzKCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIC0xKSwgaGVhZDogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgMSkgfSxcbiAgICAgICAgdXNlckV2ZW50OiBkZWwgPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcbiAgICB9KTtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIiksIHRydWUpO1xuICAgIH1cbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQudmFsdWUgPSB0ZXh0O1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHRhcmdldC5zZWxlY3Rpb25FbmQgPSB0ZXh0Lmxlbmd0aDtcbiAgICB0YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBjb3BpZWRSYW5nZShzdGF0ZSkge1xuICAgIGxldCBjb250ZW50ID0gW10sIHJhbmdlcyA9IFtdLCBsaW5ld2lzZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgaWYgKCFjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBkbyBhIGxpbmUtd2lzZSBjb3B5XG4gICAgICAgIGxldCB1cHRvID0gLTE7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IHVwdG8pIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2gobGluZS50ZXh0KTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGxpbmUudG8gKyAxKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwdG8gPSBsaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsaW5ld2lzZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7IHRleHQ6IGNvbnRlbnQuam9pbihzdGF0ZS5saW5lQnJlYWspLCByYW5nZXMsIGxpbmV3aXNlIH07XG59XG5sZXQgbGFzdExpbmV3aXNlQ29weSA9IG51bGw7XG5oYW5kbGVycy5jb3B5ID0gaGFuZGxlcnMuY3V0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgdGV4dCwgcmFuZ2VzLCBsaW5ld2lzZSB9ID0gY29waWVkUmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgaWYgKCF0ZXh0ICYmICFsaW5ld2lzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxhc3RMaW5ld2lzZUNvcHkgPSBsaW5ld2lzZSA/IHRleHQgOiBudWxsO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PSBcImN1dFwiICYmICF2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHJhbmdlcyxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgdXNlckV2ZW50OiBcImRlbGV0ZS5jdXRcIlxuICAgICAgICB9KTtcbn07XG5mdW5jdGlvbiB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3Lmhhc0ZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgfSwgMTApO1xufVxuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gV2hlbiBmb2N1c2luZyByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBtb3ZlIGl0IGJhY2sgdG8gd2hlcmUgaXQgd2FzXG4gICAgaWYgKCF2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgJiYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wIHx8IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbmhhbmRsZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5oYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gaGFuZGxlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPT0gbnVsbClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSB0cnVlO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAvLyBGSVhNRSBwb3NzaWJseSBzZXQgYSB0aW1lb3V0IHRvIGNsZWFyIGl0IGFnYWluIG9uIEFuZHJvaWRcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IDA7XG4gICAgfVxufTtcbmhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkKVxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBGb3JjZSB0aGUgY29tcG9zaXRpb24gc3RhdGUgdG8gYmUgY2xlYXJlZCBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuXG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCAmJiB2aWV3LmRvY1ZpZXcuY29tcG9zaXRpb25EZWNvLnNpemUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgfSwgNTApO1xufTtcbmhhbmRsZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RDb250ZXh0TWVudSA9IERhdGUubm93KCk7XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQmVjYXVzZSBDaHJvbWUgQW5kcm9pZCBkb2Vzbid0IGZpcmUgdXNlZnVsIGtleSBldmVudHMsIHVzZVxuICAgIC8vIGJlZm9yZWlucHV0IHRvIGRldGVjdCBiYWNrc3BhY2UgKGFuZCBwb3NzaWJseSBlbnRlciBhbmQgZGVsZXRlLFxuICAgIC8vIGJ1dCB0aG9zZSB1c3VhbGx5IGRvbid0IGV2ZW4gc2VlbSB0byBmaXJlIGJlZm9yZWlucHV0IGV2ZW50cyBhdFxuICAgIC8vIHRoZSBtb21lbnQpIGFuZCBmYWtlIGEga2V5IGV2ZW50IGZvciBpdC5cbiAgICAvL1xuICAgIC8vIChwcmV2ZW50RGVmYXVsdCBvbiBiZWZvcmVpbnB1dCwgdGhvdWdoIHN1cHBvcnRlZCBpbiB0aGUgc3BlYyxcbiAgICAvLyBzZWVtcyB0byBkbyBub3RoaW5nIGF0IGFsbCBvbiBDaHJvbWUpLlxuICAgIGxldCBwZW5kaW5nO1xuICAgIGlmIChicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmFuZHJvaWQgJiYgKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkuaW5wdXRUeXBlID09IGV2ZW50LmlucHV0VHlwZSkpKSB7XG4gICAgICAgIHZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KHBlbmRpbmcua2V5LCBwZW5kaW5nLmtleUNvZGUpO1xuICAgICAgICBpZiAocGVuZGluZy5rZXkgPT0gXCJCYWNrc3BhY2VcIiB8fCBwZW5kaW5nLmtleSA9PSBcIkRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRWaWV3SGVpZ2h0ID0gKChfYSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlaWdodCkgfHwgMDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBCYWNrc3BhY2luZyBuZWFyIHVuZWRpdGFibGUgbm9kZXMgb24gQ2hyb21lIEFuZHJvaWQgc29tZXRpbWVzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzIHRoZSB2aXJ0dWFsIGtleWJvYXJkLiBUaGlzIHRyaWVzIHRvIGNydWRlbHkgZGV0ZWN0XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbmQgcmVmb2N1cyB0byBnZXQgaXQgYmFjay5cbiAgICAgICAgICAgICAgICBpZiAoKCgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDApID4gc3RhcnRWaWV3SGVpZ2h0ICsgMTAgJiYgdmlldy5oYXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHdyYXBwaW5nV2hpdGVTcGFjZSA9IFtcInByZS13cmFwXCIsIFwibm9ybWFsXCIsIFwicHJlLWxpbmVcIiwgXCJicmVhay1zcGFjZXNcIl07XG5jbGFzcyBIZWlnaHRPcmFjbGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kb2MgPSBUZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gMzA7XG4gICAgICAgIC8vIFVzZWQgdG8gdHJhY2ssIGR1cmluZyB1cGRhdGVIZWlnaHQsIGlmIGFueSBhY3R1YWwgaGVpZ2h0cyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBoZWlnaHRGb3JHYXAoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5kb2MubGluZUF0KHRvKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyICsgMTtcbiAgICAgICAgaWYgKHRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgbGluZXMgKz0gTWF0aC5jZWlsKCgodG8gLSBmcm9tKSAtIChsaW5lcyAqIHRoaXMubGluZUxlbmd0aCAqIDAuNSkpIC8gdGhpcy5saW5lTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodCAqIGxpbmVzO1xuICAgIH1cbiAgICBoZWlnaHRGb3JMaW5lKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMubGluZVdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgbGV0IGxpbmVzID0gMSArIE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVuZ3RoIC0gdGhpcy5saW5lTGVuZ3RoKSAvICh0aGlzLmxpbmVMZW5ndGggLSA1KSkpO1xuICAgICAgICByZXR1cm4gbGluZXMgKiB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgfVxuICAgIHNldERvYyhkb2MpIHsgdGhpcy5kb2MgPSBkb2M7IHJldHVybiB0aGlzOyB9XG4gICAgbXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMSkgIT0gdGhpcy5saW5lV3JhcHBpbmc7XG4gICAgfVxuICAgIG11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykge1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBoID0gbGluZUhlaWdodHNbaV07XG4gICAgICAgICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0pIHsgLy8gUm91bmQgdG8gLjEgcGl4ZWxzXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hlaWdodDtcbiAgICB9XG4gICAgcmVmcmVzaCh3aGl0ZVNwYWNlLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIGxpbmVMZW5ndGgsIGtub3duSGVpZ2h0cykge1xuICAgICAgICBsZXQgbGluZVdyYXBwaW5nID0gd3JhcHBpbmdXaGl0ZVNwYWNlLmluZGV4T2Yod2hpdGVTcGFjZSkgPiAtMTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBNYXRoLnJvdW5kKGxpbmVIZWlnaHQpICE9IE1hdGgucm91bmQodGhpcy5saW5lSGVpZ2h0KSB8fCB0aGlzLmxpbmVXcmFwcGluZyAhPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IGNoYXJXaWR0aDtcbiAgICAgICAgdGhpcy5saW5lTGVuZ3RoID0gbGluZUxlbmd0aDtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrbm93bkhlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGtub3duSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaCA8IDApXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG59XG4vLyBUaGlzIG9iamVjdCBpcyB1c2VkIGJ5IGB1cGRhdGVIZWlnaHRgIHRvIG1ha2UgRE9NIG1lYXN1cmVtZW50c1xuLy8gYXJyaXZlIGF0IHRoZSByaWdodCBuaWRlcy4gVGhlIGBoZWlnaHRzYCBhcnJheSBpcyBhIHNlcXVlbmNlIG9mXG4vLyBibG9jayBoZWlnaHRzLCBzdGFydGluZyBmcm9tIHBvc2l0aW9uIGBmcm9tYC5cbmNsYXNzIE1lYXN1cmVkSGVpZ2h0cyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgaGVpZ2h0cykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmhlaWdodHMgPSBoZWlnaHRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgZ2V0IG1vcmUoKSB7IHJldHVybiB0aGlzLmluZGV4IDwgdGhpcy5oZWlnaHRzLmxlbmd0aDsgfVxufVxuLyoqXG5SZWNvcmQgdXNlZCB0byByZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBibG9jay1sZXZlbCBlbGVtZW50XG5pbiB0aGUgZWRpdG9yIHZpZXcuXG4qL1xuY2xhc3MgQmxvY2tJbmZvIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50KS5cbiAgICAqL1xuICAgIHRvcCwgXG4gICAgLyoqXG4gICAgSXRzIGhlaWdodC5cbiAgICAqL1xuICAgIGhlaWdodCwgXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgZWxlbWVudCBhcyBhIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUaGUgYm90dG9tIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IGJvdHRvbSgpIHsgcmV0dXJuIHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgbGV0IGRldGFpbCA9IChBcnJheS5pc0FycmF5KHRoaXMudHlwZSkgPyB0aGlzLnR5cGUgOiBbdGhpc10pXG4gICAgICAgICAgICAuY29uY2F0KEFycmF5LmlzQXJyYXkob3RoZXIudHlwZSkgPyBvdGhlci50eXBlIDogW290aGVyXSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKHRoaXMuZnJvbSwgdGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGgsIHRoaXMudG9wLCB0aGlzLmhlaWdodCArIG90aGVyLmhlaWdodCwgZGV0YWlsKTtcbiAgICB9XG59XG52YXIgUXVlcnlUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUXVlcnlUeXBlKSB7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zXCJdID0gMF0gPSBcIkJ5UG9zXCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5SGVpZ2h0XCJdID0gMV0gPSBcIkJ5SGVpZ2h0XCI7XG4gICAgUXVlcnlUeXBlW1F1ZXJ5VHlwZVtcIkJ5UG9zTm9IZWlnaHRcIl0gPSAyXSA9IFwiQnlQb3NOb0hlaWdodFwiO1xucmV0dXJuIFF1ZXJ5VHlwZX0pKFF1ZXJ5VHlwZSB8fCAoUXVlcnlUeXBlID0ge30pKTtcbmNvbnN0IEVwc2lsb24gPSAxZS0zO1xuY2xhc3MgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIC8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb3ZlcmVkXG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2YgdGhpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgIGZsYWdzID0gMiAvKiBGbGFnLk91dGRhdGVkICovKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBnZXQgb3V0ZGF0ZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogRmxhZy5PdXRkYXRlZCAqLykgPiAwOyB9XG4gICAgc2V0IG91dGRhdGVkKHZhbHVlKSB7IHRoaXMuZmxhZ3MgPSAodmFsdWUgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSB8ICh0aGlzLmZsYWdzICYgfjIgLyogRmxhZy5PdXRkYXRlZCAqLyk7IH1cbiAgICBzZXRIZWlnaHQob3JhY2xlLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSA+IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmFzZSBjYXNlIGlzIHRvIHJlcGxhY2UgYSBsZWFmIG5vZGUsIHdoaWNoIHNpbXBseSBidWlsZHMgYSB0cmVlXG4gICAgLy8gZnJvbSB0aGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIHRoYXQgKEhlaWdodE1hcEJyYW5jaCBhbmRcbiAgICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICAvLyBBZ2FpbiwgdGhlc2UgYXJlIGJhc2UgY2FzZXMsIGFuZCBhcmUgb3ZlcnJpZGRlbiBmb3IgYnJhbmNoIGFuZCBnYXAgbm9kZXMuXG4gICAgZGVjb21wb3NlTGVmdChfdG8sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGRlY29tcG9zZVJpZ2h0KF9mcm9tLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBhcHBseUNoYW5nZXMoZGVjb3JhdGlvbnMsIG9sZERvYywgb3JhY2xlLCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBjaGFuZ2VzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb2xkRG9jLCAwLCAwKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydC50byA+PSB0b0EgPyBzdGFydCA6IG1lLmxpbmVBdCh0b0EsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgdG9CICs9IGVuZC50byAtIHRvQTtcbiAgICAgICAgICAgIHRvQSA9IGVuZC50bztcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBzdGFydC5mcm9tIDw9IGNoYW5nZXNbaSAtIDFdLnRvQSkge1xuICAgICAgICAgICAgICAgIGZyb21BID0gY2hhbmdlc1tpIC0gMV0uZnJvbUE7XG4gICAgICAgICAgICAgICAgZnJvbUIgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQjtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgc3RhcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUIgKz0gc3RhcnQuZnJvbSAtIGZyb21BO1xuICAgICAgICAgICAgZnJvbUEgPSBzdGFydC5mcm9tO1xuICAgICAgICAgICAgbGV0IG5vZGVzID0gTm9kZUJ1aWxkZXIuYnVpbGQob3JhY2xlLCBkZWNvcmF0aW9ucywgZnJvbUIsIHRvQik7XG4gICAgICAgICAgICBtZSA9IG1lLnJlcGxhY2UoZnJvbUEsIHRvQSwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZS51cGRhdGVIZWlnaHQob3JhY2xlLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KCkgeyByZXR1cm4gbmV3IEhlaWdodE1hcFRleHQoMCwgMCk7IH1cbiAgICAvLyBub2RlcyB1c2VzIG51bGwgdmFsdWVzIHRvIGluZGljYXRlIHRoZSBwb3NpdGlvbiBvZiBsaW5lIGJyZWFrcy5cbiAgICAvLyBUaGVyZSBhcmUgbmV2ZXIgbGluZSBicmVha3MgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYXJyYXksIG9yXG4gICAgLy8gdHdvIGxpbmUgYnJlYWtzIG5leHQgdG8gZWFjaCBvdGhlciwgYW5kIHRoZSBhcnJheSBpc24ndCBhbGxvd2VkXG4gICAgLy8gdG8gYmUgZW1wdHkgKHNhbWUgcmVzdHJpY3Rpb25zIGFzIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBidWlsZGVyKS5cbiAgICBzdGF0aWMgb2Yobm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICBsZXQgaSA9IDAsIGogPSBub2Rlcy5sZW5ndGgsIGJlZm9yZSA9IDAsIGFmdGVyID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPiBhZnRlciAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAxICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlciA+IGJlZm9yZSAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0ID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBudWxsLCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShqLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMiArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBhZnRlciAtPSBzcGxpdC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlIDwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzW2krK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGVzWy0tal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYnJrID0gMDtcbiAgICAgICAgaWYgKG5vZGVzW2kgLSAxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIZWlnaHRNYXBCcmFuY2goSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKDAsIGkpKSwgYnJrLCBIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoaikpKTtcbiAgICB9XG59XG5IZWlnaHRNYXAucHJvdG90eXBlLnNpemUgPSAxO1xuY2xhc3MgSGVpZ2h0TWFwQmxvY2sgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0LCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgYmxvY2tBdChfaGVpZ2h0LCBfZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AsIHRoaXMuaGVpZ2h0LCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICBsaW5lQXQoX3ZhbHVlLCBfdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KDAsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBpZiAoZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiB0byA+PSBvZmZzZXQpXG4gICAgICAgICAgICBmKHRoaXMuYmxvY2tBdCgwLCBkb2MsIHRvcCwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIF9mb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXSk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGJsb2NrKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcFRleHQgZXh0ZW5kcyBIZWlnaHRNYXBCbG9jayB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSAwOyAvLyBBbW91bnQgb2YgY29sbGFwc2VkIGNvbnRlbnQgaW4gdGhlIGxpbmVcbiAgICAgICAgdGhpcy53aWRnZXRIZWlnaHQgPSAwOyAvLyBNYXhpbXVtIGlubGluZSB3aWRnZXQgaGVpZ2h0XG4gICAgfVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxICYmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmIChub2RlLmZsYWdzICYgNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi8pKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5sZW5ndGggLSBub2RlLmxlbmd0aCkgPCAxMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBIZWlnaHRNYXBUZXh0KG5vZGUubGVuZ3RoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgICAgICBub2RlLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgTWF0aC5tYXgodGhpcy53aWRnZXRIZWlnaHQsIG9yYWNsZS5oZWlnaHRGb3JMaW5lKHRoaXMubGVuZ3RoIC0gdGhpcy5jb2xsYXBzZWQpKSk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYGxpbmUoJHt0aGlzLmxlbmd0aH0ke3RoaXMuY29sbGFwc2VkID8gLXRoaXMuY29sbGFwc2VkIDogXCJcIn0ke3RoaXMud2lkZ2V0SGVpZ2h0ID8gXCI6XCIgKyB0aGlzLndpZGdldEhlaWdodCA6IFwiXCJ9KWA7XG4gICAgfVxufVxuY2xhc3MgSGVpZ2h0TWFwR2FwIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHsgc3VwZXIobGVuZ3RoLCAwKTsgfVxuICAgIGxpbmVzKGRvYywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBkb2MubGluZUF0KG9mZnNldCkubnVtYmVyLCBsYXN0TGluZSA9IGRvYy5saW5lQXQob2Zmc2V0ICsgdGhpcy5sZW5ndGgpLm51bWJlcjtcbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgbGluZUhlaWdodDogdGhpcy5oZWlnaHQgLyAobGFzdExpbmUgLSBmaXJzdExpbmUgKyAxKSB9O1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIGxpbmVIZWlnaHQpKSk7XG4gICAgICAgIGxldCB7IGZyb20sIGxlbmd0aCB9ID0gZG9jLmxpbmUoZmlyc3RMaW5lICsgbGluZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgbGluZUhlaWdodCAqIGxpbmUsIGxpbmVIZWlnaHQsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQodmFsdWUsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgdG8gLSBmcm9tLCAwLCAwLCBCbG9ja1R5cGUuVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZmlyc3RMaW5lLCBsaW5lSGVpZ2h0IH0gPSB0aGlzLmxpbmVzKGRvYywgb2Zmc2V0KTtcbiAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoLCBudW1iZXIgfSA9IGRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCBsZW5ndGgsIHRvcCArIGxpbmVIZWlnaHQgKiAobnVtYmVyIC0gZmlyc3RMaW5lKSwgbGluZUhlaWdodCwgQmxvY2tUeXBlLlRleHQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxpbmVIZWlnaHQgfSA9IHRoaXMubGluZXMoZG9jLCBvZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpLCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyB0aGlzLmxlbmd0aCwgdG8pOyBwb3MgPD0gZW5kOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAocG9zID09IGZyb20pXG4gICAgICAgICAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQgKiAobGluZS5udW1iZXIgLSBmaXJzdExpbmUpO1xuICAgICAgICAgICAgZihuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIHRvcCwgbGluZUhlaWdodCwgQmxvY2tUeXBlLlRleHQpKTtcbiAgICAgICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBsZXQgd2FzQ2hhbmdlZCA9IG9yYWNsZS5oZWlnaHRDaGFuZ2VkO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmVkLmZyb20gPiBvZmZzZXQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwR2FwKG1lYXN1cmVkLmZyb20gLSBvZmZzZXQgLSAxKS51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPD0gZW5kICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlSGVpZ2h0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc2luZ2xlSGVpZ2h0KSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSAtMjtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KGxlbiwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsaW5lLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChlbmQgLSBwb3MpLnVwZGF0ZUhlaWdodChvcmFjbGUsIHBvcykpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHdhc0NoYW5nZWQgfHwgc2luZ2xlSGVpZ2h0IDwgMCB8fCBNYXRoLmFicyhyZXN1bHQuaGVpZ2h0IC0gdGhpcy5oZWlnaHQpID49IEVwc2lsb24gfHxcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhzaW5nbGVIZWlnaHQgLSB0aGlzLmxpbmVzKG9yYWNsZS5kb2MsIG9mZnNldCkubGluZUhlaWdodCkgPj0gRXBzaWxvbjtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBvcmFjbGUuaGVpZ2h0Rm9yR2FwKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgZ2FwKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcEJyYW5jaCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVmdCwgYnJrLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0Lmxlbmd0aCArIGJyayArIHJpZ2h0Lmxlbmd0aCwgbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQsIGJyayB8IChsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkpO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgfVxuICAgIGdldCBicmVhaygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxIC8qIEZsYWcuQnJlYWsgKi87IH1cbiAgICBibG9ja0F0KGhlaWdodCwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgbWlkID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodDtcbiAgICAgICAgcmV0dXJuIGhlaWdodCA8IG1pZCA/IHRoaXMubGVmdC5ibG9ja0F0KGhlaWdodCwgZG9jLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5ibG9ja0F0KGhlaWdodCwgZG9jLCBtaWQsIG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrKTtcbiAgICB9XG4gICAgbGluZUF0KHZhbHVlLCB0eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGxldCBsZWZ0ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQgPyB2YWx1ZSA8IHJpZ2h0VG9wIDogdmFsdWUgPCByaWdodE9mZnNldDtcbiAgICAgICAgbGV0IGJhc2UgPSBsZWZ0ID8gdGhpcy5sZWZ0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldClcbiAgICAgICAgICAgIDogdGhpcy5yaWdodC5saW5lQXQodmFsdWUsIHR5cGUsIGRvYywgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgfHwgKGxlZnQgPyBiYXNlLnRvIDwgcmlnaHRPZmZzZXQgOiBiYXNlLmZyb20gPiByaWdodE9mZnNldCkpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IHN1YlF1ZXJ5ID0gdHlwZSA9PSBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA/IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0IDogUXVlcnlUeXBlLkJ5UG9zO1xuICAgICAgICBpZiAobGVmdClcbiAgICAgICAgICAgIHJldHVybiBiYXNlLmpvaW4odGhpcy5yaWdodC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBkb2MsIHJpZ2h0VG9wLCByaWdodE9mZnNldCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIGRvYywgdG9wLCBvZmZzZXQpLmpvaW4oYmFzZSk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCByaWdodFRvcCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQsIHJpZ2h0T2Zmc2V0ID0gb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAodG8gPj0gcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1pZCA9IHRoaXMubGluZUF0KHJpZ2h0T2Zmc2V0LCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgdG9wLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBtaWQuZnJvbSlcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgbWlkLmZyb20gLSAxLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmIChtaWQudG8gPj0gZnJvbSAmJiBtaWQuZnJvbSA8PSB0bylcbiAgICAgICAgICAgICAgICBmKG1pZCk7XG4gICAgICAgICAgICBpZiAodG8gPiBtaWQudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoTGluZShtaWQudG8gKyAxLCB0bywgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQsIGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCByaWdodFN0YXJ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmICh0byA8IHJpZ2h0U3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShmcm9tLCB0bywgbm9kZXMpLCB0aGlzLnJpZ2h0KTtcbiAgICAgICAgaWYgKGZyb20gPiB0aGlzLmxlZnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LnJlcGxhY2UoZnJvbSAtIHJpZ2h0U3RhcnQsIHRvIC0gcmlnaHRTdGFydCwgbm9kZXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZUxlZnQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgbGV0IGxlZnQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIGxlZnQgLSAxKTtcbiAgICAgICAgaWYgKHRvIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY29tcG9zZVJpZ2h0KHRvLCByZXN1bHQpO1xuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YocmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRvIDw9IGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubGVmdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgICAgICBpZiAodG8gPj0gbGVmdClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG8gPiBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5yaWdodC5kZWNvbXBvc2VMZWZ0KHRvIC0gbGVmdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0Lmxlbmd0aCwgcmlnaHQgPSBsZWZ0ICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKGZyb20gPj0gcmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kZWNvbXBvc2VSaWdodChmcm9tIC0gcmlnaHQsIHJlc3VsdCk7XG4gICAgICAgIGlmIChmcm9tIDwgbGVmdClcbiAgICAgICAgICAgIHRoaXMubGVmdC5kZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayAmJiBmcm9tIDwgcmlnaHQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yaWdodCk7XG4gICAgfVxuICAgIGJhbGFuY2VkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnNpemUgPiAyICogcmlnaHQuc2l6ZSB8fCByaWdodC5zaXplID4gMiAqIGxlZnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2YodGhpcy5icmVhayA/IFtsZWZ0LCBudWxsLCByaWdodF0gOiBbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gbGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZDtcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWsgKyByaWdodC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgeyBsZWZ0LCByaWdodCB9ID0gdGhpcywgcmlnaHRTdGFydCA9IG9mZnNldCArIGxlZnQubGVuZ3RoICsgdGhpcy5icmVhaywgcmViYWxhbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IGxlZnQgPSBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlKTtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gcmlnaHRTdGFydCArIHJpZ2h0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gcmlnaHQgPSByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByaWdodC51cGRhdGVIZWlnaHQob3JhY2xlLCByaWdodFN0YXJ0LCBmb3JjZSk7XG4gICAgICAgIGlmIChyZWJhbGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5sZWZ0LmhlaWdodCArIHRoaXMucmlnaHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMubGVmdCArICh0aGlzLmJyZWFrID8gXCIgXCIgOiBcIi1cIikgKyB0aGlzLnJpZ2h0OyB9XG59XG5mdW5jdGlvbiBtZXJnZUdhcHMobm9kZXMsIGFyb3VuZCkge1xuICAgIGxldCBiZWZvcmUsIGFmdGVyO1xuICAgIGlmIChub2Rlc1thcm91bmRdID09IG51bGwgJiZcbiAgICAgICAgKGJlZm9yZSA9IG5vZGVzW2Fyb3VuZCAtIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJlxuICAgICAgICAoYWZ0ZXIgPSBub2Rlc1thcm91bmQgKyAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgIG5vZGVzLnNwbGljZShhcm91bmQgLSAxLCAzLCBuZXcgSGVpZ2h0TWFwR2FwKGJlZm9yZS5sZW5ndGggKyAxICsgYWZ0ZXIubGVuZ3RoKSk7XG59XG5jb25zdCByZWxldmFudFdpZGdldEhlaWdodCA9IDU7XG5jbGFzcyBOb2RlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBvcmFjbGUpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMub3JhY2xlID0gb3JhY2xlO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGluZUVuZCA9IC0xO1xuICAgICAgICB0aGlzLmNvdmVyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSBwb3M7XG4gICAgfVxuICAgIGdldCBpc0NvdmVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvdmVyaW5nICYmIHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSB0aGlzLmNvdmVyaW5nO1xuICAgIH1cbiAgICBzcGFuKF9mcm9tLCB0bykge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHRvLCB0aGlzLmxpbmVFbmQpLCBsYXN0ID0gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgICAgIGxhc3QubGVuZ3RoICs9IGVuZCAtIHRoaXMucG9zO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID4gdGhpcy5wb3MgfHwgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dChlbmQgLSB0aGlzLnBvcywgLTEpKTtcbiAgICAgICAgICAgIHRoaXMud3JpdHRlblRvID0gZW5kO1xuICAgICAgICAgICAgaWYgKHRvID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdHRlblRvKys7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbykge1xuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGRlY28uaGVpZ2h0UmVsZXZhbnQpIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA6IDA7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgMClcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9jayhuZXcgSGVpZ2h0TWFwQmxvY2sobGVuLCBoZWlnaHQsIGRlY28udHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvID4gZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5zcGFuKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW5lRW5kID4gLTEgJiYgdGhpcy5saW5lRW5kIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICB0aGlzLmxpbmVFbmQgPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKS50bztcbiAgICB9XG4gICAgZW50ZXJMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lU3RhcnQgPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubGluZUVuZCA9IHRvO1xuICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0dGVuVG8gPCBmcm9tIC0gMSB8fCB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2godGhpcy5ibGFua0NvbnRlbnQodGhpcy53cml0dGVuVG8sIGZyb20gLSAxKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zID4gZnJvbSlcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCh0aGlzLnBvcyAtIGZyb20sIC0xKSk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3M7XG4gICAgfVxuICAgIGJsYW5rQ29udGVudChmcm9tLCB0bykge1xuICAgICAgICBsZXQgZ2FwID0gbmV3IEhlaWdodE1hcEdhcCh0byAtIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5vcmFjbGUuZG9jLmxpbmVBdChmcm9tKS50byA9PSB0bylcbiAgICAgICAgICAgIGdhcC5mbGFncyB8PSA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLztcbiAgICAgICAgcmV0dXJuIGdhcDtcbiAgICB9XG4gICAgZW5zdXJlTGluZSgpIHtcbiAgICAgICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA/IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgYWRkQmxvY2soYmxvY2spIHtcbiAgICAgICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLldpZGdldEFmdGVyICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTGluZSgpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goYmxvY2spO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBibG9jay5sZW5ndGg7XG4gICAgICAgIGlmIChibG9jay50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUpXG4gICAgICAgICAgICB0aGlzLmNvdmVyaW5nID0gYmxvY2s7XG4gICAgfVxuICAgIGFkZExpbmVEZWNvKGhlaWdodCwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyBsZW5ndGg7XG4gICAgfVxuICAgIGZpbmlzaChmcm9tKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggPT0gMCA/IG51bGwgOiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xICYmICEobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpICYmICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwVGV4dCgwLCAtMSkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLndyaXR0ZW5UbyA8IHRoaXMucG9zIHx8IGxhc3QgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgdGhpcy5wb3MpKTtcbiAgICAgICAgbGV0IHBvcyA9IGZyb207XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlSGVpZ2h0KHRoaXMub3JhY2xlLCBwb3MpO1xuICAgICAgICAgICAgcG9zICs9IG5vZGUgPyBub2RlLmxlbmd0aCA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBjYWxsZWQgd2l0aCBhIHJlZ2lvbiB0aGF0IG9uIGJvdGggc2lkZXMgZWl0aGVyIHN0cmV0Y2hlc1xuICAgIC8vIHRvIGEgbGluZSBicmVhayBvciB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgICAvLyBUaGUgcmV0dXJuZWQgYXJyYXkgdXNlcyBudWxsIHRvIGluZGljYXRlIGxpbmUgYnJlYWtzLCBidXQgbmV2ZXJcbiAgICAvLyBzdGFydHMgb3IgZW5kcyBpbiBhIGxpbmUgYnJlYWssIG9yIGhhcyBtdWx0aXBsZSBsaW5lIGJyZWFrcyBuZXh0XG4gICAgLy8gdG8gZWFjaCBvdGhlci5cbiAgICBzdGF0aWMgYnVpbGQob3JhY2xlLCBkZWNvcmF0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgTm9kZUJ1aWxkZXIoZnJvbSwgb3JhY2xlKTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyLCAwKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKGZyb20pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMoYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yO1xuICAgIFJhbmdlU2V0LmNvbXBhcmUoYSwgYiwgZGlmZiwgY29tcCwgMCk7XG4gICAgcmV0dXJuIGNvbXAuY2hhbmdlcztcbn1cbmNsYXNzIERlY29yYXRpb25Db21wYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZSgpIHsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bywgYSwgYikge1xuICAgICAgICBpZiAoZnJvbSA8IHRvIHx8IGEgJiYgYS5oZWlnaHRSZWxldmFudCB8fCBiICYmIGIuaGVpZ2h0UmVsZXZhbnQpXG4gICAgICAgICAgICBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzLCA1KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZpc2libGVQaXhlbFJhbmdlKGRvbSwgcGFkZGluZ1RvcCkge1xuICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBsZXQgbGVmdCA9IE1hdGgubWF4KDAsIHJlY3QubGVmdCksIHJpZ2h0ID0gTWF0aC5taW4od2luLmlubmVyV2lkdGgsIHJlY3QucmlnaHQpO1xuICAgIGxldCB0b3AgPSBNYXRoLm1heCgwLCByZWN0LnRvcCksIGJvdHRvbSA9IE1hdGgubWluKHdpbi5pbm5lckhlaWdodCwgcmVjdC5ib3R0b20pO1xuICAgIGZvciAobGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlOyBwYXJlbnQgJiYgcGFyZW50ICE9IGRvYy5ib2R5Oykge1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbHQpO1xuICAgICAgICAgICAgaWYgKChlbHQuc2Nyb2xsSGVpZ2h0ID4gZWx0LmNsaWVudEhlaWdodCB8fCBlbHQuc2Nyb2xsV2lkdGggPiBlbHQuY2xpZW50V2lkdGgpICYmXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgIT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50UmVjdCA9IGVsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgcGFyZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBwYXJlbnRSZWN0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHBhcmVudFJlY3QudG9wKTtcbiAgICAgICAgICAgICAgICBib3R0b20gPSBwYXJlbnQgPT0gZG9tLnBhcmVudE5vZGUgPyBwYXJlbnRSZWN0LmJvdHRvbSA6IE1hdGgubWluKGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuZnVuY3Rpb24gZnVsbFBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogcGFkZGluZ1RvcCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcod3JhcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5zaXplLCB3cmFwcGluZykgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5jbGFzcyBMaW5lR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgdmVydGljYWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCA9IHZlcnRpY2FsO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2l6ZSA9PSB0aGlzLnNpemUgJiYgb3RoZXIudmVydGljYWwgPT0gdGhpcy52ZXJ0aWNhbDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLnNpemUgKyBcInB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gXCIycHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuc2l6ZSA6IC0xOyB9XG59XG5jbGFzcyBWaWV3U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIGNvbnRlbnRET00tbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0geyBsZWZ0OiAwLCByaWdodDogd2luZG93LmlubmVyV2lkdGgsIHRvcDogMCwgYm90dG9tOiAwIH07XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZWRpdG9yV2lkdGggPSAwO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZS5mYWNldChjb250ZW50QXR0cmlidXRlcykuc29tZSh2ID0+IHR5cGVvZiB2ICE9IFwiZnVuY3Rpb25cIiAmJiB2LmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGUoZ3Vlc3NXcmFwcGluZyk7XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2Moc3RhdGUuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUuZG9jLmxlbmd0aCldKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgbnVsbCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyhmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUJsb2NrQXQocG9zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICB0aGlzLnNjYWxlciA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodCA8PSA3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyA/IElkU2NhbGVyIDpcbiAgICAgICAgICAgIG5ldyBCaWdTY2FsZXIodGhpcy5oZWlnaHRPcmFjbGUuZG9jLCB0aGlzLmhlaWdodE1hcCwgdGhpcy52aWV3cG9ydHMpO1xuICAgIH1cbiAgICB1cGRhdGVWaWV3cG9ydExpbmVzKCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLnN0YXRlLmRvYywgMCwgMCwgYmxvY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2godGhpcy5zY2FsZXIuc2NhbGUgPT0gMSA/IGJsb2NrIDogc2NhbGVCbG9jayhibG9jaywgdGhpcy5zY2FsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IHRoaXMuaGVpZ2h0TWFwLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBoZWlnaHRDaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0TWFwLmhlaWdodCAhPSBwcmV2SGVpZ2h0KVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IGhlaWdodENoYW5nZXMubGVuZ3RoID8gdGhpcy5tYXBWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB1cGRhdGUuY2hhbmdlcykgOiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcbiAgICAgICAgICAgICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh2aWV3cG9ydCkpXG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgbGV0IHVwZGF0ZUxpbmVzID0gIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fFxuICAgICAgICAgICAgdmlld3BvcnQuZnJvbSAhPSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdmlld3BvcnQudG8gIT0gdGhpcy52aWV3cG9ydC50bztcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICh1cGRhdGVMaW5lcylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIGlmICghdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jICYmIHVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgdXBkYXRlLnZpZXcubGluZVdyYXBwaW5nICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmXG4gICAgICAgICAgICAhdXBkYXRlLnN0YXRlLmZhY2V0KG5hdGl2ZVNlbGVjdGlvbkhpZGRlbikpXG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSB0cnVlO1xuICAgIH1cbiAgICBtZWFzdXJlKHZpZXcpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcuY29udGVudERPTSwgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pO1xuICAgICAgICBsZXQgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IHN0eWxlLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGxldCByZWZyZXNoID0gdGhpcy5oZWlnaHRPcmFjbGUubXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKTtcbiAgICAgICAgbGV0IG1lYXN1cmVDb250ZW50ID0gcmVmcmVzaCB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gZG9tLmNsaWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gZG9tLmNsaWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDAsIGJpYXMgPSAwO1xuICAgICAgICAvLyBWZXJ0aWNhbCBwYWRkaW5nXG4gICAgICAgIGxldCBwYWRkaW5nVG9wID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ1RvcCkgfHwgMCwgcGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDA7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdUb3AgIT0gcGFkZGluZ1RvcCB8fCB0aGlzLnBhZGRpbmdCb3R0b20gIT0gcGFkZGluZ0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBQaXhlbCB2aWV3cG9ydFxuICAgICAgICBsZXQgcGl4ZWxWaWV3cG9ydCA9ICh0aGlzLnByaW50aW5nID8gZnVsbFBpeGVsUmFuZ2UgOiB2aXNpYmxlUGl4ZWxSYW5nZSkoZG9tLCB0aGlzLnBhZGRpbmdUb3ApO1xuICAgICAgICBsZXQgZFRvcCA9IHBpeGVsVmlld3BvcnQudG9wIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCwgZEJvdHRvbSA9IHBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0gcGl4ZWxWaWV3cG9ydDtcbiAgICAgICAgbGV0IGluVmlldyA9IHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gPiB0aGlzLnBpeGVsVmlld3BvcnQudG9wICYmIHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCA+IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0O1xuICAgICAgICBpZiAoaW5WaWV3ICE9IHRoaXMuaW5WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmluVmlldyA9IGluVmlldztcbiAgICAgICAgICAgIGlmIChpblZpZXcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcgJiYgIXRoaXMuc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb20uY2xpZW50V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01XaWR0aCAhPSBjb250ZW50V2lkdGggfHwgdGhpcy5lZGl0b3JIZWlnaHQgIT0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVhc3VyZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lSGVpZ2h0cyA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHRoaXMudmlld3BvcnQpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoIH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IGxpbmVIZWlnaHQgPiAwICYmIG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgY29udGVudFdpZHRoIC8gY2hhcldpZHRoLCBsaW5lSGVpZ2h0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1pbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IHZwIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodHMgPSB2cC5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IGxpbmVIZWlnaHRzIDogdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModnApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gKHJlZnJlc2ggPyBIZWlnaHRNYXAuZW1wdHkoKS5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSkgOiB0aGlzLmhlaWdodE1hcCkudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh2cC5mcm9tLCBoZWlnaHRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JhY2xlLmhlaWdodENoYW5nZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCAmJiAodGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkID4gdGhpcy52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICh2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAoKHJlc3VsdCAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pIHx8IHZpZXdwb3J0Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHJlZnJlc2ggPyBbXSA6IHRoaXMubGluZUdhcHMsIHZpZXcpKTtcbiAgICAgICAgcmVzdWx0IHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYykge1xuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgaW4gdGhlIHJlYWQgc3RhZ2UsIGJlY2F1c2UgbW92aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHRvIGEgbGluZSBlbmQgaXMgZ29pbmcgdG8gdHJpZ2dlciBhIGxheW91dCBhbnl3YXksIHNvIGl0XG4gICAgICAgICAgICAvLyBjYW4ndCBiZSBhIHB1cmUgd3JpdGUuIEl0IHNob3VsZCBiZSByYXJlIHRoYXQgaXQgZG9lcyBhbnlcbiAgICAgICAgICAgIC8vIHdyaXRpbmcuXG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcuZW5mb3JjZUN1cnNvckFzc29jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IHZpc2libGVUb3AoKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApOyB9XG4gICAgZ2V0IHZpc2libGVCb3R0b20oKSB7IHJldHVybiB0aGlzLnNjYWxlci5mcm9tRE9NKHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20pOyB9XG4gICAgZ2V0Vmlld3BvcnQoYmlhcywgc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBkaXZpZGUgVlAuTWFyZ2luIGJldHdlZW4gdGhlIHRvcCBhbmQgdGhlXG4gICAgICAgIC8vIGJvdHRvbSwgZGVwZW5kaW5nIG9uIHRoZSBiaWFzICh0aGUgY2hhbmdlIGluIHZpZXdwb3J0IHBvc2l0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSkuIEl0J2xsIGhvbGQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgIGxldCBtYXJnaW5Ub3AgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGJpYXMgLyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIpKTtcbiAgICAgICAgbGV0IG1hcCA9IHRoaXMuaGVpZ2h0TWFwLCBkb2MgPSB0aGlzLnN0YXRlLmRvYywgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh2aXNpYmxlVG9wIC0gbWFyZ2luVG9wICogMTAwMCAvKiBWUC5NYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHZpc2libGVCb3R0b20gKyAoMSAtIG1hcmdpblRvcCkgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLnRvKTtcbiAgICAgICAgLy8gSWYgc2Nyb2xsVGFyZ2V0IGlzIGdpdmVuLCBtYWtlIHN1cmUgdGhlIHZpZXdwb3J0IGluY2x1ZGVzIHRoYXQgcG9zaXRpb25cbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgbGV0IHsgaGVhZCB9ID0gc2Nyb2xsVGFyZ2V0LnJhbmdlO1xuICAgICAgICAgICAgaWYgKGhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IGhlYWQgPiB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3SGVpZ2h0ID0gTWF0aC5taW4odGhpcy5lZGl0b3JIZWlnaHQsIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wKTtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSBtYXAubGluZUF0KGhlYWQsIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKSwgdG9wUG9zO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcImNlbnRlclwiKVxuICAgICAgICAgICAgICAgICAgICB0b3BQb3MgPSAoYmxvY2sudG9wICsgYmxvY2suYm90dG9tKSAvIDIgLSB2aWV3SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxUYXJnZXQueSA9PSBcInN0YXJ0XCIgfHwgc2Nyb2xsVGFyZ2V0LnkgPT0gXCJuZWFyZXN0XCIgJiYgaGVhZCA8IHZpZXdwb3J0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLnRvcDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IGJsb2NrLmJvdHRvbSAtIHZpZXdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmlld3BvcnQgPSBuZXcgVmlld3BvcnQobWFwLmxpbmVBdCh0b3BQb3MgLSAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS5mcm9tLCBtYXAubGluZUF0KHRvcFBvcyArIHZpZXdIZWlnaHQgKyAxMDAwIC8qIFZQLk1hcmdpbiAqLyAvIDIsIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xuICAgIH1cbiAgICBtYXBWaWV3cG9ydCh2aWV3cG9ydCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3BvcnQodGhpcy5oZWlnaHRNYXAubGluZUF0KGZyb20sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLmZyb20sIHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0bywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCkudG8pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiB2aWV3cG9ydCBjb3ZlcnMgdGhlIHZpc2libGUgcGFydCBvZiB0aGVcbiAgICAvLyBkb2N1bWVudCBhbmQgbm90IHRvbyBtdWNoIGJleW9uZCB0aGF0LlxuICAgIHZpZXdwb3J0SXNBcHByb3ByaWF0ZSh7IGZyb20sIHRvIH0sIGJpYXMgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHsgdG9wIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCk7XG4gICAgICAgIGxldCB7IGJvdHRvbSB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChmcm9tID09IDAgfHwgdG9wIDw9IHZpc2libGVUb3AgLSBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oLWJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvID09IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIGJvdHRvbSA+PSB2aXNpYmxlQm90dG9tICsgTWF0aC5tYXgoMTAgLyogVlAuTWluQ292ZXJNYXJnaW4gKi8sIE1hdGgubWluKGJpYXMsIDI1MCAvKiBWUC5NYXhDb3Zlck1hcmdpbiAqLykpKSAmJlxuICAgICAgICAgICAgKHRvcCA+IHZpc2libGVUb3AgLSAyICogMTAwMCAvKiBWUC5NYXJnaW4gKi8gJiYgYm90dG9tIDwgdmlzaWJsZUJvdHRvbSArIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyk7XG4gICAgfVxuICAgIG1hcExpbmVHYXBzKGdhcHMsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFnYXBzLmxlbmd0aCB8fCBjaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZ2FwIG9mIGdhcHMpXG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMudG91Y2hlc1JhbmdlKGdhcC5mcm9tLCBnYXAudG8pKVxuICAgICAgICAgICAgICAgIG1hcHBlZC5wdXNoKG5ldyBMaW5lR2FwKGNoYW5nZXMubWFwUG9zKGdhcC5mcm9tKSwgY2hhbmdlcy5tYXBQb3MoZ2FwLnRvKSwgZ2FwLnNpemUpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcG9zaXRpb25zIGluIHRoZSB2aWV3cG9ydCB3aGVyZSB0aGUgc3RhcnQgb3IgZW5kIG9mIGFcbiAgICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAgIC8vIGFwcHJvcHJpYXRlIHRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlZHJhd3MuXG4gICAgLy8gVXNlcyBjcnVkZSBjaGFyYWN0ZXItY291bnRpbmcgZm9yIHRoZSBwb3NpdGlvbmluZyBhbmQgc2l6aW5nLFxuICAgIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gICAgLy8gcHJlZGljdGFibGUuIFJlbGllcyBvbiBnZW5lcm91cyBtYXJnaW5zIChzZWUgTEcuTWFyZ2luKSB0byBoaWRlXG4gICAgLy8gdGhlIGFydGlmYWN0cyB0aGlzIG1pZ2h0IHByb2R1Y2UgZnJvbSB0aGUgdXNlci5cbiAgICBlbnN1cmVMaW5lR2FwcyhjdXJyZW50LCBtYXlNZWFzdXJlKSB7XG4gICAgICAgIGxldCB3cmFwcGluZyA9IHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZztcbiAgICAgICAgbGV0IG1hcmdpbiA9IHdyYXBwaW5nID8gMTAwMDAgLyogTEcuTWFyZ2luV3JhcCAqLyA6IDIwMDAgLyogTEcuTWFyZ2luICovLCBoYWxmTWFyZ2luID0gbWFyZ2luID4+IDEsIGRvdWJsZU1hcmdpbiA9IG1hcmdpbiA8PCAxO1xuICAgICAgICAvLyBUaGUgbm9uLXdyYXBwaW5nIGxvZ2ljIHdvbid0IHdvcmsgYXQgYWxsIGluIHByZWRvbWluYW50bHkgcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSICYmICF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgbGV0IGFkZEdhcCA9IChmcm9tLCB0bywgbGluZSwgc3RydWN0dXJlKSA9PiB7XG4gICAgICAgICAgICBpZiAodG8gLSBmcm9tIDwgaGFsZk1hcmdpbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgc2VsID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgYXZvaWQgPSBbc2VsLmZyb21dO1xuICAgICAgICAgICAgaWYgKCFzZWwuZW1wdHkpXG4gICAgICAgICAgICAgICAgYXZvaWQucHVzaChzZWwudG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIGF2b2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKGZyb20sIHBvcyAtIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkR2FwKHBvcyArIDEwIC8qIExHLlNlbGVjdGlvbk1hcmdpbiAqLywgdG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2FwID0gZmluZChjdXJyZW50LCBnYXAgPT4gZ2FwLmZyb20gPj0gbGluZS5mcm9tICYmIGdhcC50byA8PSBsaW5lLnRvICYmXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IGhhbGZNYXJnaW4gJiYgTWF0aC5hYnMoZ2FwLnRvIC0gdG8pIDwgaGFsZk1hcmdpbiAmJlxuICAgICAgICAgICAgICAgICFhdm9pZC5zb21lKHBvcyA9PiBnYXAuZnJvbSA8IHBvcyAmJiBnYXAudG8gPiBwb3MpKTtcbiAgICAgICAgICAgIGlmICghZ2FwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biwgc25hcCBnYXAgZW5kcyB0byBsaW5lIHN0YXJ0cyB0byBhdm9pZCBzaGlmdHMgaW4gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICBpZiAodG8gPCBsaW5lLnRvICYmIG1heU1lYXN1cmUgJiYgd3JhcHBpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5TWVhc3VyZS52aXNpYmxlUmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gdG8gJiYgci50byA+PSB0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVTdGFydCA9IG1heU1lYXN1cmUubW92ZVRvTGluZUJvdW5kYXJ5KEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pLCBmYWxzZSwgdHJ1ZSkuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdGFydCA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0byA9IGxpbmVTdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2FwID0gbmV3IExpbmVHYXAoZnJvbSwgdG8sIHRoaXMuZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBzLnB1c2goZ2FwKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZURlY28pO1xuICAgICAgICAgICAgaWYgKHN0cnVjdHVyZS50b3RhbCA8IGRvdWJsZU1hcmdpbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjcm9sbFRhcmdldCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHZpZXdGcm9tLCB2aWV3VG87XG4gICAgICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKG1hcmdpbiAvIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGgpICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgdG9wLCBib3Q7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy52aXNpYmxlQm90dG9tIC0gdGhpcy52aXNpYmxlVG9wKSAvIDIgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy52aXNpYmxlVG9wIC0gbGluZS50b3AgLSBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9ICh0aGlzLnZpc2libGVCb3R0b20gLSBsaW5lLnRvcCArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0b3ApO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luV2lkdGggPSBtYXJnaW4gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCAtIHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0KSAvIDIgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0YXJnZXRGcmFjICsgc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICh0aGlzLnBpeGVsVmlld3BvcnQubGVmdCAtIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIGFkZEdhcChsaW5lLmZyb20sIHZpZXdGcm9tLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgYWRkR2FwKHZpZXdUbywgbGluZS50bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2FwcztcbiAgICB9XG4gICAgZ2FwU2l6ZShsaW5lLCBmcm9tLCB0bywgc3RydWN0dXJlKSB7XG4gICAgICAgIGxldCBmcmFjdGlvbiA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRvKSAtIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIGZyb20pO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5oZWlnaHQgKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGggKiBmcmFjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVMaW5lR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICghTGluZUdhcC5zYW1lKGdhcHMsIHRoaXMubGluZUdhcHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVHYXBzID0gZ2FwcztcbiAgICAgICAgICAgIHRoaXMubGluZUdhcERlY28gPSBEZWNvcmF0aW9uLnNldChnYXBzLm1hcChnYXAgPT4gZ2FwLmRyYXcodGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gcmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMuc29tZSgociwgaSkgPT4gci5mcm9tICE9IHJhbmdlc1tpXS5mcm9tIHx8IHIudG8gIT0gcmFuZ2VzW2ldLnRvKTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLyA6IDA7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiYgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHBvcywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIFF1ZXJ5VHlwZS5CeUhlaWdodCwgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuc3RhdGUuZG9jLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlRGVjbykge1xuICAgIGxldCByYW5nZXMgPSBbXSwgcG9zID0gZnJvbSwgdG90YWwgPSAwO1xuICAgIFJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcbiAgICAgICAgc3BhbigpIHsgfSxcbiAgICAgICAgcG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZyb20gLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgfVxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXG4gICAgaWYgKHBvcyA8IHRvKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0byB9KTtcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCByYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvbih7IHRvdGFsLCByYW5nZXMgfSwgcmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPD0gMClcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xuICAgIGlmIChyYXRpbyA+PSAxKVxuICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXSwgc2l6ZSA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgZGlzdDtcbiAgICAgICAgZGlzdCAtPSBzaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHBvcykge1xuICAgIGxldCBjb3VudGVkID0gMDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygc3RydWN0dXJlLnJhbmdlcykge1xuICAgICAgICBpZiAocG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZWQgLyBzdHJ1Y3R1cmUudG90YWw7XG59XG5mdW5jdGlvbiBmaW5kKGFycmF5LCBmKSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIGFycmF5KVxuICAgICAgICBpZiAoZih2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gRG9uJ3Qgc2NhbGUgd2hlbiB0aGUgZG9jdW1lbnQgaGVpZ2h0IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygd2hhdFxuLy8gdGhlIERPTSBjYW4gaGFuZGxlLlxuY29uc3QgSWRTY2FsZXIgPSB7XG4gICAgdG9ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBmcm9tRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgc2NhbGU6IDFcbn07XG4vLyBXaGVuIHRoZSBoZWlnaHQgaXMgdG9vIGJpZyAoPiBWUC5NYXhET01IZWlnaHQpLCBzY2FsZSBkb3duIHRoZVxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXG4vLyBWUC5NYXhET01IZWlnaHQuXG5jbGFzcyBCaWdTY2FsZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcbiAgICAgICAgbGV0IHZwSGVpZ2h0ID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIDAsIDApLnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBoZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgMCwgMCkuYm90dG9tO1xuICAgICAgICAgICAgdnBIZWlnaHQgKz0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZSA9ICg3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyAtIHZwSGVpZ2h0KSAvIChoZWlnaHRNYXAuaGVpZ2h0IC0gdnBIZWlnaHQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgIG9iai5kb21Ub3AgPSBkb21CYXNlICsgKG9iai50b3AgLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkb21CYXNlID0gb2JqLmRvbUJvdHRvbSA9IG9iai5kb21Ub3AgKyAob2JqLmJvdHRvbSAtIG9iai50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21CYXNlICsgKG4gLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5ib3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAuZG9tVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5kb21Cb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLnRvcCArIChuIC0gdnAuZG9tVG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVCbG9jayhibG9jaywgc2NhbGVyKSB7XG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgbGV0IGJUb3AgPSBzY2FsZXIudG9ET00oYmxvY2sudG9wKSwgYkJvdHRvbSA9IHNjYWxlci50b0RPTShibG9jay5ib3R0b20pO1xuICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGJsb2NrLmZyb20sIGJsb2NrLmxlbmd0aCwgYlRvcCwgYkJvdHRvbSAtIGJUb3AsIEFycmF5LmlzQXJyYXkoYmxvY2sudHlwZSkgPyBibG9jay50eXBlLm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay50eXBlKTtcbn1cblxuY29uc3QgdGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xuY29uc3QgZGFya1RoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuaW5kZXhPZih0cnVlKSA+IC0xIH0pO1xuY29uc3QgYmFzZVRoZW1lSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlTGlnaHRJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VEYXJrSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuY29uc3QgbGlnaHREYXJrSURzID0geyBcIiZsaWdodFwiOiBcIi5cIiArIGJhc2VMaWdodElELCBcIiZkYXJrXCI6IFwiLlwiICsgYmFzZURhcmtJRCB9O1xuZnVuY3Rpb24gYnVpbGRUaGVtZShtYWluLCBzcGVjLCBzY29wZXMpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlTW9kdWxlKHNwZWMsIHtcbiAgICAgICAgZmluaXNoKHNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8mLy50ZXN0KHNlbCkgPyBzZWwucmVwbGFjZSgvJlxcdyovLCBtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobSA9PSBcIiZcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW47XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZXMgfHwgIXNjb3Blc1ttXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuc3VwcG9ydGVkIHNlbGVjdG9yOiAke219YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1ttXTtcbiAgICAgICAgICAgIH0pIDogbWFpbiArIFwiIFwiICsgc2VsO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9idWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHtcbiAgICBcIiZcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZSAhaW1wb3J0YW50XCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBzaW1wbGUgZGVmYXVsdCBvdXRsaW5lIHRvIG1ha2Ugc3VyZSBhIGZvY3VzZWRcbiAgICAgICAgICAgIC8vIGVkaXRvciBpcyB2aXN1YWxseSBkaXN0aW5jdC4gQ2FuJ3QgbGVhdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGFuZCBkb2Vzbid0IGluY2x1ZGUgdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXJzLiBXZSBhbHNvIGNhbid0IHVzZSBhbiAnYXV0bycgb3V0bGluZSwgc2luY2UgdGhvc2VcbiAgICAgICAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgdGhpbmdzIGxpa2UgdGhlIGFjdGl2ZSBsaW5lIGJhY2tncm91bmQgdG8gY292ZXJcbiAgICAgICAgICAgIC8vIHRoZSBvdXRsaW5lICgjMjk3KS5cbiAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgIH0sXG4gICAgXCIuY20tc2Nyb2xsZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnQgIWltcG9ydGFudFwiLFxuICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93WDogXCJhdXRvXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHpJbmRleDogMFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgZmxleEdyb3c6IDIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiNHB4IDBcIixcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgIFwiJltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIjoge1xuICAgICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbmVXcmFwcGluZ1wiOiB7XG4gICAgICAgIHdoaXRlU3BhY2VfZmFsbGJhY2s6IFwicHJlLXdyYXBcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJicmVhay1zcGFjZXNcIixcbiAgICAgICAgd29yZEJyZWFrOiBcImJyZWFrLXdvcmRcIixcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiBcImFueXdoZXJlXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDFcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJibGFja1wiIH0sXG4gICAgXCImZGFyayAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwid2hpdGVcIiB9LFxuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAycHggMCA2cHhcIlxuICAgIH0sXG4gICAgXCIuY20tbGF5ZXJcIjoge1xuICAgICAgICBjb250YWluOiBcInNpemUgc3R5bGVcIixcbiAgICAgICAgXCImID4gKlwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDlkOWQ5XCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMjJcIlxuICAgIH0sXG4gICAgXCImbGlnaHQuY20tZm9jdXNlZCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q3ZDRmMFwiXG4gICAgfSxcbiAgICBcIiZkYXJrLmNtLWZvY3VzZWQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMyMzNcIlxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBcInN0ZXBzKDEpIGNtLWJsaW5rIDEuMnMgaW5maW5pdGVcIlxuICAgIH0sXG4gICAgLy8gVHdvIGFuaW1hdGlvbnMgZGVmaW5lZCBzbyB0aGF0IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiB0aGVtIHRvXG4gICAgLy8gcmVzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGhvdXQgZm9yY2luZyBhbm90aGVyIHN0eWxlXG4gICAgLy8gcmVjb21wdXRhdGlvbi5cbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmtcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rMlwiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjJweCBzb2xpZCBibGFja1wiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0wLjZweFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IFwiIzQ0NFwiXG4gICAgfSxcbiAgICBcIi5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NjZWVmZjQ0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWVlZmYzM1wiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwicmVkXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcIiNmNzhcIiB9LFxuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgekluZGV4OiAyMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzZjNmM2Y1wiLFxuICAgICAgICBib3JkZXJSaWdodDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwiI2NjY1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbmVOdW1iZXJzIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDNweCAwIDVweFwiLFxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZTJmMmZmXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzIyMjIyN1wiXG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbHNcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFNwYWNlOmJlZm9yZVwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IFwiYXR0cihkYXRhLWRpc3BsYXkpXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICBjb2xvcjogXCIjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFRhYlwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjBcIj48cGF0aCBzdHJva2U9XCIlMjM4ODhcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBkPVwiTTEgMTBIMTk2TDE5MCA1TTE5MCAxNUwxOTYgMTBNMTk3IDRMMTk3IDE2XCIvPjwvc3ZnPicpYCxcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IFwiYXV0byAxMDAlXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJyaWdodCA5MCVcIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICAgIH0sXG4gICAgXCIuY20tdHJhaWxpbmdTcGFjZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmYzMzIyNTVcIlxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY2xhc3MgRE9NQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydCwgZW5kLCB0eXBlT3Zlcikge1xuICAgICAgICB0aGlzLnR5cGVPdmVyID0gdHlwZU92ZXI7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHsgaW1wcmVjaXNlSGVhZDogaUhlYWQsIGltcHJlY2lzZUFuY2hvcjogaUFuY2hvciB9ID0gdmlldy5kb2NWaWV3O1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSAmJiBzdGFydCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgY2hhbmdlcyB3aGVuIHRoZSBlZGl0b3IgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgPiAtMSAmJiAodGhpcy5ib3VuZHMgPSB2aWV3LmRvY1ZpZXcuZG9tQm91bmRzQXJvdW5kKHN0YXJ0LCBlbmQsIDApKSkge1xuICAgICAgICAgICAgbGV0IHNlbFBvaW50cyA9IGlIZWFkIHx8IGlBbmNob3IgPyBbXSA6IHNlbGVjdGlvblBvaW50cyh2aWV3KTtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRE9NUmVhZGVyKHNlbFBvaW50cywgdmlldy5zdGF0ZSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZFJhbmdlKHRoaXMuYm91bmRzLnN0YXJ0RE9NLCB0aGlzLmJvdW5kcy5lbmRET00pO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gcmVhZGVyLnRleHQ7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IHNlbGVjdGlvbkZyb21Qb2ludHMoc2VsUG9pbnRzLCB0aGlzLmJvdW5kcy5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb21TZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAgICAgbGV0IGhlYWQgPSBpSGVhZCAmJiBpSGVhZC5ub2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgaUhlYWQub2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWRcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICBsZXQgYW5jaG9yID0gaUFuY2hvciAmJiBpQW5jaG9yLm5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgaUFuY2hvci5vZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5hbmNob3JOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3JcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMubmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2UodmlldywgZG9tQ2hhbmdlKSB7XG4gICAgbGV0IGNoYW5nZTtcbiAgICBsZXQgeyBuZXdTZWwgfSA9IGRvbUNoYW5nZSwgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoZG9tQ2hhbmdlLmJvdW5kcykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gZG9tQ2hhbmdlLmJvdW5kcztcbiAgICAgICAgbGV0IHByZWZlcnJlZFBvcyA9IHNlbC5mcm9tLCBwcmVmZXJyZWRTaWRlID0gbnVsbDtcbiAgICAgICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZCAob3IsIG9uXG4gICAgICAgIC8vIEFuZHJvaWQsIHdoZW4gc29tZXRoaW5nIHdhcyBkZWxldGVkKVxuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlID09PSA4ICYmIHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA+IERhdGUubm93KCkgLSAxMDAgfHxcbiAgICAgICAgICAgIGJyb3dzZXIuYW5kcm9pZCAmJiBkb21DaGFuZ2UudGV4dC5sZW5ndGggPCB0byAtIGZyb20pIHtcbiAgICAgICAgICAgIHByZWZlcnJlZFBvcyA9IHNlbC50bztcbiAgICAgICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWZmID0gZmluZERpZmYodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSwgZG9tQ2hhbmdlLnRleHQsIHByZWZlcnJlZFBvcyAtIGZyb20sIHByZWZlcnJlZFNpZGUpO1xuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXG4gICAgICAgICAgICAvLyBlbmQgb2YgYSBsaW5lLiBEb21DaGFuZ2UgZHJvcHMgb25lIG9mIHRob3NlLlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9PSAxMyAmJlxuICAgICAgICAgICAgICAgIGRpZmYudG9CID09IGRpZmYuZnJvbSArIDIgJiYgZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikgPT0gTGluZUJyZWFrUGxhY2Vob2xkZXIgKyBMaW5lQnJlYWtQbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICBkaWZmLnRvQi0tO1xuICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tOiBmcm9tICsgZGlmZi5mcm9tLCB0bzogZnJvbSArIGRpZmYudG9BLFxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChMaW5lQnJlYWtQbGFjZWhvbGRlcikpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICghdmlldy5oYXNGb2N1cyAmJiB2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSB8fCBuZXdTZWwubWFpbi5lcShzZWwpKSkge1xuICAgICAgICBuZXdTZWwgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSAmJiAhbmV3U2VsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjaGFuZ2UgJiYgZG9tQ2hhbmdlLnR5cGVPdmVyICYmICFzZWwuZW1wdHkgJiYgbmV3U2VsICYmIG5ld1NlbC5tYWluLmVtcHR5KSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgc2VsLnRvKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJlxuICAgICAgICAoY2hhbmdlLmZyb20gIT0gc2VsLmZyb20gfHwgY2hhbmdlLnRvICE9IHNlbC50bykgJiZcbiAgICAgICAgKHNlbC50byAtIHNlbC5mcm9tKSAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSkgPD0gNCkge1xuICAgICAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcbiAgICAgICAgLy8gYXNzdW1lIGl0IGlzIGEgc2VsZWN0aW9uIHJlcGxhY2UgKHdpdGggaWRlbnRpY2FsIGNoYXJhY3RlcnMgYXRcbiAgICAgICAgLy8gdGhlIHN0YXJ0L2VuZCBub3QgaW5jbHVkZWQgaW4gdGhlIGRpZmYpXG4gICAgICAgIGNoYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLFxuICAgICAgICAgICAgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgY2hhbmdlLmZyb20pLmFwcGVuZChjaGFuZ2UuaW5zZXJ0KS5hcHBlbmQodmlldy5zdGF0ZS5kb2Muc2xpY2UoY2hhbmdlLnRvLCBzZWwudG8pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkIC0gMSAmJlxuICAgICAgICAvXlxcLiA/JC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpKSB7XG4gICAgICAgIC8vIERldGVjdCBpbnNlcnQtcGVyaW9kLW9uLWRvdWJsZS1zcGFjZSBNYWMgYW5kIEFuZHJvaWQgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJlZ3VsYXIgc3BhY2UgaW5zZXJ0LlxuICAgICAgICBpZiAobmV3U2VsICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDIpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIuY2hyb21lICYmIGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgY2hhbmdlLmZyb20gPT0gc2VsLmhlYWQgJiZcbiAgICAgICAgY2hhbmdlLmluc2VydC50b1N0cmluZygpID09IFwiXFxuIFwiICYmIHZpZXcubGluZVdyYXBwaW5nKSB7XG4gICAgICAgIC8vIEluIENocm9tZSwgaWYgeW91IGluc2VydCBhIHNwYWNlIGF0IHRoZSBzdGFydCBvZiBhIHdyYXBwZWRcbiAgICAgICAgLy8gbGluZSwgaXQgd2lsbCBhY3R1YWxseSBpbnNlcnQgYSBuZXdsaW5lIGFuZCBhIHNwYWNlLCBjYXVzaW5nIGFcbiAgICAgICAgLy8gYm9ndXMgbmV3IGxpbmUgdG8gYmUgY3JlYXRlZCBpbiBDb2RlTWlycm9yICgjOTY4KVxuICAgICAgICBpZiAobmV3U2VsKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmIHZpZXcuaW5wdXRTdGF0ZS5mbHVzaElPU0tleSh2aWV3KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IGZpcmUgcmVhc29uYWJsZSBrZXkgZXZlbnRzIGZvciBlbnRlcixcbiAgICAgICAgLy8gYmFja3NwYWNlLCBvciBkZWxldGUuIFNvIHRoaXMgZGV0ZWN0cyBjaGFuZ2VzIHRoYXQgbG9vayBsaWtlXG4gICAgICAgIC8vIHRoZXkncmUgY2F1c2VkIGJ5IHRob3NlIGtleXMsIGFuZCByZWludGVycHJldHMgdGhlbSBhcyBrZXlcbiAgICAgICAgLy8gZXZlbnRzLiAoU29tZSBvZiB0aGVzZSBrZXlzIGFyZSBhbHNvIGhhbmRsZWQgYnkgYmVmb3JlaW5wdXRcbiAgICAgICAgLy8gZXZlbnRzIGFuZCB0aGUgcGVuZGluZ0FuZHJvaWRLZXkgbWVjaGFuaXNtLCBidXQgdGhhdCdzIG5vdFxuICAgICAgICAvLyByZWxpYWJsZSBpbiBhbGwgc2l0dWF0aW9ucy4pXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiZcbiAgICAgICAgICAgICgoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byAmJlxuICAgICAgICAgICAgICAgIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDEgJiYgY2hhbmdlLmluc2VydC5saW5lcyA9PSAyICYmXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkVudGVyXCIsIDEzKSkgfHxcbiAgICAgICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gLSAxICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiQmFja3NwYWNlXCIsIDgpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICsgMSAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHRleHQgPSBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGlucHV0SGFuZGxlcikuc29tZShoID0+IGgodmlldywgY2hhbmdlLmZyb20sIGNoYW5nZS50bywgdGV4dCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgICAgIGxldCB0cjtcbiAgICAgICAgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgICAgICghbmV3U2VsIHx8IG5ld1NlbC5tYWluLmVtcHR5ICYmIG5ld1NlbC5tYWluLmZyb20gPT0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCkgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gc2VsLmZyb20gPCBjaGFuZ2UuZnJvbSA/IHN0YXJ0U3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIGNoYW5nZS5mcm9tKSA6IFwiXCI7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBzZWwudG8gPiBjaGFuZ2UudG8gPyBzdGFydFN0YXRlLnNsaWNlRG9jKGNoYW5nZS50bywgc2VsLnRvKSA6IFwiXCI7XG4gICAgICAgICAgICB0ciA9IHN0YXJ0U3RhdGUucmVwbGFjZVNlbGVjdGlvbih2aWV3LnN0YXRlLnRvVGV4dChiZWZvcmUgKyBjaGFuZ2UuaW5zZXJ0LnNsaWNlU3RyaW5nKDAsIHVuZGVmaW5lZCwgdmlldy5zdGF0ZS5saW5lQnJlYWspICsgYWZ0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKGNoYW5nZSk7XG4gICAgICAgICAgICBsZXQgbWFpblNlbCA9IG5ld1NlbCAmJiAhc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5lcShuZXdTZWwubWFpbikgJiYgbmV3U2VsLm1haW4udG8gPD0gY2hhbmdlcy5uZXdMZW5ndGhcbiAgICAgICAgICAgICAgICA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGFwcGx5IGEgY29tcG9zaXRpb24gY2hhbmdlIHRvIGFsbCBjdXJzb3JzXG4gICAgICAgICAgICBpZiAoc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCA+IDEgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmXG4gICAgICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIGxldCBjb21wb3NpdGlvblJhbmdlID0gY29tcG9zaXRpb25TdXJyb3VuZGluZ05vZGUodmlldykgfHwgdmlldy5zdGF0ZS5kb2MubGluZUF0KHNlbC5oZWFkKTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gc2VsLnRvIC0gY2hhbmdlLnRvLCBzaXplID0gc2VsLnRvIC0gc2VsLmZyb207XG4gICAgICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiByYW5nZS50byA9PSBzZWwudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCByYW5nZTogbWFpblNlbCB8fCByYW5nZS5tYXAoY2hhbmdlcykgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnRvIC0gcmFuZ2UuZnJvbSAhPSBzaXplIHx8IHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pICE9IHJlcGxhY2VkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSdzIG5vIHdheSB0byBtYWtlIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGlvbiwgc28gY3Vyc29ycyBpbiB0aGUgY29tcG9zaXRpb24gcmFuZ2UgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSAmJiByYW5nZS50byA+PSBjb21wb3NpdGlvblJhbmdlLmZyb20gJiYgcmFuZ2UuZnJvbSA8PSBjb21wb3NpdGlvblJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlQ2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyh7IGZyb20sIHRvLCBpbnNlcnQ6IGNoYW5nZS5pbnNlcnQgfSksIHNlbE9mZiA9IHJhbmdlLnRvIC0gc2VsLnRvO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6ICFtYWluU2VsID8gcmFuZ2UubWFwKHJhbmdlQ2hhbmdlcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1heCgwLCBtYWluU2VsLmFuY2hvciArIHNlbE9mZiksIE1hdGgubWF4KDAsIG1haW5TZWwuaGVhZCArIHNlbE9mZikpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZXJFdmVudCA9IFwiaW5wdXQudHlwZVwiO1xuICAgICAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQgKz0gXCIuc3RhcnRcIjtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAhbmV3U2VsLm1haW4uZXEoc2VsKSkge1xuICAgICAgICBsZXQgc2Nyb2xsSW50b1ZpZXcgPSBmYWxzZSwgdXNlckV2ZW50ID0gXCJzZWxlY3RcIjtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luID09IFwic2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgdXNlckV2ZW50ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogbmV3U2VsLCBzY3JvbGxJbnRvVmlldywgdXNlckV2ZW50IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgbWluTGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBsZXQgZnJvbSA9IDA7XG4gICAgd2hpbGUgKGZyb20gPCBtaW5MZW4gJiYgYS5jaGFyQ29kZUF0KGZyb20pID09IGIuY2hhckNvZGVBdChmcm9tKSlcbiAgICAgICAgZnJvbSsrO1xuICAgIGlmIChmcm9tID09IG1pbkxlbiAmJiBhLmxlbmd0aCA9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRvQSA9IGEubGVuZ3RoLCB0b0IgPSBiLmxlbmd0aDtcbiAgICB3aGlsZSAodG9BID4gMCAmJiB0b0IgPiAwICYmIGEuY2hhckNvZGVBdCh0b0EgLSAxKSA9PSBiLmNoYXJDb2RlQXQodG9CIC0gMSkpIHtcbiAgICAgICAgdG9BLS07XG4gICAgICAgIHRvQi0tO1xuICAgIH1cbiAgICBpZiAocHJlZmVycmVkU2lkZSA9PSBcImVuZFwiKSB7XG4gICAgICAgIGxldCBhZGp1c3QgPSBNYXRoLm1heCgwLCBmcm9tIC0gTWF0aC5taW4odG9BLCB0b0IpKTtcbiAgICAgICAgcHJlZmVycmVkUG9zIC09IHRvQSArIGFkanVzdCAtIGZyb207XG4gICAgfVxuICAgIGlmICh0b0EgPCBmcm9tICYmIGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9BID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9CID0gZnJvbSArICh0b0IgLSB0b0EpO1xuICAgICAgICB0b0EgPSBmcm9tO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b0IgPCBmcm9tKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQiA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQSA9IGZyb20gKyAodG9BIC0gdG9CKTtcbiAgICAgICAgdG9CID0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZnJvbSwgdG9BLCB0b0IgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblBvaW50cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGlmICh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChhbmNob3JOb2RlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBET01Qb2ludChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpKTtcbiAgICAgICAgaWYgKGZvY3VzTm9kZSAhPSBhbmNob3JOb2RlIHx8IGZvY3VzT2Zmc2V0ICE9IGFuY2hvck9mZnNldClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBET01Qb2ludChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tUG9pbnRzKHBvaW50cywgYmFzZSkge1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhbmNob3IgPSBwb2ludHNbMF0ucG9zLCBoZWFkID0gcG9pbnRzLmxlbmd0aCA9PSAyID8gcG9pbnRzWzFdLnBvcyA6IGFuY2hvcjtcbiAgICByZXR1cm4gYW5jaG9yID4gLTEgJiYgaGVhZCA+IC0xID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IgKyBiYXNlLCBoZWFkICsgYmFzZSkgOiBudWxsO1xufVxuXG5jb25zdCBvYnNlcnZlT3B0aW9ucyA9IHtcbiAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59O1xuLy8gSUUxMSBoYXMgdmVyeSBicm9rZW4gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB3ZSBhbHNvIGxpc3RlbiB0b1xuLy8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkIHRoZXJlXG5jb25zdCB1c2VDaGFyRGF0YSA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLy8gVGhlIGtub3duIHNlbGVjdGlvbi4gS2VwdCBpbiBvdXIgb3duIG9iamVjdCwgYXMgb3Bwb3NlZCB0byBqdXN0XG4gICAgICAgIC8vIGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgc2VsZWN0aW9uIGJlY2F1c2U6XG4gICAgICAgIC8vICAtIFNhZmFyaSBkb2Vzbid0IHJlcG9ydCB0aGUgcmlnaHQgc2VsZWN0aW9uIGluIHNoYWRvdyBET01cbiAgICAgICAgLy8gIC0gUmVhZGluZyBmcm9tIHRoZSBzZWxlY3Rpb24gZm9yY2VzIGEgRE9NIGxheW91dFxuICAgICAgICAvLyAgLSBUaGlzIHdheSwgd2UgY2FuIGlnbm9yZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnRzIGlmIHdlIGhhdmVcbiAgICAgICAgLy8gICAgYWxyZWFkeSBzZWVuIHRoZSAnbmV3JyBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZSA9IG5ldyBET01TZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgLy8gU2V0IHdoZW4gYSBzZWxlY3Rpb24gY2hhbmdlIGlzIGRldGVjdGVkLCBjbGVhcmVkIG9uIGZsdXNoXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXRzID0gW107XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZUNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2FwcyA9IFtdO1xuICAgICAgICAvLyBUaW1lb3V0IGZvciBzY2hlZHVsaW5nIGNoZWNrIG9mIHRoZSBwYXJlbnRzIHRoYXQgbmVlZCBzY3JvbGwgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgbXV0YXRpb25zKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICAgICAgLy8gSUUxMSB3aWxsIHNvbWV0aW1lcyAob24gdHlwaW5nIG92ZXIgYSBzZWxlY3Rpb24gb3JcbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIG91dCBhIHNpbmdsZSBjaGFyYWN0ZXIgdGV4dCBub2RlKSBjYWxsIHRoZVxuICAgICAgICAgICAgLy8gb2JzZXJ2ZXIgY2FsbGJhY2sgYmVmb3JlIGFjdHVhbGx5IHVwZGF0aW5nIHRoZSBET00uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVW5yZWxhdGVkbHksIGlPUyBTYWZhcmkgd2lsbCwgd2hlbiBlbmRpbmcgYSBjb21wb3NpdGlvbixcbiAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBmaXJzdCBjbGVhciBpdCwgZGVsaXZlciB0aGUgbXV0YXRpb25zLCBhbmQgdGhlblxuICAgICAgICAgICAgLy8gcmVpbnNlcnQgdGhlIGZpbmlzaGVkIHRleHQuIENvZGVNaXJyb3IncyBoYW5kbGluZyBvZiB0aGVcbiAgICAgICAgICAgIC8vIGRlbGV0aW9uIHdpbGwgcHJldmVudCB0aGUgcmVpbnNlcnRpb24gZnJvbSBoYXBwZW5pbmcsXG4gICAgICAgICAgICAvLyBicmVha2luZyBjb21wb3NpdGlvbi5cbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5pb3MgJiYgdmlldy5jb21wb3NpbmcpICYmXG4gICAgICAgICAgICAgICAgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBldmVudC5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25QcmludCA9IHRoaXMub25QcmludC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsID0gdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMudmlldy5kb2NWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdFVwZGF0ZSkgPCBEYXRlLm5vdygpIC0gNzUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwub2JzZXJ2ZSh2aWV3LnNjcm9sbERPTSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNvbnRlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCkpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVDb250ZW50Lm9ic2VydmUodmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbiA9IHZpZXcud2luKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Q2hlY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gc2V0VGltZW91dCh0aGlzLmxpc3RlbkZvclNjcm9sbC5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIChlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSAhPSB0aGlzLmludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9ICF0aGlzLmludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nICE9IHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5vYnNlcnZlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB9XG4gICAgb25TY3JvbGxDaGFuZ2VkKGUpIHtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUucnVuU2Nyb2xsSGFuZGxlcnModGhpcy52aWV3LCBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoZSkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZSk7XG4gICAgfVxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBvblByaW50KCkge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLnByaW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICB9XG4gICAgdXBkYXRlR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICh0aGlzLmdhcEludGVyc2VjdGlvbiAmJiAoZ2Fwcy5sZW5ndGggIT0gdGhpcy5nYXBzLmxlbmd0aCB8fCB0aGlzLmdhcHMuc29tZSgoZywgaSkgPT4gZyAhPSBnYXBzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLm9ic2VydmUoZ2FwKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwcyA9IGdhcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHdhc0NoYW5nZWQgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgICAgIGlmICghdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKSB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWwgPSB0aGlzLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB0aGlzLmRvbSA6ICFoYXNTZWxlY3Rpb24odmlldy5kb20sIHNlbCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb250ZXh0ID0gc2VsLmFuY2hvck5vZGUgJiYgdmlldy5kb2NWaWV3Lm5lYXJlc3Qoc2VsLmFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lmlnbm9yZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKCF3YXNDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgaGFzIGEgc2ltaWxhciBpc3N1ZSB3aGVuIGJhY2tzcGFjaW5nIG91dCBhXG4gICAgICAgIC8vIHNlbGVjdGlvbiAoIzY0NSkuXG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPD0gMTEgfHwgYnJvd3Nlci5hbmRyb2lkICYmIGJyb3dzZXIuY2hyb21lKSAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJlxuICAgICAgICAgICAgLy8gKFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRSlcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICB9XG4gICAgcmVhZFNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICAvLyBUaGUgU2VsZWN0aW9uIG9iamVjdCBpcyBicm9rZW4gaW4gc2hhZG93IHJvb3RzIGluIFNhZmFyaS4gU2VlXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0XG4gICAgICAgIGxldCByYW5nZSA9IGJyb3dzZXIuc2FmYXJpICYmIHZpZXcucm9vdC5ub2RlVHlwZSA9PSAxMSAmJlxuICAgICAgICAgICAgZGVlcEFjdGl2ZUVsZW1lbnQodGhpcy5kb20ub3duZXJEb2N1bWVudCkgPT0gdGhpcy5kb20gJiZcbiAgICAgICAgICAgIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh0aGlzLnZpZXcpIHx8IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBpZiAoIXJhbmdlIHx8IHRoaXMuc2VsZWN0aW9uUmFuZ2UuZXEocmFuZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbG9jYWwgPSBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHJhbmdlKTtcbiAgICAgICAgLy8gRGV0ZWN0IHRoZSBzaXR1YXRpb24gd2hlcmUgdGhlIGJyb3dzZXIgaGFzLCBvbiBmb2N1cywgbW92ZWQgdGhlXG4gICAgICAgIC8vIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQgZWxlbWVudC4gUmVzZXQgaXQgdG8gdGhlXG4gICAgICAgIC8vIHBvc2l0aW9uIGZyb20gdGhlIGVkaXRvciBzdGF0ZS5cbiAgICAgICAgaWYgKGxvY2FsICYmICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID4gRGF0ZS5ub3coKSAtIDIwMCAmJlxuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLmxhc3RUb3VjaFRpbWUgPCBEYXRlLm5vdygpIC0gMzAwICYmXG4gICAgICAgICAgICBhdEVsZW1lbnRTdGFydCh0aGlzLmRvbSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gMDtcbiAgICAgICAgICAgIHZpZXcuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKGxvY2FsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjbGVhclNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlLnNldChudWxsLCAwLCBudWxsLCAwKTtcbiAgICB9XG4gICAgbGlzdGVuRm9yU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIGxldCBpID0gMCwgY2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHRoaXMuZG9tOyBkb207KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5zY3JvbGxUYXJnZXRzW2ldID09IGRvbSlcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkLnB1c2goZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uYXNzaWduZWRTbG90IHx8IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgIWNoYW5nZWQpXG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMgPSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZShmKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICB9XG4gICAgLy8gVGhyb3cgYXdheSBhbnkgcGVuZGluZyBjaGFuZ2VzXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQsIGVzcGVjaWFsbHkgaW4gY29tYmluYXRpb24gd2l0aCBHQm9hcmQsIG5vdCBvbmx5XG4gICAgLy8gZG9lc24ndCByZWxpYWJseSBmaXJlIHJlZ3VsYXIga2V5IGV2ZW50cywgYnV0IGFsc28gb2Z0ZW5cbiAgICAvLyBzdXJyb3VuZHMgdGhlIGVmZmVjdCBvZiBlbnRlciBvciBiYWNrc3BhY2Ugd2l0aCBhIGJ1bmNoIG9mXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIHRoYXQsIHdoZW4gaW50ZXJydXB0ZWQsIGNhdXNlIHRleHQgZHVwbGljYXRpb25cbiAgICAvLyBvciBvdGhlciBraW5kcyBvZiBjb3JydXB0aW9uLiBUaGlzIGhhY2sgbWFrZXMgdGhlIGVkaXRvciBiYWNrIG9mZlxuICAgIC8vIGZyb20gaGFuZGxpbmcgRE9NIGNoYW5nZXMgZm9yIGEgbW9tZW50IHdoZW4gc3VjaCBhIGtleSBpc1xuICAgIC8vIGRldGVjdGVkICh2aWEgYmVmb3JlaW5wdXQgb3Iga2V5ZG93biksIGFuZCB0aGVuIHRyaWVzIHRvIGZsdXNoXG4gICAgLy8gdGhlbSBvciwgaWYgdGhhdCBoYXMgbm8gZWZmZWN0LCBkaXNwYXRjaGVzIHRoZSBnaXZlbiBrZXkuXG4gICAgZGVsYXlBbmRyb2lkS2V5KGtleSwga2V5Q29kZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgbGV0IGZsdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5O1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5mbHVzaCgpICYmIGtleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuZG9tLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx1c2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGJhY2tzcGFjZSBiZWZvcmVpbnB1dCBpcyBzb21ldGltZXMgc2lnbmFsbGVkIHNwdXJpb3VzbHksXG4gICAgICAgIC8vIEVudGVyIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkgfHwga2V5ID09IFwiRW50ZXJcIilcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSB7XG4gICAgICAgICAgICAgICAga2V5LCBrZXlDb2RlLFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIHRoZSBrZXkgaGFuZGxlciB3aGVuIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkIGlmXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBjb21pbmcgcmlnaHQgYWZ0ZXIgYW5vdGhlciBjaGFuZ2UsIGluIHdoaWNoIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBwcm9iYWJseSBwYXJ0IG9mIGEgd2VpcmQgY2hhaW4gb2YgdXBkYXRlcywgYW5kIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGlnbm9yZWQgaWYgaXQgcmV0dXJucyB0aGUgRE9NIHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICAgICAgICBmb3JjZTogdGhpcy5sYXN0Q2hhbmdlIDwgRGF0ZS5ub3coKSAtIDUwIHx8ICEhKChfYSA9IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZSlcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSB7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZEZsdXNoIDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4geyB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xOyB0aGlzLmZsdXNoKCk7IH0pO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlY29yZHMoKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgIHJlY29yZHMucHVzaChtdXQpO1xuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0eXBlT3ZlciB9O1xuICAgIH1cbiAgICByZWFkQ2hhbmdlKCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0bywgdHlwZU92ZXIgfSA9IHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgIW5ld1NlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZnJvbSA+IC0xKVxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV3IERPTUNoYW5nZSh0aGlzLnZpZXcsIGZyb20sIHRvLCB0eXBlT3Zlcik7XG4gICAgfVxuICAgIC8vIEFwcGx5IHBlbmRpbmcgY2hhbmdlcywgaWYgYW55XG4gICAgZmx1c2gocmVhZFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBob2xkIG9mZiBmbHVzaGluZyB3aGVuIHBlbmRpbmcga2V5cyBhcmUgc2V04oCUdGhlIGNvZGVcbiAgICAgICAgLy8gbWFuYWdpbmcgdGhvc2Ugd2lsbCBtYWtlIHN1cmUgcHJvY2Vzc1JlY29yZHMgaXMgY2FsbGVkIGFuZCB0aGVcbiAgICAgICAgLy8gdmlldyBpcyByZXN5bmNocm9uaXplZCBhZnRlclxuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocmVhZFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBkb21DaGFuZ2UgPSB0aGlzLnJlYWRDaGFuZ2UoKTtcbiAgICAgICAgaWYgKCFkb21DaGFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGFwcGx5RE9NQ2hhbmdlKHRoaXMudmlldywgZG9tQ2hhbmdlKTtcbiAgICAgICAgLy8gVGhlIHZpZXcgd2Fzbid0IHVwZGF0ZWRcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlKVxuICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xuICAgIH1cbiAgICByZWFkTXV0YXRpb24ocmVjKSB7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMudmlldy5kb2NWaWV3Lm5lYXJlc3QocmVjLnRhcmdldCk7XG4gICAgICAgIGlmICghY1ZpZXcgfHwgY1ZpZXcuaWdub3JlTXV0YXRpb24ocmVjKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjVmlldy5tYXJrRGlydHkocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpXG4gICAgICAgICAgICBjVmlldy5kaXJ0eSB8PSA0IC8qIERpcnR5LkF0dHJzICovO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKGNWaWV3LCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRBZnRlciA9IGZpbmRDaGlsZChjVmlldywgcmVjLm5leHRTaWJsaW5nIHx8IHJlYy50YXJnZXQubmV4dFNpYmxpbmcsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY2hpbGRCZWZvcmUgPyBjVmlldy5wb3NBZnRlcihjaGlsZEJlZm9yZSkgOiBjVmlldy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gY1ZpZXcucG9zQmVmb3JlKGNoaWxkQWZ0ZXIpIDogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlYy50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjVmlldy5wb3NBdFN0YXJ0LCB0bzogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiByZWMudGFyZ2V0Lm5vZGVWYWx1ZSA9PSByZWMub2xkVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFdpbmRvdyh3aW4pIHtcbiAgICAgICAgaWYgKHdpbiAhPSB0aGlzLndpbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICAgICAgdGhpcy53aW4gPSB3aW47XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHJlbW92ZVdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAoX2EgPSB0aGlzLmludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9iID0gdGhpcy5nYXBJbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMucmVzaXplU2Nyb2xsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2QgPSB0aGlzLnJlc2l6ZUNvbnRlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kaXNjb25uZWN0KCk7XG4gICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wYXJlbnRDaGVjayk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGQoY1ZpZXcsIGRvbSwgZGlyKSB7XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBsZXQgY3VyVmlldyA9IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICBpZiAoY3VyVmlldyAmJiBjdXJWaWV3LnBhcmVudCA9PSBjVmlldylcbiAgICAgICAgICAgIHJldHVybiBjdXJWaWV3O1xuICAgICAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIGRvbSA9IHBhcmVudCAhPSBjVmlldy5kb20gPyBwYXJlbnQgOiBkaXIgPiAwID8gZG9tLm5leHRTaWJsaW5nIDogZG9tLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcbmZ1bmN0aW9uIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIxKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd3Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5jb250ZW50RE9NLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IGZvdW5kLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSBmb3VuZC5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gZm91bmQuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IGZvdW5kLmVuZE9mZnNldDtcbiAgICBsZXQgY3VyQW5jaG9yID0gdmlldy5kb2NWaWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJBbmNob3Iubm9kZSwgY3VyQW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG5cbi8vIFRoZSBlZGl0b3IncyB1cGRhdGUgc3RhdGUgbWFjaGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICAgICBJZGxlIOKGkiBVcGRhdGluZyDih4YgSWRsZSAodW5jaGVja2VkKSDihpIgTWVhc3VyaW5nIOKGkiBJZGxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRICAgICAg4oaTXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRpbmcgKG1lYXN1cmUpXG4vL1xuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAnSWRsZScgYW5kICdJZGxlICh1bmNoZWNrZWQpJyBsaWVzIGluXG4vLyB3aGV0aGVyIGEgbGF5b3V0IGNoZWNrIGhhcyBiZWVuIHNjaGVkdWxlZC4gQSByZWd1bGFyIHVwZGF0ZSB0aHJvdWdoXG4vLyB0aGUgYHVwZGF0ZWAgbWV0aG9kIHVwZGF0ZXMgdGhlIERPTSBpbiBhIHdyaXRlLW9ubHkgZmFzaGlvbiwgYW5kXG4vLyByZWxpZXMgb24gYSBjaGVjayAoc2NoZWR1bGVkIHdpdGggYHJlcXVlc3RBbmltYXRpb25GcmFtZWApIHRvIG1ha2Vcbi8vIHN1cmUgZXZlcnl0aGluZyBpcyB3aGVyZSBpdCBzaG91bGQgYmUgYW5kIHRoZSB2aWV3cG9ydCBjb3ZlcnMgdGhlXG4vLyB2aXNpYmxlIGNvZGUuIFRoYXQgY2hlY2sgY29udGludWVzIHRvIG1lYXN1cmUgYW5kIHRoZW4gb3B0aW9uYWxseVxuLy8gdXBkYXRlIHVudGlsIGl0IHJlYWNoZXMgYSBjb2hlcmVudCBzdGF0ZS5cbi8qKlxuQW4gZWRpdG9yIHZpZXcgcmVwcmVzZW50cyB0aGUgZWRpdG9yJ3MgdXNlciBpbnRlcmZhY2UuIEl0IGhvbGRzXG50aGUgZWRpdGFibGUgRE9NIHN1cmZhY2UsIGFuZCBwb3NzaWJseSBvdGhlciBlbGVtZW50cyBzdWNoIGFzIHRoZVxubGluZSBudW1iZXIgZ3V0dGVyLiBJdCBoYW5kbGVzIGV2ZW50cyBhbmQgZGlzcGF0Y2hlcyBzdGF0ZVxudHJhbnNhY3Rpb25zIGZvciBlZGl0aW5nIGFjdGlvbnMuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHZpZXcuIFlvdSdsbCB3YW50IHRvIGVpdGhlciBwcm92aWRlIGEgYHBhcmVudGBcbiAgICBvcHRpb24sIG9yIHB1dCBgdmlldy5kb21gIGludG8geW91ciBkb2N1bWVudCBhZnRlciBjcmVhdGluZyBhXG4gICAgdmlldywgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5NYXAgPSBuZXcgTWFwO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0ge307XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0ge307XG4gICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS50YWJJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5jbGFzc05hbWUgPSBcImNtLXNjcm9sbGVyXCI7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgdG9wOiAtMTAwMDBweFwiO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmFubm91bmNlRE9NKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxET00pO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaCA9IGNvbmZpZy5kaXNwYXRjaCB8fCAoKHRyKSA9PiB0aGlzLnVwZGF0ZShbdHJdKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoY29uZmlnLnJvb3QgfHwgZ2V0Um9vdChjb25maWcucGFyZW50KSB8fCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShjb25maWcuc3RhdGUgfHwgRWRpdG9yU3RhdGUuY3JlYXRlKGNvbmZpZykpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zdGF0ZTsgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGlzcGxheSBsYXJnZSBkb2N1bWVudHMgd2l0aG91dCBjb25zdW1pbmcgdG9vIG11Y2hcbiAgICBtZW1vcnkgb3Igb3ZlcmxvYWRpbmcgdGhlIGJyb3dzZXIsIENvZGVNaXJyb3Igb25seSBkcmF3cyB0aGVcbiAgICBjb2RlIHRoYXQgaXMgdmlzaWJsZSAocGx1cyBhIG1hcmdpbiBhcm91bmQgaXQpIHRvIHRoZSBET00uIFRoaXNcbiAgICBwcm9wZXJ0eSB0ZWxscyB5b3UgdGhlIGV4dGVudCBvZiB0aGUgY3VycmVudCBkcmF3biB2aWV3cG9ydCwgaW5cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgYXJlLCBmb3IgZXhhbXBsZSwgbGFyZ2UgY29sbGFwc2VkIHJhbmdlcyBpbiB0aGVcbiAgICB2aWV3cG9ydCwgaXRzIHNpemUgY2FuIGJlIGEgbG90IGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgdmlzaWJsZVxuICAgIGNvbnRlbnQuIFRodXMsIGlmIHlvdSBhcmUgZG9pbmcgc29tZXRoaW5nIGxpa2Ugc3R5bGluZyB0aGVcbiAgICBjb250ZW50IGluIHRoZSB2aWV3cG9ydCwgaXQgaXMgcHJlZmVyYWJsZSB0byBvbmx5IGRvIHNvIGZvclxuICAgIHRoZXNlIHJhbmdlcywgd2hpY2ggYXJlIHRoZSBzdWJzZXQgb2YgdGhlIHZpZXdwb3J0IHRoYXQgaXNcbiAgICBhY3R1YWxseSBkcmF3bi5cbiAgICAqL1xuICAgIGdldCB2aXNpYmxlUmFuZ2VzKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlzaWJsZVJhbmdlczsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgZmFsc2Ugd2hlbiB0aGUgZWRpdG9yIGlzIGVudGlyZWx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XG4gICAgb3Igb3RoZXJ3aXNlIGhpZGRlbi5cbiAgICAqL1xuICAgIGdldCBpblZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5pblZpZXc7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIHRleHQgdmlhXG4gICAgW0lNRV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5wdXRfbWV0aG9kKSwgYW5kIGF0IGxlYXN0XG4gICAgb25lIGNoYW5nZSBoYXMgYmVlbiBtYWRlIGluIHRoZSBjdXJyZW50IGNvbXBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGluIGNvbXBvc2luZyBzdGF0ZS4gTm90ZVxuICAgIHRoYXQgb24gc29tZSBwbGF0Zm9ybXMsIGxpa2UgQW5kcm9pZCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIGFcbiAgICBsb3QsIHNpbmNlIGp1c3QgcHV0dGluZyB0aGUgY3Vyc29yIG9uIGEgd29yZCBzdGFydHMgYVxuICAgIGNvbXBvc2l0aW9uIHRoZXJlLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2l0aW9uU3RhcnRlZCgpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMDsgfVxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBvciBzaGFkb3cgcm9vdCB0aGF0IHRoZSB2aWV3IGxpdmVzIGluLlxuICAgICovXG4gICAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLl9yb290OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2luKCkgeyByZXR1cm4gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IH1cbiAgICBkaXNwYXRjaCguLi5pbnB1dCkge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaChpbnB1dC5sZW5ndGggPT0gMSAmJiBpbnB1dFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gaW5wdXRbMF1cbiAgICAgICAgICAgIDogdGhpcy5zdGF0ZS51cGRhdGUoLi4uaW5wdXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLiBUaGlzIHdpbGxcbiAgICB1cGRhdGUgdGhlIHZpc2libGUgZG9jdW1lbnQgYW5kIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgc3RhdGVcbiAgICBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb25zLCBhbmQgbm90aWZ5IHZpZXcgcGx1Z2lucyBvZiB0aGVcbiAgICBjaGFuZ2UuIFlvdSBzaG91bGQgdXN1YWxseSBjYWxsXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLCB3aGljaCB1c2VzIHRoaXNcbiAgICBhcyBhIHByaW1pdGl2ZS5cbiAgICAqL1xuICAgIHVwZGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy51cGRhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgbGV0IHJlZHJhd24gPSBmYWxzZSwgYXR0cnNDaGFuZ2VkID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgc3RhdGUgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZG9lc24ndCBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cIik7XG4gICAgICAgICAgICBzdGF0ZSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIERPTSBjaGFuZ2UsIGVhZ2VybHkgcmVhZCBpdCBhbmQgdHJ5IHRvXG4gICAgICAgIC8vIGFwcGx5IGl0IGFmdGVyIHRoZSBnaXZlbiB0cmFuc2FjdGlvbnMuXG4gICAgICAgIGxldCBwZW5kaW5nS2V5ID0gdGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSwgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKHBlbmRpbmdLZXkpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgZG9tQ2hhbmdlID0gdGhpcy5vYnNlcnZlci5yZWFkQ2hhbmdlKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHRyeSB0byBhcHBseSBET00gY2hhbmdlcyBpZiB0aGUgdHJhbnNhY3Rpb25zIGRpZG4ndFxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBkb2Mgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSAmJiAhdGhpcy5zdGF0ZS5kb2MuZXEoc3RhdGUuZG9jKSB8fCAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHBocmFzZXMgY2hhbmdlLCByZWRyYXcgdGhlIGVkaXRvclxuICAgICAgICBpZiAoc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykgIT0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXQgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG1haW4gfSA9IHRyLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gbmV3IFNjcm9sbFRhcmdldChtYWluLmVtcHR5ID8gbWFpbiA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobWFpbi5oZWFkLCBtYWluLmhlYWQgPiBtYWluLmFuY2hvciA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS51cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBDYWNoZWRPcmRlci51cGRhdGUodGhpcy5iaWRpQ2FjaGUsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKSAhPSB0aGlzLnN0eWxlTW9kdWxlcylcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICBhdHRyc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dBbm5vdW5jZW1lbnRzKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHJlZHJhd24sIHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwic2VsZWN0LnBvaW50ZXJcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHRoZW1lKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhlbWUpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlZHJhd24gfHwgYXR0cnNDaGFuZ2VkIHx8IHNjcm9sbFRhcmdldCB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0RW5mb3JjZUN1cnNvckFzc29jIHx8IHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudClcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGUpO1xuICAgICAgICBpZiAoZG9tQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmNvbnRlbnRET00sIHBlbmRpbmdLZXkua2V5LCBwZW5kaW5nS2V5LmtleUNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxuICAgIHNvIHlvdSBzaG91bGQgcHJvYmFibHkgb25seSB1c2UgaXQgd2hlbiB0aGUgbmV3IHN0YXRlIGlzbid0XG4gICAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcbiAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcuc2V0U3RhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICBsZXQgaGFkRm9jdXMgPSB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMsIHRoaXMucGx1Z2lucyk7XG4gICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFkRm9jdXMpXG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2lucyh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZTcGVjcyA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLCBzcGVjcyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcykge1xuICAgICAgICAgICAgbGV0IG5ld1BsdWdpbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBwcmV2U3BlY3MuaW5kZXhPZihzcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ubXVzdFVwZGF0ZSAhPSB1cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcywgdGhpcy5wbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgeyBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCwgY2xpZW50SGVpZ2h0IH0gPSB0aGlzLnNjcm9sbERPTTtcbiAgICAgICAgbGV0IHJlZkhlaWdodCA9IHNjcm9sbFRvcCA+IHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCAtIDQgPyBzY3JvbGxIZWlnaHQgOiBzY3JvbGxUb3A7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAxIC8qIFVwZGF0ZVN0YXRlLk1lYXN1cmluZyAqLztcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGxldCByZWZCbG9jayA9IHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KHJlZkhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLnZpZXdTdGF0ZS5tZWFzdXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiAhdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIk1lYXN1cmUgbG9vcCByZXN0YXJ0ZWQgbW9yZSB0aGFuIDUgdGltZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlZpZXdwb3J0IGZhaWxlZCB0byBzdGFiaWxpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyaW5nID0gW107XG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gbWVhc3VyZSByZXF1ZXN0cyBpbiB0aGlzIGN5Y2xlIHdoZW4gdGhlIHZpZXdwb3J0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VkICYgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovKSlcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMubWVhc3VyZVJlcXVlc3RzLCBtZWFzdXJpbmddID0gW21lYXN1cmluZywgdGhpcy5tZWFzdXJlUmVxdWVzdHNdO1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlZCA9IG1lYXN1cmluZy5tYXAobSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbS5yZWFkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmFkTWVhc3VyZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGUgPSBWaWV3VXBkYXRlLmNyZWF0ZSh0aGlzLCB0aGlzLnN0YXRlLCBbXSksIHJlZHJhd24gPSBmYWxzZSwgc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkW2ldICE9IEJhZE1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtZWFzdXJpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ud3JpdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ud3JpdGUobWVhc3VyZWRbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5zY3JvbGxJbnRvVmlldyh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocmVmQmxvY2suZnJvbSkudG9wIC0gcmVmQmxvY2sudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRE9NLnNjcm9sbFRvcCArPSBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IG9sZFZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSBvbGRWaWV3cG9ydC50byAmJlxuICAgICAgICAgICAgICAgICAgICAhc2Nyb2xsZWQgJiYgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVkICYmICF1cGRhdGVkLmVtcHR5KVxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZS5mYWNldCh1cGRhdGVMaXN0ZW5lcikpXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgQ1NTIGNsYXNzZXMgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGVkaXRvciB0aGVtZXMuXG4gICAgKi9cbiAgICBnZXQgdGhlbWVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4gYmFzZVRoZW1lSUQgKyBcIiBcIiArXG4gICAgICAgICAgICAodGhpcy5zdGF0ZS5mYWNldChkYXJrVGhlbWUpID8gYmFzZURhcmtJRCA6IGJhc2VMaWdodElEKSArIFwiIFwiICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZmFjZXQodGhlbWUpO1xuICAgIH1cbiAgICB1cGRhdGVBdHRycygpIHtcbiAgICAgICAgbGV0IGVkaXRvckF0dHJzID0gYXR0cnNGcm9tRmFjZXQodGhpcywgZWRpdG9yQXR0cmlidXRlcywge1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZWRpdG9yXCIgKyAodGhpcy5oYXNGb2N1cyA/IFwiIGNtLWZvY3VzZWQgXCIgOiBcIiBcIikgKyB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGNvbnRlbnRBdHRycyA9IHtcbiAgICAgICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgICAgIGF1dG9jb3JyZWN0OiBcIm9mZlwiLFxuICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6IFwib2ZmXCIsXG4gICAgICAgICAgICB0cmFuc2xhdGU6IFwibm9cIixcbiAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogIXRoaXMuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gXCJmYWxzZVwiIDogXCJ0cnVlXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1jb250ZW50XCIsXG4gICAgICAgICAgICBzdHlsZTogYCR7YnJvd3Nlci50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgICAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIGNvbnRlbnRBdHRyc1tcImFyaWEtcmVhZG9ubHlcIl0gPSBcInRydWVcIjtcbiAgICAgICAgYXR0cnNGcm9tRmFjZXQodGhpcywgY29udGVudEF0dHJpYnV0ZXMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoYW5nZWRDb250ZW50ID0gdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkRWRpdG9yID0gdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMuZWRpdG9yQXR0cnMsIGVkaXRvckF0dHJzKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQ29udGVudCB8fCBjaGFuZ2VkRWRpdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IGVkaXRvckF0dHJzO1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IGNvbnRlbnRBdHRycztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIHNob3dBbm5vdW5jZW1lbnRzKHRycykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKEVkaXRvclZpZXcuYW5ub3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3VuY2VET00udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gdGhpcy5hbm5vdW5jZURPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgbW91bnRTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNb2R1bGVzID0gdGhpcy5zdGF0ZS5mYWNldChzdHlsZU1vZHVsZSk7XG4gICAgICAgIFN0eWxlTW9kdWxlLm1vdW50KHRoaXMucm9vdCwgdGhpcy5zdHlsZU1vZHVsZXMuY29uY2F0KGJhc2VUaGVtZSQxKS5yZXZlcnNlKCkpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHRoZSBlZGl0b3IgbGF5b3V0IGlzbid0IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovICYmIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xuICAgIGRvIGN1c3RvbSBET00gbWVhc3VyaW5nIGZvbGxvd2VkIGJ5IGEgRE9NIHdyaXRlIHBoYXNlLiBVc2luZ1xuICAgIHRoaXMgaXMgcHJlZmVyYWJsZSByZWFkaW5nIERPTSBsYXlvdXQgZGlyZWN0bHkgZnJvbSwgZm9yXG4gICAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxuICAgIGRyYXdpbmcgZG9uZSBieSBvdGhlciBjb21wb25lbnRzIGlzIHN5bmNocm9uaXplZCwgYXZvaWRpbmdcbiAgICB1bm5lY2Vzc2FyeSBET00gbGF5b3V0IGNvbXB1dGF0aW9ucy5cbiAgICAqL1xuICAgIHJlcXVlc3RNZWFzdXJlKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSB0aGlzLndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5tZWFzdXJlKCkpO1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzLmluZGV4T2YocmVxdWVzdCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICAgIHBsdWdpbnMgdGhhdCBjcmFzaCBjYW4gYmUgZHJvcHBlZCBmcm9tIGEgdmlldywgc28gZXZlbiB3aGVuIHlvdVxuICAgIGtub3cgeW91IHJlZ2lzdGVyZWQgYSBnaXZlbiBwbHVnaW4sIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNoZWNrXG4gICAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHBsdWdpbihwbHVnaW4pIHtcbiAgICAgICAgbGV0IGtub3duID0gdGhpcy5wbHVnaW5NYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgIGlmIChrbm93biA9PT0gdW5kZWZpbmVkIHx8IGtub3duICYmIGtub3duLnNwZWMgIT0gcGx1Z2luKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuc2V0KHBsdWdpbiwga25vd24gPSB0aGlzLnBsdWdpbnMuZmluZChwID0+IHAuc3BlYyA9PSBwbHVnaW4pIHx8IG51bGwpO1xuICAgICAgICByZXR1cm4ga25vd24gJiYga25vd24udXBkYXRlKHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudCwgaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBUaGlzXG4gICAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgICBkaXJlY3RseSB0byB0aGUgdG9wIG9mIHRoZSBmaXJzdCBsaW5lLCBub3QgYWJvdmUgdGhlIHBhZGRpbmcuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwb3J0cyB0aGUgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cgdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgdGV4dCBsaW5lIG9yIGJsb2NrIHdpZGdldCBhdCB0aGUgZ2l2ZW4gdmVydGljYWxcbiAgICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKSkuXG4gICAgKi9cbiAgICBlbGVtZW50QXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayAoc2VlXG4gICAgW2BsaW5lQmxvY2tBdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBhdCB0aGUgZ2l2ZW5cbiAgICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50IGFuZCB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhbGwgW2xpbmVcbiAgICBibG9ja3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVCbG9ja0F0KSBpbiB0aGUgdmlld3BvcnQuIFBvc2l0aW9uc1xuICAgIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0TGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgYXJvdW5kIHRoZSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gQSBsaW5lXG4gICAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICAgIG5vbi1baGlkZGVuXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBsaW5lIGJyZWFrcywgb3IgdGhlXG4gICAgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudC4gSXQgd2lsbCB1c3VhbGx5IGp1c3QgaG9sZCBhIGxpbmUgb2ZcbiAgICB0ZXh0LCBidXQgbWF5IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIHRleHRibG9ja3MgYnkgYmxvY2tcbiAgICB3aWRnZXRzLlxuICAgICovXG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZWRpdG9yJ3MgdG90YWwgY29udGVudCBoZWlnaHQuXG4gICAgKi9cbiAgICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYnkgW2dyYXBoZW1lXG4gICAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxuICAgIHRoZSBtb3Rpb24gaXMgYXdheSBmcm9tIHRoZSBsaW5lIHN0YXJ0LCBvciB0b3dhcmRzIGl0LiBJblxuICAgIGJpZGlyZWN0aW9uYWwgdGV4dCwgdGhlIGxpbmUgaXMgdHJhdmVyc2VkIGluIHZpc3VhbCBvcmRlciwgdXNpbmdcbiAgICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiAgICBXaGVuIHRoZSBzdGFydCBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGVcbiAgICByZXR1cm5lZCBwb3NpdGlvbiB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm9cbiAgICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbml0aWFsID0+IGJ5R3JvdXAodGhpcywgc3RhcnQuaGVhZCwgaW5pdGlhbCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZVZlcnRpY2FsbHkodGhpcywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XG4gICAgbWVhbmluZ2Z1bCAoaXQgbWF5IGp1c3QgcG9pbnQgYmVmb3JlIG9yIGFmdGVyIGEgcGxhY2Vob2xkZXJcbiAgICBlbGVtZW50KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICAgIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgd2lkdGggb2YgYWxsIGNoYXJhY3RlcnMgKGdpdmVuIHZhcmlhYmxlXG4gICAgd2lkdGggZm9udHMgb3Igc3R5bGluZyBvZiBpbnZpZGlkdWFsIHJhbmdlcykuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdENoYXJhY3RlcldpZHRoKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxuICAgIGZvciBhbGwgbGluZXMuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXG4gICAgQ1NTIHByb3BlcnR5KSBvZiB0aGUgZWRpdG9yJ3MgY29udGVudCBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjsgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFzXG4gICAgYXNzaWduZWQgYnkgQ1NTLiBJZlxuICAgIFtgcGVyTGluZVRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15wZXJMaW5lVGV4dERpcmVjdGlvbilcbiAgICBpc24ndCBlbmFibGVkLCBvciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQsXG4gICAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcbiAgICBbYHRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gTm90ZSB0aGF0XG4gICAgdGhpcyBtYXkgdHJpZ2dlciBhIERPTSBsYXlvdXQuXG4gICAgKi9cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCBwZXJMaW5lID0gdGhpcy5zdGF0ZS5mYWNldChwZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghcGVyTGluZSB8fCBwb3MgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgcG9zID4gdGhpcy52aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHREaXJlY3Rpb247XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcudGV4dERpcmVjdGlvbkF0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXG4gICAgKGFzIGRldGVybWluZWQgYnkgdGhlXG4gICAgW2B3aGl0ZS1zcGFjZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy93aGl0ZS1zcGFjZSlcbiAgICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXG4gICAgKi9cbiAgICBnZXQgbGluZVdyYXBwaW5nKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIGxpbmVcbiAgICAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50IGRvY3VtZW50KSBhcyBhbiBhcnJheSBvZiBzcGFuXG4gICAgb2JqZWN0cy4gVGhlIG9yZGVyIG9mIHRoZXNlIHNwYW5zIG1hdGNoZXMgdGhlIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKeKAlGlmIHRoYXQgaXNcbiAgICBsZWZ0LXRvLXJpZ2h0LCB0aGUgbGVmdG1vc3Qgc3BhbnMgY29tZSBmaXJzdCwgb3RoZXJ3aXNlIHRoZVxuICAgIHJpZ2h0bW9zdCBzcGFucyBjb21lIGZpcnN0LlxuICAgICovXG4gICAgYmlkaVNwYW5zKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gTWF4QmlkaUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICAgICAgbGV0IGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMuYmlkaUNhY2hlKVxuICAgICAgICAgICAgaWYgKGVudHJ5LmZyb20gPT0gbGluZS5mcm9tICYmIGVudHJ5LmRpciA9PSBkaXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm9yZGVyO1xuICAgICAgICBsZXQgb3JkZXIgPSBjb21wdXRlT3JkZXIobGluZS50ZXh0LCBkaXIpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgb3JkZXIpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBlZGl0b3IgaGFzIGZvY3VzLlxuICAgICovXG4gICAgZ2V0IGhhc0ZvY3VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFNhZmFyaSByZXR1cm4gZmFsc2UgZm9yIGhhc0ZvY3VzIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuXG4gICAgICAgIC8vIG9yIGNsb3NpbmcsIHdoaWNoIGxlYWRzIHVzIHRvIGlnbm9yZSBzZWxlY3Rpb24gY2hhbmdlcyBmcm9tIHRoZVxuICAgICAgICAvLyBjb250ZXh0IG1lbnUgYmVjYXVzZSBpdCBsb29rcyBsaWtlIHRoZSBlZGl0b3IgaXNuJ3QgZm9jdXNlZC5cbiAgICAgICAgLy8gVGhpcyBrbHVkZ2VzIGFyb3VuZCB0aGF0LlxuICAgICAgICByZXR1cm4gKHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuaGFzRm9jdXMoKSB8fCBicm93c2VyLnNhZmFyaSAmJiAoKF9hID0gdGhpcy5pbnB1dFN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdENvbnRleHRNZW51KSA+IERhdGUubm93KCkgLSAzZTQpICYmXG4gICAgICAgICAgICB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET007XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBmb2N1cyBvbiB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBbcm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyMjdmlldy5FZGl0b3JWaWV3Q29uZmlnLnJvb3QpIGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuIFRoaXMgaXMgb25seVxuICAgIG5lY2Vzc2FyeSB3aGVuIG1vdmluZyB0aGUgZWRpdG9yJ3MgZXhpc3RpbmcgRE9NIHRvIGEgbmV3IHdpbmRvdyBvciBzaGFkb3cgcm9vdC5cbiAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICBpZiAodGhpcy5fcm9vdCAhPSByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuc2V0V2luZG93KChyb290Lm5vZGVUeXBlID09IDkgPyByb290IDogcm9vdC5vd25lckRvY3VtZW50KS5kZWZhdWx0VmlldyB8fCB3aW5kb3cpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFuIHVwIHRoaXMgZWRpdG9yIHZpZXcsIHJlbW92aW5nIGl0cyBlbGVtZW50IGZyb20gdGhlXG4gICAgZG9jdW1lbnQsIHVucmVnaXN0ZXJpbmcgZXZlbnQgaGFuZGxlcnMsIGFuZCBub3RpZnlpbmdcbiAgICBwbHVnaW5zLiBUaGUgdmlldyBpbnN0YW5jZSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXJcbiAgICBjYWxsaW5nIHRoaXMuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBlZmZlY3QgdGhhdCBjYW4gYmVcbiAgICBbYWRkZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRvIGEgdHJhbnNhY3Rpb24gdG9cbiAgICBjYXVzZSBpdCB0byBzY3JvbGwgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIHJhbmdlIGludG8gdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBzY3JvbGxJbnRvVmlldyhwb3MsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW50b1ZpZXcub2YobmV3IFNjcm9sbFRhcmdldCh0eXBlb2YgcG9zID09IFwibnVtYmVyXCIgPyBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcykgOiBwb3MsIG9wdGlvbnMueSwgb3B0aW9ucy54LCBvcHRpb25zLnlNYXJnaW4sIG9wdGlvbnMueE1hcmdpbikpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXG4gICAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICAgIGV4dGVuc2lvbiBwcmVjZWRlbmNlLCBhbmQgdGhlIGZpcnN0IGhhbmRsZXIgdG8gcmV0dXJuIHRydWUgd2lsbFxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxuICAgIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgICBvbiB0aGUgW2NvbnRlbnQgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29udGVudERPTSksIGV4Y2VwdFxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXG4gICAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZXMgaXMgc2Nyb2xsZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudEhhbmRsZXJzOiBoYW5kbGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGhlbWUgZXh0ZW5zaW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgY2FuIGJlIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxuICAgIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICAgIHByZWZpeGVkIHdpdGggYSBnZW5lcmF0ZWQgY2xhc3MgZm9yIHRoZSBzdHlsZS5cbiAgICBcbiAgICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgICB0aGF0IGRpcmVjdGx5IG1hdGNoIHRoZSBlZGl0b3IncyBbd3JhcHBlclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSnigJR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxuICAgIGFkZGVk4oCUbmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgICB0aGUgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudOKAlGZvciBleGFtcGxlXG4gICAgYCYuY20tZm9jdXNlZGAuXG4gICAgXG4gICAgV2hlbiBgZGFya2AgaXMgc2V0IHRvIHRydWUsIHRoZSB0aGVtZSB3aWxsIGJlIG1hcmtlZCBhcyBkYXJrLFxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxuICAgIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gICAgYCZsaWdodGAgd2hlbiBhIGxpZ2h0IHRoZW1lIGlzIGFjdGl2ZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgdGhlbWUoc3BlYywgb3B0aW9ucykge1xuICAgICAgICBsZXQgcHJlZml4ID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhcmspXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXJrVGhlbWUub2YodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcbiAgICB3aXRoIFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSksIHVzZSBgJmAgdG8gaW5kaWNhdGUgdGhlXG4gICAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XG4gICAgdGFyZ2V0IGVkaXRvcnMgd2l0aCBhIGRhcmsgb3IgbGlnaHQgdGhlbWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFByZWMubG93ZXN0KHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhbiBlZGl0b3IgdmlldyBpbnN0YW5jZSBmcm9tIHRoZSB2aWV3J3MgRE9NXG4gICAgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb21ET00oZG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xuICAgICAgICBsZXQgY1ZpZXcgPSBjb250ZW50ICYmIENvbnRlbnRWaWV3LmdldChjb250ZW50KSB8fCBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBjVmlldyA9PT0gbnVsbCB8fCBjVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY1ZpZXcucm9vdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3KSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcbkJ5IGRlZmF1bHQsIHRoZSBlZGl0b3IgYXNzdW1lcyBhbGwgaXRzIGNvbnRlbnQgaGFzIHRoZSBzYW1lXG5bdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EaXJlY3Rpb24pLiBDb25maWd1cmUgdGhpcyB3aXRoIGEgYHRydWVgXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcbmxpbmUgc2VwYXJhdGVseS5cbiovXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBoYXZlIGl0cyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0LiAoTm90ZSB0aGF0IHRoaXNcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cbndoZW4gdGhvc2UgYXJlIGJvdW5kIHRvIGtleXMgb3IgYnV0dG9ucy4gU2VlIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGZhY2V0IGZvciB0aGF0LilcbiovXG5FZGl0b3JWaWV3LmVkaXRhYmxlID0gZWRpdGFibGU7XG4vKipcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxuZnVuY3Rpb25zIGluIHRoaXMgZmFjZXQgd2lsbCBiZSBjYWxsZWQgZm9yIGEgYG1vdXNlZG93bmAgZXZlbnRcbm9uIHRoZSBlZGl0b3IsIGFuZCBjYW4gcmV0dXJuIGFuIG9iamVjdCB0aGF0IG92ZXJyaWRlcyB0aGUgd2F5IGFcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cbiovXG5FZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUgPSBtb3VzZVNlbGVjdGlvblN0eWxlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW9uIGRyYWcgZXZlbnRcbnNob3VsZCBtb3ZlIG9yIGNvcHkgdGhlIHNlbGVjdGlvbi4gVGhlIGdpdmVuIHByZWRpY2F0ZSB3aWxsIGJlXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXG50aGUgZHJhZyBzaG91bGQgbW92ZSB0aGUgY29udGVudC5cbiovXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW5nIGNsaWNrIGFkZHMgYVxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxuZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjaGVjayBgZXZlbnQubWV0YUtleWAgb24gbWFjT1MsIGFuZFxuYGV2ZW50LmN0cmxLZXlgIGVsc2V3aGVyZS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIERlY29yYXRpb25zIGNhbiBiZSBwcm92aWRlZCBpbiB0d29cbndheXPigJRkaXJlY3RseSwgb3IgdmlhIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlZGl0b3Igdmlldy5cblxuT25seSBkZWNvcmF0aW9uIHNldHMgcHJvdmlkZWQgZGlyZWN0bHkgYXJlIGFsbG93ZWQgdG8gaW5mbHVlbmNlXG50aGUgZWRpdG9yJ3MgdmVydGljYWwgbGF5b3V0IHN0cnVjdHVyZS4gVGhlIG9uZXMgcHJvdmlkZWQgYXNcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcbmFuZCB0aHVzICoqbXVzdCBub3QqKiBpbnRyb2R1Y2UgYmxvY2sgd2lkZ2V0cyBvciByZXBsYWNpbmdcbmRlY29yYXRpb25zIHRoYXQgY292ZXIgbGluZSBicmVha3MuXG5cbklmIHlvdSB3YW50IGRlY29yYXRlZCByYW5nZXMgdG8gYmVoYXZlIGxpa2UgYXRvbWljIHVuaXRzIGZvclxuY3Vyc29yIG1vdGlvbiBhbmQgZGVsZXRpb24gcHVycG9zZXMsIGFsc28gcHJvdmlkZSB0aGUgcmFuZ2Ugc2V0XG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xuW2BFZGl0b3JWaWV3LmF0b21pY1Jhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmF0b21pY1JhbmdlcykuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5Vc2VkIHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXRvbXMgYXMgZmFyIGFzXG5jdXJzb3IgbW90aW9uIGlzIGNvbmNlcm5lZC4gVGhpcyBjYXVzZXMgbWV0aG9kcyBsaWtlXG5bYG1vdmVCeUNoYXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlDaGFyKSBhbmRcbltgbW92ZVZlcnRpY2FsbHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgKGFuZCB0aGVcbmNvbW1hbmRzIGJ1aWx0IG9uIHRvcCBvZiB0aGVtKSB0byBza2lwIGFjcm9zcyBzdWNoIHJlZ2lvbnMgd2hlblxuYSBzZWxlY3Rpb24gZW5kcG9pbnQgd291bGQgZW50ZXIgdGhlbS4gVGhpcyBkb2VzIF9ub3RfIHByZXZlbnRcbmRpcmVjdCBwcm9ncmFtbWF0aWMgW3NlbGVjdGlvblxudXBkYXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBmcm9tIG1vdmluZyBpbnRvIHN1Y2hcbnJlZ2lvbnMuXG4qL1xuRWRpdG9yVmlldy5hdG9taWNSYW5nZXMgPSBhdG9taWNSYW5nZXM7XG4vKipcbkZhY2V0IHRoYXQgYWxsb3dzIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbFxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxuc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52aXNpYmxlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMgPSBzY3JvbGxNYXJnaW5zO1xuLyoqXG5UaGlzIGZhY2V0IHJlY29yZHMgd2hldGhlciBhIGRhcmsgdGhlbWUgaXMgYWN0aXZlLiBUaGUgZXh0ZW5zaW9uXG5yZXR1cm5lZCBieSBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIGF1dG9tYXRpY2FsbHlcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cbnRydWUuXG4qL1xuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLy8gTWF4aW11bSBsaW5lIGxlbmd0aCBmb3Igd2hpY2ggd2UgY29tcHV0ZSBhY2N1cmF0ZSBiaWRpIGluZm9cbmNvbnN0IE1heEJpZGlMaW5lID0gNDA5NjtcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcbmNsYXNzIENhY2hlZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlyLCBvcmRlcikge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGUoY2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgbGFzdERpciA9IGNhY2hlLmxlbmd0aCA/IGNhY2hlW2NhY2hlLmxlbmd0aCAtIDFdLmRpciA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLm1heCgwLCBjYWNoZS5sZW5ndGggLSAxMCk7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2FjaGVbaV07XG4gICAgICAgICAgICBpZiAoZW50cnkuZGlyID09IGxhc3REaXIgJiYgIWNoYW5nZXMudG91Y2hlc1JhbmdlKGVudHJ5LmZyb20sIGVudHJ5LnRvKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FjaGVkT3JkZXIoY2hhbmdlcy5tYXBQb3MoZW50cnkuZnJvbSwgMSksIGNoYW5nZXMubWFwUG9zKGVudHJ5LnRvLCAtMSksIGVudHJ5LmRpciwgZW50cnkub3JkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJzRnJvbUZhY2V0KHZpZXcsIGZhY2V0LCBiYXNlKSB7XG4gICAgZm9yIChsZXQgc291cmNlcyA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpLCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgc291cmNlID0gc291cmNlc1tpXSwgdmFsdWUgPSB0eXBlb2Ygc291cmNlID09IFwiZnVuY3Rpb25cIiA/IHNvdXJjZSh2aWV3KSA6IHNvdXJjZTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgY29tYmluZUF0dHJzKHZhbHVlLCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG59XG5cbmNvbnN0IGN1cnJlbnRQbGF0Zm9ybSA9IGJyb3dzZXIubWFjID8gXCJtYWNcIiA6IGJyb3dzZXIud2luZG93cyA/IFwid2luXCIgOiBicm93c2VyLmxpbnV4ID8gXCJsaW51eFwiIDogXCJrZXlcIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSwgcGxhdGZvcm0pIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xuICAgIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgbW9kID0gcGFydHNbaV07XG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm0gPT0gXCJtYWNcIilcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIG5hbWUgPSBcIk1ldGEtXCIgKyBuYW1lO1xuICAgIGlmIChzaGlmdCAhPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmNvbnN0IGhhbmRsZUtleUV2ZW50cyA9IC8qQF9fUFVSRV9fKi9QcmVjLmRlZmF1bHQoLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAga2V5ZG93bihldmVudCwgdmlldykge1xuICAgICAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgXCJlZGl0b3JcIik7XG4gICAgfVxufSkpO1xuLyoqXG5GYWNldCB1c2VkIGZvciByZWdpc3RlcmluZyBrZXltYXBzLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXBzIHRvIGFuIGVkaXRvci4gVGhlaXIgcHJpb3JpdGllc1xuZGV0ZXJtaW5lIHRoZWlyIHByZWNlZGVuY2UgKHRoZSBvbmVzIHNwZWNpZmllZCBlYXJseSBvciB3aXRoIGhpZ2hcbnByaW9yaXR5IGdldCBjaGVja2VkIGZpcnN0KS4gV2hlbiBhIGhhbmRsZXIgaGFzIHJldHVybmVkIGB0cnVlYFxuZm9yIGEgZ2l2ZW4ga2V5LCBubyBmdXJ0aGVyIGhhbmRsZXJzIGFyZSBjYWxsZWQuXG4qL1xuY29uc3Qga2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGVuYWJsZXM6IGhhbmRsZUtleUV2ZW50cyB9KTtcbmNvbnN0IEtleW1hcHMgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFRoaXMgaXMgaGlkZGVuIGJlaGluZCBhbiBpbmRpcmVjdGlvbiwgcmF0aGVyIHRoYW4gZGlyZWN0bHkgY29tcHV0ZWRcbi8vIGJ5IHRoZSBmYWNldCwgdG8ga2VlcCBpbnRlcm5hbCB0eXBlcyBvdXQgb2YgdGhlIGZhY2V0J3MgdHlwZS5cbmZ1bmN0aW9uIGdldEtleW1hcChzdGF0ZSkge1xuICAgIGxldCBiaW5kaW5ncyA9IHN0YXRlLmZhY2V0KGtleW1hcCk7XG4gICAgbGV0IG1hcCA9IEtleW1hcHMuZ2V0KGJpbmRpbmdzKTtcbiAgICBpZiAoIW1hcClcbiAgICAgICAgS2V5bWFwcy5zZXQoYmluZGluZ3MsIG1hcCA9IGJ1aWxkS2V5bWFwKGJpbmRpbmdzLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKSkpO1xuICAgIHJldHVybiBtYXA7XG59XG4vKipcblJ1biB0aGUga2V5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gc2NvcGUuIFRoZSBldmVudFxub2JqZWN0IHNob3VsZCBiZSBhIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXG5oYW5kbGVycyBoYW5kbGVkIGl0LlxuKi9cbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIHNjb3BlKTtcbn1cbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xuY29uc3QgUHJlZml4VGltZW91dCA9IDQwMDA7XG5mdW5jdGlvbiBidWlsZEtleW1hcChiaW5kaW5ncywgcGxhdGZvcm0gPSBjdXJyZW50UGxhdGZvcm0pIHtcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBpc1ByZWZpeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoZWNrUHJlZml4ID0gKG5hbWUsIGlzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXG4gICAgICAgICAgICBpc1ByZWZpeFtuYW1lXSA9IGlzO1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBuYW1lICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gICAgfTtcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBydW46IFsodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXJPYmogPSBzdG9yZWRQcmVmaXggPSB7IHZpZXcsIHByZWZpeCwgc2NvcGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7IH0sIFByZWZpeFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XG4gICAgICAgIGNoZWNrUHJlZml4KGZ1bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBzY29wZU9ialtmdWxsXSB8fCAoc2NvcGVPYmpbZnVsbF0gPSB7IHByZXZlbnREZWZhdWx0OiBmYWxzZSwgcnVuOiAoKF9iID0gKF9hID0gc2NvcGVPYmouX2FueSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKCkpIHx8IFtdIH0pO1xuICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgIGJpbmRpbmcucnVuLnB1c2goY29tbWFuZCk7XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIH07XG4gICAgZm9yIChsZXQgYiBvZiBiaW5kaW5ncykge1xuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xuICAgICAgICBpZiAoYi5hbnkpXG4gICAgICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVPYmouX2FueSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmouX2FueSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBydW46IFtdIH07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKGIuYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgYWRkKHNjb3BlLCBuYW1lLCBiLnJ1biwgYi5wcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgICAgICBpZiAoYi5zaGlmdClcbiAgICAgICAgICAgICAgICBhZGQoc2NvcGUsIFwiU2hpZnQtXCIgKyBuYW1lLCBiLnNoaWZ0LCBiLnByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmQ7XG59XG5mdW5jdGlvbiBydW5IYW5kbGVycyhtYXAsIGV2ZW50LCB2aWV3LCBzY29wZSkge1xuICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCk7XG4gICAgbGV0IGNoYXJDb2RlID0gY29kZVBvaW50QXQobmFtZSwgMCksIGlzQ2hhciA9IGNvZGVQb2ludFNpemUoY2hhckNvZGUpID09IG5hbWUubGVuZ3RoICYmIG5hbWUgIT0gXCIgXCI7XG4gICAgbGV0IHByZWZpeCA9IFwiXCIsIGZhbGx0aHJvdWdoID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChmYWxsdGhyb3VnaCA9IG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsO1xuICAgIH1cbiAgICBsZXQgcmFuID0gbmV3IFNldDtcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLnJ1bilcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xuICAgICAgICAgICAgICAgICAgICByYW4uYWRkKGNtZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQodmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICAgICAgZmFsbHRocm91Z2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGxldCBzY29wZU9iaiA9IG1hcFtzY29wZV0sIGJhc2VOYW1lLCBzaGlmdE5hbWU7XG4gICAgaWYgKHNjb3BlT2JqKSB7XG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCAhaXNDaGFyKV0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpc0NoYXIgJiYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICYmXG4gICAgICAgICAgICAvLyBDdHJsLUFsdCBtYXkgYmUgdXNlZCBmb3IgQWx0R3Igb24gV2luZG93c1xuICAgICAgICAgICAgIShicm93c2VyLndpbmRvd3MgJiYgZXZlbnQuY3RybEtleSAmJiBldmVudC5hbHRLZXkpICYmXG4gICAgICAgICAgICAoYmFzZU5hbWUgPSBiYXNlW2V2ZW50LmtleUNvZGVdKSAmJiBiYXNlTmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQsIHRydWUpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoc2hpZnROYW1lID0gc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCB0cnVlKV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmouX2FueSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGx0aHJvdWdoO1xufVxuXG4vKipcbkltcGxlbWVudGF0aW9uIG9mIFtgTGF5ZXJNYXJrZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTGF5ZXJNYXJrZXIpIHRoYXQgY3JlYXRlc1xuYSByZWN0YW5nbGUgYXQgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMuXG4qL1xuY2xhc3MgUmVjdGFuZ2xlTWFya2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrZXIgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGRpbWVuc2lvbnMuIElmIGB3aWR0aGBcbiAgICBpcyBudWxsLCB0aGUgRE9NIGVsZW1lbnQgd2lsbCBnZXQgbm8gd2lkdGggc3R5bGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIHVwZGF0ZShlbHQsIHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYuY2xhc3NOYW1lICE9IHRoaXMuY2xhc3NOYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWRqdXN0KGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHRoaXMubGVmdCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLnRvcCA9IHRoaXMudG9wICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy53aWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgICBlcShwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQgPT0gcC5sZWZ0ICYmIHRoaXMudG9wID09IHAudG9wICYmIHRoaXMud2lkdGggPT0gcC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PSBwLmhlaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPT0gcC5jbGFzc05hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiByZWN0YW5nbGVzIGZvciB0aGUgZ2l2ZW4gc2VsZWN0aW9uIHJhbmdlLFxuICAgIGFzc2lnbmluZyB0aGVtIHRoZWNsYXNzYGNsYXNzTmFtZWAuIFdpbGwgY3JlYXRlIGEgc2luZ2xlXG4gICAgcmVjdGFuZ2xlIGZvciBlbXB0eSByYW5nZXMsIGFuZCBhIHNldCBvZiBzZWxlY3Rpb24tc3R5bGVcbiAgICByZWN0YW5nbGVzIGNvdmVyaW5nIHRoZSByYW5nZSdzIGNvbnRlbnQgKGluIGEgYmlkaS1hd2FyZVxuICAgIHdheSkgZm9yIG5vbi1lbXB0eSBvbmVzLlxuICAgICovXG4gICAgc3RhdGljIGZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gdmlldy5jb29yZHNBdFBvcyhyYW5nZS5oZWFkLCByYW5nZS5hc3NvYyB8fCAxKTtcbiAgICAgICAgICAgIGlmICghcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gZ2V0QmFzZSh2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIHBvcy5sZWZ0IC0gYmFzZS5sZWZ0LCBwb3MudG9wIC0gYmFzZS50b3AsIG51bGwsIHBvcy5ib3R0b20gLSBwb3MudG9wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlc0ZvclJhbmdlKHZpZXcsIGNsYXNzTmFtZSwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QmFzZSh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbGVmdCA9IHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0LCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wIH07XG59XG5mdW5jdGlvbiB3cmFwcGVkTGluZSh2aWV3LCBwb3MsIGluc2lkZSkge1xuICAgIGxldCByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICByZXR1cm4geyBmcm9tOiBNYXRoLm1heChpbnNpZGUuZnJvbSwgdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZhbHNlLCB0cnVlKS5mcm9tKSxcbiAgICAgICAgdG86IE1hdGgubWluKGluc2lkZS50bywgdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIHRydWUsIHRydWUpLmZyb20pLFxuICAgICAgICB0eXBlOiBCbG9ja1R5cGUuVGV4dCB9O1xufVxuZnVuY3Rpb24gYmxvY2tBdCh2aWV3LCBwb3MpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKVxuICAgICAgICBmb3IgKGxldCBsIG9mIGxpbmUudHlwZSkge1xuICAgICAgICAgICAgaWYgKGwudG8gPiBwb3MgfHwgbC50byA9PSBwb3MgJiYgKGwudG8gPT0gbGluZS50byB8fCBsLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00sIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgbGV0IGxpbmVTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgbGV0IGxlZnRTaWRlID0gY29udGVudFJlY3QubGVmdCArIHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpO1xuICAgIGxldCByaWdodFNpZGUgPSBjb250ZW50UmVjdC5yaWdodCAtIHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgIGxldCBzdGFydEJsb2NrID0gYmxvY2tBdCh2aWV3LCBmcm9tKSwgZW5kQmxvY2sgPSBibG9ja0F0KHZpZXcsIHRvKTtcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSBzdGFydEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBzdGFydEJsb2NrIDogbnVsbDtcbiAgICBsZXQgdmlzdWFsRW5kID0gZW5kQmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGVuZEJsb2NrIDogbnVsbDtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgaWYgKHZpc3VhbFN0YXJ0KVxuICAgICAgICAgICAgdmlzdWFsU3RhcnQgPSB3cmFwcGVkTGluZSh2aWV3LCBmcm9tLCB2aXN1YWxTdGFydCk7XG4gICAgICAgIGlmICh2aXN1YWxFbmQpXG4gICAgICAgICAgICB2aXN1YWxFbmQgPSB3cmFwcGVkTGluZSh2aWV3LCB0bywgdmlzdWFsRW5kKTtcbiAgICB9XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCAmJiB2aXN1YWxTdGFydC5mcm9tID09IHZpc3VhbEVuZC5mcm9tKSB7XG4gICAgICAgIHJldHVybiBwaWVjZXMoZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHZpc3VhbFN0YXJ0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdG9wID0gdmlzdWFsU3RhcnQgPyBkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCBudWxsLCB2aXN1YWxTdGFydCkgOiBkcmF3Rm9yV2lkZ2V0KHN0YXJ0QmxvY2ssIGZhbHNlKTtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHZpc3VhbEVuZCA/IGRyYXdGb3JMaW5lKG51bGwsIHJhbmdlLnRvLCB2aXN1YWxFbmQpIDogZHJhd0ZvcldpZGdldChlbmRCbG9jaywgdHJ1ZSk7XG4gICAgICAgIGxldCBiZXR3ZWVuID0gW107XG4gICAgICAgIGlmICgodmlzdWFsU3RhcnQgfHwgc3RhcnRCbG9jaykudG8gPCAodmlzdWFsRW5kIHx8IGVuZEJsb2NrKS5mcm9tIC0gMSlcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIHZpZXcuZWxlbWVudEF0SGVpZ2h0KCh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyKS50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCAtIDAuMDEgLyogQy5FcHNpbG9uICovLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCArIDAuMDEgLyogQy5FcHNpbG9uICovKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4oZnJvbUNvb3Jkcy50b3AsIHRvQ29vcmRzLnRvcCwgdG9wKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGZyb21Db29yZHMuYm90dG9tLCB0b0Nvb3Jkcy5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICBpZiAoZGlyID09IERpcmVjdGlvbi5MVFIpXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKGx0ciAmJiBmcm9tT3BlbiA/IGxlZnRTaWRlIDogZnJvbUNvb3Jkcy5sZWZ0LCBsdHIgJiYgdG9PcGVuID8gcmlnaHRTaWRlIDogdG9Db29yZHMucmlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaCghbHRyICYmIHRvT3BlbiA/IGxlZnRTaWRlIDogdG9Db29yZHMubGVmdCwgIWx0ciAmJiBmcm9tT3BlbiA/IHJpZ2h0U2lkZSA6IGZyb21Db29yZHMucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IGxpbmUuZnJvbSwgZW5kID0gdG8gIT09IG51bGwgJiYgdG8gIT09IHZvaWQgMCA/IHRvIDogbGluZS50bztcbiAgICAgICAgLy8gU3BsaXQgdGhlIHJhbmdlIGJ5IHZpc2libGUgcmFuZ2UgYW5kIGRvY3VtZW50IGxpbmVcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpXG4gICAgICAgICAgICBpZiAoci50byA+IHN0YXJ0ICYmIHIuZnJvbSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KHIuZnJvbSwgc3RhcnQpLCBlbmRQb3MgPSBNYXRoLm1pbihyLnRvLCBlbmQpOzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvY0xpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3BhbiBvZiB2aWV3LmJpZGlTcGFucyhkb2NMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYW5Gcm9tID0gc3Bhbi5mcm9tICsgZG9jTGluZS5mcm9tLCBzcGFuVG8gPSBzcGFuLnRvICsgZG9jTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5Gcm9tID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuVG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3BhbihNYXRoLm1heChzcGFuRnJvbSwgcG9zKSwgZnJvbSA9PSBudWxsICYmIHNwYW5Gcm9tIDw9IHN0YXJ0LCBNYXRoLm1pbihzcGFuVG8sIGVuZFBvcyksIHRvID09IG51bGwgJiYgc3BhblRvID49IGVuZCwgc3Bhbi5kaXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGRvY0xpbmUudG8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGhvcml6b250YWwubGVuZ3RoID09IDApXG4gICAgICAgICAgICBhZGRTcGFuKHN0YXJ0LCBmcm9tID09IG51bGwsIGVuZCwgdG8gPT0gbnVsbCwgdmlldy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd0ZvcldpZGdldChibG9jaywgdG9wKSB7XG4gICAgICAgIGxldCB5ID0gY29udGVudFJlY3QudG9wICsgKHRvcCA/IGJsb2NrLnRvcCA6IGJsb2NrLmJvdHRvbSk7XG4gICAgICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBob3Jpem9udGFsOiBbXSB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXIoYSwgYikge1xuICAgIHJldHVybiBhLmNvbnN0cnVjdG9yID09IGIuY29uc3RydWN0b3IgJiYgYS5lcShiKTtcbn1cbmNsYXNzIExheWVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgbGF5ZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLmRyYXduID0gW107XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5tZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXcuYmluZCh0aGlzKSB9O1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXJcIik7XG4gICAgICAgIGlmIChsYXllci5hYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllci1hYm92ZVwiKTtcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChsYXllci5jbGFzcyk7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5zZXRPcmRlcih2aWV3LnN0YXRlKTtcbiAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICBpZiAobGF5ZXIubW91bnQpXG4gICAgICAgICAgICBsYXllci5tb3VudCh0aGlzLmRvbSwgdmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxheWVyT3JkZXIpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYXllck9yZGVyKSlcbiAgICAgICAgICAgIHRoaXMuc2V0T3JkZXIodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIudXBkYXRlKHVwZGF0ZSwgdGhpcy5kb20pIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgIH1cbiAgICBzZXRPcmRlcihzdGF0ZSkge1xuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG9yZGVyLmxlbmd0aCAmJiBvcmRlcltwb3NdICE9IHRoaXMubGF5ZXIpXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xuICAgIH1cbiAgICBkcmF3KG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoICE9IHRoaXMuZHJhd24ubGVuZ3RoIHx8IG1hcmtlcnMuc29tZSgocCwgaSkgPT4gIXNhbWVNYXJrZXIocCwgdGhpcy5kcmF3bltpXSkpKSB7XG4gICAgICAgICAgICBsZXQgb2xkID0gdGhpcy5kb20uZmlyc3RDaGlsZCwgb2xkSSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBtYXJrZXIgb2YgbWFya2Vycykge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIudXBkYXRlICYmIG9sZCAmJiBtYXJrZXIuY29uc3RydWN0b3IgJiYgdGhpcy5kcmF3bltvbGRJXS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIudXBkYXRlKG9sZCwgdGhpcy5kcmF3bltvbGRJXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkID0gb2xkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBvbGRJKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobWFya2VyLmRyYXcoKSwgb2xkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAob2xkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgb2xkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIG9sZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYXduID0gbWFya2VycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5sYXllci5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5sYXllci5kZXN0cm95KHRoaXMuZG9tLCB0aGlzLnZpZXcpO1xuICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICB9XG59XG5jb25zdCBsYXllck9yZGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYSBsYXllci5cbiovXG5mdW5jdGlvbiBsYXllcihjb25maWcpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBWaWV3UGx1Z2luLmRlZmluZSh2ID0+IG5ldyBMYXllclZpZXcodiwgY29uZmlnKSksXG4gICAgICAgIGxheWVyT3JkZXIub2YoY29uZmlnKVxuICAgIF07XG59XG5cbmNvbnN0IENhbkhpZGVQcmltYXJ5ID0gIWJyb3dzZXIuaW9zOyAvLyBGSVhNRSB0ZXN0IElFXG5jb25zdCBzZWxlY3Rpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAxMjAwLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogKGEsIGIpID0+IE1hdGgubWluKGEsIGIpLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZGVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNlbGVjdGlvbiBhbmRcbmN1cnNvciwgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGJhY2tncm91bmQgYmVoaW5kIHRoZSB0ZXh0XG4od2l0aCB0aGUgYGNtLXNlbGVjdGlvbkJhY2tncm91bmRgIGNsYXNzKSwgYW5kIHRoZVxuY3Vyc29ycyB3aXRoIGVsZW1lbnRzIG92ZXJsYWlkIG92ZXIgdGhlIGNvZGUgKHVzaW5nXG5gY20tY3Vyc29yLXByaW1hcnlgIGFuZCBgY20tY3Vyc29yLXNlY29uZGFyeWApLlxuXG5UaGlzIGFsbG93cyB0aGUgZWRpdG9yIHRvIGRpc3BsYXkgc2Vjb25kYXJ5IHNlbGVjdGlvbiByYW5nZXMsIGFuZFxudGVuZHMgdG8gcHJvZHVjZSBhIHR5cGUgb2Ygc2VsZWN0aW9uIG1vcmUgaW4gbGluZSB3aXRoIHRoYXQgdXNlcnNcbmV4cGVjdCBpbiBhIHRleHQgZWRpdG9yICh0aGUgbmF0aXZlIHNlbGVjdGlvbiBzdHlsaW5nIHdpbGwgb2Z0ZW5cbmxlYXZlIGdhcHMgYmV0d2VlbiBsaW5lcyBhbmQgd29uJ3QgZmlsbCB0aGUgaG9yaXpvbnRhbCBzcGFjZSBhZnRlclxuYSBsaW5lIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250aW51ZXMgcGFzdCBpdCkuXG5cbkl0IGRvZXMgaGF2ZSBhIHBlcmZvcm1hbmNlIGNvc3QsIGluIHRoYXQgaXQgcmVxdWlyZXMgYW4gZXh0cmEgRE9NXG5sYXlvdXQgY3ljbGUgZm9yIG1hbnkgdXBkYXRlcyAodGhlIHNlbGVjdGlvbiBpcyBkcmF3biBiYXNlZCBvbiBET01cbmxheW91dCBpbmZvcm1hdGlvbiB0aGF0J3Mgb25seSBhdmFpbGFibGUgYWZ0ZXIgbGF5aW5nIG91dCB0aGVcbmNvbnRlbnQpLlxuKi9cbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZWxlY3Rpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY3Vyc29yTGF5ZXIsXG4gICAgICAgIHNlbGVjdGlvbkxheWVyLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxuICAgICAgICBuYXRpdmVTZWxlY3Rpb25IaWRkZW4ub2YodHJ1ZSlcbiAgICBdO1xufVxuZnVuY3Rpb24gY29uZmlnQ2hhbmdlZCh1cGRhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmNvbnN0IGN1cnNvckxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogdHJ1ZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxufSk7XG5jb25zdCB0aGVtZVNwZWMgPSB7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgXCImOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH1cbiAgICB9XG59O1xuaWYgKENhbkhpZGVQcmltYXJ5KVxuICAgIHRoZW1lU3BlY1tcIi5jbS1saW5lXCJdLmNhcmV0Q29sb3IgPSBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIjtcbmNvbnN0IGhpZGVOYXRpdmVTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHRoZW1lU3BlYykpO1xuXG5jb25zdCBzZXREcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHBvcywgbWFwcGluZykgeyByZXR1cm4gcG9zID09IG51bGwgPyBudWxsIDogbWFwcGluZy5tYXBQb3MocG9zKTsgfVxufSk7XG5jb25zdCBkcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZShwb3MsIHRyKSB7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHBvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHBvcyk7XG4gICAgICAgIHJldHVybiB0ci5lZmZlY3RzLnJlZHVjZSgocG9zLCBlKSA9PiBlLmlzKHNldERyb3BDdXJzb3JQb3MpID8gZS52YWx1ZSA6IHBvcywgcG9zKTtcbiAgICB9XG59KTtcbmNvbnN0IGRyYXdEcm9wQ3Vyc29yID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRQb3MuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhd0N1cnNvci5iaW5kKHRoaXMpIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY3Vyc29yUG9zID0gdXBkYXRlLnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpO1xuICAgICAgICBpZiAoY3Vyc29yUG9zID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jdXJzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLnZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLmNsYXNzTmFtZSA9IFwiY20tZHJvcEN1cnNvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpICE9IGN1cnNvclBvcyB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRQb3MoKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGxldCByZWN0ID0gcG9zICE9IG51bGwgJiYgdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHBvcyk7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgb3V0ZXIgPSB0aGlzLnZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gb3V0ZXIubGVmdCArIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgLSBvdXRlci50b3AgKyB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICAgICAgICB9O1xuICAgIH1cbiAgICBkcmF3Q3Vyc29yKHBvcykge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5oZWlnaHQgPSBwb3MuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IFwiLTEwMDAwMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIHNldERyb3BQb3MocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gcG9zKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RHJvcEN1cnNvclBvcy5vZihwb3MpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3ModGhpcy52aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PSB0aGlzLnZpZXcuY29udGVudERPTSB8fCAhdGhpcy52aWV3LmNvbnRlbnRET00uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnZW5kKCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBkcm9wKCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcbkRyYXdzIGEgY3Vyc29yIGF0IHRoZSBjdXJyZW50IGRyb3AgcG9zaXRpb24gd2hlbiBzb21ldGhpbmcgaXNcbmRyYWdnZWQgb3ZlciB0aGUgZWRpdG9yLlxuKi9cbmZ1bmN0aW9uIGRyb3BDdXJzb3IoKSB7XG4gICAgcmV0dXJuIFtkcm9wQ3Vyc29yUG9zLCBkcmF3RHJvcEN1cnNvcl07XG59XG5cbmZ1bmN0aW9uIGl0ZXJNYXRjaGVzKGRvYywgcmUsIGZyb20sIHRvLCBmKSB7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjdXJzb3IgPSBkb2MuaXRlclJhbmdlKGZyb20sIHRvKSwgcG9zID0gZnJvbSwgbTsgIWN1cnNvci5uZXh0KCkuZG9uZTsgcG9zICs9IGN1cnNvci52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFjdXJzb3IubGluZUJyZWFrKVxuICAgICAgICAgICAgd2hpbGUgKG0gPSByZS5leGVjKGN1cnNvci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgZihwb3MgKyBtLmluZGV4LCBtKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaFJhbmdlcyh2aWV3LCBtYXhMZW5ndGgpIHtcbiAgICBsZXQgdmlzaWJsZSA9IHZpZXcudmlzaWJsZVJhbmdlcztcbiAgICBpZiAodmlzaWJsZS5sZW5ndGggPT0gMSAmJiB2aXNpYmxlWzBdLmZyb20gPT0gdmlldy52aWV3cG9ydC5mcm9tICYmXG4gICAgICAgIHZpc2libGVbMF0udG8gPT0gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aXNpYmxlKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heCh2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSkuZnJvbSwgZnJvbSAtIG1heExlbmd0aCk7XG4gICAgICAgIHRvID0gTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bywgdG8gKyBtYXhMZW5ndGgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnRvID49IGZyb20pXG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnRvID0gdG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkhlbHBlciBjbGFzcyB1c2VkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIG1haW50YWluIGRlY29yYXRpb25zIG9uXG52aXNpYmxlIGNvZGUgdGhhdCBtYXRjaGVzIGEgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uLiBUbyBiZSB1c2VkXG5pbiBhIFt2aWV3IHBsdWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pLiBJbnN0YW5jZXMgb2YgdGhpcyBvYmplY3RcbnJlcHJlc2VudCBhIG1hdGNoaW5nIGNvbmZpZ3VyYXRpb24uXG4qL1xuY2xhc3MgTWF0Y2hEZWNvcmF0b3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGRlY29yYXRvci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBjb25zdCB7IHJlZ2V4cCwgZGVjb3JhdGlvbiwgZGVjb3JhdGUsIGJvdW5kYXJ5LCBtYXhMZW5ndGggPSAxMDAwIH0gPSBjb25maWc7XG4gICAgICAgIGlmICghcmVnZXhwLmdsb2JhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnaXZlbiB0byBNYXRjaERlY29yYXRvciBzaG91bGQgaGF2ZSBpdHMgJ2cnIGZsYWcgc2V0XCIpO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9IHJlZ2V4cDtcbiAgICAgICAgaWYgKGRlY29yYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IGRlY29yYXRlKGFkZCwgZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgbWF0Y2gsIHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWNvcmF0aW9uID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRlY28gPSBkZWNvcmF0aW9uKG1hdGNoLCB2aWV3LCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjbylcbiAgICAgICAgICAgICAgICAgICAgYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY28pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCBfdmlldywgZnJvbSwgYWRkKSA9PiBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjb3JhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVpdGhlciAnZGVjb3JhdGUnIG9yICdkZWNvcmF0aW9uJyBzaG91bGQgYmUgcHJvdmlkZWQgdG8gTWF0Y2hEZWNvcmF0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuICAgICAgICB0aGlzLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgZnVsbCBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIG1hdGNoZXMgaW4gdGhlIGdpdmVuXG4gICAgdmlldydzIHZpZXdwb3J0LiBZb3UnbGwgd2FudCB0byBjYWxsIHRoaXMgd2hlbiBpbml0aWFsaXppbmcgeW91clxuICAgIHBsdWdpbi5cbiAgICAqL1xuICAgIGNyZWF0ZURlY28odmlldykge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCksIGFkZCA9IGJ1aWxkLmFkZC5iaW5kKGJ1aWxkKTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1hdGNoUmFuZ2VzKHZpZXcsIHRoaXMubWF4TGVuZ3RoKSlcbiAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgZnJvbSwgdG8sIChmcm9tLCBtKSA9PiB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIGZyb20sIGFkZCkpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgYSB2aWV3IHVwZGF0ZS4gYGRlY29gIF9tdXN0XyBiZVxuICAgIHRoZSBzZXQgb2YgZGVjb3JhdGlvbnMgcHJvZHVjZWQgYnkgX3RoaXNfIGBNYXRjaERlY29yYXRvcmAgZm9yXG4gICAgdGhlIHZpZXcgc3RhdGUgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgKi9cbiAgICB1cGRhdGVEZWNvKHVwZGF0ZSwgZGVjbykge1xuICAgICAgICBsZXQgY2hhbmdlRnJvbSA9IDFlOSwgY2hhbmdlVG8gPSAtMTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKF9mLCBfdCwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiB1cGRhdGUudmlldy52aWV3cG9ydC5mcm9tICYmIGZyb20gPCB1cGRhdGUudmlldy52aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VGcm9tID0gTWF0aC5taW4oZnJvbSwgY2hhbmdlRnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZVRvID0gTWF0aC5tYXgodG8sIGNoYW5nZVRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY2hhbmdlVG8gLSBjaGFuZ2VGcm9tID4gMTAwMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICBpZiAoY2hhbmdlVG8gPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVJhbmdlKHVwZGF0ZS52aWV3LCBkZWNvLm1hcCh1cGRhdGUuY2hhbmdlcyksIGNoYW5nZUZyb20sIGNoYW5nZVRvKTtcbiAgICAgICAgcmV0dXJuIGRlY287XG4gICAgfVxuICAgIHVwZGF0ZVJhbmdlKHZpZXcsIGRlY28sIHVwZGF0ZUZyb20sIHVwZGF0ZVRvKSB7XG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KHIuZnJvbSwgdXBkYXRlRnJvbSksIHRvID0gTWF0aC5taW4oci50bywgdXBkYXRlVG8pO1xuICAgICAgICAgICAgaWYgKHRvID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKSwgdG9MaW5lID0gZnJvbUxpbmUudG8gPCB0byA/IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykgOiBmcm9tTGluZTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChyLmZyb20sIGZyb21MaW5lLmZyb20pLCBlbmQgPSBNYXRoLm1pbihyLnRvLCB0b0xpbmUudG8pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBmcm9tID4gZnJvbUxpbmUuZnJvbTsgZnJvbS0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdChmcm9tTGluZS50ZXh0W2Zyb20gLSAxIC0gZnJvbUxpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBmcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdG8gPCB0b0xpbmUudG87IHRvKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KHRvTGluZS50ZXh0W3RvIC0gdG9MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gW10sIG07XG4gICAgICAgICAgICAgICAgbGV0IGFkZCA9IChmcm9tLCB0bywgZGVjbykgPT4gcmFuZ2VzLnB1c2goZGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tTGluZSA9PSB0b0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gc3RhcnQgLSBmcm9tTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG0gPSB0aGlzLnJlZ2V4cC5leGVjKGZyb21MaW5lLnRleHQpKSAmJiBtLmluZGV4IDwgZW5kIC0gZnJvbUxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2gobSwgdmlldywgbS5pbmRleCArIGZyb21MaW5lLmZyb20sIGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIHN0YXJ0LCBlbmQsIChmcm9tLCBtKSA9PiB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIGZyb20sIGFkZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvID0gZGVjby51cGRhdGUoeyBmaWx0ZXJGcm9tOiBzdGFydCwgZmlsdGVyVG86IGVuZCwgZmlsdGVyOiAoZnJvbSwgdG8pID0+IGZyb20gPCBzdGFydCB8fCB0byA+IGVuZCwgYWRkOiByYW5nZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY287XG4gICAgfVxufVxuXG5jb25zdCBVbmljb2RlUmVnZXhwU3VwcG9ydCA9IC94Ly51bmljb2RlICE9IG51bGwgPyBcImd1XCIgOiBcImdcIjtcbmNvbnN0IFNwZWNpYWxzID0gLypAX19QVVJFX18qL25ldyBSZWdFeHAoXCJbXFx1MDAwMC1cXHUwMDA4XFx1MDAwYS1cXHUwMDFmXFx1MDA3Zi1cXHUwMDlmXFx1MDBhZFxcdTA2MWNcXHUyMDBiXFx1MjAwZVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdTIwMmRcXHUyMDJlXFx1MjA2NlxcdTIwNjdcXHUyMDY5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY11cIiwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xuY29uc3QgTmFtZXMgPSB7XG4gICAgMDogXCJudWxsXCIsXG4gICAgNzogXCJiZWxsXCIsXG4gICAgODogXCJiYWNrc3BhY2VcIixcbiAgICAxMDogXCJuZXdsaW5lXCIsXG4gICAgMTE6IFwidmVydGljYWwgdGFiXCIsXG4gICAgMTM6IFwiY2FycmlhZ2UgcmV0dXJuXCIsXG4gICAgMjc6IFwiZXNjYXBlXCIsXG4gICAgODIwMzogXCJ6ZXJvIHdpZHRoIHNwYWNlXCIsXG4gICAgODIwNDogXCJ6ZXJvIHdpZHRoIG5vbi1qb2luZXJcIixcbiAgICA4MjA1OiBcInplcm8gd2lkdGggam9pbmVyXCIsXG4gICAgODIwNjogXCJsZWZ0LXRvLXJpZ2h0IG1hcmtcIixcbiAgICA4MjA3OiBcInJpZ2h0LXRvLWxlZnQgbWFya1wiLFxuICAgIDgyMzI6IFwibGluZSBzZXBhcmF0b3JcIixcbiAgICA4MjM3OiBcImxlZnQtdG8tcmlnaHQgb3ZlcnJpZGVcIixcbiAgICA4MjM4OiBcInJpZ2h0LXRvLWxlZnQgb3ZlcnJpZGVcIixcbiAgICA4Mjk0OiBcImxlZnQtdG8tcmlnaHQgaXNvbGF0ZVwiLFxuICAgIDgyOTU6IFwicmlnaHQtdG8tbGVmdCBpc29sYXRlXCIsXG4gICAgODI5NzogXCJwb3AgZGlyZWN0aW9uYWwgaXNvbGF0ZVwiLFxuICAgIDgyMzM6IFwicGFyYWdyYXBoIHNlcGFyYXRvclwiLFxuICAgIDY1Mjc5OiBcInplcm8gd2lkdGggbm8tYnJlYWsgc3BhY2VcIixcbiAgICA2NTUzMjogXCJvYmplY3QgcmVwbGFjZW1lbnRcIlxufTtcbmxldCBfc3VwcG9ydHNUYWJTaXplID0gbnVsbDtcbmZ1bmN0aW9uIHN1cHBvcnRzVGFiU2l6ZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKF9zdXBwb3J0c1RhYlNpemUgPT0gbnVsbCAmJiB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGxldCBzdHlsZXMgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBfc3VwcG9ydHNUYWJTaXplID0gKChfYSA9IHN0eWxlcy50YWJTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdHlsZXMuTW96VGFiU2l6ZSkgIT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9zdXBwb3J0c1RhYlNpemUgfHwgZmFsc2U7XG59XG5jb25zdCBzcGVjaWFsQ2hhckNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgY29uZmlnID0gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgICAgICBzcGVjaWFsQ2hhcnM6IFNwZWNpYWxzLFxuICAgICAgICAgICAgYWRkU3BlY2lhbENoYXJzOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLnJlcGxhY2VUYWJzID0gIXN1cHBvcnRzVGFiU2l6ZSgpKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoXCJcXHR8XCIgKyBjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xuICAgICAgICBpZiAoY29uZmlnLmFkZFNwZWNpYWxDaGFycylcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlICsgXCJ8XCIgKyBjb25maWcuYWRkU3BlY2lhbENoYXJzLnNvdXJjZSwgVW5pY29kZVJlZ2V4cFN1cHBvcnQpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGluc3RhbGxzIGhpZ2hsaWdodGluZyBvZiBzcGVjaWFsXG5jaGFyYWN0ZXJzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFNwZWNpYWxDaGFycyhcbi8qKlxuQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuKi9cbmNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtzcGVjaWFsQ2hhckNvbmZpZy5vZihjb25maWcpLCBzcGVjaWFsQ2hhclBsdWdpbigpXTtcbn1cbmxldCBfcGx1Z2luID0gbnVsbDtcbmZ1bmN0aW9uIHNwZWNpYWxDaGFyUGx1Z2luKCkge1xuICAgIHJldHVybiBfcGx1Z2luIHx8IChfcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbkNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKHZpZXcuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIG1ha2VEZWNvcmF0b3IoY29uZikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRjaERlY29yYXRvcih7XG4gICAgICAgICAgICAgICAgcmVnZXhwOiBjb25mLnNwZWNpYWxDaGFycyxcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9uOiAobSwgdmlldywgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRvYyB9ID0gdmlldy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb2RlUG9pbnRBdChtWzBdLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHZpZXcuc3RhdGUudGFiU2l6ZSwgY29sID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBzaXplLCBwb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5OiBjb25mLnJlcGxhY2VUYWJzID8gdW5kZWZpbmVkIDogL1teXS9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykgIT0gY29uZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKGNvbmYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KSk7XG59XG5jb25zdCBEZWZhdWx0UGxhY2Vob2xkZXIgPSBcIlxcdTIwMjJcIjtcbi8vIEFzc2lnbnMgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBmcm9tIHRoZSBDb250cm9sIFBpY3R1cmVzIGJsb2NrIHRvXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyJDEoY29kZSkge1xuICAgIGlmIChjb2RlID49IDMyKVxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIGlmIChjb2RlID09IDEwKVxuICAgICAgICByZXR1cm4gXCJcXHUyNDI0XCI7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xufVxuY2xhc3MgU3BlY2lhbENoYXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5jb2RlID09IHRoaXMuY29kZTsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHBoID0gcGxhY2Vob2xkZXIkMSh0aGlzLmNvZGUpO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChOYW1lc1t0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHBoO1xuICAgICAgICBzcGFuLnRpdGxlID0gZGVzYztcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc3BlY2lhbENoYXJcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLndpZHRoID09IHRoaXMud2lkdGg7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiXFx0XCI7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcbiAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNvbnN0IHBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTAwMDtcbiAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IFwicGFkZGluZy1ib3R0b206IDEwMDBweFwiIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdXBkYXRlO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0IC0gdmlldy5kZWZhdWx0TGluZUhlaWdodCAtIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCAtIDAuNTtcbiAgICAgICAgaWYgKGhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogYHBhZGRpbmctYm90dG9tOiAke2hlaWdodH1weGAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IG1ha2VzIHN1cmUgdGhlIGNvbnRlbnQgaGFzIGEgYm90dG9tXG5tYXJnaW4gZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBlZGl0b3IsIG1pbnVzIG9uZSBsaW5lXG5oZWlnaHQsIHNvIHRoYXQgZXZlcnkgbGluZSBpbiB0aGUgZG9jdW1lbnQgY2FuIGJlIHNjcm9sbGVkIHRvIHRoZVxudG9wIG9mIHRoZSBlZGl0b3IuXG5cblRoaXMgaXMgb25seSBtZWFuaW5nZnVsIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxhYmxlLCBhbmQgc2hvdWxkXG5ub3QgYmUgZW5hYmxlZCBpbiBlZGl0b3JzIHRoYXQgdGFrZSB0aGUgc2l6ZSBvZiB0aGVpciBjb250ZW50LlxuKi9cbmZ1bmN0aW9uIHNjcm9sbFBhc3RFbmQoKSB7XG4gICAgcmV0dXJuIFtwbHVnaW4sIGNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSB8fCBudWxsOyB9KV07XG59XG5cbi8qKlxuTWFyayBsaW5lcyB0aGF0IGhhdmUgYSBjdXJzb3Igb24gdGhlbSB3aXRoIHRoZSBgXCJjbS1hY3RpdmVMaW5lXCJgXG5ET00gY2xhc3MuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUhpZ2hsaWdodGVyO1xufVxuY29uc3QgbGluZURlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5saW5lKHsgY2xhc3M6IFwiY20tYWN0aXZlTGluZVwiIH0pO1xuY29uc3QgYWN0aXZlTGluZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBsYXN0TGluZVN0YXJ0ID0gLTEsIGRlY28gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChyLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IGxhc3RMaW5lU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2gobGluZURlY28ucmFuZ2UobGluZS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuXG5jbGFzcyBQbGFjZWhvbGRlciBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCB3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHdyYXAuY2xhc3NOYW1lID0gXCJjbS1wbGFjZWhvbGRlclwiO1xuICAgICAgICB3cmFwLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgd3JhcC5hcHBlbmRDaGlsZCh0eXBlb2YgdGhpcy5jb250ZW50ID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmNvbnRlbnQpIDogdGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcInBsYWNlaG9sZGVyIFwiICsgdGhpcy5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHJldHVybiB3cmFwO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4vKipcbkV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYSBwbGFjZWhvbGRlcuKAlGEgcGllY2Ugb2YgZXhhbXBsZSBjb250ZW50XG50byBzaG93IHdoZW4gdGhlIGVkaXRvciBpcyBlbXB0eS5cbiovXG5mdW5jdGlvbiBwbGFjZWhvbGRlcihjb250ZW50KSB7XG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBEZWNvcmF0aW9uLnNldChbRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IG5ldyBQbGFjZWhvbGRlcihjb250ZW50KSwgc2lkZTogMSB9KS5yYW5nZSgwKV0pO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZWNvcmF0aW9ucygpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gRGVjb3JhdGlvbi5ub25lIDogdGhpcy5wbGFjZWhvbGRlcjsgfVxuICAgIH0sIHsgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9ucyB9KTtcbn1cblxuLy8gRG9uJ3QgY29tcHV0ZSBwcmVjaXNlIGNvbHVtbiBwb3NpdGlvbnMgZm9yIGxpbmUgb2Zmc2V0cyBhYm92ZSB0aGlzXG4vLyAoc2luY2UgaXQgY291bGQgZ2V0IGV4cGVuc2l2ZSkuIEFzc3VtZSBvZmZzZXQ9PWNvbHVtbiBmb3IgdGhlbS5cbmNvbnN0IE1heE9mZiA9IDIwMDA7XG5mdW5jdGlvbiByZWN0YW5nbGVGb3Ioc3RhdGUsIGEsIGIpIHtcbiAgICBsZXQgc3RhcnRMaW5lID0gTWF0aC5taW4oYS5saW5lLCBiLmxpbmUpLCBlbmRMaW5lID0gTWF0aC5tYXgoYS5saW5lLCBiLmxpbmUpO1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBpZiAoYS5vZmYgPiBNYXhPZmYgfHwgYi5vZmYgPiBNYXhPZmYgfHwgYS5jb2wgPCAwIHx8IGIuY29sIDwgMCkge1xuICAgICAgICBsZXQgc3RhcnRPZmYgPSBNYXRoLm1pbihhLm9mZiwgYi5vZmYpLCBlbmRPZmYgPSBNYXRoLm1heChhLm9mZiwgYi5vZmYpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSBlbmRPZmYpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0T2ZmLCBsaW5lLnRvICsgZW5kT2ZmKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBzdGFydENvbCA9IE1hdGgubWluKGEuY29sLCBiLmNvbCksIGVuZENvbCA9IE1hdGgubWF4KGEuY29sLCBiLmNvbCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lKGkpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZmluZENvbHVtbihsaW5lLnRleHQsIHN0YXJ0Q29sLCBzdGF0ZS50YWJTaXplLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUudG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBmaW5kQ29sdW1uKGxpbmUudGV4dCwgZW5kQ29sLCBzdGF0ZS50YWJTaXplKTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UobGluZS5mcm9tICsgc3RhcnQsIGxpbmUuZnJvbSArIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiBhYnNvbHV0ZUNvbHVtbih2aWV3LCB4KSB7XG4gICAgbGV0IHJlZiA9IHZpZXcuY29vcmRzQXRQb3Modmlldy52aWV3cG9ydC5mcm9tKTtcbiAgICByZXR1cm4gcmVmID8gTWF0aC5yb3VuZChNYXRoLmFicygocmVmLmxlZnQgLSB4KSAvIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKSkgOiAtMTtcbn1cbmZ1bmN0aW9uIGdldFBvcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBvZmZzZXQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9LCBmYWxzZSk7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KSwgb2ZmID0gb2Zmc2V0IC0gbGluZS5mcm9tO1xuICAgIGxldCBjb2wgPSBvZmYgPiBNYXhPZmYgPyAtMVxuICAgICAgICA6IG9mZiA9PSBsaW5lLmxlbmd0aCA/IGFic29sdXRlQ29sdW1uKHZpZXcsIGV2ZW50LmNsaWVudFgpXG4gICAgICAgICAgICA6IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgdmlldy5zdGF0ZS50YWJTaXplLCBvZmZzZXQgLSBsaW5lLmZyb20pO1xuICAgIHJldHVybiB7IGxpbmU6IGxpbmUubnVtYmVyLCBjb2wsIG9mZiB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSBnZXRQb3ModmlldywgZXZlbnQpLCBzdGFydFNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghc3RhcnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdTdGFydCA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZShzdGFydC5saW5lKS5mcm9tKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGluZSA9IHVwZGF0ZS5zdGF0ZS5kb2MubGluZUF0KG5ld1N0YXJ0KTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHsgbGluZTogbmV3TGluZS5udW1iZXIsIGNvbDogc3RhcnQuY29sLCBvZmY6IE1hdGgubWluKHN0YXJ0Lm9mZiwgbmV3TGluZS5sZW5ndGgpIH07XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIF9leHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZ2V0UG9zKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghY3VyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSByZWN0YW5nbGVGb3Iodmlldy5zdGF0ZSwgc3RhcnQsIGN1cik7XG4gICAgICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5jb25jYXQoc3RhcnRTZWwucmFuZ2VzKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHJlY3Rhbmd1bGFyIHNlbGVjdGlvbnMuIEJ5XG5kZWZhdWx0LCBpdCB3aWxsIHJlYWN0IHRvIGxlZnQgbW91c2UgZHJhZyB3aXRoIHRoZSBBbHQga2V5IGhlbGRcbmRvd24uIFdoZW4gc3VjaCBhIHNlbGVjdGlvbiBvY2N1cnMsIHRoZSB0ZXh0IHdpdGhpbiB0aGUgcmVjdGFuZ2xlXG50aGF0IHdhcyBkcmFnZ2VkIG92ZXIgd2lsbCBiZSBzZWxlY3RlZCwgYXMgb25lIHNlbGVjdGlvblxuW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlKSBwZXIgbGluZS5cbiovXG5mdW5jdGlvbiByZWN0YW5ndWxhclNlbGVjdGlvbihvcHRpb25zKSB7XG4gICAgbGV0IGZpbHRlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnRGaWx0ZXIpIHx8IChlID0+IGUuYWx0S2V5ICYmIGUuYnV0dG9uID09IDApO1xuICAgIHJldHVybiBFZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUub2YoKHZpZXcsIGV2ZW50KSA9PiBmaWx0ZXIoZXZlbnQpID8gcmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUodmlldywgZXZlbnQpIDogbnVsbCk7XG59XG5jb25zdCBrZXlzID0ge1xuICAgIEFsdDogWzE4LCBlID0+IGUuYWx0S2V5XSxcbiAgICBDb250cm9sOiBbMTcsIGUgPT4gZS5jdHJsS2V5XSxcbiAgICBTaGlmdDogWzE2LCBlID0+IGUuc2hpZnRLZXldLFxuICAgIE1ldGE6IFs5MSwgZSA9PiBlLm1ldGFLZXldXG59O1xuY29uc3Qgc2hvd0Nyb3NzaGFpciA9IHsgc3R5bGU6IFwiY3Vyc29yOiBjcm9zc2hhaXJcIiB9O1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IHR1cm5zIHRoZSBwb2ludGVyIGN1cnNvciBpbnRvIGFcbmNyb3NzaGFpciB3aGVuIGEgZ2l2ZW4gbW9kaWZpZXIga2V5LCBkZWZhdWx0aW5nIHRvIEFsdCwgaXMgaGVsZFxuZG93bi4gQ2FuIHNlcnZlIGFzIGEgdmlzdWFsIGhpbnQgdGhhdCByZWN0YW5ndWxhciBzZWxlY3Rpb24gaXNcbmdvaW5nIHRvIGhhcHBlbiB3aGVuIHBhaXJlZCB3aXRoXG5bYHJlY3Rhbmd1bGFyU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKS5cbiovXG5mdW5jdGlvbiBjcm9zc2hhaXJDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IFtjb2RlLCBnZXR0ZXJdID0ga2V5c1tvcHRpb25zLmtleSB8fCBcIkFsdFwiXTtcbiAgICBsZXQgcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoaXNEb3duKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rvd24gIT0gaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBpc0Rvd247XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGtleWRvd24oZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGUua2V5Q29kZSA9PSBjb2RlIHx8IGdldHRlcihlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5dXAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gY29kZSB8fCAhZ2V0dGVyKGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2Vtb3ZlKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgcGx1Z2luLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHZpZXcgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRG93bikgPyBzaG93Q3Jvc3NoYWlyIDogbnVsbDsgfSlcbiAgICBdO1xufVxuXG5jb25zdCBPdXRzaWRlID0gXCItMTAwMDBweFwiO1xuY2xhc3MgVG9vbHRpcFZpZXdNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBmYWNldCwgY3JlYXRlVG9vbHRpcFZpZXcpIHtcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3ID0gY3JlYXRlVG9vbHRpcFZpZXc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgdGhpcy50b29sdGlwcyA9IHRoaXMuaW5wdXQuZmlsdGVyKHQgPT4gdCk7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdGhpcy50b29sdGlwcy5tYXAoY3JlYXRlVG9vbHRpcFZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRoaXMuZmFjZXQpO1xuICAgICAgICBsZXQgdG9vbHRpcHMgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIGlmICh0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdC51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9vbHRpcFZpZXdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aXAgPSB0b29sdGlwc1tpXSwga25vd24gPSAtMTtcbiAgICAgICAgICAgIGlmICghdGlwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG90aGVyID0gdGhpcy50b29sdGlwc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgJiYgb3RoZXIuY3JlYXRlID09IHRpcC5jcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgIGtub3duID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwVmlld3NbaV0gPSB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3KHRpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwVmlld3NbaV0gPSB0aGlzLnRvb2x0aXBWaWV3c1trbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcFZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIGlmICh0b29sdGlwVmlld3MuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgICAgICAgICAgICB0LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0b29sdGlwVmlld3M7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlcyBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIHRvb2x0aXAgYmVoYXZpb3IuXG4qL1xuZnVuY3Rpb24gdG9vbHRpcHMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gdG9vbHRpcENvbmZpZy5vZihjb25maWcpO1xufVxuZnVuY3Rpb24gd2luZG93U3BhY2Uodmlldykge1xuICAgIGxldCB7IHdpbiB9ID0gdmlldztcbiAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0LCByaWdodDogd2luLmlubmVyV2lkdGggfTtcbn1cbmNvbnN0IHRvb2x0aXBDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBwb3NpdGlvbjogYnJvd3Nlci5pb3MgPyBcImFic29sdXRlXCIgOiAoKF9hID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBvc2l0aW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc2l0aW9uKSB8fCBcImZpeGVkXCIsXG4gICAgICAgICAgICBwYXJlbnQ6ICgoX2IgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucGFyZW50KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBTcGFjZTogKChfYyA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi50b29sdGlwU3BhY2UpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9vbHRpcFNwYWNlKSB8fCB3aW5kb3dTcGFjZSxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBrbm93bkhlaWdodCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuY29uc3QgdG9vbHRpcFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBjb25maWcucGFyZW50O1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93VG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCkpO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpID4gdGhpcy5sYXN0VHJhbnNhY3Rpb24gLSA1MCAmJlxuICAgICAgICAgICAgICAgIGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPCAxKVxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVNvb24oKTtcbiAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFsxXSB9KSA6IG51bGw7XG4gICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICB2aWV3Lndpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24gPSB0aGlzLm1lYXN1cmVTb29uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNob3VsZE1lYXN1cmUgPSB1cGRhdGVkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQ7XG4gICAgICAgIGxldCBuZXdDb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZyk7XG4gICAgICAgIGlmIChuZXdDb25maWcucG9zaXRpb24gIT0gdGhpcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ld0NvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLnBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBuZXdDb25maWcucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0LmRvbSk7XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnZpZXcudGhlbWVDbGFzc2VzICE9IHRoaXMuY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTWVhc3VyZSlcbiAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIik7XG4gICAgICAgIGlmICh0b29sdGlwLmFycm93ICYmICF0b29sdGlwVmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwID4gLmNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgICAgIGxldCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBhcnJvdy5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXJyb3dcIjtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5hcHBlbmRDaGlsZChhcnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy52aWV3Lndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24pO1xuICAgICAgICBmb3IgKGxldCB0b29sdGlwVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAoX2EgPSB0b29sdGlwVmlldy5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0b29sdGlwVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubWVhc3VyZVRpbWVvdXQpO1xuICAgIH1cbiAgICByZWFkTWVhc3VyZSgpIHtcbiAgICAgICAgbGV0IGVkaXRvciA9IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMucGFyZW50ID8gdGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBlZGl0b3IsXG4gICAgICAgICAgICBwb3M6IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAoKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiB0di5nZXRDb29yZHMgPyB0di5nZXRDb29yZHModC5wb3MpIDogdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgeyBlZGl0b3IsIHNwYWNlIH0gPSBtZWFzdXJlZDtcbiAgICAgICAgbGV0IG90aGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLm1hbmFnZXIudG9vbHRpcHNbaV0sIHRWaWV3ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXSwgeyBkb20gfSA9IHRWaWV3O1xuICAgICAgICAgICAgbGV0IHBvcyA9IG1lYXN1cmVkLnBvc1tpXSwgc2l6ZSA9IG1lYXN1cmVkLnNpemVbaV07XG4gICAgICAgICAgICAvLyBIaWRlIHRvb2x0aXBzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGVkaXRvci5cbiAgICAgICAgICAgIGlmICghcG9zIHx8IHBvcy5ib3R0b20gPD0gTWF0aC5tYXgoZWRpdG9yLnRvcCwgc3BhY2UudG9wKSB8fFxuICAgICAgICAgICAgICAgIHBvcy50b3AgPj0gTWF0aC5taW4oZWRpdG9yLmJvdHRvbSwgc3BhY2UuYm90dG9tKSB8fFxuICAgICAgICAgICAgICAgIHBvcy5yaWdodCA8IE1hdGgubWF4KGVkaXRvci5sZWZ0LCBzcGFjZS5sZWZ0KSAtIC4xIHx8XG4gICAgICAgICAgICAgICAgcG9zLmxlZnQgPiBNYXRoLm1pbihlZGl0b3IucmlnaHQsIHNwYWNlLnJpZ2h0KSArIC4xKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSB0b29sdGlwLmFycm93ID8gdFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyb3dIZWlnaHQgPSBhcnJvdyA/IDcgLyogQXJyb3cuU2l6ZSAqLyA6IDA7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBzaXplLnJpZ2h0IC0gc2l6ZS5sZWZ0LCBoZWlnaHQgPSAoX2EgPSBrbm93bkhlaWdodC5nZXQodFZpZXcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzaXplLmJvdHRvbSAtIHNpemUudG9wO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRWaWV3Lm9mZnNldCB8fCBub09mZnNldCwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gc2l6ZS53aWR0aCA+IHNwYWNlLnJpZ2h0IC0gc3BhY2UubGVmdCA/IChsdHIgPyBzcGFjZS5sZWZ0IDogc3BhY2UucmlnaHQgLSBzaXplLndpZHRoKVxuICAgICAgICAgICAgICAgIDogbHRyID8gTWF0aC5taW4ocG9zLmxlZnQgLSAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSArIG9mZnNldC54LCBzcGFjZS5yaWdodCAtIHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWF4KHNwYWNlLmxlZnQsIHBvcy5sZWZ0IC0gd2lkdGggKyAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSAtIG9mZnNldC54KTtcbiAgICAgICAgICAgIGxldCBhYm92ZSA9ICEhdG9vbHRpcC5hYm92ZTtcbiAgICAgICAgICAgIGlmICghdG9vbHRpcC5zdHJpY3RTaWRlICYmIChhYm92ZVxuICAgICAgICAgICAgICAgID8gcG9zLnRvcCAtIChzaXplLmJvdHRvbSAtIHNpemUudG9wKSAtIG9mZnNldC55IDwgc3BhY2UudG9wXG4gICAgICAgICAgICAgICAgOiBwb3MuYm90dG9tICsgKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApICsgb2Zmc2V0LnkgPiBzcGFjZS5ib3R0b20pICYmXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcbiAgICAgICAgICAgICAgICBhYm92ZSA9ICFhYm92ZTtcbiAgICAgICAgICAgIGxldCBzcGFjZVZlcnQgPSAoYWJvdmUgPyBwb3MudG9wIC0gc3BhY2UudG9wIDogc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSkgLSBhcnJvd0hlaWdodDtcbiAgICAgICAgICAgIGlmIChzcGFjZVZlcnQgPCBoZWlnaHQgJiYgdFZpZXcucmVzaXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZVZlcnQgPCB0aGlzLnZpZXcuZGVmYXVsdExpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrbm93bkhlaWdodC5zZXQodFZpZXcsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmhlaWdodCA9IChoZWlnaHQgPSBzcGFjZVZlcnQpICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLnN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IGFib3ZlID8gcG9zLnRvcCAtIGhlaWdodCAtIGFycm93SGVpZ2h0IC0gb2Zmc2V0LnkgOiBwb3MuYm90dG9tICsgYXJyb3dIZWlnaHQgKyBvZmZzZXQueTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2Ygb3RoZXJzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoci5sZWZ0IDwgcmlnaHQgJiYgci5yaWdodCA+IGxlZnQgJiYgci50b3AgPCB0b3AgKyBoZWlnaHQgJiYgci5ib3R0b20gPiB0b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBhYm92ZSA/IHIudG9wIC0gaGVpZ2h0IC0gMiAtIGFycm93SGVpZ2h0IDogci5ib3R0b20gKyBhcnJvd0hlaWdodCArIDI7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gKHRvcCAtIG1lYXN1cmVkLnBhcmVudC50b3ApICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gKGxlZnQgLSBtZWFzdXJlZC5wYXJlbnQubGVmdCkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJvdylcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYCR7cG9zLmxlZnQgKyAobHRyID8gb2Zmc2V0LnggOiAtb2Zmc2V0LngpIC0gKGxlZnQgKyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gLSA3IC8qIEFycm93LlNpemUgKi8pfXB4YDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tOiB0b3AgKyBoZWlnaHQgfSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYWJvdmVcIiwgYWJvdmUpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWJlbG93XCIsICFhYm92ZSk7XG4gICAgICAgICAgICBpZiAodFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICB0Vmlldy5wb3NpdGlvbmVkKG1lYXN1cmVkLnNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZU1lYXN1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluVmlldyAhPSB0aGlzLnZpZXcuaW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pblZpZXcgPSB0aGlzLnZpZXcuaW5WaWV3O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR2IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB0di5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgekluZGV4OiAxMDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLXNlY3Rpb246bm90KDpmaXJzdC1jaGlsZClcIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgaGVpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICB3aWR0aDogYCR7NyAvKiBBcnJvdy5TaXplICovICogMn1weGAsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICBcIiY6YmVmb3JlLCAmOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1hYm92ZSAmXCI6IHtcbiAgICAgICAgICAgIGJvdHRvbTogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWJlbG93ICZcIjoge1xuICAgICAgICAgICAgdG9wOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCIjMzMzMzM4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IG5vT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4vKipcbkZhY2V0IHRvIHdoaWNoIGFuIGV4dGVuc2lvbiBjYW4gYWRkIGEgdmFsdWUgdG8gc2hvdyBhIHRvb2x0aXAuXG4qL1xuY29uc3Qgc2hvd1Rvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBbdG9vbHRpcFBsdWdpbiwgYmFzZVRoZW1lXVxufSk7XG5jb25zdCBzaG93SG92ZXJUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgSG92ZXJUb29sdGlwSG9zdCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1ob3ZlclwiKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93SG92ZXJUb29sdGlwLCB0ID0+IHRoaXMuY3JlYXRlSG9zdGVkVmlldyh0KSk7XG4gICAgfVxuICAgIC8vIE5lZWRzIHRvIGJlIHN0YXRpYyBzbyB0aGF0IGhvc3QgdG9vbHRpcCBpbnN0YW5jZXMgYWx3YXlzIG1hdGNoXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgSG92ZXJUb29sdGlwSG9zdCh2aWV3KTtcbiAgICB9XG4gICAgY3JlYXRlSG9zdGVkVmlldyh0b29sdGlwKSB7XG4gICAgICAgIGxldCBob3N0ZWRWaWV3ID0gdG9vbHRpcC5jcmVhdGUodGhpcy52aWV3KTtcbiAgICAgICAgaG9zdGVkVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXAtc2VjdGlvblwiKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoaG9zdGVkVmlldy5kb20pO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiBob3N0ZWRWaWV3O1xuICAgIH1cbiAgICBtb3VudCh2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3LnBvc2l0aW9uZWQoc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuZmlsdGVyKHQgPT4gdCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLmZpbHRlcih0ID0+IHQuZW5kICE9IG51bGwpLm1hcCh0ID0+IHQuZW5kKSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGhvdmVyZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0TW92ZS50aW1lO1xuICAgICAgICBpZiAoaG92ZXJlZCA8IHRoaXMuaG92ZXJUaW1lKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUgLSBob3ZlcmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdGFydEhvdmVyKCk7XG4gICAgfVxuICAgIHN0YXJ0SG92ZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgbGV0IHsgbGFzdE1vdmUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhsYXN0TW92ZS50YXJnZXQpID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKGxhc3RNb3ZlKSA6IG51bGw7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHRoaXMudmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAocG9zQ29vcmRzID09IG51bGwgfHwgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgIGxhc3RNb3ZlLnggPCBwb3NDb29yZHMubGVmdCAtIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGggfHxcbiAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYmlkaSA9IHRoaXMudmlldy5iaWRpU3BhbnModGhpcy52aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKSkuZmluZChzID0+IHMuZnJvbSA8PSBwb3MgJiYgcy50byA+PSBwb3MpO1xuICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHRoaXMudmlldywgcG9zLCAobGFzdE1vdmUueCA8IHBvc0Nvb3Jkcy5sZWZ0ID8gLXJ0bCA6IHJ0bCkpO1xuICAgICAgICBpZiAob3BlbiA9PT0gbnVsbCB8fCBvcGVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuLnRoZW4pIHtcbiAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nID0geyBwb3MgfTtcbiAgICAgICAgICAgIG9wZW4udGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcgPT0gcGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihyZXN1bHQpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJob3ZlciB0b29sdGlwXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG9wZW4pIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHRhcmdldDogZXZlbnQudGFyZ2V0LCB0aW1lOiBEYXRlLm5vdygpIH07XG4gICAgICAgIGlmICh0aGlzLmhvdmVyVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSk7XG4gICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGlmICh0b29sdGlwICYmICFpc0luVG9vbHRpcCh0aGlzLmxhc3RNb3ZlLnRhcmdldCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IHRvb2x0aXAgfHwgdGhpcy5wZW5kaW5nLCBlbmQgPSAoX2EgPSB0b29sdGlwID09PSBudWxsIHx8IHRvb2x0aXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvb2x0aXAuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwb3M7XG4gICAgICAgICAgICBpZiAoKHBvcyA9PSBlbmQgPyB0aGlzLnZpZXcucG9zQXRDb29yZHModGhpcy5sYXN0TW92ZSkgIT0gcG9zXG4gICAgICAgICAgICAgICAgOiAhaXNPdmVyUmFuZ2UodGhpcy52aWV3LCBwb3MsIGVuZCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgNiAvKiBIb3Zlci5NYXhEaXN0ICovKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhvdmVyVGltZW91dCk7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSAmJiAhaXNJblRvb2x0aXAoZS5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhvdmVyVGltZW91dCk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlKTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0luVG9vbHRpcChlbHQpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBlbHQ7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpXG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tdG9vbHRpcFwiKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT3ZlclJhbmdlKHZpZXcsIGZyb20sIHRvLCB4LCB5LCBtYXJnaW4pIHtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGxldCBmcm9tRE9NID0gdmlldy5kb21BdFBvcyhmcm9tKSwgdG9ET00gPSB2aWV3LmRvbUF0UG9zKHRvKTtcbiAgICByYW5nZS5zZXRFbmQodG9ET00ubm9kZSwgdG9ET00ub2Zmc2V0KTtcbiAgICByYW5nZS5zZXRTdGFydChmcm9tRE9NLm5vZGUsIGZyb21ET00ub2Zmc2V0KTtcbiAgICBsZXQgcmVjdHMgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpO1xuICAgIHJhbmdlLmRldGFjaCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgbGV0IGRpc3QgPSBNYXRoLm1heChyZWN0LnRvcCAtIHksIHkgLSByZWN0LmJvdHRvbSwgcmVjdC5sZWZ0IC0geCwgeCAtIHJlY3QucmlnaHQpO1xuICAgICAgICBpZiAoZGlzdCA8PSBtYXJnaW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5TZXQgdXAgYSBob3ZlciB0b29sdGlwLCB3aGljaCBzaG93cyB1cCB3aGVuIHRoZSBwb2ludGVyIGhvdmVyc1xub3ZlciByYW5nZXMgb2YgdGV4dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBob3ZlcnNcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXG5hc3NvY2lhdGVkIHdpdGggcG9zaXRpb24gYHBvc2AsIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhpZGVPbiAmJiBvcHRpb25zLmhpZGVPbih0ciwgdmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1BvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLnBvcywgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb3B5LnBvcyA9IG5ld1BvcztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuZW5kID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuZW5kKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0SG92ZXIpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIG9wdGlvbnMuaG92ZXJUaW1lIHx8IDMwMCAvKiBIb3Zlci5UaW1lICovKSksXG4gICAgICAgIHNob3dIb3ZlclRvb2x0aXBIb3N0XG4gICAgXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwKHZpZXcsIHRvb2x0aXApIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKCFwbHVnaW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XG4gICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbZm91bmRdO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgYW55IGhvdmVyIHRvb2x0aXBzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuc29tZSh4ID0+IHgpO1xufVxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGVmZmVjdCB0aGF0IGNsb3NlcyBhbGwgaG92ZXIgdG9vbHRpcHMuXG4qL1xuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBzID0gLypAX19QVVJFX18qL2Nsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1heWJlTWVhc3VyZSgpO1xufVxuXG5jb25zdCBwYW5lbENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXI7XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICAgICAgdG9wQ29udGFpbmVyID0gdG9wQ29udGFpbmVyIHx8IGMudG9wQ29udGFpbmVyO1xuICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gYm90dG9tQ29udGFpbmVyIHx8IGMuYm90dG9tQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyIH07XG4gICAgfVxufSk7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHBhbmVsLW1hbmFnaW5nIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBwYW5lbHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtwYW5lbENvbmZpZy5vZihjb25maWcpXSA6IFtdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSBwYW5lbCBjcmVhdGVkIGJ5IHRoZSBnaXZlbiBjb25zdHJ1Y3RvciwgaWYgYW55LlxuVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIHlvdXIgcGFuZWxzJyBET01cbnN0cnVjdHVyZS5cbiovXG5mdW5jdGlvbiBnZXRQYW5lbCh2aWV3LCBwYW5lbCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihwYW5lbFBsdWdpbik7XG4gICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLnNwZWNzLmluZGV4T2YocGFuZWwpIDogLTE7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ucGFuZWxzW2luZGV4XSA6IG51bGw7XG59XG5jb25zdCBwYW5lbFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICB0aGlzLnNwZWNzID0gdGhpcy5pbnB1dC5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB0aGlzLnNwZWNzLm1hcChzcGVjID0+IHNwZWModmlldykpO1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh2aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB0aGlzLnRvcC5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+IHAudG9wKSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gIXAudG9wKSk7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tLmNvbnRhaW5lciAhPSBjb25mLmJvdHRvbUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgICAgICBsZXQgcGFuZWxzID0gW10sIHRvcCA9IFtdLCBib3R0b20gPSBbXSwgbW91bnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSBzcGVjKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgKHBhbmVsLnRvcCA/IHRvcCA6IGJvdHRvbSkucHVzaChwYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoYm90dG9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgbW91bnQpIHtcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHAudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHsgdG9wOiB2YWx1ZS50b3Auc2Nyb2xsTWFyZ2luKCksIGJvdHRvbTogdmFsdWUuYm90dG9tLnNjcm9sbE1hcmdpbigpIH07XG4gICAgfSlcbn0pO1xuY2xhc3MgUGFuZWxHcm91cCB7XG4gICAgY29uc3RydWN0b3IodmlldywgdG9wLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jQ2xhc3NlcygpO1xuICAgIH1cbiAgICBzeW5jKHBhbmVscykge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgaWYgKHAuZGVzdHJveSAmJiBwYW5lbHMuaW5kZXhPZihwKSA8IDApXG4gICAgICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICB0aGlzLnN5bmNET00oKTtcbiAgICB9XG4gICAgc3luY0RPTSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSB0aGlzLnRvcCA/IFwiY20tcGFuZWxzIGNtLXBhbmVscy10b3BcIiA6IFwiY20tcGFuZWxzIGNtLXBhbmVscy1ib3R0b21cIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlW3RoaXMudG9wID8gXCJ0b3BcIiA6IFwiYm90dG9tXCJdID0gXCIwXCI7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5jb250YWluZXIgfHwgdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHRoaXMudG9wID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyRE9NID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgcGFuZWwgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJET00gIT0gcGFuZWwuZG9tKVxuICAgICAgICAgICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IGN1ckRPTS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShwYW5lbC5kb20sIGN1ckRPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN1ckRPTSlcbiAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgfVxuICAgIHNjcm9sbE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRvbSB8fCB0aGlzLmNvbnRhaW5lciA/IDBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy50b3AgP1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIE1hdGgubWF4KDAsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSAtIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgfVxuICAgIHN5bmNDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY2xhc3NlcyA9PSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgKHRoaXMuY2xhc3NlcyA9IHRoaXMudmlldy50aGVtZUNsYXNzZXMpLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBwYW5lbFBsdWdpblxufSk7XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENhbGxlZCBpZiB0aGUgbWFya2VyIGhhcyBhIGB0b0RPTWAgbWV0aG9kIGFuZCBpdHMgcmVwcmVzZW50YXRpb25cbiAgICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS50b0RPTSA9IHVuZGVmaW5lZDtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxuTWFya2VycyBnaXZlbiB0byB0aGlzIGZhY2V0IHNob3VsZCBfb25seV8gZGVmaW5lIGFuXG5bYGVsZW1lbnRjbGFzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIuZWxlbWVudENsYXNzKSwgbm90IGFcbltgdG9ET01gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLnRvRE9NKSAob3IgdGhlIG1hcmtlciB3aWxsIGFwcGVhclxuaW4gYWxsIGd1dHRlcnMgZm9yIHRoZSBsaW5lKS5cbiovXG5jb25zdCBndXR0ZXJMaW5lQ2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBjbGFzczogXCJcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBlbGVtZW50U3R5bGU6IFwiXCIsXG4gICAgbWFya2VyczogKCkgPT4gUmFuZ2VTZXQuZW1wdHksXG4gICAgbGluZU1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiBudWxsLFxuICAgIGluaXRpYWxTcGFjZXI6IG51bGwsXG4gICAgdXBkYXRlU3BhY2VyOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9XG59O1xuY29uc3QgYWN0aXZlR3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGFuIGVkaXRvciBndXR0ZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgZ3V0dGVycyBhcHBlYXIgaXNcbmRldGVybWluZWQgYnkgdGhlaXIgZXh0ZW5zaW9uIHByaW9yaXR5LlxuKi9cbmZ1bmN0aW9uIGd1dHRlcihjb25maWcpIHtcbiAgICByZXR1cm4gW2d1dHRlcnMoKSwgYWN0aXZlR3V0dGVycy5vZihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgY29uZmlnKSldO1xufVxuY29uc3QgdW5maXhHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuLyoqXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxuZ3V0dGVyLCBidXQgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBleHBsaWNpdGx5IGNvbmZpZ3VyZSBpdC5cblxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXG5maXhlZCwgbWVhbmluZyB0aGV5IGRvbid0IHNjcm9sbCBhbG9uZyB3aXRoIHRoZSBjb250ZW50XG5ob3Jpem9udGFsbHkgKGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlciwgd2hpY2ggZG9lc24ndCBzdXBwb3J0XG5DU1MgW2Bwb3NpdGlvbjpcbnN0aWNreWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb3NpdGlvbiNzdGlja3kpKS5cbiovXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbXG4gICAgICAgIGd1dHRlclZpZXcsXG4gICAgXTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5maXhlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZml4R3V0dGVycy5vZih0cnVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGd1dHRlclZpZXcgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyc1wiO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB0aGlzLmd1dHRlcnMgPSB2aWV3LnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLm1hcChjb25mID0+IG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHZpZXcsIGNvbmYpKTtcbiAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICB0aGlzLmZpeGVkID0gIXZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgcG9zaXRpb246IHJlbGF0aXZlICsgZXZlbnQgaGFuZGxlcnMgdGhhdCByZWFsaWduIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVyIChvciBqdXN0IGZvcmNlIGZpeGVkPWZhbHNlIG9uIElFMTE/KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY0d1dHRlcnMoZmFsc2UpO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHZpZXcuY29udGVudERPTSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2ggZHVyaW5nIHN5bmMgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBkdXJpbmcgc2Nyb2xsaW5nKSwgc2luY2UgZm9yIGxhcmdlIHVwZGF0ZXMgdGhhdCBpc1xuICAgICAgICAgICAgLy8gZmFzdGVyLlxuICAgICAgICAgICAgbGV0IHZwQSA9IHRoaXMucHJldlZpZXdwb3J0LCB2cEIgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGxldCB2cE92ZXJsYXAgPSBNYXRoLm1pbih2cEEudG8sIHZwQi50bykgLSBNYXRoLm1heCh2cEEuZnJvbSwgdnBCLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zeW5jR3V0dGVycyh2cE92ZXJsYXAgPCAodnBCLnRvIC0gdnBCLmZyb20pICogMC44KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBsaW5lIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgdGV4dCwgY2xhc3NTZXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8geyBsZWZ0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggfSA6IHsgcmlnaHQ6IHZhbHVlLmRvbS5vZmZzZXRXaWR0aCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGxpbmUodmlldywgbGluZSwgZXh0cmFNYXJrZXJzKSB7XG4gICAgICAgIGxldCBsb2NhbE1hcmtlcnMgPSBbXTtcbiAgICAgICAgYWR2YW5jZUN1cnNvcih0aGlzLmN1cnNvciwgbG9jYWxNYXJrZXJzLCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoZXh0cmFNYXJrZXJzLmxlbmd0aClcbiAgICAgICAgICAgIGxvY2FsTWFya2VycyA9IGxvY2FsTWFya2Vycy5jb25jYXQoZXh0cmFNYXJrZXJzKTtcbiAgICAgICAgbGV0IGZvckxpbmUgPSB0aGlzLmd1dHRlci5jb25maWcubGluZU1hcmtlcih2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgICAgICBpZiAoZm9yTGluZSlcbiAgICAgICAgICAgIGxvY2FsTWFya2Vycy51bnNoaWZ0KGZvckxpbmUpO1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIGlmIChsb2NhbE1hcmtlcnMubGVuZ3RoID09IDAgJiYgIWd1dHRlci5jb25maWcucmVuZGVyRW1wdHlFbGVtZW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGFib3ZlID0gbGluZS50b3AgLSB0aGlzLmhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuaSA9PSBndXR0ZXIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV3RWx0ID0gbmV3IEd1dHRlckVsZW1lbnQodmlldywgbGluZS5oZWlnaHQsIGFib3ZlLCBsb2NhbE1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgbGluZS5oZWlnaHQsIGFib3ZlLCBsb2NhbE1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbGluZS5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGxldCBndXR0ZXIgPSB0aGlzLmd1dHRlcjtcbiAgICAgICAgd2hpbGUgKGd1dHRlci5lbGVtZW50cy5sZW5ndGggPiB0aGlzLmkpIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gZ3V0dGVyLmVsZW1lbnRzLnBvcCgpO1xuICAgICAgICAgICAgZ3V0dGVyLmRvbS5yZW1vdmVDaGlsZChsYXN0LmRvbSk7XG4gICAgICAgICAgICBsYXN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUd1dHRlclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGNvbmZpZykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnNwYWNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJcIiArICh0aGlzLmNvbmZpZy5jbGFzcyA/IFwiIFwiICsgdGhpcy5jb25maWcuY2xhc3MgOiBcIlwiKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBjb25maWcuZG9tRXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihwcm9wLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0LCB5O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGFyZ2V0LnBhcmVudE5vZGUgIT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdEhlaWdodCh5IC0gdmlldy5kb2N1bWVudFRvcCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kb21FdmVudEhhbmRsZXJzW3Byb3BdKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya2VycyA9IGFzQXJyYXkoY29uZmlnLm1hcmtlcnModmlldykpO1xuICAgICAgICBpZiAoY29uZmlnLmluaXRpYWxTcGFjZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyID0gbmV3IEd1dHRlckVsZW1lbnQodmlldywgMCwgMCwgW2NvbmZpZy5pbml0aWFsU3BhY2VyKHZpZXcpXSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNwYWNlci5kb20pO1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIuZG9tLnN0eWxlLmNzc1RleHQgKz0gXCJ2aXNpYmlsaXR5OiBoaWRkZW47IHBvaW50ZXItZXZlbnRzOiBub25lXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldk1hcmtlcnMgPSB0aGlzLm1hcmtlcnM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IGFzQXJyYXkodGhpcy5jb25maWcubWFya2Vycyh1cGRhdGUudmlldykpO1xuICAgICAgICBpZiAodGhpcy5zcGFjZXIgJiYgdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlZCA9IHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcih0aGlzLnNwYWNlci5tYXJrZXJzWzBdLCB1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZWQgIT0gdGhpcy5zcGFjZXIubWFya2Vyc1swXSlcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlci51cGRhdGUodXBkYXRlLnZpZXcsIDAsIDAsIFt1cGRhdGVkXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZwID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgICAgIHJldHVybiAhUmFuZ2VTZXQuZXEodGhpcy5tYXJrZXJzLCBwcmV2TWFya2VycywgdnAuZnJvbSwgdnAudG8pIHx8XG4gICAgICAgICAgICAodGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSA/IHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UodXBkYXRlKSA6IGZhbHNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuZWxlbWVudHMpXG4gICAgICAgICAgICBlbHQuZGVzdHJveSgpO1xuICAgIH1cbn1cbmNsYXNzIEd1dHRlckVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy5hYm92ZSA9IDA7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyRWxlbWVudFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKTtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IGhlaWdodClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCA9IGhlaWdodCkgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLmFib3ZlICE9IGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSBhYm92ZSkgPyBhYm92ZSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGlmICghc2FtZU1hcmtlcnModGhpcy5tYXJrZXJzLCBtYXJrZXJzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKTtcbiAgICB9XG4gICAgc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCBjbHMgPSBcImNtLWd1dHRlckVsZW1lbnRcIiwgZG9tUG9zID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgaU5ldyA9IDAsIGlPbGQgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBza2lwVG8gPSBpT2xkLCBtYXJrZXIgPSBpTmV3IDwgbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzW2lOZXcrK10gOiBudWxsLCBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBtYXJrZXIuZWxlbWVudENsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCIgKyBjO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpT2xkOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmNvbXBhcmUobWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNraXBUbyA9IHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaU9sZCA8IHNraXBUbykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5tYXJrZXJzW2lPbGQrK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9ET00pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZXN0cm95KGRvbVBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBhZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChtYXJrZXIudG9ET00pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci50b0RPTSh2aWV3KSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgIGlPbGQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7IC8vIEZpcnN0IGFyZ3VtZW50IG5vdCB1c2VkIHVubGVzcyBjcmVhdGluZyBtYXJrZXJzXG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcnMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmNvbXBhcmUoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkZhY2V0IHVzZWQgdG8gcHJvdmlkZSBtYXJrZXJzIHRvIHRoZSBsaW5lIG51bWJlciBndXR0ZXIuXG4qL1xuY29uc3QgbGluZU51bWJlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IHVwZGF0ZSA9PiB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZyksXG4gICAgaW5pdGlhbFNwYWNlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCBtYXhMaW5lTnVtYmVyKHZpZXcuc3RhdGUuZG9jLmxpbmVzKSkpO1xuICAgIH0sXG4gICAgdXBkYXRlU3BhY2VyKHNwYWNlciwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBtYXggPSBmb3JtYXROdW1iZXIodXBkYXRlLnZpZXcsIG1heExpbmVOdW1iZXIodXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVzKSk7XG4gICAgICAgIHJldHVybiBtYXggPT0gc3BhY2VyLm51bWJlciA/IHNwYWNlciA6IG5ldyBOdW1iZXJNYXJrZXIobWF4KTtcbiAgICB9LFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmRvbUV2ZW50SGFuZGxlcnNcbn0pKTtcbi8qKlxuQ3JlYXRlIGEgbGluZSBudW1iZXIgZ3V0dGVyIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBsaW5lTnVtYmVycyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbmVOdW1iZXJDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgZ3V0dGVycygpLFxuICAgICAgICBsaW5lTnVtYmVyR3V0dGVyXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG1heExpbmVOdW1iZXIobGluZXMpIHtcbiAgICBsZXQgbGFzdCA9IDk7XG4gICAgd2hpbGUgKGxhc3QgPCBsaW5lcylcbiAgICAgICAgbGFzdCA9IGxhc3QgKiAxMCArIDk7XG4gICAgcmV0dXJuIGxhc3Q7XG59XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVyTWFya2VyID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxlbWVudENsYXNzID0gXCJjbS1hY3RpdmVMaW5lR3V0dGVyXCI7XG4gICAgfVxufTtcbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9ndXR0ZXJMaW5lQ2xhc3MuY29tcHV0ZShbXCJzZWxlY3Rpb25cIl0sIHN0YXRlID0+IHtcbiAgICBsZXQgbWFya3MgPSBbXSwgbGFzdCA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGxpbmVQb3MgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgICAgIGlmIChsaW5lUG9zID4gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGxpbmVQb3M7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIucmFuZ2UobGluZVBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrcyk7XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXG5hbGwgZ3V0dGVyIGVsZW1lbnRzIG9uIHRoZSBbYWN0aXZlXG5saW5lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyO1xufVxuXG5jb25zdCBXaGl0ZXNwYWNlRGVjbyA9IC8qQF9fUFVSRV9fKi9uZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRXaGl0ZXNwYWNlRGVjbyhzcGFjZSkge1xuICAgIGxldCBkZWNvID0gV2hpdGVzcGFjZURlY28uZ2V0KHNwYWNlKTtcbiAgICBpZiAoIWRlY28pXG4gICAgICAgIFdoaXRlc3BhY2VEZWNvLnNldChzcGFjZSwgZGVjbyA9IERlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzcGFjZSA9PT0gXCJcXHRcIiA/IHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJjbS1oaWdobGlnaHRUYWJcIixcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiY20taGlnaGxpZ2h0U3BhY2VcIixcbiAgICAgICAgICAgICAgICBcImRhdGEtZGlzcGxheVwiOiBzcGFjZS5yZXBsYWNlKC8gL2csIFwiwrdcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIHJldHVybiBkZWNvO1xufVxuZnVuY3Rpb24gbWF0Y2hlcihkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUodmlldyA9PiAoe1xuICAgICAgICBkZWNvcmF0aW9uczogZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyksXG4gICAgICAgIHVwZGF0ZSh1KSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdG9yLnVwZGF0ZURlY28odSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgfSksIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pO1xufVxuY29uc3Qgd2hpdGVzcGFjZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL21hdGNoZXIoLypAX19QVVJFX18qL25ldyBNYXRjaERlY29yYXRvcih7XG4gICAgcmVnZXhwOiAvXFx0fCArL2csXG4gICAgZGVjb3JhdGlvbjogbWF0Y2ggPT4gZ2V0V2hpdGVzcGFjZURlY28obWF0Y2hbMF0pLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWdobGlnaHRzIHdoaXRlc3BhY2UsIGFkZGluZyBhXG5gY20taGlnaGxpZ2h0U3BhY2VgIGNsYXNzIHRvIHN0cmV0Y2hlcyBvZiBzcGFjZXMsIGFuZCBhXG5gY20taGlnaGxpZ2h0VGFiYCBjbGFzcyB0byBpbmRpdmlkdWFsIHRhYiBjaGFyYWN0ZXJzLiBCeSBkZWZhdWx0LFxudGhlIGZvcm1lciBhcmUgc2hvd24gYXMgZmFpbnQgZG90cywgYW5kIHRoZSBsYXR0ZXIgYXMgYXJyb3dzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFdoaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHdoaXRlc3BhY2VIaWdobGlnaHRlcjtcbn1cbmNvbnN0IHRyYWlsaW5nSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHMrJC9nLFxuICAgIGRlY29yYXRpb246IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS10cmFpbGluZ1NwYWNlXCIgfSksXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tdHJhaWxpbmdTcGFjZWAgY2xhc3MgdG8gYWxsXG50cmFpbGluZyB3aGl0ZXNwYWNlLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHJhaWxpbmdIaWdobGlnaHRlcjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3Rlc3QgPSB7IEhlaWdodE1hcCwgSGVpZ2h0T3JhY2xlLCBNZWFzdXJlZEhlaWdodHMsIFF1ZXJ5VHlwZSwgQ2hhbmdlZFJhbmdlLCBjb21wdXRlT3JkZXIsIG1vdmVWaXN1YWxseSB9O1xuXG5leHBvcnQgeyBCaWRpU3BhbiwgQmxvY2tJbmZvLCBCbG9ja1R5cGUsIERlY29yYXRpb24sIERpcmVjdGlvbiwgRWRpdG9yVmlldywgR3V0dGVyTWFya2VyLCBNYXRjaERlY29yYXRvciwgUmVjdGFuZ2xlTWFya2VyLCBWaWV3UGx1Z2luLCBWaWV3VXBkYXRlLCBXaWRnZXRUeXBlLCBfX3Rlc3QsIGNsb3NlSG92ZXJUb29sdGlwcywgY3Jvc3NoYWlyQ3Vyc29yLCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCBnZXRQYW5lbCwgZ2V0VG9vbHRpcCwgZ3V0dGVyLCBndXR0ZXJMaW5lQ2xhc3MsIGd1dHRlcnMsIGhhc0hvdmVyVG9vbHRpcHMsIGhpZ2hsaWdodEFjdGl2ZUxpbmUsIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIsIGhpZ2hsaWdodFNwZWNpYWxDaGFycywgaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlLCBoaWdobGlnaHRXaGl0ZXNwYWNlLCBob3ZlclRvb2x0aXAsIGtleW1hcCwgbGF5ZXIsIGxpbmVOdW1iZXJNYXJrZXJzLCBsaW5lTnVtYmVycywgbG9nRXhjZXB0aW9uLCBwYW5lbHMsIHBsYWNlaG9sZGVyLCByZWN0YW5ndWxhclNlbGVjdGlvbiwgcmVwb3NpdGlvblRvb2x0aXBzLCBydW5TY29wZUhhbmRsZXJzLCBzY3JvbGxQYXN0RW5kLCBzaG93UGFuZWwsIHNob3dUb29sdGlwLCB0b29sdGlwcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/view/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultBufferLength\": () => (/* binding */ DefaultBufferLength),\n/* harmony export */   \"IterMode\": () => (/* binding */ IterMode),\n/* harmony export */   \"MountedTree\": () => (/* binding */ MountedTree),\n/* harmony export */   \"NodeProp\": () => (/* binding */ NodeProp),\n/* harmony export */   \"NodeSet\": () => (/* binding */ NodeSet),\n/* harmony export */   \"NodeType\": () => (/* binding */ NodeType),\n/* harmony export */   \"NodeWeakMap\": () => (/* binding */ NodeWeakMap),\n/* harmony export */   \"Parser\": () => (/* binding */ Parser),\n/* harmony export */   \"Tree\": () => (/* binding */ Tree),\n/* harmony export */   \"TreeBuffer\": () => (/* binding */ TreeBuffer),\n/* harmony export */   \"TreeCursor\": () => (/* binding */ TreeCursor),\n/* harmony export */   \"TreeFragment\": () => (/* binding */ TreeFragment),\n/* harmony export */   \"parseMixed\": () => (/* binding */ parseMixed)\n/* harmony export */ });\n// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n  /// Create a new node prop type.\n  constructor(config = {}) {\n    this.id = nextPropID++;\n    this.perNode = !!config.perNode;\n    this.deserialize = config.deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    });\n  }\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#common.NodeSet.extend) or\n  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  /// prop values for each node type in the set. Takes a [match\n  /// object](#common.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match) {\n    if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n    if (typeof match != \"function\") match = NodeType.match(match);\n    return type => {\n      let result = match(type);\n      return result === undefined ? null : [this, result];\n    };\n  }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({\n  perNode: true\n});\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({\n  perNode: true\n});\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages in mixed-language parsers.\nNodeProp.mounted = new NodeProp({\n  perNode: true\n});\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n  constructor(\n  /// The inner tree.\n  tree,\n  /// If this is null, this tree replaces the entire node (it will\n  /// be included in the regular iteration instead of its host\n  /// node). If not, only the given ranges are considered to be\n  /// covered by this tree. This is used for trees that are mixed in\n  /// a way that isn't strictly hierarchical. Such mounted trees are\n  /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n  /// and [`enter`](#common.SyntaxNode.enter).\n  overlay,\n  /// The parser used to create this subtree.\n  parser) {\n    this.tree = tree;\n    this.overlay = overlay;\n    this.parser = parser;\n  }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n  /// @internal\n  constructor(\n  /// The name of the node type. Not necessarily unique, but if the\n  /// grammar was written properly, different node types with the\n  /// same name within a node set should play the same semantic\n  /// role.\n  name,\n  /// @internal\n  props,\n  /// The id of this node in its set. Corresponds to the term ids\n  /// used in the parser.\n  id,\n  /// @internal\n  flags = 0) {\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n  /// Define a node type.\n  static define(spec) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n    let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) | (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type);\n      if (src) {\n        if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n        props[src[0].id] = src[1];\n      }\n    }\n    return type;\n  }\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop(prop) {\n    return this.props[prop.id];\n  }\n  /// True when this is the top node of a grammar.\n  get isTop() {\n    return (this.flags & 1 /* NodeFlag.Top */) > 0;\n  }\n  /// True when this node is produced by a skip rule.\n  get isSkipped() {\n    return (this.flags & 2 /* NodeFlag.Skipped */) > 0;\n  }\n  /// Indicates whether this is an error node.\n  get isError() {\n    return (this.flags & 4 /* NodeFlag.Error */) > 0;\n  }\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() {\n    return (this.flags & 8 /* NodeFlag.Anonymous */) > 0;\n  }\n  /// Returns true when this node's name or one of its\n  /// [groups](#common.NodeProp^group) matches the given string.\n  is(name) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true;\n      let group = this.prop(NodeProp.group);\n      return group ? group.indexOf(name) > -1 : false;\n    }\n    return this.id == name;\n  }\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#common.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match(map) {\n    let direct = Object.create(null);\n    for (let prop in map) for (let name of prop.split(\" \")) direct[name] = map[prop];\n    return node => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups[i]];\n        if (found) return found;\n      }\n    };\n  }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n  /// The node types in this set, by id.\n  types) {\n    this.types = types;\n    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  }\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method can be created with\n  /// [`NodeProp.add`](#common.NodeProp.add).\n  extend(...props) {\n    let newTypes = [];\n    for (let type of this.types) {\n      let newProps = null;\n      for (let source of props) {\n        let add = source(type);\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props);\n          newProps[add[0].id] = add[1];\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n    }\n    return new NodeSet(newTypes);\n  }\n}\nconst CachedNode = new WeakMap(),\n  CachedInnerNode = new WeakMap();\n/// Options that control iteration. Can be combined with the `|`\n/// operator to enable multiple ones.\nvar IterMode;\n(function (IterMode) {\n  /// When enabled, iteration will only visit [`Tree`](#common.Tree)\n  /// objects, not nodes packed into\n  /// [`TreeBuffer`](#common.TreeBuffer)s.\n  IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n  /// Enable this to make iteration include anonymous nodes (such as\n  /// the nodes that wrap repeated grammar constructs into a balanced\n  /// tree).\n  IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n  /// By default, regular [mounted](#common.NodeProp^mounted) nodes\n  /// replace their base node in iteration. Enable this to ignore them\n  /// instead.\n  IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n  /// This option only applies in\n  /// [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n  /// library to not enter mounted overlays if one covers the given\n  /// position.\n  IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  constructor(\n  /// The type of the top node.\n  type,\n  /// This node's child nodes.\n  children,\n  /// The positions (offsets relative to the start of this tree) of\n  /// the children.\n  positions,\n  /// The total length of this tree\n  length,\n  /// Per-node [node props](#common.NodeProp) to associate with this node.\n  props) {\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length;\n    /// @internal\n    this.props = null;\n    if (props && props.length) {\n      this.props = Object.create(null);\n      for (let [prop, value] of props) this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n    }\n  }\n  /// @internal\n  toString() {\n    let mounted = this.prop(NodeProp.mounted);\n    if (mounted && !mounted.overlay) return mounted.tree.toString();\n    let children = \"\";\n    for (let ch of this.children) {\n      let str = ch.toString();\n      if (str) {\n        if (children) children += \",\";\n        children += str;\n      }\n    }\n    return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n  }\n  /// Get a [tree cursor](#common.TreeCursor) positioned at the top of\n  /// the tree. Mode can be used to [control](#common.IterMode) which\n  /// nodes the cursor visits.\n  cursor(mode = 0) {\n    return new TreeCursor(this.topNode, mode);\n  }\n  /// Get a [tree cursor](#common.TreeCursor) pointing into this tree\n  /// at the given position and side (see\n  /// [`moveTo`](#common.TreeCursor.moveTo).\n  cursorAt(pos, side = 0, mode = 0) {\n    let scope = CachedNode.get(this) || this.topNode;\n    let cursor = new TreeCursor(scope);\n    cursor.moveTo(pos, side);\n    CachedNode.set(this, cursor._tree);\n    return cursor;\n  }\n  /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode() {\n    return new TreeNode(this, 0, 0, null);\n  }\n  /// Get the [syntax node](#common.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  ///\n  /// Note that this will not enter\n  /// [overlays](#common.MountedTree.overlay), and you often want\n  /// [`resolveInner`](#common.Tree.resolveInner) instead.\n  resolve(pos, side = 0) {\n    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n    CachedNode.set(this, node);\n    return node;\n  }\n  /// Like [`resolve`](#common.Tree.resolve), but will enter\n  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n  /// pointing into the innermost overlaid tree at the given position\n  /// (with parent links going through all parent structure, including\n  /// the host trees).\n  resolveInner(pos, side = 0) {\n    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n    CachedInnerNode.set(this, node);\n    return node;\n  }\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, that node will\n  /// not have its children iterated over (or `leave` called).\n  iterate(spec) {\n    let {\n      enter,\n      leave,\n      from = 0,\n      to = this.length\n    } = spec;\n    for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous);;) {\n      let entered = false;\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {\n        if (c.firstChild()) continue;\n        entered = true;\n      }\n      for (;;) {\n        if (entered && leave && !c.type.isAnonymous) leave(c);\n        if (c.nextSibling()) break;\n        if (!c.parent()) return;\n        entered = true;\n      }\n    }\n  }\n  /// Get the value of the given [node prop](#common.NodeProp) for this\n  /// node. Works with both per-node and per-type props.\n  prop(prop) {\n    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n  }\n  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n  /// format that can be passed to the [`Tree`](#common.Tree)\n  /// constructor.\n  get propValues() {\n    let result = [];\n    if (this.props) for (let id in this.props) result.push([+id, this.props[id]]);\n    return result;\n  }\n  /// Balance the direct children of this tree, producing a copy of\n  /// which may have children grouped into subtrees with type\n  /// [`NodeType.none`](#common.NodeType^none).\n  balance(config = {}) {\n    return this.children.length <= 8 /* Balance.BranchFactor */ ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n  }\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data) {\n    return buildTree(data);\n  }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n  constructor(buffer, index) {\n    this.buffer = buffer;\n    this.index = index;\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  get pos() {\n    return this.index;\n  }\n  next() {\n    this.index -= 4;\n  }\n  fork() {\n    return new FlatBufferCursor(this.buffer, this.index);\n  }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it).\nclass TreeBuffer {\n  /// Create a tree buffer.\n  constructor(\n  /// The buffer's content.\n  buffer,\n  /// The total length of the group of nodes in the buffer.\n  length,\n  /// The node set used in this buffer.\n  set) {\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n  }\n  /// @internal\n  get type() {\n    return NodeType.none;\n  }\n  /// @internal\n  toString() {\n    let result = [];\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result.join(\",\");\n  }\n  /// @internal\n  childString(index) {\n    let id = this.buffer[index],\n      endIndex = this.buffer[index + 3];\n    let type = this.set.types[id],\n      result = type.name;\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n    index += 4;\n    if (endIndex == index) return result;\n    let children = [];\n    while (index < endIndex) {\n      children.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result + \"(\" + children.join(\",\") + \")\";\n  }\n  /// @internal\n  findChild(startIndex, endIndex, dir, pos, side) {\n    let {\n        buffer\n      } = this,\n      pick = -1;\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n        pick = i;\n        if (dir > 0) break;\n      }\n    }\n    return pick;\n  }\n  /// @internal\n  slice(startI, endI, from) {\n    let b = this.buffer;\n    let copy = new Uint16Array(endI - startI),\n      len = 0;\n    for (let i = startI, j = 0; i < endI;) {\n      copy[j++] = b[i++];\n      copy[j++] = b[i++] - from;\n      let to = copy[j++] = b[i++] - from;\n      copy[j++] = b[i++] - startI;\n      len = Math.max(len, to);\n    }\n    return new TreeBuffer(copy, len, this.set);\n  }\n}\nfunction checkSide(side, pos, from, to) {\n  switch (side) {\n    case -2 /* Side.Before */:\n      return from < pos;\n    case -1 /* Side.AtOrBefore */:\n      return to >= pos && from < pos;\n    case 0 /* Side.Around */:\n      return from < pos && to > pos;\n    case 1 /* Side.AtOrAfter */:\n      return from <= pos && to > pos;\n    case 2 /* Side.After */:\n      return to > pos;\n    case 4 /* Side.DontCare */:\n      return true;\n  }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n  let scan = node.childBefore(pos);\n  while (scan) {\n    let last = scan.lastChild;\n    if (!last || last.to != scan.to) break;\n    if (last.type.isError && last.from == last.to) {\n      node = scan;\n      scan = last.prevSibling;\n    } else {\n      scan = last;\n    }\n  }\n  return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n  var _a;\n  // Move up to a node that actually holds the position, if possible\n  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {\n    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n    if (!parent) return node;\n    node = parent;\n  }\n  let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n  // Must go up out of overlays when those do not overlap with pos\n  if (overlays) for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n    if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n  }\n  for (;;) {\n    let inner = node.enter(pos, side, mode);\n    if (!inner) return node;\n    node = inner;\n  }\n}\nclass TreeNode {\n  constructor(_tree, from,\n  // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n  index, _parent) {\n    this._tree = _tree;\n    this.from = from;\n    this.index = index;\n    this._parent = _parent;\n  }\n  get type() {\n    return this._tree.type;\n  }\n  get name() {\n    return this._tree.type.name;\n  }\n  get to() {\n    return this.from + this._tree.length;\n  }\n  nextChild(i, dir, pos, side, mode = 0) {\n    for (let parent = this;;) {\n      for (let {\n          children,\n          positions\n        } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i],\n          start = positions[i] + parent.from;\n        if (!checkSide(side, pos, start, start + next.length)) continue;\n        if (next instanceof TreeBuffer) {\n          if (mode & IterMode.ExcludeBuffers) continue;\n          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n        } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n          let mounted;\n          if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n          let inner = new TreeNode(next, start, i, parent);\n          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n        }\n      }\n      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n      if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n      parent = parent._parent;\n      if (!parent) return null;\n    }\n  }\n  get firstChild() {\n    return this.nextChild(0, 1, 0, 4 /* Side.DontCare */);\n  }\n  get lastChild() {\n    return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */);\n  }\n  childAfter(pos) {\n    return this.nextChild(0, 1, pos, 2 /* Side.After */);\n  }\n  childBefore(pos) {\n    return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */);\n  }\n  enter(pos, side, mode = 0) {\n    let mounted;\n    if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {\n      let rPos = pos - this.from;\n      for (let {\n        from,\n        to\n      } of mounted.overlay) {\n        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n      }\n    }\n    return this.nextChild(0, 1, pos, side, mode);\n  }\n  nextSignificantParent() {\n    let val = this;\n    while (val.type.isAnonymous && val._parent) val = val._parent;\n    return val;\n  }\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null;\n  }\n  get nextSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n  }\n  get prevSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n  }\n  cursor(mode = 0) {\n    return new TreeCursor(this, mode);\n  }\n  get tree() {\n    return this._tree;\n  }\n  toTree() {\n    return this._tree;\n  }\n  resolve(pos, side = 0) {\n    return resolveNode(this, pos, side, false);\n  }\n  resolveInner(pos, side = 0) {\n    return resolveNode(this, pos, side, true);\n  }\n  enterUnfinishedNodesBefore(pos) {\n    return enterUnfinishedNodesBefore(this, pos);\n  }\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  }\n  /// @internal\n  toString() {\n    return this._tree.toString();\n  }\n  get node() {\n    return this;\n  }\n  matchContext(context) {\n    return matchNodeContext(this, context);\n  }\n}\nfunction getChildren(node, type, before, after) {\n  let cur = node.cursor(),\n    result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result;\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n  for (let p = node.parent; i >= 0; p = p.parent) {\n    if (!p) return false;\n    if (!p.type.isAnonymous) {\n      if (context[i] && context[i] != p.name) return false;\n      i--;\n    }\n  }\n  return true;\n}\nclass BufferContext {\n  constructor(parent, buffer, index, start) {\n    this.parent = parent;\n    this.buffer = buffer;\n    this.index = index;\n    this.start = start;\n  }\n}\nclass BufferNode {\n  get name() {\n    return this.type.name;\n  }\n  get from() {\n    return this.context.start + this.context.buffer.buffer[this.index + 1];\n  }\n  get to() {\n    return this.context.start + this.context.buffer.buffer[this.index + 2];\n  }\n  constructor(context, _parent, index) {\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n  child(dir, pos, side) {\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n  get firstChild() {\n    return this.child(1, 0, 4 /* Side.DontCare */);\n  }\n  get lastChild() {\n    return this.child(-1, 0, 4 /* Side.DontCare */);\n  }\n  childAfter(pos) {\n    return this.child(1, pos, 2 /* Side.After */);\n  }\n  childBefore(pos) {\n    return this.child(-1, pos, -2 /* Side.Before */);\n  }\n  enter(pos, side, mode = 0) {\n    if (mode & IterMode.ExcludeBuffers) return null;\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent();\n  }\n  externalSibling(dir) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n  }\n\n  get nextSibling() {\n    let {\n      buffer\n    } = this.context;\n    let after = buffer.buffer[this.index + 3];\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n    return this.externalSibling(1);\n  }\n  get prevSibling() {\n    let {\n      buffer\n    } = this.context;\n    let parentStart = this._parent ? this._parent.index + 4 : 0;\n    if (this.index == parentStart) return this.externalSibling(-1);\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n  }\n\n  cursor(mode = 0) {\n    return new TreeCursor(this, mode);\n  }\n  get tree() {\n    return null;\n  }\n  toTree() {\n    let children = [],\n      positions = [];\n    let {\n      buffer\n    } = this.context;\n    let startI = this.index + 4,\n      endI = buffer.buffer[this.index + 3];\n    if (endI > startI) {\n      let from = buffer.buffer[this.index + 1];\n      children.push(buffer.slice(startI, endI, from));\n      positions.push(0);\n    }\n    return new Tree(this.type, children, positions, this.to - this.from);\n  }\n  resolve(pos, side = 0) {\n    return resolveNode(this, pos, side, false);\n  }\n  resolveInner(pos, side = 0) {\n    return resolveNode(this, pos, side, true);\n  }\n  enterUnfinishedNodesBefore(pos) {\n    return enterUnfinishedNodesBefore(this, pos);\n  }\n  /// @internal\n  toString() {\n    return this.context.buffer.childString(this.index);\n  }\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  }\n  get node() {\n    return this;\n  }\n  matchContext(context) {\n    return matchNodeContext(this, context);\n  }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n  /// Shorthand for `.type.name`.\n  get name() {\n    return this.type.name;\n  }\n  /// @internal\n  constructor(node,\n  /// @internal\n  mode = 0) {\n    this.mode = mode;\n    /// @internal\n    this.buffer = null;\n    this.stack = [];\n    /// @internal\n    this.index = 0;\n    this.bufferNode = null;\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  }\n  yieldNode(node) {\n    if (!node) return false;\n    this._tree = node;\n    this.type = node.type;\n    this.from = node.from;\n    this.to = node.to;\n    return true;\n  }\n  yieldBuf(index, type) {\n    this.index = index;\n    let {\n      start,\n      buffer\n    } = this.buffer;\n    this.type = type || buffer.set.types[buffer.buffer[index]];\n    this.from = start + buffer.buffer[index + 1];\n    this.to = start + buffer.buffer[index + 2];\n    return true;\n  }\n  yield(node) {\n    if (!node) return false;\n    if (node instanceof TreeNode) {\n      this.buffer = null;\n      return this.yieldNode(node);\n    }\n    this.buffer = node.context;\n    return this.yieldBuf(node.index, node.type);\n  }\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n  }\n  /// @internal\n  enterChild(dir, pos, side) {\n    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n    let {\n      buffer\n    } = this.buffer;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n    if (index < 0) return false;\n    this.stack.push(this.index);\n    return this.yieldBuf(index);\n  }\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() {\n    return this.enterChild(1, 0, 4 /* Side.DontCare */);\n  }\n  /// Move the cursor to this node's last child.\n  lastChild() {\n    return this.enterChild(-1, 0, 4 /* Side.DontCare */);\n  }\n  /// Move the cursor to the first child that ends after `pos`.\n  childAfter(pos) {\n    return this.enterChild(1, pos, 2 /* Side.After */);\n  }\n  /// Move to the last child that starts before `pos`.\n  childBefore(pos) {\n    return this.enterChild(-1, pos, -2 /* Side.Before */);\n  }\n  /// Move the cursor to the child around `pos`. If side is -1 the\n  /// child may end at that position, when 1 it may start there. This\n  /// will also enter [overlaid](#common.MountedTree.overlay)\n  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n  /// set to false.\n  enter(pos, side, mode = this.mode) {\n    if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n  }\n  /// Move to the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n    if (this.stack.length) return this.yieldBuf(this.stack.pop());\n    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n    this.buffer = null;\n    return this.yieldNode(parent);\n  }\n  /// @internal\n  sibling(dir) {\n    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n    let {\n        buffer\n      } = this.buffer,\n      d = this.stack.length - 1;\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    } else {\n      let after = buffer.buffer[this.index + 3];\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n  }\n  /// Move to this node's next sibling, if any.\n  nextSibling() {\n    return this.sibling(1);\n  }\n  /// Move to this node's previous sibling, if any.\n  prevSibling() {\n    return this.sibling(-1);\n  }\n  atLastNode(dir) {\n    let index,\n      parent,\n      {\n        buffer\n      } = this;\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false;\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;\n      }\n      ({\n        index,\n        parent\n      } = buffer);\n    } else {\n      ({\n        index,\n        _parent: parent\n      } = this._tree);\n    }\n    for (; parent; ({\n      index,\n      _parent: parent\n    } = parent)) {\n      if (index > -1) for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n        let child = parent._tree.children[i];\n        if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n      }\n    }\n    return true;\n  }\n  move(dir, enter) {\n    if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */)) return true;\n    for (;;) {\n      if (this.sibling(dir)) return true;\n      if (this.atLastNode(dir) || !this.parent()) return false;\n    }\n  }\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty or `enter` is false, its next sibling or\n  /// the next sibling of the first parent node that has one.\n  next(enter = true) {\n    return this.move(1, enter);\n  }\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by its last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev(enter = true) {\n    return this.move(-1, enter);\n  }\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos, side = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;\n    // Then scan down into child nodes as far as possible\n    while (this.enterChild(1, pos, side)) {}\n    return this;\n  }\n  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n  /// position.\n  get node() {\n    if (!this.buffer) return this._tree;\n    let cache = this.bufferNode,\n      result = null,\n      depth = 0;\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c;\n          result = c;\n          depth = d + 1;\n          break scan;\n        }\n        index = this.stack[--d];\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n  }\n  /// Get the [tree](#common.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#common.TreeBuffer).\n  get tree() {\n    return this.buffer ? null : this._tree._tree;\n  }\n  /// Iterate over the current node and all its descendants, calling\n  /// `enter` when entering a node and `leave`, if given, when leaving\n  /// one. When `enter` returns `false`, any children of that node are\n  /// skipped, and `leave` isn't called for it.\n  iterate(enter, leave) {\n    for (let depth = 0;;) {\n      let mustLeave = false;\n      if (this.type.isAnonymous || enter(this) !== false) {\n        if (this.firstChild()) {\n          depth++;\n          continue;\n        }\n        if (!this.type.isAnonymous) mustLeave = true;\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(this);\n        mustLeave = this.type.isAnonymous;\n        if (this.nextSibling()) break;\n        if (!depth) return;\n        this.parent();\n        depth--;\n        mustLeave = true;\n      }\n    }\n  }\n  /// Test whether the current node matches a given context—a sequence\n  /// of direct parent node names. Empty strings in the context array\n  /// are treated as wildcards.\n  matchContext(context) {\n    if (!this.buffer) return matchNodeContext(this.node, context);\n    let {\n        buffer\n      } = this.buffer,\n      {\n        types\n      } = buffer.set;\n    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n      if (d < 0) return matchNodeContext(this.node, context, i);\n      let type = types[buffer.buffer[this.stack[d]]];\n      if (!type.isAnonymous) {\n        if (context[i] && context[i] != type.name) return false;\n        i--;\n      }\n    }\n    return true;\n  }\n}\nfunction hasChild(tree) {\n  return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n  var _a;\n  let {\n    buffer,\n    nodeSet,\n    maxBufferLength = DefaultBufferLength,\n    reused = [],\n    minRepeatType = nodeSet.types.length\n  } = data;\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  let types = nodeSet.types;\n  let contextHash = 0,\n    lookAhead = 0;\n  function takeNode(parentStart, minPos, children, positions, inRepeat) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    let lookAheadAtStart = lookAhead;\n    while (size < 0) {\n      cursor.next();\n      if (size == -1 /* SpecialRecord.Reuse */) {\n        let node = reused[id];\n        children.push(node);\n        positions.push(start - parentStart);\n        return;\n      } else if (size == -3 /* SpecialRecord.ContextChange */) {\n        // Context change\n        contextHash = id;\n        return;\n      } else if (size == -4 /* SpecialRecord.LookAhead */) {\n        lookAhead = id;\n        return;\n      } else {\n        throw new RangeError(`Unrecognized record size: ${size}`);\n      }\n    }\n    let type = types[id],\n      node,\n      buffer;\n    let startPos = start - parentStart;\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip);\n      let endPos = cursor.pos - buffer.size,\n        index = data.length;\n      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index);\n      node = new TreeBuffer(data, end - buffer.start, nodeSet);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      let endPos = cursor.pos - size;\n      cursor.next();\n      let localChildren = [],\n        localPositions = [];\n      let localInRepeat = id >= minRepeatType ? id : -1;\n      let lastGroup = 0,\n        lastEnd = end;\n      while (cursor.pos > endPos) {\n        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n          if (cursor.end <= lastEnd - maxBufferLength) {\n            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n            lastGroup = localChildren.length;\n            lastEnd = cursor.end;\n          }\n          cursor.next();\n        } else {\n          takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n        }\n      }\n      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n      localChildren.reverse();\n      localPositions.reverse();\n      if (localInRepeat > -1 && lastGroup > 0) {\n        let make = makeBalanced(type);\n        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n      } else {\n        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n      }\n    }\n    children.push(node);\n    positions.push(startPos);\n  }\n  function makeBalanced(type) {\n    return (children, positions, length) => {\n      let lookAhead = 0,\n        lastI = children.length - 1,\n        last,\n        lookAheadProp;\n      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n        if (!lastI && last.type == type && last.length == length) return last;\n        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n      }\n      return makeTree(type, children, positions, length, lookAhead);\n    };\n  }\n  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n    let localChildren = [],\n      localPositions = [];\n    while (children.length > i) {\n      localChildren.push(children.pop());\n      localPositions.push(positions.pop() + base - from);\n    }\n    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n    positions.push(from - base);\n  }\n  function makeTree(type, children, positions, length, lookAhead = 0, props) {\n    if (contextHash) {\n      let pair = [NodeProp.contextHash, contextHash];\n      props = props ? [pair].concat(props) : [pair];\n    }\n    if (lookAhead > 25) {\n      let pair = [NodeProp.lookAhead, lookAhead];\n      props = props ? [pair].concat(props) : [pair];\n    }\n    return new Tree(type, children, positions, length, props);\n  }\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork();\n    let size = 0,\n      start = 0,\n      skip = 0,\n      minStart = fork.end - maxBufferLength;\n    let result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      let nodeSize = fork.size;\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat && nodeSize >= 0) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n      let startPos = fork.pos - nodeSize;\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      let nodeStart = fork.start;\n      fork.next();\n      while (fork.pos > startPos) {\n        if (fork.size < 0) {\n          if (fork.size == -3 /* SpecialRecord.ContextChange */) localSkipped += 4;else break scan;\n        } else if (fork.id >= minRepeatType) {\n          localSkipped += 4;\n        }\n        fork.next();\n      }\n      start = nodeStart;\n      size += nodeSize;\n      skip += localSkipped;\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n    return result.size > 4 ? result : undefined;\n  }\n  function copyToBuffer(bufferStart, buffer, index) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    cursor.next();\n    if (size >= 0 && id < minRepeatType) {\n      let startIndex = index;\n      if (size > 4) {\n        let endPos = cursor.pos - (size - 4);\n        while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);\n      }\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    } else if (size == -3 /* SpecialRecord.ContextChange */) {\n      contextHash = id;\n    } else if (size == -4 /* SpecialRecord.LookAhead */) {\n      lookAhead = id;\n    }\n    return index;\n  }\n  let children = [],\n    positions = [];\n  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap();\nfunction nodeSize(balanceType, node) {\n  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n  let size = nodeSizeCache.get(node);\n  if (size == null) {\n    size = 1;\n    for (let child of node.children) {\n      if (child.type != balanceType || !(child instanceof Tree)) {\n        size = 1;\n        break;\n      }\n      size += nodeSize(balanceType, child);\n    }\n    nodeSizeCache.set(node, size);\n  }\n  return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType,\n// The direct children and their positions\nchildren, positions,\n// The index range in children/positions to use\nfrom, to,\n// The start position of the nodes, relative to their parent.\nstart,\n// Length of the outer node\nlength,\n// Function to build the top node of the balanced tree\nmkTop,\n// Function to build internal nodes for the balanced tree\nmkTree) {\n  let total = 0;\n  for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i]);\n  let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */);\n  let localChildren = [],\n    localPositions = [];\n  function divide(children, positions, from, to, offset) {\n    for (let i = from; i < to;) {\n      let groupFrom = i,\n        groupStart = positions[i],\n        groupSize = nodeSize(balanceType, children[i]);\n      i++;\n      for (; i < to; i++) {\n        let nextSize = nodeSize(balanceType, children[i]);\n        if (groupSize + nextSize >= maxChild) break;\n        groupSize += nextSize;\n      }\n      if (i == groupFrom + 1) {\n        if (groupSize > maxChild) {\n          let only = children[groupFrom]; // Only trees can have a size > 1\n          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n          continue;\n        }\n        localChildren.push(children[groupFrom]);\n      } else {\n        let length = positions[i - 1] + children[i - 1].length - groupStart;\n        localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n      }\n      localPositions.push(groupStart + offset - start);\n    }\n  }\n  divide(children, positions, from, to, 0);\n  return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/// Provides a way to associate values with pieces of trees. As long\n/// as that part of the tree is reused, the associated values can be\n/// retrieved from an updated tree.\nclass NodeWeakMap {\n  constructor() {\n    this.map = new WeakMap();\n  }\n  setBuffer(buffer, index, value) {\n    let inner = this.map.get(buffer);\n    if (!inner) this.map.set(buffer, inner = new Map());\n    inner.set(index, value);\n  }\n  getBuffer(buffer, index) {\n    let inner = this.map.get(buffer);\n    return inner && inner.get(index);\n  }\n  /// Set the value for this syntax node.\n  set(node, value) {\n    if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);else if (node instanceof TreeNode) this.map.set(node.tree, value);\n  }\n  /// Retrieve value for this syntax node, if it exists in the map.\n  get(node) {\n    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n  }\n  /// Set the value for the node that a cursor currently points to.\n  cursorSet(cursor, value) {\n    if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);else this.map.set(cursor.tree, value);\n  }\n  /// Retrieve the value for the node that a cursor currently points\n  /// to.\n  cursorGet(cursor) {\n    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n  }\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n  /// Construct a tree fragment. You'll usually want to use\n  /// [`addTree`](#common.TreeFragment^addTree) and\n  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n  /// calling this directly.\n  constructor(\n  /// The start of the unchanged range pointed to by this fragment.\n  /// This refers to an offset in the _updated_ document (as opposed\n  /// to the original tree).\n  from,\n  /// The end of the unchanged range.\n  to,\n  /// The tree that this fragment is based on.\n  tree,\n  /// The offset between the fragment's tree and the document that\n  /// this fragment can be used against. Add this when going from\n  /// document to tree positions, subtract it to go from tree to\n  /// document positions.\n  offset, openStart = false, openEnd = false) {\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n  }\n  /// Whether the start of the fragment represents the start of a\n  /// parse, or the end of a change. (In the second case, it may not\n  /// be safe to reuse some nodes at the start, depending on the\n  /// parsing algorithm.)\n  get openStart() {\n    return (this.open & 1 /* Open.Start */) > 0;\n  }\n  /// Whether the end of the fragment represents the end of a\n  /// full-document parse, or the start of a change.\n  get openEnd() {\n    return (this.open & 2 /* Open.End */) > 0;\n  }\n  /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the resulting\n  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n  /// true.\n  static addTree(tree, fragments = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n    for (let f of fragments) if (f.to > tree.length) result.push(f);\n    return result;\n  }\n  /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n  static applyChanges(fragments, changes, minGap = 128) {\n    if (!changes.length) return fragments;\n    let result = [];\n    let fI = 1,\n      nextF = fragments.length ? fragments[0] : null;\n    for (let cI = 0, pos = 0, off = 0;; cI++) {\n      let nextC = cI < changes.length ? changes[cI] : null;\n      let nextPos = nextC ? nextC.fromA : 1e9;\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut = nextF;\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off,\n            fTo = Math.min(cut.to, nextPos) - off;\n          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n        }\n        if (cut) result.push(cut);\n        if (nextF.to > nextPos) break;\n        nextF = fI < fragments.length ? fragments[fI++] : null;\n      }\n      if (!nextC) break;\n      pos = nextC.toA;\n      off = nextC.toA - nextC.toB;\n    }\n    return result;\n  }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n  /// Start a parse, returning a [partial parse](#common.PartialParse)\n  /// object. [`fragments`](#common.TreeFragment) can be passed in to\n  /// make the parse incremental.\n  ///\n  /// By default, the entire input is parsed. You can pass `ranges`,\n  /// which should be a sorted array of non-empty, non-overlapping\n  /// ranges, to parse only those ranges. The tree returned in that\n  /// case will start at `ranges[0].from`.\n  startParse(input, fragments, ranges) {\n    if (typeof input == \"string\") input = new StringInput(input);\n    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n    return this.createParse(input, fragments || [], ranges);\n  }\n  /// Run a full parse, returning the resulting tree.\n  parse(input, fragments, ranges) {\n    let parse = this.startParse(input, fragments, ranges);\n    for (;;) {\n      let done = parse.advance();\n      if (done) return done;\n    }\n  }\n}\nclass StringInput {\n  constructor(string) {\n    this.string = string;\n  }\n  get length() {\n    return this.string.length;\n  }\n  chunk(from) {\n    return this.string.slice(from);\n  }\n  get lineChunks() {\n    return false;\n  }\n  read(from, to) {\n    return this.string.slice(from, to);\n  }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\nfunction parseMixed(nest) {\n  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n  constructor(parser, parse, overlay, target, ranges) {\n    this.parser = parser;\n    this.parse = parse;\n    this.overlay = overlay;\n    this.target = target;\n    this.ranges = ranges;\n  }\n}\nclass ActiveOverlay {\n  constructor(parser, predicate, mounts, index, start, target, prev) {\n    this.parser = parser;\n    this.predicate = predicate;\n    this.mounts = mounts;\n    this.index = index;\n    this.start = start;\n    this.target = target;\n    this.prev = prev;\n    this.depth = 0;\n    this.ranges = [];\n  }\n}\nconst stoppedInner = new NodeProp({\n  perNode: true\n});\nclass MixedParse {\n  constructor(base, nest, input, fragments, ranges) {\n    this.nest = nest;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.inner = [];\n    this.innerDone = 0;\n    this.baseTree = null;\n    this.stoppedAt = null;\n    this.baseParse = base;\n  }\n  advance() {\n    if (this.baseParse) {\n      let done = this.baseParse.advance();\n      if (!done) return null;\n      this.baseParse = null;\n      this.baseTree = done;\n      this.startInner();\n      if (this.stoppedAt != null) for (let inner of this.inner) inner.parse.stopAt(this.stoppedAt);\n    }\n    if (this.innerDone == this.inner.length) {\n      let result = this.baseTree;\n      if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n      return result;\n    }\n    let inner = this.inner[this.innerDone],\n      done = inner.parse.advance();\n    if (done) {\n      this.innerDone++;\n      // This is a somewhat dodgy but super helpful hack where we\n      // patch up nodes created by the inner parse (and thus\n      // presumably not aliased anywhere else) to hold the information\n      // about the inner parse.\n      let props = Object.assign(Object.create(null), inner.target.props);\n      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n      inner.target.props = props;\n    }\n    return null;\n  }\n  get parsedPos() {\n    if (this.baseParse) return 0;\n    let pos = this.input.length;\n    for (let i = this.innerDone; i < this.inner.length; i++) {\n      if (this.inner[i].ranges[0].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n    }\n    return pos;\n  }\n  stopAt(pos) {\n    this.stoppedAt = pos;\n    if (this.baseParse) this.baseParse.stopAt(pos);else for (let i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos);\n  }\n  startInner() {\n    let fragmentCursor = new FragmentCursor(this.fragments);\n    let overlay = null;\n    let covered = null;\n    let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n      let enter = true,\n        range;\n      if (fragmentCursor.hasNode(cursor)) {\n        if (overlay) {\n          let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n          if (match) for (let r of match.mount.overlay) {\n            let from = r.from + match.pos,\n              to = r.to + match.pos;\n            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from)) overlay.ranges.push({\n              from,\n              to\n            });\n          }\n        }\n        enter = false;\n      } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n        enter = isCovered != 2 /* Cover.Full */;\n      } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n        if (!cursor.tree) materialize(cursor);\n        let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n        if (typeof nest.overlay == \"function\") {\n          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n        } else {\n          let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n          if (ranges.length) this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n          if (!nest.overlay) enter = false;else if (ranges.length) covered = {\n            ranges,\n            depth: 0,\n            prev: covered\n          };\n        }\n      } else if (overlay && (range = overlay.predicate(cursor))) {\n        if (range === true) range = new Range(cursor.from, cursor.to);\n        if (range.from < range.to) overlay.ranges.push(range);\n      }\n      if (enter && cursor.firstChild()) {\n        if (overlay) overlay.depth++;\n        if (covered) covered.depth++;\n      } else {\n        for (;;) {\n          if (cursor.nextSibling()) break;\n          if (!cursor.parent()) break scan;\n          if (overlay && ! --overlay.depth) {\n            let ranges = punchRanges(this.ranges, overlay.ranges);\n            if (ranges.length) this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n            overlay = overlay.prev;\n          }\n          if (covered && ! --covered.depth) covered = covered.prev;\n        }\n      }\n    }\n  }\n}\nfunction checkCover(covered, from, to) {\n  for (let range of covered) {\n    if (range.from >= to) break;\n    if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n  }\n\n  return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n  if (startI < endI) {\n    let from = buf.buffer[startI + 1];\n    nodes.push(buf.slice(startI, endI, from));\n    positions.push(from - off);\n  }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n  let {\n      node\n    } = cursor,\n    depth = 0;\n  // Scan up to the nearest tree\n  do {\n    cursor.parent();\n    depth++;\n  } while (!cursor.tree);\n  // Find the index of the buffer in that tree\n  let i = 0,\n    base = cursor.tree,\n    off = 0;\n  for (;; i++) {\n    off = base.positions[i] + cursor.from;\n    if (off <= node.from && off + base.children[i].length >= node.to) break;\n  }\n  let buf = base.children[i],\n    b = buf.buffer;\n  // Split a level in the buffer, putting the nodes before and after\n  // the child that contains `node` into new buffers.\n  function split(startI, endI, type, innerOffset, length) {\n    let i = startI;\n    while (b[i + 2] + off <= node.from) i = b[i + 3];\n    let children = [],\n      positions = [];\n    sliceBuf(buf, startI, i, children, positions, innerOffset);\n    let from = b[i + 1],\n      to = b[i + 2];\n    let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n    children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n    positions.push(from - innerOffset);\n    sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n    return new Tree(type, children, positions, length);\n  }\n  base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n  // Move the cursor back to the target node\n  for (let d = 0; d <= depth; d++) cursor.childAfter(node.from);\n}\nclass StructureCursor {\n  constructor(root, offset) {\n    this.offset = offset;\n    this.done = false;\n    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n  }\n  // Move to the first node (in pre-order) that starts at or after `pos`.\n  moveTo(pos) {\n    let {\n        cursor\n      } = this,\n      p = pos - this.offset;\n    while (!this.done && cursor.from < p) {\n      if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;else if (!cursor.next(false)) this.done = true;\n    }\n  }\n  hasNode(cursor) {\n    this.moveTo(cursor.from);\n    if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n      for (let tree = this.cursor.tree;;) {\n        if (tree == cursor.tree) return true;\n        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;\n      }\n    }\n    return false;\n  }\n}\nclass FragmentCursor {\n  constructor(fragments) {\n    var _a;\n    this.fragments = fragments;\n    this.curTo = 0;\n    this.fragI = 0;\n    if (fragments.length) {\n      let first = this.curFrag = fragments[0];\n      this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n      this.inner = new StructureCursor(first.tree, -first.offset);\n    } else {\n      this.curFrag = this.inner = null;\n    }\n  }\n  hasNode(node) {\n    while (this.curFrag && node.from >= this.curTo) this.nextFrag();\n    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n  }\n  nextFrag() {\n    var _a;\n    this.fragI++;\n    if (this.fragI == this.fragments.length) {\n      this.curFrag = this.inner = null;\n    } else {\n      let frag = this.curFrag = this.fragments[this.fragI];\n      this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n      this.inner = new StructureCursor(frag.tree, -frag.offset);\n    }\n  }\n  findMounts(pos, parser) {\n    var _a;\n    let result = [];\n    if (this.inner) {\n      this.inner.cursor.moveTo(pos, 1);\n      for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n        let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n        if (mount && mount.parser == parser) {\n          for (let i = this.fragI; i < this.fragments.length; i++) {\n            let frag = this.fragments[i];\n            if (frag.from >= pos.to) break;\n            if (frag.tree == this.curFrag.tree) result.push({\n              frag,\n              pos: pos.from - frag.offset,\n              mount\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }\n}\nfunction punchRanges(outer, ranges) {\n  let copy = null,\n    current = ranges;\n  for (let i = 1, j = 0; i < outer.length; i++) {\n    let gapFrom = outer[i - 1].to,\n      gapTo = outer[i].from;\n    for (; j < current.length; j++) {\n      let r = current[j];\n      if (r.from >= gapTo) break;\n      if (r.to <= gapFrom) continue;\n      if (!copy) current = copy = ranges.slice();\n      if (r.from < gapFrom) {\n        copy[j] = new Range(r.from, gapFrom);\n        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n      } else if (r.to > gapTo) {\n        copy[j--] = new Range(gapTo, r.to);\n      } else {\n        copy.splice(j--, 1);\n      }\n    }\n  }\n  return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n  let iA = 0,\n    iB = 0,\n    inA = false,\n    inB = false,\n    pos = -1e9;\n  let result = [];\n  for (;;) {\n    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n    if (inA != inB) {\n      let start = Math.max(pos, from),\n        end = Math.min(nextA, nextB, to);\n      if (start < end) result.push(new Range(start, end));\n    }\n    pos = Math.min(nextA, nextB);\n    if (pos == 1e9) break;\n    if (nextA == pos) {\n      if (!inA) inA = true;else {\n        inA = false;\n        iA++;\n      }\n    }\n    if (nextB == pos) {\n      if (!inB) inB = true;else {\n        inB = false;\n        iB++;\n      }\n    }\n  }\n  return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n  let result = [];\n  for (let {\n    pos,\n    mount,\n    frag\n  } of mounts) {\n    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),\n      endPos = startPos + mount.tree.length;\n    let from = Math.max(frag.from, startPos),\n      to = Math.min(frag.to, endPos);\n    if (mount.overlay) {\n      let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n      let changes = findCoverChanges(ranges, overlay, from, to);\n      for (let i = 0, pos = from;; i++) {\n        let last = i == changes.length,\n          end = last ? to : changes[i].from;\n        if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n        if (last) break;\n        pos = changes[i].to;\n      }\n    } else {\n      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n    }\n  }\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BsZXplci9jb21tb24vZGlzdC9pbmRleC5qcz85NjY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZJWE1FIHByb2ZpbGUgYWRkaW5nIGEgcGVyLVRyZWUgVHJlZU5vZGUgY2FjaGUsIHZhbGlkYXRpbmcgaXQgYnlcbi8vIHBhcmVudCBwb2ludGVyXG4vLy8gVGhlIGRlZmF1bHQgbWF4aW11bSBsZW5ndGggb2YgYSBgVHJlZUJ1ZmZlcmAgbm9kZS5cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vLy8gRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG4vLy8gY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuLy8vIGNsYXNzIHJlcHJlc2VudCBwcm9wIG5hbWVzLlxuY2xhc3MgTm9kZVByb3Age1xuICAgIC8vLyBDcmVhdGUgYSBuZXcgbm9kZSBwcm9wIHR5cGUuXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vLyBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIC8vLyBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbiAgICAvLy8gW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgLy8vIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIC8vLyBvYmplY3RdKCNjb21tb24uTm9kZVR5cGVebWF0Y2gpIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB1bmRlZmluZWRcbiAgICAvLy8gaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgLy8vIGl0IGRvZXMuXG4gICAgYWRkKG1hdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoICE9IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG1hdGNoID0gTm9kZVR5cGUubWF0Y2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtYXRjaCh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbdGhpcywgcmVzdWx0XTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLy8gUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbi8vLyBkZWxpbWl0ZXJzLCB0aGlzIGhvbGRzIGFuIGFycmF5IG9mIG5vZGUgbmFtZXMgKHdyaXR0ZW4gYXMgYVxuLy8vIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbi8vLyBmb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaW52ZXJzZSBvZiBbYGNsb3NlZEJ5YF0oI2NvbW1vbi5Ob2RlUHJvcF5jbG9zZWRCeSkuIFRoaXMgaXNcbi8vLyBhdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xuLy8vIG9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLy8vIFVzZWQgdG8gYXNzaWduIG5vZGUgdHlwZXMgdG8gZ3JvdXBzIChmb3IgZXhhbXBsZSwgYWxsIG5vZGVcbi8vLyB0eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG4vLy8gYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8vLyBUaGUgaGFzaCBvZiB0aGUgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlci5jb25zdHJ1Y3Rvcilcbi8vLyB0aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuLy8vIGNvbnRleHR1YWwgbm9kZXMuXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhlIGRpc3RhbmNlIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBub2RlIHRoYXQgdGhlIHRva2VuaXplclxuLy8vIGxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG4vLy8gcGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG4vLy8gZWZmaWNpZW5jeSByZWFzb25zLilcbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vLy8gVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxuLy8vIG5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbi8vLyBkaWZmZXJlbnQgbGFuZ3VhZ2VzIGluIG1peGVkLWxhbmd1YWdlIHBhcnNlcnMuXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8vLyBBIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbi8vLyBhIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxuLy8vIHJlcHJlc2VudGVkIGJ5IGFub3RoZXIgdHJlZS5cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIGlubmVyIHRyZWUuXG4gICAgdHJlZSwgXG4gICAgLy8vIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIC8vLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVndWxhciBpdGVyYXRpb24gaW5zdGVhZCBvZiBpdHMgaG9zdFxuICAgIC8vLyBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLy8gY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICAvLy8gYSB3YXkgdGhhdCBpc24ndCBzdHJpY3RseSBoaWVyYXJjaGljYWwuIFN1Y2ggbW91bnRlZCB0cmVlcyBhcmVcbiAgICAvLy8gb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICAvLy8gYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgIG92ZXJsYXksIFxuICAgIC8vLyBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxufVxuY29uc3Qgbm9Qcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vLy8gRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvLy8gQGludGVybmFsXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICAvLy8gZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICAvLy8gc2FtZSBuYW1lIHdpdGhpbiBhIG5vZGUgc2V0IHNob3VsZCBwbGF5IHRoZSBzYW1lIHNlbWFudGljXG4gICAgLy8vIHJvbGUuXG4gICAgbmFtZSwgXG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHByb3BzLCBcbiAgICAvLy8gVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICAvLy8gdXNlZCBpbiB0aGUgcGFyc2VyLlxuICAgIGlkLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgZmxhZ3MgPSAwKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBOb2RlRmxhZy5Ub3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZXMgYSBub2RlIHByb3AgZm9yIHRoaXMgdHlwZS4gV2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWZcbiAgICAvLy8gdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIGlzIHRoZSB0b3Agbm9kZSBvZiBhIGdyYW1tYXIuXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLy8vIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgZ2V0IGlzU2tpcHBlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBOb2RlRmxhZy5Ta2lwcGVkICovKSA+IDA7IH1cbiAgICAvLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIE5vZGVGbGFnLkVycm9yICovKSA+IDA7IH1cbiAgICAvLy8gV2hlbiB0cnVlLCB0aGlzIG5vZGUgdHlwZSBkb2Vzbid0IGNvcnJlc3BvbmQgdG8gYSB1c2VyLWRlY2xhcmVkXG4gICAgLy8vIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8vLyBSZXR1cm5zIHRydWUgd2hlbiB0aGlzIG5vZGUncyBuYW1lIG9yIG9uZSBvZiBpdHNcbiAgICAvLy8gW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLy8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gICAgLy8vIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgLy8vIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgLy8vIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICAgIC8vLyBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICAvLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICBzdGF0aWMgbWF0Y2gobWFwKSB7XG4gICAgICAgIGxldCBkaXJlY3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1hcClcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICAgICAgZGlyZWN0W25hbWVdID0gbWFwW3Byb3BdO1xuICAgICAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwcyA9IG5vZGUucHJvcChOb2RlUHJvcC5ncm91cCksIGkgPSAtMTsgaSA8IChncm91cHMgPyBncm91cHMubGVuZ3RoIDogMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGRpcmVjdFtpIDwgMCA/IG5vZGUubmFtZSA6IGdyb3Vwc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuLy8vIEFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8vLyBBIG5vZGUgc2V0IGhvbGRzIGEgY29sbGVjdGlvbiBvZiBub2RlIHR5cGVzLiBJdCBpcyB1c2VkIHRvXG4vLy8gY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG4vLy8gZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuLy8vIFtoYXNdKCNsci5MUlBhcnNlci5ub2RlU2V0KSBhIG5vZGUgc2V0LCBhbmQgW3RyZWVcbi8vLyBidWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG4vLy8gZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbi8vLyB0eXBlcyBpbiBpdCwgc28gdGhhdCB0aGUgaWRzIGZpdCBpbnRvIDE2LWJpdCB0eXBlZCBhcnJheSBzbG90cy5cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8vLyBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgICAvLy8gdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIG5vZGUgdHlwZXMgaW4gdGhpcyBzZXQsIGJ5IGlkLlxuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICAvLy8gYXJndW1lbnRzIHRvIHRoaXMgbWV0aG9kIGNhbiBiZSBjcmVhdGVkIHdpdGhcbiAgICAvLy8gW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vLy8gT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG4vLy8gb3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLy8vIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgLy8vIG9iamVjdHMsIG5vdCBub2RlcyBwYWNrZWQgaW50b1xuICAgIC8vLyBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLy8vIEVuYWJsZSB0aGlzIHRvIG1ha2UgaXRlcmF0aW9uIGluY2x1ZGUgYW5vbnltb3VzIG5vZGVzIChzdWNoIGFzXG4gICAgLy8vIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIC8vLyB0cmVlKS5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkluY2x1ZGVBbm9ueW1vdXNcIl0gPSAyXSA9IFwiSW5jbHVkZUFub255bW91c1wiO1xuICAgIC8vLyBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgLy8vIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICAvLy8gaW5zdGVhZC5cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvLy8gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgLy8vIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLXN0eWxlIG1ldGhvZHMuIEl0IHRlbGxzIHRoZVxuICAgIC8vLyBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgLy8vIHBvc2l0aW9uLlxuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSWdub3JlT3ZlcmxheXNcIl0gPSA4XSA9IFwiSWdub3JlT3ZlcmxheXNcIjtcbn0pKEl0ZXJNb2RlIHx8IChJdGVyTW9kZSA9IHt9KSk7XG4vLy8gQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG4vLy8gdHJlZXM6IHRoZSB3YXkgdGhleSBhcmUgYWN0dWFsbHkgc3RvcmVkIGluIG1lbW9yeSwgYW5kIHRoZVxuLy8vIGNvbnZlbmllbnQgd2F5LlxuLy8vXG4vLy8gU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG4vLy8gb2JqZWN0cy4gQnkgcGFja2luZyBkZXRhaWwgaW5mb3JtYXRpb24gaW50byBgVHJlZUJ1ZmZlcmAgbGVhZlxuLy8vIG5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG4vLy9cbi8vLyBIb3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG4vLy8gcmVwcmVzZW50YXRpb24gaXMgdmVyeSBhd2t3YXJkLCBzbyBtb3N0IGNsaWVudCBjb2RlIHdpbGwgd2FudCB0b1xuLy8vIHVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuLy8vIFtgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG4vLy8gYSB2aWV3IG9uIHNvbWUgcGFydCBvZiB0aGlzIGRhdGEgc3RydWN0dXJlLCBhbmQgY2FuIGJlIHVzZWQgdG9cbi8vLyBtb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbmNsYXNzIFRyZWUge1xuICAgIC8vLyBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHR5cGUgb2YgdGhlIHRvcCBub2RlLlxuICAgIHR5cGUsIFxuICAgIC8vLyBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICBjaGlsZHJlbiwgXG4gICAgLy8vIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICAvLy8gdGhlIGNoaWxkcmVuLlxuICAgIHBvc2l0aW9ucywgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gUGVyLW5vZGUgW25vZGUgcHJvcHNdKCNjb21tb24uTm9kZVByb3ApIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgbm9kZS5cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSB0aGlzLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gbW91bnRlZC50cmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSBjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gXCIsXCI7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdGhpcy50eXBlLm5hbWUgPyBjaGlsZHJlbiA6XG4gICAgICAgICAgICAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICtcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyBjaGlsZHJlbiArIFwiKVwiIDogXCJcIik7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgLy8vIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIC8vLyBub2RlcyB0aGUgY3Vyc29yIHZpc2l0cy5cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICAvLy8gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlIChzZWVcbiAgICAvLy8gW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLy8vIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gICAgLy8vIHRyZWUuXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgLy8vIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICAvLy8gcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIC8vLyBwb3NpdGlvbi4gV2l0aCAwLCBpdCdsbCBvbmx5IGVudGVyIG5vZGVzIHRoYXQgY292ZXIgdGhlIHBvc2l0aW9uXG4gICAgLy8vIGZyb20gYm90aCBzaWRlcy5cbiAgICAvLy9cbiAgICAvLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICAvLy8gW292ZXJsYXlzXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpLCBhbmQgeW91IG9mdGVuIHdhbnRcbiAgICAvLy8gW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIExpa2UgW2ByZXNvbHZlYF0oI2NvbW1vbi5UcmVlLnJlc29sdmUpLCBidXQgd2lsbCBlbnRlclxuICAgIC8vLyBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgLy8vIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgIC8vLyAod2l0aCBwYXJlbnQgbGlua3MgZ29pbmcgdGhyb3VnaCBhbGwgcGFyZW50IHN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gICAgLy8vIHRoZSBob3N0IHRyZWVzKS5cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLy8vIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIC8vLyBub2RlIHRoYXQgdG91Y2hlcyB0aGUgYGZyb21gL2B0b2AgcmVnaW9uIChpZiBnaXZlbikgYmVmb3JlXG4gICAgLy8vIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICAvLy8gbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICAvLy8gbm90IGhhdmUgaXRzIGNoaWxkcmVuIGl0ZXJhdGVkIG92ZXIgKG9yIGBsZWF2ZWAgY2FsbGVkKS5cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKChzcGVjLm1vZGUgfHwgMCkgfCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJlZCAmJiBsZWF2ZSAmJiAhYy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICAvLy8gbm9kZS4gV29ya3Mgd2l0aCBib3RoIHBlci1ub2RlIGFuZCBwZXItdHlwZSBwcm9wcy5cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLy8gUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgLy8vIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICAvLy8gY29uc3RydWN0b3IuXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vLyBCYWxhbmNlIHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyB0cmVlLCBwcm9kdWNpbmcgYSBjb3B5IG9mXG4gICAgLy8vIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICAvLy8gW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICBiYWxhbmNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovID8gdGhpcyA6XG4gICAgICAgICAgICBiYWxhbmNlUmFuZ2UoTm9kZVR5cGUubm9uZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5wb3NpdGlvbnMsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCAwLCB0aGlzLmxlbmd0aCwgKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHRoaXMucHJvcFZhbHVlcyksIGNvbmZpZy5tYWtlVHJlZSB8fCAoKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLy8gQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgLy8vIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICBzdGF0aWMgYnVpbGQoZGF0YSkgeyByZXR1cm4gYnVpbGRUcmVlKGRhdGEpOyB9XG59XG4vLy8gVGhlIGVtcHR5IHRyZWVcblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8vLyBUcmVlIGJ1ZmZlcnMgY29udGFpbiAodHlwZSwgc3RhcnQsIGVuZCwgZW5kSW5kZXgpIHF1YWRzIGZvciBlYWNoXG4vLy8gbm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbi8vLyBiZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuLy8vIGNoaWxkcmVuIGJlbG9uZyB0byBpdCkuXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvLy8gQ3JlYXRlIGEgdHJlZSBidWZmZXIuXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8vIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgIGJ1ZmZlciwgXG4gICAgLy8vIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgbGVuZ3RoLCBcbiAgICAvLy8gVGhlIG5vZGUgc2V0IHVzZWQgaW4gdGhpcyBidWZmZXIuXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIE5vZGVUeXBlLm5vbmU7IH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIGZpbmRDaGlsZChzdGFydEluZGV4LCBlbmRJbmRleCwgZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLCBwaWNrID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpICE9IGVuZEluZGV4OyBpID0gYnVmZmVyW2kgKyAzXSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrU2lkZShzaWRlLCBwb3MsIGJ1ZmZlcltpICsgMV0sIGJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNrO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCBsZW4sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIFNpZGUuQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBTaWRlLkF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIFNpZGUuQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBTaWRlLkFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShub2RlLCBwb3MpIHtcbiAgICBsZXQgc2NhbiA9IG5vZGUuY2hpbGRCZWZvcmUocG9zKTtcbiAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICBsZXQgbGFzdCA9IHNjYW4ubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChsYXN0LnR5cGUuaXNFcnJvciAmJiBsYXN0LmZyb20gPT0gbGFzdC50bykge1xuICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgcG9zLCBzaWRlLCBvdmVybGF5cykge1xuICAgIHZhciBfYTtcbiAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICB3aGlsZSAobm9kZS5mcm9tID09IG5vZGUudG8gfHxcbiAgICAgICAgKHNpZGUgPCAxID8gbm9kZS5mcm9tID49IHBvcyA6IG5vZGUuZnJvbSA+IHBvcykgfHxcbiAgICAgICAgKHNpZGUgPiAtMSA/IG5vZGUudG8gPD0gcG9zIDogbm9kZS50byA8IHBvcykpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICFvdmVybGF5cyAmJiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgbm9kZS5pbmRleCA8IDAgPyBudWxsIDogbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGxldCBtb2RlID0gb3ZlcmxheXMgPyAwIDogSXRlck1vZGUuSWdub3JlT3ZlcmxheXM7XG4gICAgLy8gTXVzdCBnbyB1cCBvdXQgb2Ygb3ZlcmxheXMgd2hlbiB0aG9zZSBkbyBub3Qgb3ZlcmxhcCB3aXRoIHBvc1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgZm9yIChsZXQgc2NhbiA9IG5vZGUsIHBhcmVudCA9IHNjYW4ucGFyZW50OyBwYXJlbnQ7IHNjYW4gPSBwYXJlbnQsIHBhcmVudCA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NhbiBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHNjYW4uaW5kZXggPCAwICYmICgoX2EgPSBwYXJlbnQuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZyb20pICE9IHNjYW4uZnJvbSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgaW5uZXIgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgbW9kZSk7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wcm9wcyAmJiAobW91bnRlZCA9IG5leHQucHJvcChOb2RlUHJvcC5tb3VudGVkKSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gdGhpcy5fdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgZ2V0Q2hpbGQodHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIGxldCByID0gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICAgIHJldHVybiByLmxlbmd0aCA/IHJbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXRDaGlsZHJlbih0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgIH1cbiAgICAvLy8gQGludGVybmFsXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkgeyByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTsgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSwgdHlwZSwgYmVmb3JlLCBhZnRlcikge1xuICAgIGxldCBjdXIgPSBub2RlLmN1cnNvcigpLCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWN1ci5maXJzdENoaWxkKCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKGJlZm9yZSAhPSBudWxsKVxuICAgICAgICB3aGlsZSAoIWN1ci50eXBlLmlzKGJlZm9yZSkpXG4gICAgICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudDsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBjdXJzb3IobW9kZSA9IDApIHsgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMsIG1vZGUpOyB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiBudWxsOyB9XG4gICAgdG9UcmVlKCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc3RhcnRJID0gdGhpcy5pbmRleCArIDQsIGVuZEkgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgaWYgKGVuZEkgPiBzdGFydEkpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1ZmZlci5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbiAgICByZXNvbHZlKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7IHJldHVybiBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSh0aGlzLCBwb3MpOyB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHsgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcywgY29udGV4dCk7IH1cbn1cbi8vLyBBIHRyZWUgY3Vyc29yIG9iamVjdCBmb2N1c2VzIG9uIGEgZ2l2ZW4gbm9kZSBpbiBhIHN5bnRheCB0cmVlLCBhbmRcbi8vLyBhbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG5jbGFzcyBUcmVlQ3Vyc29yIHtcbiAgICAvLy8gU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvLy8gQGludGVybmFsXG4gICAgbW9kZSA9IDApIHtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmVlID0gbm9kZS5jb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbm9kZS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IG5vZGUuX3BhcmVudDsgbjsgbiA9IG4uX3BhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnVuc2hpZnQobi5pbmRleCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy55aWVsZEJ1Zihub2RlLmluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB5aWVsZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBub2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IG5vZGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IG5vZGUudG87XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB5aWVsZEJ1ZihpbmRleCwgdHlwZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5zZXQudHlwZXNbYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgICAgICB0aGlzLmZyb20gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAxXTtcbiAgICAgICAgdGhpcy50byA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDJdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLiBXaGVuIHRoaXMgcmV0dXJuc1xuICAgIC8vLyBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLlxuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8vLyBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICBjaGlsZEFmdGVyKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvLy8gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gICAgLy8vIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIC8vLyB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgLy8vIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gICAgLy8vIHNldCB0byBmYWxzZS5cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5fdHJlZS5fcGFyZW50IDogdGhpcy5fdHJlZS5wYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLy8vIEBpbnRlcm5hbFxuICAgIHNpYmxpbmcoZGlyKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3RyZWUuX3BhcmVudCA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuaW5kZXggPCAwID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX3RyZWUuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5fdHJlZS5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gZCA8IDAgPyAwIDogdGhpcy5zdGFja1tkXSArIDQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCAhPSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgICAgICAgIGlmIChhZnRlciA8IChkIDwgMCA/IGJ1ZmZlci5idWZmZXIubGVuZ3RoIDogYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdICsgM10pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZCA8IDAgPyB0aGlzLnlpZWxkKHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0Q2hpbGQodGhpcy5idWZmZXIuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvLy8gTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8vLyBNb3ZlIHRvIHRoaXMgbm9kZSdzIHByZXZpb3VzIHNpYmxpbmcsIGlmIGFueS5cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuX3RyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyLCBlbnRlcikge1xuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vLyBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIC8vLyBbcHJlLW9yZGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmVlX3RyYXZlcnNhbCNQcmUtb3JkZXIsX05MUilcbiAgICAvLy8gdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIC8vLyBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIC8vLyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnQgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvLy8gTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICAvLy8gbm9kZSBpcyBmb2xsb3dlZCBieSBpdHMgbGFzdCBjaGlsZCBvciwgaWYgaXQgaGFzIG5vbmUsIGl0c1xuICAgIC8vLyBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAvLy8gbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgcHJldihlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgtMSwgZW50ZXIpOyB9XG4gICAgLy8vIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgLy8vIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICAvLy8gaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IHN0YXJ0IGF0IGBwb3NgLlxuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vLyBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICAvLy8gcG9zaXRpb24uXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vLyBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIC8vLyBhbnkuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiB0aGUgbm9kZSBpcyBpbiBhIFt0cmVlXG4gICAgLy8vIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8vLyBJdGVyYXRlIG92ZXIgdGhlIGN1cnJlbnQgbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgY2FsbGluZ1xuICAgIC8vLyBgZW50ZXJgIHdoZW4gZW50ZXJpbmcgYSBub2RlIGFuZCBgbGVhdmVgLCBpZiBnaXZlbiwgd2hlbiBsZWF2aW5nXG4gICAgLy8vIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICAvLy8gc2tpcHBlZCwgYW5kIGBsZWF2ZWAgaXNuJ3QgY2FsbGVkIGZvciBpdC5cbiAgICBpdGVyYXRlKGVudGVyLCBsZWF2ZSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcih0aGlzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKHRoaXMpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIC8vLyBvZiBkaXJlY3QgcGFyZW50IG5vZGUgbmFtZXMuIEVtcHR5IHN0cmluZ3MgaW4gdGhlIGNvbnRleHQgYXJyYXlcbiAgICAvLy8gYXJlIHRyZWF0ZWQgYXMgd2lsZGNhcmRzLlxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBTcGVjaWFsUmVjb3JkLlJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPj0gMCAmJiBsYXN0R3JvdXAgPiAwICYmIGxhc3RHcm91cCA8IGxvY2FsQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1ha2VSZXBlYXRMZWFmKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBzdGFydCwgbGFzdEdyb3VwLCBzdGFydCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbGFzdEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBtYWtlID0gbWFrZUJhbGFuY2VkKHR5cGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBiYWxhbmNlUmFuZ2UodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIDAsIGxvY2FsQ2hpbGRyZW4ubGVuZ3RoLCAwLCBlbmQgLSBzdGFydCwgbWFrZSwgbWFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbWFrZVRyZWUodHlwZSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGVuZCAtIHN0YXJ0LCBsb29rQWhlYWRBdFN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydFBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCA9IDAsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEpO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuLy8vIFByb3ZpZGVzIGEgd2F5IHRvIGFzc29jaWF0ZSB2YWx1ZXMgd2l0aCBwaWVjZXMgb2YgdHJlZXMuIEFzIGxvbmdcbi8vLyBhcyB0aGF0IHBhcnQgb2YgdGhlIHRyZWUgaXMgcmV1c2VkLCB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgY2FuIGJlXG4vLy8gcmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWZmZXIsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChidWZmZXIsIGlubmVyID0gbmV3IE1hcCk7XG4gICAgICAgIGlubmVyLnNldChpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGlubmVyICYmIGlubmVyLmdldChpbmRleCk7XG4gICAgfVxuICAgIC8vLyBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgIHNldChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSlcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChub2RlLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8vIFJldHJpZXZlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLCBpZiBpdCBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8vIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50cyB0by5cbiAgICBjdXJzb3JTZXQoY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoY3Vyc29yLmJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGN1cnNvci50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vLyBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIC8vLyB0by5cbiAgICBjdXJzb3JHZXQoY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3IuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCkgOiB0aGlzLm1hcC5nZXQoY3Vyc29yLnRyZWUpO1xuICAgIH1cbn1cblxuLy8vIFRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbi8vLyBwYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbi8vLyB0aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG4vLy8gdG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG4vLy8gcGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbi8vLyB1cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvLy8gQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2VcbiAgICAvLy8gW2BhZGRUcmVlYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYWRkVHJlZSkgYW5kXG4gICAgLy8vIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgLy8vIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIC8vLyBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIC8vLyB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgZnJvbSwgXG4gICAgLy8vIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICB0bywgXG4gICAgLy8vIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICB0cmVlLCBcbiAgICAvLy8gVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgLy8vIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgLy8vIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICAvLy8gZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLy8vIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgLy8vIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgLy8vIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLy8gcGFyc2luZyBhbGdvcml0aG0uKVxuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBPcGVuLlN0YXJ0ICovKSA+IDA7IH1cbiAgICAvLy8gV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIC8vLyBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBPcGVuLkVuZCAqLykgPiAwOyB9XG4gICAgLy8vIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIC8vLyBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICAvLy8gd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIC8vLyB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIC8vLyBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgLy8vIHRydWUuXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8vIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICAvLy8gc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIC8vLyBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8vIEEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbmNsYXNzIFBhcnNlciB7XG4gICAgLy8vIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICAvLy8gb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgLy8vIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIC8vL1xuICAgIC8vLyBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIC8vLyB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICAvLy8gcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIC8vLyBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLy8vIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vLy8gQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuLy8vIHNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuLy8vIGZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG4vLy8gYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG4vLy8gdHJlZS5cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgfVxufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLnJhbmdlc1swXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOyB0aGlzLnN0b3BwZWRBdCA9PSBudWxsIHx8IGN1cnNvci5mcm9tIDwgdGhpcy5zdG9wcGVkQXQ7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXIgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBkZXB0aCA9IDA7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBpID0gMCwgYmFzZSA9IGN1cnNvci50cmVlLCBvZmYgPSAwO1xuICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgIG9mZiA9IGJhc2UucG9zaXRpb25zW2ldICsgY3Vyc29yLmZyb207XG4gICAgICAgIGlmIChvZmYgPD0gbm9kZS5mcm9tICYmIG9mZiArIGJhc2UuY2hpbGRyZW5baV0ubGVuZ3RoID49IG5vZGUudG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGJ1ZiA9IGJhc2UuY2hpbGRyZW5baV0sIGIgPSBidWYuYnVmZmVyO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBsZXQgaSA9IHN0YXJ0STtcbiAgICAgICAgd2hpbGUgKGJbaSArIDJdICsgb2ZmIDw9IG5vZGUuZnJvbSlcbiAgICAgICAgICAgIGkgPSBiW2kgKyAzXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgaSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbaSArIDFdLCB0byA9IGJbaSArIDJdO1xuICAgICAgICBsZXQgaXNUYXJnZXQgPSBmcm9tICsgb2ZmID09IG5vZGUuZnJvbSAmJiB0byArIG9mZiA9PSBub2RlLnRvICYmIGJbaV0gPT0gbm9kZS50eXBlLmlkO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGlzVGFyZ2V0ID8gbm9kZS50b1RyZWUoKSA6IHNwbGl0KGkgKyA0LCBiW2kgKyAzXSwgYnVmLnNldC50eXBlc1tiW2ldXSwgZnJvbSwgdG8gLSBmcm9tKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBpbm5lck9mZnNldCk7XG4gICAgICAgIHNsaWNlQnVmKGJ1ZiwgYltpICsgM10sIGVuZEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCk7XG4gICAgfVxuICAgIGJhc2UuY2hpbGRyZW5baV0gPSBzcGxpdCgwLCBiLmxlbmd0aCwgTm9kZVR5cGUubm9uZSwgMCwgYnVmLmxlbmd0aCk7XG4gICAgLy8gTW92ZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIHRhcmdldCBub2RlXG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPD0gZGVwdGg7IGQrKylcbiAgICAgICAgY3Vyc29yLmNoaWxkQWZ0ZXIobm9kZS5mcm9tKTtcbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tag\": () => (/* binding */ Tag),\n/* harmony export */   \"classHighlighter\": () => (/* binding */ classHighlighter),\n/* harmony export */   \"getStyleTags\": () => (/* binding */ getStyleTags),\n/* harmony export */   \"highlightTree\": () => (/* binding */ highlightTree),\n/* harmony export */   \"styleTags\": () => (/* binding */ styleTags),\n/* harmony export */   \"tagHighlighter\": () => (/* binding */ tagHighlighter),\n/* harmony export */   \"tags\": () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n  /// @internal\n  constructor(\n  /// The set of this tag and all its parent tags, starting with\n  /// this one itself and sorted in order of decreasing specificity.\n  set,\n  /// The base unmodified tag that this one is based on, if it's\n  /// modified @internal\n  base,\n  /// The modifiers applied to this.base @internal\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    /// @internal\n    this.id = nextTagID++;\n  }\n  /// Define a new tag. If `parent` is given, the tag is treated as a\n  /// sub-tag of that parent, and\n  /// [highlighters](#highlight.tagHighlighter) that don't mention\n  /// this tag will try to fall back to the parent tag (or grandparent\n  /// tag, etc).\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  }\n  /// Define a tag _modifier_, which is a function that, given a tag,\n  /// will return a tag that is a subtag of the original. Applying the\n  /// same modifier to a twice tag will return the same value (`m1(t1)\n  /// == m1(t1)`) and applying multiple modifiers will, regardless or\n  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  ///\n  /// When multiple modifiers are applied to a given base tag, each\n  /// smaller set of modifiers is registered as a parent, so that for\n  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  /// `m1(m3(t1)`, and so on.\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n}\nlet nextModifierID = 0;\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n      tag = new Tag(set, base, mods);\n    for (let m of mods) m.instances.push(tag);\n    let configs = powerSet(mods);\n    for (let parent of base.set) if (!parent.modified.length) for (let config of configs) set.push(Modifier.get(parent, config));\n    return tag;\n  }\n}\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n  let sets = [[]];\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0, e = sets.length; j < e; j++) {\n      sets.push(sets[j].concat(array[i]));\n    }\n  }\n  return sets.sort((a, b) => b.length - a.length);\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single level—wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n        mode = 2 /* Mode.Normal */,\n        rest = part;\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1 /* Mode.Inherit */;\n          break;\n        }\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n        if (pos == part.length && next == \"!\") {\n          mode = 0 /* Mode.Opaque */;\n          break;\n        }\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n      let last = pieces.length - 1,\n        inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n  return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n  get opaque() {\n    return this.mode == 0 /* Mode.Opaque */;\n  }\n  get inherit() {\n    return this.mode == 1 /* Mode.Inherit */;\n  }\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n    other.next = this.sort(other.next);\n    return other;\n  }\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n  let map = Object.create(null);\n  for (let style of tags) {\n    if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else for (let tag of style.tag) map[tag.id] = style.class;\n  }\n  let {\n    scope,\n    all = null\n  } = options || {};\n  return {\n    style: tags => {\n      let cls = all;\n      for (let tag of tags) {\n        for (let sub of tag.set) {\n          let tagClass = map[sub.id];\n          if (tagClass) {\n            cls = cls ? cls + \" \" + tagClass : tagClass;\n            break;\n          }\n        }\n      }\n      return cls;\n    },\n    scope\n  };\n}\nfunction highlightTags(highlighters, tags) {\n  let result = null;\n  for (let highlighter of highlighters) {\n    let value = highlighter.style(tags);\n    if (value) result = result ? result + \" \" + value : value;\n  }\n  return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter,\n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle,\n/// The start of the range to highlight.\nfrom = 0,\n/// The end of the range.\nto = tree.length) {\n  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n  builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n  builder.flush(to);\n}\nclass HighlightBuilder {\n  constructor(at, highlighters, span) {\n    this.at = at;\n    this.highlighters = highlighters;\n    this.span = span;\n    this.class = \"\";\n  }\n  startSpan(at, cls) {\n    if (cls != this.class) {\n      this.flush(at);\n      if (at > this.at) this.at = at;\n      this.class = cls;\n    }\n  }\n  flush(to) {\n    if (to > this.at && this.class) this.span(this.at, to, this.class);\n  }\n  highlightRange(cursor, from, to, inheritedClass, highlighters) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    if (type.isTop) highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n    let cls = inheritedClass;\n    let rule = getStyleTags(cursor) || Rule.empty;\n    let tagCls = highlightTags(highlighters, rule.tags);\n    if (tagCls) {\n      if (cls) cls += \" \";\n      cls += tagCls;\n      if (rule.mode == 1 /* Mode.Inherit */) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n    }\n    this.startSpan(cursor.from, cls);\n    if (rule.opaque) return;\n    let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n    if (mounted && mounted.overlay) {\n      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n      let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n      let hasChild = cursor.firstChild();\n      for (let i = 0, pos = start;; i++) {\n        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n        let nextPos = next ? next.from + start : end;\n        let rangeFrom = Math.max(from, pos),\n          rangeTo = Math.min(to, nextPos);\n        if (rangeFrom < rangeTo && hasChild) {\n          while (cursor.from < rangeTo) {\n            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n            this.startSpan(Math.min(rangeTo, cursor.to), cls);\n            if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n          }\n        }\n        if (!next || nextPos > to) break;\n        pos = next.to + start;\n        if (pos > from) {\n          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n          this.startSpan(pos, cls);\n        }\n      }\n      if (hasChild) cursor.parent();\n    } else if (cursor.firstChild()) {\n      do {\n        if (cursor.to <= from) continue;\n        if (cursor.from >= to) break;\n        this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n        this.startSpan(Math.min(to, cursor.to), cls);\n      } while (cursor.nextSibling());\n      cursor.parent();\n    }\n  }\n}\n/// Match a syntax node's [highlight rules](#highlight.styleTags). If\n/// there's a match, return its set of tags, and whether it is\n/// opaque (uses a `!`) or applies to all child nodes (`/...`).\nfunction getStyleTags(node) {\n  let rule = node.type.prop(ruleNodeProp);\n  while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;\n  return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(),\n  name = t(),\n  typeName = t(name),\n  propertyName = t(name),\n  literal = t(),\n  string = t(literal),\n  number = t(literal),\n  content = t(),\n  heading = t(content),\n  keyword = t(),\n  operator = t(),\n  punctuation = t(),\n  bracket = t(punctuation),\n  meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an element—if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n  /// A comment.\n  comment,\n  /// A line [comment](#highlight.tags.comment).\n  lineComment: t(comment),\n  /// A block [comment](#highlight.tags.comment).\n  blockComment: t(comment),\n  /// A documentation [comment](#highlight.tags.comment).\n  docComment: t(comment),\n  /// Any kind of identifier.\n  name,\n  /// The [name](#highlight.tags.name) of a variable.\n  variableName: t(name),\n  /// A type [name](#highlight.tags.name).\n  typeName: typeName,\n  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  tagName: t(typeName),\n  /// A property or field [name](#highlight.tags.name).\n  propertyName: propertyName,\n  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  attributeName: t(propertyName),\n  /// The [name](#highlight.tags.name) of a class.\n  className: t(name),\n  /// A label [name](#highlight.tags.name).\n  labelName: t(name),\n  /// A namespace [name](#highlight.tags.name).\n  namespace: t(name),\n  /// The [name](#highlight.tags.name) of a macro.\n  macroName: t(name),\n  /// A literal value.\n  literal,\n  /// A string [literal](#highlight.tags.literal).\n  string,\n  /// A documentation [string](#highlight.tags.string).\n  docString: t(string),\n  /// A character literal (subtag of [string](#highlight.tags.string)).\n  character: t(string),\n  /// An attribute value (subtag of [string](#highlight.tags.string)).\n  attributeValue: t(string),\n  /// A number [literal](#highlight.tags.literal).\n  number,\n  /// An integer [number](#highlight.tags.number) literal.\n  integer: t(number),\n  /// A floating-point [number](#highlight.tags.number) literal.\n  float: t(number),\n  /// A boolean [literal](#highlight.tags.literal).\n  bool: t(literal),\n  /// Regular expression [literal](#highlight.tags.literal).\n  regexp: t(literal),\n  /// An escape [literal](#highlight.tags.literal), for example a\n  /// backslash escape in a string.\n  escape: t(literal),\n  /// A color [literal](#highlight.tags.literal).\n  color: t(literal),\n  /// A URL [literal](#highlight.tags.literal).\n  url: t(literal),\n  /// A language keyword.\n  keyword,\n  /// The [keyword](#highlight.tags.keyword) for the self or this\n  /// object.\n  self: t(keyword),\n  /// The [keyword](#highlight.tags.keyword) for null.\n  null: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  atom: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that represents a unit.\n  unit: t(keyword),\n  /// A modifier [keyword](#highlight.tags.keyword).\n  modifier: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n  operatorKeyword: t(keyword),\n  /// A control-flow related [keyword](#highlight.tags.keyword).\n  controlKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that defines something.\n  definitionKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) related to defining or\n  /// interfacing with modules.\n  moduleKeyword: t(keyword),\n  /// An operator.\n  operator,\n  /// An [operator](#highlight.tags.operator) that dereferences something.\n  derefOperator: t(operator),\n  /// Arithmetic-related [operator](#highlight.tags.operator).\n  arithmeticOperator: t(operator),\n  /// Logical [operator](#highlight.tags.operator).\n  logicOperator: t(operator),\n  /// Bit [operator](#highlight.tags.operator).\n  bitwiseOperator: t(operator),\n  /// Comparison [operator](#highlight.tags.operator).\n  compareOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that updates its operand.\n  updateOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that defines something.\n  definitionOperator: t(operator),\n  /// Type-related [operator](#highlight.tags.operator).\n  typeOperator: t(operator),\n  /// Control-flow [operator](#highlight.tags.operator).\n  controlOperator: t(operator),\n  /// Program or markup punctuation.\n  punctuation,\n  /// [Punctuation](#highlight.tags.punctuation) that separates\n  /// things.\n  separator: t(punctuation),\n  /// Bracket-style [punctuation](#highlight.tags.punctuation).\n  bracket,\n  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  /// tokens).\n  angleBracket: t(bracket),\n  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  /// tokens).\n  squareBracket: t(bracket),\n  /// Parentheses (usually `(` and `)` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  paren: t(bracket),\n  /// Braces (usually `{` and `}` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  brace: t(bracket),\n  /// Content, for example plain text in XML or markup documents.\n  content,\n  /// [Content](#highlight.tags.content) that represents a heading.\n  heading,\n  /// A level 1 [heading](#highlight.tags.heading).\n  heading1: t(heading),\n  /// A level 2 [heading](#highlight.tags.heading).\n  heading2: t(heading),\n  /// A level 3 [heading](#highlight.tags.heading).\n  heading3: t(heading),\n  /// A level 4 [heading](#highlight.tags.heading).\n  heading4: t(heading),\n  /// A level 5 [heading](#highlight.tags.heading).\n  heading5: t(heading),\n  /// A level 6 [heading](#highlight.tags.heading).\n  heading6: t(heading),\n  /// A prose separator (such as a horizontal rule).\n  contentSeparator: t(content),\n  /// [Content](#highlight.tags.content) that represents a list.\n  list: t(content),\n  /// [Content](#highlight.tags.content) that represents a quote.\n  quote: t(content),\n  /// [Content](#highlight.tags.content) that is emphasized.\n  emphasis: t(content),\n  /// [Content](#highlight.tags.content) that is styled strong.\n  strong: t(content),\n  /// [Content](#highlight.tags.content) that is part of a link.\n  link: t(content),\n  /// [Content](#highlight.tags.content) that is styled as code or\n  /// monospace.\n  monospace: t(content),\n  /// [Content](#highlight.tags.content) that has a strike-through\n  /// style.\n  strikethrough: t(content),\n  /// Inserted text in a change-tracking format.\n  inserted: t(),\n  /// Deleted text.\n  deleted: t(),\n  /// Changed text.\n  changed: t(),\n  /// An invalid or unsyntactic element.\n  invalid: t(),\n  /// Metadata or meta-instruction.\n  meta,\n  /// [Metadata](#highlight.tags.meta) that applies to the entire\n  /// document.\n  documentMeta: t(meta),\n  /// [Metadata](#highlight.tags.meta) that annotates or adds\n  /// attributes to a given syntactic element.\n  annotation: t(meta),\n  /// Processing instruction or preprocessor directive. Subtag of\n  /// [meta](#highlight.tags.meta).\n  processingInstruction: t(meta),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  /// given element is being defined. Expected to be used with the\n  /// various [name](#highlight.tags.name) tags.\n  definition: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n  /// something is constant. Mostly expected to be used with\n  /// [variable names](#highlight.tags.variableName).\n  constant: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  /// a [variable](#highlight.tags.variableName) or [property\n  /// name](#highlight.tags.propertyName) is being called or defined\n  /// as a function.\n  function: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  /// [names](#highlight.tags.name) to indicate that they belong to\n  /// the language's standard environment.\n  standard: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  /// [names](#highlight.tags.name) is local to some scope.\n  local: Tag.defineModifier(),\n  /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n  /// can be used to tag language-specific alternative variants of\n  /// some common tag. It is recommended for themes to define special\n  /// forms of at least the [string](#highlight.tags.string) and\n  /// [variable name](#highlight.tags.variableName) tags, since those\n  /// come up a lot.\n  special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([{\n  tag: tags.link,\n  class: \"tok-link\"\n}, {\n  tag: tags.heading,\n  class: \"tok-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"tok-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"tok-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"tok-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"tok-atom\"\n}, {\n  tag: tags.bool,\n  class: \"tok-bool\"\n}, {\n  tag: tags.url,\n  class: \"tok-url\"\n}, {\n  tag: tags.labelName,\n  class: \"tok-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"tok-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"tok-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"tok-literal\"\n}, {\n  tag: tags.string,\n  class: \"tok-string\"\n}, {\n  tag: tags.number,\n  class: \"tok-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"tok-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"tok-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"tok-variableName tok-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"tok-variableName tok-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"tok-variableName2\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  class: \"tok-propertyName tok-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"tok-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"tok-namespace\"\n}, {\n  tag: tags.className,\n  class: \"tok-className\"\n}, {\n  tag: tags.macroName,\n  class: \"tok-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"tok-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"tok-operator\"\n}, {\n  tag: tags.comment,\n  class: \"tok-comment\"\n}, {\n  tag: tags.meta,\n  class: \"tok-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"tok-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"tok-punctuation\"\n}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzPzVhODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vLy8gSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG4vLy8gVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG4vLy8gdHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG4vLy8gYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuLy8vXG4vLy8gQmVjYXVzZSBzeW50YXggdHJlZSBub2RlIHR5cGVzIGFuZCBoaWdobGlnaHQgc3R5bGVzIGhhdmUgdG8gYmVcbi8vLyBhYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuLy8vIFt2b2NhYnVsYXJ5XSgjaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG4vLy8gdHJhZGl0aW9uYWwgb3BlbiBzdHJpbmctYmFzZWQgc3lzdGVtcywgd2hpY2ggbWFrZSBpdCBoYXJkIGZvclxuLy8vIGhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG4vLy8gdmFyaW91cyBsYW5ndWFnZXMpLlxuLy8vXG4vLy8gSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG4vLy8gaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbi8vLyB0aGUgbGFuZ3VhZ2UgcGFja2FnZSBhbmQgdGhlIGhpZ2hsaWdodGVyKSwgYnV0IHN1Y2ggdGFncyB3aWxsIG5vdFxuLy8vIGJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbi8vLyBmcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG5jbGFzcyBUYWcge1xuICAgIC8vLyBAaW50ZXJuYWxcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLy8gVGhlIHNldCBvZiB0aGlzIHRhZyBhbmQgYWxsIGl0cyBwYXJlbnQgdGFncywgc3RhcnRpbmcgd2l0aFxuICAgIC8vLyB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgIHNldCwgXG4gICAgLy8vIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICAvLy8gbW9kaWZpZWQgQGludGVybmFsXG4gICAgYmFzZSwgXG4gICAgLy8vIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLy8vIEBpbnRlcm5hbFxuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSBuZXcgdGFnLiBJZiBgcGFyZW50YCBpcyBnaXZlbiwgdGhlIHRhZyBpcyB0cmVhdGVkIGFzIGFcbiAgICAvLy8gc3ViLXRhZyBvZiB0aGF0IHBhcmVudCwgYW5kXG4gICAgLy8vIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIC8vLyB0aGlzIHRhZyB3aWxsIHRyeSB0byBmYWxsIGJhY2sgdG8gdGhlIHBhcmVudCB0YWcgKG9yIGdyYW5kcGFyZW50XG4gICAgLy8vIHRhZywgZXRjKS5cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8vLyBEZWZpbmUgYSB0YWcgX21vZGlmaWVyXywgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIHRhZyxcbiAgICAvLy8gd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICAgIC8vLyBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgLy8vID09IG0xKHQxKWApIGFuZCBhcHBseWluZyBtdWx0aXBsZSBtb2RpZmllcnMgd2lsbCwgcmVnYXJkbGVzcyBvclxuICAgIC8vLyBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgICAvLy9cbiAgICAvLy8gV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIC8vLyBzbWFsbGVyIHNldCBvZiBtb2RpZmllcnMgaXMgcmVnaXN0ZXJlZCBhcyBhIHBhcmVudCwgc28gdGhhdCBmb3JcbiAgICAvLy8gZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXG4gICAgLy8vIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgc3RhdGljIGRlZmluZU1vZGlmaWVyKCkge1xuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyO1xuICAgICAgICByZXR1cm4gKHRhZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZy5tb2RpZmllZC5pbmRleE9mKG1vZCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyLmdldCh0YWcuYmFzZSB8fCB0YWcsIHRhZy5tb2RpZmllZC5jb25jYXQobW9kKS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmxldCBuZXh0TW9kaWZpZXJJRCA9IDA7XG5jbGFzcyBNb2RpZmllciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGJhc2UsIG1vZHMpIHtcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgZXhpc3RzID0gbW9kc1swXS5pbnN0YW5jZXMuZmluZCh0ID0+IHQuYmFzZSA9PSBiYXNlICYmIHNhbWVBcnJheShtb2RzLCB0Lm1vZGlmaWVkKSk7XG4gICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICBsZXQgc2V0ID0gW10sIHRhZyA9IG5ldyBUYWcoc2V0LCBiYXNlLCBtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxuICAgICAgICAgICAgbS5pbnN0YW5jZXMucHVzaCh0YWcpO1xuICAgICAgICBsZXQgY29uZmlncyA9IHBvd2VyU2V0KG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBpZiAoIXBhcmVudC5tb2RpZmllZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT0gYltpXSk7XG59XG5mdW5jdGlvbiBwb3dlclNldChhcnJheSkge1xuICAgIGxldCBzZXRzID0gW1tdXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBlID0gc2V0cy5sZW5ndGg7IGogPCBlOyBqKyspIHtcbiAgICAgICAgICAgIHNldHMucHVzaChzZXRzW2pdLmNvbmNhdChhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuLy8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxuLy8vIHZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3Jcbi8vLyBbYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuLy8vXG4vLy8gVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbi8vLyB0YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG4vLy9cbi8vLyBOb2RlIHNlbGVjdG9ycyBtYXkgaG9sZCBvbmUgb3IgbW9yZSAoc3BhY2Utc2VwYXJhdGVkKSBub2RlIHBhdGhzLlxuLy8vIFN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG4vLy8gbXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG4vLy8gY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxuLy8vIG1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxuLy8vIG90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuLy8vIGJ1dCBvbmx5IGEgc2luZ2xlIGxldmVs4oCUd2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuLy8vIGFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxuLy8vIHRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG4vLy9cbi8vLyBBIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxuLy8vIHRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG4vLy8gbWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbi8vLyB1c2VkKS5cbi8vL1xuLy8vIFdoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbi8vLyBoYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG4vLy8gZ2l2ZW4gc3R5bGUuXG4vLy9cbi8vLyBJbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxuLy8vIG11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cbi8vL1xuLy8vIEZvciBleGFtcGxlOlxuLy8vXG4vLy8gYGBgamF2YXNjcmlwdFxuLy8vIHBhcnNlci53aXRoUHJvcHMoXG4vLy8gICBzdHlsZVRhZ3Moe1xuLy8vICAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuLy8vICAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4vLy8gICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4vLy8gICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbi8vLyAgICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbi8vLyAgICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4vLy8gICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbi8vLyAgICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4vLy8gICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4vLy8gICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4vLy8gICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4vLy8gICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbi8vLyAgIH0pXG4vLy8gKVxuLy8vIGBgYFxuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE1vZGUuTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIE1vZGUuSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IFwiXCIgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE1vZGUuT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgTm9kZVByb3AoKTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE1vZGUuT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBNb2RlLk5vcm1hbCAqLywgbnVsbCk7XG4vLy8gRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG4vLy8gdGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxuLy8vIHRha2UgcHJlY2VkZW5jZS5cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vLyBIaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG4vLy8gW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIFxuLy8vIEFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbi8vLyBvZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cbi8vLyBgY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxucHV0U3R5bGUsIFxuLy8vIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuZnJvbSA9IDAsIFxuLy8vIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG5jbGFzcyBIaWdobGlnaHRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhdCwgaGlnaGxpZ2h0ZXJzLCBzcGFuKSB7XG4gICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlcnMgPSBoaWdobGlnaHRlcnM7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMuY2xhc3MgPSBcIlwiO1xuICAgIH1cbiAgICBzdGFydFNwYW4oYXQsIGNscykge1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0ID4gdGhpcy5hdClcbiAgICAgICAgICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgICAgICB0aGlzLmNsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKHRvKSB7XG4gICAgICAgIGlmICh0byA+IHRoaXMuYXQgJiYgdGhpcy5jbGFzcylcbiAgICAgICAgICAgIHRoaXMuc3Bhbih0aGlzLmF0LCB0bywgdGhpcy5jbGFzcyk7XG4gICAgfVxuICAgIGhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZnJvbTogc3RhcnQsIHRvOiBlbmQgfSA9IGN1cnNvcjtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZS5pc1RvcClcbiAgICAgICAgICAgIGhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUodHlwZSkpO1xuICAgICAgICBsZXQgY2xzID0gaW5oZXJpdGVkQ2xhc3M7XG4gICAgICAgIGxldCBydWxlID0gZ2V0U3R5bGVUYWdzKGN1cnNvcikgfHwgUnVsZS5lbXB0eTtcbiAgICAgICAgbGV0IHRhZ0NscyA9IGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCBydWxlLnRhZ3MpO1xuICAgICAgICBpZiAodGFnQ2xzKSB7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIjtcbiAgICAgICAgICAgIGNscyArPSB0YWdDbHM7XG4gICAgICAgICAgICBpZiAocnVsZS5tb2RlID09IDEgLyogTW9kZS5Jbmhlcml0ICovKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzICs9IChpbmhlcml0ZWRDbGFzcyA/IFwiIFwiIDogXCJcIikgKyB0YWdDbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFNwYW4oY3Vyc29yLmZyb20sIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIGluaGVyaXRlZENsYXNzLCBpbm5lckhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKHBvcywgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vLyBNYXRjaCBhIHN5bnRheCBub2RlJ3MgW2hpZ2hsaWdodCBydWxlc10oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpLiBJZlxuLy8vIHRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbi8vLyBvcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLy8vIFRoZSBkZWZhdWx0IHNldCBvZiBoaWdobGlnaHRpbmcgW3RhZ3NdKCNoaWdobGlnaHQuVGFnKS5cbi8vL1xuLy8vIFRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbi8vLyBhbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuLy8vIGNvbnN0cnVjdHMgd291bGQgZmlsbCBhIHN0YWNrIG9mIGJvb2tzLCBhbmQgYmUgaW1wcmFjdGljYWwgdG9cbi8vLyB3cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuLy8vIGZhaWxzLCBbb3BlbiBhblxuLy8vIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9jb2RlbWlycm9yLm5leHQpIHRvIHByb3Bvc2UgYVxuLy8vIG5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxuLy8vIHlvdXIgdXNlIGNhc2UuXG4vLy9cbi8vLyBOb3RlIHRoYXQgaXQgaXMgbm90IG9ibGlnYXRvcnkgdG8gYWx3YXlzIGF0dGFjaCB0aGUgbW9zdCBzcGVjaWZpY1xuLy8vIHRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW504oCUaWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuLy8vIGRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG4vLy8gaXQgaXMgb2theSB0byBzdHlsZSBpdCBhcyBpdHMgbW9yZSBnZW5lcmFsIHZhcmlhbnQgKGEgdmFyaWFibGUpLlxuLy8vIFxuLy8vIEZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbi8vLyB0aGUgcGFyZW50LlxuY29uc3QgdGFncyA9IHtcbiAgICAvLy8gQSBjb21tZW50LlxuICAgIGNvbW1lbnQsXG4gICAgLy8vIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgIGxpbmVDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8vLyBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgIG5hbWUsXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIHR5cGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLy8vIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgdGFnTmFtZTogdCh0eXBlTmFtZSksXG4gICAgLy8vIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvLy8gQW4gYXR0cmlidXRlIG5hbWUgKHN1YnRhZyBvZiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLy8vIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgY2xhc3NOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8vLyBBIG5hbWVzcGFjZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvLy8gVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICBtYWNyb05hbWU6IHQobmFtZSksXG4gICAgLy8vIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICBsaXRlcmFsLFxuICAgIC8vLyBBIHN0cmluZyBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgIHN0cmluZyxcbiAgICAvLy8gQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgIGRvY1N0cmluZzogdChzdHJpbmcpLFxuICAgIC8vLyBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8vLyBBbiBhdHRyaWJ1dGUgdmFsdWUgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvLy8gQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBudW1iZXIsXG4gICAgLy8vIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLy8vIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8vLyBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICBib29sOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLy8vIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXG4gICAgLy8vIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLy8vIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxuICAgIC8vLyBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAga2V5d29yZCxcbiAgICAvLy8gVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcbiAgICAvLy8gb2JqZWN0LlxuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLy8vIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICBhdG9tOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLy8vIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8vLyBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIC8vLyBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvLy8gQW4gb3BlcmF0b3IuXG4gICAgb3BlcmF0b3IsXG4gICAgLy8vIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLy8vIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvLy8gQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8vLyBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvLy8gW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgLy8vIHRoaW5ncy5cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8vLyBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cbiAgICBicmFja2V0LFxuICAgIC8vLyBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIC8vLyB0b2tlbnMpLlxuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgLy8vIHRva2VucykuXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvLy8gUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgLy8vIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLy8vIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvLy8gQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICBjb250ZW50LFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgaGVhZGluZyxcbiAgICAvLy8gQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLy8vIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxuICAgIC8vLyBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvLy8gQSBwcm9zZSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvLy8gW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgLy8vIG1vbm9zcGFjZS5cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLy8vIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICAgIC8vLyBzdHlsZS5cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8vLyBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8vLyBEZWxldGVkIHRleHQuXG4gICAgZGVsZXRlZDogdCgpLFxuICAgIC8vLyBDaGFuZ2VkIHRleHQuXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8vLyBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8vLyBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgIG1ldGEsXG4gICAgLy8vIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgLy8vIGRvY3VtZW50LlxuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcbiAgICAvLy8gW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIC8vLyBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcbiAgICAvLy8gUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICAvLy8gW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIC8vLyBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICAvLy8gdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLy8vIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICAvLy8gc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXG4gICAgLy8vIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8vLyBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgICAvLy8gYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIC8vLyBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIC8vLyBhcyBhIGZ1bmN0aW9uLlxuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIC8vLyBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgLy8vIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxuICAgIC8vLyBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvLy8gQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICAgIC8vLyBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICAvLy8gc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgLy8vIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICAvLy8gW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgLy8vIGNvbWUgdXAgYSBsb3QuXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKClcbn07XG4vLy8gVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbi8vLyB0b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxuLy8vXG4vLy8gVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbi8vLyAoZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuLy8vXG4vLy8gKiBbYGxpbmtgXSgjaGlnaGxpZ2h0LnRhZ3MubGluaylcbi8vLyAqIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuLy8vICogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbi8vLyAqIFtgc3Ryb25nYF0oI2hpZ2hsaWdodC50YWdzLnN0cm9uZylcbi8vLyAqIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuLy8vICogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4vLy8gKiBbYGJvb2xgXSgjaGlnaGxpZ2h0LnRhZ3MuYm9vbClcbi8vLyAqIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbi8vLyAqIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbi8vLyAqIFtgaW5zZXJ0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW5zZXJ0ZWQpXG4vLy8gKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbi8vLyAqIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuLy8vICogW2BzdHJpbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuLy8vICogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuLy8vICogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICogW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSlcbi8vLyAqIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbi8vLyAqIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbi8vLyAqIFtgbWFjcm9OYW1lYF0oI2hpZ2hsaWdodC50YWdzLm1hY3JvTmFtZSlcbi8vLyAqIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbi8vLyAqIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4vLy8gKiBbYGNvbW1lbnRgXSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudClcbi8vLyAqIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuLy8vICogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbi8vLyAqIFtgaW52YWxpZGBdKCNoaWdobGlnaHQudGFncy5pbnZhbGlkKVxuLy8vXG4vLy8gSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcbi8vL1xuLy8vICogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbi8vLyAgIFtgZXNjYXBlYF0oI2hpZ2hsaWdodC50YWdzLmVzY2FwZSksIGFuZFxuLy8vICAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4vLy8gICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4vLy8gKiBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbi8vLyAgIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4vLy8gKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcImBcbi8vLyAqIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuLy8vICAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuLy8vICogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AocHJvcGVydHlOYW1lKWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4vLy8gICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG5jb25zdCBjbGFzc0hpZ2hsaWdodGVyID0gdGFnSGlnaGxpZ2h0ZXIoW1xuICAgIHsgdGFnOiB0YWdzLmxpbmssIGNsYXNzOiBcInRvay1saW5rXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLCBjbGFzczogXCJ0b2staGVhZGluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGNsYXNzOiBcInRvay1lbXBoYXNpc1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLCBjbGFzczogXCJ0b2stc3Ryb25nXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLCBjbGFzczogXCJ0b2sta2V5d29yZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYXRvbSwgY2xhc3M6IFwidG9rLWF0b21cIiB9LFxuICAgIHsgdGFnOiB0YWdzLmJvb2wsIGNsYXNzOiBcInRvay1ib29sXCIgfSxcbiAgICB7IHRhZzogdGFncy51cmwsIGNsYXNzOiBcInRvay11cmxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxhYmVsTmFtZSwgY2xhc3M6IFwidG9rLWxhYmVsTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW5zZXJ0ZWQsIGNsYXNzOiBcInRvay1pbnNlcnRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVsZXRlZCwgY2xhc3M6IFwidG9rLWRlbGV0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpdGVyYWwsIGNsYXNzOiBcInRvay1saXRlcmFsXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpbmcsIGNsYXNzOiBcInRvay1zdHJpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm51bWJlciwgY2xhc3M6IFwidG9rLW51bWJlclwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLCBjbGFzczogXCJ0b2stc3RyaW5nMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudmFyaWFibGVOYW1lLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUyXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcInRvay10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJ0b2stbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsIGNsYXNzOiBcInRvay1jbGFzc05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwidG9rLW1hY3JvTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHJvcGVydHlOYW1lLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5vcGVyYXRvciwgY2xhc3M6IFwidG9rLW9wZXJhdG9yXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJ0b2stY29tbWVudFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSwgY2xhc3M6IFwidG9rLW1ldGFcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsIGNsYXNzOiBcInRvay1pbnZhbGlkXCIgfSxcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwidG9rLXB1bmN0dWF0aW9uXCIgfVxuXSk7XG5cbmV4cG9ydCB7IFRhZywgY2xhc3NIaWdobGlnaHRlciwgZ2V0U3R5bGVUYWdzLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCB0YWdzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "./node_modules/crelt/index.es.js":
/*!****************************************!*\
  !*** ./node_modules/crelt/index.es.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ crelt)\n/* harmony export */ });\nfunction crelt() {\n  var elt = arguments[0];\n  if (typeof elt == \"string\") elt = document.createElement(elt);\n  var i = 1,\n    next = arguments[1];\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name];\n      if (typeof value == \"string\") elt.setAttribute(name, value);else if (value != null) elt[name] = value;\n    }\n    i++;\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i]);\n  return elt;\n}\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child));\n  } else if (child == null) {} else if (child.nodeType != null) {\n    elt.appendChild(child);\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i]);\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3JlbHQvaW5kZXguZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2NyZWx0L2luZGV4LmVzLmpzPzI5NWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlbHQoKSB7XG4gIHZhciBlbHQgPSBhcmd1bWVudHNbMF1cbiAgaWYgKHR5cGVvZiBlbHQgPT0gXCJzdHJpbmdcIikgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbHQpXG4gIHZhciBpID0gMSwgbmV4dCA9IGFyZ3VtZW50c1sxXVxuICBpZiAobmV4dCAmJiB0eXBlb2YgbmV4dCA9PSBcIm9iamVjdFwiICYmIG5leHQubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbmV4dCkgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0LCBuYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gbmV4dFtuYW1lXVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSBlbHQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxuICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkgZWx0W25hbWVdID0gdmFsdWVcbiAgICB9XG4gICAgaSsrXG4gIH1cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFkZChlbHQsIGFyZ3VtZW50c1tpXSlcbiAgcmV0dXJuIGVsdFxufVxuXG5mdW5jdGlvbiBhZGQoZWx0LCBjaGlsZCkge1xuICBpZiAodHlwZW9mIGNoaWxkID09IFwic3RyaW5nXCIpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKVxuICB9IGVsc2UgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgfSBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSAhPSBudWxsKSB7XG4gICAgZWx0LmFwcGVuZENoaWxkKGNoaWxkKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5sZW5ndGg7IGkrKykgYWRkKGVsdCwgY2hpbGRbaV0pXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGlsZCBub2RlOiBcIiArIGNoaWxkKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crelt/index.es.js\n");

/***/ }),

/***/ "./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StyleModule\": () => (/* binding */ StyleModule)\n/* harmony export */ });\nconst C = \"\\u037c\";\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C);\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\");\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {};\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nclass StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = [];\n    let {\n      finish\n    } = options || {};\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/);\n    }\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [],\n        isAt = /^@(\\w+)\\b/.exec(selectors[0]),\n        keyframes = isAt && isAt[1] == \"keyframes\";\n      if (isAt && spec == null) return target.push(selectors[0] + \";\");\n      for (let prop in spec) {\n        let value = spec[prop];\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\");\n          render(splitSelector(prop), value, local, keyframes);\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\");\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") + \" {\" + local.join(\" \") + \"}\");\n      }\n    }\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() {\n    return this.rules.join(\"\\n\");\n  }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1;\n    top[COUNT] = id + 1;\n    return C + id.toString(36);\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  static mount(root, modules) {\n    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);\n  }\n}\nlet adoptedSet = null;\nclass StyleSet {\n  constructor(root) {\n    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\n      if (adoptedSet) {\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);\n        return root[SET] = adoptedSet;\n      }\n      this.sheet = new CSSStyleSheet();\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);\n      adoptedSet = this;\n    } else {\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\");\n      let target = root.head || root;\n      target.insertBefore(this.styleTag, target.firstChild);\n    }\n    this.modules = [];\n    root[SET] = this;\n  }\n  mount(modules) {\n    let sheet = this.sheet;\n    let pos = 0 /* Current rule offset */,\n      j = 0; /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i],\n        index = this.modules.indexOf(mod);\n      if (index < j && index > -1) {\n        // Ordering conflict\n        this.modules.splice(index, 1);\n        j--;\n        index = -1;\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod);\n        if (sheet) for (let k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length;\n        pos += mod.rules.length;\n        j++;\n      }\n    }\n    if (!sheet) {\n      let text = \"\";\n      for (let i = 0; i < this.modules.length; i++) text += this.modules[i].getRules() + \"\\n\";\n      this.styleTag.textContent = text;\n    }\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbW9kL3NyYy9zdHlsZS1tb2QuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3N0eWxlLW1vZC9zcmMvc3R5bGUtbW9kLmpzP2FlNDkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQyA9IFwiXFx1MDM3Y1wiXG5jb25zdCBDT1VOVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19cIiArIEMgOiBTeW1ib2wuZm9yKEMpXG5jb25zdCBTRVQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fc3R5bGVTZXRcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlOCkgOiBTeW1ib2woXCJzdHlsZVNldFwiKVxuY29uc3QgdG9wID0gdHlwZW9mIGdsb2JhbFRoaXMgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fVxuXG4vLyA6OiAtIFN0eWxlIG1vZHVsZXMgZW5jYXBzdWxhdGUgYSBzZXQgb2YgQ1NTIHJ1bGVzIGRlZmluZWQgZnJvbVxuLy8gSmF2YVNjcmlwdC4gVGhlaXIgZGVmaW5pdGlvbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gRE9NXG4vLyByb290IGFmdGVyIGl0IGhhcyBiZWVuIF9tb3VudGVkXyB0aGVyZSB3aXRoIGBTdHlsZU1vZHVsZS5tb3VudGAuXG4vL1xuLy8gU3R5bGUgbW9kdWxlcyBzaG91bGQgYmUgY3JlYXRlZCBvbmNlIGFuZCBzdG9yZWQgc29tZXdoZXJlLCBhc1xuLy8gb3Bwb3NlZCB0byByZS1jcmVhdGluZyB0aGVtIGV2ZXJ5IHRpbWUgeW91IG5lZWQgdGhlbS4gVGhlIGFtb3VudCBvZlxuLy8gQ1NTIHJ1bGVzIGdlbmVyYXRlZCBmb3IgYSBnaXZlbiBET00gcm9vdCBpcyBib3VuZGVkIGJ5IHRoZSBhbW91bnRcbi8vIG9mIHN0eWxlIG1vZHVsZXMgdGhhdCB3ZXJlIHVzZWQuIFNvIHRvIGF2b2lkIGxlYWtpbmcgcnVsZXMsIGRvbid0XG4vLyBjcmVhdGUgdGhlc2UgZHluYW1pY2FsbHksIGJ1dCB0cmVhdCB0aGVtIGFzIG9uZS10aW1lIGFsbG9jYXRpb25zLlxuZXhwb3J0IGNsYXNzIFN0eWxlTW9kdWxlIHtcbiAgLy8gOjogKE9iamVjdDxTdHlsZT4sID97ZmluaXNoOiA/KHN0cmluZykg4oaSIHN0cmluZ30pXG4gIC8vIENyZWF0ZSBhIHN0eWxlIG1vZHVsZSBmcm9tIHRoZSBnaXZlbiBzcGVjLlxuICAvL1xuICAvLyBXaGVuIGBmaW5pc2hgIGlzIGdpdmVuLCBpdCBpcyBjYWxsZWQgb24gcmVndWxhciAobm9uLWBAYClcbiAgLy8gc2VsZWN0b3JzIChhZnRlciBgJmAgZXhwYW5zaW9uKSB0byBjb21wdXRlIHRoZSBmaW5hbCBzZWxlY3Rvci5cbiAgY29uc3RydWN0b3Ioc3BlYywgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMgPSBbXVxuICAgIGxldCB7ZmluaXNofSA9IG9wdGlvbnMgfHwge31cblxuICAgIGZ1bmN0aW9uIHNwbGl0U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAvXkAvLnRlc3Qoc2VsZWN0b3IpID8gW3NlbGVjdG9yXSA6IHNlbGVjdG9yLnNwbGl0KC8sXFxzKi8pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKHNlbGVjdG9ycywgc3BlYywgdGFyZ2V0LCBpc0tleWZyYW1lcykge1xuICAgICAgbGV0IGxvY2FsID0gW10sIGlzQXQgPSAvXkAoXFx3KylcXGIvLmV4ZWMoc2VsZWN0b3JzWzBdKSwga2V5ZnJhbWVzID0gaXNBdCAmJiBpc0F0WzFdID09IFwia2V5ZnJhbWVzXCJcbiAgICAgIGlmIChpc0F0ICYmIHNwZWMgPT0gbnVsbCkgcmV0dXJuIHRhcmdldC5wdXNoKHNlbGVjdG9yc1swXSArIFwiO1wiKVxuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNwZWNbcHJvcF1cbiAgICAgICAgaWYgKC8mLy50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgcmVuZGVyKHByb3Auc3BsaXQoLyxcXHMqLykubWFwKHBhcnQgPT4gc2VsZWN0b3JzLm1hcChzZWwgPT4gcGFydC5yZXBsYWNlKC8mLywgc2VsKSkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpLFxuICAgICAgICAgICAgICAgICB2YWx1ZSwgdGFyZ2V0KVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKCFpc0F0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IChcIiArIHByb3AgKyBcIikgc2hvdWxkIGJlIGEgcHJpbWl0aXZlIHZhbHVlLlwiKVxuICAgICAgICAgIHJlbmRlcihzcGxpdFNlbGVjdG9yKHByb3ApLCB2YWx1ZSwgbG9jYWwsIGtleWZyYW1lcylcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgbG9jYWwucHVzaChwcm9wLnJlcGxhY2UoL18uKi8sIFwiXCIpLnJlcGxhY2UoL1tBLVpdL2csIGwgPT4gXCItXCIgKyBsLnRvTG93ZXJDYXNlKCkpICsgXCI6IFwiICsgdmFsdWUgKyBcIjtcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvY2FsLmxlbmd0aCB8fCBrZXlmcmFtZXMpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2goKGZpbmlzaCAmJiAhaXNBdCAmJiAhaXNLZXlmcmFtZXMgPyBzZWxlY3RvcnMubWFwKGZpbmlzaCkgOiBzZWxlY3RvcnMpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiIHtcIiArIGxvY2FsLmpvaW4oXCIgXCIpICsgXCJ9XCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgc3BlY1twcm9wXSwgdGhpcy5ydWxlcylcbiAgfVxuXG4gIC8vIDo6ICgpIOKGkiBzdHJpbmdcbiAgLy8gUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBtb2R1bGUncyBDU1MgcnVsZXMuXG4gIGdldFJ1bGVzKCkgeyByZXR1cm4gdGhpcy5ydWxlcy5qb2luKFwiXFxuXCIpIH1cblxuICAvLyA6OiAoKSDihpIgc3RyaW5nXG4gIC8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBDU1MgY2xhc3MgbmFtZS5cbiAgc3RhdGljIG5ld05hbWUoKSB7XG4gICAgbGV0IGlkID0gdG9wW0NPVU5UXSB8fCAxXG4gICAgdG9wW0NPVU5UXSA9IGlkICsgMVxuICAgIHJldHVybiBDICsgaWQudG9TdHJpbmcoMzYpXG4gIH1cblxuICAvLyA6OiAodW5pb248RG9jdW1lbnQsIFNoYWRvd1Jvb3Q+LCB1bmlvbjxbU3R5bGVNb2R1bGVdLCBTdHlsZU1vZHVsZT4pXG4gIC8vXG4gIC8vIE1vdW50IHRoZSBnaXZlbiBzZXQgb2YgbW9kdWxlcyBpbiB0aGUgZ2l2ZW4gRE9NIHJvb3QsIHdoaWNoIGVuc3VyZXNcbiAgLy8gdGhhdCB0aGUgQ1NTIHJ1bGVzIGRlZmluZWQgYnkgdGhlIG1vZHVsZSBhcmUgYXZhaWxhYmxlIGluIHRoYXRcbiAgLy8gY29udGV4dC5cbiAgLy9cbiAgLy8gUnVsZXMgYXJlIG9ubHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50IG9uY2UgcGVyIHJvb3QuXG4gIC8vXG4gIC8vIFJ1bGUgb3JkZXIgd2lsbCBmb2xsb3cgdGhlIG9yZGVyIG9mIHRoZSBtb2R1bGVzLCBzbyB0aGF0IHJ1bGVzIGZyb21cbiAgLy8gbW9kdWxlcyBsYXRlciBpbiB0aGUgYXJyYXkgdGFrZSBwcmVjZWRlbmNlIG9mIHRob3NlIGZyb20gZWFybGllclxuICAvLyBtb2R1bGVzLiBJZiB5b3UgY2FsbCB0aGlzIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZSByb290XG4gIC8vIGluIGEgd2F5IHRoYXQgY2hhbmdlcyB0aGUgb3JkZXIgb2YgYWxyZWFkeSBtb3VudGVkIG1vZHVsZXMsIHRoZSBvbGRcbiAgLy8gb3JkZXIgd2lsbCBiZSBjaGFuZ2VkLlxuICBzdGF0aWMgbW91bnQocm9vdCwgbW9kdWxlcykge1xuICAgIChyb290W1NFVF0gfHwgbmV3IFN0eWxlU2V0KHJvb3QpKS5tb3VudChBcnJheS5pc0FycmF5KG1vZHVsZXMpID8gbW9kdWxlcyA6IFttb2R1bGVzXSlcbiAgfVxufVxuXG5sZXQgYWRvcHRlZFNldCA9IG51bGxcblxuY2xhc3MgU3R5bGVTZXQge1xuICBjb25zdHJ1Y3Rvcihyb290KSB7XG4gICAgaWYgKCFyb290LmhlYWQgJiYgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgdHlwZW9mIENTU1N0eWxlU2hlZXQgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGFkb3B0ZWRTZXQpIHtcbiAgICAgICAgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbYWRvcHRlZFNldC5zaGVldF0uY29uY2F0KHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzKVxuICAgICAgICByZXR1cm4gcm9vdFtTRVRdID0gYWRvcHRlZFNldFxuICAgICAgfVxuICAgICAgdGhpcy5zaGVldCA9IG5ldyBDU1NTdHlsZVNoZWV0XG4gICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFt0aGlzLnNoZWV0XS5jb25jYXQocm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpXG4gICAgICBhZG9wdGVkU2V0ID0gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlVGFnID0gKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290KS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIilcbiAgICAgIGxldCB0YXJnZXQgPSByb290LmhlYWQgfHwgcm9vdFxuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLnN0eWxlVGFnLCB0YXJnZXQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgdGhpcy5tb2R1bGVzID0gW11cbiAgICByb290W1NFVF0gPSB0aGlzXG4gIH1cblxuICBtb3VudChtb2R1bGVzKSB7XG4gICAgbGV0IHNoZWV0ID0gdGhpcy5zaGVldFxuICAgIGxldCBwb3MgPSAwIC8qIEN1cnJlbnQgcnVsZSBvZmZzZXQgKi8sIGogPSAwIC8qIEluZGV4IGludG8gdGhpcy5tb2R1bGVzICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbW9kID0gbW9kdWxlc1tpXSwgaW5kZXggPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihtb2QpXG4gICAgICBpZiAoaW5kZXggPCBqICYmIGluZGV4ID4gLTEpIHsgLy8gT3JkZXJpbmcgY29uZmxpY3RcbiAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgai0tXG4gICAgICAgIGluZGV4ID0gLTFcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGorKywgMCwgbW9kKVxuICAgICAgICBpZiAoc2hlZXQpIGZvciAobGV0IGsgPSAwOyBrIDwgbW9kLnJ1bGVzLmxlbmd0aDsgaysrKVxuICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUobW9kLnJ1bGVzW2tdLCBwb3MrKylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChqIDwgaW5kZXgpIHBvcyArPSB0aGlzLm1vZHVsZXNbaisrXS5ydWxlcy5sZW5ndGhcbiAgICAgICAgcG9zICs9IG1vZC5ydWxlcy5sZW5ndGhcbiAgICAgICAgaisrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzaGVldCkge1xuICAgICAgbGV0IHRleHQgPSBcIlwiXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGV4dCArPSB0aGlzLm1vZHVsZXNbaV0uZ2V0UnVsZXMoKSArIFwiXFxuXCJcbiAgICAgIHRoaXMuc3R5bGVUYWcudGV4dENvbnRlbnQgPSB0ZXh0XG4gICAgfVxuICB9XG59XG5cbi8vIFN0eWxlOjpPYmplY3Q8dW5pb248U3R5bGUsc3RyaW5nPj5cbi8vXG4vLyBBIHN0eWxlIGlzIGFuIG9iamVjdCB0aGF0LCBpbiB0aGUgc2ltcGxlIGNhc2UsIG1hcHMgQ1NTIHByb3BlcnR5XG4vLyBuYW1lcyB0byBzdHJpbmdzIGhvbGRpbmcgdGhlaXIgdmFsdWVzLCBhcyBpbiBge2NvbG9yOiBcInJlZFwiLFxuLy8gZm9udFdlaWdodDogXCJib2xkXCJ9YC4gVGhlIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBnaXZlbiBpblxuLy8gY2FtZWwtY2FzZeKAlHRoZSBsaWJyYXJ5IHdpbGwgaW5zZXJ0IGEgZGFzaCBiZWZvcmUgY2FwaXRhbCBsZXR0ZXJzXG4vLyB3aGVuIGNvbnZlcnRpbmcgdGhlbSB0byBDU1MuXG4vL1xuLy8gSWYgeW91IGluY2x1ZGUgYW4gdW5kZXJzY29yZSBpbiBhIHByb3BlcnR5IG5hbWUsIGl0IGFuZCBldmVyeXRoaW5nXG4vLyBhZnRlciBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0LCB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW5cbi8vIHByb3ZpZGluZyBhIHByb3BlcnR5IG11bHRpcGxlIHRpbWVzLCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4vLyByZWFzb25zLlxuLy9cbi8vIEEgcHJvcGVydHkgaW4gYSBzdHlsZSBvYmplY3QgY2FuIGFsc28gYmUgYSBzdWItc2VsZWN0b3IsIHdoaWNoXG4vLyBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gYWRkIGEgcHNldWRvLXNlbGVjdG9yIG9yIGEgY2hpbGRcbi8vIHNlbGVjdG9yLiBTdWNoIGEgcHJvcGVydHkgc2hvdWxkIGNvbnRhaW4gYSBgJmAgY2hhcmFjdGVyLCB3aGljaFxuLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgY3VycmVudCBzZWxlY3Rvci4gRm9yIGV4YW1wbGUgYHtcIiY6YmVmb3JlXCI6XG4vLyB7Y29udGVudDogJ1wiaGlcIid9fWAuIFN1Yi1zZWxlY3RvcnMgYW5kIHJlZ3VsYXIgcHJvcGVydGllcyBjYW5cbi8vIGZyZWVseSBiZSBtaXhlZCBpbiBhIGdpdmVuIG9iamVjdC4gQW55IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBgJmAgaXNcbi8vIGFzc3VtZWQgdG8gYmUgYSBzdWItc2VsZWN0b3IuXG4vL1xuLy8gRmluYWxseSwgYSBwcm9wZXJ0eSBjYW4gc3BlY2lmeSBhbiBALWJsb2NrIHRvIGJlIHdyYXBwZWQgYXJvdW5kIHRoZVxuLy8gc3R5bGVzIGRlZmluZWQgaW5zaWRlIHRoZSBvYmplY3QgdGhhdCdzIHRoZSBwcm9wZXJ0eSdzIHZhbHVlLiBGb3Jcbi8vIGV4YW1wbGUgdG8gY3JlYXRlIGEgbWVkaWEgcXVlcnkgeW91IGNhbiBkbyBge1wiQG1lZGlhIHNjcmVlbiBhbmRcbi8vIChtaW4td2lkdGg6IDQwMHB4KVwiOiB7Li4ufX1gLlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-mod/src/style-mod.js\n");

/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"base\": () => (/* binding */ base),\n/* harmony export */   \"keyName\": () => (/* binding */ keyName),\n/* harmony export */   \"shift\": () => (/* binding */ shift)\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n};\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n};\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent);\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nvar brokenModifierNames = mac || chrome && +chrome[1] < 57;\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\nfunction keyName(event) {\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == \"Unidentified\";\n  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || \"Unidentified\";\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\";\n  if (name == \"Del\") name = \"Delete\";\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\";\n  if (name == \"Up\") name = \"ArrowUp\";\n  if (name == \"Right\") name = \"ArrowRight\";\n  if (name == \"Down\") name = \"ArrowDown\";\n  return name;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5lcy5qcz85ZWE3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIlxufVxuXG52YXIgY2hyb21lID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBnZWNrbyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvR2Vja29cXC9cXGQrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxudmFyIGllID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFxcZHxUcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIGJyb2tlbk1vZGlmaWVyTmFtZXMgPSBtYWMgfHwgY2hyb21lICYmICtjaHJvbWVbMV0gPCA1N1xuXG4vLyBGaWxsIGluIHRoZSBkaWdpdCBrZXlzXG5mb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIGJhc2VbNDggKyBpXSA9IGJhc2VbOTYgKyBpXSA9IFN0cmluZyhpKVxuXG4vLyBUaGUgZnVuY3Rpb24ga2V5c1xuZm9yICh2YXIgaSA9IDE7IGkgPD0gMjQ7IGkrKykgYmFzZVtpICsgMTExXSA9IFwiRlwiICsgaVxuXG4vLyBBbmQgdGhlIGFscGhhYmV0aWMga2V5c1xuZm9yICh2YXIgaSA9IDY1OyBpIDw9IDkwOyBpKyspIHtcbiAgYmFzZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDMyKVxuICBzaGlmdFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSlcbn1cblxuLy8gRm9yIGVhY2ggY29kZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIHNoaWZ0LWVxdWl2YWxlbnQsIGNvcHkgdGhlIGJhc2UgbmFtZVxuZm9yICh2YXIgY29kZSBpbiBiYXNlKSBpZiAoIXNoaWZ0Lmhhc093blByb3BlcnR5KGNvZGUpKSBzaGlmdFtjb2RlXSA9IGJhc2VbY29kZV1cblxuZXhwb3J0IGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQpIHtcbiAgdmFyIGlnbm9yZUtleSA9IGJyb2tlbk1vZGlmaWVyTmFtZXMgJiYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHx8XG4gICAgaWUgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT0gMSB8fFxuICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/w3c-keyname/index.es.js\n");

/***/ })

}]);