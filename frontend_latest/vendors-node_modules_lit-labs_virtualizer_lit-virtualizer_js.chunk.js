"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_lit-virtualizer_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/LitVirtualizer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/LitVirtualizer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LitVirtualizer\": () => (/* binding */ LitVirtualizer)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators/property.js */ \"./node_modules/lit/decorators/property.js\");\n/* harmony import */ var _virtualize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./virtualize.js */ \"./node_modules/@lit-labs/virtualizer/virtualize.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n\nclass LitVirtualizer extends lit__WEBPACK_IMPORTED_MODULE_0__.LitElement {\n  constructor() {\n    super(...arguments);\n    this.items = [];\n    this.renderItem = _virtualize_js__WEBPACK_IMPORTED_MODULE_2__.defaultRenderItem;\n    this.keyFunction = _virtualize_js__WEBPACK_IMPORTED_MODULE_2__.defaultKeyFunction;\n    this.layout = {};\n    this.scroller = false;\n  }\n  createRenderRoot() {\n    return this;\n  }\n  render() {\n    const {\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller\n    } = this;\n    return lit__WEBPACK_IMPORTED_MODULE_0__.html`${(0,_virtualize_js__WEBPACK_IMPORTED_MODULE_2__.virtualize)({\n      items,\n      renderItem,\n      keyFunction,\n      layout,\n      scroller\n    })}`;\n  }\n  element(index) {\n    var _a;\n    return (_a = this[_virtualize_js__WEBPACK_IMPORTED_MODULE_2__.virtualizerRef]) === null || _a === void 0 ? void 0 : _a.element(index);\n  }\n  get layoutComplete() {\n    var _a;\n    return (_a = this[_virtualize_js__WEBPACK_IMPORTED_MODULE_2__.virtualizerRef]) === null || _a === void 0 ? void 0 : _a.layoutComplete;\n  }\n  /**\n   * This scrollToIndex() shim is here to provide backwards compatibility with other 0.x versions of\n   * lit-virtualizer. It is deprecated and will likely be removed in the 1.0.0 release.\n   */\n  scrollToIndex(index, position = 'start') {\n    var _a;\n    (_a = this.element(index)) === null || _a === void 0 ? void 0 : _a.scrollIntoView({\n      block: position\n    });\n  }\n}\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  attribute: false\n})], LitVirtualizer.prototype, \"items\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()], LitVirtualizer.prototype, \"renderItem\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)()], LitVirtualizer.prototype, \"keyFunction\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  attribute: false\n})], LitVirtualizer.prototype, \"layout\", void 0);\n(0,tslib__WEBPACK_IMPORTED_MODULE_3__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  reflect: true,\n  type: Boolean\n})], LitVirtualizer.prototype, \"scroller\", void 0);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL0xpdFZpcnR1YWxpemVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7OztBQU1BO0FBQ0E7QUFHQTtBQVNBO0FBQUE7O0FBRUE7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQW1DQTtBQWpDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTs7QUFJQTtBQUFBO0FBQUE7QUFDQTs7QUE5Q0E7QUFEQTtBQUFBO0FBSUE7QUFHQTtBQUdBO0FBREE7QUFBQTtBQUlBO0FBREE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC9zcmMvTGl0VmlydHVhbGl6ZXIudHM/ZDdiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtodG1sLCBMaXRFbGVtZW50fSBmcm9tICdsaXQnO1xuaW1wb3J0IHtwcm9wZXJ0eX0gZnJvbSAnbGl0L2RlY29yYXRvcnMvcHJvcGVydHkuanMnO1xuaW1wb3J0IHtLZXlGbn0gZnJvbSAnbGl0L2RpcmVjdGl2ZXMvcmVwZWF0LmpzJztcbmltcG9ydCB7TGF5b3V0Q29uZmlnVmFsdWV9IGZyb20gJy4vbGF5b3V0cy9zaGFyZWQvTGF5b3V0LmpzJztcbmltcG9ydCB7XG4gIHZpcnR1YWxpemUsXG4gIHZpcnR1YWxpemVyUmVmLFxuICBWaXJ0dWFsaXplckhvc3RFbGVtZW50LFxuICBkZWZhdWx0UmVuZGVySXRlbSxcbiAgZGVmYXVsdEtleUZ1bmN0aW9uLFxuICBSZW5kZXJJdGVtRnVuY3Rpb24sXG59IGZyb20gJy4vdmlydHVhbGl6ZS5qcyc7XG5cbmV4cG9ydCBjbGFzcyBMaXRWaXJ0dWFsaXplcjxUID0gdW5rbm93bj4gZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgQHByb3BlcnR5KHthdHRyaWJ1dGU6IGZhbHNlfSlcbiAgaXRlbXM6IFRbXSA9IFtdO1xuXG4gIEBwcm9wZXJ0eSgpXG4gIHJlbmRlckl0ZW06IFJlbmRlckl0ZW1GdW5jdGlvbjxUPiA9IGRlZmF1bHRSZW5kZXJJdGVtO1xuXG4gIEBwcm9wZXJ0eSgpXG4gIGtleUZ1bmN0aW9uOiBLZXlGbjxUPiA9IGRlZmF1bHRLZXlGdW5jdGlvbjtcblxuICBAcHJvcGVydHkoe2F0dHJpYnV0ZTogZmFsc2V9KVxuICBsYXlvdXQ6IExheW91dENvbmZpZ1ZhbHVlID0ge307XG5cbiAgQHByb3BlcnR5KHtyZWZsZWN0OiB0cnVlLCB0eXBlOiBCb29sZWFufSlcbiAgc2Nyb2xsZXIgPSBmYWxzZTtcblxuICBjcmVhdGVSZW5kZXJSb290KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtpdGVtcywgcmVuZGVySXRlbSwga2V5RnVuY3Rpb24sIGxheW91dCwgc2Nyb2xsZXJ9ID0gdGhpcztcbiAgICByZXR1cm4gaHRtbGAke3ZpcnR1YWxpemUoe1xuICAgICAgaXRlbXMsXG4gICAgICByZW5kZXJJdGVtLFxuICAgICAga2V5RnVuY3Rpb24sXG4gICAgICBsYXlvdXQsXG4gICAgICBzY3JvbGxlcixcbiAgICB9KX1gO1xuICB9XG5cbiAgZWxlbWVudChpbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuICh0aGlzIGFzIFZpcnR1YWxpemVySG9zdEVsZW1lbnQpW3ZpcnR1YWxpemVyUmVmXT8uZWxlbWVudChpbmRleCk7XG4gIH1cblxuICBnZXQgbGF5b3V0Q29tcGxldGUoKSB7XG4gICAgcmV0dXJuICh0aGlzIGFzIFZpcnR1YWxpemVySG9zdEVsZW1lbnQpW3ZpcnR1YWxpemVyUmVmXT8ubGF5b3V0Q29tcGxldGU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBzY3JvbGxUb0luZGV4KCkgc2hpbSBpcyBoZXJlIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvdGhlciAwLnggdmVyc2lvbnMgb2ZcbiAgICogbGl0LXZpcnR1YWxpemVyLiBJdCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIHRoZSAxLjAuMCByZWxlYXNlLlxuICAgKi9cbiAgc2Nyb2xsVG9JbmRleChcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIHBvc2l0aW9uOiAnc3RhcnQnIHwgJ2NlbnRlcicgfCAnZW5kJyB8ICduZWFyZXN0JyA9ICdzdGFydCdcbiAgKSB7XG4gICAgdGhpcy5lbGVtZW50KGluZGV4KT8uc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBwb3NpdGlvbn0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/LitVirtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/ScrollerController.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/ScrollerController.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScrollerController\": () => (/* binding */ ScrollerController),\n/* harmony export */   \"ScrollerShim\": () => (/* binding */ ScrollerShim)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass ScrollerShim {\n  constructor(element) {\n    this._node = null;\n    this._element = null;\n    const node = element !== null && element !== void 0 ? element : window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n  get element() {\n    return this._element || document.scrollingElement || document.documentElement;\n  }\n  get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n  get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n  get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n  get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n  get viewportHeight() {\n    return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;\n  }\n  get viewportWidth() {\n    return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;\n  }\n  get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n  get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\nclass ScrollerController extends ScrollerShim {\n  constructor(client, element) {\n    super(element);\n    this._originalScrollTo = null;\n    this._originalScrollBy = null;\n    this._originalScroll = null;\n    this._clients = [];\n    this._retarget = null;\n    this._end = null;\n    this.__destination = null;\n    this.correctingScrollError = false;\n    const node = this._node;\n    const instance = ScrollerController._instanceMap.get(node);\n    if (instance) {\n      instance._attach(client);\n      return instance;\n    } else {\n      this._checkForArrival = this._checkForArrival.bind(this);\n      this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n      this.scrollTo = this.scrollTo.bind(this);\n      this.scrollBy = this.scrollBy.bind(this);\n      this._originalScrollTo = node.scrollTo;\n      this._originalScrollBy = node.scrollBy;\n      this._originalScroll = node.scroll;\n      this._attach(client);\n    }\n  }\n  get _destination() {\n    return this.__destination;\n  }\n  get scrolling() {\n    return this._destination !== null;\n  }\n  scrollTo(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    this._scrollTo(options);\n  }\n  scrollBy(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n  _nativeScrollTo(options) {\n    this._originalScrollTo.bind(this._element || window)(options);\n  }\n  _scrollTo(options, retarget = null, end = null) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n  _setDestination(options) {\n    let {\n      top,\n      left\n    } = options;\n    top = top === undefined ? undefined : Math.max(0, Math.min(top, this.maxScrollTop));\n    left = left === undefined ? undefined : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (this._destination !== null && left === this._destination.left && top === this._destination.top) {\n      return false;\n    }\n    this.__destination = {\n      top,\n      left,\n      behavior: 'smooth'\n    };\n    return true;\n  }\n  _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n  _updateManagedScrollTo(coordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n  managedScrollTo(options, retarget, end) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n  correctScrollError(coordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() => requestAnimationFrame(() => this.correctingScrollError = false));\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n  _checkForArrival() {\n    if (this._destination !== null) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this;\n      let {\n        top,\n        left\n      } = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n  detach(client) {\n    this._clients = this._clients.splice(this._clients.indexOf(client), 1);\n    if (this._clients.length === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n  _attach(client) {\n    this._clients.push(client);\n    if (this._clients.length === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\nScrollerController._instanceMap = new WeakMap();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1Njcm9sbGVyQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztBQVdBO0FBSUE7QUFIQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFvQkE7QUFDQTtBQWxCQTtBQUlBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTtBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUlBO0FBS0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFyTUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kL3NyYy9TY3JvbGxlckNvbnRyb2xsZXIudHM/YWQyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtTY3JvbGxUb0Nvb3JkaW5hdGVzfSBmcm9tICcuL2xheW91dHMvc2hhcmVkL0xheW91dC5qcyc7XG5cbnR5cGUgcmV0YXJnZXRTY3JvbGxDYWxsYmFjayA9ICgpID0+IFNjcm9sbFRvQ29vcmRpbmF0ZXM7XG50eXBlIGVuZFNjcm9sbENhbGxiYWNrID0gKCkgPT4gdm9pZDtcblxuZXhwb3J0IGNsYXNzIFNjcm9sbGVyU2hpbSB7XG4gIHByb3RlY3RlZCBfbm9kZTogRWxlbWVudCB8IFdpbmRvdyB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgX2VsZW1lbnQ6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50PzogRWxlbWVudCkge1xuICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50ID8/IHdpbmRvdztcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9lbGVtZW50IHx8IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wIHx8IHdpbmRvdy5zY3JvbGxZO1xuICB9XG5cbiAgcHVibGljIGdldCBzY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCB8fCB3aW5kb3cuc2Nyb2xsWDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldCBzY3JvbGxXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNjcm9sbFdpZHRoO1xuICB9XG5cbiAgcHVibGljIGdldCB2aWV3cG9ydEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFxuICAgICAgPyB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgOiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZpZXdwb3J0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRcbiAgICAgID8gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgICAgOiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbWF4U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodCAtIHRoaXMudmlld3BvcnRIZWlnaHQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1heFNjcm9sbExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsV2lkdGggLSB0aGlzLnZpZXdwb3J0V2lkdGg7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNjcm9sbGVyQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbGVyU2hpbSB7XG4gIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZU1hcDogV2Vha01hcDxFbGVtZW50IHwgV2luZG93LCBTY3JvbGxlckNvbnRyb2xsZXI+ID1cbiAgICBuZXcgV2Vha01hcCgpO1xuICBwcml2YXRlIF9vcmlnaW5hbFNjcm9sbFRvOlxuICAgIHwgdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgfCB0eXBlb2Ygd2luZG93LnNjcm9sbFRvXG4gICAgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfb3JpZ2luYWxTY3JvbGxCeTpcbiAgICB8IHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeVxuICAgIHwgdHlwZW9mIHdpbmRvdy5zY3JvbGxCeVxuICAgIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX29yaWdpbmFsU2Nyb2xsOlxuICAgIHwgdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFxuICAgIHwgdHlwZW9mIHdpbmRvdy5zY3JvbGxcbiAgICB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9jbGllbnRzOiBBcnJheTx1bmtub3duPiA9IFtdO1xuICBwcml2YXRlIF9yZXRhcmdldDogcmV0YXJnZXRTY3JvbGxDYWxsYmFjayB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9lbmQ6IGVuZFNjcm9sbENhbGxiYWNrIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX19kZXN0aW5hdGlvbjogU2Nyb2xsVG9PcHRpb25zIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY2xpZW50OiB1bmtub3duLCBlbGVtZW50PzogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2RlITtcbiAgICBjb25zdCBpbnN0YW5jZSA9IFNjcm9sbGVyQ29udHJvbGxlci5faW5zdGFuY2VNYXAuZ2V0KG5vZGUhKTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLl9hdHRhY2goY2xpZW50KTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2hlY2tGb3JBcnJpdmFsID0gdGhpcy5fY2hlY2tGb3JBcnJpdmFsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl91cGRhdGVNYW5hZ2VkU2Nyb2xsVG8gPSB0aGlzLl91cGRhdGVNYW5hZ2VkU2Nyb2xsVG8uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuc2Nyb2xsVG8gPSB0aGlzLnNjcm9sbFRvLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnNjcm9sbEJ5ID0gdGhpcy5zY3JvbGxCeS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb3JpZ2luYWxTY3JvbGxUbyA9IG5vZGUuc2Nyb2xsVG87XG4gICAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbEJ5ID0gbm9kZS5zY3JvbGxCeTtcbiAgICAgIHRoaXMuX29yaWdpbmFsU2Nyb2xsID0gbm9kZS5zY3JvbGw7XG4gICAgICB0aGlzLl9hdHRhY2goY2xpZW50KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29ycmVjdGluZ1Njcm9sbEVycm9yID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBnZXQgX2Rlc3RpbmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZGVzdGluYXRpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNjcm9sbGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVzdGluYXRpb24gIT09IG51bGw7XG4gIH1cblxuICBwdWJsaWMgc2Nyb2xsVG8ob3B0aW9uczogU2Nyb2xsVG9PcHRpb25zKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbFRvKHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbFRvKHAxOiBTY3JvbGxUb09wdGlvbnMgfCBudW1iZXIsIHAyPzogbnVtYmVyKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbFRvKHAxOiBTY3JvbGxUb09wdGlvbnMgfCBudW1iZXIsIHAyPzogbnVtYmVyKSB7XG4gICAgY29uc3Qgb3B0aW9uczogU2Nyb2xsVG9PcHRpb25zID1cbiAgICAgIHR5cGVvZiBwMSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHAyID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHtsZWZ0OiBwMSwgdG9wOiBwMn1cbiAgICAgICAgOiAocDEgYXMgU2Nyb2xsVG9PcHRpb25zKTtcbiAgICB0aGlzLl9zY3JvbGxUbyhvcHRpb25zKTtcbiAgfVxuXG4gIHB1YmxpYyBzY3JvbGxCeShvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMpOiB2b2lkO1xuICBwdWJsaWMgc2Nyb2xsQnkoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkO1xuICBwdWJsaWMgc2Nyb2xsQnkocDE6IFNjcm9sbFRvT3B0aW9ucyB8IG51bWJlciwgcDI/OiBudW1iZXIpOiB2b2lkO1xuICBwdWJsaWMgc2Nyb2xsQnkocDE6IFNjcm9sbFRvT3B0aW9ucyB8IG51bWJlciwgcDI/OiBudW1iZXIpIHtcbiAgICBjb25zdCBvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMgPVxuICAgICAgdHlwZW9mIHAxID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcDIgPT09ICdudW1iZXInXG4gICAgICAgID8ge2xlZnQ6IHAxLCB0b3A6IHAyfVxuICAgICAgICA6IChwMSBhcyBTY3JvbGxUb09wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnRvcCArPSB0aGlzLnNjcm9sbFRvcDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmxlZnQgKz0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgICB0aGlzLl9zY3JvbGxUbyhvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgX25hdGl2ZVNjcm9sbFRvKG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucykge1xuICAgIHRoaXMuX29yaWdpbmFsU2Nyb2xsVG8hLmJpbmQodGhpcy5fZWxlbWVudCB8fCB3aW5kb3cpKG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2Nyb2xsVG8oXG4gICAgb3B0aW9uczogU2Nyb2xsVG9PcHRpb25zLFxuICAgIHJldGFyZ2V0OiByZXRhcmdldFNjcm9sbENhbGxiYWNrIHwgbnVsbCA9IG51bGwsXG4gICAgZW5kOiBlbmRTY3JvbGxDYWxsYmFjayB8IG51bGwgPSBudWxsXG4gICkge1xuICAgIGlmICh0aGlzLl9lbmQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2VuZCgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgIHRoaXMuX3NldERlc3RpbmF0aW9uKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fcmV0YXJnZXQgPSByZXRhcmdldDtcbiAgICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzZXRTY3JvbGxTdGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLl9uYXRpdmVTY3JvbGxUbyhvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NldERlc3RpbmF0aW9uKG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucykge1xuICAgIGxldCB7dG9wLCBsZWZ0fSA9IG9wdGlvbnM7XG4gICAgdG9wID1cbiAgICAgIHRvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4odG9wLCB0aGlzLm1heFNjcm9sbFRvcCkpO1xuICAgIGxlZnQgPVxuICAgICAgbGVmdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4obGVmdCwgdGhpcy5tYXhTY3JvbGxMZWZ0KSk7XG4gICAgaWYgKFxuICAgICAgdGhpcy5fZGVzdGluYXRpb24gIT09IG51bGwgJiZcbiAgICAgIGxlZnQgPT09IHRoaXMuX2Rlc3RpbmF0aW9uLmxlZnQgJiZcbiAgICAgIHRvcCA9PT0gdGhpcy5fZGVzdGluYXRpb24udG9wXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX19kZXN0aW5hdGlvbiA9IHt0b3AsIGxlZnQsIGJlaGF2aW9yOiAnc21vb3RoJ307XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIF9yZXNldFNjcm9sbFN0YXRlKCkge1xuICAgIHRoaXMuX19kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fcmV0YXJnZXQgPSBudWxsO1xuICAgIHRoaXMuX2VuZCA9IG51bGw7XG4gIH1cblxuICBwcml2YXRlIF91cGRhdGVNYW5hZ2VkU2Nyb2xsVG8oY29vcmRpbmF0ZXM6IFNjcm9sbFRvQ29vcmRpbmF0ZXMpIHtcbiAgICBpZiAodGhpcy5fZGVzdGluYXRpb24pIHtcbiAgICAgIGlmICh0aGlzLl9zZXREZXN0aW5hdGlvbihjb29yZGluYXRlcykpIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlU2Nyb2xsVG8odGhpcy5fZGVzdGluYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBtYW5hZ2VkU2Nyb2xsVG8oXG4gICAgb3B0aW9uczogU2Nyb2xsVG9PcHRpb25zLFxuICAgIHJldGFyZ2V0OiByZXRhcmdldFNjcm9sbENhbGxiYWNrLFxuICAgIGVuZDogZW5kU2Nyb2xsQ2FsbGJhY2tcbiAgKSB7XG4gICAgdGhpcy5fc2Nyb2xsVG8ob3B0aW9ucywgcmV0YXJnZXQsIGVuZCk7XG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1hbmFnZWRTY3JvbGxUbztcbiAgfVxuXG4gIHB1YmxpYyBjb3JyZWN0U2Nyb2xsRXJyb3IoY29vcmRpbmF0ZXM6IFNjcm9sbFRvQ29vcmRpbmF0ZXMpIHtcbiAgICB0aGlzLmNvcnJlY3RpbmdTY3JvbGxFcnJvciA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gKHRoaXMuY29ycmVjdGluZ1Njcm9sbEVycm9yID0gZmFsc2UpKVxuICAgICk7XG4gICAgLy8gQ29ycmVjdCB0aGUgZXJyb3JcbiAgICB0aGlzLl9uYXRpdmVTY3JvbGxUbyhjb29yZGluYXRlcyk7XG4gICAgLy8gVGhlbiwgaWYgd2Ugd2VyZSBoZWFkZWQgZm9yIGEgc3BlY2lmaWMgZGVzdGluYXRpb24sIHdlIGNvbnRpbnVlIHNjcm9sbGluZzpcbiAgICAvLyBGaXJzdCwgd2UgdXBkYXRlIG91ciB0YXJnZXQgZGVzdGluYXRpb24sIGlmIGFwcGxpY2FibGUuLi5cbiAgICBpZiAodGhpcy5fcmV0YXJnZXQpIHtcbiAgICAgIHRoaXMuX3NldERlc3RpbmF0aW9uKHRoaXMuX3JldGFyZ2V0KCkpO1xuICAgIH1cbiAgICAvLyBUaGVuIHdlIGdvIGFoZWFkIGFuZCByZXN1bWUgc2Nyb2xsaW5nXG4gICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLl9uYXRpdmVTY3JvbGxUbyh0aGlzLl9kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tGb3JBcnJpdmFsKCkge1xuICAgIGlmICh0aGlzLl9kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge3Njcm9sbFRvcCwgc2Nyb2xsTGVmdH0gPSB0aGlzO1xuICAgICAgbGV0IHt0b3AsIGxlZnR9ID0gdGhpcy5fZGVzdGluYXRpb247XG4gICAgICB0b3AgPSBNYXRoLm1pbih0b3AgfHwgMCwgdGhpcy5tYXhTY3JvbGxUb3ApO1xuICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQgfHwgMCwgdGhpcy5tYXhTY3JvbGxMZWZ0KTtcbiAgICAgIGNvbnN0IHRvcERpZmYgPSBNYXRoLmFicyh0b3AgLSBzY3JvbGxUb3ApO1xuICAgICAgY29uc3QgbGVmdERpZmYgPSBNYXRoLmFicyhsZWZ0IC0gc2Nyb2xsTGVmdCk7XG4gICAgICAvLyBXZSBjaGVjayB0byBzZWUgaWYgd2UndmUgYXJyaXZlZCBhdCBvdXIgZGVzdGluYXRpb24uXG4gICAgICBpZiAodG9wRGlmZiA8IDEgJiYgbGVmdERpZmYgPCAxKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbmQpIHtcbiAgICAgICAgICB0aGlzLl9lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNldFNjcm9sbFN0YXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRldGFjaChjbGllbnQ6IHVua25vd24pIHtcbiAgICB0aGlzLl9jbGllbnRzID0gdGhpcy5fY2xpZW50cy5zcGxpY2UodGhpcy5fY2xpZW50cy5pbmRleE9mKGNsaWVudCksIDEpO1xuICAgIGlmICh0aGlzLl9jbGllbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fbm9kZSEuc2Nyb2xsVG8gPSB0aGlzLl9vcmlnaW5hbFNjcm9sbFRvITtcbiAgICAgIHRoaXMuX25vZGUhLnNjcm9sbEJ5ID0gdGhpcy5fb3JpZ2luYWxTY3JvbGxCeSE7XG4gICAgICB0aGlzLl9ub2RlIS5zY3JvbGwgPSB0aGlzLl9vcmlnaW5hbFNjcm9sbCE7XG4gICAgICB0aGlzLl9ub2RlIS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9jaGVja0ZvckFycml2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgX2F0dGFjaChjbGllbnQ6IHVua25vd24pIHtcbiAgICB0aGlzLl9jbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICBpZiAodGhpcy5fY2xpZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuX25vZGUhLnNjcm9sbFRvID0gdGhpcy5zY3JvbGxUbztcbiAgICAgIHRoaXMuX25vZGUhLnNjcm9sbEJ5ID0gdGhpcy5zY3JvbGxCeTtcbiAgICAgIHRoaXMuX25vZGUhLnNjcm9sbCA9IHRoaXMuc2Nyb2xsVG87XG4gICAgICB0aGlzLl9ub2RlIS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9jaGVja0ZvckFycml2YWwpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/ScrollerController.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/Virtualizer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/Virtualizer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Virtualizer\": () => (/* binding */ Virtualizer),\n/* harmony export */   \"virtualizerRef\": () => (/* binding */ virtualizerRef)\n/* harmony export */ });\n/* harmony import */ var _polyfillLoaders_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfillLoaders/ResizeObserver.js */ \"./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@lit-labs/virtualizer/events.js\");\n/* harmony import */ var _ScrollerController_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScrollerController.js */ \"./node_modules/@lit-labs/virtualizer/ScrollerController.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\nconst virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nlet DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nclass Virtualizer {\n  constructor(config) {\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  set items(items) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n  _init(config) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    this._initLayout(config.layout || {});\n  }\n  async _initObservers() {\n    this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n    const ResizeObserver = await (0,_polyfillLoaders_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    this._hostElementRO = new ResizeObserver(() => this._hostElementSizeChanged());\n    this._childrenRO = new ResizeObserver(this._childrenSizeChanged.bind(this));\n  }\n  _initHostElement(config) {\n    const hostElement = this._hostElement = config.hostElement;\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n  async connected() {\n    await this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n    this._scrollerController = new _ScrollerController_js__WEBPACK_IMPORTED_MODULE_2__.ScrollerController(this, this._clippingAncestors[0]);\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n  _observeAndListen() {\n    this._mutationObserver.observe(this._hostElement, {\n      childList: true\n    });\n    this._hostElementRO.observe(this._hostElement);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO.observe(ancestor);\n    });\n    this._hostElementRO.observe(this._scrollerController.element);\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._scrollEventListeners.forEach(target => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n  }\n  disconnected() {\n    var _a, _b, _c, _d;\n    this._scrollEventListeners.forEach(target => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController = ((_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.detach(this)) || null;\n    (_b = this._mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    (_c = this._hostElementRO) === null || _c === void 0 ? void 0 : _c.disconnect();\n    (_d = this._childrenRO) === null || _d === void 0 ? void 0 : _d.disconnect();\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n  _applyVirtualizerStyles() {\n    const hostElement = this._hostElement;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style;\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n  _getSizer() {\n    const hostElement = this._hostElement;\n    if (!this._sizer) {\n      // Use a pre-existing sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.innerHTML = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n  updateLayoutConfig(layoutConfig) {\n    const Ctor = layoutConfig.type || DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {\n        ...layoutConfig\n      };\n      delete config.type;\n      this._layout.config = config;\n      return true;\n    }\n    return false;\n  }\n  async _initLayout(layoutConfig) {\n    let config;\n    let Ctor;\n    if (typeof layoutConfig.type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = layoutConfig.type;\n      // ...while the rest of the specifier is our layout config\n      const copy = {\n        ...layoutConfig\n      };\n      delete copy.type;\n      config = copy;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig;\n    }\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js\"), __webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_flow_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./layouts/flow.js */ \"./node_modules/@lit-labs/virtualizer/layouts/flow.js\"))).FlowLayout;\n    }\n    this._layout = new Ctor(config);\n    if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n    this._layout.addEventListener('scrollsizechange', this);\n    this._layout.addEventListener('scrollerrorchange', this);\n    this._layout.addEventListener('itempositionchange', this);\n    this._layout.addEventListener('rangechange', this);\n    this._layout.addEventListener('unpinned', this);\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement.addEventListener('load', this._loadListener, true);\n    }\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n      const virtualizationTime = entries.filter(e => e.startTime >= this._benchmarkStart && e.startTime < now).reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {\n        timeElapsed,\n        virtualizationTime\n      };\n    }\n    return null;\n  }\n  _measureChildren() {\n    const mm = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element) {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {\n      width,\n      height\n    } = element.getBoundingClientRect();\n    return Object.assign({\n      width,\n      height\n    }, getMargins(element));\n  }\n  async _schedule(method) {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n  async _updateDOM() {\n    const {\n      _rangeChanged,\n      _itemsChanged\n    } = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    } else {\n      this._finishDOMUpdate();\n    }\n  }\n  _finishDOMUpdate() {\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n  _updateLayout() {\n    if (this._layout) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n  _handleScrollEvent() {\n    var _a;\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      (_a = this._layout) === null || _a === void 0 ? void 0 : _a.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n  handleEvent(event) {\n    switch (event.type) {\n      case 'scroll':\n        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n          this._handleScrollEvent();\n        }\n        break;\n      case 'scrollsizechange':\n        this._scrollSize = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'scrollerrorchange':\n        this._scrollError = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'itempositionchange':\n        this._childrenPos = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'rangechange':\n        this._adjustRange(event.detail);\n        this._schedule(this._updateDOM);\n        break;\n      case 'unpinned':\n        this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_1__.UnpinnedEvent());\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n  get _children() {\n    const arr = [];\n    let next = this._hostElement.firstElementChild;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling;\n    }\n    return arr;\n  }\n  _updateView() {\n    var _a;\n    const hostElement = this._hostElement;\n    const scrollingElement = (_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.element;\n    const layout = this._layout;\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n      const hostElementBounds = hostElement.getBoundingClientRect();\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      const ancestorBounds = this._clippingAncestors.map(ancestor => ancestor.getBoundingClientRect());\n      ancestorBounds.unshift(hostElementBounds);\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top\n      };\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight\n      };\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n      const height = Math.max(1, bottom - top);\n      const width = Math.max(1, right - left);\n      layout.viewportSize = {\n        width,\n        height\n      };\n      layout.viewportScroll = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  _sizeHostElement(size) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement.style;\n      style.minWidth = h ? `${h}px` : '100%';\n      style.minHeight = v ? `${v}px` : '100%';\n    }\n  }\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  _positionChildren(pos) {\n    if (pos) {\n      pos.forEach(({\n        top,\n        left,\n        width,\n        height,\n        xOffset,\n        yOffset\n      }, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          child.style.left = xOffset === undefined ? null : xOffset + 'px';\n          child.style.top = yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n  async _adjustRange(range) {\n    const {\n      _first,\n      _last,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n  }\n  _correctScrollError() {\n    if (this._scrollError) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this._scrollerController;\n      const {\n        top,\n        left\n      } = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left\n      });\n    }\n  }\n  element(index) {\n    var _a;\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return ((_a = this._items) === null || _a === void 0 ? void 0 : _a[index]) === undefined ? undefined : {\n      scrollIntoView: (options = {}) => this._scrollElementIntoView({\n        ...options,\n        index\n      })\n    };\n  }\n  _scrollElementIntoView(options) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout.getScrollIntoViewCoordinates(options);\n        const {\n          behavior\n        } = options;\n        this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n          behavior\n        }), () => this._layout.getScrollIntoViewCoordinates(options), () => this._scrollIntoViewTarget = null);\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout.pin = options;\n      }\n    }\n  }\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  _checkScrollIntoViewTarget(pos) {\n    const {\n      index\n    } = this._scrollIntoViewTarget || {};\n    if (index && (pos === null || pos === void 0 ? void 0 : pos.has(index))) {\n      this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n    }\n  }\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  _notifyRange() {\n    this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_1__.RangeChangedEvent({\n      first: this._first,\n      last: this._last\n    }));\n  }\n  _notifyVisibility() {\n    this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_1__.VisibilityChangedEvent({\n      first: this._firstVisible,\n      last: this._lastVisible\n    }));\n  }\n  get layoutComplete() {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n  _rejectLayoutCompletePromise(reason) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n  _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));\n    }\n  }\n  _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n  _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n  _childLoaded() {}\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  _childrenSizeChanged(changes) {\n    // Only measure if the layout requires it\n    if (this._layout.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(change.target, change.contentRect);\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\nfunction getMargins(el) {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n  return getElementAncestors(el, includeSelf).filter(a => getComputedStyle(a).overflow !== 'visible');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1ZpcnR1YWxpemVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFnQkE7QUFLQTtBQUVBO0FBQ0E7QUE0Q0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQTRIQTtBQTNIQTtBQUVBO0FBRUE7QUFFQTs7OztBQUlBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQU9BO0FBRUE7QUFFQTtBQUVBOzs7QUFHQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7O0FBS0E7QUFFQTtBQUlBOzs7QUFHQTtBQUVBOzs7O0FBSUE7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTtBQUVBOzs7OztBQUtBO0FBR0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7O0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBSUE7QUFFQTtBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBOztBQUdBOztBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFJQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kL3NyYy9WaXJ0dWFsaXplci50cz83NTU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQgZ2V0UmVzaXplT2JzZXJ2ZXIgZnJvbSAnLi9wb2x5ZmlsbExvYWRlcnMvUmVzaXplT2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHtcbiAgSXRlbUJveCxcbiAgTWFyZ2lucyxcbiAgTGF5b3V0Q29uZmlnVmFsdWUsXG4gIENoaWxkUG9zaXRpb25zLFxuICBDaGlsZE1lYXN1cmVtZW50cyxcbiAgTGF5b3V0LFxuICBMYXlvdXRDb25zdHJ1Y3RvcixcbiAgTGF5b3V0U3BlY2lmaWVyLFxuICBTaXplLFxuICBJbnRlcm5hbFJhbmdlLFxuICBNZWFzdXJlQ2hpbGRGdW5jdGlvbixcbiAgU2Nyb2xsVG9Db29yZGluYXRlcyxcbiAgQmFzZUxheW91dENvbmZpZyxcbn0gZnJvbSAnLi9sYXlvdXRzL3NoYXJlZC9MYXlvdXQuanMnO1xuaW1wb3J0IHtcbiAgUmFuZ2VDaGFuZ2VkRXZlbnQsXG4gIFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQsXG4gIFVucGlubmVkRXZlbnQsXG59IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7U2Nyb2xsZXJDb250cm9sbGVyfSBmcm9tICcuL1Njcm9sbGVyQ29udHJvbGxlci5qcyc7XG5cbmV4cG9ydCBjb25zdCB2aXJ0dWFsaXplclJlZiA9IFN5bWJvbCgndmlydHVhbGl6ZXJSZWYnKTtcbmNvbnN0IFNJWkVSX0FUVFJJQlVURSA9ICd2aXJ0dWFsaXplci1zaXplcic7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIEhUTUxFbGVtZW50RXZlbnRNYXAge1xuICAgIHJhbmdlQ2hhbmdlZDogUmFuZ2VDaGFuZ2VkRXZlbnQ7XG4gICAgdmlzaWJpbGl0eUNoYW5nZWQ6IFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQ7XG4gICAgdW5waW5uZWQ6IFVucGlubmVkRXZlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXJ0dWFsaXplckhvc3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBbdmlydHVhbGl6ZXJSZWZdPzogVmlydHVhbGl6ZXI7XG59XG5cbi8qKlxuICogQSB2ZXJ5IGxpbWl0ZWQgcHJveHkgb2JqZWN0IGZvciBhIHZpcnR1YWxpemVyIGNoaWxkLFxuICogcmV0dXJuZWQgYnkgVmlydHVhbGl6ZXIuZWxlbWVudChpZHg6IG51bWJlcikuIEludHJvZHVjZWRcbiAqIHRvIGVuYWJsZSBzY3JvbGxpbmcgYSB2aXJ0dWFsIGVsZW1lbnQgaW50byB2aWV3IHVzaW5nXG4gKiBhIGNhbGwgdGhhdCBsb29rcyBhbmQgYmVoYXZlcyBlc3NlbnRpYWxseSB0aGUgc2FtZSBhcyBmb3JcbiAqIGEgcmVhbCBFbGVtZW50LiBNYXkgYmUgdXNlZnVsIGZvciBvdGhlciB0aGluZ3MgbGF0ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmlydHVhbGl6ZXJDaGlsZEVsZW1lbnRQcm94eSB7XG4gIHNjcm9sbEludG9WaWV3OiAob3B0aW9ucz86IFNjcm9sbEludG9WaWV3T3B0aW9ucykgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHNjcm9sbGluZyBhIChwb3NzaWJseSB2aXJ0dWFsKSBlbGVtZW50XG4gKiBpbnRvIHZpZXcsIGdpdmVuIGl0cyBpbmRleFxuICovXG5pbnRlcmZhY2UgU2Nyb2xsRWxlbWVudEludG9WaWV3T3B0aW9ucyBleHRlbmRzIFNjcm9sbEludG9WaWV3T3B0aW9ucyB7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlydHVhbGl6ZXJDb25maWcge1xuICBsYXlvdXQ/OiBMYXlvdXRDb25maWdWYWx1ZTtcblxuICAvKipcbiAgICogVGhlIHBhcmVudCBvZiBhbGwgY2hpbGQgbm9kZXMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBob3N0RWxlbWVudDogVmlydHVhbGl6ZXJIb3N0RWxlbWVudDtcblxuICBzY3JvbGxlcj86IGJvb2xlYW47XG59XG5cbmxldCBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3I6IExheW91dENvbnN0cnVjdG9yO1xuXG4vKipcbiAqIFByb3ZpZGVzIHZpcnR1YWwgc2Nyb2xsaW5nIGJvaWxlcnBsYXRlLlxuICpcbiAqIEV4dGVuc2lvbnMgb2YgdGhpcyBjbGFzcyBtdXN0IHNldCBob3N0RWxlbWVudCBhbmQgbGF5b3V0LlxuICpcbiAqIEV4dGVuc2lvbnMgb2YgdGhpcyBjbGFzcyBtdXN0IGFsc28gb3ZlcnJpZGUgVmlydHVhbFJlcGVhdGVyJ3MgRE9NXG4gKiBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZpcnR1YWxpemVyIHtcbiAgcHJpdmF0ZSBfYmVuY2htYXJrU3RhcnQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX2xheW91dDogTGF5b3V0IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfY2xpcHBpbmdBbmNlc3RvcnM6IEhUTUxFbGVtZW50W10gPSBbXTtcblxuICAvKipcbiAgICogTGF5b3V0IHByb3ZpZGVzIHRoZXNlIHZhbHVlcywgd2Ugc2V0IHRoZW0gb24gX3JlbmRlcigpLlxuICAgKiBUT0RPIEBzdHJhdmVyc2k6IENhbiB3ZSBmaW5kIGFuIFhPUiB0eXBlLCB1c2FibGUgZm9yIHRoZSBrZXkgaGVyZT9cbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbFNpemU6IFNpemUgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIHNjcm9sbCB0YXJnZXQncyBjdXJyZW50IGFuZCByZXF1aXJlZCBzY3JvbGwgb2Zmc2V0cy5cbiAgICogUHJvdmlkZWQgYnkgbGF5b3V0LlxuICAgKi9cbiAgcHJpdmF0ZSBfc2Nyb2xsRXJyb3I6IHtsZWZ0OiBudW1iZXI7IHRvcDogbnVtYmVyfSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdGhlIHBvc2l0aW9ucyAodG9wLCBsZWZ0KSBvZiB0aGUgY2hpbGRyZW4gaW4gdGhlIGN1cnJlbnQgcmFuZ2UuXG4gICAqL1xuICBwcml2YXRlIF9jaGlsZHJlblBvczogQ2hpbGRQb3NpdGlvbnMgfCBudWxsID0gbnVsbDtcblxuICAvLyBUT0RPOiAoZ3JheW5vcnRvbik6IHR5cGVcbiAgcHJpdmF0ZSBfY2hpbGRNZWFzdXJlbWVudHM6IENoaWxkTWVhc3VyZW1lbnRzIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfdG9CZU1lYXN1cmVkOiBNYXA8SFRNTEVsZW1lbnQsIHVua25vd24+ID0gbmV3IE1hcCgpO1xuXG4gIHByaXZhdGUgX3JhbmdlQ2hhbmdlZCA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfaXRlbXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBwcml2YXRlIF92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFRoZSBIVE1MRWxlbWVudCB0aGF0IGhvc3RzIHRoZSB2aXJ0dWFsaXplci4gU2V0IGJ5IGhvc3RFbGVtZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9ob3N0RWxlbWVudD86IFZpcnR1YWxpemVySG9zdEVsZW1lbnQ7XG5cbiAgcHJpdmF0ZSBfc2Nyb2xsZXJDb250cm9sbGVyOiBTY3JvbGxlckNvbnRyb2xsZXIgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9pc1Njcm9sbGVyID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfc2l6ZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBvYnNlcnZlciBhdHRhY2hlZCB0byBob3N0RWxlbWVudC5cbiAgICovXG4gIHByaXZhdGUgX2hvc3RFbGVtZW50Uk86IFJlc2l6ZU9ic2VydmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBvYnNlcnZlciBhdHRhY2hlZCB0byBjaGlsZHJlbi5cbiAgICovXG4gIHByaXZhdGUgX2NoaWxkcmVuUk86IFJlc2l6ZU9ic2VydmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfbXV0YXRpb25PYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX3Njcm9sbEV2ZW50TGlzdGVuZXJzOiAoRWxlbWVudCB8IFdpbmRvdylbXSA9IFtdO1xuICBwcml2YXRlIF9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9uczogQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgcGFzc2l2ZTogdHJ1ZSxcbiAgfTtcblxuICAvLyBUT0RPIChncmF5bm9ydG9uKTogUmV0aGluaywgcGVyIGxvbmdlciBjb21tZW50IGJlbG93XG5cbiAgcHJpdmF0ZSBfbG9hZExpc3RlbmVyID0gdGhpcy5fY2hpbGRMb2FkZWQuYmluZCh0aGlzKTtcblxuICAvKipcbiAgICogSW5kZXggb2YgZWxlbWVudCB0byBzY3JvbGwgaW50byB2aWV3LCBwbHVzIHNjcm9sbFxuICAgKiBiZWhhdmlvciBvcHRpb25zLCBhcyBpbXBlcmF0aXZlbHkgc3BlY2lmaWVkIHZpYVxuICAgKiBgZWxlbWVudChpbmRleCkuc2Nyb2xsSW50b1ZpZXcoKWBcbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbEludG9WaWV3VGFyZ2V0OiBTY3JvbGxFbGVtZW50SW50b1ZpZXdPcHRpb25zIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfdXBkYXRlU2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlczpcbiAgICB8ICgoY29vcmRpbmF0ZXM6IFNjcm9sbFRvQ29vcmRpbmF0ZXMpID0+IHZvaWQpXG4gICAgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogSXRlbXMgdG8gcmVuZGVyLiBTZXQgYnkgaXRlbXMuXG4gICAqL1xuICBwcml2YXRlIF9pdGVtczogQXJyYXk8dW5rbm93bj4gPSBbXTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGNoaWxkIGluIHRoZSByYW5nZSwgbm90IG5lY2Vzc2FyaWx5IHRoZSBmaXJzdCB2aXNpYmxlIGNoaWxkLlxuICAgKiBUT0RPIEBzdHJhdmVyc2k6IENvbnNpZGVyIHJlbmFtaW5nIHRoZXNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9maXJzdCA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgcmFuZ2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xhc3QgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gaW50ZXJzZWN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByaXZhdGUgX2ZpcnN0VmlzaWJsZSA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF9sYXN0VmlzaWJsZSA9IC0xO1xuXG4gIHByb3RlY3RlZCBfc2NoZWR1bGVkID0gbmV3IFdlYWtTZXQoKTtcblxuICAvKipcbiAgICogSW52b2tlZCBhdCB0aGUgZW5kIG9mIGVhY2ggcmVuZGVyIGN5Y2xlOiBjaGlsZHJlbiBpbiB0aGUgcmFuZ2UgYXJlXG4gICAqIG1lYXN1cmVkLCBhbmQgdGhlaXIgZGltZW5zaW9ucyBwYXNzZWQgdG8gdGhpcyBjYWxsYmFjay4gVXNlIGl0IHRvIGxheW91dFxuICAgKiBjaGlsZHJlbiBhcyBuZWVkZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX21lYXN1cmVDYWxsYmFjazogKChzaXplczogQ2hpbGRNZWFzdXJlbWVudHMpID0+IHZvaWQpIHwgbnVsbCA9XG4gICAgbnVsbDtcblxuICBwcm90ZWN0ZWQgX21lYXN1cmVDaGlsZE92ZXJyaWRlOiBNZWFzdXJlQ2hpbGRGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTdGF0ZSBmb3IgYGxheW91dENvbXBsZXRlYCBwcm9taXNlXG4gICAqL1xuICBwcml2YXRlIF9sYXlvdXRDb21wbGV0ZVByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfbGF5b3V0Q29tcGxldGVSZXNvbHZlcjogRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfbGF5b3V0Q29tcGxldGVSZWplY3RlcjogRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfcGVuZGluZ0xheW91dENvbXBsZXRlOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFZpcnR1YWxpemVyQ29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1ZpcnR1YWxpemVyIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGEgY29uZmlndXJhdGlvbiBvYmplY3QnXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhvc3RFbGVtZW50KSB7XG4gICAgICB0aGlzLl9pbml0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1ZpcnR1YWxpemVyIGNvbmZpZ3VyYXRpb24gcmVxdWlyZXMgdGhlIFwiaG9zdEVsZW1lbnRcIiBwcm9wZXJ0eSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2V0IGl0ZW1zKGl0ZW1zOiBBcnJheTx1bmtub3duPiB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSAmJiBpdGVtcyAhPT0gdGhpcy5faXRlbXMpIHtcbiAgICAgIHRoaXMuX2l0ZW1zQ2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICBfaW5pdChjb25maWc6IFZpcnR1YWxpemVyQ29uZmlnKSB7XG4gICAgdGhpcy5faXNTY3JvbGxlciA9ICEhY29uZmlnLnNjcm9sbGVyO1xuICAgIHRoaXMuX2luaXRIb3N0RWxlbWVudChjb25maWcpO1xuICAgIC8vIElmIG5vIGxheW91dCBpcyBzcGVjaWZpZWQsIHdlIG1ha2UgYW4gZW1wdHlcbiAgICAvLyBsYXlvdXQgY29uZmlnLCB3aGljaCB3aWxsIHJlc3VsdCBpbiB0aGUgZGVmYXVsdFxuICAgIC8vIGxheW91dCB3aXRoIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgIHRoaXMuX2luaXRMYXlvdXQoY29uZmlnLmxheW91dCB8fCAoe30gYXMgQmFzZUxheW91dENvbmZpZykpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfaW5pdE9ic2VydmVycygpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICB0aGlzLl9maW5pc2hET01VcGRhdGUuYmluZCh0aGlzKVxuICAgICk7XG4gICAgY29uc3QgUmVzaXplT2JzZXJ2ZXIgPSBhd2FpdCBnZXRSZXNpemVPYnNlcnZlcigpO1xuICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT5cbiAgICAgIHRoaXMuX2hvc3RFbGVtZW50U2l6ZUNoYW5nZWQoKVxuICAgICk7XG4gICAgdGhpcy5fY2hpbGRyZW5STyA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLl9jaGlsZHJlblNpemVDaGFuZ2VkLmJpbmQodGhpcykpO1xuICB9XG5cbiAgX2luaXRIb3N0RWxlbWVudChjb25maWc6IFZpcnR1YWxpemVyQ29uZmlnKSB7XG4gICAgY29uc3QgaG9zdEVsZW1lbnQgPSAodGhpcy5faG9zdEVsZW1lbnQgPSBjb25maWcuaG9zdEVsZW1lbnQpO1xuICAgIHRoaXMuX2FwcGx5VmlydHVhbGl6ZXJTdHlsZXMoKTtcbiAgICBob3N0RWxlbWVudFt2aXJ0dWFsaXplclJlZl0gPSB0aGlzO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdGVkKCkge1xuICAgIGF3YWl0IHRoaXMuX2luaXRPYnNlcnZlcnMoKTtcbiAgICBjb25zdCBpbmNsdWRlU2VsZiA9IHRoaXMuX2lzU2Nyb2xsZXI7XG4gICAgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnMgPSBnZXRDbGlwcGluZ0FuY2VzdG9ycyhcbiAgICAgIHRoaXMuX2hvc3RFbGVtZW50ISxcbiAgICAgIGluY2x1ZGVTZWxmXG4gICAgKTtcblxuICAgIHRoaXMuX3Njcm9sbGVyQ29udHJvbGxlciA9IG5ldyBTY3JvbGxlckNvbnRyb2xsZXIoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnNbMF1cbiAgICApO1xuXG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB0aGlzLl9vYnNlcnZlQW5kTGlzdGVuKCk7XG4gIH1cblxuICBfb2JzZXJ2ZUFuZExpc3RlbigpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyIS5vYnNlcnZlKHRoaXMuX2hvc3RFbGVtZW50ISwge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8hLm9ic2VydmUodGhpcy5faG9zdEVsZW1lbnQhKTtcbiAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5wdXNoKHdpbmRvdyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMsIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycy5mb3JFYWNoKChhbmNlc3RvcikgPT4ge1xuICAgICAgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgJ3Njcm9sbCcsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJPcHRpb25zXG4gICAgICApO1xuICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudFJPIS5vYnNlcnZlKGFuY2VzdG9yKTtcbiAgICB9KTtcbiAgICB0aGlzLl9ob3N0RWxlbWVudFJPIS5vYnNlcnZlKHRoaXMuX3Njcm9sbGVyQ29udHJvbGxlciEuZWxlbWVudCk7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2NoaWxkcmVuUk8hLm9ic2VydmUoY2hpbGQpKTtcbiAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5mb3JFYWNoKCh0YXJnZXQpID0+XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5mb3JFYWNoKCh0YXJnZXQpID0+XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgJ3Njcm9sbCcsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJPcHRpb25zXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzID0gW107XG4gICAgdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyID0gdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyPy5kZXRhY2godGhpcykgfHwgbnVsbDtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTz8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuX2NoaWxkcmVuUk8/LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9yZWplY3RMYXlvdXRDb21wbGV0ZVByb21pc2UoJ2Rpc2Nvbm5lY3RlZCcpO1xuICB9XG5cbiAgcHJpdmF0ZSBfYXBwbHlWaXJ0dWFsaXplclN0eWxlcygpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50ITtcbiAgICAvLyBXb3VsZCByYXRoZXIgc2V0IHRoZXNlIENTUyBwcm9wZXJ0aWVzIG9uIHRoZSBob3N0IHVzaW5nIFNoYWRvdyBSb290XG4gICAgLy8gc3R5bGUgc2NvcGluZyAoYW5kIGZhbGxpbmcgYmFjayB0byBhIGdsb2JhbCBzdHlsZXNoZWV0IHdoZXJlIG5hdGl2ZVxuICAgIC8vIFNoYWRvdyBET00gaXMgbm90IGF2YWlsYWJsZSksIGJ1dCB0aGlzIE1vYmlsZSBTYWZhcmkgYnVnIGlzIHByZXZlbnRpbmdcbiAgICAvLyB0aGF0IGZyb20gd29ya2luZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyNjE5NVxuICAgIGNvbnN0IHN0eWxlID0gaG9zdEVsZW1lbnQuc3R5bGUgYXMgQ1NTU3R5bGVEZWNsYXJhdGlvbiAmIHtjb250YWluOiBzdHJpbmd9O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gICAgc3R5bGUucG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbiB8fCAncmVsYXRpdmUnO1xuICAgIHN0eWxlLmNvbnRhaW4gPSBzdHlsZS5jb250YWluIHx8ICdzaXplIGxheW91dCc7XG5cbiAgICBpZiAodGhpcy5faXNTY3JvbGxlcikge1xuICAgICAgc3R5bGUub3ZlcmZsb3cgPSBzdHlsZS5vdmVyZmxvdyB8fCAnYXV0byc7XG4gICAgICBzdHlsZS5taW5IZWlnaHQgPSBzdHlsZS5taW5IZWlnaHQgfHwgJzE1MHB4JztcbiAgICB9XG4gIH1cblxuICBfZ2V0U2l6ZXIoKSB7XG4gICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLl9ob3N0RWxlbWVudCE7XG4gICAgaWYgKCF0aGlzLl9zaXplcikge1xuICAgICAgLy8gVXNlIGEgcHJlLWV4aXN0aW5nIHNpemVyIGVsZW1lbnQgaWYgcHJvdmlkZWQgKGZvciBiZXR0ZXIgaW50ZWdyYXRpb25cbiAgICAgIC8vIHdpdGggdkRPTSByZW5kZXJlcnMpXG4gICAgICBsZXQgc2l6ZXIgPSBob3N0RWxlbWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBgWyR7U0laRVJfQVRUUklCVVRFfV1gXG4gICAgICApIGFzIEhUTUxFbGVtZW50O1xuICAgICAgaWYgKCFzaXplcikge1xuICAgICAgICBzaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzaXplci5zZXRBdHRyaWJ1dGUoU0laRVJfQVRUUklCVVRFLCAnJyk7XG4gICAgICAgIGhvc3RFbGVtZW50LmFwcGVuZENoaWxkKHNpemVyKTtcbiAgICAgIH1cbiAgICAgIC8vIFdoZW4gdGhlIHNjcm9sbEhlaWdodCBpcyBsYXJnZSwgdGhlIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgbWlnaHQgYmVcbiAgICAgIC8vIGlnbm9yZWQuIFNldHRpbmcgY29udGVudCBhbmQgZm9udC1zaXplIGVuc3VyZXMgdGhlIGVsZW1lbnQgaGFzIGEgc2l6ZS5cbiAgICAgIE9iamVjdC5hc3NpZ24oc2l6ZXIuc3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIG1hcmdpbjogJy0ycHggMCAwIDAnLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICAgICAgZm9udFNpemU6ICcycHgnLFxuICAgICAgfSk7XG4gICAgICBzaXplci5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICAgIHNpemVyLnNldEF0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUsICcnKTtcbiAgICAgIHRoaXMuX3NpemVyID0gc2l6ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaXplcjtcbiAgfVxuXG4gIHVwZGF0ZUxheW91dENvbmZpZyhsYXlvdXRDb25maWc6IExheW91dENvbmZpZ1ZhbHVlKSB7XG4gICAgY29uc3QgQ3RvciA9XG4gICAgICAoKGxheW91dENvbmZpZyBhcyBMYXlvdXRTcGVjaWZpZXIpLnR5cGUgYXMgTGF5b3V0Q29uc3RydWN0b3IpIHx8XG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3I7XG4gICAgaWYgKHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIHRoaXMuX2xheW91dCBpbnN0YW5jZW9mIEN0b3IpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb25maWcudHlwZTtcbiAgICAgIHRoaXMuX2xheW91dC5jb25maWcgPSBjb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9pbml0TGF5b3V0KGxheW91dENvbmZpZzogTGF5b3V0Q29uZmlnVmFsdWUpIHtcbiAgICBsZXQgY29uZmlnOiBCYXNlTGF5b3V0Q29uZmlnIHwgdW5kZWZpbmVkO1xuICAgIGxldCBDdG9yOiBMYXlvdXRDb25zdHJ1Y3RvciB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgZnVsbCBMYXlvdXRTcGVjaWZpZXIsIHRoZSBgdHlwZWAgcHJvcGVydHlcbiAgICAgIC8vIGdpdmVzIHVzIG91ciBjb25zdHJ1Y3Rvci4uLlxuICAgICAgQ3RvciA9IChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlIGFzIExheW91dENvbnN0cnVjdG9yO1xuICAgICAgLy8gLi4ud2hpbGUgdGhlIHJlc3Qgb2YgdGhlIHNwZWNpZmllciBpcyBvdXIgbGF5b3V0IGNvbmZpZ1xuICAgICAgY29uc3QgY29weSA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb3B5LnR5cGU7XG4gICAgICBjb25maWcgPSBjb3B5IGFzIEJhc2VMYXlvdXRDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBmdWxsIExheW91dFNwZWNpZmllciwgd2UganVzdFxuICAgICAgLy8gaGF2ZSBhIGNvbmZpZyBmb3IgdGhlIGRlZmF1bHQgbGF5b3V0XG4gICAgICBjb25maWcgPSBsYXlvdXRDb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY29uc3RydWN0b3IgeWV0LCBsb2FkIHRoZSBkZWZhdWx0XG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3IgPSBDdG9yID0gKGF3YWl0IGltcG9ydCgnLi9sYXlvdXRzL2Zsb3cuanMnKSlcbiAgICAgICAgLkZsb3dMYXlvdXQgYXMgdW5rbm93biBhcyBMYXlvdXRDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXlvdXQgPSBuZXcgQ3Rvcihjb25maWcpO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fbGF5b3V0Lm1lYXN1cmVDaGlsZHJlbiAmJlxuICAgICAgdHlwZW9mIHRoaXMuX2xheW91dC51cGRhdGVJdGVtU2l6ZXMgPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fbGF5b3V0Lm1lYXN1cmVDaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9tZWFzdXJlQ2hpbGRPdmVycmlkZSA9IHRoaXMuX2xheW91dC5tZWFzdXJlQ2hpbGRyZW47XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWFzdXJlQ2FsbGJhY2sgPSB0aGlzLl9sYXlvdXQudXBkYXRlSXRlbVNpemVzLmJpbmQodGhpcy5fbGF5b3V0KTtcbiAgICB9XG4gICAgdGhpcy5fbGF5b3V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbHNpemVjaGFuZ2UnLCB0aGlzKTtcbiAgICB0aGlzLl9sYXlvdXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsZXJyb3JjaGFuZ2UnLCB0aGlzKTtcbiAgICB0aGlzLl9sYXlvdXQuYWRkRXZlbnRMaXN0ZW5lcignaXRlbXBvc2l0aW9uY2hhbmdlJywgdGhpcyk7XG4gICAgdGhpcy5fbGF5b3V0LmFkZEV2ZW50TGlzdGVuZXIoJ3JhbmdlY2hhbmdlJywgdGhpcyk7XG4gICAgdGhpcy5fbGF5b3V0LmFkZEV2ZW50TGlzdGVuZXIoJ3VucGlubmVkJywgdGhpcyk7XG4gICAgaWYgKHRoaXMuX2xheW91dC5saXN0ZW5Gb3JDaGlsZExvYWRFdmVudHMpIHtcbiAgICAgIHRoaXMuX2hvc3RFbGVtZW50IS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fbG9hZExpc3RlbmVyLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgfVxuXG4gIC8vIFRPRE8gKGdyYXlub3J0b24pOiBSZXdvcmsgYmVuY2htYXJraW5nIHNvIHRoYXQgaXQgaGFzIG5vIEFQSSBhbmRcbiAgLy8gaW5zdGVhZCBpcyBhbHdheXMgb24gZXhjZXB0IGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIHN0YXJ0QmVuY2htYXJraW5nKCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcEJlbmNobWFya2luZygpIHtcbiAgICBpZiAodGhpcy5fYmVuY2htYXJrU3RhcnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gbm93IC0gdGhpcy5fYmVuY2htYXJrU3RhcnQ7XG4gICAgICBjb25zdCBlbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcbiAgICAgICAgJ3V2LXZpcnR1YWxpemluZycsXG4gICAgICAgICdtZWFzdXJlJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHZpcnR1YWxpemF0aW9uVGltZSA9IGVudHJpZXNcbiAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAoZSkgPT4gZS5zdGFydFRpbWUgPj0gdGhpcy5fYmVuY2htYXJrU3RhcnQhICYmIGUuc3RhcnRUaW1lIDwgbm93XG4gICAgICAgIClcbiAgICAgICAgLnJlZHVjZSgodCwgbSkgPT4gdCArIG0uZHVyYXRpb24sIDApO1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSBudWxsO1xuICAgICAgcmV0dXJuIHt0aW1lRWxhcHNlZCwgdmlydHVhbGl6YXRpb25UaW1lfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9tZWFzdXJlQ2hpbGRyZW4oKTogdm9pZCB7XG4gICAgY29uc3QgbW06IENoaWxkTWVhc3VyZW1lbnRzID0ge307XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBjb25zdCBmbiA9IHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlIHx8IHRoaXMuX21lYXN1cmVDaGlsZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZmlyc3QgKyBpO1xuICAgICAgaWYgKHRoaXMuX2l0ZW1zQ2hhbmdlZCB8fCB0aGlzLl90b0JlTWVhc3VyZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICBtbVtpZHhdID0gZm4uY2FsbCh0aGlzLCBjaGlsZCwgdGhpcy5faXRlbXNbaWR4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkTWVhc3VyZW1lbnRzID0gbW07XG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB0aGlzLl90b0JlTWVhc3VyZWQuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgbWFyZ2lucyBvZiB0aGUgZ2l2ZW4gY2hpbGQuXG4gICAqL1xuICBfbWVhc3VyZUNoaWxkKGVsZW1lbnQ6IEVsZW1lbnQpOiBJdGVtQm94IHtcbiAgICAvLyBvZmZzZXRXaWR0aCBkb2Vzbid0IHRha2UgdHJhbnNmb3JtcyBpbiBjb25zaWRlcmF0aW9uLCBzbyB3ZSB1c2VcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgd2hpY2ggZG9lcy5cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0fSwgZ2V0TWFyZ2lucyhlbGVtZW50KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3NjaGVkdWxlKG1ldGhvZDogRnVuY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZC5oYXMobWV0aG9kKSkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkLmFkZChtZXRob2QpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQuZGVsZXRlKG1ldGhvZCk7XG4gICAgICBtZXRob2QuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfdXBkYXRlRE9NKCkge1xuICAgIGNvbnN0IHtfcmFuZ2VDaGFuZ2VkLCBfaXRlbXNDaGFuZ2VkfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlWaXNpYmlsaXR5KCk7XG4gICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3JhbmdlQ2hhbmdlZCB8fCBfaXRlbXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlSYW5nZSgpO1xuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpbmlzaERPTVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9maW5pc2hET01VcGRhdGUoKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2NoaWxkcmVuUk8hLm9ic2VydmUoY2hpbGQpKTtcbiAgICB0aGlzLl9jaGVja1Njcm9sbEludG9WaWV3VGFyZ2V0KHRoaXMuX2NoaWxkcmVuUG9zKTtcbiAgICB0aGlzLl9wb3NpdGlvbkNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuUG9zKTtcbiAgICB0aGlzLl9zaXplSG9zdEVsZW1lbnQodGhpcy5fc2Nyb2xsU2l6ZSk7XG4gICAgdGhpcy5fY29ycmVjdFNjcm9sbEVycm9yKCk7XG4gICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1lbmQnKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGF5b3V0KCkge1xuICAgIGlmICh0aGlzLl9sYXlvdXQpIHtcbiAgICAgIHRoaXMuX2xheW91dCEuaXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQsIHdlIG1heSBoYXZlIG1lYXN1cmVtZW50cyBidXQgbm8gY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMuX21lYXN1cmVDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hpbGRNZWFzdXJlbWVudHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5b3V0IS5yZWZsb3dJZk5lZWRlZCgpO1xuICAgICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1hcmsoJ3V2LWVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVNjcm9sbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCAmJiAnbWFyaycgaW4gd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWVhc3VyZSgndXYtdmlydHVhbGl6aW5nJywgJ3V2LXN0YXJ0JywgJ3V2LWVuZCcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIG1lYXN1cmluZyBwZXJmb3JtYW5jZSBkYXRhOiAnLCBlKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5jb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdXNlci1pbml0aWF0ZWQgc2Nyb2xsLCBzbyB3ZSB1bnBpbiB0aGUgbGF5b3V0XG4gICAgICB0aGlzLl9sYXlvdXQ/LnVucGluKCk7XG4gICAgfVxuICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudDogQ3VzdG9tRXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID09PSB3aW5kb3cgfHxcbiAgICAgICAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycy5pbmNsdWRlcyhldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVTY3JvbGxFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2Nyb2xsc2l6ZWNoYW5nZSc6XG4gICAgICAgIHRoaXMuX3Njcm9sbFNpemUgPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZURPTSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2Nyb2xsZXJyb3JjaGFuZ2UnOlxuICAgICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlRE9NKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpdGVtcG9zaXRpb25jaGFuZ2UnOlxuICAgICAgICB0aGlzLl9jaGlsZHJlblBvcyA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlRE9NKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyYW5nZWNoYW5nZSc6XG4gICAgICAgIHRoaXMuX2FkanVzdFJhbmdlKGV2ZW50LmRldGFpbCk7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZURPTSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndW5waW5uZWQnOlxuICAgICAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChuZXcgVW5waW5uZWRFdmVudCgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oJ2V2ZW50IG5vdCBoYW5kbGVkJywgZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfY2hpbGRyZW4oKTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuX2hvc3RFbGVtZW50IS5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKCFuZXh0Lmhhc0F0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUpKSB7XG4gICAgICAgIGFyci5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nIGFzIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlVmlldygpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50O1xuICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXI/LmVsZW1lbnQ7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuXG4gICAgaWYgKGhvc3RFbGVtZW50ICYmIHNjcm9sbGluZ0VsZW1lbnQgJiYgbGF5b3V0KSB7XG4gICAgICBsZXQgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0O1xuXG4gICAgICBjb25zdCBob3N0RWxlbWVudEJvdW5kcyA9IGhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB0b3AgPSAwO1xuICAgICAgbGVmdCA9IDA7XG4gICAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgICBjb25zdCBhbmNlc3RvckJvdW5kcyA9IHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzLm1hcCgoYW5jZXN0b3IpID0+XG4gICAgICAgIGFuY2VzdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICApO1xuICAgICAgYW5jZXN0b3JCb3VuZHMudW5zaGlmdChob3N0RWxlbWVudEJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgYm91bmRzIG9mIGFuY2VzdG9yQm91bmRzKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgYm91bmRzLnRvcCk7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBib3VuZHMubGVmdCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgYm91bmRzLmJvdHRvbSk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIGJvdW5kcy5yaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMgPSBzY3JvbGxpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBjb25zdCBvZmZzZXRXaXRoaW5TY3JvbGxlciA9IHtcbiAgICAgICAgbGVmdDogaG9zdEVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBob3N0RWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxpbmdFbGVtZW50Qm91bmRzLnRvcCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRvdGFsU2Nyb2xsU2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgICAgIGhlaWdodDogc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB0b3AgLSBob3N0RWxlbWVudEJvdW5kcy50b3AgKyBob3N0RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gbGVmdCAtIGhvc3RFbGVtZW50Qm91bmRzLmxlZnQgKyBob3N0RWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCgxLCBib3R0b20gLSB0b3ApO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCByaWdodCAtIGxlZnQpO1xuXG4gICAgICBsYXlvdXQudmlld3BvcnRTaXplID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgICAgbGF5b3V0LnZpZXdwb3J0U2Nyb2xsID0ge3RvcDogc2Nyb2xsVG9wLCBsZWZ0OiBzY3JvbGxMZWZ0fTtcbiAgICAgIGxheW91dC50b3RhbFNjcm9sbFNpemUgPSB0b3RhbFNjcm9sbFNpemU7XG4gICAgICBsYXlvdXQub2Zmc2V0V2l0aGluU2Nyb2xsZXIgPSBvZmZzZXRXaXRoaW5TY3JvbGxlcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBob3N0IGVsZW1lbnQgc28gdGhhdCBpdHMgc2l6ZSByZWZsZWN0cyB0aGVcbiAgICogdG90YWwgc2l6ZSBvZiBhbGwgaXRlbXMuXG4gICAqL1xuICBwcml2YXRlIF9zaXplSG9zdEVsZW1lbnQoc2l6ZT86IFNpemUgfCBudWxsKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZWVtIHRvIGNyYXAgb3V0IGlmIHRoZSBob3N0IGVsZW1lbnQgZ2V0cyBsYXJnZXIgdGhhblxuICAgIC8vIGEgY2VydGFpbiBzaXplLCBzbyB3ZSBjbGFtcCBpdCBoZXJlICh0aGlzIHZhbHVlIGJhc2VkIG9uIGFkIGhvY1xuICAgIC8vIHRlc3RpbmcgaW4gQ2hyb21lIC8gU2FmYXJpIC8gRmlyZWZveCBNYWMpXG4gICAgY29uc3QgbWF4ID0gODIwMDAwMDtcbiAgICBjb25zdCBoID0gc2l6ZSAmJiBzaXplLndpZHRoICE9PSBudWxsID8gTWF0aC5taW4obWF4LCBzaXplLndpZHRoKSA6IDA7XG4gICAgY29uc3QgdiA9IHNpemUgJiYgc2l6ZS5oZWlnaHQgIT09IG51bGwgPyBNYXRoLm1pbihtYXgsIHNpemUuaGVpZ2h0KSA6IDA7XG5cbiAgICBpZiAodGhpcy5faXNTY3JvbGxlcikge1xuICAgICAgdGhpcy5fZ2V0U2l6ZXIoKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7aH1weCwgJHt2fXB4KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5faG9zdEVsZW1lbnQhLnN0eWxlO1xuICAgICAgKHN0eWxlLm1pbldpZHRoIGFzIHN0cmluZyB8IG51bGwpID0gaCA/IGAke2h9cHhgIDogJzEwMCUnO1xuICAgICAgKHN0eWxlLm1pbkhlaWdodCBhcyBzdHJpbmcgfCBudWxsKSA9IHYgPyBgJHt2fXB4YCA6ICcxMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdG9wIGFuZCBsZWZ0IHRyYW5zZm9ybSBzdHlsZSBvZiB0aGUgY2hpbGRyZW4gZnJvbSB0aGUgdmFsdWVzIGluXG4gICAqIHBvcy5cbiAgICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uQ2hpbGRyZW4ocG9zOiBDaGlsZFBvc2l0aW9ucyB8IG51bGwpIHtcbiAgICBpZiAocG9zKSB7XG4gICAgICBwb3MuZm9yRWFjaCgoe3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCwgeE9mZnNldCwgeU9mZnNldH0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baW5kZXggLSB0aGlzLl9maXJzdF07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICBjaGlsZC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgICAgICAgY2hpbGQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2xlZnR9cHgsICR7dG9wfXB4KWA7XG4gICAgICAgICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIChjaGlsZC5zdHlsZS5sZWZ0IGFzIHN0cmluZyB8IG51bGwpID1cbiAgICAgICAgICAgIHhPZmZzZXQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB4T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAoY2hpbGQuc3R5bGUudG9wIGFzIHN0cmluZyB8IG51bGwpID1cbiAgICAgICAgICAgIHlPZmZzZXQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB5T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYWRqdXN0UmFuZ2UocmFuZ2U6IEludGVybmFsUmFuZ2UpIHtcbiAgICBjb25zdCB7X2ZpcnN0LCBfbGFzdCwgX2ZpcnN0VmlzaWJsZSwgX2xhc3RWaXNpYmxlfSA9IHRoaXM7XG4gICAgdGhpcy5fZmlyc3QgPSByYW5nZS5maXJzdDtcbiAgICB0aGlzLl9sYXN0ID0gcmFuZ2UubGFzdDtcbiAgICB0aGlzLl9maXJzdFZpc2libGUgPSByYW5nZS5maXJzdFZpc2libGU7XG4gICAgdGhpcy5fbGFzdFZpc2libGUgPSByYW5nZS5sYXN0VmlzaWJsZTtcbiAgICB0aGlzLl9yYW5nZUNoYW5nZWQgPVxuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkIHx8IHRoaXMuX2ZpcnN0ICE9PSBfZmlyc3QgfHwgdGhpcy5fbGFzdCAhPT0gX2xhc3Q7XG4gICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPVxuICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgfHxcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSAhPT0gX2ZpcnN0VmlzaWJsZSB8fFxuICAgICAgdGhpcy5fbGFzdFZpc2libGUgIT09IF9sYXN0VmlzaWJsZTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvcnJlY3RTY3JvbGxFcnJvcigpIHtcbiAgICBpZiAodGhpcy5fc2Nyb2xsRXJyb3IpIHtcbiAgICAgIGNvbnN0IHtzY3JvbGxUb3AsIHNjcm9sbExlZnR9ID0gdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyITtcbiAgICAgIGNvbnN0IHt0b3AsIGxlZnR9ID0gdGhpcy5fc2Nyb2xsRXJyb3I7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLmNvcnJlY3RTY3JvbGxFcnJvcih7XG4gICAgICAgIHRvcDogc2Nyb2xsVG9wIC0gdG9wLFxuICAgICAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gbGVmdCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBlbGVtZW50KGluZGV4OiBudW1iZXIpOiBWaXJ0dWFsaXplckNoaWxkRWxlbWVudFByb3h5IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICBpbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pdGVtcz8uW2luZGV4XSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB7XG4gICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IChvcHRpb25zOiBTY3JvbGxJbnRvVmlld09wdGlvbnMgPSB7fSkgPT5cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnRJbnRvVmlldyh7Li4ub3B0aW9ucywgaW5kZXh9KSxcbiAgICAgICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbEVsZW1lbnRJbnRvVmlldyhvcHRpb25zOiBTY3JvbGxFbGVtZW50SW50b1ZpZXdPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5kZXggPj0gdGhpcy5fZmlyc3QgJiYgb3B0aW9ucy5pbmRleCA8PSB0aGlzLl9sYXN0KSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbltvcHRpb25zLmluZGV4IC0gdGhpcy5fZmlyc3RdLnNjcm9sbEludG9WaWV3KG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmluZGV4ID0gTWF0aC5taW4ob3B0aW9ucy5pbmRleCwgdGhpcy5faXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAob3B0aW9ucy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLl9sYXlvdXQhLmdldFNjcm9sbEludG9WaWV3Q29vcmRpbmF0ZXMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHtiZWhhdmlvcn0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzID1cbiAgICAgICAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLm1hbmFnZWRTY3JvbGxUbyhcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29vcmRpbmF0ZXMsIHtiZWhhdmlvcn0pLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5fbGF5b3V0IS5nZXRTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzKG9wdGlvbnMpLFxuICAgICAgICAgICAgKCkgPT4gKHRoaXMuX3Njcm9sbEludG9WaWV3VGFyZ2V0ID0gbnVsbClcbiAgICAgICAgICApO1xuICAgICAgICB0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCA9IG9wdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sYXlvdXQhLnBpbiA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGFyZSBzbW9vdGhseSBzY3JvbGxpbmcgdG8gYW4gZWxlbWVudCBhbmQgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIGlzIGluIHRoZSBET00sIHdlIHVwZGF0ZSBvdXIgdGFyZ2V0IGNvb3JkaW5hdGVzIGFzIG5lZWRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfY2hlY2tTY3JvbGxJbnRvVmlld1RhcmdldChwb3M6IENoaWxkUG9zaXRpb25zIHwgbnVsbCkge1xuICAgIGNvbnN0IHtpbmRleH0gPSB0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCB8fCB7fTtcbiAgICBpZiAoaW5kZXggJiYgcG9zPy5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLl91cGRhdGVTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzIShcbiAgICAgICAgdGhpcy5fbGF5b3V0IS5nZXRTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzKHRoaXMuX3Njcm9sbEludG9WaWV3VGFyZ2V0ISlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgcmFuZ2VjaGFuZ2UgZXZlbnQgd2l0aCB0aGUgY3VycmVudCBmaXJzdCwgbGFzdCwgZmlyc3RWaXNpYmxlLCBhbmRcbiAgICogbGFzdFZpc2libGUuXG4gICAqL1xuICBwcml2YXRlIF9ub3RpZnlSYW5nZSgpIHtcbiAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBSYW5nZUNoYW5nZWRFdmVudCh7Zmlyc3Q6IHRoaXMuX2ZpcnN0LCBsYXN0OiB0aGlzLl9sYXN0fSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfbm90aWZ5VmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50KHtcbiAgICAgICAgZmlyc3Q6IHRoaXMuX2ZpcnN0VmlzaWJsZSxcbiAgICAgICAgbGFzdDogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGxheW91dENvbXBsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIExhemlseSBjcmVhdGUgcHJvbWlzZVxuICAgIGlmICghdGhpcy5fbGF5b3V0Q29tcGxldGVQcm9taXNlKSB7XG4gICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlamVjdGVyID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UhO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVqZWN0TGF5b3V0Q29tcGxldGVQcm9taXNlKHJlYXNvbjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIhKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0TGF5b3V0Q29tcGxldGVTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2NoZWR1bGVMYXlvdXRDb21wbGV0ZSgpIHtcbiAgICAvLyBEb24ndCBkbyBhbnl0aGluZyB1bmxlc3Mgd2UgaGF2ZSBhIHBlbmRpbmcgcHJvbWlzZVxuICAgIC8vIEFuZCBvbmx5IHJlcXVlc3QgYSBmcmFtZSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSBzb1xuICAgIGlmICh0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UgJiYgdGhpcy5fcGVuZGluZ0xheW91dENvbXBsZXRlID09PSBudWxsKSB7XG4gICAgICAvLyBXYWl0IG9uZSBhZGRpdGlvbmFsIGZyYW1lIHRvIGJlIHN1cmUgdGhlIGxheW91dCBpcyBzdGFibGVcbiAgICAgIHRoaXMuX3BlbmRpbmdMYXlvdXRDb21wbGV0ZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5fcmVzb2x2ZUxheW91dENvbXBsZXRlUHJvbWlzZSgpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9yZXNvbHZlTGF5b3V0Q29tcGxldGVQcm9taXNlKCkge1xuICAgIGlmICh0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0TGF5b3V0Q29tcGxldGVTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVzZXRMYXlvdXRDb21wbGV0ZVN0YXRlKCkge1xuICAgIHRoaXMuX2xheW91dENvbXBsZXRlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0Q29tcGxldGVSZXNvbHZlciA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0Q29tcGxldGVSZWplY3RlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0xheW91dENvbXBsZXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYW5kIHVwZGF0ZSB0aGUgdmlldyBhdCB0aGUgbmV4dCBvcHBvcnR1bml0eSB3aXRoIHRoZSBnaXZlblxuICAgKiBob3N0RWxlbWVudCBzaXplLlxuICAgKi9cbiAgcHJpdmF0ZSBfaG9zdEVsZW1lbnRTaXplQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICB9XG5cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFJldGhpbmsgaG93IHRoaXMgd29ya3MuIFByb2JhYmx5IGNoaWxkIGxvYWRpbmcgaXMgdG9vIHNwZWNpZmljXG4gIC8vIHRvIGhhdmUgZGVkaWNhdGVkIHN1cHBvcnQgZm9yOyBtaWdodCB3YW50IHNvbWUgbW9yZSBnZW5lcmljIGxpZmVjeWNsZSBob29rcyBmb3JcbiAgLy8gbGF5b3V0cyB0byB1c2UuIFBvc3NpYmx5IGhhbmRsZSBtZWFzdXJlbWVudCB0aGlzIHdheSwgdG9vLCBvciBtYXliZSB0aGF0IHJlbWFpbnNcbiAgLy8gYSBmaXJzdC1jbGFzcyBmZWF0dXJlP1xuXG4gIHByaXZhdGUgX2NoaWxkTG9hZGVkKCkge31cblxuICAvLyBUaGlzIGlzIHRoZSBjYWxsYmFjayBmb3IgdGhlIFJlc2l6ZU9ic2VydmVyIHRoYXQgd2F0Y2hlcyB0aGVcbiAgLy8gdmlydHVhbGl6ZXIncyBjaGlsZHJlbi4gV2UgbGFuZCBoZXJlIGF0IHRoZSBlbmQgb2YgZXZlcnkgdmlydHVhbGl6ZXJcbiAgLy8gdXBkYXRlIGN5Y2xlIHRoYXQgcmVzdWx0cyBpbiBjaGFuZ2VzIHRvIHBoeXNpY2FsIGl0ZW1zLCBhbmQgd2UgYWxzb1xuICAvLyBlbmQgdXAgaGVyZSBpZiBvbmUgb3IgbW9yZSBjaGlsZHJlbiBjaGFuZ2Ugc2l6ZSBpbmRlcGVuZGVudGx5IG9mXG4gIC8vIHRoZSB2aXJ0dWFsaXplciB1cGRhdGUgY3ljbGUuXG4gIHByaXZhdGUgX2NoaWxkcmVuU2l6ZUNoYW5nZWQoY2hhbmdlczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gICAgLy8gT25seSBtZWFzdXJlIGlmIHRoZSBsYXlvdXQgcmVxdWlyZXMgaXRcbiAgICBpZiAodGhpcy5fbGF5b3V0IS5tZWFzdXJlQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5fdG9CZU1lYXN1cmVkLnNldChcbiAgICAgICAgICBjaGFuZ2UudGFyZ2V0IGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgIGNoYW5nZS5jb250ZW50UmVjdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUNoaWxkcmVuKCk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGVuZCBvZiBhbiB1cGRhdGUgY3ljbGUsIHdlIG5lZWQgdG8gcmVzZXQgc29tZVxuICAgIC8vIGludGVybmFsIHN0YXRlLiBUaGlzIHNob3VsZCBiZSBhIGhhcm1sZXNzIG5vLW9wIGlmIHdlJ3JlIGhhbmRsaW5nXG4gICAgLy8gYW4gb3V0LW9mLWN5Y2xlIFJlc2l6ZU9ic2VydmVyIGNhbGxiYWNrLCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvIGNhc2VzLlxuICAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0Q29tcGxldGUoKTtcbiAgICB0aGlzLl9pdGVtc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGVsOiBFbGVtZW50KTogTWFyZ2lucyB7XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICByZXR1cm4ge1xuICAgIG1hcmdpblRvcDogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luVG9wKSxcbiAgICBtYXJnaW5SaWdodDogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luUmlnaHQpLFxuICAgIG1hcmdpbkJvdHRvbTogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luQm90dG9tKSxcbiAgICBtYXJnaW5MZWZ0OiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5MZWZ0KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFyZ2luVmFsdWUodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGZsb2F0ID0gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IE5hTjtcbiAgcmV0dXJuIE51bWJlci5pc05hTihmbG9hdCkgPyAwIDogZmxvYXQ7XG59XG5cbi8vIFRPRE8gKGdyYXlub3J0b24pOiBEZWFsIHdpdGggaWZyYW1lcz9cbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQoZWw6IEVsZW1lbnQpIHtcbiAgaWYgKGVsLmFzc2lnbmVkU2xvdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBlbC5hc3NpZ25lZFNsb3Q7XG4gIH1cbiAgaWYgKGVsLnBhcmVudEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICBjb25zdCBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIChwYXJlbnROb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8vXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRBbmNlc3RvcnMoZWw6IEhUTUxFbGVtZW50LCBpbmNsdWRlU2VsZiA9IGZhbHNlKSB7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICBsZXQgcGFyZW50ID0gaW5jbHVkZVNlbGYgPyBlbCA6IChnZXRQYXJlbnRFbGVtZW50KGVsKSBhcyBIVE1MRWxlbWVudCk7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgIHBhcmVudCA9IGdldFBhcmVudEVsZW1lbnQocGFyZW50KSBhcyBIVE1MRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0FuY2VzdG9ycyhlbDogSFRNTEVsZW1lbnQsIGluY2x1ZGVTZWxmID0gZmFsc2UpIHtcbiAgcmV0dXJuIGdldEVsZW1lbnRBbmNlc3RvcnMoZWwsIGluY2x1ZGVTZWxmKS5maWx0ZXIoXG4gICAgKGEpID0+IGdldENvbXB1dGVkU3R5bGUoYSkub3ZlcmZsb3cgIT09ICd2aXNpYmxlJ1xuICApO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/Virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/events.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/events.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RangeChangedEvent\": () => (/* binding */ RangeChangedEvent),\n/* harmony export */   \"UnpinnedEvent\": () => (/* binding */ UnpinnedEvent),\n/* harmony export */   \"VisibilityChangedEvent\": () => (/* binding */ VisibilityChangedEvent)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass RangeChangedEvent extends Event {\n  constructor(range) {\n    super(RangeChangedEvent.eventName, {\n      bubbles: true\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\nRangeChangedEvent.eventName = 'rangeChanged';\nclass VisibilityChangedEvent extends Event {\n  constructor(range) {\n    super(VisibilityChangedEvent.eventName, {\n      bubbles: true\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\nVisibilityChangedEvent.eventName = 'visibilityChanged';\nclass UnpinnedEvent extends Event {\n  constructor() {\n    super(UnpinnedEvent.eventName, {\n      bubbles: false\n    });\n  }\n}\nUnpinnedEvent.eventName = 'unpinned';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2V2ZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7QUFNQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVlBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFKQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvc3JjL2V2ZW50cy50cz9jM2U4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnQgY2xhc3MgUmFuZ2VDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAncmFuZ2VDaGFuZ2VkJztcblxuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocmFuZ2U6IFJhbmdlKSB7XG4gICAgc3VwZXIoUmFuZ2VDaGFuZ2VkRXZlbnQuZXZlbnROYW1lLCB7YnViYmxlczogdHJ1ZX0pO1xuICAgIHRoaXMuZmlyc3QgPSByYW5nZS5maXJzdDtcbiAgICB0aGlzLmxhc3QgPSByYW5nZS5sYXN0O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBzdGF0aWMgZXZlbnROYW1lID0gJ3Zpc2liaWxpdHlDaGFuZ2VkJztcblxuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocmFuZ2U6IFJhbmdlKSB7XG4gICAgc3VwZXIoVmlzaWJpbGl0eUNoYW5nZWRFdmVudC5ldmVudE5hbWUsIHtidWJibGVzOiB0cnVlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVucGlubmVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAndW5waW5uZWQnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFVucGlubmVkRXZlbnQuZXZlbnROYW1lLCB7YnViYmxlczogZmFsc2V9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmFuZ2Uge1xuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/events.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/lit-virtualizer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/lit-virtualizer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LitVirtualizer\": () => (/* reexport safe */ _LitVirtualizer_js__WEBPACK_IMPORTED_MODULE_0__.LitVirtualizer),\n/* harmony export */   \"RangeChangedEvent\": () => (/* reexport safe */ _events_js__WEBPACK_IMPORTED_MODULE_1__.RangeChangedEvent),\n/* harmony export */   \"VisibilityChangedEvent\": () => (/* reexport safe */ _events_js__WEBPACK_IMPORTED_MODULE_1__.VisibilityChangedEvent)\n/* harmony export */ });\n/* harmony import */ var _LitVirtualizer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LitVirtualizer.js */ \"./node_modules/@lit-labs/virtualizer/LitVirtualizer.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@lit-labs/virtualizer/events.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n/**\n * Import this module to declare the lit-virtualizer custom element.\n */\ncustomElements.define('lit-virtualizer', _LitVirtualizer_js__WEBPACK_IMPORTED_MODULE_0__.LitVirtualizer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xpdC12aXJ0dWFsaXplci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvc3JjL2xpdC12aXJ0dWFsaXplci50cz9iMjYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQge0xpdFZpcnR1YWxpemVyfSBmcm9tICcuL0xpdFZpcnR1YWxpemVyLmpzJztcbmV4cG9ydCB7TGl0VmlydHVhbGl6ZXJ9O1xuZXhwb3J0IHtSYW5nZUNoYW5nZWRFdmVudCwgVmlzaWJpbGl0eUNoYW5nZWRFdmVudH0gZnJvbSAnLi9ldmVudHMuanMnO1xuXG4vKipcbiAqIEltcG9ydCB0aGlzIG1vZHVsZSB0byBkZWNsYXJlIHRoZSBsaXQtdmlydHVhbGl6ZXIgY3VzdG9tIGVsZW1lbnQuXG4gKi9cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGl0LXZpcnR1YWxpemVyJywgTGl0VmlydHVhbGl6ZXIpO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBIVE1MRWxlbWVudFRhZ05hbWVNYXAge1xuICAgICdsaXQtdmlydHVhbGl6ZXInOiBMaXRWaXJ0dWFsaXplcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/lit-virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ResizeObserver)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _RO;\nlet RO;\nasync function ResizeObserver() {\n  return RO || init();\n}\nasync function init() {\n  if (_RO) {\n    return (await _RO).default;\n  } else {\n    _RO = window.ResizeObserver;\n    try {\n      new _RO(function () {});\n    } catch (e) {\n      _RO = __webpack_require__.e(/*! import() */ \"vendors-node_modules_lit-labs_virtualizer_polyfills_resize-observer-polyfill_ResizeObserver_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../polyfills/resize-observer-polyfill/ResizeObserver.js */ \"./node_modules/@lit-labs/virtualizer/polyfills/resize-observer-polyfill/ResizeObserver.js\"));\n      _RO = (await _RO).default;\n    }\n    return RO = _RO;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3BvbHlmaWxsTG9hZGVycy9SZXNpemVPYnNlcnZlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvcG9seWZpbGxMb2FkZXJzL1Jlc2l6ZU9ic2VydmVyLnRzPzQzZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7UmVzaXplT2JzZXJ2ZXJDb25zdHJ1Y3Rvcn0gZnJvbSAnLi4vcG9seWZpbGxzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9SZXNpemVPYnNlcnZlci5qcyc7XG50eXBlIFJlc2l6ZU9ic2VydmVyTW9kdWxlID1cbiAgdHlwZW9mIGltcG9ydCgnLi4vcG9seWZpbGxzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9SZXNpemVPYnNlcnZlci5qcycpO1xuXG5sZXQgX1JPOiBSZXNpemVPYnNlcnZlck1vZHVsZSB8IFJlc2l6ZU9ic2VydmVyQ29uc3RydWN0b3I7XG5sZXQgUk86IFJlc2l6ZU9ic2VydmVyQ29uc3RydWN0b3I7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge1xuICByZXR1cm4gUk8gfHwgaW5pdCgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0KCkge1xuICBpZiAoX1JPKSB7XG4gICAgcmV0dXJuICgoYXdhaXQgX1JPKSBhcyBSZXNpemVPYnNlcnZlck1vZHVsZSkuZGVmYXVsdDtcbiAgfSBlbHNlIHtcbiAgICBfUk8gPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXI7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBfUk8oZnVuY3Rpb24gKCkge30pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9STyA9IGltcG9ydChcbiAgICAgICAgJy4uL3BvbHlmaWxscy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvUmVzaXplT2JzZXJ2ZXIuanMnXG4gICAgICApIGFzIHVua25vd24gYXMgUmVzaXplT2JzZXJ2ZXJNb2R1bGU7XG4gICAgICBfUk8gPSAoYXdhaXQgX1JPKS5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gKFJPID0gX1JPKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/virtualize.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/virtualize.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultKeyFunction\": () => (/* binding */ defaultKeyFunction),\n/* harmony export */   \"defaultRenderItem\": () => (/* binding */ defaultRenderItem),\n/* harmony export */   \"virtualize\": () => (/* binding */ virtualize),\n/* harmony export */   \"virtualizerRef\": () => (/* reexport safe */ _Virtualizer_js__WEBPACK_IMPORTED_MODULE_4__.virtualizerRef)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var lit_async_directive_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/async-directive.js */ \"./node_modules/lit/async-directive.js\");\n/* harmony import */ var lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit/directives/repeat.js */ \"./node_modules/lit/directives/repeat.js\");\n/* harmony import */ var _Virtualizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Virtualizer.js */ \"./node_modules/@lit-labs/virtualizer/Virtualizer.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n\n\n\nconst defaultKeyFunction = item => item;\nconst defaultRenderItem = (item, idx) => lit__WEBPACK_IMPORTED_MODULE_0__.html`${idx}: ${JSON.stringify(item, null, 2)}`;\nclass VirtualizeDirective extends lit_async_directive_js__WEBPACK_IMPORTED_MODULE_2__.AsyncDirective {\n  constructor(part) {\n    super(part);\n    this._virtualizer = null;\n    this._first = 0;\n    this._last = -1;\n    this._renderItem = (item, idx) => defaultRenderItem(item, idx + this._first);\n    this._keyFunction = (item, idx) => defaultKeyFunction(item, idx + this._first);\n    this._items = [];\n    if (part.type !== lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.CHILD) {\n      throw new Error('The virtualize directive can only be used in child expressions');\n    }\n  }\n  render(config) {\n    if (config) {\n      this._setFunctions(config);\n    }\n    const itemsToRender = [];\n    // TODO (graynorton): Is this the best / only place to ensure\n    // that _last isn't outside the current bounds of the items array?\n    // Not sure we should ever arrive here with it out of bounds.\n    // Repro case for original issue: https://tinyurl.com/yes8b2e6\n    const lastItem = Math.min(this._items.length, this._last + 1);\n    if (this._first >= 0 && this._last >= this._first) {\n      for (let i = this._first; i < lastItem; i++) {\n        itemsToRender.push(this._items[i]);\n      }\n    }\n    return (0,lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_3__.repeat)(itemsToRender, this._keyFunction, this._renderItem);\n  }\n  update(part, [config]) {\n    this._setFunctions(config);\n    this._items = config.items || [];\n    if (this._virtualizer) {\n      this._updateVirtualizerConfig(part, config);\n    } else {\n      this._initialize(part, config);\n    }\n    return this.render();\n  }\n  _updateVirtualizerConfig(part, config) {\n    const compatible = this._virtualizer.updateLayoutConfig(config.layout || {});\n    if (!compatible) {\n      const hostElement = part.parentNode;\n      this._makeVirtualizer(hostElement, config);\n    }\n    this._virtualizer.items = this._items;\n  }\n  _setFunctions(config) {\n    const {\n      renderItem,\n      keyFunction\n    } = config;\n    if (renderItem) {\n      this._renderItem = (item, idx) => renderItem(item, idx + this._first);\n    }\n    if (keyFunction) {\n      this._keyFunction = (item, idx) => keyFunction(item, idx + this._first);\n    }\n  }\n  _makeVirtualizer(hostElement, config) {\n    if (this._virtualizer) {\n      this._virtualizer.disconnected();\n    }\n    const {\n      layout,\n      scroller,\n      items\n    } = config;\n    this._virtualizer = new _Virtualizer_js__WEBPACK_IMPORTED_MODULE_4__.Virtualizer({\n      hostElement,\n      layout,\n      scroller\n    });\n    this._virtualizer.items = items;\n    this._virtualizer.connected();\n  }\n  _initialize(part, config) {\n    const hostElement = part.parentNode;\n    if (hostElement && hostElement.nodeType === 1) {\n      hostElement.addEventListener('rangeChanged', e => {\n        e.stopPropagation();\n        this._first = e.first;\n        this._last = e.last;\n        this.setValue(this.render());\n      });\n      this._makeVirtualizer(hostElement, config);\n    }\n  }\n  disconnected() {\n    var _a;\n    (_a = this._virtualizer) === null || _a === void 0 ? void 0 : _a.disconnected();\n  }\n  reconnected() {\n    var _a;\n    (_a = this._virtualizer) === null || _a === void 0 ? void 0 : _a.connected();\n  }\n}\nconst virtualize = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(VirtualizeDirective);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3ZpcnR1YWxpemUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBOEJBO0FBQ0E7QUFLQTtBQVVBO0FBQ0E7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFJQTtBQUNBOztBQUlBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFJQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvc3JjL3ZpcnR1YWxpemUudHM/ZjY1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtUZW1wbGF0ZVJlc3VsdCwgQ2hpbGRQYXJ0LCBodG1sfSBmcm9tICdsaXQnO1xuaW1wb3J0IHtkaXJlY3RpdmUsIERpcmVjdGl2ZVJlc3VsdCwgUGFydEluZm8sIFBhcnRUeXBlfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7QXN5bmNEaXJlY3RpdmV9IGZyb20gJ2xpdC9hc3luYy1kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHtyZXBlYXQsIEtleUZufSBmcm9tICdsaXQvZGlyZWN0aXZlcy9yZXBlYXQuanMnO1xuaW1wb3J0IHtWaXJ0dWFsaXplcn0gZnJvbSAnLi9WaXJ0dWFsaXplci5qcyc7XG5pbXBvcnQge1JhbmdlQ2hhbmdlZEV2ZW50fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge0xheW91dENvbmZpZ1ZhbHVlfSBmcm9tICcuL2xheW91dHMvc2hhcmVkL0xheW91dC5qcyc7XG5cbmV4cG9ydCB7dmlydHVhbGl6ZXJSZWYsIFZpcnR1YWxpemVySG9zdEVsZW1lbnR9IGZyb20gJy4vVmlydHVhbGl6ZXIuanMnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHZpcnR1YWxpemUgZGlyZWN0aXZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVEaXJlY3RpdmVDb25maWc8VD4ge1xuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXQtaHRtbCBUZW1wbGF0ZVJlc3VsdC4gSXQgd2lsbCBiZSB1c2VkXG4gICAqIHRvIGdlbmVyYXRlIHRoZSBET00gZm9yIGVhY2ggaXRlbSBpbiB0aGUgdmlydHVhbCBsaXN0LlxuICAgKi9cbiAgcmVuZGVySXRlbT86IFJlbmRlckl0ZW1GdW5jdGlvbjxUPjtcblxuICBrZXlGdW5jdGlvbj86IEtleUZuPFQ+O1xuXG4gIHNjcm9sbGVyPzogYm9vbGVhbjtcblxuICAvLyBUT0RPIChncmF5bm9ydG9uKTogRG9jdW1lbnQuLi5cbiAgbGF5b3V0PzogTGF5b3V0Q29uZmlnVmFsdWU7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGl0ZW1zIHRvIGRpc3BsYXkgdmlhIHRoZSByZW5kZXJJdGVtIGZ1bmN0aW9uLlxuICAgKi9cbiAgaXRlbXM/OiBBcnJheTxUPjtcbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVySXRlbUZ1bmN0aW9uPFQgPSB1bmtub3duPiA9IChcbiAgaXRlbTogVCxcbiAgaW5kZXg6IG51bWJlclxuKSA9PiBUZW1wbGF0ZVJlc3VsdDtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRLZXlGdW5jdGlvbjogS2V5Rm48dW5rbm93bj4gPSAoaXRlbTogdW5rbm93bikgPT4gaXRlbTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0UmVuZGVySXRlbTogUmVuZGVySXRlbUZ1bmN0aW9uPHVua25vd24+ID0gKFxuICBpdGVtOiB1bmtub3duLFxuICBpZHg6IG51bWJlclxuKSA9PiBodG1sYCR7aWR4fTogJHtKU09OLnN0cmluZ2lmeShpdGVtLCBudWxsLCAyKX1gO1xuXG5jbGFzcyBWaXJ0dWFsaXplRGlyZWN0aXZlPFQgPSB1bmtub3duPiBleHRlbmRzIEFzeW5jRGlyZWN0aXZlIHtcbiAgX3ZpcnR1YWxpemVyOiBWaXJ0dWFsaXplciB8IG51bGwgPSBudWxsO1xuICBfZmlyc3QgPSAwO1xuICBfbGFzdCA9IC0xO1xuICBfcmVuZGVySXRlbTogUmVuZGVySXRlbUZ1bmN0aW9uPFQ+ID0gKGl0ZW06IFQsIGlkeDogbnVtYmVyKSA9PlxuICAgIGRlZmF1bHRSZW5kZXJJdGVtKGl0ZW0sIGlkeCArIHRoaXMuX2ZpcnN0KTtcbiAgX2tleUZ1bmN0aW9uOiBLZXlGbjxUPiA9IChpdGVtOiBULCBpZHg6IG51bWJlcikgPT5cbiAgICBkZWZhdWx0S2V5RnVuY3Rpb24oaXRlbSwgaWR4ICsgdGhpcy5fZmlyc3QpO1xuICBfaXRlbXM6IEFycmF5PFQ+ID0gW107XG5cbiAgY29uc3RydWN0b3IocGFydDogUGFydEluZm8pIHtcbiAgICBzdXBlcihwYXJ0KTtcbiAgICBpZiAocGFydC50eXBlICE9PSBQYXJ0VHlwZS5DSElMRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHZpcnR1YWxpemUgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgaW4gY2hpbGQgZXhwcmVzc2lvbnMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcihjb25maWc/OiBWaXJ0dWFsaXplRGlyZWN0aXZlQ29uZmlnPFQ+KSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5fc2V0RnVuY3Rpb25zKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zVG9SZW5kZXI6IEFycmF5PFQ+ID0gW107XG4gICAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IElzIHRoaXMgdGhlIGJlc3QgLyBvbmx5IHBsYWNlIHRvIGVuc3VyZVxuICAgIC8vIHRoYXQgX2xhc3QgaXNuJ3Qgb3V0c2lkZSB0aGUgY3VycmVudCBib3VuZHMgb2YgdGhlIGl0ZW1zIGFycmF5P1xuICAgIC8vIE5vdCBzdXJlIHdlIHNob3VsZCBldmVyIGFycml2ZSBoZXJlIHdpdGggaXQgb3V0IG9mIGJvdW5kcy5cbiAgICAvLyBSZXBybyBjYXNlIGZvciBvcmlnaW5hbCBpc3N1ZTogaHR0cHM6Ly90aW55dXJsLmNvbS95ZXM4YjJlNlxuICAgIGNvbnN0IGxhc3RJdGVtID0gTWF0aC5taW4odGhpcy5faXRlbXMubGVuZ3RoLCB0aGlzLl9sYXN0ICsgMSk7XG5cbiAgICBpZiAodGhpcy5fZmlyc3QgPj0gMCAmJiB0aGlzLl9sYXN0ID49IHRoaXMuX2ZpcnN0KSB7XG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fZmlyc3Q7IGkgPCBsYXN0SXRlbTsgaSsrKSB7XG4gICAgICAgIGl0ZW1zVG9SZW5kZXIucHVzaCh0aGlzLl9pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBlYXQoaXRlbXNUb1JlbmRlciwgdGhpcy5fa2V5RnVuY3Rpb24sIHRoaXMuX3JlbmRlckl0ZW0pO1xuICB9XG5cbiAgdXBkYXRlKHBhcnQ6IENoaWxkUGFydCwgW2NvbmZpZ106IFtWaXJ0dWFsaXplRGlyZWN0aXZlQ29uZmlnPFQ+XSkge1xuICAgIHRoaXMuX3NldEZ1bmN0aW9ucyhjb25maWcpO1xuICAgIHRoaXMuX2l0ZW1zID0gY29uZmlnLml0ZW1zIHx8IFtdO1xuICAgIGlmICh0aGlzLl92aXJ0dWFsaXplcikge1xuICAgICAgdGhpcy5fdXBkYXRlVmlydHVhbGl6ZXJDb25maWcocGFydCwgY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZShwYXJ0LCBjb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgX3VwZGF0ZVZpcnR1YWxpemVyQ29uZmlnKFxuICAgIHBhcnQ6IENoaWxkUGFydCxcbiAgICBjb25maWc6IFZpcnR1YWxpemVEaXJlY3RpdmVDb25maWc8VD5cbiAgKSB7XG4gICAgY29uc3QgY29tcGF0aWJsZSA9IHRoaXMuX3ZpcnR1YWxpemVyIS51cGRhdGVMYXlvdXRDb25maWcoXG4gICAgICBjb25maWcubGF5b3V0IHx8IHt9XG4gICAgKTtcbiAgICBpZiAoIWNvbXBhdGlibGUpIHtcbiAgICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gcGFydC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50O1xuICAgICAgdGhpcy5fbWFrZVZpcnR1YWxpemVyKGhvc3RFbGVtZW50LCBjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLl92aXJ0dWFsaXplciEuaXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgfVxuXG4gIHByaXZhdGUgX3NldEZ1bmN0aW9ucyhjb25maWc6IFZpcnR1YWxpemVEaXJlY3RpdmVDb25maWc8VD4pIHtcbiAgICBjb25zdCB7cmVuZGVySXRlbSwga2V5RnVuY3Rpb259ID0gY29uZmlnO1xuICAgIGlmIChyZW5kZXJJdGVtKSB7XG4gICAgICB0aGlzLl9yZW5kZXJJdGVtID0gKGl0ZW0sIGlkeCkgPT4gcmVuZGVySXRlbShpdGVtLCBpZHggKyB0aGlzLl9maXJzdCk7XG4gICAgfVxuICAgIGlmIChrZXlGdW5jdGlvbikge1xuICAgICAgdGhpcy5fa2V5RnVuY3Rpb24gPSAoaXRlbSwgaWR4KSA9PiBrZXlGdW5jdGlvbihpdGVtLCBpZHggKyB0aGlzLl9maXJzdCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbWFrZVZpcnR1YWxpemVyKFxuICAgIGhvc3RFbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICBjb25maWc6IFZpcnR1YWxpemVEaXJlY3RpdmVDb25maWc8VD5cbiAgKSB7XG4gICAgaWYgKHRoaXMuX3ZpcnR1YWxpemVyKSB7XG4gICAgICB0aGlzLl92aXJ0dWFsaXplci5kaXNjb25uZWN0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qge2xheW91dCwgc2Nyb2xsZXIsIGl0ZW1zfSA9IGNvbmZpZztcbiAgICB0aGlzLl92aXJ0dWFsaXplciA9IG5ldyBWaXJ0dWFsaXplcih7aG9zdEVsZW1lbnQsIGxheW91dCwgc2Nyb2xsZXJ9KTtcbiAgICB0aGlzLl92aXJ0dWFsaXplci5pdGVtcyA9IGl0ZW1zO1xuICAgIHRoaXMuX3ZpcnR1YWxpemVyIS5jb25uZWN0ZWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRpYWxpemUocGFydDogQ2hpbGRQYXJ0LCBjb25maWc6IFZpcnR1YWxpemVEaXJlY3RpdmVDb25maWc8VD4pIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHBhcnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudDtcbiAgICBpZiAoaG9zdEVsZW1lbnQgJiYgaG9zdEVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGhvc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JhbmdlQ2hhbmdlZCcsIChlOiBSYW5nZUNoYW5nZWRFdmVudCkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLl9maXJzdCA9IGUuZmlyc3Q7XG4gICAgICAgIHRoaXMuX2xhc3QgPSBlLmxhc3Q7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5yZW5kZXIoKSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX21ha2VWaXJ0dWFsaXplcihob3N0RWxlbWVudCwgY29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5fdmlydHVhbGl6ZXI/LmRpc2Nvbm5lY3RlZCgpO1xuICB9XG5cbiAgcmVjb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5fdmlydHVhbGl6ZXI/LmNvbm5lY3RlZCgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB2aXJ0dWFsaXplID0gZGlyZWN0aXZlKFZpcnR1YWxpemVEaXJlY3RpdmUpIGFzIDxUPihcbiAgY29uZmlnPzogVmlydHVhbGl6ZURpcmVjdGl2ZUNvbmZpZzxUPlxuKSA9PiBEaXJlY3RpdmVSZXN1bHQ8dHlwZW9mIFZpcnR1YWxpemVEaXJlY3RpdmU+O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/virtualize.js\n");

/***/ }),

/***/ "./node_modules/lit/decorators/property.js":
/*!*************************************************!*\
  !*** ./node_modules/lit/decorators/property.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "property": () => (/* reexport safe */ _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_0__.property)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element/decorators/property.js */ "./node_modules/@lit/reactive-element/development/decorators/property.js");


/***/ })

}]);