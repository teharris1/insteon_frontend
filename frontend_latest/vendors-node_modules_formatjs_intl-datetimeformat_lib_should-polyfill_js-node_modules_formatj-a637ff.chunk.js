"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_formatjs_intl-datetimeformat_lib_should-polyfill_js-node_modules_formatj-a637ff"],{

/***/ "./node_modules/@formatjs/intl-datetimeformat/lib/should-polyfill.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-datetimeformat/lib/should-polyfill.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shouldPolyfill\": () => (/* binding */ shouldPolyfill)\n/* harmony export */ });\n/* harmony import */ var _formatjs_intl_localematcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formatjs/intl-localematcher */ \"./node_modules/@formatjs/intl-localematcher/index.js\");\n/* harmony import */ var _supported_locales__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./supported-locales */ \"./node_modules/@formatjs/intl-datetimeformat/lib/supported-locales.js\");\n\n\n\nfunction supportsDateStyle() {\n  try {\n    return !!new Intl.DateTimeFormat(undefined, {\n      dateStyle: 'short'\n    }).resolvedOptions().dateStyle;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * https://bugs.chromium.org/p/chromium/issues/detail?id=865351\n */\n\n\nfunction hasChromeLt71Bug() {\n  try {\n    return new Intl.DateTimeFormat('en', {\n      hourCycle: 'h11',\n      hour: 'numeric'\n    }).formatToParts(0)[2].type !== 'dayPeriod';\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Node 14's version of Intl.DateTimeFormat does not throw\n * when dateStyle/timeStyle is used with other options.\n * This was fixed in newer V8 versions\n */\n\n\nfunction hasUnthrownDateTimeStyleBug() {\n  try {\n    return !!new Intl.DateTimeFormat('en', {\n      dateStyle: 'short',\n      hour: 'numeric'\n    }).format(new Date(0));\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction supportedLocalesOf(locale) {\n  if (!locale) {\n    return true;\n  }\n\n  var locales = Array.isArray(locale) ? locale : [locale];\n  return Intl.DateTimeFormat.supportedLocalesOf(locales).length === locales.length;\n}\n\nfunction shouldPolyfill(locale) {\n  if (locale === void 0) {\n    locale = 'en';\n  }\n\n  if (!('DateTimeFormat' in Intl) || !('formatToParts' in Intl.DateTimeFormat.prototype) || !('formatRange' in Intl.DateTimeFormat.prototype) || hasChromeLt71Bug() || hasUnthrownDateTimeStyleBug() || !supportsDateStyle() || !supportedLocalesOf(locale)) {\n    return locale ? (0,_formatjs_intl_localematcher__WEBPACK_IMPORTED_MODULE_0__.match)([locale], _supported_locales__WEBPACK_IMPORTED_MODULE_1__.supportedLocales, 'en') : undefined;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtZGF0ZXRpbWVmb3JtYXQvbGliL3Nob3VsZC1wb2x5ZmlsbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFPQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWRhdGV0aW1lZm9ybWF0L2xpYi9zaG91bGQtcG9seWZpbGwuanM/YzBkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXRjaCB9IGZyb20gJ0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXInO1xuaW1wb3J0IHsgc3VwcG9ydGVkTG9jYWxlcyB9IGZyb20gJy4vc3VwcG9ydGVkLWxvY2FsZXMnO1xuZnVuY3Rpb24gc3VwcG9ydHNEYXRlU3R5bGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBkYXRlU3R5bGU6ICdzaG9ydCcsXG4gICAgICAgIH0pLnJlc29sdmVkT3B0aW9ucygpLmRhdGVTdHlsZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODY1MzUxXG4gKi9cbmZ1bmN0aW9uIGhhc0Nocm9tZUx0NzFCdWcoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4nLCB7XG4gICAgICAgICAgICBob3VyQ3ljbGU6ICdoMTEnLFxuICAgICAgICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgICB9KS5mb3JtYXRUb1BhcnRzKDApWzJdLnR5cGUgIT09ICdkYXlQZXJpb2QnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogTm9kZSAxNCdzIHZlcnNpb24gb2YgSW50bC5EYXRlVGltZUZvcm1hdCBkb2VzIG5vdCB0aHJvd1xuICogd2hlbiBkYXRlU3R5bGUvdGltZVN0eWxlIGlzIHVzZWQgd2l0aCBvdGhlciBvcHRpb25zLlxuICogVGhpcyB3YXMgZml4ZWQgaW4gbmV3ZXIgVjggdmVyc2lvbnNcbiAqL1xuZnVuY3Rpb24gaGFzVW50aHJvd25EYXRlVGltZVN0eWxlQnVnKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIW5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbicsIHtcbiAgICAgICAgICAgIGRhdGVTdHlsZTogJ3Nob3J0JyxcbiAgICAgICAgICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICAgICAgfSkuZm9ybWF0KG5ldyBEYXRlKDApKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1cHBvcnRlZExvY2FsZXNPZihsb2NhbGUpIHtcbiAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxvY2FsZXMgPSBBcnJheS5pc0FycmF5KGxvY2FsZSkgPyBsb2NhbGUgOiBbbG9jYWxlXTtcbiAgICByZXR1cm4gKEludGwuRGF0ZVRpbWVGb3JtYXQuc3VwcG9ydGVkTG9jYWxlc09mKGxvY2FsZXMpLmxlbmd0aCA9PT0gbG9jYWxlcy5sZW5ndGgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFBvbHlmaWxsKGxvY2FsZSkge1xuICAgIGlmIChsb2NhbGUgPT09IHZvaWQgMCkgeyBsb2NhbGUgPSAnZW4nOyB9XG4gICAgaWYgKCEoJ0RhdGVUaW1lRm9ybWF0JyBpbiBJbnRsKSB8fFxuICAgICAgICAhKCdmb3JtYXRUb1BhcnRzJyBpbiBJbnRsLkRhdGVUaW1lRm9ybWF0LnByb3RvdHlwZSkgfHxcbiAgICAgICAgISgnZm9ybWF0UmFuZ2UnIGluIEludGwuRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlKSB8fFxuICAgICAgICBoYXNDaHJvbWVMdDcxQnVnKCkgfHxcbiAgICAgICAgaGFzVW50aHJvd25EYXRlVGltZVN0eWxlQnVnKCkgfHxcbiAgICAgICAgIXN1cHBvcnRzRGF0ZVN0eWxlKCkgfHxcbiAgICAgICAgIXN1cHBvcnRlZExvY2FsZXNPZihsb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUgPyBtYXRjaChbbG9jYWxlXSwgc3VwcG9ydGVkTG9jYWxlcywgJ2VuJykgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-datetimeformat/lib/should-polyfill.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-datetimeformat/lib/supported-locales.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-datetimeformat/lib/supported-locales.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"supportedLocales\": () => (/* binding */ supportedLocales)\n/* harmony export */ });\n// This file is generated from supported-locales-gen.ts\nvar supportedLocales = [\"af-NA\", \"af\", \"agq\", \"ak\", \"am\", \"ar-AE\", \"ar-BH\", \"ar-DJ\", \"ar-DZ\", \"ar-EG\", \"ar-EH\", \"ar-ER\", \"ar-IL\", \"ar-IQ\", \"ar-JO\", \"ar-KM\", \"ar-KW\", \"ar-LB\", \"ar-LY\", \"ar-MA\", \"ar-MR\", \"ar-OM\", \"ar-PS\", \"ar-QA\", \"ar-SA\", \"ar-SD\", \"ar-SO\", \"ar-SS\", \"ar-SY\", \"ar-TD\", \"ar-TN\", \"ar-YE\", \"ar\", \"as\", \"asa\", \"ast\", \"az-Cyrl\", \"az-Latn\", \"az\", \"bas\", \"be-tarask\", \"be\", \"bem\", \"bez\", \"bg\", \"bm\", \"bn-IN\", \"bn\", \"bo-IN\", \"bo\", \"br\", \"brx\", \"bs-Cyrl\", \"bs-Latn\", \"bs\", \"ca-AD\", \"ca-ES-valencia\", \"ca-FR\", \"ca-IT\", \"ca\", \"ccp-IN\", \"ccp\", \"ce\", \"ceb\", \"cgg\", \"chr\", \"ckb-IR\", \"ckb\", \"cs\", \"cy\", \"da-GL\", \"da\", \"dav\", \"de-AT\", \"de-BE\", \"de-CH\", \"de-IT\", \"de-LI\", \"de-LU\", \"de\", \"dje\", \"doi\", \"dsb\", \"dua\", \"dyo\", \"dz\", \"ebu\", \"ee-TG\", \"ee\", \"el-CY\", \"el\", \"en-001\", \"en-150\", \"en-AE\", \"en-AG\", \"en-AI\", \"en-AS\", \"en-AT\", \"en-AU\", \"en-BB\", \"en-BE\", \"en-BI\", \"en-BM\", \"en-BS\", \"en-BW\", \"en-BZ\", \"en-CA\", \"en-CC\", \"en-CH\", \"en-CK\", \"en-CM\", \"en-CX\", \"en-CY\", \"en-DE\", \"en-DG\", \"en-DK\", \"en-DM\", \"en-ER\", \"en-FI\", \"en-FJ\", \"en-FK\", \"en-FM\", \"en-GB\", \"en-GD\", \"en-GG\", \"en-GH\", \"en-GI\", \"en-GM\", \"en-GU\", \"en-GY\", \"en-HK\", \"en-IE\", \"en-IL\", \"en-IM\", \"en-IN\", \"en-IO\", \"en-JE\", \"en-JM\", \"en-KE\", \"en-KI\", \"en-KN\", \"en-KY\", \"en-LC\", \"en-LR\", \"en-LS\", \"en-MG\", \"en-MH\", \"en-MO\", \"en-MP\", \"en-MS\", \"en-MT\", \"en-MU\", \"en-MW\", \"en-MY\", \"en-NA\", \"en-NF\", \"en-NG\", \"en-NL\", \"en-NR\", \"en-NU\", \"en-NZ\", \"en-PG\", \"en-PH\", \"en-PK\", \"en-PN\", \"en-PR\", \"en-PW\", \"en-RW\", \"en-SB\", \"en-SC\", \"en-SD\", \"en-SE\", \"en-SG\", \"en-SH\", \"en-SI\", \"en-SL\", \"en-SS\", \"en-SX\", \"en-SZ\", \"en-TC\", \"en-TK\", \"en-TO\", \"en-TT\", \"en-TV\", \"en-TZ\", \"en-UG\", \"en-UM\", \"en-VC\", \"en-VG\", \"en-VI\", \"en-VU\", \"en-WS\", \"en-ZA\", \"en-ZM\", \"en-ZW\", \"en\", \"eo\", \"es-419\", \"es-AR\", \"es-BO\", \"es-BR\", \"es-BZ\", \"es-CL\", \"es-CO\", \"es-CR\", \"es-CU\", \"es-DO\", \"es-EA\", \"es-EC\", \"es-GQ\", \"es-GT\", \"es-HN\", \"es-IC\", \"es-MX\", \"es-NI\", \"es-PA\", \"es-PE\", \"es-PH\", \"es-PR\", \"es-PY\", \"es-SV\", \"es-US\", \"es-UY\", \"es-VE\", \"es\", \"et\", \"eu\", \"ewo\", \"fa-AF\", \"fa\", \"ff-Adlm-BF\", \"ff-Adlm-CM\", \"ff-Adlm-GH\", \"ff-Adlm-GM\", \"ff-Adlm-GW\", \"ff-Adlm-LR\", \"ff-Adlm-MR\", \"ff-Adlm-NE\", \"ff-Adlm-NG\", \"ff-Adlm-SL\", \"ff-Adlm-SN\", \"ff-Adlm\", \"ff-Latn-BF\", \"ff-Latn-CM\", \"ff-Latn-GH\", \"ff-Latn-GM\", \"ff-Latn-GN\", \"ff-Latn-GW\", \"ff-Latn-LR\", \"ff-Latn-MR\", \"ff-Latn-NE\", \"ff-Latn-NG\", \"ff-Latn-SL\", \"ff-Latn\", \"ff\", \"fi\", \"fil\", \"fo-DK\", \"fo\", \"fr-BE\", \"fr-BF\", \"fr-BI\", \"fr-BJ\", \"fr-BL\", \"fr-CA\", \"fr-CD\", \"fr-CF\", \"fr-CG\", \"fr-CH\", \"fr-CI\", \"fr-CM\", \"fr-DJ\", \"fr-DZ\", \"fr-GA\", \"fr-GF\", \"fr-GN\", \"fr-GP\", \"fr-GQ\", \"fr-HT\", \"fr-KM\", \"fr-LU\", \"fr-MA\", \"fr-MC\", \"fr-MF\", \"fr-MG\", \"fr-ML\", \"fr-MQ\", \"fr-MR\", \"fr-MU\", \"fr-NC\", \"fr-NE\", \"fr-PF\", \"fr-PM\", \"fr-RE\", \"fr-RW\", \"fr-SC\", \"fr-SN\", \"fr-SY\", \"fr-TD\", \"fr-TG\", \"fr-TN\", \"fr-VU\", \"fr-WF\", \"fr-YT\", \"fr\", \"fur\", \"fy\", \"ga-GB\", \"ga\", \"gd\", \"gl\", \"gsw-FR\", \"gsw-LI\", \"gsw\", \"gu\", \"guz\", \"gv\", \"ha-GH\", \"ha-NE\", \"ha\", \"haw\", \"he\", \"hi\", \"hr-BA\", \"hr\", \"hsb\", \"hu\", \"hy\", \"ia\", \"id\", \"ig\", \"ii\", \"is\", \"it-CH\", \"it-SM\", \"it-VA\", \"it\", \"ja\", \"jgo\", \"jmc\", \"jv\", \"ka\", \"kab\", \"kam\", \"kde\", \"kea\", \"kgp\", \"khq\", \"ki\", \"kk\", \"kkj\", \"kl\", \"kln\", \"km\", \"kn\", \"ko-KP\", \"ko\", \"kok\", \"ks-Arab\", \"ks\", \"ksb\", \"ksf\", \"ksh\", \"ku\", \"kw\", \"ky\", \"lag\", \"lb\", \"lg\", \"lkt\", \"ln-AO\", \"ln-CF\", \"ln-CG\", \"ln\", \"lo\", \"lrc-IQ\", \"lrc\", \"lt\", \"lu\", \"luo\", \"luy\", \"lv\", \"mai\", \"mas-TZ\", \"mas\", \"mer\", \"mfe\", \"mg\", \"mgh\", \"mgo\", \"mi\", \"mk\", \"ml\", \"mn\", \"mni-Beng\", \"mni\", \"mr\", \"ms-BN\", \"ms-ID\", \"ms-SG\", \"ms\", \"mt\", \"mua\", \"my\", \"mzn\", \"naq\", \"nb-SJ\", \"nb\", \"nd\", \"nds-NL\", \"nds\", \"ne-IN\", \"ne\", \"nl-AW\", \"nl-BE\", \"nl-BQ\", \"nl-CW\", \"nl-SR\", \"nl-SX\", \"nl\", \"nmg\", \"nn\", \"nnh\", \"no\", \"nus\", \"nyn\", \"om-KE\", \"om\", \"or\", \"os-RU\", \"os\", \"pa-Arab\", \"pa-Guru\", \"pa\", \"pcm\", \"pl\", \"ps-PK\", \"ps\", \"pt-AO\", \"pt-CH\", \"pt-CV\", \"pt-GQ\", \"pt-GW\", \"pt-LU\", \"pt-MO\", \"pt-MZ\", \"pt-PT\", \"pt-ST\", \"pt-TL\", \"pt\", \"qu-BO\", \"qu-EC\", \"qu\", \"rm\", \"rn\", \"ro-MD\", \"ro\", \"rof\", \"ru-BY\", \"ru-KG\", \"ru-KZ\", \"ru-MD\", \"ru-UA\", \"ru\", \"rw\", \"rwk\", \"sa\", \"sah\", \"saq\", \"sat-Olck\", \"sat\", \"sbp\", \"sc\", \"sd-Arab\", \"sd-Deva\", \"sd\", \"se-FI\", \"se-SE\", \"se\", \"seh\", \"ses\", \"sg\", \"shi-Latn\", \"shi-Tfng\", \"shi\", \"si\", \"sk\", \"sl\", \"smn\", \"sn\", \"so-DJ\", \"so-ET\", \"so-KE\", \"so\", \"sq-MK\", \"sq-XK\", \"sq\", \"sr-Cyrl-BA\", \"sr-Cyrl-ME\", \"sr-Cyrl-XK\", \"sr-Cyrl\", \"sr-Latn-BA\", \"sr-Latn-ME\", \"sr-Latn-XK\", \"sr-Latn\", \"sr\", \"su-Latn\", \"su\", \"sv-AX\", \"sv-FI\", \"sv\", \"sw-CD\", \"sw-KE\", \"sw-UG\", \"sw\", \"ta-LK\", \"ta-MY\", \"ta-SG\", \"ta\", \"te\", \"teo-KE\", \"teo\", \"tg\", \"th\", \"ti-ER\", \"ti\", \"tk\", \"to\", \"tr-CY\", \"tr\", \"tt\", \"twq\", \"tzm\", \"ug\", \"uk\", \"und\", \"ur-IN\", \"ur\", \"uz-Arab\", \"uz-Cyrl\", \"uz-Latn\", \"uz\", \"vai-Latn\", \"vai-Vaii\", \"vai\", \"vi\", \"vun\", \"wae\", \"wo\", \"xh\", \"xog\", \"yav\", \"yi\", \"yo-BJ\", \"yo\", \"yrl-CO\", \"yrl-VE\", \"yrl\", \"yue-Hans\", \"yue-Hant\", \"yue\", \"zgh\", \"zh-Hans-HK\", \"zh-Hans-MO\", \"zh-Hans-SG\", \"zh-Hans\", \"zh-Hant-HK\", \"zh-Hant-MO\", \"zh-Hant\", \"zh\", \"zu\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtZGF0ZXRpbWVmb3JtYXQvbGliL3N1cHBvcnRlZC1sb2NhbGVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1kYXRldGltZWZvcm1hdC9saWIvc3VwcG9ydGVkLWxvY2FsZXMuanM/MzdmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gc3VwcG9ydGVkLWxvY2FsZXMtZ2VuLnRzXG5leHBvcnQgdmFyIHN1cHBvcnRlZExvY2FsZXMgPSBbXCJhZi1OQVwiLCBcImFmXCIsIFwiYWdxXCIsIFwiYWtcIiwgXCJhbVwiLCBcImFyLUFFXCIsIFwiYXItQkhcIiwgXCJhci1ESlwiLCBcImFyLURaXCIsIFwiYXItRUdcIiwgXCJhci1FSFwiLCBcImFyLUVSXCIsIFwiYXItSUxcIiwgXCJhci1JUVwiLCBcImFyLUpPXCIsIFwiYXItS01cIiwgXCJhci1LV1wiLCBcImFyLUxCXCIsIFwiYXItTFlcIiwgXCJhci1NQVwiLCBcImFyLU1SXCIsIFwiYXItT01cIiwgXCJhci1QU1wiLCBcImFyLVFBXCIsIFwiYXItU0FcIiwgXCJhci1TRFwiLCBcImFyLVNPXCIsIFwiYXItU1NcIiwgXCJhci1TWVwiLCBcImFyLVREXCIsIFwiYXItVE5cIiwgXCJhci1ZRVwiLCBcImFyXCIsIFwiYXNcIiwgXCJhc2FcIiwgXCJhc3RcIiwgXCJhei1DeXJsXCIsIFwiYXotTGF0blwiLCBcImF6XCIsIFwiYmFzXCIsIFwiYmUtdGFyYXNrXCIsIFwiYmVcIiwgXCJiZW1cIiwgXCJiZXpcIiwgXCJiZ1wiLCBcImJtXCIsIFwiYm4tSU5cIiwgXCJiblwiLCBcImJvLUlOXCIsIFwiYm9cIiwgXCJiclwiLCBcImJyeFwiLCBcImJzLUN5cmxcIiwgXCJicy1MYXRuXCIsIFwiYnNcIiwgXCJjYS1BRFwiLCBcImNhLUVTLXZhbGVuY2lhXCIsIFwiY2EtRlJcIiwgXCJjYS1JVFwiLCBcImNhXCIsIFwiY2NwLUlOXCIsIFwiY2NwXCIsIFwiY2VcIiwgXCJjZWJcIiwgXCJjZ2dcIiwgXCJjaHJcIiwgXCJja2ItSVJcIiwgXCJja2JcIiwgXCJjc1wiLCBcImN5XCIsIFwiZGEtR0xcIiwgXCJkYVwiLCBcImRhdlwiLCBcImRlLUFUXCIsIFwiZGUtQkVcIiwgXCJkZS1DSFwiLCBcImRlLUlUXCIsIFwiZGUtTElcIiwgXCJkZS1MVVwiLCBcImRlXCIsIFwiZGplXCIsIFwiZG9pXCIsIFwiZHNiXCIsIFwiZHVhXCIsIFwiZHlvXCIsIFwiZHpcIiwgXCJlYnVcIiwgXCJlZS1UR1wiLCBcImVlXCIsIFwiZWwtQ1lcIiwgXCJlbFwiLCBcImVuLTAwMVwiLCBcImVuLTE1MFwiLCBcImVuLUFFXCIsIFwiZW4tQUdcIiwgXCJlbi1BSVwiLCBcImVuLUFTXCIsIFwiZW4tQVRcIiwgXCJlbi1BVVwiLCBcImVuLUJCXCIsIFwiZW4tQkVcIiwgXCJlbi1CSVwiLCBcImVuLUJNXCIsIFwiZW4tQlNcIiwgXCJlbi1CV1wiLCBcImVuLUJaXCIsIFwiZW4tQ0FcIiwgXCJlbi1DQ1wiLCBcImVuLUNIXCIsIFwiZW4tQ0tcIiwgXCJlbi1DTVwiLCBcImVuLUNYXCIsIFwiZW4tQ1lcIiwgXCJlbi1ERVwiLCBcImVuLURHXCIsIFwiZW4tREtcIiwgXCJlbi1ETVwiLCBcImVuLUVSXCIsIFwiZW4tRklcIiwgXCJlbi1GSlwiLCBcImVuLUZLXCIsIFwiZW4tRk1cIiwgXCJlbi1HQlwiLCBcImVuLUdEXCIsIFwiZW4tR0dcIiwgXCJlbi1HSFwiLCBcImVuLUdJXCIsIFwiZW4tR01cIiwgXCJlbi1HVVwiLCBcImVuLUdZXCIsIFwiZW4tSEtcIiwgXCJlbi1JRVwiLCBcImVuLUlMXCIsIFwiZW4tSU1cIiwgXCJlbi1JTlwiLCBcImVuLUlPXCIsIFwiZW4tSkVcIiwgXCJlbi1KTVwiLCBcImVuLUtFXCIsIFwiZW4tS0lcIiwgXCJlbi1LTlwiLCBcImVuLUtZXCIsIFwiZW4tTENcIiwgXCJlbi1MUlwiLCBcImVuLUxTXCIsIFwiZW4tTUdcIiwgXCJlbi1NSFwiLCBcImVuLU1PXCIsIFwiZW4tTVBcIiwgXCJlbi1NU1wiLCBcImVuLU1UXCIsIFwiZW4tTVVcIiwgXCJlbi1NV1wiLCBcImVuLU1ZXCIsIFwiZW4tTkFcIiwgXCJlbi1ORlwiLCBcImVuLU5HXCIsIFwiZW4tTkxcIiwgXCJlbi1OUlwiLCBcImVuLU5VXCIsIFwiZW4tTlpcIiwgXCJlbi1QR1wiLCBcImVuLVBIXCIsIFwiZW4tUEtcIiwgXCJlbi1QTlwiLCBcImVuLVBSXCIsIFwiZW4tUFdcIiwgXCJlbi1SV1wiLCBcImVuLVNCXCIsIFwiZW4tU0NcIiwgXCJlbi1TRFwiLCBcImVuLVNFXCIsIFwiZW4tU0dcIiwgXCJlbi1TSFwiLCBcImVuLVNJXCIsIFwiZW4tU0xcIiwgXCJlbi1TU1wiLCBcImVuLVNYXCIsIFwiZW4tU1pcIiwgXCJlbi1UQ1wiLCBcImVuLVRLXCIsIFwiZW4tVE9cIiwgXCJlbi1UVFwiLCBcImVuLVRWXCIsIFwiZW4tVFpcIiwgXCJlbi1VR1wiLCBcImVuLVVNXCIsIFwiZW4tVkNcIiwgXCJlbi1WR1wiLCBcImVuLVZJXCIsIFwiZW4tVlVcIiwgXCJlbi1XU1wiLCBcImVuLVpBXCIsIFwiZW4tWk1cIiwgXCJlbi1aV1wiLCBcImVuXCIsIFwiZW9cIiwgXCJlcy00MTlcIiwgXCJlcy1BUlwiLCBcImVzLUJPXCIsIFwiZXMtQlJcIiwgXCJlcy1CWlwiLCBcImVzLUNMXCIsIFwiZXMtQ09cIiwgXCJlcy1DUlwiLCBcImVzLUNVXCIsIFwiZXMtRE9cIiwgXCJlcy1FQVwiLCBcImVzLUVDXCIsIFwiZXMtR1FcIiwgXCJlcy1HVFwiLCBcImVzLUhOXCIsIFwiZXMtSUNcIiwgXCJlcy1NWFwiLCBcImVzLU5JXCIsIFwiZXMtUEFcIiwgXCJlcy1QRVwiLCBcImVzLVBIXCIsIFwiZXMtUFJcIiwgXCJlcy1QWVwiLCBcImVzLVNWXCIsIFwiZXMtVVNcIiwgXCJlcy1VWVwiLCBcImVzLVZFXCIsIFwiZXNcIiwgXCJldFwiLCBcImV1XCIsIFwiZXdvXCIsIFwiZmEtQUZcIiwgXCJmYVwiLCBcImZmLUFkbG0tQkZcIiwgXCJmZi1BZGxtLUNNXCIsIFwiZmYtQWRsbS1HSFwiLCBcImZmLUFkbG0tR01cIiwgXCJmZi1BZGxtLUdXXCIsIFwiZmYtQWRsbS1MUlwiLCBcImZmLUFkbG0tTVJcIiwgXCJmZi1BZGxtLU5FXCIsIFwiZmYtQWRsbS1OR1wiLCBcImZmLUFkbG0tU0xcIiwgXCJmZi1BZGxtLVNOXCIsIFwiZmYtQWRsbVwiLCBcImZmLUxhdG4tQkZcIiwgXCJmZi1MYXRuLUNNXCIsIFwiZmYtTGF0bi1HSFwiLCBcImZmLUxhdG4tR01cIiwgXCJmZi1MYXRuLUdOXCIsIFwiZmYtTGF0bi1HV1wiLCBcImZmLUxhdG4tTFJcIiwgXCJmZi1MYXRuLU1SXCIsIFwiZmYtTGF0bi1ORVwiLCBcImZmLUxhdG4tTkdcIiwgXCJmZi1MYXRuLVNMXCIsIFwiZmYtTGF0blwiLCBcImZmXCIsIFwiZmlcIiwgXCJmaWxcIiwgXCJmby1ES1wiLCBcImZvXCIsIFwiZnItQkVcIiwgXCJmci1CRlwiLCBcImZyLUJJXCIsIFwiZnItQkpcIiwgXCJmci1CTFwiLCBcImZyLUNBXCIsIFwiZnItQ0RcIiwgXCJmci1DRlwiLCBcImZyLUNHXCIsIFwiZnItQ0hcIiwgXCJmci1DSVwiLCBcImZyLUNNXCIsIFwiZnItREpcIiwgXCJmci1EWlwiLCBcImZyLUdBXCIsIFwiZnItR0ZcIiwgXCJmci1HTlwiLCBcImZyLUdQXCIsIFwiZnItR1FcIiwgXCJmci1IVFwiLCBcImZyLUtNXCIsIFwiZnItTFVcIiwgXCJmci1NQVwiLCBcImZyLU1DXCIsIFwiZnItTUZcIiwgXCJmci1NR1wiLCBcImZyLU1MXCIsIFwiZnItTVFcIiwgXCJmci1NUlwiLCBcImZyLU1VXCIsIFwiZnItTkNcIiwgXCJmci1ORVwiLCBcImZyLVBGXCIsIFwiZnItUE1cIiwgXCJmci1SRVwiLCBcImZyLVJXXCIsIFwiZnItU0NcIiwgXCJmci1TTlwiLCBcImZyLVNZXCIsIFwiZnItVERcIiwgXCJmci1UR1wiLCBcImZyLVROXCIsIFwiZnItVlVcIiwgXCJmci1XRlwiLCBcImZyLVlUXCIsIFwiZnJcIiwgXCJmdXJcIiwgXCJmeVwiLCBcImdhLUdCXCIsIFwiZ2FcIiwgXCJnZFwiLCBcImdsXCIsIFwiZ3N3LUZSXCIsIFwiZ3N3LUxJXCIsIFwiZ3N3XCIsIFwiZ3VcIiwgXCJndXpcIiwgXCJndlwiLCBcImhhLUdIXCIsIFwiaGEtTkVcIiwgXCJoYVwiLCBcImhhd1wiLCBcImhlXCIsIFwiaGlcIiwgXCJoci1CQVwiLCBcImhyXCIsIFwiaHNiXCIsIFwiaHVcIiwgXCJoeVwiLCBcImlhXCIsIFwiaWRcIiwgXCJpZ1wiLCBcImlpXCIsIFwiaXNcIiwgXCJpdC1DSFwiLCBcIml0LVNNXCIsIFwiaXQtVkFcIiwgXCJpdFwiLCBcImphXCIsIFwiamdvXCIsIFwiam1jXCIsIFwianZcIiwgXCJrYVwiLCBcImthYlwiLCBcImthbVwiLCBcImtkZVwiLCBcImtlYVwiLCBcImtncFwiLCBcImtocVwiLCBcImtpXCIsIFwia2tcIiwgXCJra2pcIiwgXCJrbFwiLCBcImtsblwiLCBcImttXCIsIFwia25cIiwgXCJrby1LUFwiLCBcImtvXCIsIFwia29rXCIsIFwia3MtQXJhYlwiLCBcImtzXCIsIFwia3NiXCIsIFwia3NmXCIsIFwia3NoXCIsIFwia3VcIiwgXCJrd1wiLCBcImt5XCIsIFwibGFnXCIsIFwibGJcIiwgXCJsZ1wiLCBcImxrdFwiLCBcImxuLUFPXCIsIFwibG4tQ0ZcIiwgXCJsbi1DR1wiLCBcImxuXCIsIFwibG9cIiwgXCJscmMtSVFcIiwgXCJscmNcIiwgXCJsdFwiLCBcImx1XCIsIFwibHVvXCIsIFwibHV5XCIsIFwibHZcIiwgXCJtYWlcIiwgXCJtYXMtVFpcIiwgXCJtYXNcIiwgXCJtZXJcIiwgXCJtZmVcIiwgXCJtZ1wiLCBcIm1naFwiLCBcIm1nb1wiLCBcIm1pXCIsIFwibWtcIiwgXCJtbFwiLCBcIm1uXCIsIFwibW5pLUJlbmdcIiwgXCJtbmlcIiwgXCJtclwiLCBcIm1zLUJOXCIsIFwibXMtSURcIiwgXCJtcy1TR1wiLCBcIm1zXCIsIFwibXRcIiwgXCJtdWFcIiwgXCJteVwiLCBcIm16blwiLCBcIm5hcVwiLCBcIm5iLVNKXCIsIFwibmJcIiwgXCJuZFwiLCBcIm5kcy1OTFwiLCBcIm5kc1wiLCBcIm5lLUlOXCIsIFwibmVcIiwgXCJubC1BV1wiLCBcIm5sLUJFXCIsIFwibmwtQlFcIiwgXCJubC1DV1wiLCBcIm5sLVNSXCIsIFwibmwtU1hcIiwgXCJubFwiLCBcIm5tZ1wiLCBcIm5uXCIsIFwibm5oXCIsIFwibm9cIiwgXCJudXNcIiwgXCJueW5cIiwgXCJvbS1LRVwiLCBcIm9tXCIsIFwib3JcIiwgXCJvcy1SVVwiLCBcIm9zXCIsIFwicGEtQXJhYlwiLCBcInBhLUd1cnVcIiwgXCJwYVwiLCBcInBjbVwiLCBcInBsXCIsIFwicHMtUEtcIiwgXCJwc1wiLCBcInB0LUFPXCIsIFwicHQtQ0hcIiwgXCJwdC1DVlwiLCBcInB0LUdRXCIsIFwicHQtR1dcIiwgXCJwdC1MVVwiLCBcInB0LU1PXCIsIFwicHQtTVpcIiwgXCJwdC1QVFwiLCBcInB0LVNUXCIsIFwicHQtVExcIiwgXCJwdFwiLCBcInF1LUJPXCIsIFwicXUtRUNcIiwgXCJxdVwiLCBcInJtXCIsIFwicm5cIiwgXCJyby1NRFwiLCBcInJvXCIsIFwicm9mXCIsIFwicnUtQllcIiwgXCJydS1LR1wiLCBcInJ1LUtaXCIsIFwicnUtTURcIiwgXCJydS1VQVwiLCBcInJ1XCIsIFwicndcIiwgXCJyd2tcIiwgXCJzYVwiLCBcInNhaFwiLCBcInNhcVwiLCBcInNhdC1PbGNrXCIsIFwic2F0XCIsIFwic2JwXCIsIFwic2NcIiwgXCJzZC1BcmFiXCIsIFwic2QtRGV2YVwiLCBcInNkXCIsIFwic2UtRklcIiwgXCJzZS1TRVwiLCBcInNlXCIsIFwic2VoXCIsIFwic2VzXCIsIFwic2dcIiwgXCJzaGktTGF0blwiLCBcInNoaS1UZm5nXCIsIFwic2hpXCIsIFwic2lcIiwgXCJza1wiLCBcInNsXCIsIFwic21uXCIsIFwic25cIiwgXCJzby1ESlwiLCBcInNvLUVUXCIsIFwic28tS0VcIiwgXCJzb1wiLCBcInNxLU1LXCIsIFwic3EtWEtcIiwgXCJzcVwiLCBcInNyLUN5cmwtQkFcIiwgXCJzci1DeXJsLU1FXCIsIFwic3ItQ3lybC1YS1wiLCBcInNyLUN5cmxcIiwgXCJzci1MYXRuLUJBXCIsIFwic3ItTGF0bi1NRVwiLCBcInNyLUxhdG4tWEtcIiwgXCJzci1MYXRuXCIsIFwic3JcIiwgXCJzdS1MYXRuXCIsIFwic3VcIiwgXCJzdi1BWFwiLCBcInN2LUZJXCIsIFwic3ZcIiwgXCJzdy1DRFwiLCBcInN3LUtFXCIsIFwic3ctVUdcIiwgXCJzd1wiLCBcInRhLUxLXCIsIFwidGEtTVlcIiwgXCJ0YS1TR1wiLCBcInRhXCIsIFwidGVcIiwgXCJ0ZW8tS0VcIiwgXCJ0ZW9cIiwgXCJ0Z1wiLCBcInRoXCIsIFwidGktRVJcIiwgXCJ0aVwiLCBcInRrXCIsIFwidG9cIiwgXCJ0ci1DWVwiLCBcInRyXCIsIFwidHRcIiwgXCJ0d3FcIiwgXCJ0em1cIiwgXCJ1Z1wiLCBcInVrXCIsIFwidW5kXCIsIFwidXItSU5cIiwgXCJ1clwiLCBcInV6LUFyYWJcIiwgXCJ1ei1DeXJsXCIsIFwidXotTGF0blwiLCBcInV6XCIsIFwidmFpLUxhdG5cIiwgXCJ2YWktVmFpaVwiLCBcInZhaVwiLCBcInZpXCIsIFwidnVuXCIsIFwid2FlXCIsIFwid29cIiwgXCJ4aFwiLCBcInhvZ1wiLCBcInlhdlwiLCBcInlpXCIsIFwieW8tQkpcIiwgXCJ5b1wiLCBcInlybC1DT1wiLCBcInlybC1WRVwiLCBcInlybFwiLCBcInl1ZS1IYW5zXCIsIFwieXVlLUhhbnRcIiwgXCJ5dWVcIiwgXCJ6Z2hcIiwgXCJ6aC1IYW5zLUhLXCIsIFwiemgtSGFucy1NT1wiLCBcInpoLUhhbnMtU0dcIiwgXCJ6aC1IYW5zXCIsIFwiemgtSGFudC1IS1wiLCBcInpoLUhhbnQtTU9cIiwgXCJ6aC1IYW50XCIsIFwiemhcIiwgXCJ6dVwiXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-datetimeformat/lib/supported-locales.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-locale/lib/should-polyfill.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@formatjs/intl-locale/lib/should-polyfill.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shouldPolyfill\": () => (/* binding */ shouldPolyfill)\n/* harmony export */ });\n/**\n * https://bugs.chromium.org/p/v8/issues/detail?id=10682\n */\nfunction hasIntlGetCanonicalLocalesBug() {\n  try {\n    return new Intl.Locale('und-x-private').toString() === 'x-private';\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction shouldPolyfill() {\n  return !('Locale' in Intl) || hasIntlGetCanonicalLocalesBug();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlL2xpYi9zaG91bGQtcG9seWZpbGwuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlL2xpYi9zaG91bGQtcG9seWZpbGwuanM/N2I2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEwNjgyXG4gKi9cbmZ1bmN0aW9uIGhhc0ludGxHZXRDYW5vbmljYWxMb2NhbGVzQnVnKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50bC5Mb2NhbGUoJ3VuZC14LXByaXZhdGUnKS50b1N0cmluZygpID09PSAneC1wcml2YXRlJztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFBvbHlmaWxsKCkge1xuICAgIHJldHVybiAhKCdMb2NhbGUnIGluIEludGwpIHx8IGhhc0ludGxHZXRDYW5vbmljYWxMb2NhbGVzQnVnKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-locale/lib/should-polyfill.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/BestAvailableLocale.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/BestAvailableLocale.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BestAvailableLocale = void 0;\n/**\n * https://tc39.es/ecma402/#sec-bestavailablelocale\n * @param availableLocales\n * @param locale\n */\n\nfunction BestAvailableLocale(availableLocales, locale) {\n  var candidate = locale;\n\n  while (true) {\n    if (availableLocales.has(candidate)) {\n      return candidate;\n    }\n\n    var pos = candidate.lastIndexOf('-');\n\n    if (!~pos) {\n      return undefined;\n    }\n\n    if (pos >= 2 && candidate[pos - 2] === '-') {\n      pos -= 2;\n    }\n\n    candidate = candidate.slice(0, pos);\n  }\n}\n\nexports.BestAvailableLocale = BestAvailableLocale;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC9CZXN0QXZhaWxhYmxlTG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2Fic3RyYWN0L0Jlc3RBdmFpbGFibGVMb2NhbGUuanM/MmQwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVzdEF2YWlsYWJsZUxvY2FsZSA9IHZvaWQgMDtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1iZXN0YXZhaWxhYmxlbG9jYWxlXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIGxvY2FsZVxuICovXG5mdW5jdGlvbiBCZXN0QXZhaWxhYmxlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIGxvY2FsZSkge1xuICAgIHZhciBjYW5kaWRhdGUgPSBsb2NhbGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZXMuaGFzKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcyA9IGNhbmRpZGF0ZS5sYXN0SW5kZXhPZignLScpO1xuICAgICAgICBpZiAoIX5wb3MpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSAyICYmIGNhbmRpZGF0ZVtwb3MgLSAyXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwb3MgLT0gMjtcbiAgICAgICAgfVxuICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGUuc2xpY2UoMCwgcG9zKTtcbiAgICB9XG59XG5leHBvcnRzLkJlc3RBdmFpbGFibGVMb2NhbGUgPSBCZXN0QXZhaWxhYmxlTG9jYWxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/BestAvailableLocale.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/BestFitMatcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/BestFitMatcher.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BestFitMatcher = void 0;\n\nvar BestAvailableLocale_1 = __webpack_require__(/*! ./BestAvailableLocale */ \"./node_modules/@formatjs/intl-localematcher/abstract/BestAvailableLocale.js\");\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-localematcher/abstract/utils.js\");\n/**\n * https://tc39.es/ecma402/#sec-bestfitmatcher\n * @param availableLocales\n * @param requestedLocales\n * @param getDefaultLocale\n */\n\n\nfunction BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale) {\n  var minimizedAvailableLocaleMap = {};\n  var availableLocaleMap = {};\n  var canonicalizedLocaleMap = {};\n  var minimizedAvailableLocales = new Set();\n  availableLocales.forEach(function (locale) {\n    var minimizedLocale = new Intl.Locale(locale).minimize().toString();\n    var canonicalizedLocale = Intl.getCanonicalLocales(locale)[0] || locale;\n    minimizedAvailableLocaleMap[minimizedLocale] = locale;\n    availableLocaleMap[locale] = locale;\n    canonicalizedLocaleMap[canonicalizedLocale] = locale;\n    minimizedAvailableLocales.add(minimizedLocale);\n    minimizedAvailableLocales.add(locale);\n    minimizedAvailableLocales.add(canonicalizedLocale);\n  });\n  var foundLocale;\n\n  for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {\n    var l = requestedLocales_1[_i];\n\n    if (foundLocale) {\n      break;\n    }\n\n    var noExtensionLocale = l.replace(utils_1.UNICODE_EXTENSION_SEQUENCE_REGEX, '');\n\n    if (availableLocales.has(noExtensionLocale)) {\n      foundLocale = noExtensionLocale;\n      break;\n    }\n\n    if (minimizedAvailableLocales.has(noExtensionLocale)) {\n      foundLocale = noExtensionLocale;\n      break;\n    }\n\n    var locale = new Intl.Locale(noExtensionLocale);\n    var maximizedRequestedLocale = locale.maximize().toString();\n    var minimizedRequestedLocale = locale.minimize().toString(); // Check minimized locale\n\n    if (minimizedAvailableLocales.has(minimizedRequestedLocale)) {\n      foundLocale = minimizedRequestedLocale;\n      break;\n    } // Lookup algo on maximized locale\n\n\n    foundLocale = (0, BestAvailableLocale_1.BestAvailableLocale)(minimizedAvailableLocales, maximizedRequestedLocale);\n  }\n\n  if (!foundLocale) {\n    return {\n      locale: getDefaultLocale()\n    };\n  }\n\n  return {\n    locale: availableLocaleMap[foundLocale] || canonicalizedLocaleMap[foundLocale] || minimizedAvailableLocaleMap[foundLocale] || foundLocale\n  };\n}\n\nexports.BestFitMatcher = BestFitMatcher;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC9CZXN0Rml0TWF0Y2hlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBO0FBTUE7O0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvYWJzdHJhY3QvQmVzdEZpdE1hdGNoZXIuanM/YzAxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVzdEZpdE1hdGNoZXIgPSB2b2lkIDA7XG52YXIgQmVzdEF2YWlsYWJsZUxvY2FsZV8xID0gcmVxdWlyZShcIi4vQmVzdEF2YWlsYWJsZUxvY2FsZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtYmVzdGZpdG1hdGNoZXJcbiAqIEBwYXJhbSBhdmFpbGFibGVMb2NhbGVzXG4gKiBAcGFyYW0gcmVxdWVzdGVkTG9jYWxlc1xuICogQHBhcmFtIGdldERlZmF1bHRMb2NhbGVcbiAqL1xuZnVuY3Rpb24gQmVzdEZpdE1hdGNoZXIoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgZ2V0RGVmYXVsdExvY2FsZSkge1xuICAgIHZhciBtaW5pbWl6ZWRBdmFpbGFibGVMb2NhbGVNYXAgPSB7fTtcbiAgICB2YXIgYXZhaWxhYmxlTG9jYWxlTWFwID0ge307XG4gICAgdmFyIGNhbm9uaWNhbGl6ZWRMb2NhbGVNYXAgPSB7fTtcbiAgICB2YXIgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcyA9IG5ldyBTZXQoKTtcbiAgICBhdmFpbGFibGVMb2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgICAgICB2YXIgbWluaW1pemVkTG9jYWxlID0gbmV3IEludGwuTG9jYWxlKGxvY2FsZSlcbiAgICAgICAgICAgIC5taW5pbWl6ZSgpXG4gICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNhbm9uaWNhbGl6ZWRMb2NhbGUgPSBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMobG9jYWxlKVswXSB8fCBsb2NhbGU7XG4gICAgICAgIG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZU1hcFttaW5pbWl6ZWRMb2NhbGVdID0gbG9jYWxlO1xuICAgICAgICBhdmFpbGFibGVMb2NhbGVNYXBbbG9jYWxlXSA9IGxvY2FsZTtcbiAgICAgICAgY2Fub25pY2FsaXplZExvY2FsZU1hcFtjYW5vbmljYWxpemVkTG9jYWxlXSA9IGxvY2FsZTtcbiAgICAgICAgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcy5hZGQobWluaW1pemVkTG9jYWxlKTtcbiAgICAgICAgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcy5hZGQobG9jYWxlKTtcbiAgICAgICAgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcy5hZGQoY2Fub25pY2FsaXplZExvY2FsZSk7XG4gICAgfSk7XG4gICAgdmFyIGZvdW5kTG9jYWxlO1xuICAgIGZvciAodmFyIF9pID0gMCwgcmVxdWVzdGVkTG9jYWxlc18xID0gcmVxdWVzdGVkTG9jYWxlczsgX2kgPCByZXF1ZXN0ZWRMb2NhbGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBsID0gcmVxdWVzdGVkTG9jYWxlc18xW19pXTtcbiAgICAgICAgaWYgKGZvdW5kTG9jYWxlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9FeHRlbnNpb25Mb2NhbGUgPSBsLnJlcGxhY2UodXRpbHNfMS5VTklDT0RFX0VYVEVOU0lPTl9TRVFVRU5DRV9SRUdFWCwgJycpO1xuICAgICAgICBpZiAoYXZhaWxhYmxlTG9jYWxlcy5oYXMobm9FeHRlbnNpb25Mb2NhbGUpKSB7XG4gICAgICAgICAgICBmb3VuZExvY2FsZSA9IG5vRXh0ZW5zaW9uTG9jYWxlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZXMuaGFzKG5vRXh0ZW5zaW9uTG9jYWxlKSkge1xuICAgICAgICAgICAgZm91bmRMb2NhbGUgPSBub0V4dGVuc2lvbkxvY2FsZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbGUgPSBuZXcgSW50bC5Mb2NhbGUobm9FeHRlbnNpb25Mb2NhbGUpO1xuICAgICAgICB2YXIgbWF4aW1pemVkUmVxdWVzdGVkTG9jYWxlID0gbG9jYWxlLm1heGltaXplKCkudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG1pbmltaXplZFJlcXVlc3RlZExvY2FsZSA9IGxvY2FsZS5taW5pbWl6ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIENoZWNrIG1pbmltaXplZCBsb2NhbGVcbiAgICAgICAgaWYgKG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZXMuaGFzKG1pbmltaXplZFJlcXVlc3RlZExvY2FsZSkpIHtcbiAgICAgICAgICAgIGZvdW5kTG9jYWxlID0gbWluaW1pemVkUmVxdWVzdGVkTG9jYWxlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9va3VwIGFsZ28gb24gbWF4aW1pemVkIGxvY2FsZVxuICAgICAgICBmb3VuZExvY2FsZSA9ICgwLCBCZXN0QXZhaWxhYmxlTG9jYWxlXzEuQmVzdEF2YWlsYWJsZUxvY2FsZSkobWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcywgbWF4aW1pemVkUmVxdWVzdGVkTG9jYWxlKTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZExvY2FsZSkge1xuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGdldERlZmF1bHRMb2NhbGUoKSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGU6IGF2YWlsYWJsZUxvY2FsZU1hcFtmb3VuZExvY2FsZV0gfHxcbiAgICAgICAgICAgIGNhbm9uaWNhbGl6ZWRMb2NhbGVNYXBbZm91bmRMb2NhbGVdIHx8XG4gICAgICAgICAgICBtaW5pbWl6ZWRBdmFpbGFibGVMb2NhbGVNYXBbZm91bmRMb2NhbGVdIHx8XG4gICAgICAgICAgICBmb3VuZExvY2FsZSxcbiAgICB9O1xufVxuZXhwb3J0cy5CZXN0Rml0TWF0Y2hlciA9IEJlc3RGaXRNYXRjaGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/BestFitMatcher.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/CanonicalizeLocaleList.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/CanonicalizeLocaleList.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanonicalizeLocaleList = void 0;\n/**\n * http://ecma-international.org/ecma-402/7.0/index.html#sec-canonicalizelocalelist\n * @param locales\n */\n\nfunction CanonicalizeLocaleList(locales) {\n  // TODO\n  return Intl.getCanonicalLocales(locales);\n}\n\nexports.CanonicalizeLocaleList = CanonicalizeLocaleList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC9DYW5vbmljYWxpemVMb2NhbGVMaXN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvYWJzdHJhY3QvQ2Fub25pY2FsaXplTG9jYWxlTGlzdC5qcz9hMDVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYW5vbmljYWxpemVMb2NhbGVMaXN0ID0gdm9pZCAwO1xuLyoqXG4gKiBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTQwMi83LjAvaW5kZXguaHRtbCNzZWMtY2Fub25pY2FsaXplbG9jYWxlbGlzdFxuICogQHBhcmFtIGxvY2FsZXNcbiAqL1xuZnVuY3Rpb24gQ2Fub25pY2FsaXplTG9jYWxlTGlzdChsb2NhbGVzKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMobG9jYWxlcyk7XG59XG5leHBvcnRzLkNhbm9uaWNhbGl6ZUxvY2FsZUxpc3QgPSBDYW5vbmljYWxpemVMb2NhbGVMaXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/CanonicalizeLocaleList.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/LookupMatcher.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/LookupMatcher.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.LookupMatcher = void 0;\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-localematcher/abstract/utils.js\");\n\nvar BestAvailableLocale_1 = __webpack_require__(/*! ./BestAvailableLocale */ \"./node_modules/@formatjs/intl-localematcher/abstract/BestAvailableLocale.js\");\n/**\n * https://tc39.es/ecma402/#sec-lookupmatcher\n * @param availableLocales\n * @param requestedLocales\n * @param getDefaultLocale\n */\n\n\nfunction LookupMatcher(availableLocales, requestedLocales, getDefaultLocale) {\n  var result = {\n    locale: ''\n  };\n\n  for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {\n    var locale = requestedLocales_1[_i];\n    var noExtensionLocale = locale.replace(utils_1.UNICODE_EXTENSION_SEQUENCE_REGEX, '');\n    var availableLocale = (0, BestAvailableLocale_1.BestAvailableLocale)(availableLocales, noExtensionLocale);\n\n    if (availableLocale) {\n      result.locale = availableLocale;\n\n      if (locale !== noExtensionLocale) {\n        result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);\n      }\n\n      return result;\n    }\n  }\n\n  result.locale = getDefaultLocale();\n  return result;\n}\n\nexports.LookupMatcher = LookupMatcher;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC9Mb29rdXBNYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2Fic3RyYWN0L0xvb2t1cE1hdGNoZXIuanM/NDExNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9va3VwTWF0Y2hlciA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgQmVzdEF2YWlsYWJsZUxvY2FsZV8xID0gcmVxdWlyZShcIi4vQmVzdEF2YWlsYWJsZUxvY2FsZVwiKTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1sb29rdXBtYXRjaGVyXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIHJlcXVlc3RlZExvY2FsZXNcbiAqIEBwYXJhbSBnZXREZWZhdWx0TG9jYWxlXG4gKi9cbmZ1bmN0aW9uIExvb2t1cE1hdGNoZXIoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgZ2V0RGVmYXVsdExvY2FsZSkge1xuICAgIHZhciByZXN1bHQgPSB7IGxvY2FsZTogJycgfTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHJlcXVlc3RlZExvY2FsZXNfMSA9IHJlcXVlc3RlZExvY2FsZXM7IF9pIDwgcmVxdWVzdGVkTG9jYWxlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbG9jYWxlID0gcmVxdWVzdGVkTG9jYWxlc18xW19pXTtcbiAgICAgICAgdmFyIG5vRXh0ZW5zaW9uTG9jYWxlID0gbG9jYWxlLnJlcGxhY2UodXRpbHNfMS5VTklDT0RFX0VYVEVOU0lPTl9TRVFVRU5DRV9SRUdFWCwgJycpO1xuICAgICAgICB2YXIgYXZhaWxhYmxlTG9jYWxlID0gKDAsIEJlc3RBdmFpbGFibGVMb2NhbGVfMS5CZXN0QXZhaWxhYmxlTG9jYWxlKShhdmFpbGFibGVMb2NhbGVzLCBub0V4dGVuc2lvbkxvY2FsZSk7XG4gICAgICAgIGlmIChhdmFpbGFibGVMb2NhbGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sb2NhbGUgPSBhdmFpbGFibGVMb2NhbGU7XG4gICAgICAgICAgICBpZiAobG9jYWxlICE9PSBub0V4dGVuc2lvbkxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5leHRlbnNpb24gPSBsb2NhbGUuc2xpY2Uobm9FeHRlbnNpb25Mb2NhbGUubGVuZ3RoICsgMSwgbG9jYWxlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sb2NhbGUgPSBnZXREZWZhdWx0TG9jYWxlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuTG9va3VwTWF0Y2hlciA9IExvb2t1cE1hdGNoZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/LookupMatcher.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/LookupSupportedLocales.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/LookupSupportedLocales.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.LookupSupportedLocales = void 0;\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-localematcher/abstract/utils.js\");\n\nvar BestAvailableLocale_1 = __webpack_require__(/*! ./BestAvailableLocale */ \"./node_modules/@formatjs/intl-localematcher/abstract/BestAvailableLocale.js\");\n/**\n * https://tc39.es/ecma402/#sec-lookupsupportedlocales\n * @param availableLocales\n * @param requestedLocales\n */\n\n\nfunction LookupSupportedLocales(availableLocales, requestedLocales) {\n  var subset = [];\n\n  for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {\n    var locale = requestedLocales_1[_i];\n    var noExtensionLocale = locale.replace(utils_1.UNICODE_EXTENSION_SEQUENCE_REGEX, '');\n    var availableLocale = (0, BestAvailableLocale_1.BestAvailableLocale)(availableLocales, noExtensionLocale);\n\n    if (availableLocale) {\n      subset.push(availableLocale);\n    }\n  }\n\n  return subset;\n}\n\nexports.LookupSupportedLocales = LookupSupportedLocales;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC9Mb29rdXBTdXBwb3J0ZWRMb2NhbGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2Fic3RyYWN0L0xvb2t1cFN1cHBvcnRlZExvY2FsZXMuanM/M2NlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9va3VwU3VwcG9ydGVkTG9jYWxlcyA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgQmVzdEF2YWlsYWJsZUxvY2FsZV8xID0gcmVxdWlyZShcIi4vQmVzdEF2YWlsYWJsZUxvY2FsZVwiKTtcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1sb29rdXBzdXBwb3J0ZWRsb2NhbGVzXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIHJlcXVlc3RlZExvY2FsZXNcbiAqL1xuZnVuY3Rpb24gTG9va3VwU3VwcG9ydGVkTG9jYWxlcyhhdmFpbGFibGVMb2NhbGVzLCByZXF1ZXN0ZWRMb2NhbGVzKSB7XG4gICAgdmFyIHN1YnNldCA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgcmVxdWVzdGVkTG9jYWxlc18xID0gcmVxdWVzdGVkTG9jYWxlczsgX2kgPCByZXF1ZXN0ZWRMb2NhbGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSByZXF1ZXN0ZWRMb2NhbGVzXzFbX2ldO1xuICAgICAgICB2YXIgbm9FeHRlbnNpb25Mb2NhbGUgPSBsb2NhbGUucmVwbGFjZSh1dGlsc18xLlVOSUNPREVfRVhURU5TSU9OX1NFUVVFTkNFX1JFR0VYLCAnJyk7XG4gICAgICAgIHZhciBhdmFpbGFibGVMb2NhbGUgPSAoMCwgQmVzdEF2YWlsYWJsZUxvY2FsZV8xLkJlc3RBdmFpbGFibGVMb2NhbGUpKGF2YWlsYWJsZUxvY2FsZXMsIG5vRXh0ZW5zaW9uTG9jYWxlKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZSkge1xuICAgICAgICAgICAgc3Vic2V0LnB1c2goYXZhaWxhYmxlTG9jYWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3Vic2V0O1xufVxuZXhwb3J0cy5Mb29rdXBTdXBwb3J0ZWRMb2NhbGVzID0gTG9va3VwU3VwcG9ydGVkTG9jYWxlcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/LookupSupportedLocales.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/ResolveLocale.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/ResolveLocale.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ResolveLocale = void 0;\n\nvar LookupMatcher_1 = __webpack_require__(/*! ./LookupMatcher */ \"./node_modules/@formatjs/intl-localematcher/abstract/LookupMatcher.js\");\n\nvar BestFitMatcher_1 = __webpack_require__(/*! ./BestFitMatcher */ \"./node_modules/@formatjs/intl-localematcher/abstract/BestFitMatcher.js\");\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-localematcher/abstract/utils.js\");\n\nvar UnicodeExtensionValue_1 = __webpack_require__(/*! ./UnicodeExtensionValue */ \"./node_modules/@formatjs/intl-localematcher/abstract/UnicodeExtensionValue.js\");\n/**\n * https://tc39.es/ecma402/#sec-resolvelocale\n */\n\n\nfunction ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData, getDefaultLocale) {\n  var matcher = options.localeMatcher;\n  var r;\n\n  if (matcher === 'lookup') {\n    r = (0, LookupMatcher_1.LookupMatcher)(availableLocales, requestedLocales, getDefaultLocale);\n  } else {\n    r = (0, BestFitMatcher_1.BestFitMatcher)(availableLocales, requestedLocales, getDefaultLocale);\n  }\n\n  var foundLocale = r.locale;\n  var result = {\n    locale: '',\n    dataLocale: foundLocale\n  };\n  var supportedExtension = '-u';\n\n  for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {\n    var key = relevantExtensionKeys_1[_i];\n    (0, utils_1.invariant)(foundLocale in localeData, \"Missing locale data for \".concat(foundLocale));\n    var foundLocaleData = localeData[foundLocale];\n    (0, utils_1.invariant)(typeof foundLocaleData === 'object' && foundLocaleData !== null, \"locale data \".concat(key, \" must be an object\"));\n    var keyLocaleData = foundLocaleData[key];\n    (0, utils_1.invariant)(Array.isArray(keyLocaleData), \"keyLocaleData for \".concat(key, \" must be an array\"));\n    var value = keyLocaleData[0];\n    (0, utils_1.invariant)(typeof value === 'string' || value === null, \"value must be string or null but got \".concat(typeof value, \" in key \").concat(key));\n    var supportedExtensionAddition = '';\n\n    if (r.extension) {\n      var requestedValue = (0, UnicodeExtensionValue_1.UnicodeExtensionValue)(r.extension, key);\n\n      if (requestedValue !== undefined) {\n        if (requestedValue !== '') {\n          if (~keyLocaleData.indexOf(requestedValue)) {\n            value = requestedValue;\n            supportedExtensionAddition = \"-\".concat(key, \"-\").concat(value);\n          }\n        } else if (~requestedValue.indexOf('true')) {\n          value = 'true';\n          supportedExtensionAddition = \"-\".concat(key);\n        }\n      }\n    }\n\n    if (key in options) {\n      var optionsValue = options[key];\n      (0, utils_1.invariant)(typeof optionsValue === 'string' || typeof optionsValue === 'undefined' || optionsValue === null, 'optionsValue must be String, Undefined or Null');\n\n      if (~keyLocaleData.indexOf(optionsValue)) {\n        if (optionsValue !== value) {\n          value = optionsValue;\n          supportedExtensionAddition = '';\n        }\n      }\n    }\n\n    result[key] = value;\n    supportedExtension += supportedExtensionAddition;\n  }\n\n  if (supportedExtension.length > 2) {\n    var privateIndex = foundLocale.indexOf('-x-');\n\n    if (privateIndex === -1) {\n      foundLocale = foundLocale + supportedExtension;\n    } else {\n      var preExtension = foundLocale.slice(0, privateIndex);\n      var postExtension = foundLocale.slice(privateIndex, foundLocale.length);\n      foundLocale = preExtension + supportedExtension + postExtension;\n    }\n\n    foundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n  }\n\n  result.locale = foundLocale;\n  return result;\n}\n\nexports.ResolveLocale = ResolveLocale;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC9SZXNvbHZlTG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2Fic3RyYWN0L1Jlc29sdmVMb2NhbGUuanM/OThiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2ZUxvY2FsZSA9IHZvaWQgMDtcbnZhciBMb29rdXBNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9Mb29rdXBNYXRjaGVyXCIpO1xudmFyIEJlc3RGaXRNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9CZXN0Rml0TWF0Y2hlclwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgVW5pY29kZUV4dGVuc2lvblZhbHVlXzEgPSByZXF1aXJlKFwiLi9Vbmljb2RlRXh0ZW5zaW9uVmFsdWVcIik7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtcmVzb2x2ZWxvY2FsZVxuICovXG5mdW5jdGlvbiBSZXNvbHZlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIG9wdGlvbnMsIHJlbGV2YW50RXh0ZW5zaW9uS2V5cywgbG9jYWxlRGF0YSwgZ2V0RGVmYXVsdExvY2FsZSkge1xuICAgIHZhciBtYXRjaGVyID0gb3B0aW9ucy5sb2NhbGVNYXRjaGVyO1xuICAgIHZhciByO1xuICAgIGlmIChtYXRjaGVyID09PSAnbG9va3VwJykge1xuICAgICAgICByID0gKDAsIExvb2t1cE1hdGNoZXJfMS5Mb29rdXBNYXRjaGVyKShhdmFpbGFibGVMb2NhbGVzLCByZXF1ZXN0ZWRMb2NhbGVzLCBnZXREZWZhdWx0TG9jYWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHIgPSAoMCwgQmVzdEZpdE1hdGNoZXJfMS5CZXN0Rml0TWF0Y2hlcikoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgZ2V0RGVmYXVsdExvY2FsZSk7XG4gICAgfVxuICAgIHZhciBmb3VuZExvY2FsZSA9IHIubG9jYWxlO1xuICAgIHZhciByZXN1bHQgPSB7IGxvY2FsZTogJycsIGRhdGFMb2NhbGU6IGZvdW5kTG9jYWxlIH07XG4gICAgdmFyIHN1cHBvcnRlZEV4dGVuc2lvbiA9ICctdSc7XG4gICAgZm9yICh2YXIgX2kgPSAwLCByZWxldmFudEV4dGVuc2lvbktleXNfMSA9IHJlbGV2YW50RXh0ZW5zaW9uS2V5czsgX2kgPCByZWxldmFudEV4dGVuc2lvbktleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHJlbGV2YW50RXh0ZW5zaW9uS2V5c18xW19pXTtcbiAgICAgICAgKDAsIHV0aWxzXzEuaW52YXJpYW50KShmb3VuZExvY2FsZSBpbiBsb2NhbGVEYXRhLCBcIk1pc3NpbmcgbG9jYWxlIGRhdGEgZm9yIFwiLmNvbmNhdChmb3VuZExvY2FsZSkpO1xuICAgICAgICB2YXIgZm91bmRMb2NhbGVEYXRhID0gbG9jYWxlRGF0YVtmb3VuZExvY2FsZV07XG4gICAgICAgICgwLCB1dGlsc18xLmludmFyaWFudCkodHlwZW9mIGZvdW5kTG9jYWxlRGF0YSA9PT0gJ29iamVjdCcgJiYgZm91bmRMb2NhbGVEYXRhICE9PSBudWxsLCBcImxvY2FsZSBkYXRhIFwiLmNvbmNhdChrZXksIFwiIG11c3QgYmUgYW4gb2JqZWN0XCIpKTtcbiAgICAgICAgdmFyIGtleUxvY2FsZURhdGEgPSBmb3VuZExvY2FsZURhdGFba2V5XTtcbiAgICAgICAgKDAsIHV0aWxzXzEuaW52YXJpYW50KShBcnJheS5pc0FycmF5KGtleUxvY2FsZURhdGEpLCBcImtleUxvY2FsZURhdGEgZm9yIFwiLmNvbmNhdChrZXksIFwiIG11c3QgYmUgYW4gYXJyYXlcIikpO1xuICAgICAgICB2YXIgdmFsdWUgPSBrZXlMb2NhbGVEYXRhWzBdO1xuICAgICAgICAoMCwgdXRpbHNfMS5pbnZhcmlhbnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgPT09IG51bGwsIFwidmFsdWUgbXVzdCBiZSBzdHJpbmcgb3IgbnVsbCBidXQgZ290IFwiLmNvbmNhdCh0eXBlb2YgdmFsdWUsIFwiIGluIGtleSBcIikuY29uY2F0KGtleSkpO1xuICAgICAgICB2YXIgc3VwcG9ydGVkRXh0ZW5zaW9uQWRkaXRpb24gPSAnJztcbiAgICAgICAgaWYgKHIuZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdGVkVmFsdWUgPSAoMCwgVW5pY29kZUV4dGVuc2lvblZhbHVlXzEuVW5pY29kZUV4dGVuc2lvblZhbHVlKShyLmV4dGVuc2lvbiwga2V5KTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAofmtleUxvY2FsZURhdGEuaW5kZXhPZihyZXF1ZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVxdWVzdGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRFeHRlbnNpb25BZGRpdGlvbiA9IFwiLVwiLmNvbmNhdChrZXksIFwiLVwiKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKH5yZXF1ZXN0ZWRWYWx1ZS5pbmRleE9mKCd0cnVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZEV4dGVuc2lvbkFkZGl0aW9uID0gXCItXCIuY29uY2F0KGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnNWYWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmludmFyaWFudCkodHlwZW9mIG9wdGlvbnNWYWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9uc1ZhbHVlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnNWYWx1ZSA9PT0gbnVsbCwgJ29wdGlvbnNWYWx1ZSBtdXN0IGJlIFN0cmluZywgVW5kZWZpbmVkIG9yIE51bGwnKTtcbiAgICAgICAgICAgIGlmICh+a2V5TG9jYWxlRGF0YS5pbmRleE9mKG9wdGlvbnNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkRXh0ZW5zaW9uQWRkaXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgc3VwcG9ydGVkRXh0ZW5zaW9uICs9IHN1cHBvcnRlZEV4dGVuc2lvbkFkZGl0aW9uO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydGVkRXh0ZW5zaW9uLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdmFyIHByaXZhdGVJbmRleCA9IGZvdW5kTG9jYWxlLmluZGV4T2YoJy14LScpO1xuICAgICAgICBpZiAocHJpdmF0ZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgZm91bmRMb2NhbGUgPSBmb3VuZExvY2FsZSArIHN1cHBvcnRlZEV4dGVuc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVFeHRlbnNpb24gPSBmb3VuZExvY2FsZS5zbGljZSgwLCBwcml2YXRlSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHBvc3RFeHRlbnNpb24gPSBmb3VuZExvY2FsZS5zbGljZShwcml2YXRlSW5kZXgsIGZvdW5kTG9jYWxlLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3VuZExvY2FsZSA9IHByZUV4dGVuc2lvbiArIHN1cHBvcnRlZEV4dGVuc2lvbiArIHBvc3RFeHRlbnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRMb2NhbGUgPSBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMoZm91bmRMb2NhbGUpWzBdO1xuICAgIH1cbiAgICByZXN1bHQubG9jYWxlID0gZm91bmRMb2NhbGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuUmVzb2x2ZUxvY2FsZSA9IFJlc29sdmVMb2NhbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/ResolveLocale.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/UnicodeExtensionValue.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/UnicodeExtensionValue.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.UnicodeExtensionValue = void 0;\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-localematcher/abstract/utils.js\");\n/**\n * https://tc39.es/ecma402/#sec-unicodeextensionvalue\n * @param extension\n * @param key\n */\n\n\nfunction UnicodeExtensionValue(extension, key) {\n  (0, utils_1.invariant)(key.length === 2, 'key must have 2 elements');\n  var size = extension.length;\n  var searchValue = \"-\".concat(key, \"-\");\n  var pos = extension.indexOf(searchValue);\n\n  if (pos !== -1) {\n    var start = pos + 4;\n    var end = start;\n    var k = start;\n    var done = false;\n\n    while (!done) {\n      var e = extension.indexOf('-', k);\n      var len = void 0;\n\n      if (e === -1) {\n        len = size - k;\n      } else {\n        len = e - k;\n      }\n\n      if (len === 2) {\n        done = true;\n      } else if (e === -1) {\n        end = size;\n        done = true;\n      } else {\n        end = e;\n        k = e + 1;\n      }\n    }\n\n    return extension.slice(start, end);\n  }\n\n  searchValue = \"-\".concat(key);\n  pos = extension.indexOf(searchValue);\n\n  if (pos !== -1 && pos + 3 === size) {\n    return '';\n  }\n\n  return undefined;\n}\n\nexports.UnicodeExtensionValue = UnicodeExtensionValue;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC9Vbmljb2RlRXh0ZW5zaW9uVmFsdWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2Fic3RyYWN0L1VuaWNvZGVFeHRlbnNpb25WYWx1ZS5qcz84ZjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vbmljb2RlRXh0ZW5zaW9uVmFsdWUgPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLXVuaWNvZGVleHRlbnNpb252YWx1ZVxuICogQHBhcmFtIGV4dGVuc2lvblxuICogQHBhcmFtIGtleVxuICovXG5mdW5jdGlvbiBVbmljb2RlRXh0ZW5zaW9uVmFsdWUoZXh0ZW5zaW9uLCBrZXkpIHtcbiAgICAoMCwgdXRpbHNfMS5pbnZhcmlhbnQpKGtleS5sZW5ndGggPT09IDIsICdrZXkgbXVzdCBoYXZlIDIgZWxlbWVudHMnKTtcbiAgICB2YXIgc2l6ZSA9IGV4dGVuc2lvbi5sZW5ndGg7XG4gICAgdmFyIHNlYXJjaFZhbHVlID0gXCItXCIuY29uY2F0KGtleSwgXCItXCIpO1xuICAgIHZhciBwb3MgPSBleHRlbnNpb24uaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zICsgNDtcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0O1xuICAgICAgICB2YXIgayA9IHN0YXJ0O1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXh0ZW5zaW9uLmluZGV4T2YoJy0nLCBrKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBzaXplIC0gaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlbiA9IGUgLSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzaXplO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kID0gZTtcbiAgICAgICAgICAgICAgICBrID0gZSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgc2VhcmNoVmFsdWUgPSBcIi1cIi5jb25jYXQoa2V5KTtcbiAgICBwb3MgPSBleHRlbnNpb24uaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gICAgaWYgKHBvcyAhPT0gLTEgJiYgcG9zICsgMyA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLlVuaWNvZGVFeHRlbnNpb25WYWx1ZSA9IFVuaWNvZGVFeHRlbnNpb25WYWx1ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/UnicodeExtensionValue.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/abstract/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/abstract/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.invariant = exports.UNICODE_EXTENSION_SEQUENCE_REGEX = void 0;\nexports.UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;\n\nfunction invariant(condition, message, Err) {\n  if (Err === void 0) {\n    Err = Error;\n  }\n\n  if (!condition) {\n    throw new Err(message);\n  }\n}\n\nexports.invariant = invariant;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9hYnN0cmFjdC91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2Fic3RyYWN0L3V0aWxzLmpzPzE2ODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludmFyaWFudCA9IGV4cG9ydHMuVU5JQ09ERV9FWFRFTlNJT05fU0VRVUVOQ0VfUkVHRVggPSB2b2lkIDA7XG5leHBvcnRzLlVOSUNPREVfRVhURU5TSU9OX1NFUVVFTkNFX1JFR0VYID0gLy11KD86LVswLTlhLXpdezIsOH0pKy9naTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UsIEVycikge1xuICAgIGlmIChFcnIgPT09IHZvaWQgMCkgeyBFcnIgPSBFcnJvcjsgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnIobWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5pbnZhcmlhbnQgPSBpbnZhcmlhbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/abstract/utils.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-localematcher/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@formatjs/intl-localematcher/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ResolveLocale = exports.LookupSupportedLocales = exports.match = void 0;\n\nvar CanonicalizeLocaleList_1 = __webpack_require__(/*! ./abstract/CanonicalizeLocaleList */ \"./node_modules/@formatjs/intl-localematcher/abstract/CanonicalizeLocaleList.js\");\n\nvar ResolveLocale_1 = __webpack_require__(/*! ./abstract/ResolveLocale */ \"./node_modules/@formatjs/intl-localematcher/abstract/ResolveLocale.js\");\n\nfunction match(requestedLocales, availableLocales, defaultLocale, opts) {\n  var locales = availableLocales.reduce(function (all, l) {\n    all.add(l);\n    return all;\n  }, new Set());\n  return (0, ResolveLocale_1.ResolveLocale)(locales, (0, CanonicalizeLocaleList_1.CanonicalizeLocaleList)(requestedLocales), {\n    localeMatcher: (opts === null || opts === void 0 ? void 0 : opts.algorithm) || 'best fit'\n  }, [], {}, function () {\n    return defaultLocale;\n  }).locale;\n}\n\nexports.match = match;\n\nvar LookupSupportedLocales_1 = __webpack_require__(/*! ./abstract/LookupSupportedLocales */ \"./node_modules/@formatjs/intl-localematcher/abstract/LookupSupportedLocales.js\");\n\nObject.defineProperty(exports, \"LookupSupportedLocales\", ({\n  enumerable: true,\n  get: function () {\n    return LookupSupportedLocales_1.LookupSupportedLocales;\n  }\n}));\n\nvar ResolveLocale_2 = __webpack_require__(/*! ./abstract/ResolveLocale */ \"./node_modules/@formatjs/intl-localematcher/abstract/ResolveLocale.js\");\n\nObject.defineProperty(exports, \"ResolveLocale\", ({\n  enumerable: true,\n  get: function () {\n    return ResolveLocale_2.ResolveLocale;\n  }\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvaW5kZXguanM/NWI3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2ZUxvY2FsZSA9IGV4cG9ydHMuTG9va3VwU3VwcG9ydGVkTG9jYWxlcyA9IGV4cG9ydHMubWF0Y2ggPSB2b2lkIDA7XG52YXIgQ2Fub25pY2FsaXplTG9jYWxlTGlzdF8xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvQ2Fub25pY2FsaXplTG9jYWxlTGlzdFwiKTtcbnZhciBSZXNvbHZlTG9jYWxlXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9SZXNvbHZlTG9jYWxlXCIpO1xuZnVuY3Rpb24gbWF0Y2gocmVxdWVzdGVkTG9jYWxlcywgYXZhaWxhYmxlTG9jYWxlcywgZGVmYXVsdExvY2FsZSwgb3B0cykge1xuICAgIHZhciBsb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgbCkge1xuICAgICAgICBhbGwuYWRkKGwpO1xuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgcmV0dXJuICgwLCBSZXNvbHZlTG9jYWxlXzEuUmVzb2x2ZUxvY2FsZSkobG9jYWxlcywgKDAsIENhbm9uaWNhbGl6ZUxvY2FsZUxpc3RfMS5DYW5vbmljYWxpemVMb2NhbGVMaXN0KShyZXF1ZXN0ZWRMb2NhbGVzKSwge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmFsZ29yaXRobSkgfHwgJ2Jlc3QgZml0JyxcbiAgICB9LCBbXSwge30sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZmF1bHRMb2NhbGU7IH0pLmxvY2FsZTtcbn1cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbnZhciBMb29rdXBTdXBwb3J0ZWRMb2NhbGVzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9Mb29rdXBTdXBwb3J0ZWRMb2NhbGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9va3VwU3VwcG9ydGVkTG9jYWxlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTG9va3VwU3VwcG9ydGVkTG9jYWxlc18xLkxvb2t1cFN1cHBvcnRlZExvY2FsZXM7IH0gfSk7XG52YXIgUmVzb2x2ZUxvY2FsZV8yID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvUmVzb2x2ZUxvY2FsZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc29sdmVMb2NhbGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlc29sdmVMb2NhbGVfMi5SZXNvbHZlTG9jYWxlOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-localematcher/index.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/lib/should-polyfill.js":
/*!************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/lib/should-polyfill.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shouldPolyfill\": () => (/* binding */ shouldPolyfill)\n/* harmony export */ });\n/* harmony import */ var _formatjs_intl_localematcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formatjs/intl-localematcher */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/index.js\");\n/* harmony import */ var _supported_locales__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./supported-locales */ \"./node_modules/@formatjs/intl-pluralrules/lib/supported-locales.js\");\n\n\n\nfunction supportedLocalesOf(locale) {\n  if (!locale) {\n    return true;\n  }\n\n  var locales = Array.isArray(locale) ? locale : [locale];\n  return Intl.PluralRules.supportedLocalesOf(locales).length === locales.length;\n}\n\nfunction shouldPolyfill(locale) {\n  if (locale === void 0) {\n    locale = 'en';\n  }\n\n  if (!('PluralRules' in Intl) || new Intl.PluralRules('en', {\n    minimumFractionDigits: 2\n  }).select(1) === 'one' || !supportedLocalesOf(locale)) {\n    return locale ? (0,_formatjs_intl_localematcher__WEBPACK_IMPORTED_MODULE_0__.match)([locale], _supported_locales__WEBPACK_IMPORTED_MODULE_1__.supportedLocales, 'en') : undefined;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbGliL3Nob3VsZC1wb2x5ZmlsbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLXBsdXJhbHJ1bGVzL2xpYi9zaG91bGQtcG9seWZpbGwuanM/Y2EyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXRjaCB9IGZyb20gJ0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXInO1xuaW1wb3J0IHsgc3VwcG9ydGVkTG9jYWxlcyB9IGZyb20gJy4vc3VwcG9ydGVkLWxvY2FsZXMnO1xuZnVuY3Rpb24gc3VwcG9ydGVkTG9jYWxlc09mKGxvY2FsZSkge1xuICAgIGlmICghbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbG9jYWxlcyA9IEFycmF5LmlzQXJyYXkobG9jYWxlKSA/IGxvY2FsZSA6IFtsb2NhbGVdO1xuICAgIHJldHVybiBJbnRsLlBsdXJhbFJ1bGVzLnN1cHBvcnRlZExvY2FsZXNPZihsb2NhbGVzKS5sZW5ndGggPT09IGxvY2FsZXMubGVuZ3RoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFBvbHlmaWxsKGxvY2FsZSkge1xuICAgIGlmIChsb2NhbGUgPT09IHZvaWQgMCkgeyBsb2NhbGUgPSAnZW4nOyB9XG4gICAgaWYgKCEoJ1BsdXJhbFJ1bGVzJyBpbiBJbnRsKSB8fFxuICAgICAgICBuZXcgSW50bC5QbHVyYWxSdWxlcygnZW4nLCB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMiB9KS5zZWxlY3QoMSkgPT09XG4gICAgICAgICAgICAnb25lJyB8fFxuICAgICAgICAhc3VwcG9ydGVkTG9jYWxlc09mKGxvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZSA/IG1hdGNoKFtsb2NhbGVdLCBzdXBwb3J0ZWRMb2NhbGVzLCAnZW4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/lib/should-polyfill.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/lib/supported-locales.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/lib/supported-locales.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"supportedLocales\": () => (/* binding */ supportedLocales)\n/* harmony export */ });\n// This file is generated from supported-locales-gen.ts\nvar supportedLocales = [\"af\", \"ak\", \"am\", \"an\", \"ar\", \"ars\", \"as\", \"asa\", \"ast\", \"az\", \"bal\", \"be\", \"bem\", \"bez\", \"bg\", \"bho\", \"bm\", \"bn\", \"bo\", \"br\", \"brx\", \"bs\", \"ca\", \"ce\", \"ceb\", \"cgg\", \"chr\", \"ckb\", \"cs\", \"cy\", \"da\", \"de\", \"doi\", \"dsb\", \"dv\", \"dz\", \"ee\", \"el\", \"en\", \"eo\", \"es\", \"et\", \"eu\", \"fa\", \"ff\", \"fi\", \"fil\", \"fo\", \"fr\", \"fur\", \"fy\", \"ga\", \"gd\", \"gl\", \"gsw\", \"gu\", \"guw\", \"gv\", \"ha\", \"haw\", \"he\", \"hi\", \"hnj\", \"hr\", \"hsb\", \"hu\", \"hy\", \"ia\", \"id\", \"ig\", \"ii\", \"io\", \"is\", \"it\", \"iu\", \"ja\", \"jbo\", \"jgo\", \"jmc\", \"jv\", \"jw\", \"ka\", \"kab\", \"kaj\", \"kcg\", \"kde\", \"kea\", \"kk\", \"kkj\", \"kl\", \"km\", \"kn\", \"ko\", \"ks\", \"ksb\", \"ksh\", \"ku\", \"kw\", \"ky\", \"lag\", \"lb\", \"lg\", \"lij\", \"lkt\", \"ln\", \"lo\", \"lt\", \"lv\", \"mas\", \"mg\", \"mgo\", \"mk\", \"ml\", \"mn\", \"mo\", \"mr\", \"ms\", \"mt\", \"my\", \"nah\", \"naq\", \"nb\", \"nd\", \"ne\", \"nl\", \"nn\", \"nnh\", \"no\", \"nqo\", \"nr\", \"nso\", \"ny\", \"nyn\", \"om\", \"or\", \"os\", \"osa\", \"pa\", \"pap\", \"pcm\", \"pl\", \"prg\", \"ps\", \"pt-PT\", \"pt\", \"rm\", \"ro\", \"rof\", \"ru\", \"rwk\", \"sah\", \"saq\", \"sat\", \"sc\", \"scn\", \"sd\", \"sdh\", \"se\", \"seh\", \"ses\", \"sg\", \"sh\", \"shi\", \"si\", \"sk\", \"sl\", \"sma\", \"smi\", \"smj\", \"smn\", \"sms\", \"sn\", \"so\", \"sq\", \"sr\", \"ss\", \"ssy\", \"st\", \"su\", \"sv\", \"sw\", \"syr\", \"ta\", \"te\", \"teo\", \"th\", \"ti\", \"tig\", \"tk\", \"tl\", \"tn\", \"to\", \"tpi\", \"tr\", \"ts\", \"tzm\", \"ug\", \"uk\", \"und\", \"ur\", \"uz\", \"ve\", \"vi\", \"vo\", \"vun\", \"wa\", \"wae\", \"wo\", \"xh\", \"xog\", \"yi\", \"yo\", \"yue\", \"zh\", \"zu\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbGliL3N1cHBvcnRlZC1sb2NhbGVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1wbHVyYWxydWxlcy9saWIvc3VwcG9ydGVkLWxvY2FsZXMuanM/NDI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gc3VwcG9ydGVkLWxvY2FsZXMtZ2VuLnRzXG5leHBvcnQgdmFyIHN1cHBvcnRlZExvY2FsZXMgPSBbXCJhZlwiLCBcImFrXCIsIFwiYW1cIiwgXCJhblwiLCBcImFyXCIsIFwiYXJzXCIsIFwiYXNcIiwgXCJhc2FcIiwgXCJhc3RcIiwgXCJhelwiLCBcImJhbFwiLCBcImJlXCIsIFwiYmVtXCIsIFwiYmV6XCIsIFwiYmdcIiwgXCJiaG9cIiwgXCJibVwiLCBcImJuXCIsIFwiYm9cIiwgXCJiclwiLCBcImJyeFwiLCBcImJzXCIsIFwiY2FcIiwgXCJjZVwiLCBcImNlYlwiLCBcImNnZ1wiLCBcImNoclwiLCBcImNrYlwiLCBcImNzXCIsIFwiY3lcIiwgXCJkYVwiLCBcImRlXCIsIFwiZG9pXCIsIFwiZHNiXCIsIFwiZHZcIiwgXCJkelwiLCBcImVlXCIsIFwiZWxcIiwgXCJlblwiLCBcImVvXCIsIFwiZXNcIiwgXCJldFwiLCBcImV1XCIsIFwiZmFcIiwgXCJmZlwiLCBcImZpXCIsIFwiZmlsXCIsIFwiZm9cIiwgXCJmclwiLCBcImZ1clwiLCBcImZ5XCIsIFwiZ2FcIiwgXCJnZFwiLCBcImdsXCIsIFwiZ3N3XCIsIFwiZ3VcIiwgXCJndXdcIiwgXCJndlwiLCBcImhhXCIsIFwiaGF3XCIsIFwiaGVcIiwgXCJoaVwiLCBcImhualwiLCBcImhyXCIsIFwiaHNiXCIsIFwiaHVcIiwgXCJoeVwiLCBcImlhXCIsIFwiaWRcIiwgXCJpZ1wiLCBcImlpXCIsIFwiaW9cIiwgXCJpc1wiLCBcIml0XCIsIFwiaXVcIiwgXCJqYVwiLCBcImpib1wiLCBcImpnb1wiLCBcImptY1wiLCBcImp2XCIsIFwiandcIiwgXCJrYVwiLCBcImthYlwiLCBcImthalwiLCBcImtjZ1wiLCBcImtkZVwiLCBcImtlYVwiLCBcImtrXCIsIFwia2tqXCIsIFwia2xcIiwgXCJrbVwiLCBcImtuXCIsIFwia29cIiwgXCJrc1wiLCBcImtzYlwiLCBcImtzaFwiLCBcImt1XCIsIFwia3dcIiwgXCJreVwiLCBcImxhZ1wiLCBcImxiXCIsIFwibGdcIiwgXCJsaWpcIiwgXCJsa3RcIiwgXCJsblwiLCBcImxvXCIsIFwibHRcIiwgXCJsdlwiLCBcIm1hc1wiLCBcIm1nXCIsIFwibWdvXCIsIFwibWtcIiwgXCJtbFwiLCBcIm1uXCIsIFwibW9cIiwgXCJtclwiLCBcIm1zXCIsIFwibXRcIiwgXCJteVwiLCBcIm5haFwiLCBcIm5hcVwiLCBcIm5iXCIsIFwibmRcIiwgXCJuZVwiLCBcIm5sXCIsIFwibm5cIiwgXCJubmhcIiwgXCJub1wiLCBcIm5xb1wiLCBcIm5yXCIsIFwibnNvXCIsIFwibnlcIiwgXCJueW5cIiwgXCJvbVwiLCBcIm9yXCIsIFwib3NcIiwgXCJvc2FcIiwgXCJwYVwiLCBcInBhcFwiLCBcInBjbVwiLCBcInBsXCIsIFwicHJnXCIsIFwicHNcIiwgXCJwdC1QVFwiLCBcInB0XCIsIFwicm1cIiwgXCJyb1wiLCBcInJvZlwiLCBcInJ1XCIsIFwicndrXCIsIFwic2FoXCIsIFwic2FxXCIsIFwic2F0XCIsIFwic2NcIiwgXCJzY25cIiwgXCJzZFwiLCBcInNkaFwiLCBcInNlXCIsIFwic2VoXCIsIFwic2VzXCIsIFwic2dcIiwgXCJzaFwiLCBcInNoaVwiLCBcInNpXCIsIFwic2tcIiwgXCJzbFwiLCBcInNtYVwiLCBcInNtaVwiLCBcInNtalwiLCBcInNtblwiLCBcInNtc1wiLCBcInNuXCIsIFwic29cIiwgXCJzcVwiLCBcInNyXCIsIFwic3NcIiwgXCJzc3lcIiwgXCJzdFwiLCBcInN1XCIsIFwic3ZcIiwgXCJzd1wiLCBcInN5clwiLCBcInRhXCIsIFwidGVcIiwgXCJ0ZW9cIiwgXCJ0aFwiLCBcInRpXCIsIFwidGlnXCIsIFwidGtcIiwgXCJ0bFwiLCBcInRuXCIsIFwidG9cIiwgXCJ0cGlcIiwgXCJ0clwiLCBcInRzXCIsIFwidHptXCIsIFwidWdcIiwgXCJ1a1wiLCBcInVuZFwiLCBcInVyXCIsIFwidXpcIiwgXCJ2ZVwiLCBcInZpXCIsIFwidm9cIiwgXCJ2dW5cIiwgXCJ3YVwiLCBcIndhZVwiLCBcIndvXCIsIFwieGhcIiwgXCJ4b2dcIiwgXCJ5aVwiLCBcInlvXCIsIFwieXVlXCIsIFwiemhcIiwgXCJ6dVwiXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/lib/supported-locales.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestAvailableLocale.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestAvailableLocale.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BestAvailableLocale\": () => (/* binding */ BestAvailableLocale)\n/* harmony export */ });\n/**\n * https://tc39.es/ecma402/#sec-bestavailablelocale\n * @param availableLocales\n * @param locale\n */\nfunction BestAvailableLocale(availableLocales, locale) {\n  var candidate = locale;\n\n  while (true) {\n    if (availableLocales.has(candidate)) {\n      return candidate;\n    }\n\n    var pos = candidate.lastIndexOf('-');\n\n    if (!~pos) {\n      return undefined;\n    }\n\n    if (pos >= 2 && candidate[pos - 2] === '-') {\n      pos -= 2;\n    }\n\n    candidate = candidate.slice(0, pos);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L0Jlc3RBdmFpbGFibGVMb2NhbGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1wbHVyYWxydWxlcy9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9saWIvYWJzdHJhY3QvQmVzdEF2YWlsYWJsZUxvY2FsZS5qcz9iYTA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1iZXN0YXZhaWxhYmxlbG9jYWxlXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIGxvY2FsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQmVzdEF2YWlsYWJsZUxvY2FsZShhdmFpbGFibGVMb2NhbGVzLCBsb2NhbGUpIHtcbiAgICB2YXIgY2FuZGlkYXRlID0gbG9jYWxlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChhdmFpbGFibGVMb2NhbGVzLmhhcyhjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3MgPSBjYW5kaWRhdGUubGFzdEluZGV4T2YoJy0nKTtcbiAgICAgICAgaWYgKCF+cG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gMiAmJiBjYW5kaWRhdGVbcG9zIC0gMl0gPT09ICctJykge1xuICAgICAgICAgICAgcG9zIC09IDI7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlLnNsaWNlKDAsIHBvcyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestAvailableLocale.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestFitMatcher.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestFitMatcher.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BestFitMatcher\": () => (/* binding */ BestFitMatcher)\n/* harmony export */ });\n/* harmony import */ var _BestAvailableLocale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BestAvailableLocale */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestAvailableLocale.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js\");\n\n\n/**\n * https://tc39.es/ecma402/#sec-bestfitmatcher\n * @param availableLocales\n * @param requestedLocales\n * @param getDefaultLocale\n */\n\nfunction BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale) {\n  var minimizedAvailableLocaleMap = {};\n  var availableLocaleMap = {};\n  var canonicalizedLocaleMap = {};\n  var minimizedAvailableLocales = new Set();\n  availableLocales.forEach(function (locale) {\n    var minimizedLocale = new Intl.Locale(locale).minimize().toString();\n    var canonicalizedLocale = Intl.getCanonicalLocales(locale)[0] || locale;\n    minimizedAvailableLocaleMap[minimizedLocale] = locale;\n    availableLocaleMap[locale] = locale;\n    canonicalizedLocaleMap[canonicalizedLocale] = locale;\n    minimizedAvailableLocales.add(minimizedLocale);\n    minimizedAvailableLocales.add(locale);\n    minimizedAvailableLocales.add(canonicalizedLocale);\n  });\n  var foundLocale;\n\n  for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {\n    var l = requestedLocales_1[_i];\n\n    if (foundLocale) {\n      break;\n    }\n\n    var noExtensionLocale = l.replace(_utils__WEBPACK_IMPORTED_MODULE_1__.UNICODE_EXTENSION_SEQUENCE_REGEX, '');\n\n    if (availableLocales.has(noExtensionLocale)) {\n      foundLocale = noExtensionLocale;\n      break;\n    }\n\n    if (minimizedAvailableLocales.has(noExtensionLocale)) {\n      foundLocale = noExtensionLocale;\n      break;\n    }\n\n    var locale = new Intl.Locale(noExtensionLocale);\n    var maximizedRequestedLocale = locale.maximize().toString();\n    var minimizedRequestedLocale = locale.minimize().toString(); // Check minimized locale\n\n    if (minimizedAvailableLocales.has(minimizedRequestedLocale)) {\n      foundLocale = minimizedRequestedLocale;\n      break;\n    } // Lookup algo on maximized locale\n\n\n    foundLocale = (0,_BestAvailableLocale__WEBPACK_IMPORTED_MODULE_0__.BestAvailableLocale)(minimizedAvailableLocales, maximizedRequestedLocale);\n  }\n\n  if (!foundLocale) {\n    return {\n      locale: getDefaultLocale()\n    };\n  }\n\n  return {\n    locale: availableLocaleMap[foundLocale] || canonicalizedLocaleMap[foundLocale] || minimizedAvailableLocaleMap[foundLocale] || foundLocale\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L0Jlc3RGaXRNYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBO0FBTUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLXBsdXJhbHJ1bGVzL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2xpYi9hYnN0cmFjdC9CZXN0Rml0TWF0Y2hlci5qcz8xZDM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJlc3RBdmFpbGFibGVMb2NhbGUgfSBmcm9tICcuL0Jlc3RBdmFpbGFibGVMb2NhbGUnO1xuaW1wb3J0IHsgVU5JQ09ERV9FWFRFTlNJT05fU0VRVUVOQ0VfUkVHRVggfSBmcm9tICcuL3V0aWxzJztcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1iZXN0Zml0bWF0Y2hlclxuICogQHBhcmFtIGF2YWlsYWJsZUxvY2FsZXNcbiAqIEBwYXJhbSByZXF1ZXN0ZWRMb2NhbGVzXG4gKiBAcGFyYW0gZ2V0RGVmYXVsdExvY2FsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gQmVzdEZpdE1hdGNoZXIoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgZ2V0RGVmYXVsdExvY2FsZSkge1xuICAgIHZhciBtaW5pbWl6ZWRBdmFpbGFibGVMb2NhbGVNYXAgPSB7fTtcbiAgICB2YXIgYXZhaWxhYmxlTG9jYWxlTWFwID0ge307XG4gICAgdmFyIGNhbm9uaWNhbGl6ZWRMb2NhbGVNYXAgPSB7fTtcbiAgICB2YXIgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcyA9IG5ldyBTZXQoKTtcbiAgICBhdmFpbGFibGVMb2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgICAgICB2YXIgbWluaW1pemVkTG9jYWxlID0gbmV3IEludGwuTG9jYWxlKGxvY2FsZSlcbiAgICAgICAgICAgIC5taW5pbWl6ZSgpXG4gICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNhbm9uaWNhbGl6ZWRMb2NhbGUgPSBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMobG9jYWxlKVswXSB8fCBsb2NhbGU7XG4gICAgICAgIG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZU1hcFttaW5pbWl6ZWRMb2NhbGVdID0gbG9jYWxlO1xuICAgICAgICBhdmFpbGFibGVMb2NhbGVNYXBbbG9jYWxlXSA9IGxvY2FsZTtcbiAgICAgICAgY2Fub25pY2FsaXplZExvY2FsZU1hcFtjYW5vbmljYWxpemVkTG9jYWxlXSA9IGxvY2FsZTtcbiAgICAgICAgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcy5hZGQobWluaW1pemVkTG9jYWxlKTtcbiAgICAgICAgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcy5hZGQobG9jYWxlKTtcbiAgICAgICAgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlcy5hZGQoY2Fub25pY2FsaXplZExvY2FsZSk7XG4gICAgfSk7XG4gICAgdmFyIGZvdW5kTG9jYWxlO1xuICAgIGZvciAodmFyIF9pID0gMCwgcmVxdWVzdGVkTG9jYWxlc18xID0gcmVxdWVzdGVkTG9jYWxlczsgX2kgPCByZXF1ZXN0ZWRMb2NhbGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBsID0gcmVxdWVzdGVkTG9jYWxlc18xW19pXTtcbiAgICAgICAgaWYgKGZvdW5kTG9jYWxlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9FeHRlbnNpb25Mb2NhbGUgPSBsLnJlcGxhY2UoVU5JQ09ERV9FWFRFTlNJT05fU0VRVUVOQ0VfUkVHRVgsICcnKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZXMuaGFzKG5vRXh0ZW5zaW9uTG9jYWxlKSkge1xuICAgICAgICAgICAgZm91bmRMb2NhbGUgPSBub0V4dGVuc2lvbkxvY2FsZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5pbWl6ZWRBdmFpbGFibGVMb2NhbGVzLmhhcyhub0V4dGVuc2lvbkxvY2FsZSkpIHtcbiAgICAgICAgICAgIGZvdW5kTG9jYWxlID0gbm9FeHRlbnNpb25Mb2NhbGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9jYWxlID0gbmV3IEludGwuTG9jYWxlKG5vRXh0ZW5zaW9uTG9jYWxlKTtcbiAgICAgICAgdmFyIG1heGltaXplZFJlcXVlc3RlZExvY2FsZSA9IGxvY2FsZS5tYXhpbWl6ZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBtaW5pbWl6ZWRSZXF1ZXN0ZWRMb2NhbGUgPSBsb2NhbGUubWluaW1pemUoKS50b1N0cmluZygpO1xuICAgICAgICAvLyBDaGVjayBtaW5pbWl6ZWQgbG9jYWxlXG4gICAgICAgIGlmIChtaW5pbWl6ZWRBdmFpbGFibGVMb2NhbGVzLmhhcyhtaW5pbWl6ZWRSZXF1ZXN0ZWRMb2NhbGUpKSB7XG4gICAgICAgICAgICBmb3VuZExvY2FsZSA9IG1pbmltaXplZFJlcXVlc3RlZExvY2FsZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2t1cCBhbGdvIG9uIG1heGltaXplZCBsb2NhbGVcbiAgICAgICAgZm91bmRMb2NhbGUgPSBCZXN0QXZhaWxhYmxlTG9jYWxlKG1pbmltaXplZEF2YWlsYWJsZUxvY2FsZXMsIG1heGltaXplZFJlcXVlc3RlZExvY2FsZSk7XG4gICAgfVxuICAgIGlmICghZm91bmRMb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIHsgbG9jYWxlOiBnZXREZWZhdWx0TG9jYWxlKCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYWxlOiBhdmFpbGFibGVMb2NhbGVNYXBbZm91bmRMb2NhbGVdIHx8XG4gICAgICAgICAgICBjYW5vbmljYWxpemVkTG9jYWxlTWFwW2ZvdW5kTG9jYWxlXSB8fFxuICAgICAgICAgICAgbWluaW1pemVkQXZhaWxhYmxlTG9jYWxlTWFwW2ZvdW5kTG9jYWxlXSB8fFxuICAgICAgICAgICAgZm91bmRMb2NhbGUsXG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestFitMatcher.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/CanonicalizeLocaleList.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/CanonicalizeLocaleList.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanonicalizeLocaleList\": () => (/* binding */ CanonicalizeLocaleList)\n/* harmony export */ });\n/**\n * http://ecma-international.org/ecma-402/7.0/index.html#sec-canonicalizelocalelist\n * @param locales\n */\nfunction CanonicalizeLocaleList(locales) {\n  // TODO\n  return Intl.getCanonicalLocales(locales);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L0Nhbm9uaWNhbGl6ZUxvY2FsZUxpc3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLXBsdXJhbHJ1bGVzL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2xpYi9hYnN0cmFjdC9DYW5vbmljYWxpemVMb2NhbGVMaXN0LmpzP2IyNGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTQwMi83LjAvaW5kZXguaHRtbCNzZWMtY2Fub25pY2FsaXplbG9jYWxlbGlzdFxuICogQHBhcmFtIGxvY2FsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENhbm9uaWNhbGl6ZUxvY2FsZUxpc3QobG9jYWxlcykge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gSW50bC5nZXRDYW5vbmljYWxMb2NhbGVzKGxvY2FsZXMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/CanonicalizeLocaleList.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupMatcher.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupMatcher.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LookupMatcher\": () => (/* binding */ LookupMatcher)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js\");\n/* harmony import */ var _BestAvailableLocale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BestAvailableLocale */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestAvailableLocale.js\");\n\n\n/**\n * https://tc39.es/ecma402/#sec-lookupmatcher\n * @param availableLocales\n * @param requestedLocales\n * @param getDefaultLocale\n */\n\nfunction LookupMatcher(availableLocales, requestedLocales, getDefaultLocale) {\n  var result = {\n    locale: ''\n  };\n\n  for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {\n    var locale = requestedLocales_1[_i];\n    var noExtensionLocale = locale.replace(_utils__WEBPACK_IMPORTED_MODULE_0__.UNICODE_EXTENSION_SEQUENCE_REGEX, '');\n    var availableLocale = (0,_BestAvailableLocale__WEBPACK_IMPORTED_MODULE_1__.BestAvailableLocale)(availableLocales, noExtensionLocale);\n\n    if (availableLocale) {\n      result.locale = availableLocale;\n\n      if (locale !== noExtensionLocale) {\n        result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);\n      }\n\n      return result;\n    }\n  }\n\n  result.locale = getDefaultLocale();\n  return result;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L0xvb2t1cE1hdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1wbHVyYWxydWxlcy9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9saWIvYWJzdHJhY3QvTG9va3VwTWF0Y2hlci5qcz80NzMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVOSUNPREVfRVhURU5TSU9OX1NFUVVFTkNFX1JFR0VYIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBCZXN0QXZhaWxhYmxlTG9jYWxlIH0gZnJvbSAnLi9CZXN0QXZhaWxhYmxlTG9jYWxlJztcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1sb29rdXBtYXRjaGVyXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIHJlcXVlc3RlZExvY2FsZXNcbiAqIEBwYXJhbSBnZXREZWZhdWx0TG9jYWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBMb29rdXBNYXRjaGVyKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIGdldERlZmF1bHRMb2NhbGUpIHtcbiAgICB2YXIgcmVzdWx0ID0geyBsb2NhbGU6ICcnIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCByZXF1ZXN0ZWRMb2NhbGVzXzEgPSByZXF1ZXN0ZWRMb2NhbGVzOyBfaSA8IHJlcXVlc3RlZExvY2FsZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHJlcXVlc3RlZExvY2FsZXNfMVtfaV07XG4gICAgICAgIHZhciBub0V4dGVuc2lvbkxvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKFVOSUNPREVfRVhURU5TSU9OX1NFUVVFTkNFX1JFR0VYLCAnJyk7XG4gICAgICAgIHZhciBhdmFpbGFibGVMb2NhbGUgPSBCZXN0QXZhaWxhYmxlTG9jYWxlKGF2YWlsYWJsZUxvY2FsZXMsIG5vRXh0ZW5zaW9uTG9jYWxlKTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZUxvY2FsZSkge1xuICAgICAgICAgICAgcmVzdWx0LmxvY2FsZSA9IGF2YWlsYWJsZUxvY2FsZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUgIT09IG5vRXh0ZW5zaW9uTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmV4dGVuc2lvbiA9IGxvY2FsZS5zbGljZShub0V4dGVuc2lvbkxvY2FsZS5sZW5ndGggKyAxLCBsb2NhbGUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LmxvY2FsZSA9IGdldERlZmF1bHRMb2NhbGUoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupMatcher.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupSupportedLocales.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupSupportedLocales.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LookupSupportedLocales\": () => (/* binding */ LookupSupportedLocales)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js\");\n/* harmony import */ var _BestAvailableLocale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BestAvailableLocale */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestAvailableLocale.js\");\n\n\n/**\n * https://tc39.es/ecma402/#sec-lookupsupportedlocales\n * @param availableLocales\n * @param requestedLocales\n */\n\nfunction LookupSupportedLocales(availableLocales, requestedLocales) {\n  var subset = [];\n\n  for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {\n    var locale = requestedLocales_1[_i];\n    var noExtensionLocale = locale.replace(_utils__WEBPACK_IMPORTED_MODULE_0__.UNICODE_EXTENSION_SEQUENCE_REGEX, '');\n    var availableLocale = (0,_BestAvailableLocale__WEBPACK_IMPORTED_MODULE_1__.BestAvailableLocale)(availableLocales, noExtensionLocale);\n\n    if (availableLocale) {\n      subset.push(availableLocale);\n    }\n  }\n\n  return subset;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L0xvb2t1cFN1cHBvcnRlZExvY2FsZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1wbHVyYWxydWxlcy9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9saWIvYWJzdHJhY3QvTG9va3VwU3VwcG9ydGVkTG9jYWxlcy5qcz9kYjIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVOSUNPREVfRVhURU5TSU9OX1NFUVVFTkNFX1JFR0VYIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBCZXN0QXZhaWxhYmxlTG9jYWxlIH0gZnJvbSAnLi9CZXN0QXZhaWxhYmxlTG9jYWxlJztcbi8qKlxuICogaHR0cHM6Ly90YzM5LmVzL2VjbWE0MDIvI3NlYy1sb29rdXBzdXBwb3J0ZWRsb2NhbGVzXG4gKiBAcGFyYW0gYXZhaWxhYmxlTG9jYWxlc1xuICogQHBhcmFtIHJlcXVlc3RlZExvY2FsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIExvb2t1cFN1cHBvcnRlZExvY2FsZXMoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcykge1xuICAgIHZhciBzdWJzZXQgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHJlcXVlc3RlZExvY2FsZXNfMSA9IHJlcXVlc3RlZExvY2FsZXM7IF9pIDwgcmVxdWVzdGVkTG9jYWxlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbG9jYWxlID0gcmVxdWVzdGVkTG9jYWxlc18xW19pXTtcbiAgICAgICAgdmFyIG5vRXh0ZW5zaW9uTG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoVU5JQ09ERV9FWFRFTlNJT05fU0VRVUVOQ0VfUkVHRVgsICcnKTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUxvY2FsZSA9IEJlc3RBdmFpbGFibGVMb2NhbGUoYXZhaWxhYmxlTG9jYWxlcywgbm9FeHRlbnNpb25Mb2NhbGUpO1xuICAgICAgICBpZiAoYXZhaWxhYmxlTG9jYWxlKSB7XG4gICAgICAgICAgICBzdWJzZXQucHVzaChhdmFpbGFibGVMb2NhbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzZXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupSupportedLocales.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/ResolveLocale.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/ResolveLocale.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ResolveLocale\": () => (/* binding */ ResolveLocale)\n/* harmony export */ });\n/* harmony import */ var _LookupMatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LookupMatcher */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupMatcher.js\");\n/* harmony import */ var _BestFitMatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BestFitMatcher */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/BestFitMatcher.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js\");\n/* harmony import */ var _UnicodeExtensionValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UnicodeExtensionValue */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/UnicodeExtensionValue.js\");\n\n\n\n\n/**\n * https://tc39.es/ecma402/#sec-resolvelocale\n */\n\nfunction ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData, getDefaultLocale) {\n  var matcher = options.localeMatcher;\n  var r;\n\n  if (matcher === 'lookup') {\n    r = (0,_LookupMatcher__WEBPACK_IMPORTED_MODULE_0__.LookupMatcher)(availableLocales, requestedLocales, getDefaultLocale);\n  } else {\n    r = (0,_BestFitMatcher__WEBPACK_IMPORTED_MODULE_1__.BestFitMatcher)(availableLocales, requestedLocales, getDefaultLocale);\n  }\n\n  var foundLocale = r.locale;\n  var result = {\n    locale: '',\n    dataLocale: foundLocale\n  };\n  var supportedExtension = '-u';\n\n  for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {\n    var key = relevantExtensionKeys_1[_i];\n    (0,_utils__WEBPACK_IMPORTED_MODULE_2__.invariant)(foundLocale in localeData, \"Missing locale data for \".concat(foundLocale));\n    var foundLocaleData = localeData[foundLocale];\n    (0,_utils__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof foundLocaleData === 'object' && foundLocaleData !== null, \"locale data \".concat(key, \" must be an object\"));\n    var keyLocaleData = foundLocaleData[key];\n    (0,_utils__WEBPACK_IMPORTED_MODULE_2__.invariant)(Array.isArray(keyLocaleData), \"keyLocaleData for \".concat(key, \" must be an array\"));\n    var value = keyLocaleData[0];\n    (0,_utils__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof value === 'string' || value === null, \"value must be string or null but got \".concat(typeof value, \" in key \").concat(key));\n    var supportedExtensionAddition = '';\n\n    if (r.extension) {\n      var requestedValue = (0,_UnicodeExtensionValue__WEBPACK_IMPORTED_MODULE_3__.UnicodeExtensionValue)(r.extension, key);\n\n      if (requestedValue !== undefined) {\n        if (requestedValue !== '') {\n          if (~keyLocaleData.indexOf(requestedValue)) {\n            value = requestedValue;\n            supportedExtensionAddition = \"-\".concat(key, \"-\").concat(value);\n          }\n        } else if (~requestedValue.indexOf('true')) {\n          value = 'true';\n          supportedExtensionAddition = \"-\".concat(key);\n        }\n      }\n    }\n\n    if (key in options) {\n      var optionsValue = options[key];\n      (0,_utils__WEBPACK_IMPORTED_MODULE_2__.invariant)(typeof optionsValue === 'string' || typeof optionsValue === 'undefined' || optionsValue === null, 'optionsValue must be String, Undefined or Null');\n\n      if (~keyLocaleData.indexOf(optionsValue)) {\n        if (optionsValue !== value) {\n          value = optionsValue;\n          supportedExtensionAddition = '';\n        }\n      }\n    }\n\n    result[key] = value;\n    supportedExtension += supportedExtensionAddition;\n  }\n\n  if (supportedExtension.length > 2) {\n    var privateIndex = foundLocale.indexOf('-x-');\n\n    if (privateIndex === -1) {\n      foundLocale = foundLocale + supportedExtension;\n    } else {\n      var preExtension = foundLocale.slice(0, privateIndex);\n      var postExtension = foundLocale.slice(privateIndex, foundLocale.length);\n      foundLocale = preExtension + supportedExtension + postExtension;\n    }\n\n    foundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n  }\n\n  result.locale = foundLocale;\n  return result;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L1Jlc29sdmVMb2NhbGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1wbHVyYWxydWxlcy9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9saWIvYWJzdHJhY3QvUmVzb2x2ZUxvY2FsZS5qcz9kOTY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvb2t1cE1hdGNoZXIgfSBmcm9tICcuL0xvb2t1cE1hdGNoZXInO1xuaW1wb3J0IHsgQmVzdEZpdE1hdGNoZXIgfSBmcm9tICcuL0Jlc3RGaXRNYXRjaGVyJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgVW5pY29kZUV4dGVuc2lvblZhbHVlIH0gZnJvbSAnLi9Vbmljb2RlRXh0ZW5zaW9uVmFsdWUnO1xuLyoqXG4gKiBodHRwczovL3RjMzkuZXMvZWNtYTQwMi8jc2VjLXJlc29sdmVsb2NhbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlc29sdmVMb2NhbGUoYXZhaWxhYmxlTG9jYWxlcywgcmVxdWVzdGVkTG9jYWxlcywgb3B0aW9ucywgcmVsZXZhbnRFeHRlbnNpb25LZXlzLCBsb2NhbGVEYXRhLCBnZXREZWZhdWx0TG9jYWxlKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBvcHRpb25zLmxvY2FsZU1hdGNoZXI7XG4gICAgdmFyIHI7XG4gICAgaWYgKG1hdGNoZXIgPT09ICdsb29rdXAnKSB7XG4gICAgICAgIHIgPSBMb29rdXBNYXRjaGVyKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIGdldERlZmF1bHRMb2NhbGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgciA9IEJlc3RGaXRNYXRjaGVyKGF2YWlsYWJsZUxvY2FsZXMsIHJlcXVlc3RlZExvY2FsZXMsIGdldERlZmF1bHRMb2NhbGUpO1xuICAgIH1cbiAgICB2YXIgZm91bmRMb2NhbGUgPSByLmxvY2FsZTtcbiAgICB2YXIgcmVzdWx0ID0geyBsb2NhbGU6ICcnLCBkYXRhTG9jYWxlOiBmb3VuZExvY2FsZSB9O1xuICAgIHZhciBzdXBwb3J0ZWRFeHRlbnNpb24gPSAnLXUnO1xuICAgIGZvciAodmFyIF9pID0gMCwgcmVsZXZhbnRFeHRlbnNpb25LZXlzXzEgPSByZWxldmFudEV4dGVuc2lvbktleXM7IF9pIDwgcmVsZXZhbnRFeHRlbnNpb25LZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSByZWxldmFudEV4dGVuc2lvbktleXNfMVtfaV07XG4gICAgICAgIGludmFyaWFudChmb3VuZExvY2FsZSBpbiBsb2NhbGVEYXRhLCBcIk1pc3NpbmcgbG9jYWxlIGRhdGEgZm9yIFwiLmNvbmNhdChmb3VuZExvY2FsZSkpO1xuICAgICAgICB2YXIgZm91bmRMb2NhbGVEYXRhID0gbG9jYWxlRGF0YVtmb3VuZExvY2FsZV07XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgZm91bmRMb2NhbGVEYXRhID09PSAnb2JqZWN0JyAmJiBmb3VuZExvY2FsZURhdGEgIT09IG51bGwsIFwibG9jYWxlIGRhdGEgXCIuY29uY2F0KGtleSwgXCIgbXVzdCBiZSBhbiBvYmplY3RcIikpO1xuICAgICAgICB2YXIga2V5TG9jYWxlRGF0YSA9IGZvdW5kTG9jYWxlRGF0YVtrZXldO1xuICAgICAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShrZXlMb2NhbGVEYXRhKSwgXCJrZXlMb2NhbGVEYXRhIGZvciBcIi5jb25jYXQoa2V5LCBcIiBtdXN0IGJlIGFuIGFycmF5XCIpKTtcbiAgICAgICAgdmFyIHZhbHVlID0ga2V5TG9jYWxlRGF0YVswXTtcbiAgICAgICAgaW52YXJpYW50KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgPT09IG51bGwsIFwidmFsdWUgbXVzdCBiZSBzdHJpbmcgb3IgbnVsbCBidXQgZ290IFwiLmNvbmNhdCh0eXBlb2YgdmFsdWUsIFwiIGluIGtleSBcIikuY29uY2F0KGtleSkpO1xuICAgICAgICB2YXIgc3VwcG9ydGVkRXh0ZW5zaW9uQWRkaXRpb24gPSAnJztcbiAgICAgICAgaWYgKHIuZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdGVkVmFsdWUgPSBVbmljb2RlRXh0ZW5zaW9uVmFsdWUoci5leHRlbnNpb24sIGtleSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWRWYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKH5rZXlMb2NhbGVEYXRhLmluZGV4T2YocmVxdWVzdGVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcXVlc3RlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkRXh0ZW5zaW9uQWRkaXRpb24gPSBcIi1cIi5jb25jYXQoa2V5LCBcIi1cIikuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh+cmVxdWVzdGVkVmFsdWUuaW5kZXhPZigndHJ1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ3RydWUnO1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRFeHRlbnNpb25BZGRpdGlvbiA9IFwiLVwiLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zVmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIG9wdGlvbnNWYWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9uc1ZhbHVlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnNWYWx1ZSA9PT0gbnVsbCwgJ29wdGlvbnNWYWx1ZSBtdXN0IGJlIFN0cmluZywgVW5kZWZpbmVkIG9yIE51bGwnKTtcbiAgICAgICAgICAgIGlmICh+a2V5TG9jYWxlRGF0YS5pbmRleE9mKG9wdGlvbnNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbnNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkRXh0ZW5zaW9uQWRkaXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgc3VwcG9ydGVkRXh0ZW5zaW9uICs9IHN1cHBvcnRlZEV4dGVuc2lvbkFkZGl0aW9uO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydGVkRXh0ZW5zaW9uLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdmFyIHByaXZhdGVJbmRleCA9IGZvdW5kTG9jYWxlLmluZGV4T2YoJy14LScpO1xuICAgICAgICBpZiAocHJpdmF0ZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgZm91bmRMb2NhbGUgPSBmb3VuZExvY2FsZSArIHN1cHBvcnRlZEV4dGVuc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVFeHRlbnNpb24gPSBmb3VuZExvY2FsZS5zbGljZSgwLCBwcml2YXRlSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHBvc3RFeHRlbnNpb24gPSBmb3VuZExvY2FsZS5zbGljZShwcml2YXRlSW5kZXgsIGZvdW5kTG9jYWxlLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3VuZExvY2FsZSA9IHByZUV4dGVuc2lvbiArIHN1cHBvcnRlZEV4dGVuc2lvbiArIHBvc3RFeHRlbnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRMb2NhbGUgPSBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMoZm91bmRMb2NhbGUpWzBdO1xuICAgIH1cbiAgICByZXN1bHQubG9jYWxlID0gZm91bmRMb2NhbGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/ResolveLocale.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/UnicodeExtensionValue.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/UnicodeExtensionValue.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnicodeExtensionValue\": () => (/* binding */ UnicodeExtensionValue)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js\");\n\n/**\n * https://tc39.es/ecma402/#sec-unicodeextensionvalue\n * @param extension\n * @param key\n */\n\nfunction UnicodeExtensionValue(extension, key) {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.invariant)(key.length === 2, 'key must have 2 elements');\n  var size = extension.length;\n  var searchValue = \"-\".concat(key, \"-\");\n  var pos = extension.indexOf(searchValue);\n\n  if (pos !== -1) {\n    var start = pos + 4;\n    var end = start;\n    var k = start;\n    var done = false;\n\n    while (!done) {\n      var e = extension.indexOf('-', k);\n      var len = void 0;\n\n      if (e === -1) {\n        len = size - k;\n      } else {\n        len = e - k;\n      }\n\n      if (len === 2) {\n        done = true;\n      } else if (e === -1) {\n        end = size;\n        done = true;\n      } else {\n        end = e;\n        k = e + 1;\n      }\n    }\n\n    return extension.slice(start, end);\n  }\n\n  searchValue = \"-\".concat(key);\n  pos = extension.indexOf(searchValue);\n\n  if (pos !== -1 && pos + 3 === size) {\n    return '';\n  }\n\n  return undefined;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L1VuaWNvZGVFeHRlbnNpb25WYWx1ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1wbHVyYWxydWxlcy9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlci9saWIvYWJzdHJhY3QvVW5pY29kZUV4dGVuc2lvblZhbHVlLmpzPzk1YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnLi91dGlscyc7XG4vKipcbiAqIGh0dHBzOi8vdGMzOS5lcy9lY21hNDAyLyNzZWMtdW5pY29kZWV4dGVuc2lvbnZhbHVlXG4gKiBAcGFyYW0gZXh0ZW5zaW9uXG4gKiBAcGFyYW0ga2V5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBVbmljb2RlRXh0ZW5zaW9uVmFsdWUoZXh0ZW5zaW9uLCBrZXkpIHtcbiAgICBpbnZhcmlhbnQoa2V5Lmxlbmd0aCA9PT0gMiwgJ2tleSBtdXN0IGhhdmUgMiBlbGVtZW50cycpO1xuICAgIHZhciBzaXplID0gZXh0ZW5zaW9uLmxlbmd0aDtcbiAgICB2YXIgc2VhcmNoVmFsdWUgPSBcIi1cIi5jb25jYXQoa2V5LCBcIi1cIik7XG4gICAgdmFyIHBvcyA9IGV4dGVuc2lvbi5pbmRleE9mKHNlYXJjaFZhbHVlKTtcbiAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3MgKyA0O1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQ7XG4gICAgICAgIHZhciBrID0gc3RhcnQ7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgdmFyIGUgPSBleHRlbnNpb24uaW5kZXhPZignLScsIGspO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChlID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IHNpemUgLSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVuID0gZSAtIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHNpemU7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBlO1xuICAgICAgICAgICAgICAgIGsgPSBlICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBzZWFyY2hWYWx1ZSA9IFwiLVwiLmNvbmNhdChrZXkpO1xuICAgIHBvcyA9IGV4dGVuc2lvbi5pbmRleE9mKHNlYXJjaFZhbHVlKTtcbiAgICBpZiAocG9zICE9PSAtMSAmJiBwb3MgKyAzID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/UnicodeExtensionValue.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UNICODE_EXTENSION_SEQUENCE_REGEX\": () => (/* binding */ UNICODE_EXTENSION_SEQUENCE_REGEX),\n/* harmony export */   \"invariant\": () => (/* binding */ invariant)\n/* harmony export */ });\nvar UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;\nfunction invariant(condition, message, Err) {\n  if (Err === void 0) {\n    Err = Error;\n  }\n\n  if (!condition) {\n    throw new Err(message);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2Fic3RyYWN0L3V0aWxzLmpzP2I2YWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBVTklDT0RFX0VYVEVOU0lPTl9TRVFVRU5DRV9SRUdFWCA9IC8tdSg/Oi1bMC05YS16XXsyLDh9KSsvZ2k7XG5leHBvcnQgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSwgRXJyKSB7XG4gICAgaWYgKEVyciA9PT0gdm9pZCAwKSB7IEVyciA9IEVycm9yOyB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycihtZXNzYWdlKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/utils.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LookupSupportedLocales\": () => (/* reexport safe */ _abstract_LookupSupportedLocales__WEBPACK_IMPORTED_MODULE_2__.LookupSupportedLocales),\n/* harmony export */   \"ResolveLocale\": () => (/* reexport safe */ _abstract_ResolveLocale__WEBPACK_IMPORTED_MODULE_1__.ResolveLocale),\n/* harmony export */   \"match\": () => (/* binding */ match)\n/* harmony export */ });\n/* harmony import */ var _abstract_CanonicalizeLocaleList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/CanonicalizeLocaleList */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/CanonicalizeLocaleList.js\");\n/* harmony import */ var _abstract_ResolveLocale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/ResolveLocale */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/ResolveLocale.js\");\n/* harmony import */ var _abstract_LookupSupportedLocales__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/LookupSupportedLocales */ \"./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/abstract/LookupSupportedLocales.js\");\n\n\nfunction match(requestedLocales, availableLocales, defaultLocale, opts) {\n  var locales = availableLocales.reduce(function (all, l) {\n    all.add(l);\n    return all;\n  }, new Set());\n  return (0,_abstract_ResolveLocale__WEBPACK_IMPORTED_MODULE_1__.ResolveLocale)(locales, (0,_abstract_CanonicalizeLocaleList__WEBPACK_IMPORTED_MODULE_0__.CanonicalizeLocaleList)(requestedLocales), {\n    localeMatcher: (opts === null || opts === void 0 ? void 0 : opts.algorithm) || 'best fit'\n  }, [], {}, function () {\n    return defaultLocale;\n  }).locale;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcGx1cmFscnVsZXMvbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLWxvY2FsZW1hdGNoZXIvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bmb3JtYXRqcy9pbnRsLXBsdXJhbHJ1bGVzL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1sb2NhbGVtYXRjaGVyL2xpYi9pbmRleC5qcz9lOWExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhbm9uaWNhbGl6ZUxvY2FsZUxpc3QgfSBmcm9tICcuL2Fic3RyYWN0L0Nhbm9uaWNhbGl6ZUxvY2FsZUxpc3QnO1xuaW1wb3J0IHsgUmVzb2x2ZUxvY2FsZSB9IGZyb20gJy4vYWJzdHJhY3QvUmVzb2x2ZUxvY2FsZSc7XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2gocmVxdWVzdGVkTG9jYWxlcywgYXZhaWxhYmxlTG9jYWxlcywgZGVmYXVsdExvY2FsZSwgb3B0cykge1xuICAgIHZhciBsb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgbCkge1xuICAgICAgICBhbGwuYWRkKGwpO1xuICAgICAgICByZXR1cm4gYWxsO1xuICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgcmV0dXJuIFJlc29sdmVMb2NhbGUobG9jYWxlcywgQ2Fub25pY2FsaXplTG9jYWxlTGlzdChyZXF1ZXN0ZWRMb2NhbGVzKSwge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmFsZ29yaXRobSkgfHwgJ2Jlc3QgZml0JyxcbiAgICB9LCBbXSwge30sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZmF1bHRMb2NhbGU7IH0pLmxvY2FsZTtcbn1cbmV4cG9ydCB7IExvb2t1cFN1cHBvcnRlZExvY2FsZXMgfSBmcm9tICcuL2Fic3RyYWN0L0xvb2t1cFN1cHBvcnRlZExvY2FsZXMnO1xuZXhwb3J0IHsgUmVzb2x2ZUxvY2FsZSB9IGZyb20gJy4vYWJzdHJhY3QvUmVzb2x2ZUxvY2FsZSc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-pluralrules/node_modules/@formatjs/intl-localematcher/lib/index.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-relativetimeformat/lib/should-polyfill.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-relativetimeformat/lib/should-polyfill.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shouldPolyfill\": () => (/* binding */ shouldPolyfill)\n/* harmony export */ });\n/* harmony import */ var _formatjs_intl_localematcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @formatjs/intl-localematcher */ \"./node_modules/@formatjs/intl-localematcher/index.js\");\n/* harmony import */ var _supported_locales__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./supported-locales */ \"./node_modules/@formatjs/intl-relativetimeformat/lib/supported-locales.js\");\n\n\n\nfunction supportedLocalesOf(locale) {\n  if (!locale) {\n    return true;\n  }\n\n  var locales = Array.isArray(locale) ? locale : [locale];\n  return Intl.RelativeTimeFormat.supportedLocalesOf(locales).length === locales.length;\n}\n\nfunction hasResolvedOptionsNumberingSystem(locale) {\n  try {\n    return 'numberingSystem' in new Intl.RelativeTimeFormat(locale || 'en', {\n      numeric: 'auto'\n    }).resolvedOptions();\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction shouldPolyfill(locale) {\n  if (locale === void 0) {\n    locale = 'en';\n  }\n\n  if (!('RelativeTimeFormat' in Intl) || !supportedLocalesOf(locale) || !hasResolvedOptionsNumberingSystem(locale)) {\n    return (0,_formatjs_intl_localematcher__WEBPACK_IMPORTED_MODULE_0__.match)([locale], _supported_locales__WEBPACK_IMPORTED_MODULE_1__.supportedLocales, 'en');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcmVsYXRpdmV0aW1lZm9ybWF0L2xpYi9zaG91bGQtcG9seWZpbGwuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZm9ybWF0anMvaW50bC1yZWxhdGl2ZXRpbWVmb3JtYXQvbGliL3Nob3VsZC1wb2x5ZmlsbC5qcz8zNDMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1hdGNoIH0gZnJvbSAnQGZvcm1hdGpzL2ludGwtbG9jYWxlbWF0Y2hlcic7XG5pbXBvcnQgeyBzdXBwb3J0ZWRMb2NhbGVzIH0gZnJvbSAnLi9zdXBwb3J0ZWQtbG9jYWxlcyc7XG5mdW5jdGlvbiBzdXBwb3J0ZWRMb2NhbGVzT2YobG9jYWxlKSB7XG4gICAgaWYgKCFsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBsb2NhbGVzID0gQXJyYXkuaXNBcnJheShsb2NhbGUpID8gbG9jYWxlIDogW2xvY2FsZV07XG4gICAgcmV0dXJuIChJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5zdXBwb3J0ZWRMb2NhbGVzT2YobG9jYWxlcykubGVuZ3RoID09PVxuICAgICAgICBsb2NhbGVzLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBoYXNSZXNvbHZlZE9wdGlvbnNOdW1iZXJpbmdTeXN0ZW0obG9jYWxlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgnbnVtYmVyaW5nU3lzdGVtJyBpblxuICAgICAgICAgICAgbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSB8fCAnZW4nLCB7XG4gICAgICAgICAgICAgICAgbnVtZXJpYzogJ2F1dG8nLFxuICAgICAgICAgICAgfSkucmVzb2x2ZWRPcHRpb25zKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFBvbHlmaWxsKGxvY2FsZSkge1xuICAgIGlmIChsb2NhbGUgPT09IHZvaWQgMCkgeyBsb2NhbGUgPSAnZW4nOyB9XG4gICAgaWYgKCEoJ1JlbGF0aXZlVGltZUZvcm1hdCcgaW4gSW50bCkgfHxcbiAgICAgICAgIXN1cHBvcnRlZExvY2FsZXNPZihsb2NhbGUpIHx8XG4gICAgICAgICFoYXNSZXNvbHZlZE9wdGlvbnNOdW1iZXJpbmdTeXN0ZW0obG9jYWxlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2goW2xvY2FsZV0sIHN1cHBvcnRlZExvY2FsZXMsICdlbicpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-relativetimeformat/lib/should-polyfill.js\n");

/***/ }),

/***/ "./node_modules/@formatjs/intl-relativetimeformat/lib/supported-locales.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@formatjs/intl-relativetimeformat/lib/supported-locales.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"supportedLocales\": () => (/* binding */ supportedLocales)\n/* harmony export */ });\n// This file is generated from supported-locales-gen.ts\nvar supportedLocales = [\"af-NA\", \"af\", \"agq\", \"ak\", \"am\", \"ar-AE\", \"ar-BH\", \"ar-DJ\", \"ar-DZ\", \"ar-EG\", \"ar-EH\", \"ar-ER\", \"ar-IL\", \"ar-IQ\", \"ar-JO\", \"ar-KM\", \"ar-KW\", \"ar-LB\", \"ar-LY\", \"ar-MA\", \"ar-MR\", \"ar-OM\", \"ar-PS\", \"ar-QA\", \"ar-SA\", \"ar-SD\", \"ar-SO\", \"ar-SS\", \"ar-SY\", \"ar-TD\", \"ar-TN\", \"ar-YE\", \"ar\", \"as\", \"asa\", \"ast\", \"az-Cyrl\", \"az-Latn\", \"az\", \"bas\", \"be-tarask\", \"be\", \"bem\", \"bez\", \"bg\", \"bm\", \"bn-IN\", \"bn\", \"bo-IN\", \"bo\", \"br\", \"brx\", \"bs-Cyrl\", \"bs-Latn\", \"bs\", \"ca-AD\", \"ca-ES-valencia\", \"ca-FR\", \"ca-IT\", \"ca\", \"ccp-IN\", \"ccp\", \"ce\", \"ceb\", \"cgg\", \"chr\", \"ckb-IR\", \"ckb\", \"cs\", \"cy\", \"da-GL\", \"da\", \"dav\", \"de-AT\", \"de-BE\", \"de-CH\", \"de-IT\", \"de-LI\", \"de-LU\", \"de\", \"dje\", \"doi\", \"dsb\", \"dua\", \"dyo\", \"dz\", \"ebu\", \"ee-TG\", \"ee\", \"el-CY\", \"el\", \"en-001\", \"en-150\", \"en-AE\", \"en-AG\", \"en-AI\", \"en-AS\", \"en-AT\", \"en-AU\", \"en-BB\", \"en-BE\", \"en-BI\", \"en-BM\", \"en-BS\", \"en-BW\", \"en-BZ\", \"en-CA\", \"en-CC\", \"en-CH\", \"en-CK\", \"en-CM\", \"en-CX\", \"en-CY\", \"en-DE\", \"en-DG\", \"en-DK\", \"en-DM\", \"en-ER\", \"en-FI\", \"en-FJ\", \"en-FK\", \"en-FM\", \"en-GB\", \"en-GD\", \"en-GG\", \"en-GH\", \"en-GI\", \"en-GM\", \"en-GU\", \"en-GY\", \"en-HK\", \"en-IE\", \"en-IL\", \"en-IM\", \"en-IN\", \"en-IO\", \"en-JE\", \"en-JM\", \"en-KE\", \"en-KI\", \"en-KN\", \"en-KY\", \"en-LC\", \"en-LR\", \"en-LS\", \"en-MG\", \"en-MH\", \"en-MO\", \"en-MP\", \"en-MS\", \"en-MT\", \"en-MU\", \"en-MW\", \"en-MY\", \"en-NA\", \"en-NF\", \"en-NG\", \"en-NL\", \"en-NR\", \"en-NU\", \"en-NZ\", \"en-PG\", \"en-PH\", \"en-PK\", \"en-PN\", \"en-PR\", \"en-PW\", \"en-RW\", \"en-SB\", \"en-SC\", \"en-SD\", \"en-SE\", \"en-SG\", \"en-SH\", \"en-SI\", \"en-SL\", \"en-SS\", \"en-SX\", \"en-SZ\", \"en-TC\", \"en-TK\", \"en-TO\", \"en-TT\", \"en-TV\", \"en-TZ\", \"en-UG\", \"en-UM\", \"en-VC\", \"en-VG\", \"en-VI\", \"en-VU\", \"en-WS\", \"en-ZA\", \"en-ZM\", \"en-ZW\", \"en\", \"eo\", \"es-419\", \"es-AR\", \"es-BO\", \"es-BR\", \"es-BZ\", \"es-CL\", \"es-CO\", \"es-CR\", \"es-CU\", \"es-DO\", \"es-EA\", \"es-EC\", \"es-GQ\", \"es-GT\", \"es-HN\", \"es-IC\", \"es-MX\", \"es-NI\", \"es-PA\", \"es-PE\", \"es-PH\", \"es-PR\", \"es-PY\", \"es-SV\", \"es-US\", \"es-UY\", \"es-VE\", \"es\", \"et\", \"eu\", \"ewo\", \"fa-AF\", \"fa\", \"ff-Adlm-BF\", \"ff-Adlm-CM\", \"ff-Adlm-GH\", \"ff-Adlm-GM\", \"ff-Adlm-GW\", \"ff-Adlm-LR\", \"ff-Adlm-MR\", \"ff-Adlm-NE\", \"ff-Adlm-NG\", \"ff-Adlm-SL\", \"ff-Adlm-SN\", \"ff-Adlm\", \"ff-Latn-BF\", \"ff-Latn-CM\", \"ff-Latn-GH\", \"ff-Latn-GM\", \"ff-Latn-GN\", \"ff-Latn-GW\", \"ff-Latn-LR\", \"ff-Latn-MR\", \"ff-Latn-NE\", \"ff-Latn-NG\", \"ff-Latn-SL\", \"ff-Latn\", \"ff\", \"fi\", \"fil\", \"fo-DK\", \"fo\", \"fr-BE\", \"fr-BF\", \"fr-BI\", \"fr-BJ\", \"fr-BL\", \"fr-CA\", \"fr-CD\", \"fr-CF\", \"fr-CG\", \"fr-CH\", \"fr-CI\", \"fr-CM\", \"fr-DJ\", \"fr-DZ\", \"fr-GA\", \"fr-GF\", \"fr-GN\", \"fr-GP\", \"fr-GQ\", \"fr-HT\", \"fr-KM\", \"fr-LU\", \"fr-MA\", \"fr-MC\", \"fr-MF\", \"fr-MG\", \"fr-ML\", \"fr-MQ\", \"fr-MR\", \"fr-MU\", \"fr-NC\", \"fr-NE\", \"fr-PF\", \"fr-PM\", \"fr-RE\", \"fr-RW\", \"fr-SC\", \"fr-SN\", \"fr-SY\", \"fr-TD\", \"fr-TG\", \"fr-TN\", \"fr-VU\", \"fr-WF\", \"fr-YT\", \"fr\", \"fur\", \"fy\", \"ga-GB\", \"ga\", \"gd\", \"gl\", \"gsw-FR\", \"gsw-LI\", \"gsw\", \"gu\", \"guz\", \"gv\", \"ha-GH\", \"ha-NE\", \"ha\", \"haw\", \"he\", \"hi\", \"hr-BA\", \"hr\", \"hsb\", \"hu\", \"hy\", \"ia\", \"id\", \"ig\", \"ii\", \"is\", \"it-CH\", \"it-SM\", \"it-VA\", \"it\", \"ja\", \"jgo\", \"jmc\", \"jv\", \"ka\", \"kab\", \"kam\", \"kde\", \"kea\", \"kgp\", \"khq\", \"ki\", \"kk\", \"kkj\", \"kl\", \"kln\", \"km\", \"kn\", \"ko-KP\", \"ko\", \"kok\", \"ks-Arab\", \"ks\", \"ksb\", \"ksf\", \"ksh\", \"ku\", \"kw\", \"ky\", \"lag\", \"lb\", \"lg\", \"lkt\", \"ln-AO\", \"ln-CF\", \"ln-CG\", \"ln\", \"lo\", \"lrc-IQ\", \"lrc\", \"lt\", \"lu\", \"luo\", \"luy\", \"lv\", \"mai\", \"mas-TZ\", \"mas\", \"mer\", \"mfe\", \"mg\", \"mgh\", \"mgo\", \"mi\", \"mk\", \"ml\", \"mn\", \"mni-Beng\", \"mni\", \"mr\", \"ms-BN\", \"ms-ID\", \"ms-SG\", \"ms\", \"mt\", \"mua\", \"my\", \"mzn\", \"naq\", \"nb-SJ\", \"nb\", \"nd\", \"nds-NL\", \"nds\", \"ne-IN\", \"ne\", \"nl-AW\", \"nl-BE\", \"nl-BQ\", \"nl-CW\", \"nl-SR\", \"nl-SX\", \"nl\", \"nmg\", \"nn\", \"nnh\", \"no\", \"nus\", \"nyn\", \"om-KE\", \"om\", \"or\", \"os-RU\", \"os\", \"pa-Arab\", \"pa-Guru\", \"pa\", \"pcm\", \"pl\", \"ps-PK\", \"ps\", \"pt-AO\", \"pt-CH\", \"pt-CV\", \"pt-GQ\", \"pt-GW\", \"pt-LU\", \"pt-MO\", \"pt-MZ\", \"pt-PT\", \"pt-ST\", \"pt-TL\", \"pt\", \"qu-BO\", \"qu-EC\", \"qu\", \"rm\", \"rn\", \"ro-MD\", \"ro\", \"rof\", \"ru-BY\", \"ru-KG\", \"ru-KZ\", \"ru-MD\", \"ru-UA\", \"ru\", \"rw\", \"rwk\", \"sa\", \"sah\", \"saq\", \"sat-Olck\", \"sat\", \"sbp\", \"sc\", \"sd-Arab\", \"sd-Deva\", \"sd\", \"se-FI\", \"se-SE\", \"se\", \"seh\", \"ses\", \"sg\", \"shi-Latn\", \"shi-Tfng\", \"shi\", \"si\", \"sk\", \"sl\", \"smn\", \"sn\", \"so-DJ\", \"so-ET\", \"so-KE\", \"so\", \"sq-MK\", \"sq-XK\", \"sq\", \"sr-Cyrl-BA\", \"sr-Cyrl-ME\", \"sr-Cyrl-XK\", \"sr-Cyrl\", \"sr-Latn-BA\", \"sr-Latn-ME\", \"sr-Latn-XK\", \"sr-Latn\", \"sr\", \"su-Latn\", \"su\", \"sv-AX\", \"sv-FI\", \"sv\", \"sw-CD\", \"sw-KE\", \"sw-UG\", \"sw\", \"ta-LK\", \"ta-MY\", \"ta-SG\", \"ta\", \"te\", \"teo-KE\", \"teo\", \"tg\", \"th\", \"ti-ER\", \"ti\", \"tk\", \"to\", \"tr-CY\", \"tr\", \"tt\", \"twq\", \"tzm\", \"ug\", \"uk\", \"und\", \"ur-IN\", \"ur\", \"uz-Arab\", \"uz-Cyrl\", \"uz-Latn\", \"uz\", \"vai-Latn\", \"vai-Vaii\", \"vai\", \"vi\", \"vun\", \"wae\", \"wo\", \"xh\", \"xog\", \"yav\", \"yi\", \"yo-BJ\", \"yo\", \"yrl-CO\", \"yrl-VE\", \"yrl\", \"yue-Hans\", \"yue-Hant\", \"yue\", \"zgh\", \"zh-Hans-HK\", \"zh-Hans-MO\", \"zh-Hans-SG\", \"zh-Hans\", \"zh-Hant-HK\", \"zh-Hant-MO\", \"zh-Hant\", \"zh\", \"zu\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcmVsYXRpdmV0aW1lZm9ybWF0L2xpYi9zdXBwb3J0ZWQtbG9jYWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGZvcm1hdGpzL2ludGwtcmVsYXRpdmV0aW1lZm9ybWF0L2xpYi9zdXBwb3J0ZWQtbG9jYWxlcy5qcz9hYmFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBzdXBwb3J0ZWQtbG9jYWxlcy1nZW4udHNcbmV4cG9ydCB2YXIgc3VwcG9ydGVkTG9jYWxlcyA9IFtcImFmLU5BXCIsIFwiYWZcIiwgXCJhZ3FcIiwgXCJha1wiLCBcImFtXCIsIFwiYXItQUVcIiwgXCJhci1CSFwiLCBcImFyLURKXCIsIFwiYXItRFpcIiwgXCJhci1FR1wiLCBcImFyLUVIXCIsIFwiYXItRVJcIiwgXCJhci1JTFwiLCBcImFyLUlRXCIsIFwiYXItSk9cIiwgXCJhci1LTVwiLCBcImFyLUtXXCIsIFwiYXItTEJcIiwgXCJhci1MWVwiLCBcImFyLU1BXCIsIFwiYXItTVJcIiwgXCJhci1PTVwiLCBcImFyLVBTXCIsIFwiYXItUUFcIiwgXCJhci1TQVwiLCBcImFyLVNEXCIsIFwiYXItU09cIiwgXCJhci1TU1wiLCBcImFyLVNZXCIsIFwiYXItVERcIiwgXCJhci1UTlwiLCBcImFyLVlFXCIsIFwiYXJcIiwgXCJhc1wiLCBcImFzYVwiLCBcImFzdFwiLCBcImF6LUN5cmxcIiwgXCJhei1MYXRuXCIsIFwiYXpcIiwgXCJiYXNcIiwgXCJiZS10YXJhc2tcIiwgXCJiZVwiLCBcImJlbVwiLCBcImJlelwiLCBcImJnXCIsIFwiYm1cIiwgXCJibi1JTlwiLCBcImJuXCIsIFwiYm8tSU5cIiwgXCJib1wiLCBcImJyXCIsIFwiYnJ4XCIsIFwiYnMtQ3lybFwiLCBcImJzLUxhdG5cIiwgXCJic1wiLCBcImNhLUFEXCIsIFwiY2EtRVMtdmFsZW5jaWFcIiwgXCJjYS1GUlwiLCBcImNhLUlUXCIsIFwiY2FcIiwgXCJjY3AtSU5cIiwgXCJjY3BcIiwgXCJjZVwiLCBcImNlYlwiLCBcImNnZ1wiLCBcImNoclwiLCBcImNrYi1JUlwiLCBcImNrYlwiLCBcImNzXCIsIFwiY3lcIiwgXCJkYS1HTFwiLCBcImRhXCIsIFwiZGF2XCIsIFwiZGUtQVRcIiwgXCJkZS1CRVwiLCBcImRlLUNIXCIsIFwiZGUtSVRcIiwgXCJkZS1MSVwiLCBcImRlLUxVXCIsIFwiZGVcIiwgXCJkamVcIiwgXCJkb2lcIiwgXCJkc2JcIiwgXCJkdWFcIiwgXCJkeW9cIiwgXCJkelwiLCBcImVidVwiLCBcImVlLVRHXCIsIFwiZWVcIiwgXCJlbC1DWVwiLCBcImVsXCIsIFwiZW4tMDAxXCIsIFwiZW4tMTUwXCIsIFwiZW4tQUVcIiwgXCJlbi1BR1wiLCBcImVuLUFJXCIsIFwiZW4tQVNcIiwgXCJlbi1BVFwiLCBcImVuLUFVXCIsIFwiZW4tQkJcIiwgXCJlbi1CRVwiLCBcImVuLUJJXCIsIFwiZW4tQk1cIiwgXCJlbi1CU1wiLCBcImVuLUJXXCIsIFwiZW4tQlpcIiwgXCJlbi1DQVwiLCBcImVuLUNDXCIsIFwiZW4tQ0hcIiwgXCJlbi1DS1wiLCBcImVuLUNNXCIsIFwiZW4tQ1hcIiwgXCJlbi1DWVwiLCBcImVuLURFXCIsIFwiZW4tREdcIiwgXCJlbi1ES1wiLCBcImVuLURNXCIsIFwiZW4tRVJcIiwgXCJlbi1GSVwiLCBcImVuLUZKXCIsIFwiZW4tRktcIiwgXCJlbi1GTVwiLCBcImVuLUdCXCIsIFwiZW4tR0RcIiwgXCJlbi1HR1wiLCBcImVuLUdIXCIsIFwiZW4tR0lcIiwgXCJlbi1HTVwiLCBcImVuLUdVXCIsIFwiZW4tR1lcIiwgXCJlbi1IS1wiLCBcImVuLUlFXCIsIFwiZW4tSUxcIiwgXCJlbi1JTVwiLCBcImVuLUlOXCIsIFwiZW4tSU9cIiwgXCJlbi1KRVwiLCBcImVuLUpNXCIsIFwiZW4tS0VcIiwgXCJlbi1LSVwiLCBcImVuLUtOXCIsIFwiZW4tS1lcIiwgXCJlbi1MQ1wiLCBcImVuLUxSXCIsIFwiZW4tTFNcIiwgXCJlbi1NR1wiLCBcImVuLU1IXCIsIFwiZW4tTU9cIiwgXCJlbi1NUFwiLCBcImVuLU1TXCIsIFwiZW4tTVRcIiwgXCJlbi1NVVwiLCBcImVuLU1XXCIsIFwiZW4tTVlcIiwgXCJlbi1OQVwiLCBcImVuLU5GXCIsIFwiZW4tTkdcIiwgXCJlbi1OTFwiLCBcImVuLU5SXCIsIFwiZW4tTlVcIiwgXCJlbi1OWlwiLCBcImVuLVBHXCIsIFwiZW4tUEhcIiwgXCJlbi1QS1wiLCBcImVuLVBOXCIsIFwiZW4tUFJcIiwgXCJlbi1QV1wiLCBcImVuLVJXXCIsIFwiZW4tU0JcIiwgXCJlbi1TQ1wiLCBcImVuLVNEXCIsIFwiZW4tU0VcIiwgXCJlbi1TR1wiLCBcImVuLVNIXCIsIFwiZW4tU0lcIiwgXCJlbi1TTFwiLCBcImVuLVNTXCIsIFwiZW4tU1hcIiwgXCJlbi1TWlwiLCBcImVuLVRDXCIsIFwiZW4tVEtcIiwgXCJlbi1UT1wiLCBcImVuLVRUXCIsIFwiZW4tVFZcIiwgXCJlbi1UWlwiLCBcImVuLVVHXCIsIFwiZW4tVU1cIiwgXCJlbi1WQ1wiLCBcImVuLVZHXCIsIFwiZW4tVklcIiwgXCJlbi1WVVwiLCBcImVuLVdTXCIsIFwiZW4tWkFcIiwgXCJlbi1aTVwiLCBcImVuLVpXXCIsIFwiZW5cIiwgXCJlb1wiLCBcImVzLTQxOVwiLCBcImVzLUFSXCIsIFwiZXMtQk9cIiwgXCJlcy1CUlwiLCBcImVzLUJaXCIsIFwiZXMtQ0xcIiwgXCJlcy1DT1wiLCBcImVzLUNSXCIsIFwiZXMtQ1VcIiwgXCJlcy1ET1wiLCBcImVzLUVBXCIsIFwiZXMtRUNcIiwgXCJlcy1HUVwiLCBcImVzLUdUXCIsIFwiZXMtSE5cIiwgXCJlcy1JQ1wiLCBcImVzLU1YXCIsIFwiZXMtTklcIiwgXCJlcy1QQVwiLCBcImVzLVBFXCIsIFwiZXMtUEhcIiwgXCJlcy1QUlwiLCBcImVzLVBZXCIsIFwiZXMtU1ZcIiwgXCJlcy1VU1wiLCBcImVzLVVZXCIsIFwiZXMtVkVcIiwgXCJlc1wiLCBcImV0XCIsIFwiZXVcIiwgXCJld29cIiwgXCJmYS1BRlwiLCBcImZhXCIsIFwiZmYtQWRsbS1CRlwiLCBcImZmLUFkbG0tQ01cIiwgXCJmZi1BZGxtLUdIXCIsIFwiZmYtQWRsbS1HTVwiLCBcImZmLUFkbG0tR1dcIiwgXCJmZi1BZGxtLUxSXCIsIFwiZmYtQWRsbS1NUlwiLCBcImZmLUFkbG0tTkVcIiwgXCJmZi1BZGxtLU5HXCIsIFwiZmYtQWRsbS1TTFwiLCBcImZmLUFkbG0tU05cIiwgXCJmZi1BZGxtXCIsIFwiZmYtTGF0bi1CRlwiLCBcImZmLUxhdG4tQ01cIiwgXCJmZi1MYXRuLUdIXCIsIFwiZmYtTGF0bi1HTVwiLCBcImZmLUxhdG4tR05cIiwgXCJmZi1MYXRuLUdXXCIsIFwiZmYtTGF0bi1MUlwiLCBcImZmLUxhdG4tTVJcIiwgXCJmZi1MYXRuLU5FXCIsIFwiZmYtTGF0bi1OR1wiLCBcImZmLUxhdG4tU0xcIiwgXCJmZi1MYXRuXCIsIFwiZmZcIiwgXCJmaVwiLCBcImZpbFwiLCBcImZvLURLXCIsIFwiZm9cIiwgXCJmci1CRVwiLCBcImZyLUJGXCIsIFwiZnItQklcIiwgXCJmci1CSlwiLCBcImZyLUJMXCIsIFwiZnItQ0FcIiwgXCJmci1DRFwiLCBcImZyLUNGXCIsIFwiZnItQ0dcIiwgXCJmci1DSFwiLCBcImZyLUNJXCIsIFwiZnItQ01cIiwgXCJmci1ESlwiLCBcImZyLURaXCIsIFwiZnItR0FcIiwgXCJmci1HRlwiLCBcImZyLUdOXCIsIFwiZnItR1BcIiwgXCJmci1HUVwiLCBcImZyLUhUXCIsIFwiZnItS01cIiwgXCJmci1MVVwiLCBcImZyLU1BXCIsIFwiZnItTUNcIiwgXCJmci1NRlwiLCBcImZyLU1HXCIsIFwiZnItTUxcIiwgXCJmci1NUVwiLCBcImZyLU1SXCIsIFwiZnItTVVcIiwgXCJmci1OQ1wiLCBcImZyLU5FXCIsIFwiZnItUEZcIiwgXCJmci1QTVwiLCBcImZyLVJFXCIsIFwiZnItUldcIiwgXCJmci1TQ1wiLCBcImZyLVNOXCIsIFwiZnItU1lcIiwgXCJmci1URFwiLCBcImZyLVRHXCIsIFwiZnItVE5cIiwgXCJmci1WVVwiLCBcImZyLVdGXCIsIFwiZnItWVRcIiwgXCJmclwiLCBcImZ1clwiLCBcImZ5XCIsIFwiZ2EtR0JcIiwgXCJnYVwiLCBcImdkXCIsIFwiZ2xcIiwgXCJnc3ctRlJcIiwgXCJnc3ctTElcIiwgXCJnc3dcIiwgXCJndVwiLCBcImd1elwiLCBcImd2XCIsIFwiaGEtR0hcIiwgXCJoYS1ORVwiLCBcImhhXCIsIFwiaGF3XCIsIFwiaGVcIiwgXCJoaVwiLCBcImhyLUJBXCIsIFwiaHJcIiwgXCJoc2JcIiwgXCJodVwiLCBcImh5XCIsIFwiaWFcIiwgXCJpZFwiLCBcImlnXCIsIFwiaWlcIiwgXCJpc1wiLCBcIml0LUNIXCIsIFwiaXQtU01cIiwgXCJpdC1WQVwiLCBcIml0XCIsIFwiamFcIiwgXCJqZ29cIiwgXCJqbWNcIiwgXCJqdlwiLCBcImthXCIsIFwia2FiXCIsIFwia2FtXCIsIFwia2RlXCIsIFwia2VhXCIsIFwia2dwXCIsIFwia2hxXCIsIFwia2lcIiwgXCJra1wiLCBcImtralwiLCBcImtsXCIsIFwia2xuXCIsIFwia21cIiwgXCJrblwiLCBcImtvLUtQXCIsIFwia29cIiwgXCJrb2tcIiwgXCJrcy1BcmFiXCIsIFwia3NcIiwgXCJrc2JcIiwgXCJrc2ZcIiwgXCJrc2hcIiwgXCJrdVwiLCBcImt3XCIsIFwia3lcIiwgXCJsYWdcIiwgXCJsYlwiLCBcImxnXCIsIFwibGt0XCIsIFwibG4tQU9cIiwgXCJsbi1DRlwiLCBcImxuLUNHXCIsIFwibG5cIiwgXCJsb1wiLCBcImxyYy1JUVwiLCBcImxyY1wiLCBcImx0XCIsIFwibHVcIiwgXCJsdW9cIiwgXCJsdXlcIiwgXCJsdlwiLCBcIm1haVwiLCBcIm1hcy1UWlwiLCBcIm1hc1wiLCBcIm1lclwiLCBcIm1mZVwiLCBcIm1nXCIsIFwibWdoXCIsIFwibWdvXCIsIFwibWlcIiwgXCJta1wiLCBcIm1sXCIsIFwibW5cIiwgXCJtbmktQmVuZ1wiLCBcIm1uaVwiLCBcIm1yXCIsIFwibXMtQk5cIiwgXCJtcy1JRFwiLCBcIm1zLVNHXCIsIFwibXNcIiwgXCJtdFwiLCBcIm11YVwiLCBcIm15XCIsIFwibXpuXCIsIFwibmFxXCIsIFwibmItU0pcIiwgXCJuYlwiLCBcIm5kXCIsIFwibmRzLU5MXCIsIFwibmRzXCIsIFwibmUtSU5cIiwgXCJuZVwiLCBcIm5sLUFXXCIsIFwibmwtQkVcIiwgXCJubC1CUVwiLCBcIm5sLUNXXCIsIFwibmwtU1JcIiwgXCJubC1TWFwiLCBcIm5sXCIsIFwibm1nXCIsIFwibm5cIiwgXCJubmhcIiwgXCJub1wiLCBcIm51c1wiLCBcIm55blwiLCBcIm9tLUtFXCIsIFwib21cIiwgXCJvclwiLCBcIm9zLVJVXCIsIFwib3NcIiwgXCJwYS1BcmFiXCIsIFwicGEtR3VydVwiLCBcInBhXCIsIFwicGNtXCIsIFwicGxcIiwgXCJwcy1QS1wiLCBcInBzXCIsIFwicHQtQU9cIiwgXCJwdC1DSFwiLCBcInB0LUNWXCIsIFwicHQtR1FcIiwgXCJwdC1HV1wiLCBcInB0LUxVXCIsIFwicHQtTU9cIiwgXCJwdC1NWlwiLCBcInB0LVBUXCIsIFwicHQtU1RcIiwgXCJwdC1UTFwiLCBcInB0XCIsIFwicXUtQk9cIiwgXCJxdS1FQ1wiLCBcInF1XCIsIFwicm1cIiwgXCJyblwiLCBcInJvLU1EXCIsIFwicm9cIiwgXCJyb2ZcIiwgXCJydS1CWVwiLCBcInJ1LUtHXCIsIFwicnUtS1pcIiwgXCJydS1NRFwiLCBcInJ1LVVBXCIsIFwicnVcIiwgXCJyd1wiLCBcInJ3a1wiLCBcInNhXCIsIFwic2FoXCIsIFwic2FxXCIsIFwic2F0LU9sY2tcIiwgXCJzYXRcIiwgXCJzYnBcIiwgXCJzY1wiLCBcInNkLUFyYWJcIiwgXCJzZC1EZXZhXCIsIFwic2RcIiwgXCJzZS1GSVwiLCBcInNlLVNFXCIsIFwic2VcIiwgXCJzZWhcIiwgXCJzZXNcIiwgXCJzZ1wiLCBcInNoaS1MYXRuXCIsIFwic2hpLVRmbmdcIiwgXCJzaGlcIiwgXCJzaVwiLCBcInNrXCIsIFwic2xcIiwgXCJzbW5cIiwgXCJzblwiLCBcInNvLURKXCIsIFwic28tRVRcIiwgXCJzby1LRVwiLCBcInNvXCIsIFwic3EtTUtcIiwgXCJzcS1YS1wiLCBcInNxXCIsIFwic3ItQ3lybC1CQVwiLCBcInNyLUN5cmwtTUVcIiwgXCJzci1DeXJsLVhLXCIsIFwic3ItQ3lybFwiLCBcInNyLUxhdG4tQkFcIiwgXCJzci1MYXRuLU1FXCIsIFwic3ItTGF0bi1YS1wiLCBcInNyLUxhdG5cIiwgXCJzclwiLCBcInN1LUxhdG5cIiwgXCJzdVwiLCBcInN2LUFYXCIsIFwic3YtRklcIiwgXCJzdlwiLCBcInN3LUNEXCIsIFwic3ctS0VcIiwgXCJzdy1VR1wiLCBcInN3XCIsIFwidGEtTEtcIiwgXCJ0YS1NWVwiLCBcInRhLVNHXCIsIFwidGFcIiwgXCJ0ZVwiLCBcInRlby1LRVwiLCBcInRlb1wiLCBcInRnXCIsIFwidGhcIiwgXCJ0aS1FUlwiLCBcInRpXCIsIFwidGtcIiwgXCJ0b1wiLCBcInRyLUNZXCIsIFwidHJcIiwgXCJ0dFwiLCBcInR3cVwiLCBcInR6bVwiLCBcInVnXCIsIFwidWtcIiwgXCJ1bmRcIiwgXCJ1ci1JTlwiLCBcInVyXCIsIFwidXotQXJhYlwiLCBcInV6LUN5cmxcIiwgXCJ1ei1MYXRuXCIsIFwidXpcIiwgXCJ2YWktTGF0blwiLCBcInZhaS1WYWlpXCIsIFwidmFpXCIsIFwidmlcIiwgXCJ2dW5cIiwgXCJ3YWVcIiwgXCJ3b1wiLCBcInhoXCIsIFwieG9nXCIsIFwieWF2XCIsIFwieWlcIiwgXCJ5by1CSlwiLCBcInlvXCIsIFwieXJsLUNPXCIsIFwieXJsLVZFXCIsIFwieXJsXCIsIFwieXVlLUhhbnNcIiwgXCJ5dWUtSGFudFwiLCBcInl1ZVwiLCBcInpnaFwiLCBcInpoLUhhbnMtSEtcIiwgXCJ6aC1IYW5zLU1PXCIsIFwiemgtSGFucy1TR1wiLCBcInpoLUhhbnNcIiwgXCJ6aC1IYW50LUhLXCIsIFwiemgtSGFudC1NT1wiLCBcInpoLUhhbnRcIiwgXCJ6aFwiLCBcInp1XCJdO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@formatjs/intl-relativetimeformat/lib/supported-locales.js\n");

/***/ }),

/***/ "./node_modules/@material/mwc-textarea/mwc-textarea-base.js":
/*!******************************************************************!*\
  !*** ./node_modules/@material/mwc-textarea/mwc-textarea-base.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextAreaBase\": () => (/* binding */ TextAreaBase)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _material_mwc_textfield_mwc_textfield_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material/mwc-textfield/mwc-textfield-base */ \"./node_modules/@material/mwc-textfield/mwc-textfield-base.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/decorators.js */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit/directives/class-map.js */ \"./node_modules/lit/directives/class-map.js\");\n/* harmony import */ var lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lit/directives/if-defined.js */ \"./node_modules/lit/directives/if-defined.js\");\n/* harmony import */ var lit_directives_live_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lit/directives/live.js */ \"./node_modules/lit/directives/live.js\");\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n // Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n\n\n\n\n\n\nconst booleanOrStringConverter = {\n  fromAttribute(value) {\n    if (value === null) {\n      return false;\n    } else if (value === '') {\n      return true;\n    }\n\n    return value;\n  },\n\n  toAttribute(value) {\n    if (typeof value === 'boolean') {\n      return value ? '' : null;\n    }\n\n    return value;\n  }\n\n};\n/** @soyCompatible */\n\nclass TextAreaBase extends _material_mwc_textfield_mwc_textfield_base__WEBPACK_IMPORTED_MODULE_0__.TextFieldBase {\n  constructor() {\n    super(...arguments);\n    this.rows = 2;\n    this.cols = 20;\n    this.charCounter = false;\n  }\n  /** @soyTemplate */\n\n\n  render() {\n    const shouldRenderCharCounter = this.charCounter && this.maxLength !== -1;\n    const shouldRenderInternalCharCounter = shouldRenderCharCounter && this.charCounter === 'internal';\n    const shouldRenderExternalCharCounter = shouldRenderCharCounter && !shouldRenderInternalCharCounter;\n    const shouldRenderHelperText = !!this.helper || !!this.validationMessage || shouldRenderExternalCharCounter;\n    /** @classMap */\n\n    const classes = {\n      'mdc-text-field--disabled': this.disabled,\n      'mdc-text-field--no-label': !this.label,\n      'mdc-text-field--filled': !this.outlined,\n      'mdc-text-field--outlined': this.outlined,\n      'mdc-text-field--end-aligned': this.endAligned,\n      'mdc-text-field--with-internal-counter': shouldRenderInternalCharCounter\n    };\n    return lit__WEBPACK_IMPORTED_MODULE_1__.html`\n      <label class=\"mdc-text-field mdc-text-field--textarea ${(0,lit_directives_class_map_js__WEBPACK_IMPORTED_MODULE_3__.classMap)(classes)}\">\n        ${this.renderRipple()}\n        ${this.outlined ? this.renderOutline() : this.renderLabel()}\n        ${this.renderInput()}\n        ${this.renderCharCounter(shouldRenderInternalCharCounter)}\n        ${this.renderLineRipple()}\n      </label>\n      ${this.renderHelperText(shouldRenderHelperText, shouldRenderExternalCharCounter)}\n    `;\n  }\n  /** @soyTemplate */\n\n\n  renderInput() {\n    const ariaLabelledbyOrUndef = !!this.label ? 'label' : undefined;\n    const minOrUndef = this.minLength === -1 ? undefined : this.minLength;\n    const maxOrUndef = this.maxLength === -1 ? undefined : this.maxLength;\n    const autocapitalizeOrUndef = this.autocapitalize ? this.autocapitalize : undefined;\n    return lit__WEBPACK_IMPORTED_MODULE_1__.html`\n      <textarea\n          aria-labelledby=${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(ariaLabelledbyOrUndef)}\n          class=\"mdc-text-field__input\"\n          .value=\"${(0,lit_directives_live_js__WEBPACK_IMPORTED_MODULE_5__.live)(this.value)}\"\n          rows=\"${this.rows}\"\n          cols=\"${this.cols}\"\n          ?disabled=\"${this.disabled}\"\n          placeholder=\"${this.placeholder}\"\n          ?required=\"${this.required}\"\n          ?readonly=\"${this.readOnly}\"\n          minlength=\"${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(minOrUndef)}\"\n          maxlength=\"${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(maxOrUndef)}\"\n          name=\"${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(this.name === '' ? undefined : this.name)}\"\n          inputmode=\"${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(this.inputMode)}\"\n          autocapitalize=\"${(0,lit_directives_if_defined_js__WEBPACK_IMPORTED_MODULE_4__.ifDefined)(autocapitalizeOrUndef)}\"\n          @input=\"${this.handleInputChange}\"\n          @blur=\"${this.onInputBlur}\">\n      </textarea>`;\n  }\n\n}\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_2__.query)('textarea')], TextAreaBase.prototype, \"formElement\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)({\n  type: Number\n})], TextAreaBase.prototype, \"rows\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)({\n  type: Number\n})], TextAreaBase.prototype, \"cols\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_6__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)({\n  converter: booleanOrStringConverter\n})], TextAreaBase.prototype, \"charCounter\", void 0);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL213Yy10ZXh0YXJlYS9td2MtdGV4dGFyZWEtYmFzZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztBQU1BO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQWhCQTtBQW1CQTs7QUFDQTtBQUFBOztBQUdBO0FBRUE7QUFHQTtBQW9FQTtBQWxFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQVZBO0FBYUE7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFtQkE7O0FBM0VBOztBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7O0FBR0E7QUFEQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC9td2MtdGV4dGFyZWEtYmFzZS50cz9mNDRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLy8gU3R5bGUgcHJlZmVyZW5jZSBmb3IgbGVhZGluZyB1bmRlcnNjb3Jlcy5cbi8vIHRzbGludDpkaXNhYmxlOnN0cmlwLXByaXZhdGUtcHJvcGVydHktdW5kZXJzY29yZVxuXG5cbmltcG9ydCB7VGV4dEFyZWFDaGFyQ291bnRlciwgVGV4dEZpZWxkQmFzZSwgVGV4dEZpZWxkSW5wdXRNb2RlLCBUZXh0RmllbGRUeXBlfSBmcm9tICdAbWF0ZXJpYWwvbXdjLXRleHRmaWVsZC9td2MtdGV4dGZpZWxkLWJhc2UnO1xuaW1wb3J0IHtDb21wbGV4QXR0cmlidXRlQ29udmVydGVyLCBodG1sLCBUZW1wbGF0ZVJlc3VsdH0gZnJvbSAnbGl0JztcbmltcG9ydCB7cHJvcGVydHksIHF1ZXJ5fSBmcm9tICdsaXQvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQge2NsYXNzTWFwfSBmcm9tICdsaXQvZGlyZWN0aXZlcy9jbGFzcy1tYXAuanMnO1xuaW1wb3J0IHtpZkRlZmluZWR9IGZyb20gJ2xpdC9kaXJlY3RpdmVzL2lmLWRlZmluZWQuanMnO1xuaW1wb3J0IHtsaXZlfSBmcm9tICdsaXQvZGlyZWN0aXZlcy9saXZlLmpzJztcblxuZXhwb3J0IHtUZXh0QXJlYUNoYXJDb3VudGVyLCBUZXh0RmllbGRJbnB1dE1vZGUsIFRleHRGaWVsZFR5cGV9O1xuXG5jb25zdCBib29sZWFuT3JTdHJpbmdDb252ZXJ0ZXI6IENvbXBsZXhBdHRyaWJ1dGVDb252ZXJ0ZXI8Ym9vbGVhbnxzdHJpbmc+ID0ge1xuICBmcm9tQXR0cmlidXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgdG9BdHRyaWJ1dGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/ICcnIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKiBAc295Q29tcGF0aWJsZSAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRleHRBcmVhQmFzZSBleHRlbmRzIFRleHRGaWVsZEJhc2Uge1xuICBAcXVlcnkoJ3RleHRhcmVhJykgcHJvdGVjdGVkIG92ZXJyaWRlIGZvcm1FbGVtZW50ITogSFRNTElucHV0RWxlbWVudDtcblxuICBAcHJvcGVydHkoe3R5cGU6IE51bWJlcn0pIHJvd3MgPSAyO1xuXG4gIEBwcm9wZXJ0eSh7dHlwZTogTnVtYmVyfSkgY29scyA9IDIwO1xuXG4gIEBwcm9wZXJ0eSh7Y29udmVydGVyOiBib29sZWFuT3JTdHJpbmdDb252ZXJ0ZXJ9KVxuICBvdmVycmlkZSBjaGFyQ291bnRlcjogYm9vbGVhbnxUZXh0QXJlYUNoYXJDb3VudGVyID0gZmFsc2U7XG5cbiAgLyoqIEBzb3lUZW1wbGF0ZSAqL1xuICBvdmVycmlkZSByZW5kZXIoKTogVGVtcGxhdGVSZXN1bHQge1xuICAgIGNvbnN0IHNob3VsZFJlbmRlckNoYXJDb3VudGVyID0gdGhpcy5jaGFyQ291bnRlciAmJiB0aGlzLm1heExlbmd0aCAhPT0gLTE7XG4gICAgY29uc3Qgc2hvdWxkUmVuZGVySW50ZXJuYWxDaGFyQ291bnRlciA9XG4gICAgICAgIHNob3VsZFJlbmRlckNoYXJDb3VudGVyICYmIHRoaXMuY2hhckNvdW50ZXIgPT09ICdpbnRlcm5hbCc7XG4gICAgY29uc3Qgc2hvdWxkUmVuZGVyRXh0ZXJuYWxDaGFyQ291bnRlciA9XG4gICAgICAgIHNob3VsZFJlbmRlckNoYXJDb3VudGVyICYmICFzaG91bGRSZW5kZXJJbnRlcm5hbENoYXJDb3VudGVyO1xuICAgIGNvbnN0IHNob3VsZFJlbmRlckhlbHBlclRleHQgPSAhIXRoaXMuaGVscGVyIHx8ICEhdGhpcy52YWxpZGF0aW9uTWVzc2FnZSB8fFxuICAgICAgICBzaG91bGRSZW5kZXJFeHRlcm5hbENoYXJDb3VudGVyO1xuXG4gICAgLyoqIEBjbGFzc01hcCAqL1xuICAgIGNvbnN0IGNsYXNzZXMgPSB7XG4gICAgICAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCxcbiAgICAgICdtZGMtdGV4dC1maWVsZC0tbm8tbGFiZWwnOiAhdGhpcy5sYWJlbCxcbiAgICAgICdtZGMtdGV4dC1maWVsZC0tZmlsbGVkJzogIXRoaXMub3V0bGluZWQsXG4gICAgICAnbWRjLXRleHQtZmllbGQtLW91dGxpbmVkJzogdGhpcy5vdXRsaW5lZCxcbiAgICAgICdtZGMtdGV4dC1maWVsZC0tZW5kLWFsaWduZWQnOiB0aGlzLmVuZEFsaWduZWQsXG4gICAgICAnbWRjLXRleHQtZmllbGQtLXdpdGgtaW50ZXJuYWwtY291bnRlcic6IHNob3VsZFJlbmRlckludGVybmFsQ2hhckNvdW50ZXIsXG4gICAgfTtcblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPGxhYmVsIGNsYXNzPVwibWRjLXRleHQtZmllbGQgbWRjLXRleHQtZmllbGQtLXRleHRhcmVhICR7XG4gICAgICAgIGNsYXNzTWFwKGNsYXNzZXMpfVwiPlxuICAgICAgICAke3RoaXMucmVuZGVyUmlwcGxlKCl9XG4gICAgICAgICR7dGhpcy5vdXRsaW5lZCA/IHRoaXMucmVuZGVyT3V0bGluZSgpIDogdGhpcy5yZW5kZXJMYWJlbCgpfVxuICAgICAgICAke3RoaXMucmVuZGVySW5wdXQoKX1cbiAgICAgICAgJHt0aGlzLnJlbmRlckNoYXJDb3VudGVyKHNob3VsZFJlbmRlckludGVybmFsQ2hhckNvdW50ZXIpfVxuICAgICAgICAke3RoaXMucmVuZGVyTGluZVJpcHBsZSgpfVxuICAgICAgPC9sYWJlbD5cbiAgICAgICR7XG4gICAgICAgIHRoaXMucmVuZGVySGVscGVyVGV4dChcbiAgICAgICAgICAgIHNob3VsZFJlbmRlckhlbHBlclRleHQsIHNob3VsZFJlbmRlckV4dGVybmFsQ2hhckNvdW50ZXIpfVxuICAgIGA7XG4gIH1cblxuICAvKiogQHNveVRlbXBsYXRlICovXG4gIHByb3RlY3RlZCBvdmVycmlkZSByZW5kZXJJbnB1dCgpOiBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgY29uc3QgYXJpYUxhYmVsbGVkYnlPclVuZGVmID0gISF0aGlzLmxhYmVsID8gJ2xhYmVsJyA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtaW5PclVuZGVmID0gdGhpcy5taW5MZW5ndGggPT09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5taW5MZW5ndGg7XG4gICAgY29uc3QgbWF4T3JVbmRlZiA9IHRoaXMubWF4TGVuZ3RoID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMubWF4TGVuZ3RoO1xuICAgIGNvbnN0IGF1dG9jYXBpdGFsaXplT3JVbmRlZiA9IHRoaXMuYXV0b2NhcGl0YWxpemUgP1xuICAgICAgICAodGhpcy5hdXRvY2FwaXRhbGl6ZSBhcyAnb2ZmJyB8ICdub25lJyB8ICdvbicgfCAnc2VudGVuY2VzJyB8ICd3b3JkcycgfFxuICAgICAgICAgJ2NoYXJhY3RlcnMnIHwgJ29mZicgfCAnbm9uZScgfCAnb24nIHwgJ3NlbnRlbmNlcycgfCAnd29yZHMnIHxcbiAgICAgICAgICdjaGFyYWN0ZXJzJykgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgIGFyaWEtbGFiZWxsZWRieT0ke2lmRGVmaW5lZChhcmlhTGFiZWxsZWRieU9yVW5kZWYpfVxuICAgICAgICAgIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2lucHV0XCJcbiAgICAgICAgICAudmFsdWU9XCIke2xpdmUodGhpcy52YWx1ZSkgYXMgdW5rbm93biBhcyBzdHJpbmd9XCJcbiAgICAgICAgICByb3dzPVwiJHt0aGlzLnJvd3N9XCJcbiAgICAgICAgICBjb2xzPVwiJHt0aGlzLmNvbHN9XCJcbiAgICAgICAgICA/ZGlzYWJsZWQ9XCIke3RoaXMuZGlzYWJsZWR9XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIiR7dGhpcy5wbGFjZWhvbGRlcn1cIlxuICAgICAgICAgID9yZXF1aXJlZD1cIiR7dGhpcy5yZXF1aXJlZH1cIlxuICAgICAgICAgID9yZWFkb25seT1cIiR7dGhpcy5yZWFkT25seX1cIlxuICAgICAgICAgIG1pbmxlbmd0aD1cIiR7aWZEZWZpbmVkKG1pbk9yVW5kZWYpfVwiXG4gICAgICAgICAgbWF4bGVuZ3RoPVwiJHtpZkRlZmluZWQobWF4T3JVbmRlZil9XCJcbiAgICAgICAgICBuYW1lPVwiJHtpZkRlZmluZWQodGhpcy5uYW1lID09PSAnJyA/IHVuZGVmaW5lZCA6IHRoaXMubmFtZSl9XCJcbiAgICAgICAgICBpbnB1dG1vZGU9XCIke2lmRGVmaW5lZCh0aGlzLmlucHV0TW9kZSl9XCJcbiAgICAgICAgICBhdXRvY2FwaXRhbGl6ZT1cIiR7aWZEZWZpbmVkKGF1dG9jYXBpdGFsaXplT3JVbmRlZil9XCJcbiAgICAgICAgICBAaW5wdXQ9XCIke3RoaXMuaGFuZGxlSW5wdXRDaGFuZ2V9XCJcbiAgICAgICAgICBAYmx1cj1cIiR7dGhpcy5vbklucHV0Qmx1cn1cIj5cbiAgICAgIDwvdGV4dGFyZWE+YDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@material/mwc-textarea/mwc-textarea-base.js\n");

/***/ }),

/***/ "./node_modules/@material/mwc-textarea/mwc-textarea.css.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@material/mwc-textarea/mwc-textarea.css.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"styles\": () => (/* binding */ styles)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-LIcense-Identifier: Apache-2.0\n */\n\nconst styles = lit__WEBPACK_IMPORTED_MODULE_0__.css`.mdc-text-field{height:100%}.mdc-text-field__input{resize:none}`;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL213Yy10ZXh0YXJlYS9td2MtdGV4dGFyZWEuY3NzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7O0FBS0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvbXdjLXRleHRhcmVhLmNzcy50cz9hZWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTEljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7Y3NzfSBmcm9tICdsaXQnO1xuZXhwb3J0IGNvbnN0IHN0eWxlcyA9IGNzc2AubWRjLXRleHQtZmllbGR7aGVpZ2h0OjEwMCV9Lm1kYy10ZXh0LWZpZWxkX19pbnB1dHtyZXNpemU6bm9uZX1gO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@material/mwc-textarea/mwc-textarea.css.js\n");

/***/ }),

/***/ "./node_modules/@polymer/paper-item/paper-item-body.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polymer/paper-item/paper-item-body.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\n/* harmony import */ var _polymer_iron_flex_layout_iron_flex_layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/iron-flex-layout/iron-flex-layout.js */ \"./node_modules/@polymer/iron-flex-layout/iron-flex-layout.js\");\n/* harmony import */ var _polymer_paper_styles_default_theme_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/paper-styles/default-theme.js */ \"./node_modules/@polymer/paper-styles/default-theme.js\");\n/* harmony import */ var _polymer_paper_styles_default_theme_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_polymer_paper_styles_default_theme_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _polymer_paper_styles_typography_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/paper-styles/typography.js */ \"./node_modules/@polymer/paper-styles/typography.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/*\nUse `<paper-item-body>` in a `<paper-item>` or `<paper-icon-item>` to make two-\nor three- line items. It is a flex item that is a vertical flexbox.\n\n    <paper-item>\n      <paper-item-body two-line>\n        <div>Show your status</div>\n        <div secondary>Your status is visible to everyone</div>\n      </paper-item-body>\n    </paper-item>\n\nThe child elements with the `secondary` attribute is given secondary text\nstyling.\n\n### Styling\n\nThe following custom properties and mixins are available for styling:\n\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-item-body-two-line-min-height` | Minimum height of a two-line item | `72px`\n`--paper-item-body-three-line-min-height` | Minimum height of a three-line item | `88px`\n`--paper-item-body-secondary-color` | Foreground color for the `secondary` area | `--secondary-text-color`\n`--paper-item-body-secondary` | Mixin applied to the `secondary` area | `{}`\n\n*/\n\n(0,_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_4__.Polymer)({\n  _template: _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_5__.html`\n    <style>\n      :host {\n        overflow: hidden; /* needed for text-overflow: ellipsis to work on ff */\n        @apply --layout-vertical;\n        @apply --layout-center-justified;\n        @apply --layout-flex;\n      }\n\n      :host([two-line]) {\n        min-height: var(--paper-item-body-two-line-min-height, 72px);\n      }\n\n      :host([three-line]) {\n        min-height: var(--paper-item-body-three-line-min-height, 88px);\n      }\n\n      :host > ::slotted(*) {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n      }\n\n      :host > ::slotted([secondary]) {\n        @apply --paper-font-body1;\n\n        color: var(--paper-item-body-secondary-color, var(--secondary-text-color));\n\n        @apply --paper-item-body-secondary;\n      }\n    </style>\n\n    <slot></slot>\n`,\n  is: 'paper-item-body'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaXRlbS9wYXBlci1pdGVtLWJvZHkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBcENBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pdGVtL3BhcGVyLWl0ZW0tYm9keS5qcz85YzQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlXG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dCBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhc1xucGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudFxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItbGVnYWN5LmpzJztcblxuaW1wb3J0ICdAcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMnO1xuaW1wb3J0ICdAcG9seW1lci9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyc7XG5pbXBvcnQgJ0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy90eXBvZ3JhcGh5LmpzJztcbmltcG9ydCB7UG9seW1lcn0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHtodG1sfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZy5qcyc7XG5cbi8qXG5Vc2UgYDxwYXBlci1pdGVtLWJvZHk+YCBpbiBhIGA8cGFwZXItaXRlbT5gIG9yIGA8cGFwZXItaWNvbi1pdGVtPmAgdG8gbWFrZSB0d28tXG5vciB0aHJlZS0gbGluZSBpdGVtcy4gSXQgaXMgYSBmbGV4IGl0ZW0gdGhhdCBpcyBhIHZlcnRpY2FsIGZsZXhib3guXG5cbiAgICA8cGFwZXItaXRlbT5cbiAgICAgIDxwYXBlci1pdGVtLWJvZHkgdHdvLWxpbmU+XG4gICAgICAgIDxkaXY+U2hvdyB5b3VyIHN0YXR1czwvZGl2PlxuICAgICAgICA8ZGl2IHNlY29uZGFyeT5Zb3VyIHN0YXR1cyBpcyB2aXNpYmxlIHRvIGV2ZXJ5b25lPC9kaXY+XG4gICAgICA8L3BhcGVyLWl0ZW0tYm9keT5cbiAgICA8L3BhcGVyLWl0ZW0+XG5cblRoZSBjaGlsZCBlbGVtZW50cyB3aXRoIHRoZSBgc2Vjb25kYXJ5YCBhdHRyaWJ1dGUgaXMgZ2l2ZW4gc2Vjb25kYXJ5IHRleHRcbnN0eWxpbmcuXG5cbiMjIyBTdHlsaW5nXG5cblRoZSBmb2xsb3dpbmcgY3VzdG9tIHByb3BlcnRpZXMgYW5kIG1peGlucyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuXG5DdXN0b20gcHJvcGVydHkgfCBEZXNjcmlwdGlvbiB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tXG5gLS1wYXBlci1pdGVtLWJvZHktdHdvLWxpbmUtbWluLWhlaWdodGAgfCBNaW5pbXVtIGhlaWdodCBvZiBhIHR3by1saW5lIGl0ZW0gfCBgNzJweGBcbmAtLXBhcGVyLWl0ZW0tYm9keS10aHJlZS1saW5lLW1pbi1oZWlnaHRgIHwgTWluaW11bSBoZWlnaHQgb2YgYSB0aHJlZS1saW5lIGl0ZW0gfCBgODhweGBcbmAtLXBhcGVyLWl0ZW0tYm9keS1zZWNvbmRhcnktY29sb3JgIHwgRm9yZWdyb3VuZCBjb2xvciBmb3IgdGhlIGBzZWNvbmRhcnlgIGFyZWEgfCBgLS1zZWNvbmRhcnktdGV4dC1jb2xvcmBcbmAtLXBhcGVyLWl0ZW0tYm9keS1zZWNvbmRhcnlgIHwgTWl4aW4gYXBwbGllZCB0byB0aGUgYHNlY29uZGFyeWAgYXJlYSB8IGB7fWBcblxuKi9cblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGh0bWxgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuOyAvKiBuZWVkZWQgZm9yIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzIHRvIHdvcmsgb24gZmYgKi9cbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LXZlcnRpY2FsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZsZXg7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFt0d28tbGluZV0pIHtcbiAgICAgICAgbWluLWhlaWdodDogdmFyKC0tcGFwZXItaXRlbS1ib2R5LXR3by1saW5lLW1pbi1oZWlnaHQsIDcycHgpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbdGhyZWUtbGluZV0pIHtcbiAgICAgICAgbWluLWhlaWdodDogdmFyKC0tcGFwZXItaXRlbS1ib2R5LXRocmVlLWxpbmUtbWluLWhlaWdodCwgODhweCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKCopIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKFtzZWNvbmRhcnldKSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtYm9keTE7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWl0ZW0tYm9keS1zZWNvbmRhcnktY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaXRlbS1ib2R5LXNlY29uZGFyeTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuYCxcblxuICBpczogJ3BhcGVyLWl0ZW0tYm9keSdcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@polymer/paper-item/paper-item-body.js\n");

/***/ }),

/***/ "./node_modules/@polymer/paper-tooltip/paper-tooltip.js":
/*!**************************************************************!*\
  !*** ./node_modules/@polymer/paper-tooltip/paper-tooltip.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer.dom.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer.dom.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n/**\nMaterial design:\n[Tooltips](https://www.google.com/design/spec/components/tooltips.html)\n`<paper-tooltip>` is a label that appears on hover and focus when the user\nhovers over an element with the cursor or with the keyboard. It will be centered\nto an anchor element specified in the `for` attribute, or, if that doesn't\nexist, centered to the parent node containing it.\nExample:\n    <div style=\"display:inline-block\">\n      <button>Click me!</button>\n      <paper-tooltip>Tooltip text</paper-tooltip>\n    </div>\n    <div>\n      <button id=\"btn\">Click me!</button>\n      <paper-tooltip for=\"btn\">Tooltip text</paper-tooltip>\n    </div>\nThe tooltip can be positioned on the top|bottom|left|right of the anchor using\nthe `position` attribute. The default position is bottom.\n    <paper-tooltip for=\"btn\" position=\"left\">Tooltip text</paper-tooltip>\n    <paper-tooltip for=\"btn\" position=\"top\">Tooltip text</paper-tooltip>\n\n### Styling\nThe following custom properties and mixins are available for styling:\nCustom property | Description | Default\n----------------|-------------|----------\n`--paper-tooltip-background` | The background color of the tooltip | `#616161`\n`--paper-tooltip-opacity` | The opacity of the tooltip | `0.9`\n`--paper-tooltip-text-color` | The text color of the tooltip | `white`\n`--paper-tooltip` | Mixin applied to the tooltip | `{}`\n`--paper-tooltip-delay-in` | Delay before tooltip starts to fade in | `500`\n`--paper-tooltip-delay-out` | Delay before tooltip starts to fade out | `0`\n`--paper-tooltip-duration-in` | Timing for animation when showing tooltip | `500`\n`--paper-tooltip-duration-out` | Timing for animation when hiding tooltip | `0`\n`--paper-tooltip-animation` | Mixin applied to the tooltip animation | `{}`\n@group Paper Elements\n@element paper-tooltip\n@demo demo/index.html\n*/\n\n(0,_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_1__.Polymer)({\n  _template: _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_3__.html`\n    <style>\n      :host {\n        display: block;\n        position: absolute;\n        outline: none;\n        z-index: 1002;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        -webkit-user-select: none;\n        user-select: none;\n        cursor: default;\n      }\n\n      #tooltip {\n        display: block;\n        outline: none;\n        @apply --paper-font-common-base;\n        font-size: 10px;\n        line-height: 1;\n        background-color: var(--paper-tooltip-background, #616161);\n        color: var(--paper-tooltip-text-color, white);\n        padding: 8px;\n        border-radius: 2px;\n        @apply --paper-tooltip;\n      }\n\n      @keyframes keyFrameScaleUp {\n        0% {\n          transform: scale(0.0);\n        }\n        100% {\n          transform: scale(1.0);\n        }\n      }\n\n      @keyframes keyFrameScaleDown {\n        0% {\n          transform: scale(1.0);\n        }\n        100% {\n          transform: scale(0.0);\n        }\n      }\n\n      @keyframes keyFrameFadeInOpacity {\n        0% {\n          opacity: 0;\n        }\n        100% {\n          opacity: var(--paper-tooltip-opacity, 0.9);\n        }\n      }\n\n      @keyframes keyFrameFadeOutOpacity {\n        0% {\n          opacity: var(--paper-tooltip-opacity, 0.9);\n        }\n        100% {\n          opacity: 0;\n        }\n      }\n\n      @keyframes keyFrameSlideDownIn {\n        0% {\n          transform: translateY(-2000px);\n          opacity: 0;\n        }\n        10% {\n          opacity: 0.2;\n        }\n        100% {\n          transform: translateY(0);\n          opacity: var(--paper-tooltip-opacity, 0.9);\n        }\n      }\n\n      @keyframes keyFrameSlideDownOut {\n        0% {\n          transform: translateY(0);\n          opacity: var(--paper-tooltip-opacity, 0.9);\n        }\n        10% {\n          opacity: 0.2;\n        }\n        100% {\n          transform: translateY(-2000px);\n          opacity: 0;\n        }\n      }\n\n      .fade-in-animation {\n        opacity: 0;\n        animation-delay: var(--paper-tooltip-delay-in, 500ms);\n        animation-name: keyFrameFadeInOpacity;\n        animation-iteration-count: 1;\n        animation-timing-function: ease-in;\n        animation-duration: var(--paper-tooltip-duration-in, 500ms);\n        animation-fill-mode: forwards;\n        @apply --paper-tooltip-animation;\n      }\n\n      .fade-out-animation {\n        opacity: var(--paper-tooltip-opacity, 0.9);\n        animation-delay: var(--paper-tooltip-delay-out, 0ms);\n        animation-name: keyFrameFadeOutOpacity;\n        animation-iteration-count: 1;\n        animation-timing-function: ease-in;\n        animation-duration: var(--paper-tooltip-duration-out, 500ms);\n        animation-fill-mode: forwards;\n        @apply --paper-tooltip-animation;\n      }\n\n      .scale-up-animation {\n        transform: scale(0);\n        opacity: var(--paper-tooltip-opacity, 0.9);\n        animation-delay: var(--paper-tooltip-delay-in, 500ms);\n        animation-name: keyFrameScaleUp;\n        animation-iteration-count: 1;\n        animation-timing-function: ease-in;\n        animation-duration: var(--paper-tooltip-duration-in, 500ms);\n        animation-fill-mode: forwards;\n        @apply --paper-tooltip-animation;\n      }\n\n      .scale-down-animation {\n        transform: scale(1);\n        opacity: var(--paper-tooltip-opacity, 0.9);\n        animation-delay: var(--paper-tooltip-delay-out, 500ms);\n        animation-name: keyFrameScaleDown;\n        animation-iteration-count: 1;\n        animation-timing-function: ease-in;\n        animation-duration: var(--paper-tooltip-duration-out, 500ms);\n        animation-fill-mode: forwards;\n        @apply --paper-tooltip-animation;\n      }\n\n      .slide-down-animation {\n        transform: translateY(-2000px);\n        opacity: 0;\n        animation-delay: var(--paper-tooltip-delay-out, 500ms);\n        animation-name: keyFrameSlideDownIn;\n        animation-iteration-count: 1;\n        animation-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);\n        animation-duration: var(--paper-tooltip-duration-out, 500ms);\n        animation-fill-mode: forwards;\n        @apply --paper-tooltip-animation;\n      }\n\n      .slide-down-animation-out {\n        transform: translateY(0);\n        opacity: var(--paper-tooltip-opacity, 0.9);\n        animation-delay: var(--paper-tooltip-delay-out, 500ms);\n        animation-name: keyFrameSlideDownOut;\n        animation-iteration-count: 1;\n        animation-timing-function: cubic-bezier(0.4, 0.0, 1, 1);\n        animation-duration: var(--paper-tooltip-duration-out, 500ms);\n        animation-fill-mode: forwards;\n        @apply --paper-tooltip-animation;\n      }\n\n      .cancel-animation {\n        animation-delay: -30s !important;\n      }\n\n      /* Thanks IE 10. */\n\n      .hidden {\n        display: none !important;\n      }\n    </style>\n\n    <div id=\"tooltip\" class=\"hidden\">\n      <slot></slot>\n    </div>\n`,\n  is: 'paper-tooltip',\n  hostAttributes: {\n    role: 'tooltip',\n    tabindex: -1\n  },\n  properties: {\n    /**\n     * The id of the element that the tooltip is anchored to. This element\n     * must be a sibling of the tooltip. If this property is not set,\n     * then the tooltip will be centered to the parent node containing it.\n     */\n    for: {\n      type: String,\n      observer: '_findTarget'\n    },\n\n    /**\n     * Set this to true if you want to manually control when the tooltip\n     * is shown or hidden.\n     */\n    manualMode: {\n      type: Boolean,\n      value: false,\n      observer: '_manualModeChanged'\n    },\n\n    /**\n     * Positions the tooltip to the top, right, bottom, left of its content.\n     */\n    position: {\n      type: String,\n      value: 'bottom'\n    },\n\n    /**\n     * If true, no parts of the tooltip will ever be shown offscreen.\n     */\n    fitToVisibleBounds: {\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * The spacing between the top of the tooltip and the element it is\n     * anchored to.\n     */\n    offset: {\n      type: Number,\n      value: 14\n    },\n\n    /**\n     * This property is deprecated, but left over so that it doesn't\n     * break exiting code. Please use `offset` instead. If both `offset` and\n     * `marginTop` are provided, `marginTop` will be ignored.\n     * @deprecated since version 1.0.3\n     */\n    marginTop: {\n      type: Number,\n      value: 14\n    },\n\n    /**\n     * The delay that will be applied before the `entry` animation is\n     * played when showing the tooltip.\n     */\n    animationDelay: {\n      type: Number,\n      value: 500,\n      observer: '_delayChange'\n    },\n\n    /**\n     * The animation that will be played on entry.  This replaces the\n     * deprecated animationConfig.  Entries here will override the\n     * animationConfig settings.  You can enter your own animation\n     * by setting it to the css class name.\n     */\n    animationEntry: {\n      type: String,\n      value: ''\n    },\n\n    /**\n     * The animation that will be played on exit.  This replaces the\n     * deprecated animationConfig.  Entries here will override the\n     * animationConfig settings.  You can enter your own animation\n     * by setting it to the css class name.\n     */\n    animationExit: {\n      type: String,\n      value: ''\n    },\n\n    /**\n     * This property is deprecated.  Use --paper-tooltip-animation to change the\n     * animation. The entry and exit animations that will be played when showing\n     * and hiding the tooltip. If you want to override this, you must ensure\n     * that your animationConfig has the exact format below.\n     * @deprecated since version\n     *\n     * The entry and exit animations that will be played when showing and\n     * hiding the tooltip. If you want to override this, you must ensure\n     * that your animationConfig has the exact format below.\n     */\n    animationConfig: {\n      type: Object,\n      value: function () {\n        return {\n          'entry': [{\n            name: 'fade-in-animation',\n            node: this,\n            timing: {\n              delay: 0\n            }\n          }],\n          'exit': [{\n            name: 'fade-out-animation',\n            node: this\n          }]\n        };\n      }\n    },\n    _showing: {\n      type: Boolean,\n      value: false\n    }\n  },\n  listeners: {\n    'webkitAnimationEnd': '_onAnimationEnd'\n  },\n\n  /**\n   * Returns the target element that this tooltip is anchored to. It is\n   * either the element given by the `for` attribute, or the immediate parent\n   * of the tooltip.\n   *\n   * @type {Node}\n   */\n  get target() {\n    var parentNode = (0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_2__.dom)(this).parentNode; // If the parentNode is a document fragment, then we need to use the host.\n\n    var ownerRoot = (0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_2__.dom)(this).getOwnerRoot();\n    var target;\n\n    if (this.for) {\n      target = (0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_2__.dom)(ownerRoot).querySelector('#' + this.for);\n    } else {\n      target = parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE ? ownerRoot.host : parentNode;\n    }\n\n    return target;\n  },\n\n  /**\n   * @return {void}\n   */\n  attached: function () {\n    this._findTarget();\n  },\n\n  /**\n   * @return {void}\n   */\n  detached: function () {\n    if (!this.manualMode) this._removeListeners();\n  },\n\n  /**\n   * Replaces Neon-Animation playAnimation - just calls show and hide.\n   * @deprecated Use show and hide instead.\n   * @param {string} type Either `entry` or `exit`\n   */\n  playAnimation: function (type) {\n    if (type === 'entry') {\n      this.show();\n    } else if (type === 'exit') {\n      this.hide();\n    }\n  },\n\n  /**\n   * Cancels the animation and either fully shows or fully hides tooltip\n   */\n  cancelAnimation: function () {\n    // Short-cut and cancel all animations and hide\n    this.$.tooltip.classList.add('cancel-animation');\n  },\n\n  /**\n   * Shows the tooltip programatically\n   * @return {void}\n   */\n  show: function () {\n    // If the tooltip is already showing, there's nothing to do.\n    if (this._showing) return;\n\n    if ((0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_2__.dom)(this).textContent.trim() === '') {\n      // Check if effective children are also empty\n      var allChildrenEmpty = true;\n      var effectiveChildren = (0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_2__.dom)(this).getEffectiveChildNodes();\n\n      for (var i = 0; i < effectiveChildren.length; i++) {\n        if (effectiveChildren[i].textContent.trim() !== '') {\n          allChildrenEmpty = false;\n          break;\n        }\n      }\n\n      if (allChildrenEmpty) {\n        return;\n      }\n    }\n\n    this._showing = true;\n    this.$.tooltip.classList.remove('hidden');\n    this.$.tooltip.classList.remove('cancel-animation');\n    this.$.tooltip.classList.remove(this._getAnimationType('exit'));\n    this.updatePosition();\n    this._animationPlaying = true;\n    this.$.tooltip.classList.add(this._getAnimationType('entry'));\n  },\n\n  /**\n   * Hides the tooltip programatically\n   * @return {void}\n   */\n  hide: function () {\n    // If the tooltip is already hidden, there's nothing to do.\n    if (!this._showing) {\n      return;\n    } // If the entry animation is still playing, don't try to play the exit\n    // animation since this will reset the opacity to 1. Just end the animation.\n\n\n    if (this._animationPlaying) {\n      this._showing = false;\n\n      this._cancelAnimation();\n\n      return;\n    } else {\n      // Play Exit Animation\n      this._onAnimationFinish();\n    }\n\n    this._showing = false;\n    this._animationPlaying = true;\n  },\n\n  /**\n   * @return {void}\n   */\n  updatePosition: function () {\n    if (!this._target || !this.offsetParent) return;\n    var offset = this.offset; // If a marginTop has been provided by the user (pre 1.0.3), use it.\n\n    if (this.marginTop != 14 && this.offset == 14) offset = this.marginTop;\n    var parentRect = this.offsetParent.getBoundingClientRect();\n\n    var targetRect = this._target.getBoundingClientRect();\n\n    var thisRect = this.getBoundingClientRect();\n    var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;\n    var verticalCenterOffset = (targetRect.height - thisRect.height) / 2;\n    var targetLeft = targetRect.left - parentRect.left;\n    var targetTop = targetRect.top - parentRect.top;\n    var tooltipLeft, tooltipTop;\n\n    switch (this.position) {\n      case 'top':\n        tooltipLeft = targetLeft + horizontalCenterOffset;\n        tooltipTop = targetTop - thisRect.height - offset;\n        break;\n\n      case 'bottom':\n        tooltipLeft = targetLeft + horizontalCenterOffset;\n        tooltipTop = targetTop + targetRect.height + offset;\n        break;\n\n      case 'left':\n        tooltipLeft = targetLeft - thisRect.width - offset;\n        tooltipTop = targetTop + verticalCenterOffset;\n        break;\n\n      case 'right':\n        tooltipLeft = targetLeft + targetRect.width + offset;\n        tooltipTop = targetTop + verticalCenterOffset;\n        break;\n    } // TODO(noms): This should use IronFitBehavior if possible.\n\n\n    if (this.fitToVisibleBounds) {\n      // Clip the left/right side\n      if (parentRect.left + tooltipLeft + thisRect.width > window.innerWidth) {\n        this.style.right = '0px';\n        this.style.left = 'auto';\n      } else {\n        this.style.left = Math.max(0, tooltipLeft) + 'px';\n        this.style.right = 'auto';\n      } // Clip the top/bottom side.\n\n\n      if (parentRect.top + tooltipTop + thisRect.height > window.innerHeight) {\n        this.style.bottom = parentRect.height - targetTop + offset + 'px';\n        this.style.top = 'auto';\n      } else {\n        this.style.top = Math.max(-parentRect.top, tooltipTop) + 'px';\n        this.style.bottom = 'auto';\n      }\n    } else {\n      this.style.left = tooltipLeft + 'px';\n      this.style.top = tooltipTop + 'px';\n    }\n  },\n  _addListeners: function () {\n    if (this._target) {\n      this.listen(this._target, 'mouseenter', 'show');\n      this.listen(this._target, 'focus', 'show');\n      this.listen(this._target, 'mouseleave', 'hide');\n      this.listen(this._target, 'blur', 'hide');\n      this.listen(this._target, 'tap', 'hide');\n    }\n\n    this.listen(this.$.tooltip, 'animationend', '_onAnimationEnd');\n    this.listen(this, 'mouseenter', 'hide');\n  },\n  _findTarget: function () {\n    if (!this.manualMode) this._removeListeners();\n    this._target = this.target;\n    if (!this.manualMode) this._addListeners();\n  },\n  _delayChange: function (newValue) {\n    // Only Update delay if different value set\n    if (newValue !== 500) {\n      this.updateStyles({\n        '--paper-tooltip-delay-in': newValue + 'ms'\n      });\n    }\n  },\n  _manualModeChanged: function () {\n    if (this.manualMode) this._removeListeners();else this._addListeners();\n  },\n  _cancelAnimation: function () {\n    // Short-cut and cancel all animations and hide\n    this.$.tooltip.classList.remove(this._getAnimationType('entry'));\n    this.$.tooltip.classList.remove(this._getAnimationType('exit'));\n    this.$.tooltip.classList.remove('cancel-animation');\n    this.$.tooltip.classList.add('hidden');\n  },\n  _onAnimationFinish: function () {\n    if (this._showing) {\n      this.$.tooltip.classList.remove(this._getAnimationType('entry'));\n      this.$.tooltip.classList.remove('cancel-animation');\n      this.$.tooltip.classList.add(this._getAnimationType('exit'));\n    }\n  },\n  _onAnimationEnd: function () {\n    // If no longer showing add class hidden to completely hide tooltip\n    this._animationPlaying = false;\n\n    if (!this._showing) {\n      this.$.tooltip.classList.remove(this._getAnimationType('exit'));\n      this.$.tooltip.classList.add('hidden');\n    }\n  },\n  _getAnimationType: function (type) {\n    // These properties have priority over animationConfig values\n    if (type === 'entry' && this.animationEntry !== '') {\n      return this.animationEntry;\n    }\n\n    if (type === 'exit' && this.animationExit !== '') {\n      return this.animationExit;\n    } // If no results then return the legacy value from animationConfig\n\n\n    if (this.animationConfig[type] && typeof this.animationConfig[type][0].name === 'string') {\n      // Checking Timing and Update if necessary - Legacy for animationConfig\n      if (this.animationConfig[type][0].timing && this.animationConfig[type][0].timing.delay && this.animationConfig[type][0].timing.delay !== 0) {\n        var timingDelay = this.animationConfig[type][0].timing.delay; // Has Timing Change - Update CSS\n\n        if (type === 'entry') {\n          this.updateStyles({\n            '--paper-tooltip-delay-in': timingDelay + 'ms'\n          });\n        } else if (type === 'exit') {\n          this.updateStyles({\n            '--paper-tooltip-delay-out': timingDelay + 'ms'\n          });\n        }\n      }\n\n      return this.animationConfig[type][0].name;\n    }\n  },\n  _removeListeners: function () {\n    if (this._target) {\n      this.unlisten(this._target, 'mouseenter', 'show');\n      this.unlisten(this._target, 'focus', 'show');\n      this.unlisten(this._target, 'mouseleave', 'hide');\n      this.unlisten(this._target, 'blur', 'hide');\n      this.unlisten(this._target, 'tap', 'hide');\n    }\n\n    this.unlisten(this.$.tooltip, 'animationend', '_onAnimationEnd');\n    this.unlisten(this, 'mouseenter', 'hide');\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItdG9vbHRpcC9wYXBlci10b29sdGlwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFLQTtBQVJBO0FBVUE7QUFBQTtBQUFBO0FBQUE7QUF4RUE7QUEyRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUVBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQXBoQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXRvb2x0aXAvcGFwZXItdG9vbHRpcC5qcz9lYTllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNSBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbmh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlXG5mb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dCBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhc1xucGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc28gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudFxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItbGVnYWN5LmpzJztcblxuaW1wb3J0IHtQb2x5bWVyfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQge2RvbX0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcbmltcG9ydCB7aHRtbH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaHRtbC10YWcuanMnO1xuXG4vKipcbk1hdGVyaWFsIGRlc2lnbjpcbltUb29sdGlwc10oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL3Rvb2x0aXBzLmh0bWwpXG5gPHBhcGVyLXRvb2x0aXA+YCBpcyBhIGxhYmVsIHRoYXQgYXBwZWFycyBvbiBob3ZlciBhbmQgZm9jdXMgd2hlbiB0aGUgdXNlclxuaG92ZXJzIG92ZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBjdXJzb3Igb3Igd2l0aCB0aGUga2V5Ym9hcmQuIEl0IHdpbGwgYmUgY2VudGVyZWRcbnRvIGFuIGFuY2hvciBlbGVtZW50IHNwZWNpZmllZCBpbiB0aGUgYGZvcmAgYXR0cmlidXRlLCBvciwgaWYgdGhhdCBkb2Vzbid0XG5leGlzdCwgY2VudGVyZWQgdG8gdGhlIHBhcmVudCBub2RlIGNvbnRhaW5pbmcgaXQuXG5FeGFtcGxlOlxuICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9ja1wiPlxuICAgICAgPGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj5cbiAgICAgIDxwYXBlci10b29sdGlwPlRvb2x0aXAgdGV4dDwvcGFwZXItdG9vbHRpcD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2PlxuICAgICAgPGJ1dHRvbiBpZD1cImJ0blwiPkNsaWNrIG1lITwvYnV0dG9uPlxuICAgICAgPHBhcGVyLXRvb2x0aXAgZm9yPVwiYnRuXCI+VG9vbHRpcCB0ZXh0PC9wYXBlci10b29sdGlwPlxuICAgIDwvZGl2PlxuVGhlIHRvb2x0aXAgY2FuIGJlIHBvc2l0aW9uZWQgb24gdGhlIHRvcHxib3R0b218bGVmdHxyaWdodCBvZiB0aGUgYW5jaG9yIHVzaW5nXG50aGUgYHBvc2l0aW9uYCBhdHRyaWJ1dGUuIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIGJvdHRvbS5cbiAgICA8cGFwZXItdG9vbHRpcCBmb3I9XCJidG5cIiBwb3NpdGlvbj1cImxlZnRcIj5Ub29sdGlwIHRleHQ8L3BhcGVyLXRvb2x0aXA+XG4gICAgPHBhcGVyLXRvb2x0aXAgZm9yPVwiYnRuXCIgcG9zaXRpb249XCJ0b3BcIj5Ub29sdGlwIHRleHQ8L3BhcGVyLXRvb2x0aXA+XG5cbiMjIyBTdHlsaW5nXG5UaGUgZm9sbG93aW5nIGN1c3RvbSBwcm9wZXJ0aWVzIGFuZCBtaXhpbnMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcbkN1c3RvbSBwcm9wZXJ0eSB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdFxuLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS1cbmAtLXBhcGVyLXRvb2x0aXAtYmFja2dyb3VuZGAgfCBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgdG9vbHRpcCB8IGAjNjE2MTYxYFxuYC0tcGFwZXItdG9vbHRpcC1vcGFjaXR5YCB8IFRoZSBvcGFjaXR5IG9mIHRoZSB0b29sdGlwIHwgYDAuOWBcbmAtLXBhcGVyLXRvb2x0aXAtdGV4dC1jb2xvcmAgfCBUaGUgdGV4dCBjb2xvciBvZiB0aGUgdG9vbHRpcCB8IGB3aGl0ZWBcbmAtLXBhcGVyLXRvb2x0aXBgIHwgTWl4aW4gYXBwbGllZCB0byB0aGUgdG9vbHRpcCB8IGB7fWBcbmAtLXBhcGVyLXRvb2x0aXAtZGVsYXktaW5gIHwgRGVsYXkgYmVmb3JlIHRvb2x0aXAgc3RhcnRzIHRvIGZhZGUgaW4gfCBgNTAwYFxuYC0tcGFwZXItdG9vbHRpcC1kZWxheS1vdXRgIHwgRGVsYXkgYmVmb3JlIHRvb2x0aXAgc3RhcnRzIHRvIGZhZGUgb3V0IHwgYDBgXG5gLS1wYXBlci10b29sdGlwLWR1cmF0aW9uLWluYCB8IFRpbWluZyBmb3IgYW5pbWF0aW9uIHdoZW4gc2hvd2luZyB0b29sdGlwIHwgYDUwMGBcbmAtLXBhcGVyLXRvb2x0aXAtZHVyYXRpb24tb3V0YCB8IFRpbWluZyBmb3IgYW5pbWF0aW9uIHdoZW4gaGlkaW5nIHRvb2x0aXAgfCBgMGBcbmAtLXBhcGVyLXRvb2x0aXAtYW5pbWF0aW9uYCB8IE1peGluIGFwcGxpZWQgdG8gdGhlIHRvb2x0aXAgYW5pbWF0aW9uIHwgYHt9YFxuQGdyb3VwIFBhcGVyIEVsZW1lbnRzXG5AZWxlbWVudCBwYXBlci10b29sdGlwXG5AZGVtbyBkZW1vL2luZGV4Lmh0bWxcbiovXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBodG1sYFxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgei1pbmRleDogMTAwMjtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgICAgfVxuXG4gICAgICAjdG9vbHRpcCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBmb250LXNpemU6IDEwcHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b29sdGlwLWJhY2tncm91bmQsICM2MTYxNjEpO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9vbHRpcC10ZXh0LWNvbG9yLCB3aGl0ZSk7XG4gICAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgICBAYXBwbHkgLS1wYXBlci10b29sdGlwO1xuICAgICAgfVxuXG4gICAgICBAa2V5ZnJhbWVzIGtleUZyYW1lU2NhbGVVcCB7XG4gICAgICAgIDAlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgMTAwJSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEBrZXlmcmFtZXMga2V5RnJhbWVTY2FsZURvd24ge1xuICAgICAgICAwJSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjApO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC4wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBAa2V5ZnJhbWVzIGtleUZyYW1lRmFkZUluT3BhY2l0eSB7XG4gICAgICAgIDAlIHtcbiAgICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIG9wYWNpdHk6IHZhcigtLXBhcGVyLXRvb2x0aXAtb3BhY2l0eSwgMC45KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBAa2V5ZnJhbWVzIGtleUZyYW1lRmFkZU91dE9wYWNpdHkge1xuICAgICAgICAwJSB7XG4gICAgICAgICAgb3BhY2l0eTogdmFyKC0tcGFwZXItdG9vbHRpcC1vcGFjaXR5LCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgQGtleWZyYW1lcyBrZXlGcmFtZVNsaWRlRG93bkluIHtcbiAgICAgICAgMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMjAwMHB4KTtcbiAgICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB9XG4gICAgICAgIDEwJSB7XG4gICAgICAgICAgb3BhY2l0eTogMC4yO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcbiAgICAgICAgICBvcGFjaXR5OiB2YXIoLS1wYXBlci10b29sdGlwLW9wYWNpdHksIDAuOSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgQGtleWZyYW1lcyBrZXlGcmFtZVNsaWRlRG93bk91dCB7XG4gICAgICAgIDAlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XG4gICAgICAgICAgb3BhY2l0eTogdmFyKC0tcGFwZXItdG9vbHRpcC1vcGFjaXR5LCAwLjkpO1xuICAgICAgICB9XG4gICAgICAgIDEwJSB7XG4gICAgICAgICAgb3BhY2l0eTogMC4yO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMjAwMHB4KTtcbiAgICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC5mYWRlLWluLWFuaW1hdGlvbiB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tcGFwZXItdG9vbHRpcC1kZWxheS1pbiwgNTAwbXMpO1xuICAgICAgICBhbmltYXRpb24tbmFtZToga2V5RnJhbWVGYWRlSW5PcGFjaXR5O1xuICAgICAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xuICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xuICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLXBhcGVyLXRvb2x0aXAtZHVyYXRpb24taW4sIDUwMG1zKTtcbiAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvb2x0aXAtYW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICAuZmFkZS1vdXQtYW5pbWF0aW9uIHtcbiAgICAgICAgb3BhY2l0eTogdmFyKC0tcGFwZXItdG9vbHRpcC1vcGFjaXR5LCAwLjkpO1xuICAgICAgICBhbmltYXRpb24tZGVsYXk6IHZhcigtLXBhcGVyLXRvb2x0aXAtZGVsYXktb3V0LCAwbXMpO1xuICAgICAgICBhbmltYXRpb24tbmFtZToga2V5RnJhbWVGYWRlT3V0T3BhY2l0eTtcbiAgICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogMTtcbiAgICAgICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbjtcbiAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiB2YXIoLS1wYXBlci10b29sdGlwLWR1cmF0aW9uLW91dCwgNTAwbXMpO1xuICAgICAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9vbHRpcC1hbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIC5zY2FsZS11cC1hbmltYXRpb24ge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xuICAgICAgICBvcGFjaXR5OiB2YXIoLS1wYXBlci10b29sdGlwLW9wYWNpdHksIDAuOSk7XG4gICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tcGFwZXItdG9vbHRpcC1kZWxheS1pbiwgNTAwbXMpO1xuICAgICAgICBhbmltYXRpb24tbmFtZToga2V5RnJhbWVTY2FsZVVwO1xuICAgICAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xuICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xuICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLXBhcGVyLXRvb2x0aXAtZHVyYXRpb24taW4sIDUwMG1zKTtcbiAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvb2x0aXAtYW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICAuc2NhbGUtZG93bi1hbmltYXRpb24ge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICAgICAgICBvcGFjaXR5OiB2YXIoLS1wYXBlci10b29sdGlwLW9wYWNpdHksIDAuOSk7XG4gICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tcGFwZXItdG9vbHRpcC1kZWxheS1vdXQsIDUwMG1zKTtcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGtleUZyYW1lU2NhbGVEb3duO1xuICAgICAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xuICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluO1xuICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLXBhcGVyLXRvb2x0aXAtZHVyYXRpb24tb3V0LCA1MDBtcyk7XG4gICAgICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IGZvcndhcmRzO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci10b29sdGlwLWFuaW1hdGlvbjtcbiAgICAgIH1cblxuICAgICAgLnNsaWRlLWRvd24tYW5pbWF0aW9uIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0yMDAwcHgpO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBhbmltYXRpb24tZGVsYXk6IHZhcigtLXBhcGVyLXRvb2x0aXAtZGVsYXktb3V0LCA1MDBtcyk7XG4gICAgICAgIGFuaW1hdGlvbi1uYW1lOiBrZXlGcmFtZVNsaWRlRG93bkluO1xuICAgICAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xuICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4wLCAwLjAsIDAuMiwgMSk7XG4gICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogdmFyKC0tcGFwZXItdG9vbHRpcC1kdXJhdGlvbi1vdXQsIDUwMG1zKTtcbiAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvb2x0aXAtYW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICAuc2xpZGUtZG93bi1hbmltYXRpb24tb3V0IHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xuICAgICAgICBvcGFjaXR5OiB2YXIoLS1wYXBlci10b29sdGlwLW9wYWNpdHksIDAuOSk7XG4gICAgICAgIGFuaW1hdGlvbi1kZWxheTogdmFyKC0tcGFwZXItdG9vbHRpcC1kZWxheS1vdXQsIDUwMG1zKTtcbiAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGtleUZyYW1lU2xpZGVEb3duT3V0O1xuICAgICAgICBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiAxO1xuICAgICAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLjAsIDEsIDEpO1xuICAgICAgICBhbmltYXRpb24tZHVyYXRpb246IHZhcigtLXBhcGVyLXRvb2x0aXAtZHVyYXRpb24tb3V0LCA1MDBtcyk7XG4gICAgICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IGZvcndhcmRzO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci10b29sdGlwLWFuaW1hdGlvbjtcbiAgICAgIH1cblxuICAgICAgLmNhbmNlbC1hbmltYXRpb24ge1xuICAgICAgICBhbmltYXRpb24tZGVsYXk6IC0zMHMgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgLyogVGhhbmtzIElFIDEwLiAqL1xuXG4gICAgICAuaGlkZGVuIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwidG9vbHRpcFwiIGNsYXNzPVwiaGlkZGVuXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG5gLFxuXG4gIGlzOiAncGFwZXItdG9vbHRpcCcsXG4gIGhvc3RBdHRyaWJ1dGVzOiB7cm9sZTogJ3Rvb2x0aXAnLCB0YWJpbmRleDogLTF9LFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgdGhhdCB0aGUgdG9vbHRpcCBpcyBhbmNob3JlZCB0by4gVGhpcyBlbGVtZW50XG4gICAgICogbXVzdCBiZSBhIHNpYmxpbmcgb2YgdGhlIHRvb2x0aXAuIElmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldCxcbiAgICAgKiB0aGVuIHRoZSB0b29sdGlwIHdpbGwgYmUgY2VudGVyZWQgdG8gdGhlIHBhcmVudCBub2RlIGNvbnRhaW5pbmcgaXQuXG4gICAgICovXG4gICAgZm9yOiB7dHlwZTogU3RyaW5nLCBvYnNlcnZlcjogJ19maW5kVGFyZ2V0J30sXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBtYW51YWxseSBjb250cm9sIHdoZW4gdGhlIHRvb2x0aXBcbiAgICAgKiBpcyBzaG93biBvciBoaWRkZW4uXG4gICAgICovXG4gICAgbWFudWFsTW9kZToge3R5cGU6IEJvb2xlYW4sIHZhbHVlOiBmYWxzZSwgb2JzZXJ2ZXI6ICdfbWFudWFsTW9kZUNoYW5nZWQnfSxcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbnMgdGhlIHRvb2x0aXAgdG8gdGhlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCBvZiBpdHMgY29udGVudC5cbiAgICAgKi9cbiAgICBwb3NpdGlvbjoge3R5cGU6IFN0cmluZywgdmFsdWU6ICdib3R0b20nfSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBubyBwYXJ0cyBvZiB0aGUgdG9vbHRpcCB3aWxsIGV2ZXIgYmUgc2hvd24gb2Zmc2NyZWVuLlxuICAgICAqL1xuICAgIGZpdFRvVmlzaWJsZUJvdW5kczoge3R5cGU6IEJvb2xlYW4sIHZhbHVlOiBmYWxzZX0sXG4gICAgLyoqXG4gICAgICogVGhlIHNwYWNpbmcgYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSB0b29sdGlwIGFuZCB0aGUgZWxlbWVudCBpdCBpc1xuICAgICAqIGFuY2hvcmVkIHRvLlxuICAgICAqL1xuICAgIG9mZnNldDoge3R5cGU6IE51bWJlciwgdmFsdWU6IDE0fSxcbiAgICAvKipcbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsIGJ1dCBsZWZ0IG92ZXIgc28gdGhhdCBpdCBkb2Vzbid0XG4gICAgICogYnJlYWsgZXhpdGluZyBjb2RlLiBQbGVhc2UgdXNlIGBvZmZzZXRgIGluc3RlYWQuIElmIGJvdGggYG9mZnNldGAgYW5kXG4gICAgICogYG1hcmdpblRvcGAgYXJlIHByb3ZpZGVkLCBgbWFyZ2luVG9wYCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjAuM1xuICAgICAqL1xuICAgIG1hcmdpblRvcDoge3R5cGU6IE51bWJlciwgdmFsdWU6IDE0fSxcbiAgICAvKipcbiAgICAgKiBUaGUgZGVsYXkgdGhhdCB3aWxsIGJlIGFwcGxpZWQgYmVmb3JlIHRoZSBgZW50cnlgIGFuaW1hdGlvbiBpc1xuICAgICAqIHBsYXllZCB3aGVuIHNob3dpbmcgdGhlIHRvb2x0aXAuXG4gICAgICovXG4gICAgYW5pbWF0aW9uRGVsYXk6IHt0eXBlOiBOdW1iZXIsIHZhbHVlOiA1MDAsIG9ic2VydmVyOiAnX2RlbGF5Q2hhbmdlJ30sXG4gICAgLyoqXG4gICAgICogVGhlIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgcGxheWVkIG9uIGVudHJ5LiAgVGhpcyByZXBsYWNlcyB0aGVcbiAgICAgKiBkZXByZWNhdGVkIGFuaW1hdGlvbkNvbmZpZy4gIEVudHJpZXMgaGVyZSB3aWxsIG92ZXJyaWRlIHRoZVxuICAgICAqIGFuaW1hdGlvbkNvbmZpZyBzZXR0aW5ncy4gIFlvdSBjYW4gZW50ZXIgeW91ciBvd24gYW5pbWF0aW9uXG4gICAgICogYnkgc2V0dGluZyBpdCB0byB0aGUgY3NzIGNsYXNzIG5hbWUuXG4gICAgICovXG4gICAgYW5pbWF0aW9uRW50cnk6IHt0eXBlOiBTdHJpbmcsIHZhbHVlOiAnJ30sXG4gICAgLyoqXG4gICAgICogVGhlIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgcGxheWVkIG9uIGV4aXQuICBUaGlzIHJlcGxhY2VzIHRoZVxuICAgICAqIGRlcHJlY2F0ZWQgYW5pbWF0aW9uQ29uZmlnLiAgRW50cmllcyBoZXJlIHdpbGwgb3ZlcnJpZGUgdGhlXG4gICAgICogYW5pbWF0aW9uQ29uZmlnIHNldHRpbmdzLiAgWW91IGNhbiBlbnRlciB5b3VyIG93biBhbmltYXRpb25cbiAgICAgKiBieSBzZXR0aW5nIGl0IHRvIHRoZSBjc3MgY2xhc3MgbmFtZS5cbiAgICAgKi9cbiAgICBhbmltYXRpb25FeGl0OiB7dHlwZTogU3RyaW5nLCB2YWx1ZTogJyd9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZC4gIFVzZSAtLXBhcGVyLXRvb2x0aXAtYW5pbWF0aW9uIHRvIGNoYW5nZSB0aGVcbiAgICAgKiBhbmltYXRpb24uIFRoZSBlbnRyeSBhbmQgZXhpdCBhbmltYXRpb25zIHRoYXQgd2lsbCBiZSBwbGF5ZWQgd2hlbiBzaG93aW5nXG4gICAgICogYW5kIGhpZGluZyB0aGUgdG9vbHRpcC4gSWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhpcywgeW91IG11c3QgZW5zdXJlXG4gICAgICogdGhhdCB5b3VyIGFuaW1hdGlvbkNvbmZpZyBoYXMgdGhlIGV4YWN0IGZvcm1hdCBiZWxvdy5cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uXG4gICAgICpcbiAgICAgKiBUaGUgZW50cnkgYW5kIGV4aXQgYW5pbWF0aW9ucyB0aGF0IHdpbGwgYmUgcGxheWVkIHdoZW4gc2hvd2luZyBhbmRcbiAgICAgKiBoaWRpbmcgdGhlIHRvb2x0aXAuIElmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoaXMsIHlvdSBtdXN0IGVuc3VyZVxuICAgICAqIHRoYXQgeW91ciBhbmltYXRpb25Db25maWcgaGFzIHRoZSBleGFjdCBmb3JtYXQgYmVsb3cuXG4gICAgICovXG4gICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ2VudHJ5JzpcbiAgICAgICAgICAgICAgW3tuYW1lOiAnZmFkZS1pbi1hbmltYXRpb24nLCBub2RlOiB0aGlzLCB0aW1pbmc6IHtkZWxheTogMH19XSxcbiAgICAgICAgICAgICAgJ2V4aXQnOiBbe25hbWU6ICdmYWRlLW91dC1hbmltYXRpb24nLCBub2RlOiB0aGlzfV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX3Nob3dpbmc6IHt0eXBlOiBCb29sZWFuLCB2YWx1ZTogZmFsc2V9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ3dlYmtpdEFuaW1hdGlvbkVuZCc6ICdfb25BbmltYXRpb25FbmQnLFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgZWxlbWVudCB0aGF0IHRoaXMgdG9vbHRpcCBpcyBhbmNob3JlZCB0by4gSXQgaXNcbiAgICogZWl0aGVyIHRoZSBlbGVtZW50IGdpdmVuIGJ5IHRoZSBgZm9yYCBhdHRyaWJ1dGUsIG9yIHRoZSBpbW1lZGlhdGUgcGFyZW50XG4gICAqIG9mIHRoZSB0b29sdGlwLlxuICAgKlxuICAgKiBAdHlwZSB7Tm9kZX1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBkb20odGhpcykucGFyZW50Tm9kZTtcbiAgICAvLyBJZiB0aGUgcGFyZW50Tm9kZSBpcyBhIGRvY3VtZW50IGZyYWdtZW50LCB0aGVuIHdlIG5lZWQgdG8gdXNlIHRoZSBob3N0LlxuICAgIHZhciBvd25lclJvb3QgPSBkb20odGhpcykuZ2V0T3duZXJSb290KCk7XG4gICAgdmFyIHRhcmdldDtcbiAgICBpZiAodGhpcy5mb3IpIHtcbiAgICAgIHRhcmdldCA9IGRvbShvd25lclJvb3QpLnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5mb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQgPSBwYXJlbnROb2RlLm5vZGVUeXBlID09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA/XG4gICAgICAgICAgb3duZXJSb290Lmhvc3QgOlxuICAgICAgICAgIHBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZmluZFRhcmdldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5tYW51YWxNb2RlKVxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIE5lb24tQW5pbWF0aW9uIHBsYXlBbmltYXRpb24gLSBqdXN0IGNhbGxzIHNob3cgYW5kIGhpZGUuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzaG93IGFuZCBoaWRlIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVpdGhlciBgZW50cnlgIG9yIGBleGl0YFxuICAgKi9cbiAgcGxheUFuaW1hdGlvbjogZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnZW50cnknKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdleGl0Jykge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBhbmltYXRpb24gYW5kIGVpdGhlciBmdWxseSBzaG93cyBvciBmdWxseSBoaWRlcyB0b29sdGlwXG4gICAqL1xuICBjYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNob3J0LWN1dCBhbmQgY2FuY2VsIGFsbCBhbmltYXRpb25zIGFuZCBoaWRlXG4gICAgdGhpcy4kLnRvb2x0aXAuY2xhc3NMaXN0LmFkZCgnY2FuY2VsLWFuaW1hdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaG93cyB0aGUgdG9vbHRpcCBwcm9ncmFtYXRpY2FsbHlcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHRoZSB0b29sdGlwIGlzIGFscmVhZHkgc2hvd2luZywgdGhlcmUncyBub3RoaW5nIHRvIGRvLlxuICAgIGlmICh0aGlzLl9zaG93aW5nKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGRvbSh0aGlzKS50ZXh0Q29udGVudC50cmltKCkgPT09ICcnKSB7XG4gICAgICAvLyBDaGVjayBpZiBlZmZlY3RpdmUgY2hpbGRyZW4gYXJlIGFsc28gZW1wdHlcbiAgICAgIHZhciBhbGxDaGlsZHJlbkVtcHR5ID0gdHJ1ZTtcbiAgICAgIHZhciBlZmZlY3RpdmVDaGlsZHJlbiA9IGRvbSh0aGlzKS5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVmZmVjdGl2ZUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlZmZlY3RpdmVDaGlsZHJlbltpXS50ZXh0Q29udGVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgYWxsQ2hpbGRyZW5FbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWxsQ2hpbGRyZW5FbXB0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc2hvd2luZyA9IHRydWU7XG4gICAgdGhpcy4kLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgdGhpcy4kLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnY2FuY2VsLWFuaW1hdGlvbicpO1xuICAgIHRoaXMuJC50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fZ2V0QW5pbWF0aW9uVHlwZSgnZXhpdCcpKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgdGhpcy5fYW5pbWF0aW9uUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy4kLnRvb2x0aXAuY2xhc3NMaXN0LmFkZCh0aGlzLl9nZXRBbmltYXRpb25UeXBlKCdlbnRyeScpKTtcbiAgfSxcblxuICAvKipcbiAgICogSGlkZXMgdGhlIHRvb2x0aXAgcHJvZ3JhbWF0aWNhbGx5XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB0aGUgdG9vbHRpcCBpcyBhbHJlYWR5IGhpZGRlbiwgdGhlcmUncyBub3RoaW5nIHRvIGRvLlxuICAgIGlmICghdGhpcy5fc2hvd2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBlbnRyeSBhbmltYXRpb24gaXMgc3RpbGwgcGxheWluZywgZG9uJ3QgdHJ5IHRvIHBsYXkgdGhlIGV4aXRcbiAgICAvLyBhbmltYXRpb24gc2luY2UgdGhpcyB3aWxsIHJlc2V0IHRoZSBvcGFjaXR5IHRvIDEuIEp1c3QgZW5kIHRoZSBhbmltYXRpb24uXG4gICAgaWYgKHRoaXMuX2FuaW1hdGlvblBsYXlpbmcpIHtcbiAgICAgIHRoaXMuX3Nob3dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NhbmNlbEFuaW1hdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQbGF5IEV4aXQgQW5pbWF0aW9uXG4gICAgICB0aGlzLl9vbkFuaW1hdGlvbkZpbmlzaCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Nob3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25QbGF5aW5nID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3RhcmdldCB8fCAhdGhpcy5vZmZzZXRQYXJlbnQpXG4gICAgICByZXR1cm47XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIC8vIElmIGEgbWFyZ2luVG9wIGhhcyBiZWVuIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIChwcmUgMS4wLjMpLCB1c2UgaXQuXG4gICAgaWYgKHRoaXMubWFyZ2luVG9wICE9IDE0ICYmIHRoaXMub2Zmc2V0ID09IDE0KVxuICAgICAgb2Zmc2V0ID0gdGhpcy5tYXJnaW5Ub3A7XG4gICAgdmFyIHBhcmVudFJlY3QgPSB0aGlzLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IHRoaXMuX3RhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgdGhpc1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBob3Jpem9udGFsQ2VudGVyT2Zmc2V0ID0gKHRhcmdldFJlY3Qud2lkdGggLSB0aGlzUmVjdC53aWR0aCkgLyAyO1xuICAgIHZhciB2ZXJ0aWNhbENlbnRlck9mZnNldCA9ICh0YXJnZXRSZWN0LmhlaWdodCAtIHRoaXNSZWN0LmhlaWdodCkgLyAyO1xuICAgIHZhciB0YXJnZXRMZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0O1xuICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wO1xuICAgIHZhciB0b29sdGlwTGVmdCwgdG9vbHRpcFRvcDtcbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRvb2x0aXBMZWZ0ID0gdGFyZ2V0TGVmdCArIGhvcml6b250YWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgIHRvb2x0aXBUb3AgPSB0YXJnZXRUb3AgLSB0aGlzUmVjdC5oZWlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdG9vbHRpcExlZnQgPSB0YXJnZXRMZWZ0ICsgaG9yaXpvbnRhbENlbnRlck9mZnNldDtcbiAgICAgICAgdG9vbHRpcFRvcCA9IHRhcmdldFRvcCArIHRhcmdldFJlY3QuaGVpZ2h0ICsgb2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICB0b29sdGlwTGVmdCA9IHRhcmdldExlZnQgLSB0aGlzUmVjdC53aWR0aCAtIG9mZnNldDtcbiAgICAgICAgdG9vbHRpcFRvcCA9IHRhcmdldFRvcCArIHZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdG9vbHRpcExlZnQgPSB0YXJnZXRMZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aCArIG9mZnNldDtcbiAgICAgICAgdG9vbHRpcFRvcCA9IHRhcmdldFRvcCArIHZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETyhub21zKTogVGhpcyBzaG91bGQgdXNlIElyb25GaXRCZWhhdmlvciBpZiBwb3NzaWJsZS5cbiAgICBpZiAodGhpcy5maXRUb1Zpc2libGVCb3VuZHMpIHtcbiAgICAgIC8vIENsaXAgdGhlIGxlZnQvcmlnaHQgc2lkZVxuICAgICAgaWYgKHBhcmVudFJlY3QubGVmdCArIHRvb2x0aXBMZWZ0ICsgdGhpc1JlY3Qud2lkdGggPiB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICB0aGlzLnN0eWxlLnJpZ2h0ID0gJzBweCc7XG4gICAgICAgIHRoaXMuc3R5bGUubGVmdCA9ICdhdXRvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3R5bGUubGVmdCA9IE1hdGgubWF4KDAsIHRvb2x0aXBMZWZ0KSArICdweCc7XG4gICAgICAgIHRoaXMuc3R5bGUucmlnaHQgPSAnYXV0byc7XG4gICAgICB9XG4gICAgICAvLyBDbGlwIHRoZSB0b3AvYm90dG9tIHNpZGUuXG4gICAgICBpZiAocGFyZW50UmVjdC50b3AgKyB0b29sdGlwVG9wICsgdGhpc1JlY3QuaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYm90dG9tID0gKHBhcmVudFJlY3QuaGVpZ2h0IC0gdGFyZ2V0VG9wICsgb2Zmc2V0KSArICdweCc7XG4gICAgICAgIHRoaXMuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdHlsZS50b3AgPSBNYXRoLm1heCgtcGFyZW50UmVjdC50b3AsIHRvb2x0aXBUb3ApICsgJ3B4JztcbiAgICAgICAgdGhpcy5zdHlsZS5ib3R0b20gPSAnYXV0byc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUubGVmdCA9IHRvb2x0aXBMZWZ0ICsgJ3B4JztcbiAgICAgIHRoaXMuc3R5bGUudG9wID0gdG9vbHRpcFRvcCArICdweCc7XG4gICAgfVxuICB9LFxuXG4gIF9hZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl90YXJnZXQpIHtcbiAgICAgIHRoaXMubGlzdGVuKHRoaXMuX3RhcmdldCwgJ21vdXNlZW50ZXInLCAnc2hvdycpO1xuICAgICAgdGhpcy5saXN0ZW4odGhpcy5fdGFyZ2V0LCAnZm9jdXMnLCAnc2hvdycpO1xuICAgICAgdGhpcy5saXN0ZW4odGhpcy5fdGFyZ2V0LCAnbW91c2VsZWF2ZScsICdoaWRlJyk7XG4gICAgICB0aGlzLmxpc3Rlbih0aGlzLl90YXJnZXQsICdibHVyJywgJ2hpZGUnKTtcbiAgICAgIHRoaXMubGlzdGVuKHRoaXMuX3RhcmdldCwgJ3RhcCcsICdoaWRlJyk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuKHRoaXMuJC50b29sdGlwLCAnYW5pbWF0aW9uZW5kJywgJ19vbkFuaW1hdGlvbkVuZCcpO1xuICAgIHRoaXMubGlzdGVuKHRoaXMsICdtb3VzZWVudGVyJywgJ2hpZGUnKTtcbiAgfSxcblxuICBfZmluZFRhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1hbnVhbE1vZGUpXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICBpZiAoIXRoaXMubWFudWFsTW9kZSlcbiAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuICB9LFxuXG4gIF9kZWxheUNoYW5nZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAvLyBPbmx5IFVwZGF0ZSBkZWxheSBpZiBkaWZmZXJlbnQgdmFsdWUgc2V0XG4gICAgaWYgKG5ld1ZhbHVlICE9PSA1MDApIHtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVzKHsnLS1wYXBlci10b29sdGlwLWRlbGF5LWluJzogbmV3VmFsdWUgKyAnbXMnfSk7XG4gICAgfVxuICB9LFxuXG4gIF9tYW51YWxNb2RlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubWFudWFsTW9kZSlcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuICB9LFxuXG4gIF9jYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNob3J0LWN1dCBhbmQgY2FuY2VsIGFsbCBhbmltYXRpb25zIGFuZCBoaWRlXG4gICAgdGhpcy4kLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9nZXRBbmltYXRpb25UeXBlKCdlbnRyeScpKTtcbiAgICB0aGlzLiQudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2dldEFuaW1hdGlvblR5cGUoJ2V4aXQnKSk7XG4gICAgdGhpcy4kLnRvb2x0aXAuY2xhc3NMaXN0LnJlbW92ZSgnY2FuY2VsLWFuaW1hdGlvbicpO1xuICAgIHRoaXMuJC50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICB9LFxuXG4gIF9vbkFuaW1hdGlvbkZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Nob3dpbmcpIHtcbiAgICAgIHRoaXMuJC50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fZ2V0QW5pbWF0aW9uVHlwZSgnZW50cnknKSk7XG4gICAgICB0aGlzLiQudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCdjYW5jZWwtYW5pbWF0aW9uJyk7XG4gICAgICB0aGlzLiQudG9vbHRpcC5jbGFzc0xpc3QuYWRkKHRoaXMuX2dldEFuaW1hdGlvblR5cGUoJ2V4aXQnKSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkFuaW1hdGlvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gSWYgbm8gbG9uZ2VyIHNob3dpbmcgYWRkIGNsYXNzIGhpZGRlbiB0byBjb21wbGV0ZWx5IGhpZGUgdG9vbHRpcFxuICAgIHRoaXMuX2FuaW1hdGlvblBsYXlpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuX3Nob3dpbmcpIHtcbiAgICAgIHRoaXMuJC50b29sdGlwLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fZ2V0QW5pbWF0aW9uVHlwZSgnZXhpdCcpKTtcbiAgICAgIHRoaXMuJC50b29sdGlwLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cbiAgfSxcblxuICBfZ2V0QW5pbWF0aW9uVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgaGF2ZSBwcmlvcml0eSBvdmVyIGFuaW1hdGlvbkNvbmZpZyB2YWx1ZXNcbiAgICBpZiAoKHR5cGUgPT09ICdlbnRyeScpICYmICh0aGlzLmFuaW1hdGlvbkVudHJ5ICE9PSAnJykpIHtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbkVudHJ5O1xuICAgIH1cbiAgICBpZiAoKHR5cGUgPT09ICdleGl0JykgJiYgKHRoaXMuYW5pbWF0aW9uRXhpdCAhPT0gJycpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25FeGl0O1xuICAgIH1cbiAgICAvLyBJZiBubyByZXN1bHRzIHRoZW4gcmV0dXJuIHRoZSBsZWdhY3kgdmFsdWUgZnJvbSBhbmltYXRpb25Db25maWdcbiAgICBpZiAodGhpcy5hbmltYXRpb25Db25maWdbdHlwZV0gJiZcbiAgICAgICAgdHlwZW9mIHRoaXMuYW5pbWF0aW9uQ29uZmlnW3R5cGVdWzBdLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBDaGVja2luZyBUaW1pbmcgYW5kIFVwZGF0ZSBpZiBuZWNlc3NhcnkgLSBMZWdhY3kgZm9yIGFuaW1hdGlvbkNvbmZpZ1xuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uQ29uZmlnW3R5cGVdWzBdLnRpbWluZyAmJlxuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uQ29uZmlnW3R5cGVdWzBdLnRpbWluZy5kZWxheSAmJlxuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uQ29uZmlnW3R5cGVdWzBdLnRpbWluZy5kZWxheSAhPT0gMCkge1xuICAgICAgICB2YXIgdGltaW5nRGVsYXkgPSB0aGlzLmFuaW1hdGlvbkNvbmZpZ1t0eXBlXVswXS50aW1pbmcuZGVsYXk7XG4gICAgICAgIC8vIEhhcyBUaW1pbmcgQ2hhbmdlIC0gVXBkYXRlIENTU1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2VudHJ5Jykge1xuICAgICAgICAgIHRoaXMudXBkYXRlU3R5bGVzKHsnLS1wYXBlci10b29sdGlwLWRlbGF5LWluJzogdGltaW5nRGVsYXkgKyAnbXMnfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2V4aXQnKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVTdHlsZXMoeyctLXBhcGVyLXRvb2x0aXAtZGVsYXktb3V0JzogdGltaW5nRGVsYXkgKyAnbXMnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbkNvbmZpZ1t0eXBlXVswXS5uYW1lO1xuICAgIH1cbiAgfSxcblxuICBfcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fdGFyZ2V0KSB7XG4gICAgICB0aGlzLnVubGlzdGVuKHRoaXMuX3RhcmdldCwgJ21vdXNlZW50ZXInLCAnc2hvdycpO1xuICAgICAgdGhpcy51bmxpc3Rlbih0aGlzLl90YXJnZXQsICdmb2N1cycsICdzaG93Jyk7XG4gICAgICB0aGlzLnVubGlzdGVuKHRoaXMuX3RhcmdldCwgJ21vdXNlbGVhdmUnLCAnaGlkZScpO1xuICAgICAgdGhpcy51bmxpc3Rlbih0aGlzLl90YXJnZXQsICdibHVyJywgJ2hpZGUnKTtcbiAgICAgIHRoaXMudW5saXN0ZW4odGhpcy5fdGFyZ2V0LCAndGFwJywgJ2hpZGUnKTtcbiAgICB9XG4gICAgdGhpcy51bmxpc3Rlbih0aGlzLiQudG9vbHRpcCwgJ2FuaW1hdGlvbmVuZCcsICdfb25BbmltYXRpb25FbmQnKTtcbiAgICB0aGlzLnVubGlzdGVuKHRoaXMsICdtb3VzZWVudGVyJywgJ2hpZGUnKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@polymer/paper-tooltip/paper-tooltip.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxDataProviderMixin\": () => (/* binding */ ComboBoxDataProviderMixin)\n/* harmony export */ });\n/* harmony import */ var _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-combo-box-placeholder.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * @polymerMixin\n */\n\nconst ComboBoxDataProviderMixin = superClass => class DataProviderMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       * @attr {number} page-size\n       * @type {number}\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n\n      /**\n       * Total number of items.\n       * @type {number | undefined}\n       */\n      size: {\n        type: Number,\n        observer: '_sizeChanged'\n      },\n\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filter` Currently applied filter\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items.\n       * @type {ComboBoxDataProvider | undefined}\n       */\n      dataProvider: {\n        type: Object,\n        observer: '_dataProviderChanged'\n      },\n\n      /** @private */\n      _pendingRequests: {\n        value: () => {\n          return {};\n        }\n      },\n\n      /** @private */\n      __placeHolder: {\n        value: new _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_0__.ComboBoxPlaceholder()\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_dataProviderFilterChanged(filter, dataProvider)', '_dataProviderClearFilter(dataProvider, opened, value)', '_warnDataProviderValue(dataProvider, value)', '_ensureFirstPage(opened)'];\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.clearCache();\n    this.$.dropdown.addEventListener('index-requested', e => {\n      const index = e.detail.index;\n      const currentScrollerPos = e.detail.currentScrollerPos;\n      const allowedIndexRange = Math.floor(this.pageSize * 1.5); // Ignores the indexes, which are being re-sent during scrolling reset,\n      // if the corresponding page is around the current scroller position.\n      // Otherwise, there might be a last pages duplicates, which cause the\n      // loading indicator hanging and blank items\n\n      if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {\n        return;\n      }\n\n      if (index !== undefined) {\n        const page = this._getPageForIndex(index);\n\n        if (this._shouldLoadPage(page)) {\n          this._loadPage(page);\n        }\n      }\n    });\n  }\n  /** @private */\n\n\n  _dataProviderFilterChanged() {\n    if (!this._shouldFetchData()) {\n      return;\n    }\n\n    this._refreshData();\n  }\n  /** @private */\n\n\n  _dataProviderClearFilter(dataProvider, opened, value) {\n    // Can't depend on filter in this observer as we don't want\n    // to clear the filter whenever it's set\n    if (dataProvider && !this.loading && this.filter && !(opened && this.autoOpenDisabled && value === this.filter)) {\n      this._refreshData(true);\n    }\n  }\n  /** @private */\n\n\n  _refreshData(clearFilter) {\n    // Immediately mark as loading if this refresh leads to re-fetching pages\n    // This prevents some issues with the properties below triggering\n    // observers that also rely on the loading state\n    this.loading = this._shouldFetchData(); // Reset size and internal loading state\n\n    this.size = undefined;\n    this._pendingRequests = {}; // Clear filter if requested\n\n    if (clearFilter) {\n      this.filter = '';\n    } // Clear cached pages, and reload current page if we need the data\n\n\n    this.clearCache();\n  }\n  /** @private */\n\n\n  _shouldFetchData() {\n    if (!this.dataProvider) {\n      return false;\n    }\n\n    return this.opened || this.filter && this.filter.length;\n  }\n  /** @private */\n\n\n  _ensureFirstPage(opened) {\n    if (opened && this._shouldLoadPage(0)) {\n      this._loadPage(0);\n    }\n  }\n  /** @private */\n\n\n  _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {\n    return currentScrollerPos !== 0 && index >= currentScrollerPos - allowedIndexRange && index <= currentScrollerPos + allowedIndexRange;\n  }\n  /** @private */\n\n\n  _shouldLoadPage(page) {\n    if (!this.filteredItems || this._forceNextRequest) {\n      this._forceNextRequest = false;\n      return true;\n    }\n\n    const loadedItem = this.filteredItems[page * this.pageSize];\n\n    if (loadedItem !== undefined) {\n      return loadedItem instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_0__.ComboBoxPlaceholder;\n    } else {\n      return this.size === undefined;\n    }\n  }\n  /** @private */\n\n\n  _loadPage(page) {\n    // make sure same page isn't requested multiple times.\n    if (!this._pendingRequests[page] && this.dataProvider) {\n      this.loading = true;\n      const params = {\n        page,\n        pageSize: this.pageSize,\n        filter: this.filter\n      };\n\n      const callback = (items, size) => {\n        if (this._pendingRequests[page] === callback) {\n          if (!this.filteredItems) {\n            const filteredItems = [];\n            filteredItems.splice(params.page * params.pageSize, items.length, ...items);\n            this.filteredItems = filteredItems;\n          } else {\n            this.splice('filteredItems', params.page * params.pageSize, items.length, ...items);\n          } // Update selectedItem from filteredItems if value is set\n\n\n          if (this._isValidValue(this.value) && this._getItemValue(this.selectedItem) !== this.value) {\n            this._selectItemForValue(this.value);\n          }\n\n          if (!this.opened && !this.hasAttribute('focused')) {\n            this._commitValue();\n          }\n\n          this.size = size;\n          delete this._pendingRequests[page];\n\n          if (Object.keys(this._pendingRequests).length === 0) {\n            this.loading = false;\n          }\n        }\n      };\n\n      if (!this._pendingRequests[page]) {\n        // Don't request page if it's already being requested\n        this._pendingRequests[page] = callback;\n        this.dataProvider(params, callback);\n      }\n    }\n  }\n  /** @private */\n\n\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n\n\n  clearCache() {\n    if (!this.dataProvider) {\n      return;\n    }\n\n    this._pendingRequests = {};\n    const filteredItems = [];\n\n    for (let i = 0; i < (this.size || 0); i++) {\n      filteredItems.push(this.__placeHolder);\n    }\n\n    this.filteredItems = filteredItems;\n\n    if (this._shouldFetchData()) {\n      this._loadPage(0);\n    } else {\n      this._forceNextRequest = true;\n    }\n  }\n  /** @private */\n\n\n  _sizeChanged(size = 0) {\n    const filteredItems = (this.filteredItems || []).slice(0, size);\n\n    for (let i = 0; i < size; i++) {\n      filteredItems[i] = filteredItems[i] !== undefined ? filteredItems[i] : this.__placeHolder;\n    }\n\n    this.filteredItems = filteredItems; // Cleans up the redundant pending requests for pages > size\n    // Refers to https://github.com/vaadin/vaadin-flow-components/issues/229\n\n    this._flushPendingRequests(size);\n  }\n  /** @private */\n\n\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {\n      this.pageSize = oldPageSize;\n      throw new Error('`pageSize` value must be an integer > 0');\n    }\n\n    this.clearCache();\n  }\n  /** @private */\n\n\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    this._ensureItemsOrDataProvider(() => {\n      this.dataProvider = oldDataProvider;\n    });\n  }\n  /** @private */\n\n\n  _ensureItemsOrDataProvider(restoreOldValueCallback) {\n    if (this.items !== undefined && this.dataProvider !== undefined) {\n      restoreOldValueCallback();\n      throw new Error('Using `items` and `dataProvider` together is not supported');\n    } else if (this.dataProvider && !this.filteredItems) {\n      this.filteredItems = [];\n    }\n  }\n  /** @private */\n\n\n  _warnDataProviderValue(dataProvider, value) {\n    if (dataProvider && value !== '' && (this.selectedItem === undefined || this.selectedItem === null)) {\n      const valueIndex = this._indexOfValue(value, this.filteredItems);\n\n      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {\n        console.warn('Warning: unable to determine the label for the provided `value`. ' + 'Nothing to display in the text field. This usually happens when ' + 'setting an initial `value` before any items are returned from ' + 'the `dataProvider` callback. Consider setting `selectedItem` ' + 'instead of `value`');\n      }\n    }\n  }\n  /**\n   * This method cleans up the page callbacks which refers to the\n   * non-existing pages, i.e. which item indexes are greater than the\n   * changed size.\n   * This case is basically happens when:\n   * 1. Users scroll fast to the bottom and combo box generates the\n   * redundant page request/callback\n   * 2. Server side uses undefined size lazy loading and suddenly reaches\n   * the exact size which is on the range edge\n   * (for default page size = 50, it will be 100, 200, 300, ...).\n   * @param size the new size of items\n   * @private\n   */\n\n\n  _flushPendingRequests(size) {\n    if (this._pendingRequests) {\n      const lastPage = Math.ceil(size / this.pageSize);\n      const pendingRequestsKeys = Object.keys(this._pendingRequests);\n\n      for (let reqIdx = 0; reqIdx < pendingRequestsKeys.length; reqIdx++) {\n        const page = parseInt(pendingRequestsKeys[reqIdx]);\n\n        if (page >= lastPage) {\n          this._pendingRequests[page]([], size);\n        }\n      }\n    }\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtZGF0YS1wcm92aWRlci1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBO0FBREE7QUFoREE7QUFvREE7O0FBRUE7QUFDQTtBQU1BO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFLQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1VEEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L3NyYy92YWFkaW4tY29tYm8tYm94LWRhdGEtcHJvdmlkZXItbWl4aW4uanM/ZmY0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IENvbWJvQm94UGxhY2Vob2xkZXIgfSBmcm9tICcuL3ZhYWRpbi1jb21iby1ib3gtcGxhY2Vob2xkZXIuanMnO1xuXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IENvbWJvQm94RGF0YVByb3ZpZGVyTWl4aW4gPSAoc3VwZXJDbGFzcykgPT5cbiAgY2xhc3MgRGF0YVByb3ZpZGVyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGl0ZW1zIGZldGNoZWQgYXQgYSB0aW1lIGZyb20gdGhlIGRhdGFwcm92aWRlci5cbiAgICAgICAgICogQGF0dHIge251bWJlcn0gcGFnZS1zaXplXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBwYWdlU2l6ZToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICB2YWx1ZTogNTAsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfcGFnZVNpemVDaGFuZ2VkJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG90YWwgbnVtYmVyIG9mIGl0ZW1zLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICBvYnNlcnZlcjogJ19zaXplQ2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgaXRlbXMgbGF6aWx5LiBSZWNlaXZlcyBhcmd1bWVudHMgYHBhcmFtc2AsIGBjYWxsYmFja2BcbiAgICAgICAgICpcbiAgICAgICAgICogYHBhcmFtcy5wYWdlYCBSZXF1ZXN0ZWQgcGFnZSBpbmRleFxuICAgICAgICAgKlxuICAgICAgICAgKiBgcGFyYW1zLnBhZ2VTaXplYCBDdXJyZW50IHBhZ2Ugc2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgcGFyYW1zLmZpbHRlcmAgQ3VycmVudGx5IGFwcGxpZWQgZmlsdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIGBjYWxsYmFjayhpdGVtcywgc2l6ZSlgIENhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYXJndW1lbnRzOlxuICAgICAgICAgKiAgIC0gYGl0ZW1zYCBDdXJyZW50IHBhZ2Ugb2YgaXRlbXNcbiAgICAgICAgICogICAtIGBzaXplYCBUb3RhbCBudW1iZXIgb2YgaXRlbXMuXG4gICAgICAgICAqIEB0eXBlIHtDb21ib0JveERhdGFQcm92aWRlciB8IHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIGRhdGFQcm92aWRlcjoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBvYnNlcnZlcjogJ19kYXRhUHJvdmlkZXJDaGFuZ2VkJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgX3BlbmRpbmdSZXF1ZXN0czoge1xuICAgICAgICAgIHZhbHVlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgX19wbGFjZUhvbGRlcjoge1xuICAgICAgICAgIHZhbHVlOiBuZXcgQ29tYm9Cb3hQbGFjZWhvbGRlcigpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICdfZGF0YVByb3ZpZGVyRmlsdGVyQ2hhbmdlZChmaWx0ZXIsIGRhdGFQcm92aWRlciknLFxuICAgICAgICAnX2RhdGFQcm92aWRlckNsZWFyRmlsdGVyKGRhdGFQcm92aWRlciwgb3BlbmVkLCB2YWx1ZSknLFxuICAgICAgICAnX3dhcm5EYXRhUHJvdmlkZXJWYWx1ZShkYXRhUHJvdmlkZXIsIHZhbHVlKScsXG4gICAgICAgICdfZW5zdXJlRmlyc3RQYWdlKG9wZW5lZCknLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgdGhpcy4kLmRyb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ2luZGV4LXJlcXVlc3RlZCcsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZS5kZXRhaWwuaW5kZXg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxlclBvcyA9IGUuZGV0YWlsLmN1cnJlbnRTY3JvbGxlclBvcztcbiAgICAgICAgY29uc3QgYWxsb3dlZEluZGV4UmFuZ2UgPSBNYXRoLmZsb29yKHRoaXMucGFnZVNpemUgKiAxLjUpO1xuXG4gICAgICAgIC8vIElnbm9yZXMgdGhlIGluZGV4ZXMsIHdoaWNoIGFyZSBiZWluZyByZS1zZW50IGR1cmluZyBzY3JvbGxpbmcgcmVzZXQsXG4gICAgICAgIC8vIGlmIHRoZSBjb3JyZXNwb25kaW5nIHBhZ2UgaXMgYXJvdW5kIHRoZSBjdXJyZW50IHNjcm9sbGVyIHBvc2l0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZXJlIG1pZ2h0IGJlIGEgbGFzdCBwYWdlcyBkdXBsaWNhdGVzLCB3aGljaCBjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9hZGluZyBpbmRpY2F0b3IgaGFuZ2luZyBhbmQgYmxhbmsgaXRlbXNcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNraXBJbmRleChpbmRleCwgYWxsb3dlZEluZGV4UmFuZ2UsIGN1cnJlbnRTY3JvbGxlclBvcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlRm9ySW5kZXgoaW5kZXgpO1xuICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRMb2FkUGFnZShwYWdlKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZFBhZ2UocGFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfZGF0YVByb3ZpZGVyRmlsdGVyQ2hhbmdlZCgpIHtcbiAgICAgIGlmICghdGhpcy5fc2hvdWxkRmV0Y2hEYXRhKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWZyZXNoRGF0YSgpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9kYXRhUHJvdmlkZXJDbGVhckZpbHRlcihkYXRhUHJvdmlkZXIsIG9wZW5lZCwgdmFsdWUpIHtcbiAgICAgIC8vIENhbid0IGRlcGVuZCBvbiBmaWx0ZXIgaW4gdGhpcyBvYnNlcnZlciBhcyB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBjbGVhciB0aGUgZmlsdGVyIHdoZW5ldmVyIGl0J3Mgc2V0XG4gICAgICBpZiAoZGF0YVByb3ZpZGVyICYmICF0aGlzLmxvYWRpbmcgJiYgdGhpcy5maWx0ZXIgJiYgIShvcGVuZWQgJiYgdGhpcy5hdXRvT3BlbkRpc2FibGVkICYmIHZhbHVlID09PSB0aGlzLmZpbHRlcikpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaERhdGEodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3JlZnJlc2hEYXRhKGNsZWFyRmlsdGVyKSB7XG4gICAgICAvLyBJbW1lZGlhdGVseSBtYXJrIGFzIGxvYWRpbmcgaWYgdGhpcyByZWZyZXNoIGxlYWRzIHRvIHJlLWZldGNoaW5nIHBhZ2VzXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHNvbWUgaXNzdWVzIHdpdGggdGhlIHByb3BlcnRpZXMgYmVsb3cgdHJpZ2dlcmluZ1xuICAgICAgLy8gb2JzZXJ2ZXJzIHRoYXQgYWxzbyByZWx5IG9uIHRoZSBsb2FkaW5nIHN0YXRlXG4gICAgICB0aGlzLmxvYWRpbmcgPSB0aGlzLl9zaG91bGRGZXRjaERhdGEoKTtcbiAgICAgIC8vIFJlc2V0IHNpemUgYW5kIGludGVybmFsIGxvYWRpbmcgc3RhdGVcbiAgICAgIHRoaXMuc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuICAgICAgLy8gQ2xlYXIgZmlsdGVyIGlmIHJlcXVlc3RlZFxuICAgICAgaWYgKGNsZWFyRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gJyc7XG4gICAgICB9XG4gICAgICAvLyBDbGVhciBjYWNoZWQgcGFnZXMsIGFuZCByZWxvYWQgY3VycmVudCBwYWdlIGlmIHdlIG5lZWQgdGhlIGRhdGFcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9zaG91bGRGZXRjaERhdGEoKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YVByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMub3BlbmVkIHx8ICh0aGlzLmZpbHRlciAmJiB0aGlzLmZpbHRlci5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9lbnN1cmVGaXJzdFBhZ2Uob3BlbmVkKSB7XG4gICAgICBpZiAob3BlbmVkICYmIHRoaXMuX3Nob3VsZExvYWRQYWdlKDApKSB7XG4gICAgICAgIHRoaXMuX2xvYWRQYWdlKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9zaG91bGRTa2lwSW5kZXgoaW5kZXgsIGFsbG93ZWRJbmRleFJhbmdlLCBjdXJyZW50U2Nyb2xsZXJQb3MpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGN1cnJlbnRTY3JvbGxlclBvcyAhPT0gMCAmJlxuICAgICAgICBpbmRleCA+PSBjdXJyZW50U2Nyb2xsZXJQb3MgLSBhbGxvd2VkSW5kZXhSYW5nZSAmJlxuICAgICAgICBpbmRleCA8PSBjdXJyZW50U2Nyb2xsZXJQb3MgKyBhbGxvd2VkSW5kZXhSYW5nZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfc2hvdWxkTG9hZFBhZ2UocGFnZSkge1xuICAgICAgaWYgKCF0aGlzLmZpbHRlcmVkSXRlbXMgfHwgdGhpcy5fZm9yY2VOZXh0UmVxdWVzdCkge1xuICAgICAgICB0aGlzLl9mb3JjZU5leHRSZXF1ZXN0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkZWRJdGVtID0gdGhpcy5maWx0ZXJlZEl0ZW1zW3BhZ2UgKiB0aGlzLnBhZ2VTaXplXTtcbiAgICAgIGlmIChsb2FkZWRJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZEl0ZW0gaW5zdGFuY2VvZiBDb21ib0JveFBsYWNlaG9sZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9sb2FkUGFnZShwYWdlKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgc2FtZSBwYWdlIGlzbid0IHJlcXVlc3RlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgIGlmICghdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3BhZ2VdICYmIHRoaXMuZGF0YVByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChpdGVtcywgc2l6ZSkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVxdWVzdHNbcGFnZV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRJdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gW107XG4gICAgICAgICAgICAgIGZpbHRlcmVkSXRlbXMuc3BsaWNlKHBhcmFtcy5wYWdlICogcGFyYW1zLnBhZ2VTaXplLCBpdGVtcy5sZW5ndGgsIC4uLml0ZW1zKTtcbiAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZEl0ZW1zID0gZmlsdGVyZWRJdGVtcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc3BsaWNlKCdmaWx0ZXJlZEl0ZW1zJywgcGFyYW1zLnBhZ2UgKiBwYXJhbXMucGFnZVNpemUsIGl0ZW1zLmxlbmd0aCwgLi4uaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkSXRlbSBmcm9tIGZpbHRlcmVkSXRlbXMgaWYgdmFsdWUgaXMgc2V0XG4gICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFZhbHVlKHRoaXMudmFsdWUpICYmIHRoaXMuX2dldEl0ZW1WYWx1ZSh0aGlzLnNlbGVjdGVkSXRlbSkgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0SXRlbUZvclZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCAmJiAhdGhpcy5oYXNBdHRyaWJ1dGUoJ2ZvY3VzZWQnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jb21taXRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1twYWdlXTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdSZXF1ZXN0c1twYWdlXSkge1xuICAgICAgICAgIC8vIERvbid0IHJlcXVlc3QgcGFnZSBpZiBpdCdzIGFscmVhZHkgYmVpbmcgcmVxdWVzdGVkXG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3BhZ2VdID0gY2FsbGJhY2s7XG4gICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfZ2V0UGFnZUZvckluZGV4KGluZGV4KSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMucGFnZVNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY2FjaGVkIHBhZ2VzIGFuZCByZWxvYWRzIGRhdGEgZnJvbSBkYXRhcHJvdmlkZXIgd2hlbiBuZWVkZWQuXG4gICAgICovXG4gICAgY2xlYXJDYWNoZSgpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzID0ge307XG4gICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICh0aGlzLnNpemUgfHwgMCk7IGkrKykge1xuICAgICAgICBmaWx0ZXJlZEl0ZW1zLnB1c2godGhpcy5fX3BsYWNlSG9sZGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IGZpbHRlcmVkSXRlbXM7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkRmV0Y2hEYXRhKCkpIHtcbiAgICAgICAgdGhpcy5fbG9hZFBhZ2UoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mb3JjZU5leHRSZXF1ZXN0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfc2l6ZUNoYW5nZWQoc2l6ZSA9IDApIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkSXRlbXMgPSAodGhpcy5maWx0ZXJlZEl0ZW1zIHx8IFtdKS5zbGljZSgwLCBzaXplKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGZpbHRlcmVkSXRlbXNbaV0gPSBmaWx0ZXJlZEl0ZW1zW2ldICE9PSB1bmRlZmluZWQgPyBmaWx0ZXJlZEl0ZW1zW2ldIDogdGhpcy5fX3BsYWNlSG9sZGVyO1xuICAgICAgfVxuICAgICAgdGhpcy5maWx0ZXJlZEl0ZW1zID0gZmlsdGVyZWRJdGVtcztcblxuICAgICAgLy8gQ2xlYW5zIHVwIHRoZSByZWR1bmRhbnQgcGVuZGluZyByZXF1ZXN0cyBmb3IgcGFnZXMgPiBzaXplXG4gICAgICAvLyBSZWZlcnMgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZhYWRpbi92YWFkaW4tZmxvdy1jb21wb25lbnRzL2lzc3Vlcy8yMjlcbiAgICAgIHRoaXMuX2ZsdXNoUGVuZGluZ1JlcXVlc3RzKHNpemUpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9wYWdlU2l6ZUNoYW5nZWQocGFnZVNpemUsIG9sZFBhZ2VTaXplKSB7XG4gICAgICBpZiAoTWF0aC5mbG9vcihwYWdlU2l6ZSkgIT09IHBhZ2VTaXplIHx8IHBhZ2VTaXplIDwgMSkge1xuICAgICAgICB0aGlzLnBhZ2VTaXplID0gb2xkUGFnZVNpemU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHBhZ2VTaXplYCB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXIgPiAwJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfZGF0YVByb3ZpZGVyQ2hhbmdlZChkYXRhUHJvdmlkZXIsIG9sZERhdGFQcm92aWRlcikge1xuICAgICAgdGhpcy5fZW5zdXJlSXRlbXNPckRhdGFQcm92aWRlcigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gb2xkRGF0YVByb3ZpZGVyO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2Vuc3VyZUl0ZW1zT3JEYXRhUHJvdmlkZXIocmVzdG9yZU9sZFZhbHVlQ2FsbGJhY2spIHtcbiAgICAgIGlmICh0aGlzLml0ZW1zICE9PSB1bmRlZmluZWQgJiYgdGhpcy5kYXRhUHJvdmlkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN0b3JlT2xkVmFsdWVDYWxsYmFjaygpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIGBpdGVtc2AgYW5kIGBkYXRhUHJvdmlkZXJgIHRvZ2V0aGVyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhUHJvdmlkZXIgJiYgIXRoaXMuZmlsdGVyZWRJdGVtcykge1xuICAgICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfd2FybkRhdGFQcm92aWRlclZhbHVlKGRhdGFQcm92aWRlciwgdmFsdWUpIHtcbiAgICAgIGlmIChkYXRhUHJvdmlkZXIgJiYgdmFsdWUgIT09ICcnICYmICh0aGlzLnNlbGVjdGVkSXRlbSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuc2VsZWN0ZWRJdGVtID09PSBudWxsKSkge1xuICAgICAgICBjb25zdCB2YWx1ZUluZGV4ID0gdGhpcy5faW5kZXhPZlZhbHVlKHZhbHVlLCB0aGlzLmZpbHRlcmVkSXRlbXMpO1xuICAgICAgICBpZiAodmFsdWVJbmRleCA8IDAgfHwgIXRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLmZpbHRlcmVkSXRlbXNbdmFsdWVJbmRleF0pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ1dhcm5pbmc6IHVuYWJsZSB0byBkZXRlcm1pbmUgdGhlIGxhYmVsIGZvciB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gJyArXG4gICAgICAgICAgICAgICdOb3RoaW5nIHRvIGRpc3BsYXkgaW4gdGhlIHRleHQgZmllbGQuIFRoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4gJyArXG4gICAgICAgICAgICAgICdzZXR0aW5nIGFuIGluaXRpYWwgYHZhbHVlYCBiZWZvcmUgYW55IGl0ZW1zIGFyZSByZXR1cm5lZCBmcm9tICcgK1xuICAgICAgICAgICAgICAndGhlIGBkYXRhUHJvdmlkZXJgIGNhbGxiYWNrLiBDb25zaWRlciBzZXR0aW5nIGBzZWxlY3RlZEl0ZW1gICcgK1xuICAgICAgICAgICAgICAnaW5zdGVhZCBvZiBgdmFsdWVgJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2xlYW5zIHVwIHRoZSBwYWdlIGNhbGxiYWNrcyB3aGljaCByZWZlcnMgdG8gdGhlXG4gICAgICogbm9uLWV4aXN0aW5nIHBhZ2VzLCBpLmUuIHdoaWNoIGl0ZW0gaW5kZXhlcyBhcmUgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAqIGNoYW5nZWQgc2l6ZS5cbiAgICAgKiBUaGlzIGNhc2UgaXMgYmFzaWNhbGx5IGhhcHBlbnMgd2hlbjpcbiAgICAgKiAxLiBVc2VycyBzY3JvbGwgZmFzdCB0byB0aGUgYm90dG9tIGFuZCBjb21ibyBib3ggZ2VuZXJhdGVzIHRoZVxuICAgICAqIHJlZHVuZGFudCBwYWdlIHJlcXVlc3QvY2FsbGJhY2tcbiAgICAgKiAyLiBTZXJ2ZXIgc2lkZSB1c2VzIHVuZGVmaW5lZCBzaXplIGxhenkgbG9hZGluZyBhbmQgc3VkZGVubHkgcmVhY2hlc1xuICAgICAqIHRoZSBleGFjdCBzaXplIHdoaWNoIGlzIG9uIHRoZSByYW5nZSBlZGdlXG4gICAgICogKGZvciBkZWZhdWx0IHBhZ2Ugc2l6ZSA9IDUwLCBpdCB3aWxsIGJlIDEwMCwgMjAwLCAzMDAsIC4uLikuXG4gICAgICogQHBhcmFtIHNpemUgdGhlIG5ldyBzaXplIG9mIGl0ZW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmx1c2hQZW5kaW5nUmVxdWVzdHMoc2l6ZSkge1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cykge1xuICAgICAgICBjb25zdCBsYXN0UGFnZSA9IE1hdGguY2VpbChzaXplIC8gdGhpcy5wYWdlU2l6ZSk7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0c0tleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9wZW5kaW5nUmVxdWVzdHMpO1xuICAgICAgICBmb3IgKGxldCByZXFJZHggPSAwOyByZXFJZHggPCBwZW5kaW5nUmVxdWVzdHNLZXlzLmxlbmd0aDsgcmVxSWR4KyspIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQocGVuZGluZ1JlcXVlc3RzS2V5c1tyZXFJZHhdKTtcbiAgICAgICAgICBpZiAocGFnZSA+PSBsYXN0UGFnZSkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3BhZ2VdKFtdLCBzaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-dropdown.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-dropdown.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxDropdown\": () => (/* binding */ ComboBoxDropdown)\n/* harmony export */ });\n/* harmony import */ var _vaadin_combo_box_item_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-combo-box-item.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js\");\n/* harmony import */ var _vaadin_combo_box_overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-combo-box-overlay.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js\");\n/* harmony import */ var _vaadin_combo_box_scroller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vaadin-combo-box-scroller.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js\");\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n/**\n * Element for internal use only.\n *\n * @extends HTMLElement\n * @private\n */\n\nclass ComboBoxDropdown extends _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__.PolymerElement {\n  static get is() {\n    return 'vaadin-combo-box-dropdown';\n  }\n\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__.html`\n      <vaadin-combo-box-overlay\n        id=\"overlay\"\n        hidden$=\"[[_isOverlayHidden(_items.*, loading)]]\"\n        loading$=\"[[loading]]\"\n        opened=\"{{_overlayOpened}}\"\n        theme$=\"[[theme]]\"\n        position-target=\"[[positionTarget]]\"\n        no-vertical-overlap\n      ></vaadin-combo-box-overlay>\n    `;\n  }\n\n  static get properties() {\n    return {\n      /**\n       * True if the combo-box has been activate by the user.\n       * The actual opened state depends on whether the dropdown has items.\n       */\n      opened: Boolean,\n\n      /**\n       * The element to position/align the dropdown by.\n       */\n      positionTarget: {\n        type: Object,\n        observer: '_positionTargetChanged'\n      },\n\n      /**\n       * Custom function for rendering the content of the `<vaadin-combo-box-item>` propagated from the combo box element.\n       */\n      renderer: Function,\n\n      /**\n       * `true` when new items are being loaded.\n       */\n      loading: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Used to propagate the `theme` attribute from the host element.\n       */\n      theme: String,\n      _selectedItem: {\n        type: Object\n      },\n      _items: {\n        type: Array\n      },\n      _focusedIndex: {\n        type: Number,\n        value: -1\n      },\n      focusedItem: {\n        type: String,\n        computed: '_getFocusedItem(_focusedIndex)'\n      },\n      _itemLabelPath: {\n        type: String,\n        value: 'label'\n      },\n      _itemValuePath: {\n        type: String,\n        value: 'value'\n      },\n      _scroller: Object,\n      _itemIdPath: String,\n      _overlayOpened: {\n        type: Boolean,\n        observer: '_openedChanged'\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_openedOrItemsChanged(opened, _items, loading)', '__updateScroller(_scroller, _items, opened, loading, _selectedItem, _itemIdPath, _focusedIndex, renderer, theme)'];\n  }\n\n  constructor() {\n    super(); // Ensure every instance has unique ID\n\n    const uniqueId = ComboBoxDropdown._uniqueId = 1 + ComboBoxDropdown._uniqueId || 0;\n    this.scrollerId = `${this.localName}-scroller-${uniqueId}`;\n  }\n\n  ready() {\n    super.ready(); // Allow extensions to customize tag name for the items\n\n    this.__hostTagName = this.constructor.is.replace('-dropdown', '');\n    const overlay = this.$.overlay;\n    const scrollerTag = `${this.__hostTagName}-scroller`;\n\n    overlay.renderer = root => {\n      if (!root.firstChild) {\n        const scroller = document.createElement(scrollerTag);\n        root.appendChild(scroller);\n      }\n    }; // Ensure the scroller is rendered\n\n\n    overlay.requestContentUpdate();\n    this._scroller = overlay.content.querySelector(scrollerTag);\n    this._scroller.id = this.scrollerId;\n    this._scroller.getItemLabel = this.getItemLabel.bind(this);\n    this._scroller.comboBox = this.getRootNode().host;\n\n    this._scroller.addEventListener('selection-changed', e => this._forwardScrollerEvent(e));\n\n    this._scroller.addEventListener('index-requested', e => this._forwardScrollerEvent(e));\n\n    overlay.addEventListener('touchend', e => this._fireTouchAction(e));\n    overlay.addEventListener('touchmove', e => this._fireTouchAction(e)); // Prevent blurring the input when clicking inside the overlay.\n\n    overlay.addEventListener('mousedown', e => e.preventDefault()); // Preventing the default modal behaviour of the overlay on input clicking\n\n    overlay.addEventListener('vaadin-overlay-outside-click', e => {\n      e.preventDefault();\n    });\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback(); // Making sure the overlay is closed and removed from DOM after detaching the dropdown.\n\n    this._overlayOpened = false;\n  }\n\n  _fireTouchAction(sourceEvent) {\n    this.dispatchEvent(new CustomEvent('vaadin-overlay-touch-action', {\n      detail: {\n        sourceEvent: sourceEvent\n      }\n    }));\n  }\n\n  _forwardScrollerEvent(event) {\n    this.dispatchEvent(new CustomEvent(event.type, {\n      detail: event.detail\n    }));\n  }\n\n  _openedChanged(opened, wasOpened) {\n    if (opened) {\n      this._setOverlayWidth();\n\n      this._scroller.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this.__hostTagName}-overlay-max-height`) || '65vh';\n      this.dispatchEvent(new CustomEvent('vaadin-combo-box-dropdown-opened', {\n        bubbles: true,\n        composed: true\n      }));\n    } else if (wasOpened && !this.__emptyItems) {\n      this.dispatchEvent(new CustomEvent('vaadin-combo-box-dropdown-closed', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n\n  _openedOrItemsChanged(opened, items, loading) {\n    // See https://github.com/vaadin/vaadin-combo-box/pull/964\n    const hasItems = items && items.length;\n\n    if (!hasItems) {\n      this.__emptyItems = true;\n    }\n\n    this._overlayOpened = !!(opened && (loading || hasItems));\n    this.__emptyItems = false;\n  }\n\n  _getFocusedItem(focusedIndex) {\n    if (focusedIndex >= 0) {\n      return this._items[focusedIndex];\n    }\n  }\n  /**\n   * Gets the index of the item with the provided label.\n   * @return {number}\n   */\n\n\n  indexOfLabel(label) {\n    if (this._items && label) {\n      for (let i = 0; i < this._items.length; i++) {\n        if (this.getItemLabel(this._items[i]).toString().toLowerCase() === label.toString().toLowerCase()) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Gets the label string for the item based on the `_itemLabelPath`.\n   * @return {string}\n   */\n\n\n  getItemLabel(item, itemLabelPath) {\n    itemLabelPath = itemLabelPath || this._itemLabelPath;\n    let label = item && itemLabelPath ? this.get(itemLabelPath, item) : undefined;\n\n    if (label === undefined || label === null) {\n      label = item ? item.toString() : '';\n    }\n\n    return label;\n  }\n\n  _scrollIntoView(index) {\n    if (!this._scroller) {\n      return;\n    }\n\n    this._scroller.scrollIntoView(index);\n  }\n\n  adjustScrollPosition() {\n    if (this.opened && this._items) {\n      this._scrollIntoView(this._focusedIndex);\n    }\n  }\n\n  __updateScroller(scroller, items, opened, loading, selectedItem, itemIdPath, focusedIndex, renderer, theme) {\n    if (scroller) {\n      scroller.setProperties({\n        items: opened ? items : [],\n        opened,\n        loading,\n        selectedItem,\n        itemIdPath,\n        focusedIndex,\n        renderer,\n        theme\n      });\n    }\n  }\n\n  _isOverlayHidden() {\n    return !this.loading && !(this._items && this._items.length);\n  }\n\n  _positionTargetChanged(target) {\n    // we must update the overlay width when the positionTarget is set (or changes)\n    if (target) {\n      this._setOverlayWidth();\n    }\n  }\n\n  _setOverlayWidth() {\n    if (!this.positionTarget) {\n      return;\n    }\n\n    const inputWidth = this.positionTarget.clientWidth + 'px';\n    const propPrefix = `${this.__hostTagName}-overlay`;\n    const customWidth = getComputedStyle(this).getPropertyValue(`--${propPrefix}-width`);\n    this.$.overlay.style.setProperty(`--_${propPrefix}-default-width`, inputWidth);\n\n    if (customWidth === '') {\n      this.$.overlay.style.removeProperty(`--${propPrefix}-width`);\n    } else {\n      this.$.overlay.style.setProperty(`--${propPrefix}-width`, customWidth);\n    }\n\n    this.$.overlay._updatePosition();\n  }\n  /**\n   * Fired after the `vaadin-combo-box-dropdown` opens.\n   *\n   * @event vaadin-combo-box-dropdown-opened\n   */\n\n  /**\n   * Fired after the `vaadin-combo-box-dropdown` closes.\n   *\n   * @event vaadin-combo-box-dropdown-closed\n   */\n\n\n}\ncustomElements.define(ComboBoxDropdown.is, ComboBoxDropdown);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtZHJvcGRvd24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBbEVBO0FBdUVBOztBQUVBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQURBO0FBSUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBclNBO0FBd1NBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9zcmMvdmFhZGluLWNvbWJvLWJveC1kcm9wZG93bi5qcz85NmI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0ICcuL3ZhYWRpbi1jb21iby1ib3gtaXRlbS5qcyc7XG5pbXBvcnQgJy4vdmFhZGluLWNvbWJvLWJveC1vdmVybGF5LmpzJztcbmltcG9ydCAnLi92YWFkaW4tY29tYm8tYm94LXNjcm9sbGVyLmpzJztcbmltcG9ydCB7IGh0bWwsIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuXG4vKipcbiAqIEVsZW1lbnQgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29tYm9Cb3hEcm9wZG93biBleHRlbmRzIFBvbHltZXJFbGVtZW50IHtcbiAgc3RhdGljIGdldCBpcygpIHtcbiAgICByZXR1cm4gJ3ZhYWRpbi1jb21iby1ib3gtZHJvcGRvd24nO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDx2YWFkaW4tY29tYm8tYm94LW92ZXJsYXlcbiAgICAgICAgaWQ9XCJvdmVybGF5XCJcbiAgICAgICAgaGlkZGVuJD1cIltbX2lzT3ZlcmxheUhpZGRlbihfaXRlbXMuKiwgbG9hZGluZyldXVwiXG4gICAgICAgIGxvYWRpbmckPVwiW1tsb2FkaW5nXV1cIlxuICAgICAgICBvcGVuZWQ9XCJ7e19vdmVybGF5T3BlbmVkfX1cIlxuICAgICAgICB0aGVtZSQ9XCJbW3RoZW1lXV1cIlxuICAgICAgICBwb3NpdGlvbi10YXJnZXQ9XCJbW3Bvc2l0aW9uVGFyZ2V0XV1cIlxuICAgICAgICBuby12ZXJ0aWNhbC1vdmVybGFwXG4gICAgICA+PC92YWFkaW4tY29tYm8tYm94LW92ZXJsYXk+XG4gICAgYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIGlmIHRoZSBjb21iby1ib3ggaGFzIGJlZW4gYWN0aXZhdGUgYnkgdGhlIHVzZXIuXG4gICAgICAgKiBUaGUgYWN0dWFsIG9wZW5lZCBzdGF0ZSBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGRyb3Bkb3duIGhhcyBpdGVtcy5cbiAgICAgICAqL1xuICAgICAgb3BlbmVkOiBCb29sZWFuLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBlbGVtZW50IHRvIHBvc2l0aW9uL2FsaWduIHRoZSBkcm9wZG93biBieS5cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb25UYXJnZXQ6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBvYnNlcnZlcjogJ19wb3NpdGlvblRhcmdldENoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDdXN0b20gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyB0aGUgY29udGVudCBvZiB0aGUgYDx2YWFkaW4tY29tYm8tYm94LWl0ZW0+YCBwcm9wYWdhdGVkIGZyb20gdGhlIGNvbWJvIGJveCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICByZW5kZXJlcjogRnVuY3Rpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogYHRydWVgIHdoZW4gbmV3IGl0ZW1zIGFyZSBiZWluZyBsb2FkZWQuXG4gICAgICAgKi9cbiAgICAgIGxvYWRpbmc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgIGF0dHJpYnV0ZSBmcm9tIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIHRoZW1lOiBTdHJpbmcsXG5cbiAgICAgIF9zZWxlY3RlZEl0ZW06IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgfSxcblxuICAgICAgX2l0ZW1zOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgfSxcblxuICAgICAgX2ZvY3VzZWRJbmRleDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAtMSxcbiAgICAgIH0sXG5cbiAgICAgIGZvY3VzZWRJdGVtOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgY29tcHV0ZWQ6ICdfZ2V0Rm9jdXNlZEl0ZW0oX2ZvY3VzZWRJbmRleCknLFxuICAgICAgfSxcblxuICAgICAgX2l0ZW1MYWJlbFBhdGg6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ2xhYmVsJyxcbiAgICAgIH0sXG5cbiAgICAgIF9pdGVtVmFsdWVQYXRoOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICd2YWx1ZScsXG4gICAgICB9LFxuXG4gICAgICBfc2Nyb2xsZXI6IE9iamVjdCxcblxuICAgICAgX2l0ZW1JZFBhdGg6IFN0cmluZyxcblxuICAgICAgX292ZXJsYXlPcGVuZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfb3BlbmVkQ2hhbmdlZCcsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ19vcGVuZWRPckl0ZW1zQ2hhbmdlZChvcGVuZWQsIF9pdGVtcywgbG9hZGluZyknLFxuICAgICAgJ19fdXBkYXRlU2Nyb2xsZXIoX3Njcm9sbGVyLCBfaXRlbXMsIG9wZW5lZCwgbG9hZGluZywgX3NlbGVjdGVkSXRlbSwgX2l0ZW1JZFBhdGgsIF9mb2N1c2VkSW5kZXgsIHJlbmRlcmVyLCB0aGVtZSknLFxuICAgIF07XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gRW5zdXJlIGV2ZXJ5IGluc3RhbmNlIGhhcyB1bmlxdWUgSURcbiAgICBjb25zdCB1bmlxdWVJZCA9IChDb21ib0JveERyb3Bkb3duLl91bmlxdWVJZCA9IDEgKyBDb21ib0JveERyb3Bkb3duLl91bmlxdWVJZCB8fCAwKTtcbiAgICB0aGlzLnNjcm9sbGVySWQgPSBgJHt0aGlzLmxvY2FsTmFtZX0tc2Nyb2xsZXItJHt1bmlxdWVJZH1gO1xuICB9XG5cbiAgcmVhZHkoKSB7XG4gICAgc3VwZXIucmVhZHkoKTtcblxuICAgIC8vIEFsbG93IGV4dGVuc2lvbnMgdG8gY3VzdG9taXplIHRhZyBuYW1lIGZvciB0aGUgaXRlbXNcbiAgICB0aGlzLl9faG9zdFRhZ05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmlzLnJlcGxhY2UoJy1kcm9wZG93bicsICcnKTtcblxuICAgIGNvbnN0IG92ZXJsYXkgPSB0aGlzLiQub3ZlcmxheTtcbiAgICBjb25zdCBzY3JvbGxlclRhZyA9IGAke3RoaXMuX19ob3N0VGFnTmFtZX0tc2Nyb2xsZXJgO1xuXG4gICAgb3ZlcmxheS5yZW5kZXJlciA9IChyb290KSA9PiB7XG4gICAgICBpZiAoIXJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb25zdCBzY3JvbGxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoc2Nyb2xsZXJUYWcpO1xuICAgICAgICByb290LmFwcGVuZENoaWxkKHNjcm9sbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHRoZSBzY3JvbGxlciBpcyByZW5kZXJlZFxuICAgIG92ZXJsYXkucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcblxuICAgIHRoaXMuX3Njcm9sbGVyID0gb3ZlcmxheS5jb250ZW50LnF1ZXJ5U2VsZWN0b3Ioc2Nyb2xsZXJUYWcpO1xuICAgIHRoaXMuX3Njcm9sbGVyLmlkID0gdGhpcy5zY3JvbGxlcklkO1xuXG4gICAgdGhpcy5fc2Nyb2xsZXIuZ2V0SXRlbUxhYmVsID0gdGhpcy5nZXRJdGVtTGFiZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zY3JvbGxlci5jb21ib0JveCA9IHRoaXMuZ2V0Um9vdE5vZGUoKS5ob3N0O1xuXG4gICAgdGhpcy5fc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uLWNoYW5nZWQnLCAoZSkgPT4gdGhpcy5fZm9yd2FyZFNjcm9sbGVyRXZlbnQoZSkpO1xuICAgIHRoaXMuX3Njcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2luZGV4LXJlcXVlc3RlZCcsIChlKSA9PiB0aGlzLl9mb3J3YXJkU2Nyb2xsZXJFdmVudChlKSk7XG5cbiAgICBvdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKGUpID0+IHRoaXMuX2ZpcmVUb3VjaEFjdGlvbihlKSk7XG4gICAgb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCAoZSkgPT4gdGhpcy5fZmlyZVRvdWNoQWN0aW9uKGUpKTtcblxuICAgIC8vIFByZXZlbnQgYmx1cnJpbmcgdGhlIGlucHV0IHdoZW4gY2xpY2tpbmcgaW5zaWRlIHRoZSBvdmVybGF5LlxuICAgIG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG5cbiAgICAvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IG1vZGFsIGJlaGF2aW91ciBvZiB0aGUgb3ZlcmxheSBvbiBpbnB1dCBjbGlja2luZ1xuICAgIG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcigndmFhZGluLW92ZXJsYXktb3V0c2lkZS1jbGljaycsIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgLy8gTWFraW5nIHN1cmUgdGhlIG92ZXJsYXkgaXMgY2xvc2VkIGFuZCByZW1vdmVkIGZyb20gRE9NIGFmdGVyIGRldGFjaGluZyB0aGUgZHJvcGRvd24uXG4gICAgdGhpcy5fb3ZlcmxheU9wZW5lZCA9IGZhbHNlO1xuICB9XG5cbiAgX2ZpcmVUb3VjaEFjdGlvbihzb3VyY2VFdmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgndmFhZGluLW92ZXJsYXktdG91Y2gtYWN0aW9uJywge1xuICAgICAgICBkZXRhaWw6IHsgc291cmNlRXZlbnQ6IHNvdXJjZUV2ZW50IH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgX2ZvcndhcmRTY3JvbGxlckV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudC50eXBlLCB7IGRldGFpbDogZXZlbnQuZGV0YWlsIH0pKTtcbiAgfVxuXG4gIF9vcGVuZWRDaGFuZ2VkKG9wZW5lZCwgd2FzT3BlbmVkKSB7XG4gICAgaWYgKG9wZW5lZCkge1xuICAgICAgdGhpcy5fc2V0T3ZlcmxheVdpZHRoKCk7XG5cbiAgICAgIHRoaXMuX3Njcm9sbGVyLnN0eWxlLm1heEhlaWdodCA9XG4gICAgICAgIGdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZShgLS0ke3RoaXMuX19ob3N0VGFnTmFtZX0tb3ZlcmxheS1tYXgtaGVpZ2h0YCkgfHwgJzY1dmgnO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd2YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duLW9wZW5lZCcsIHsgYnViYmxlczogdHJ1ZSwgY29tcG9zZWQ6IHRydWUgfSkpO1xuICAgIH0gZWxzZSBpZiAod2FzT3BlbmVkICYmICF0aGlzLl9fZW1wdHlJdGVtcykge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndmFhZGluLWNvbWJvLWJveC1kcm9wZG93bi1jbG9zZWQnLCB7IGJ1YmJsZXM6IHRydWUsIGNvbXBvc2VkOiB0cnVlIH0pKTtcbiAgICB9XG4gIH1cblxuICBfb3BlbmVkT3JJdGVtc0NoYW5nZWQob3BlbmVkLCBpdGVtcywgbG9hZGluZykge1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmFhZGluL3ZhYWRpbi1jb21iby1ib3gvcHVsbC85NjRcbiAgICBjb25zdCBoYXNJdGVtcyA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aDtcbiAgICBpZiAoIWhhc0l0ZW1zKSB7XG4gICAgICB0aGlzLl9fZW1wdHlJdGVtcyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX292ZXJsYXlPcGVuZWQgPSAhIShvcGVuZWQgJiYgKGxvYWRpbmcgfHwgaGFzSXRlbXMpKTtcbiAgICB0aGlzLl9fZW1wdHlJdGVtcyA9IGZhbHNlO1xuICB9XG5cbiAgX2dldEZvY3VzZWRJdGVtKGZvY3VzZWRJbmRleCkge1xuICAgIGlmIChmb2N1c2VkSW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW2ZvY3VzZWRJbmRleF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBpdGVtIHdpdGggdGhlIHByb3ZpZGVkIGxhYmVsLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBpbmRleE9mTGFiZWwobGFiZWwpIHtcbiAgICBpZiAodGhpcy5faXRlbXMgJiYgbGFiZWwpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0SXRlbUxhYmVsKHRoaXMuX2l0ZW1zW2ldKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IGxhYmVsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxhYmVsIHN0cmluZyBmb3IgdGhlIGl0ZW0gYmFzZWQgb24gdGhlIGBfaXRlbUxhYmVsUGF0aGAuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEl0ZW1MYWJlbChpdGVtLCBpdGVtTGFiZWxQYXRoKSB7XG4gICAgaXRlbUxhYmVsUGF0aCA9IGl0ZW1MYWJlbFBhdGggfHwgdGhpcy5faXRlbUxhYmVsUGF0aDtcbiAgICBsZXQgbGFiZWwgPSBpdGVtICYmIGl0ZW1MYWJlbFBhdGggPyB0aGlzLmdldChpdGVtTGFiZWxQYXRoLCBpdGVtKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAobGFiZWwgPT09IHVuZGVmaW5lZCB8fCBsYWJlbCA9PT0gbnVsbCkge1xuICAgICAgbGFiZWwgPSBpdGVtID8gaXRlbS50b1N0cmluZygpIDogJyc7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbDtcbiAgfVxuXG4gIF9zY3JvbGxJbnRvVmlldyhpbmRleCkge1xuICAgIGlmICghdGhpcy5fc2Nyb2xsZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2Nyb2xsZXIuc2Nyb2xsSW50b1ZpZXcoaW5kZXgpO1xuICB9XG5cbiAgYWRqdXN0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkICYmIHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9zY3JvbGxJbnRvVmlldyh0aGlzLl9mb2N1c2VkSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIF9fdXBkYXRlU2Nyb2xsZXIoc2Nyb2xsZXIsIGl0ZW1zLCBvcGVuZWQsIGxvYWRpbmcsIHNlbGVjdGVkSXRlbSwgaXRlbUlkUGF0aCwgZm9jdXNlZEluZGV4LCByZW5kZXJlciwgdGhlbWUpIHtcbiAgICBpZiAoc2Nyb2xsZXIpIHtcbiAgICAgIHNjcm9sbGVyLnNldFByb3BlcnRpZXMoe1xuICAgICAgICBpdGVtczogb3BlbmVkID8gaXRlbXMgOiBbXSxcbiAgICAgICAgb3BlbmVkLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICBzZWxlY3RlZEl0ZW0sXG4gICAgICAgIGl0ZW1JZFBhdGgsXG4gICAgICAgIGZvY3VzZWRJbmRleCxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIHRoZW1lLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2lzT3ZlcmxheUhpZGRlbigpIHtcbiAgICByZXR1cm4gIXRoaXMubG9hZGluZyAmJiAhKHRoaXMuX2l0ZW1zICYmIHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gIH1cblxuICBfcG9zaXRpb25UYXJnZXRDaGFuZ2VkKHRhcmdldCkge1xuICAgIC8vIHdlIG11c3QgdXBkYXRlIHRoZSBvdmVybGF5IHdpZHRoIHdoZW4gdGhlIHBvc2l0aW9uVGFyZ2V0IGlzIHNldCAob3IgY2hhbmdlcylcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9zZXRPdmVybGF5V2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfc2V0T3ZlcmxheVdpZHRoKCkge1xuICAgIGlmICghdGhpcy5wb3NpdGlvblRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFdpZHRoID0gdGhpcy5wb3NpdGlvblRhcmdldC5jbGllbnRXaWR0aCArICdweCc7XG4gICAgY29uc3QgcHJvcFByZWZpeCA9IGAke3RoaXMuX19ob3N0VGFnTmFtZX0tb3ZlcmxheWA7XG4gICAgY29uc3QgY3VzdG9tV2lkdGggPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoYC0tJHtwcm9wUHJlZml4fS13aWR0aGApO1xuXG4gICAgdGhpcy4kLm92ZXJsYXkuc3R5bGUuc2V0UHJvcGVydHkoYC0tXyR7cHJvcFByZWZpeH0tZGVmYXVsdC13aWR0aGAsIGlucHV0V2lkdGgpO1xuXG4gICAgaWYgKGN1c3RvbVdpZHRoID09PSAnJykge1xuICAgICAgdGhpcy4kLm92ZXJsYXkuc3R5bGUucmVtb3ZlUHJvcGVydHkoYC0tJHtwcm9wUHJlZml4fS13aWR0aGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiQub3ZlcmxheS5zdHlsZS5zZXRQcm9wZXJ0eShgLS0ke3Byb3BQcmVmaXh9LXdpZHRoYCwgY3VzdG9tV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMuJC5vdmVybGF5Ll91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIGFmdGVyIHRoZSBgdmFhZGluLWNvbWJvLWJveC1kcm9wZG93bmAgb3BlbnMuXG4gICAqXG4gICAqIEBldmVudCB2YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duLW9wZW5lZFxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgYWZ0ZXIgdGhlIGB2YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duYCBjbG9zZXMuXG4gICAqXG4gICAqIEBldmVudCB2YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duLWNsb3NlZFxuICAgKi9cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKENvbWJvQm94RHJvcGRvd24uaXMsIENvbWJvQm94RHJvcGRvd24pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-dropdown.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxItem\": () => (/* binding */ ComboBoxItem)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/component-base/src/dir-mixin.js */ \"./node_modules/@vaadin/component-base/src/dir-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n/**\n * An item element used by the `<vaadin-combo-box>` dropdown.\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name   | Description\n * ------------|--------------\n * `checkmark` | The graphical checkmark shown for a selected item\n * `content`   | The element that wraps the item content\n *\n * The following state attributes are exposed for styling:\n *\n * Attribute    | Description\n * -------------|-------------\n * `selected`   | Set when the item is selected\n * `focused`    | Set when the item is focused\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @mixes ThemableMixin\n * @mixes DirMixin\n * @private\n */\n\nclass ComboBoxItem extends (0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__.ThemableMixin)((0,_vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_1__.DirMixin)(_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.PolymerElement)) {\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.html`\n      <style>\n        :host {\n          display: block;\n        }\n\n        :host([hidden]) {\n          display: none;\n        }\n      </style>\n      <span part=\"checkmark\" aria-hidden=\"true\"></span>\n      <div part=\"content\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-combo-box-item';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * The index of the item\n       */\n      index: Number,\n\n      /**\n       * The item to render\n       * @type {(String|Object)}\n       */\n      item: Object,\n\n      /**\n       * The text label corresponding to the item\n       */\n      label: String,\n\n      /**\n       * True when item is selected\n       */\n      selected: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * True when item is focused\n       */\n      focused: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Custom function for rendering the content of the `<vaadin-combo-box-item>` propagated from the combo box element.\n       */\n      renderer: Function,\n\n      /**\n       * Saved instance of a custom renderer function.\n       */\n      _oldRenderer: Function\n    };\n  }\n\n  static get observers() {\n    return ['__rendererOrItemChanged(renderer, index, item.*, selected, focused)', '__updateLabel(label, renderer)'];\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this._comboBox = this.parentNode.comboBox;\n\n    const hostDir = this._comboBox.getAttribute('dir');\n\n    if (hostDir) {\n      this.setAttribute('dir', hostDir);\n    }\n  }\n  /**\n   * Requests an update for the content of the item.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n\n\n  requestContentUpdate() {\n    if (!this.renderer) {\n      return;\n    }\n\n    const model = {\n      index: this.index,\n      item: this.item,\n      focused: this.focused,\n      selected: this.selected\n    };\n    this.renderer(this, this._comboBox, model);\n  }\n  /** @private */\n\n\n  __rendererOrItemChanged(renderer, index, item, _selected, _focused) {\n    if (item === undefined || index === undefined) {\n      return;\n    }\n\n    if (this._oldRenderer !== renderer) {\n      this.innerHTML = ''; // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n      // When clearing the rendered content, this part needs to be manually disposed of.\n      // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n\n      delete this._$litPart$;\n    }\n\n    if (renderer) {\n      this._oldRenderer = renderer;\n      this.requestContentUpdate();\n    }\n  }\n  /** @private */\n\n\n  __updateLabel(label, renderer) {\n    if (renderer) return;\n    this.textContent = label;\n  }\n\n}\ncustomElements.define(ComboBoxItem.is, ComboBoxItem);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtaXRlbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBM0NBO0FBNkNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQXBJQTtBQXVJQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtaXRlbS5qcz82ZWJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgaHRtbCwgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBEaXJNaXhpbiB9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2Rpci1taXhpbi5qcyc7XG5pbXBvcnQgeyBUaGVtYWJsZU1peGluIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuLyoqXG4gKiBBbiBpdGVtIGVsZW1lbnQgdXNlZCBieSB0aGUgYDx2YWFkaW4tY29tYm8tYm94PmAgZHJvcGRvd24uXG4gKlxuICogIyMjIFN0eWxpbmdcbiAqXG4gKiBUaGUgZm9sbG93aW5nIHNoYWRvdyBET00gcGFydHMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcbiAqXG4gKiBQYXJ0IG5hbWUgICB8IERlc2NyaXB0aW9uXG4gKiAtLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS1cbiAqIGBjaGVja21hcmtgIHwgVGhlIGdyYXBoaWNhbCBjaGVja21hcmsgc2hvd24gZm9yIGEgc2VsZWN0ZWQgaXRlbVxuICogYGNvbnRlbnRgICAgfCBUaGUgZWxlbWVudCB0aGF0IHdyYXBzIHRoZSBpdGVtIGNvbnRlbnRcbiAqXG4gKiBUaGUgZm9sbG93aW5nIHN0YXRlIGF0dHJpYnV0ZXMgYXJlIGV4cG9zZWQgZm9yIHN0eWxpbmc6XG4gKlxuICogQXR0cmlidXRlICAgIHwgRGVzY3JpcHRpb25cbiAqIC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLVxuICogYHNlbGVjdGVkYCAgIHwgU2V0IHdoZW4gdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAqIGBmb2N1c2VkYCAgICB8IFNldCB3aGVuIHRoZSBpdGVtIGlzIGZvY3VzZWRcbiAqXG4gKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50c10oaHR0cHM6Ly92YWFkaW4uY29tL2RvY3MvbGF0ZXN0L2RzL2N1c3RvbWl6YXRpb24vc3R5bGluZy1jb21wb25lbnRzKSBkb2N1bWVudGF0aW9uLlxuICpcbiAqIEBtaXhlcyBUaGVtYWJsZU1peGluXG4gKiBAbWl4ZXMgRGlyTWl4aW5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21ib0JveEl0ZW0gZXh0ZW5kcyBUaGVtYWJsZU1peGluKERpck1peGluKFBvbHltZXJFbGVtZW50KSkge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdChbaGlkZGVuXSkge1xuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG4gICAgICA8c3BhbiBwYXJ0PVwiY2hlY2ttYXJrXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgICAgPGRpdiBwYXJ0PVwiY29udGVudFwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgc3RhdGljIGdldCBpcygpIHtcbiAgICByZXR1cm4gJ3ZhYWRpbi1jb21iby1ib3gtaXRlbSc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGluZGV4IG9mIHRoZSBpdGVtXG4gICAgICAgKi9cbiAgICAgIGluZGV4OiBOdW1iZXIsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGl0ZW0gdG8gcmVuZGVyXG4gICAgICAgKiBAdHlwZSB7KFN0cmluZ3xPYmplY3QpfVxuICAgICAgICovXG4gICAgICBpdGVtOiBPYmplY3QsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRleHQgbGFiZWwgY29ycmVzcG9uZGluZyB0byB0aGUgaXRlbVxuICAgICAgICovXG4gICAgICBsYWJlbDogU3RyaW5nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRydWUgd2hlbiBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIHdoZW4gaXRlbSBpcyBmb2N1c2VkXG4gICAgICAgKi9cbiAgICAgIGZvY3VzZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEN1c3RvbSBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIHRoZSBjb250ZW50IG9mIHRoZSBgPHZhYWRpbi1jb21iby1ib3gtaXRlbT5gIHByb3BhZ2F0ZWQgZnJvbSB0aGUgY29tYm8gYm94IGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIHJlbmRlcmVyOiBGdW5jdGlvbixcblxuICAgICAgLyoqXG4gICAgICAgKiBTYXZlZCBpbnN0YW5jZSBvZiBhIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICAgICAqL1xuICAgICAgX29sZFJlbmRlcmVyOiBGdW5jdGlvbixcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgcmV0dXJuIFsnX19yZW5kZXJlck9ySXRlbUNoYW5nZWQocmVuZGVyZXIsIGluZGV4LCBpdGVtLiosIHNlbGVjdGVkLCBmb2N1c2VkKScsICdfX3VwZGF0ZUxhYmVsKGxhYmVsLCByZW5kZXJlciknXTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICB0aGlzLl9jb21ib0JveCA9IHRoaXMucGFyZW50Tm9kZS5jb21ib0JveDtcblxuICAgIGNvbnN0IGhvc3REaXIgPSB0aGlzLl9jb21ib0JveC5nZXRBdHRyaWJ1dGUoJ2RpcicpO1xuICAgIGlmIChob3N0RGlyKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlyJywgaG9zdERpcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFuIHVwZGF0ZSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhlIGl0ZW0uXG4gICAqIFdoaWxlIHBlcmZvcm1pbmcgdGhlIHVwZGF0ZSwgaXQgaW52b2tlcyB0aGUgcmVuZGVyZXIgcGFzc2VkIGluIHRoZSBgcmVuZGVyZXJgIHByb3BlcnR5LlxuICAgKlxuICAgKiBJdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IHRoZSB1cGRhdGUgaGFwcGVucyBpbW1lZGlhdGVseSAoc3luY2hyb25vdXNseSkgYWZ0ZXIgaXQgaXMgcmVxdWVzdGVkLlxuICAgKi9cbiAgcmVxdWVzdENvbnRlbnRVcGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZWwgPSB7XG4gICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgIGl0ZW06IHRoaXMuaXRlbSxcbiAgICAgIGZvY3VzZWQ6IHRoaXMuZm9jdXNlZCxcbiAgICAgIHNlbGVjdGVkOiB0aGlzLnNlbGVjdGVkLFxuICAgIH07XG5cbiAgICB0aGlzLnJlbmRlcmVyKHRoaXMsIHRoaXMuX2NvbWJvQm94LCBtb2RlbCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19yZW5kZXJlck9ySXRlbUNoYW5nZWQocmVuZGVyZXIsIGluZGV4LCBpdGVtLCBfc2VsZWN0ZWQsIF9mb2N1c2VkKSB7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29sZFJlbmRlcmVyICE9PSByZW5kZXJlcikge1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSAnJztcbiAgICAgIC8vIFdoZW5ldmVyIGEgTGl0LWJhc2VkIHJlbmRlcmVyIGlzIHVzZWQsIGl0IGFzc2lnbnMgYSBMaXQgcGFydCB0byB0aGUgbm9kZSBpdCB3YXMgcmVuZGVyZWQgaW50by5cbiAgICAgIC8vIFdoZW4gY2xlYXJpbmcgdGhlIHJlbmRlcmVkIGNvbnRlbnQsIHRoaXMgcGFydCBuZWVkcyB0byBiZSBtYW51YWxseSBkaXNwb3NlZCBvZi5cbiAgICAgIC8vIE90aGVyd2lzZSwgdXNpbmcgYSBMaXQtYmFzZWQgcmVuZGVyZXIgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBvciByZW5kZXIgbm90aGluZyBhZnRlcndhcmQuXG4gICAgICBkZWxldGUgdGhpcy5fJGxpdFBhcnQkO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgdGhpcy5fb2xkUmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgIHRoaXMucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX191cGRhdGVMYWJlbChsYWJlbCwgcmVuZGVyZXIpIHtcbiAgICBpZiAocmVuZGVyZXIpIHJldHVybjtcblxuICAgIHRoaXMudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoQ29tYm9Cb3hJdGVtLmlzLCBDb21ib0JveEl0ZW0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxLight\": () => (/* binding */ ComboBoxLight)\n/* harmony export */ });\n/* harmony import */ var _vaadin_combo_box_dropdown_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-combo-box-dropdown.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-dropdown.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_case_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/case-map.js */ \"./node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/* harmony import */ var _vaadin_combo_box_data_provider_mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vaadin-combo-box-data-provider-mixin.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js\");\n/* harmony import */ var _vaadin_combo_box_mixin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vaadin-combo-box-mixin.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n\n/**\n * `<vaadin-combo-box-light>` is a customizable version of the `<vaadin-combo-box>` providing\n * only the dropdown functionality and leaving the input field definition to the user.\n *\n * The element has the same API as `<vaadin-combo-box>`.\n *\n * To create a custom input field, you need to add a child element which has a two-way\n * data-bindable property representing the input value. The property name is expected\n * to be `value` by default. For example, you can use `<vaadin-text-field>` element:\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <vaadin-text-field></vaadin-text-field>\n * </vaadin-combo-box-light>\n * ```\n *\n * If you are using custom input field that has other property for value,\n * set `class=\"input\"` to enable corresponding logic, and use `attr-for-value`\n * attribute to specify which property to use:\n *\n * ```html\n * <vaadin-combo-box-light attr-for-value=\"input-value\">\n *   <custom-input class=\"input\"></custom-input>\n * </vaadin-combo-box-light>\n * ```\n *\n * You can also pass custom toggle and clear buttons with corresponding classes:\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <custom-input class=\"input\" attr-for-value=\"input-value\">\n *     <button slot=\"suffix\" class=\"clear-button\">Clear</button>\n *     <button slot=\"suffix\" class=\"toggle-button\">Toggle</button>\n *   </custom-input>\n * </vaadin-combo-box-light>\n * ```\n *\n * @fires {Event} change - Fired when the user commits a value change.\n * @fires {CustomEvent} custom-value-set - Fired when the user sets a custom value.\n * @fires {CustomEvent} filter-changed - Fired when the `filter` property changes.\n * @fires {CustomEvent} invalid-changed - Fired when the `invalid` property changes.\n * @fires {CustomEvent} opened-changed - Fired when the `opened` property changes.\n * @fires {CustomEvent} selected-item-changed - Fired when the `selectedItem` property changes.\n * @fires {CustomEvent} value-changed - Fired when the `value` property changes.\n *\n * @extends HTMLElement\n * @mixes ComboBoxDataProviderMixin\n * @mixes ComboBoxMixin\n * @mixes ThemableMixin\n */\n\nclass ComboBoxLight extends (0,_vaadin_combo_box_data_provider_mixin_js__WEBPACK_IMPORTED_MODULE_4__.ComboBoxDataProviderMixin)((0,_vaadin_combo_box_mixin_js__WEBPACK_IMPORTED_MODULE_5__.ComboBoxMixin)((0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.ThemableMixin)(_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_2__.PolymerElement))) {\n  static get is() {\n    return 'vaadin-combo-box-light';\n  }\n\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_2__.html`\n      <style>\n        :host([opened]) {\n          pointer-events: auto;\n        }\n      </style>\n\n      <slot></slot>\n\n      <vaadin-combo-box-dropdown\n        id=\"dropdown\"\n        opened=\"[[opened]]\"\n        position-target=\"[[inputElement]]\"\n        renderer=\"[[renderer]]\"\n        _focused-index=\"[[_focusedIndex]]\"\n        _item-id-path=\"[[itemIdPath]]\"\n        _item-label-path=\"[[itemLabelPath]]\"\n        loading=\"[[loading]]\"\n        theme=\"[[theme]]\"\n      ></vaadin-combo-box-dropdown>\n    `;\n  }\n\n  static get properties() {\n    return {\n      /**\n       * Name of the two-way data-bindable property representing the\n       * value of the custom input field.\n       * @attr {string} attr-for-value\n       * @type {string}\n       */\n      attrForValue: {\n        type: String,\n        value: 'value'\n      }\n    };\n  }\n  /**\n   * Used by `ClearButtonMixin` as a reference to the clear button element.\n   * @protected\n   * @return {!HTMLElement}\n   */\n\n\n  get clearElement() {\n    return this.querySelector('.clear-button');\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this._toggleElement = this.querySelector('.toggle-button');\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    this._setInputElement(this.querySelector('vaadin-text-field,.input'));\n\n    this._revertInputValue();\n  }\n  /**\n   * Returns true if the current input value satisfies all constraints (if any).\n   * @return {boolean}\n   */\n\n\n  checkValidity() {\n    if (this.inputElement.validate) {\n      return this.inputElement.validate();\n    } else {\n      return super.checkValidity();\n    }\n  }\n  /**\n   * @return {string}\n   * @protected\n   */\n\n\n  get _propertyForValue() {\n    return (0,_polymer_polymer_lib_utils_case_map_js__WEBPACK_IMPORTED_MODULE_1__.dashToCamelCase)(this.attrForValue);\n  }\n  /** @protected */\n\n\n  _isClearButton(event) {\n    return super._isClearButton(event) || event.type === 'input' && !event.isTrusted || // fake input event dispatched by clear button\n    event.composedPath()[0].getAttribute('part') === 'clear-button';\n  }\n  /**\n   * @param {!Event} event\n   * @protected\n   */\n\n\n  _onChange(event) {\n    super._onChange(event);\n\n    if (this._isClearButton(event)) {\n      this._clear();\n    }\n  }\n\n}\n\ncustomElements.define(ComboBoxLight.is, ComboBoxLight);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtbGlnaHQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBUEE7QUFZQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBekdBOztBQTRHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtbGlnaHQuanM/YmY2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCAnLi92YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duLmpzJztcbmltcG9ydCB7IGRhc2hUb0NhbWVsQ2FzZSB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGh0bWwsIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgVGhlbWFibGVNaXhpbiB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5pbXBvcnQgeyBDb21ib0JveERhdGFQcm92aWRlck1peGluIH0gZnJvbSAnLi92YWFkaW4tY29tYm8tYm94LWRhdGEtcHJvdmlkZXItbWl4aW4uanMnO1xuaW1wb3J0IHsgQ29tYm9Cb3hNaXhpbiB9IGZyb20gJy4vdmFhZGluLWNvbWJvLWJveC1taXhpbi5qcyc7XG5cbi8qKlxuICogYDx2YWFkaW4tY29tYm8tYm94LWxpZ2h0PmAgaXMgYSBjdXN0b21pemFibGUgdmVyc2lvbiBvZiB0aGUgYDx2YWFkaW4tY29tYm8tYm94PmAgcHJvdmlkaW5nXG4gKiBvbmx5IHRoZSBkcm9wZG93biBmdW5jdGlvbmFsaXR5IGFuZCBsZWF2aW5nIHRoZSBpbnB1dCBmaWVsZCBkZWZpbml0aW9uIHRvIHRoZSB1c2VyLlxuICpcbiAqIFRoZSBlbGVtZW50IGhhcyB0aGUgc2FtZSBBUEkgYXMgYDx2YWFkaW4tY29tYm8tYm94PmAuXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGlucHV0IGZpZWxkLCB5b3UgbmVlZCB0byBhZGQgYSBjaGlsZCBlbGVtZW50IHdoaWNoIGhhcyBhIHR3by13YXlcbiAqIGRhdGEtYmluZGFibGUgcHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCB2YWx1ZS4gVGhlIHByb3BlcnR5IG5hbWUgaXMgZXhwZWN0ZWRcbiAqIHRvIGJlIGB2YWx1ZWAgYnkgZGVmYXVsdC4gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIGA8dmFhZGluLXRleHQtZmllbGQ+YCBlbGVtZW50OlxuICpcbiAqIGBgYGh0bWxcbiAqIDx2YWFkaW4tY29tYm8tYm94LWxpZ2h0PlxuICogICA8dmFhZGluLXRleHQtZmllbGQ+PC92YWFkaW4tdGV4dC1maWVsZD5cbiAqIDwvdmFhZGluLWNvbWJvLWJveC1saWdodD5cbiAqIGBgYFxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgY3VzdG9tIGlucHV0IGZpZWxkIHRoYXQgaGFzIG90aGVyIHByb3BlcnR5IGZvciB2YWx1ZSxcbiAqIHNldCBgY2xhc3M9XCJpbnB1dFwiYCB0byBlbmFibGUgY29ycmVzcG9uZGluZyBsb2dpYywgYW5kIHVzZSBgYXR0ci1mb3ItdmFsdWVgXG4gKiBhdHRyaWJ1dGUgdG8gc3BlY2lmeSB3aGljaCBwcm9wZXJ0eSB0byB1c2U6XG4gKlxuICogYGBgaHRtbFxuICogPHZhYWRpbi1jb21iby1ib3gtbGlnaHQgYXR0ci1mb3ItdmFsdWU9XCJpbnB1dC12YWx1ZVwiPlxuICogICA8Y3VzdG9tLWlucHV0IGNsYXNzPVwiaW5wdXRcIj48L2N1c3RvbS1pbnB1dD5cbiAqIDwvdmFhZGluLWNvbWJvLWJveC1saWdodD5cbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGN1c3RvbSB0b2dnbGUgYW5kIGNsZWFyIGJ1dHRvbnMgd2l0aCBjb3JyZXNwb25kaW5nIGNsYXNzZXM6XG4gKlxuICogYGBgaHRtbFxuICogPHZhYWRpbi1jb21iby1ib3gtbGlnaHQ+XG4gKiAgIDxjdXN0b20taW5wdXQgY2xhc3M9XCJpbnB1dFwiIGF0dHItZm9yLXZhbHVlPVwiaW5wdXQtdmFsdWVcIj5cbiAqICAgICA8YnV0dG9uIHNsb3Q9XCJzdWZmaXhcIiBjbGFzcz1cImNsZWFyLWJ1dHRvblwiPkNsZWFyPC9idXR0b24+XG4gKiAgICAgPGJ1dHRvbiBzbG90PVwic3VmZml4XCIgY2xhc3M9XCJ0b2dnbGUtYnV0dG9uXCI+VG9nZ2xlPC9idXR0b24+XG4gKiAgIDwvY3VzdG9tLWlucHV0PlxuICogPC92YWFkaW4tY29tYm8tYm94LWxpZ2h0PlxuICogYGBgXG4gKlxuICogQGZpcmVzIHtFdmVudH0gY2hhbmdlIC0gRmlyZWQgd2hlbiB0aGUgdXNlciBjb21taXRzIGEgdmFsdWUgY2hhbmdlLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gY3VzdG9tLXZhbHVlLXNldCAtIEZpcmVkIHdoZW4gdGhlIHVzZXIgc2V0cyBhIGN1c3RvbSB2YWx1ZS5cbiAqIEBmaXJlcyB7Q3VzdG9tRXZlbnR9IGZpbHRlci1jaGFuZ2VkIC0gRmlyZWQgd2hlbiB0aGUgYGZpbHRlcmAgcHJvcGVydHkgY2hhbmdlcy5cbiAqIEBmaXJlcyB7Q3VzdG9tRXZlbnR9IGludmFsaWQtY2hhbmdlZCAtIEZpcmVkIHdoZW4gdGhlIGBpbnZhbGlkYCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gb3BlbmVkLWNoYW5nZWQgLSBGaXJlZCB3aGVuIHRoZSBgb3BlbmVkYCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gc2VsZWN0ZWQtaXRlbS1jaGFuZ2VkIC0gRmlyZWQgd2hlbiB0aGUgYHNlbGVjdGVkSXRlbWAgcHJvcGVydHkgY2hhbmdlcy5cbiAqIEBmaXJlcyB7Q3VzdG9tRXZlbnR9IHZhbHVlLWNoYW5nZWQgLSBGaXJlZCB3aGVuIHRoZSBgdmFsdWVgIHByb3BlcnR5IGNoYW5nZXMuXG4gKlxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBtaXhlcyBDb21ib0JveERhdGFQcm92aWRlck1peGluXG4gKiBAbWl4ZXMgQ29tYm9Cb3hNaXhpblxuICogQG1peGVzIFRoZW1hYmxlTWl4aW5cbiAqL1xuY2xhc3MgQ29tYm9Cb3hMaWdodCBleHRlbmRzIENvbWJvQm94RGF0YVByb3ZpZGVyTWl4aW4oQ29tYm9Cb3hNaXhpbihUaGVtYWJsZU1peGluKFBvbHltZXJFbGVtZW50KSkpIHtcbiAgc3RhdGljIGdldCBpcygpIHtcbiAgICByZXR1cm4gJ3ZhYWRpbi1jb21iby1ib3gtbGlnaHQnO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxzdHlsZT5cbiAgICAgICAgOmhvc3QoW29wZW5lZF0pIHtcbiAgICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgPHNsb3Q+PC9zbG90PlxuXG4gICAgICA8dmFhZGluLWNvbWJvLWJveC1kcm9wZG93blxuICAgICAgICBpZD1cImRyb3Bkb3duXCJcbiAgICAgICAgb3BlbmVkPVwiW1tvcGVuZWRdXVwiXG4gICAgICAgIHBvc2l0aW9uLXRhcmdldD1cIltbaW5wdXRFbGVtZW50XV1cIlxuICAgICAgICByZW5kZXJlcj1cIltbcmVuZGVyZXJdXVwiXG4gICAgICAgIF9mb2N1c2VkLWluZGV4PVwiW1tfZm9jdXNlZEluZGV4XV1cIlxuICAgICAgICBfaXRlbS1pZC1wYXRoPVwiW1tpdGVtSWRQYXRoXV1cIlxuICAgICAgICBfaXRlbS1sYWJlbC1wYXRoPVwiW1tpdGVtTGFiZWxQYXRoXV1cIlxuICAgICAgICBsb2FkaW5nPVwiW1tsb2FkaW5nXV1cIlxuICAgICAgICB0aGVtZT1cIltbdGhlbWVdXVwiXG4gICAgICA+PC92YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duPlxuICAgIGA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogTmFtZSBvZiB0aGUgdHdvLXdheSBkYXRhLWJpbmRhYmxlIHByb3BlcnR5IHJlcHJlc2VudGluZyB0aGVcbiAgICAgICAqIHZhbHVlIG9mIHRoZSBjdXN0b20gaW5wdXQgZmllbGQuXG4gICAgICAgKiBAYXR0ciB7c3RyaW5nfSBhdHRyLWZvci12YWx1ZVxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgYXR0ckZvclZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICd2YWx1ZScsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgQ2xlYXJCdXR0b25NaXhpbmAgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGNsZWFyIGJ1dHRvbiBlbGVtZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBjbGVhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNsZWFyLWJ1dHRvbicpO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgcmVhZHkoKSB7XG4gICAgc3VwZXIucmVhZHkoKTtcbiAgICB0aGlzLl90b2dnbGVFbGVtZW50ID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcudG9nZ2xlLWJ1dHRvbicpO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9zZXRJbnB1dEVsZW1lbnQodGhpcy5xdWVyeVNlbGVjdG9yKCd2YWFkaW4tdGV4dC1maWVsZCwuaW5wdXQnKSk7XG4gICAgdGhpcy5fcmV2ZXJ0SW5wdXRWYWx1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBpbnB1dCB2YWx1ZSBzYXRpc2ZpZXMgYWxsIGNvbnN0cmFpbnRzIChpZiBhbnkpLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2tWYWxpZGl0eSgpIHtcbiAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQudmFsaWRhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudC52YWxpZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2hlY2tWYWxpZGl0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldCBfcHJvcGVydHlGb3JWYWx1ZSgpIHtcbiAgICByZXR1cm4gZGFzaFRvQ2FtZWxDYXNlKHRoaXMuYXR0ckZvclZhbHVlKTtcbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIF9pc0NsZWFyQnV0dG9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHN1cGVyLl9pc0NsZWFyQnV0dG9uKGV2ZW50KSB8fFxuICAgICAgKGV2ZW50LnR5cGUgPT09ICdpbnB1dCcgJiYgIWV2ZW50LmlzVHJ1c3RlZCkgfHwgLy8gZmFrZSBpbnB1dCBldmVudCBkaXNwYXRjaGVkIGJ5IGNsZWFyIGJ1dHRvblxuICAgICAgZXZlbnQuY29tcG9zZWRQYXRoKClbMF0uZ2V0QXR0cmlidXRlKCdwYXJ0JykgPT09ICdjbGVhci1idXR0b24nXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgc3VwZXIuX29uQ2hhbmdlKGV2ZW50KTtcblxuICAgIGlmICh0aGlzLl9pc0NsZWFyQnV0dG9uKGV2ZW50KSkge1xuICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKENvbWJvQm94TGlnaHQuaXMsIENvbWJvQm94TGlnaHQpO1xuXG5leHBvcnQgeyBDb21ib0JveExpZ2h0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxMixin\": () => (/* binding */ ComboBoxMixin)\n/* harmony export */ });\n/* harmony import */ var _vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/component-base/src/browser-utils.js */ \"./node_modules/@vaadin/component-base/src/browser-utils.js\");\n/* harmony import */ var _vaadin_component_base_src_disabled_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/component-base/src/disabled-mixin.js */ \"./node_modules/@vaadin/component-base/src/disabled-mixin.js\");\n/* harmony import */ var _vaadin_component_base_src_keyboard_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/component-base/src/keyboard-mixin.js */ \"./node_modules/@vaadin/component-base/src/keyboard-mixin.js\");\n/* harmony import */ var _vaadin_component_base_src_templates_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/component-base/src/templates.js */ \"./node_modules/@vaadin/component-base/src/templates.js\");\n/* harmony import */ var _vaadin_field_base_src_input_mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/field-base/src/input-mixin.js */ \"./node_modules/@vaadin/field-base/src/input-mixin.js\");\n/* harmony import */ var _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vaadin-combo-box-placeholder.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n\n/**\n * @polymerMixin\n */\n\nconst ComboBoxMixin = subclass => class VaadinComboBoxMixinElement extends (0,_vaadin_component_base_src_keyboard_mixin_js__WEBPACK_IMPORTED_MODULE_2__.KeyboardMixin)((0,_vaadin_field_base_src_input_mixin_js__WEBPACK_IMPORTED_MODULE_4__.InputMixin)((0,_vaadin_component_base_src_disabled_mixin_js__WEBPACK_IMPORTED_MODULE_1__.DisabledMixin)(subclass))) {\n  static get properties() {\n    return {\n      /**\n       * True if the dropdown is open, false otherwise.\n       * @type {boolean}\n       */\n      opened: {\n        type: Boolean,\n        notify: true,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_openedChanged'\n      },\n\n      /**\n       * Set true to prevent the overlay from opening automatically.\n       * @attr {boolean} auto-open-disabled\n       */\n      autoOpenDisabled: {\n        type: Boolean\n      },\n\n      /**\n       * When present, it specifies that the field is read-only.\n       * @type {boolean}\n       */\n      readonly: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Custom function for rendering the content of every item.\n       * Receives three arguments:\n       *\n       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.\n       * - `comboBox` The reference to the `<vaadin-combo-box>` element.\n       * - `model` The object with the properties related with the rendered\n       *   item, contains:\n       *   - `model.index` The index of the rendered item.\n       *   - `model.item` The item.\n       * @type {ComboBoxRenderer | undefined}\n       */\n      renderer: Function,\n\n      /**\n       * A full set of items to filter the visible options from.\n       * The items can be of either `String` or `Object` type.\n       * @type {!Array<!ComboBoxItem | string> | undefined}\n       */\n      items: {\n        type: Array,\n        observer: '_itemsChanged'\n      },\n\n      /**\n       * If `true`, the user can input a value that is not present in the items list.\n       * `value` property will be set to the input value in this case.\n       * Also, when `value` is set programmatically, the input value will be set\n       * to reflect that value.\n       * @attr {boolean} allow-custom-value\n       * @type {boolean}\n       */\n      allowCustomValue: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * A subset of items, filtered based on the user input. Filtered items\n       * can be assigned directly to omit the internal filtering functionality.\n       * The items can be of either `String` or `Object` type.\n       * @type {!Array<!ComboBoxItem | string> | undefined}\n       */\n      filteredItems: {\n        type: Array\n      },\n\n      /**\n       * Used to detect user value changes and fire `change` events.\n       * @private\n       */\n      _lastCommittedValue: String,\n\n      /**\n       * When set to `true`, \"loading\" attribute is added to host and the overlay element.\n       * @type {boolean}\n       */\n      loading: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_loadingChanged'\n      },\n\n      /**\n       * @type {number}\n       * @protected\n       */\n      _focusedIndex: {\n        type: Number,\n        observer: '_focusedIndexChanged',\n        value: -1\n      },\n\n      /**\n       * Filtering string the user has typed into the input field.\n       * @type {string}\n       */\n      filter: {\n        type: String,\n        value: '',\n        notify: true\n      },\n\n      /**\n       * The selected item from the `items` array.\n       * @type {ComboBoxItem | string | undefined}\n       */\n      selectedItem: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * Path for label of the item. If `items` is an array of objects, the\n       * `itemLabelPath` is used to fetch the displayed string label for each\n       * item.\n       *\n       * The item label is also used for matching items when processing user\n       * input, i.e., for filtering and selecting items.\n       * @attr {string} item-label-path\n       * @type {string}\n       */\n      itemLabelPath: {\n        type: String,\n        value: 'label',\n        observer: '_itemLabelPathChanged'\n      },\n\n      /**\n       * Path for the value of the item. If `items` is an array of objects, the\n       * `itemValuePath:` is used to fetch the string value for the selected\n       * item.\n       *\n       * The item value is used in the `value` property of the combo box,\n       * to provide the form value.\n       * @attr {string} item-value-path\n       * @type {string}\n       */\n      itemValuePath: {\n        type: String,\n        value: 'value'\n      },\n\n      /**\n       * Path for the id of the item. If `items` is an array of objects,\n       * the `itemIdPath` is used to compare and identify the same item\n       * in `selectedItem` and `filteredItems` (items given by the\n       * `dataProvider` callback).\n       * @attr {string} item-id-path\n       */\n      itemIdPath: String,\n\n      /**\n       * @type {!HTMLElement | undefined}\n       * @protected\n       */\n      _toggleElement: {\n        type: Object,\n        observer: '_toggleElementChanged'\n      },\n\n      /** @private */\n      _closeOnBlurIsPrevented: Boolean\n    };\n  }\n\n  static get observers() {\n    return ['_filterChanged(filter, itemValuePath, itemLabelPath)', '_itemsOrPathsChanged(items.*, itemValuePath, itemLabelPath)', '_filteredItemsChanged(filteredItems.*, itemValuePath, itemLabelPath)', '_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)'];\n  }\n\n  constructor() {\n    super();\n    this._boundOnFocusout = this._onFocusout.bind(this);\n    this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this);\n    this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this);\n    this._boundClose = this.close.bind(this);\n    this._boundOnOpened = this._onOpened.bind(this);\n    this._boundOnClick = this._onClick.bind(this);\n    this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this);\n    this._boundOnTouchend = this._onTouchend.bind(this);\n  }\n  /**\n   * @return {string | undefined}\n   * @protected\n   */\n\n\n  get _inputElementValue() {\n    return this.inputElement ? this.inputElement[this._propertyForValue] : undefined;\n  }\n  /**\n   * @param {string} value\n   * @protected\n   */\n\n\n  set _inputElementValue(value) {\n    if (this.inputElement) {\n      this.inputElement[this._propertyForValue] = value;\n    }\n  }\n  /**\n   * Override method inherited from `InputMixin`\n   * to customize the input element.\n   * @protected\n   * @override\n   */\n\n\n  _inputElementChanged(input) {\n    super._inputElementChanged(input);\n\n    if (input) {\n      input.autocomplete = 'off';\n      input.autocapitalize = 'off';\n      input.setAttribute('role', 'combobox');\n      input.setAttribute('aria-autocomplete', 'list');\n      input.setAttribute('aria-expanded', !!this.opened); // Disable the macOS Safari spell check auto corrections.\n\n      input.setAttribute('spellcheck', 'false'); // Disable iOS autocorrect suggestions.\n\n      input.setAttribute('autocorrect', 'off');\n\n      this._revertInputValueToValue();\n\n      if (this.clearElement) {\n        this.clearElement.addEventListener('mousedown', this._boundOnClearButtonMouseDown);\n      }\n    }\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n    this.addEventListener('focusout', this._boundOnFocusout);\n    this._lastCommittedValue = this.value;\n    this.$.dropdown.addEventListener('selection-changed', this._boundOverlaySelectedItemChanged);\n    this.addEventListener('vaadin-combo-box-dropdown-closed', this._boundClose);\n    this.addEventListener('vaadin-combo-box-dropdown-opened', this._boundOnOpened);\n    this.addEventListener('click', this._boundOnClick);\n    this.$.dropdown.addEventListener('vaadin-overlay-touch-action', this._boundOnOverlayTouchAction);\n    this.addEventListener('touchend', this._boundOnTouchend);\n\n    const bringToFrontListener = () => {\n      requestAnimationFrame(() => {\n        this.$.dropdown.$.overlay.bringToFront();\n      });\n    };\n\n    this.addEventListener('mousedown', bringToFrontListener);\n    this.addEventListener('touchstart', bringToFrontListener);\n    (0,_vaadin_component_base_src_templates_js__WEBPACK_IMPORTED_MODULE_3__.processTemplates)(this);\n  }\n  /**\n   * Requests an update for the content of items.\n   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n\n\n  requestContentUpdate() {\n    if (!this.$.dropdown._scroller) {\n      return;\n    }\n\n    this.$.dropdown._scroller.requestContentUpdate();\n\n    this._getItemElements().forEach(item => {\n      item.requestContentUpdate();\n    });\n  }\n  /**\n   * Opens the dropdown list.\n   */\n\n\n  open() {\n    // Prevent _open() being called when input is disabled or read-only\n    if (!this.disabled && !this.readonly) {\n      this.opened = true;\n    }\n  }\n  /**\n   * Closes the dropdown list.\n   */\n\n\n  close() {\n    this.opened = false;\n  }\n  /** @private */\n\n\n  _focusedIndexChanged(index, oldIndex) {\n    if (oldIndex === undefined) {\n      return;\n    }\n\n    this._updateActiveDescendant(index);\n  }\n  /** @private */\n\n\n  _updateActiveDescendant(index) {\n    const input = this.inputElement;\n\n    if (!input) {\n      return;\n    }\n\n    const item = this._getItemElements().find(el => el.index === index);\n\n    if (item) {\n      input.setAttribute('aria-activedescendant', item.id);\n    } else {\n      input.removeAttribute('aria-activedescendant');\n    }\n  }\n  /** @private */\n\n\n  _openedChanged(opened, wasOpened) {\n    // Prevent _close() being called when opened is set to its default value (false).\n    if (wasOpened === undefined) {\n      return;\n    }\n\n    if (opened) {\n      this._openedWithFocusRing = this.hasAttribute('focus-ring'); // For touch devices, we don't want to popup virtual keyboard\n      // unless input element is explicitly focused by the user.\n\n      if (!this.hasAttribute('focused') && !_vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n        this.focus();\n      }\n    } else {\n      this._onClosed();\n\n      if (this._openedWithFocusRing && this.hasAttribute('focused')) {\n        this.setAttribute('focus-ring', '');\n      }\n    }\n\n    const input = this.inputElement;\n\n    if (input) {\n      input.setAttribute('aria-expanded', !!opened);\n\n      if (opened) {\n        input.setAttribute('aria-controls', this.$.dropdown.scrollerId);\n      } else {\n        input.removeAttribute('aria-controls');\n      }\n    }\n  }\n  /** @private */\n\n\n  _onOverlayTouchAction() {\n    // On touch devices, blur the input on touch start inside the overlay, in order to hide\n    // the virtual keyboard. But don't close the overlay on this blur.\n    this._closeOnBlurIsPrevented = true;\n    this.inputElement.blur();\n    this._closeOnBlurIsPrevented = false;\n  }\n  /** @protected */\n\n\n  _isClearButton(event) {\n    return event.composedPath()[0] === this.clearElement;\n  }\n  /**\n   * @param {Event} event\n   * @protected\n   */\n\n\n  _handleClearButtonClick(event) {\n    event.preventDefault();\n\n    this._clear(); // De-select dropdown item\n\n\n    if (this.opened) {\n      this.requestContentUpdate();\n    }\n  }\n  /**\n   * @param {Event} event\n   * @private\n   */\n\n\n  _onToggleButtonClick(event) {\n    // Prevent parent components such as `vaadin-grid`\n    // from handling the click event after it bubbles.\n    event.preventDefault();\n\n    if (this.opened) {\n      this.close();\n    } else {\n      this.open();\n    }\n  }\n  /**\n   * @param {Event} event\n   * @protected\n   */\n\n\n  _onHostClick(event) {\n    if (!this.autoOpenDisabled) {\n      event.preventDefault();\n      this.open();\n    }\n  }\n  /** @private */\n\n\n  _onClick(e) {\n    this._closeOnBlurIsPrevented = true;\n    const path = e.composedPath();\n\n    if (this._isClearButton(e)) {\n      this._handleClearButtonClick(e);\n    } else if (path.indexOf(this._toggleElement) > -1) {\n      this._onToggleButtonClick(e);\n    } else {\n      this._onHostClick(e);\n    }\n\n    this._closeOnBlurIsPrevented = false;\n  }\n  /**\n   * Override an event listener from `KeyboardMixin`.\n   * Do not call `super` to also override a listener\n   * for Esc key defined in `ClearButtonMixin`.\n   * @protected\n   * @override\n   */\n\n\n  _onKeyDown(e) {\n    if (e.keyCode === 40) {\n      this._closeOnBlurIsPrevented = true;\n\n      this._onArrowDown();\n\n      this._closeOnBlurIsPrevented = false; // prevent caret from moving\n\n      e.preventDefault();\n    } else if (e.keyCode === 38) {\n      this._closeOnBlurIsPrevented = true;\n\n      this._onArrowUp();\n\n      this._closeOnBlurIsPrevented = false; // prevent caret from moving\n\n      e.preventDefault();\n    } else if (e.keyCode === 13) {\n      this._onEnter(e);\n    } else if (e.keyCode === 27) {\n      this._onEscape(e);\n    }\n  }\n  /** @private */\n\n\n  _getItemLabel(item) {\n    return this.$.dropdown.getItemLabel(item);\n  }\n  /** @private */\n\n\n  _getItemValue(item) {\n    let value = item && this.itemValuePath ? this.get(this.itemValuePath, item) : undefined;\n\n    if (value === undefined) {\n      value = item ? item.toString() : '';\n    }\n\n    return value;\n  }\n  /** @private */\n\n\n  _onArrowDown() {\n    if (this.opened) {\n      const items = this._getOverlayItems();\n\n      if (items) {\n        this._focusedIndex = Math.min(items.length - 1, this._focusedIndex + 1);\n\n        this._prefillFocusedItemLabel();\n      }\n    } else {\n      this.open();\n    }\n  }\n  /** @private */\n\n\n  _onArrowUp() {\n    if (this.opened) {\n      if (this._focusedIndex > -1) {\n        this._focusedIndex = Math.max(0, this._focusedIndex - 1);\n      } else {\n        const items = this._getOverlayItems();\n\n        if (items) {\n          this._focusedIndex = items.length - 1;\n        }\n      }\n\n      this._prefillFocusedItemLabel();\n    } else {\n      this.open();\n    }\n  }\n  /** @private */\n\n\n  _prefillFocusedItemLabel() {\n    if (this._focusedIndex > -1) {\n      this._inputElementValue = this._getItemLabel(this.$.dropdown.focusedItem);\n\n      this._markAllSelectionRange();\n    }\n  }\n  /** @private */\n\n\n  _setSelectionRange(start, end) {\n    // Setting selection range focuses and/or moves the caret in some browsers,\n    // and there's no need to modify the selection range if the input isn't focused anyway.\n    // This affects Safari. When the overlay is open, and then hitting tab, browser should focus\n    // the next focusable element instead of the combo-box itself.\n    // Checking the focused property here is enough instead of checking the activeElement.\n    if (this.hasAttribute('focused')) {\n      this.inputElement.setSelectionRange(start, end);\n    }\n  }\n  /** @private */\n\n\n  _markAllSelectionRange() {\n    if (this._inputElementValue !== undefined) {\n      this._setSelectionRange(0, this._inputElementValue.length);\n    }\n  }\n  /** @private */\n\n\n  _clearSelectionRange() {\n    if (this._inputElementValue !== undefined) {\n      const pos = this._inputElementValue ? this._inputElementValue.length : 0;\n\n      this._setSelectionRange(pos, pos);\n    }\n  }\n  /** @private */\n\n\n  _closeOrCommit() {\n    if (!this.opened && !this.loading) {\n      this._commitValue();\n    } else {\n      this.close();\n    }\n  }\n  /** @private */\n\n\n  _onEnter(e) {\n    // do not commit value when custom values are disallowed and input value is not a valid option\n    // also stop propagation of the event, otherwise the user could submit a form while the input\n    // still contains an invalid value\n    if (!this.allowCustomValue && this._inputElementValue !== '' && this._focusedIndex < 0) {\n      // Do not submit the surrounding form.\n      e.preventDefault(); // Do not trigger global listeners\n\n      e.stopPropagation();\n      return;\n    } // stop propagation of the enter event only if the dropdown is opened, this\n    // \"consumes\" the enter event for the action of closing the dropdown\n\n\n    if (this.opened) {\n      // Do not submit the surrounding form.\n      e.preventDefault(); // Do not trigger global listeners\n\n      e.stopPropagation();\n    }\n\n    this._closeOrCommit();\n  }\n  /**\n   * @param {!KeyboardEvent} e\n   * @protected\n   */\n\n\n  _onEscape(e) {\n    if (this.autoOpenDisabled) {\n      // Auto-open is disabled\n      if (this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0) {\n        // The overlay is open or\n        // The input value has changed but the change hasn't been committed, so cancel it.\n        e.stopPropagation();\n        this._focusedIndex = -1;\n        this.cancel();\n      } else if (this.clearButtonVisible && !this.opened && !!this.value) {\n        e.stopPropagation(); // The clear button is visible and the overlay is closed, so clear the value.\n\n        this._clear();\n      }\n    } else {\n      // Auto-open is enabled\n      if (this.opened) {\n        // The overlay is open\n        e.stopPropagation();\n\n        if (this._focusedIndex > -1) {\n          // An item is focused, revert the input to the filtered value\n          this._focusedIndex = -1;\n\n          this._revertInputValue();\n        } else {\n          // No item is focused, cancel the change and close the overlay\n          this.cancel();\n        }\n      } else if (this.clearButtonVisible && !!this.value) {\n        e.stopPropagation(); // The clear button is visible and the overlay is closed, so clear the value.\n\n        this._clear();\n      }\n    }\n  }\n  /** @private */\n\n\n  _toggleElementChanged(toggleElement) {\n    if (toggleElement) {\n      // Don't blur the input on toggle mousedown\n      toggleElement.addEventListener('mousedown', e => e.preventDefault()); // Unfocus previously focused element if focus is not inside combo box (on touch devices)\n\n      toggleElement.addEventListener('click', () => {\n        if (_vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_0__.isTouch && !this.hasAttribute('focused')) {\n          document.activeElement.blur();\n        }\n      });\n    }\n  }\n  /**\n   * Clears the current value.\n   * @protected\n   */\n\n\n  _clear() {\n    this.selectedItem = null;\n\n    if (this.allowCustomValue) {\n      this.value = '';\n    }\n\n    this._detectAndDispatchChange();\n  }\n  /**\n   * Reverts back to original value.\n   */\n\n\n  cancel() {\n    this._revertInputValueToValue(); // In the next _detectAndDispatchChange() call, the change detection should not pass\n\n\n    this._lastCommittedValue = this.value;\n\n    this._closeOrCommit();\n  }\n  /** @private */\n\n\n  _onOpened() {\n    // Defer scroll position adjustment to improve performance.\n    requestAnimationFrame(() => {\n      this.$.dropdown.adjustScrollPosition(); // Set attribute after the items are rendered when overlay is opened for the first time.\n\n      this._updateActiveDescendant(this._focusedIndex);\n    }); // _detectAndDispatchChange() should not consider value changes done before opening\n\n    this._lastCommittedValue = this.value;\n  }\n  /** @private */\n\n\n  _onClosed() {\n    // Happens when the overlay is closed by clicking outside\n    if (this.opened) {\n      this.close();\n    }\n\n    if (!this.loading || this.allowCustomValue) {\n      this._commitValue();\n    }\n  }\n  /** @private */\n\n\n  _commitValue() {\n    const items = this._getOverlayItems();\n\n    if (items && this._focusedIndex > -1) {\n      const focusedItem = items[this._focusedIndex];\n\n      if (this.selectedItem !== focusedItem) {\n        this.selectedItem = focusedItem;\n      } // make sure input field is updated in case value doesn't change (i.e. FOO -> foo)\n\n\n      this._inputElementValue = this._getItemLabel(this.selectedItem);\n    } else if (this._inputElementValue === '' || this._inputElementValue === undefined) {\n      this.selectedItem = null;\n\n      if (this.allowCustomValue) {\n        this.value = '';\n      }\n    } else {\n      const toLowerCase = item => item && item.toLowerCase && item.toLowerCase(); // Try to find an item whose label matches the input value. A matching item is searched from\n      // the filteredItems array (if available) and the selectedItem (if available).\n\n\n      const itemMatchingByLabel = [...(this.filteredItems || []), this.selectedItem].find(item => {\n        return toLowerCase(this._getItemLabel(item)) === toLowerCase(this._inputElementValue);\n      });\n\n      if (this.allowCustomValue && // to prevent a repetitive input value being saved after pressing ESC and Tab.\n      !itemMatchingByLabel) {\n        const customValue = this._inputElementValue; // Store reference to the last custom value for checking it on focusout.\n\n        this._lastCustomValue = customValue; // An item matching by label was not found, but custom values are allowed.\n        // Dispatch a custom-value-set event with the input value.\n\n        const e = new CustomEvent('custom-value-set', {\n          detail: customValue,\n          composed: true,\n          cancelable: true,\n          bubbles: true\n        });\n        this.dispatchEvent(e);\n\n        if (!e.defaultPrevented) {\n          this._selectItemForValue(customValue);\n\n          this.value = customValue;\n        }\n      } else if (!this.allowCustomValue && !this.opened && itemMatchingByLabel) {\n        // An item matching by label was found, select it.\n        this.value = this._getItemValue(itemMatchingByLabel);\n      } else {\n        // Revert the input value\n        this._inputElementValue = this.selectedItem ? this._getItemLabel(this.selectedItem) : this.value || '';\n      }\n    }\n\n    this._detectAndDispatchChange();\n\n    this._clearSelectionRange();\n\n    if (!this.dataProvider) {\n      this.filter = '';\n    }\n  }\n  /**\n   * @return {string}\n   * @protected\n   */\n\n\n  get _propertyForValue() {\n    return 'value';\n  }\n  /**\n   * Override an event listener from `InputMixin`.\n   * @param {!Event} event\n   * @protected\n   * @override\n   */\n\n\n  _onInput(event) {\n    if (!this.opened && !this._isClearButton(event) && !this.autoOpenDisabled) {\n      this.open();\n    }\n\n    const value = this._inputElementValue;\n\n    if (this.filter === value) {\n      // Filter and input value might get out of sync, while keyboard navigating for example.\n      // Afterwards, input value might be changed to the same value as used in filtering.\n      // In situation like these, we need to make sure all the filter changes handlers are run.\n      this._filterChanged(this.filter, this.itemValuePath, this.itemLabelPath);\n    } else {\n      this.filter = value;\n    }\n  }\n  /**\n   * Override an event listener from `InputMixin`.\n   * @param {!Event} event\n   * @protected\n   * @override\n   */\n\n\n  _onChange(event) {\n    // Suppress the native change event fired on the native input.\n    // We use `_detectAndDispatchChange` to fire a custom event.\n    event.stopPropagation();\n  }\n  /** @private */\n\n\n  _itemLabelPathChanged(itemLabelPath) {\n    if (typeof itemLabelPath !== 'string') {\n      console.error('You should set itemLabelPath to a valid string');\n    }\n  }\n  /** @private */\n\n\n  _filterChanged(filter, itemValuePath, itemLabelPath) {\n    if (filter === undefined) {\n      return;\n    } // Scroll to the top of the list whenever the filter changes.\n\n\n    this.$.dropdown._scrollIntoView(0);\n\n    if (this.items) {\n      this.filteredItems = this._filterItems(this.items, filter);\n    } else {\n      // With certain use cases (e. g., external filtering), `items` are\n      // undefined. Filtering is unnecessary per se, but the filteredItems\n      // observer should still be invoked to update focused item.\n      this._filteredItemsChanged({\n        path: 'filteredItems',\n        value: this.filteredItems\n      }, itemValuePath, itemLabelPath);\n    }\n  }\n  /** @private */\n\n\n  _loadingChanged(loading) {\n    if (loading) {\n      this._focusedIndex = -1;\n    }\n  }\n  /** @protected */\n\n\n  _revertInputValue() {\n    if (this.filter !== '') {\n      this._inputElementValue = this.filter;\n    } else {\n      this._revertInputValueToValue();\n    }\n\n    this._clearSelectionRange();\n  }\n  /** @private */\n\n\n  _revertInputValueToValue() {\n    if (this.allowCustomValue && !this.selectedItem) {\n      this._inputElementValue = this.value;\n    } else {\n      this._inputElementValue = this._getItemLabel(this.selectedItem);\n    }\n  }\n  /** @private */\n\n\n  _selectedItemChanged(selectedItem) {\n    if (selectedItem === null || selectedItem === undefined) {\n      if (this.filteredItems) {\n        if (!this.allowCustomValue) {\n          this.value = '';\n        }\n\n        this._toggleHasValue(this.value !== '');\n\n        this._inputElementValue = this.value;\n      }\n    } else {\n      const value = this._getItemValue(selectedItem);\n\n      if (this.value !== value) {\n        this.value = value;\n\n        if (this.value !== value) {\n          // The value was changed to something else in value-changed listener,\n          // so prevent from resetting it to the previous value.\n          return;\n        }\n      }\n\n      this._toggleHasValue(true);\n\n      this._inputElementValue = this._getItemLabel(selectedItem);\n    }\n\n    this.$.dropdown._selectedItem = selectedItem;\n\n    const items = this._getOverlayItems();\n\n    if (this.filteredItems && items) {\n      this._focusedIndex = this.filteredItems.indexOf(selectedItem);\n    }\n  }\n  /**\n   * Override an observer from `InputMixin`.\n   * @protected\n   * @override\n   */\n\n\n  _valueChanged(value, oldVal) {\n    if (value === '' && oldVal === undefined) {\n      // Initializing, no need to do anything\n      // See https://github.com/vaadin/vaadin-combo-box/issues/554\n      return;\n    }\n\n    if (this._isValidValue(value)) {\n      let item;\n\n      if (this._getItemValue(this.selectedItem) !== value) {\n        this._selectItemForValue(value);\n      } else {\n        item = this.selectedItem;\n      }\n\n      if (!item && this.allowCustomValue) {\n        this._inputElementValue = value;\n      }\n\n      this._toggleHasValue(this.value !== '');\n    } else {\n      this.selectedItem = null;\n    } // In the next _detectAndDispatchChange() call, the change detection should pass\n\n\n    this._lastCommittedValue = undefined;\n  }\n  /** @private */\n\n\n  _detectAndDispatchChange() {\n    if (this.value !== this._lastCommittedValue) {\n      this.dispatchEvent(new CustomEvent('change', {\n        bubbles: true\n      }));\n      this._lastCommittedValue = this.value;\n    }\n  }\n  /** @private */\n\n\n  _itemsChanged(items, oldItems) {\n    this._ensureItemsOrDataProvider(() => {\n      this.items = oldItems;\n    });\n  }\n  /** @private */\n\n\n  _itemsOrPathsChanged(e) {\n    if (e.path === 'items' || e.path === 'items.splices') {\n      if (this.items) {\n        this.filteredItems = this.items.slice(0);\n      } else if (this.__previousItems) {\n        // Only clear filteredItems if the component had items previously but got cleared\n        this.filteredItems = null;\n      }\n\n      const valueIndex = this._indexOfValue(this.value, this.items);\n\n      this._focusedIndex = valueIndex;\n      const item = valueIndex > -1 && this.items[valueIndex];\n\n      if (item) {\n        this.selectedItem = item;\n      }\n    }\n\n    this.__previousItems = e.value;\n  }\n  /** @private */\n\n\n  _filteredItemsChanged(e) {\n    if (e.path === 'filteredItems' || e.path === 'filteredItems.splices') {\n      this._setOverlayItems(this.filteredItems); // When the external filtering is used and `value` was provided before `filteredItems`,\n      // initialize the selected item with the current value here. This will also cause\n      // the input element value to sync. In other cases, the selected item is already initialized\n      // in other observers such as `valueChanged`, `_itemsOrPathsChanged`.\n\n\n      const valueIndex = this._indexOfValue(this.value, this.filteredItems);\n\n      if (this.selectedItem === null && valueIndex >= 0) {\n        this._selectItemForValue(this.value);\n      }\n\n      const inputValue = this._inputElementValue;\n\n      if (inputValue === undefined || inputValue === this._getItemLabel(this.selectedItem)) {\n        // When the input element value is the same as the current value or not defined,\n        // set the focused index to the item that matches the value.\n        this._focusedIndex = this.$.dropdown.indexOfLabel(this._getItemLabel(this.selectedItem));\n      } else {\n        // When the user filled in something that is different from the current value = filtering is enabled,\n        // set the focused index to the item that matches the filter query.\n        this._focusedIndex = this.$.dropdown.indexOfLabel(this.filter);\n      }\n    }\n  }\n  /** @private */\n\n\n  _filterItems(arr, filter) {\n    if (!arr) {\n      return arr;\n    }\n\n    const filteredItems = arr.filter(item => {\n      filter = filter ? filter.toString().toLowerCase() : ''; // Check if item contains input value.\n\n      return this._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;\n    });\n    return filteredItems;\n  }\n  /** @private */\n\n\n  _selectItemForValue(value) {\n    const valueIndex = this._indexOfValue(value, this.filteredItems);\n\n    const previouslySelectedItem = this.selectedItem;\n\n    if (valueIndex >= 0) {\n      this.selectedItem = this.filteredItems[valueIndex];\n    } else if (this.dataProvider && this.selectedItem === undefined) {\n      this.selectedItem = undefined;\n    } else {\n      this.selectedItem = null;\n    }\n\n    if (this.selectedItem === null && previouslySelectedItem === null) {\n      this._selectedItemChanged(this.selectedItem);\n    }\n  }\n  /** @protected */\n\n\n  _getItemElements() {\n    return Array.from(this.$.dropdown._scroller.querySelectorAll('vaadin-combo-box-item'));\n  }\n  /** @private */\n\n\n  _getOverlayItems() {\n    return this.$.dropdown._items;\n  }\n  /** @private */\n\n\n  _setOverlayItems(items) {\n    this.$.dropdown.set('_items', items);\n  }\n  /** @private */\n\n\n  _indexOfValue(value, items) {\n    if (!items || !this._isValidValue(value)) {\n      return -1;\n    }\n\n    return items.findIndex(item => {\n      if (item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_5__.ComboBoxPlaceholder) {\n        return false;\n      }\n\n      return this._getItemValue(item) === value;\n    });\n  }\n  /**\n   * Checks if the value is supported as an item value in this control.\n   * @private\n   */\n\n\n  _isValidValue(value) {\n    return value !== undefined && value !== null;\n  }\n  /** @private */\n\n\n  _overlaySelectedItemChanged(e) {\n    // stop this private event from leaking outside.\n    e.stopPropagation();\n\n    if (e.detail.item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_5__.ComboBoxPlaceholder) {\n      // Placeholder items should not be selectable.\n      return;\n    }\n\n    if (this.opened) {\n      this._focusedIndex = this.filteredItems.indexOf(e.detail.item);\n      this.close();\n    } else if (this.selectedItem !== e.detail.item) {\n      this.selectedItem = e.detail.item;\n\n      this._detectAndDispatchChange();\n    }\n  }\n  /** @private */\n\n\n  __onClearButtonMouseDown(event) {\n    event.preventDefault(); // Prevent native focusout event\n\n    this.inputElement.focus();\n  }\n  /** @private */\n\n\n  _onFocusout(event) {\n    // Fixes the problem with `focusout` happening when clicking on the scroll bar on Edge\n    if (event.relatedTarget === this.$.dropdown.$.overlay) {\n      event.composedPath()[0].focus();\n      return;\n    }\n\n    if (!this.readonly && !this._closeOnBlurIsPrevented) {\n      // User's logic in `custom-value-set` event listener might cause input to blur,\n      // which will result in attempting to commit the same custom value once again.\n      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {\n        delete this._lastCustomValue;\n        return;\n      }\n\n      this._closeOrCommit();\n    }\n  }\n  /** @private */\n\n\n  _onTouchend(event) {\n    if (!this.clearElement || event.composedPath()[0] !== this.clearElement) {\n      return;\n    }\n\n    event.preventDefault();\n\n    this._clear();\n  }\n  /**\n   * Returns true if `value` is valid, and sets the `invalid` flag appropriately.\n   *\n   * @return {boolean} True if the value is valid and sets the `invalid` flag appropriately\n   */\n\n\n  validate() {\n    return !(this.invalid = !this.checkValidity());\n  }\n  /**\n   * Returns true if the current input value satisfies all constraints (if any).\n   * You can override this method for custom validations.\n   *\n   * @return {boolean}\n   */\n\n\n  checkValidity() {\n    if (super.checkValidity) {\n      return super.checkValidity();\n    }\n\n    return !this.required || !!this.value;\n  }\n  /**\n   * Fired when the value changes.\n   *\n   * @event value-changed\n   * @param {Object} detail\n   *  @param {String} detail.value the combobox value\n   */\n\n  /**\n   * Fired when selected item changes.\n   *\n   * @event selected-item-changed\n   * @param {Object} detail\n   *  @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.\n   */\n\n  /**\n   * Fired when the user sets a custom value.\n   * @event custom-value-set\n   * @param {String} detail the custom value\n   */\n\n  /**\n   * Fired when value changes.\n   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change\n   * @event change\n   */\n\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUE5S0E7QUFnTEE7O0FBRUE7QUFDQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUdBOztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFFQTs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBRUE7O0FBR0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQWhvQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L3NyYy92YWFkaW4tY29tYm8tYm94LW1peGluLmpzP2QyOTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBpc1RvdWNoIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYnJvd3Nlci11dGlscy5qcyc7XG5pbXBvcnQgeyBEaXNhYmxlZE1peGluIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlzYWJsZWQtbWl4aW4uanMnO1xuaW1wb3J0IHsgS2V5Ym9hcmRNaXhpbiB9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2tleWJvYXJkLW1peGluLmpzJztcbmltcG9ydCB7IHByb2Nlc3NUZW1wbGF0ZXMgfSBmcm9tICdAdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy90ZW1wbGF0ZXMuanMnO1xuaW1wb3J0IHsgSW5wdXRNaXhpbiB9IGZyb20gJ0B2YWFkaW4vZmllbGQtYmFzZS9zcmMvaW5wdXQtbWl4aW4uanMnO1xuaW1wb3J0IHsgQ29tYm9Cb3hQbGFjZWhvbGRlciB9IGZyb20gJy4vdmFhZGluLWNvbWJvLWJveC1wbGFjZWhvbGRlci5qcyc7XG5cbi8qKlxuICogQHBvbHltZXJNaXhpblxuICovXG5leHBvcnQgY29uc3QgQ29tYm9Cb3hNaXhpbiA9IChzdWJjbGFzcykgPT5cbiAgY2xhc3MgVmFhZGluQ29tYm9Cb3hNaXhpbkVsZW1lbnQgZXh0ZW5kcyBLZXlib2FyZE1peGluKElucHV0TWl4aW4oRGlzYWJsZWRNaXhpbihzdWJjbGFzcykpKSB7XG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaWYgdGhlIGRyb3Bkb3duIGlzIG9wZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBvcGVuZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVyOiAnX29wZW5lZENoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdHJ1ZSB0byBwcmV2ZW50IHRoZSBvdmVybGF5IGZyb20gb3BlbmluZyBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgKiBAYXR0ciB7Ym9vbGVhbn0gYXV0by1vcGVuLWRpc2FibGVkXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvT3BlbkRpc2FibGVkOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBwcmVzZW50LCBpdCBzcGVjaWZpZXMgdGhhdCB0aGUgZmllbGQgaXMgcmVhZC1vbmx5LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRvbmx5OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyB0aGUgY29udGVudCBvZiBldmVyeSBpdGVtLlxuICAgICAgICAgKiBSZWNlaXZlcyB0aHJlZSBhcmd1bWVudHM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYHJvb3RgIFRoZSBgPHZhYWRpbi1jb21iby1ib3gtaXRlbT5gIGludGVybmFsIGNvbnRhaW5lciBET00gZWxlbWVudC5cbiAgICAgICAgICogLSBgY29tYm9Cb3hgIFRoZSByZWZlcmVuY2UgdG8gdGhlIGA8dmFhZGluLWNvbWJvLWJveD5gIGVsZW1lbnQuXG4gICAgICAgICAqIC0gYG1vZGVsYCBUaGUgb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcmVsYXRlZCB3aXRoIHRoZSByZW5kZXJlZFxuICAgICAgICAgKiAgIGl0ZW0sIGNvbnRhaW5zOlxuICAgICAgICAgKiAgIC0gYG1vZGVsLmluZGV4YCBUaGUgaW5kZXggb2YgdGhlIHJlbmRlcmVkIGl0ZW0uXG4gICAgICAgICAqICAgLSBgbW9kZWwuaXRlbWAgVGhlIGl0ZW0uXG4gICAgICAgICAqIEB0eXBlIHtDb21ib0JveFJlbmRlcmVyIHwgdW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXI6IEZ1bmN0aW9uLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bGwgc2V0IG9mIGl0ZW1zIHRvIGZpbHRlciB0aGUgdmlzaWJsZSBvcHRpb25zIGZyb20uXG4gICAgICAgICAqIFRoZSBpdGVtcyBjYW4gYmUgb2YgZWl0aGVyIGBTdHJpbmdgIG9yIGBPYmplY3RgIHR5cGUuXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXk8IUNvbWJvQm94SXRlbSB8IHN0cmluZz4gfCB1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIG9ic2VydmVyOiAnX2l0ZW1zQ2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlIHVzZXIgY2FuIGlucHV0IGEgdmFsdWUgdGhhdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgaXRlbXMgbGlzdC5cbiAgICAgICAgICogYHZhbHVlYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCB0byB0aGUgaW5wdXQgdmFsdWUgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgKiBBbHNvLCB3aGVuIGB2YWx1ZWAgaXMgc2V0IHByb2dyYW1tYXRpY2FsbHksIHRoZSBpbnB1dCB2YWx1ZSB3aWxsIGJlIHNldFxuICAgICAgICAgKiB0byByZWZsZWN0IHRoYXQgdmFsdWUuXG4gICAgICAgICAqIEBhdHRyIHtib29sZWFufSBhbGxvdy1jdXN0b20tdmFsdWVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhbGxvd0N1c3RvbVZhbHVlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3Vic2V0IG9mIGl0ZW1zLCBmaWx0ZXJlZCBiYXNlZCBvbiB0aGUgdXNlciBpbnB1dC4gRmlsdGVyZWQgaXRlbXNcbiAgICAgICAgICogY2FuIGJlIGFzc2lnbmVkIGRpcmVjdGx5IHRvIG9taXQgdGhlIGludGVybmFsIGZpbHRlcmluZyBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgKiBUaGUgaXRlbXMgY2FuIGJlIG9mIGVpdGhlciBgU3RyaW5nYCBvciBgT2JqZWN0YCB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PCFDb21ib0JveEl0ZW0gfCBzdHJpbmc+IHwgdW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyZWRJdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGRldGVjdCB1c2VyIHZhbHVlIGNoYW5nZXMgYW5kIGZpcmUgYGNoYW5nZWAgZXZlbnRzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2xhc3RDb21taXR0ZWRWYWx1ZTogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIFwibG9hZGluZ1wiIGF0dHJpYnV0ZSBpcyBhZGRlZCB0byBob3N0IGFuZCB0aGUgb3ZlcmxheSBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGxvYWRpbmc6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfbG9hZGluZ0NoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfZm9jdXNlZEluZGV4OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIG9ic2VydmVyOiAnX2ZvY3VzZWRJbmRleENoYW5nZWQnLFxuICAgICAgICAgIHZhbHVlOiAtMSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlsdGVyaW5nIHN0cmluZyB0aGUgdXNlciBoYXMgdHlwZWQgaW50byB0aGUgaW5wdXQgZmllbGQuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlbGVjdGVkIGl0ZW0gZnJvbSB0aGUgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAgICogQHR5cGUge0NvbWJvQm94SXRlbSB8IHN0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGggZm9yIGxhYmVsIG9mIHRoZSBpdGVtLiBJZiBgaXRlbXNgIGlzIGFuIGFycmF5IG9mIG9iamVjdHMsIHRoZVxuICAgICAgICAgKiBgaXRlbUxhYmVsUGF0aGAgaXMgdXNlZCB0byBmZXRjaCB0aGUgZGlzcGxheWVkIHN0cmluZyBsYWJlbCBmb3IgZWFjaFxuICAgICAgICAgKiBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaXRlbSBsYWJlbCBpcyBhbHNvIHVzZWQgZm9yIG1hdGNoaW5nIGl0ZW1zIHdoZW4gcHJvY2Vzc2luZyB1c2VyXG4gICAgICAgICAqIGlucHV0LCBpLmUuLCBmb3IgZmlsdGVyaW5nIGFuZCBzZWxlY3RpbmcgaXRlbXMuXG4gICAgICAgICAqIEBhdHRyIHtzdHJpbmd9IGl0ZW0tbGFiZWwtcGF0aFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUxhYmVsUGF0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2xhYmVsJyxcbiAgICAgICAgICBvYnNlcnZlcjogJ19pdGVtTGFiZWxQYXRoQ2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGggZm9yIHRoZSB2YWx1ZSBvZiB0aGUgaXRlbS4gSWYgYGl0ZW1zYCBpcyBhbiBhcnJheSBvZiBvYmplY3RzLCB0aGVcbiAgICAgICAgICogYGl0ZW1WYWx1ZVBhdGg6YCBpcyB1c2VkIHRvIGZldGNoIHRoZSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBzZWxlY3RlZFxuICAgICAgICAgKiBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaXRlbSB2YWx1ZSBpcyB1c2VkIGluIHRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIHRoZSBjb21ibyBib3gsXG4gICAgICAgICAqIHRvIHByb3ZpZGUgdGhlIGZvcm0gdmFsdWUuXG4gICAgICAgICAqIEBhdHRyIHtzdHJpbmd9IGl0ZW0tdmFsdWUtcGF0aFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVZhbHVlUGF0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGF0aCBmb3IgdGhlIGlkIG9mIHRoZSBpdGVtLiBJZiBgaXRlbXNgIGlzIGFuIGFycmF5IG9mIG9iamVjdHMsXG4gICAgICAgICAqIHRoZSBgaXRlbUlkUGF0aGAgaXMgdXNlZCB0byBjb21wYXJlIGFuZCBpZGVudGlmeSB0aGUgc2FtZSBpdGVtXG4gICAgICAgICAqIGluIGBzZWxlY3RlZEl0ZW1gIGFuZCBgZmlsdGVyZWRJdGVtc2AgKGl0ZW1zIGdpdmVuIGJ5IHRoZVxuICAgICAgICAgKiBgZGF0YVByb3ZpZGVyYCBjYWxsYmFjaykuXG4gICAgICAgICAqIEBhdHRyIHtzdHJpbmd9IGl0ZW0taWQtcGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUlkUGF0aDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50IHwgdW5kZWZpbmVkfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdG9nZ2xlRWxlbWVudDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBvYnNlcnZlcjogJ190b2dnbGVFbGVtZW50Q2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIF9jbG9zZU9uQmx1cklzUHJldmVudGVkOiBCb29sZWFuLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICdfZmlsdGVyQ2hhbmdlZChmaWx0ZXIsIGl0ZW1WYWx1ZVBhdGgsIGl0ZW1MYWJlbFBhdGgpJyxcbiAgICAgICAgJ19pdGVtc09yUGF0aHNDaGFuZ2VkKGl0ZW1zLiosIGl0ZW1WYWx1ZVBhdGgsIGl0ZW1MYWJlbFBhdGgpJyxcbiAgICAgICAgJ19maWx0ZXJlZEl0ZW1zQ2hhbmdlZChmaWx0ZXJlZEl0ZW1zLiosIGl0ZW1WYWx1ZVBhdGgsIGl0ZW1MYWJlbFBhdGgpJyxcbiAgICAgICAgJ19zZWxlY3RlZEl0ZW1DaGFuZ2VkKHNlbGVjdGVkSXRlbSwgaXRlbVZhbHVlUGF0aCwgaXRlbUxhYmVsUGF0aCknLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9ib3VuZE9uRm9jdXNvdXQgPSB0aGlzLl9vbkZvY3Vzb3V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9ib3VuZE92ZXJsYXlTZWxlY3RlZEl0ZW1DaGFuZ2VkID0gdGhpcy5fb3ZlcmxheVNlbGVjdGVkSXRlbUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2JvdW5kT25DbGVhckJ1dHRvbk1vdXNlRG93biA9IHRoaXMuX19vbkNsZWFyQnV0dG9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9ib3VuZENsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fYm91bmRPbk9wZW5lZCA9IHRoaXMuX29uT3BlbmVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9ib3VuZE9uT3ZlcmxheVRvdWNoQWN0aW9uID0gdGhpcy5fb25PdmVybGF5VG91Y2hBY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2JvdW5kT25Ub3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldCBfaW5wdXRFbGVtZW50VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnB1dEVsZW1lbnQgPyB0aGlzLmlucHV0RWxlbWVudFt0aGlzLl9wcm9wZXJ0eUZvclZhbHVlXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0IF9pbnB1dEVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50W3RoaXMuX3Byb3BlcnR5Rm9yVmFsdWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgbWV0aG9kIGluaGVyaXRlZCBmcm9tIGBJbnB1dE1peGluYFxuICAgICAqIHRvIGN1c3RvbWl6ZSB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2lucHV0RWxlbWVudENoYW5nZWQoaW5wdXQpIHtcbiAgICAgIHN1cGVyLl9pbnB1dEVsZW1lbnRDaGFuZ2VkKGlucHV0KTtcblxuICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgIGlucHV0LmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICBpbnB1dC5hdXRvY2FwaXRhbGl6ZSA9ICdvZmYnO1xuXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgncm9sZScsICdjb21ib2JveCcpO1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXV0b2NvbXBsZXRlJywgJ2xpc3QnKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgISF0aGlzLm9wZW5lZCk7XG5cbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgbWFjT1MgU2FmYXJpIHNwZWxsIGNoZWNrIGF1dG8gY29ycmVjdGlvbnMuXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuXG4gICAgICAgIC8vIERpc2FibGUgaU9TIGF1dG9jb3JyZWN0IHN1Z2dlc3Rpb25zLlxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb3JyZWN0JywgJ29mZicpO1xuXG4gICAgICAgIHRoaXMuX3JldmVydElucHV0VmFsdWVUb1ZhbHVlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xlYXJFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5jbGVhckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fYm91bmRPbkNsZWFyQnV0dG9uTW91c2VEb3duKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgcmVhZHkoKSB7XG4gICAgICBzdXBlci5yZWFkeSgpO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fYm91bmRPbkZvY3Vzb3V0KTtcblxuICAgICAgdGhpcy5fbGFzdENvbW1pdHRlZFZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgdGhpcy4kLmRyb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbi1jaGFuZ2VkJywgdGhpcy5fYm91bmRPdmVybGF5U2VsZWN0ZWRJdGVtQ2hhbmdlZCk7XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndmFhZGluLWNvbWJvLWJveC1kcm9wZG93bi1jbG9zZWQnLCB0aGlzLl9ib3VuZENsb3NlKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndmFhZGluLWNvbWJvLWJveC1kcm9wZG93bi1vcGVuZWQnLCB0aGlzLl9ib3VuZE9uT3BlbmVkKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2spO1xuXG4gICAgICB0aGlzLiQuZHJvcGRvd24uYWRkRXZlbnRMaXN0ZW5lcigndmFhZGluLW92ZXJsYXktdG91Y2gtYWN0aW9uJywgdGhpcy5fYm91bmRPbk92ZXJsYXlUb3VjaEFjdGlvbik7XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZE9uVG91Y2hlbmQpO1xuXG4gICAgICBjb25zdCBicmluZ1RvRnJvbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLiQuZHJvcGRvd24uJC5vdmVybGF5LmJyaW5nVG9Gcm9udCgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgYnJpbmdUb0Zyb250TGlzdGVuZXIpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgYnJpbmdUb0Zyb250TGlzdGVuZXIpO1xuXG4gICAgICBwcm9jZXNzVGVtcGxhdGVzKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFuIHVwZGF0ZSBmb3IgdGhlIGNvbnRlbnQgb2YgaXRlbXMuXG4gICAgICogV2hpbGUgcGVyZm9ybWluZyB0aGUgdXBkYXRlLCBpdCBpbnZva2VzIHRoZSByZW5kZXJlciAocGFzc2VkIGluIHRoZSBgcmVuZGVyZXJgIHByb3BlcnR5KSBvbmNlIGFuIGl0ZW0uXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IHRoZSB1cGRhdGUgaGFwcGVucyBpbW1lZGlhdGVseSAoc3luY2hyb25vdXNseSkgYWZ0ZXIgaXQgaXMgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIHJlcXVlc3RDb250ZW50VXBkYXRlKCkge1xuICAgICAgaWYgKCF0aGlzLiQuZHJvcGRvd24uX3Njcm9sbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kLmRyb3Bkb3duLl9zY3JvbGxlci5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuXG4gICAgICB0aGlzLl9nZXRJdGVtRWxlbWVudHMoKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGl0ZW0ucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBkcm9wZG93biBsaXN0LlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAvLyBQcmV2ZW50IF9vcGVuKCkgYmVpbmcgY2FsbGVkIHdoZW4gaW5wdXQgaXMgZGlzYWJsZWQgb3IgcmVhZC1vbmx5XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgZHJvcGRvd24gbGlzdC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2ZvY3VzZWRJbmRleENoYW5nZWQoaW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICBpZiAob2xkSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVEZXNjZW5kYW50KGluZGV4KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfdXBkYXRlQWN0aXZlRGVzY2VuZGFudChpbmRleCkge1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0RWxlbWVudDtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0SXRlbUVsZW1lbnRzKCkuZmluZCgoZWwpID0+IGVsLmluZGV4ID09PSBpbmRleCk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGl0ZW0uaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb3BlbmVkQ2hhbmdlZChvcGVuZWQsIHdhc09wZW5lZCkge1xuICAgICAgLy8gUHJldmVudCBfY2xvc2UoKSBiZWluZyBjYWxsZWQgd2hlbiBvcGVuZWQgaXMgc2V0IHRvIGl0cyBkZWZhdWx0IHZhbHVlIChmYWxzZSkuXG4gICAgICBpZiAod2FzT3BlbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIHRoaXMuX29wZW5lZFdpdGhGb2N1c1JpbmcgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnZm9jdXMtcmluZycpO1xuICAgICAgICAvLyBGb3IgdG91Y2ggZGV2aWNlcywgd2UgZG9uJ3Qgd2FudCB0byBwb3B1cCB2aXJ0dWFsIGtleWJvYXJkXG4gICAgICAgIC8vIHVubGVzcyBpbnB1dCBlbGVtZW50IGlzIGV4cGxpY2l0bHkgZm9jdXNlZCBieSB0aGUgdXNlci5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnZm9jdXNlZCcpICYmICFpc1RvdWNoKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkNsb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5fb3BlbmVkV2l0aEZvY3VzUmluZyAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnZm9jdXNlZCcpKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2ZvY3VzLXJpbmcnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0RWxlbWVudDtcbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAhIW9wZW5lZCk7XG5cbiAgICAgICAgaWYgKG9wZW5lZCkge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsIHRoaXMuJC5kcm9wZG93bi5zY3JvbGxlcklkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vbk92ZXJsYXlUb3VjaEFjdGlvbigpIHtcbiAgICAgIC8vIE9uIHRvdWNoIGRldmljZXMsIGJsdXIgdGhlIGlucHV0IG9uIHRvdWNoIHN0YXJ0IGluc2lkZSB0aGUgb3ZlcmxheSwgaW4gb3JkZXIgdG8gaGlkZVxuICAgICAgLy8gdGhlIHZpcnR1YWwga2V5Ym9hcmQuIEJ1dCBkb24ndCBjbG9zZSB0aGUgb3ZlcmxheSBvbiB0aGlzIGJsdXIuXG4gICAgICB0aGlzLl9jbG9zZU9uQmx1cklzUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmJsdXIoKTtcbiAgICAgIHRoaXMuX2Nsb3NlT25CbHVySXNQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIF9pc0NsZWFyQnV0dG9uKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gPT09IHRoaXMuY2xlYXJFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVDbGVhckJ1dHRvbkNsaWNrKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fY2xlYXIoKTtcblxuICAgICAgLy8gRGUtc2VsZWN0IGRyb3Bkb3duIGl0ZW1cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblRvZ2dsZUJ1dHRvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAvLyBQcmV2ZW50IHBhcmVudCBjb21wb25lbnRzIHN1Y2ggYXMgYHZhYWRpbi1ncmlkYFxuICAgICAgLy8gZnJvbSBoYW5kbGluZyB0aGUgY2xpY2sgZXZlbnQgYWZ0ZXIgaXQgYnViYmxlcy5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfb25Ib3N0Q2xpY2soZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5hdXRvT3BlbkRpc2FibGVkKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vbkNsaWNrKGUpIHtcbiAgICAgIHRoaXMuX2Nsb3NlT25CbHVySXNQcmV2ZW50ZWQgPSB0cnVlO1xuXG4gICAgICBjb25zdCBwYXRoID0gZS5jb21wb3NlZFBhdGgoKTtcblxuICAgICAgaWYgKHRoaXMuX2lzQ2xlYXJCdXR0b24oZSkpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2xlYXJCdXR0b25DbGljayhlKTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5pbmRleE9mKHRoaXMuX3RvZ2dsZUVsZW1lbnQpID4gLTEpIHtcbiAgICAgICAgdGhpcy5fb25Ub2dnbGVCdXR0b25DbGljayhlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX29uSG9zdENsaWNrKGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbG9zZU9uQmx1cklzUHJldmVudGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBgS2V5Ym9hcmRNaXhpbmAuXG4gICAgICogRG8gbm90IGNhbGwgYHN1cGVyYCB0byBhbHNvIG92ZXJyaWRlIGEgbGlzdGVuZXJcbiAgICAgKiBmb3IgRXNjIGtleSBkZWZpbmVkIGluIGBDbGVhckJ1dHRvbk1peGluYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uS2V5RG93bihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSA0MCkge1xuICAgICAgICB0aGlzLl9jbG9zZU9uQmx1cklzUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb25BcnJvd0Rvd24oKTtcbiAgICAgICAgdGhpcy5fY2xvc2VPbkJsdXJJc1ByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHByZXZlbnQgY2FyZXQgZnJvbSBtb3ZpbmdcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM4KSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlT25CbHVySXNQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vbkFycm93VXAoKTtcbiAgICAgICAgdGhpcy5fY2xvc2VPbkJsdXJJc1ByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHByZXZlbnQgY2FyZXQgZnJvbSBtb3ZpbmdcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuX29uRW50ZXIoZSk7XG4gICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgdGhpcy5fb25Fc2NhcGUoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2dldEl0ZW1MYWJlbChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy4kLmRyb3Bkb3duLmdldEl0ZW1MYWJlbChpdGVtKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfZ2V0SXRlbVZhbHVlKGl0ZW0pIHtcbiAgICAgIGxldCB2YWx1ZSA9IGl0ZW0gJiYgdGhpcy5pdGVtVmFsdWVQYXRoID8gdGhpcy5nZXQodGhpcy5pdGVtVmFsdWVQYXRoLCBpdGVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gaXRlbSA/IGl0ZW0udG9TdHJpbmcoKSA6ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vbkFycm93RG93bigpIHtcbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldE92ZXJsYXlJdGVtcygpO1xuICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSBNYXRoLm1pbihpdGVtcy5sZW5ndGggLSAxLCB0aGlzLl9mb2N1c2VkSW5kZXggKyAxKTtcbiAgICAgICAgICB0aGlzLl9wcmVmaWxsRm9jdXNlZEl0ZW1MYWJlbCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb25BcnJvd1VwKCkge1xuICAgICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c2VkSW5kZXggPiAtMSkge1xuICAgICAgICAgIHRoaXMuX2ZvY3VzZWRJbmRleCA9IE1hdGgubWF4KDAsIHRoaXMuX2ZvY3VzZWRJbmRleCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ2V0T3ZlcmxheUl0ZW1zKCk7XG4gICAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ByZWZpbGxGb2N1c2VkSXRlbUxhYmVsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfcHJlZmlsbEZvY3VzZWRJdGVtTGFiZWwoKSB7XG4gICAgICBpZiAodGhpcy5fZm9jdXNlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgPSB0aGlzLl9nZXRJdGVtTGFiZWwodGhpcy4kLmRyb3Bkb3duLmZvY3VzZWRJdGVtKTtcbiAgICAgICAgdGhpcy5fbWFya0FsbFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3NldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIFNldHRpbmcgc2VsZWN0aW9uIHJhbmdlIGZvY3VzZXMgYW5kL29yIG1vdmVzIHRoZSBjYXJldCBpbiBzb21lIGJyb3dzZXJzLFxuICAgICAgLy8gYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byBtb2RpZnkgdGhlIHNlbGVjdGlvbiByYW5nZSBpZiB0aGUgaW5wdXQgaXNuJ3QgZm9jdXNlZCBhbnl3YXkuXG4gICAgICAvLyBUaGlzIGFmZmVjdHMgU2FmYXJpLiBXaGVuIHRoZSBvdmVybGF5IGlzIG9wZW4sIGFuZCB0aGVuIGhpdHRpbmcgdGFiLCBicm93c2VyIHNob3VsZCBmb2N1c1xuICAgICAgLy8gdGhlIG5leHQgZm9jdXNhYmxlIGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgY29tYm8tYm94IGl0c2VsZi5cbiAgICAgIC8vIENoZWNraW5nIHRoZSBmb2N1c2VkIHByb3BlcnR5IGhlcmUgaXMgZW5vdWdoIGluc3RlYWQgb2YgY2hlY2tpbmcgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2ZvY3VzZWQnKSkge1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfbWFya0FsbFNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgaWYgKHRoaXMuX2lucHV0RWxlbWVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uUmFuZ2UoMCwgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2lucHV0RWxlbWVudFZhbHVlID8gdGhpcy5faW5wdXRFbGVtZW50VmFsdWUubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uUmFuZ2UocG9zLCBwb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9jbG9zZU9yQ29tbWl0KCkge1xuICAgICAgaWYgKCF0aGlzLm9wZW5lZCAmJiAhdGhpcy5sb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuX2NvbW1pdFZhbHVlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX29uRW50ZXIoZSkge1xuICAgICAgLy8gZG8gbm90IGNvbW1pdCB2YWx1ZSB3aGVuIGN1c3RvbSB2YWx1ZXMgYXJlIGRpc2FsbG93ZWQgYW5kIGlucHV0IHZhbHVlIGlzIG5vdCBhIHZhbGlkIG9wdGlvblxuICAgICAgLy8gYWxzbyBzdG9wIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCwgb3RoZXJ3aXNlIHRoZSB1c2VyIGNvdWxkIHN1Ym1pdCBhIGZvcm0gd2hpbGUgdGhlIGlucHV0XG4gICAgICAvLyBzdGlsbCBjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlXG4gICAgICBpZiAoIXRoaXMuYWxsb3dDdXN0b21WYWx1ZSAmJiB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAhPT0gJycgJiYgdGhpcy5fZm9jdXNlZEluZGV4IDwgMCkge1xuICAgICAgICAvLyBEbyBub3Qgc3VibWl0IHRoZSBzdXJyb3VuZGluZyBmb3JtLlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzdG9wIHByb3BhZ2F0aW9uIG9mIHRoZSBlbnRlciBldmVudCBvbmx5IGlmIHRoZSBkcm9wZG93biBpcyBvcGVuZWQsIHRoaXNcbiAgICAgIC8vIFwiY29uc3VtZXNcIiB0aGUgZW50ZXIgZXZlbnQgZm9yIHRoZSBhY3Rpb24gb2YgY2xvc2luZyB0aGUgZHJvcGRvd25cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICAvLyBEbyBub3Qgc3VibWl0IHRoZSBzdXJyb3VuZGluZyBmb3JtLlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xvc2VPckNvbW1pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX29uRXNjYXBlKGUpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9PcGVuRGlzYWJsZWQpIHtcbiAgICAgICAgLy8gQXV0by1vcGVuIGlzIGRpc2FibGVkXG4gICAgICAgIGlmICh0aGlzLm9wZW5lZCB8fCAodGhpcy52YWx1ZSAhPT0gdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgJiYgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAvLyBUaGUgb3ZlcmxheSBpcyBvcGVuIG9yXG4gICAgICAgICAgLy8gVGhlIGlucHV0IHZhbHVlIGhhcyBjaGFuZ2VkIGJ1dCB0aGUgY2hhbmdlIGhhc24ndCBiZWVuIGNvbW1pdHRlZCwgc28gY2FuY2VsIGl0LlxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5fZm9jdXNlZEluZGV4ID0gLTE7XG4gICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNsZWFyQnV0dG9uVmlzaWJsZSAmJiAhdGhpcy5vcGVuZWQgJiYgISF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAvLyBUaGUgY2xlYXIgYnV0dG9uIGlzIHZpc2libGUgYW5kIHRoZSBvdmVybGF5IGlzIGNsb3NlZCwgc28gY2xlYXIgdGhlIHZhbHVlLlxuICAgICAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF1dG8tb3BlbiBpcyBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICAgIC8vIFRoZSBvdmVybGF5IGlzIG9wZW5cbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzZWRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBBbiBpdGVtIGlzIGZvY3VzZWQsIHJldmVydCB0aGUgaW5wdXQgdG8gdGhlIGZpbHRlcmVkIHZhbHVlXG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX3JldmVydElucHV0VmFsdWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gaXRlbSBpcyBmb2N1c2VkLCBjYW5jZWwgdGhlIGNoYW5nZSBhbmQgY2xvc2UgdGhlIG92ZXJsYXlcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2xlYXJCdXR0b25WaXNpYmxlICYmICEhdGhpcy52YWx1ZSkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgLy8gVGhlIGNsZWFyIGJ1dHRvbiBpcyB2aXNpYmxlIGFuZCB0aGUgb3ZlcmxheSBpcyBjbG9zZWQsIHNvIGNsZWFyIHRoZSB2YWx1ZS5cbiAgICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3RvZ2dsZUVsZW1lbnRDaGFuZ2VkKHRvZ2dsZUVsZW1lbnQpIHtcbiAgICAgIGlmICh0b2dnbGVFbGVtZW50KSB7XG4gICAgICAgIC8vIERvbid0IGJsdXIgdGhlIGlucHV0IG9uIHRvZ2dsZSBtb3VzZWRvd25cbiAgICAgICAgdG9nZ2xlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICAgICAgLy8gVW5mb2N1cyBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBpZiBmb2N1cyBpcyBub3QgaW5zaWRlIGNvbWJvIGJveCAob24gdG91Y2ggZGV2aWNlcylcbiAgICAgICAgdG9nZ2xlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICBpZiAoaXNUb3VjaCAmJiAhdGhpcy5oYXNBdHRyaWJ1dGUoJ2ZvY3VzZWQnKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jbGVhcigpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuYWxsb3dDdXN0b21WYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RldGVjdEFuZERpc3BhdGNoQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyBiYWNrIHRvIG9yaWdpbmFsIHZhbHVlLlxuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuX3JldmVydElucHV0VmFsdWVUb1ZhbHVlKCk7XG4gICAgICAvLyBJbiB0aGUgbmV4dCBfZGV0ZWN0QW5kRGlzcGF0Y2hDaGFuZ2UoKSBjYWxsLCB0aGUgY2hhbmdlIGRldGVjdGlvbiBzaG91bGQgbm90IHBhc3NcbiAgICAgIHRoaXMuX2xhc3RDb21taXR0ZWRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLl9jbG9zZU9yQ29tbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX29uT3BlbmVkKCkge1xuICAgICAgLy8gRGVmZXIgc2Nyb2xsIHBvc2l0aW9uIGFkanVzdG1lbnQgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuJC5kcm9wZG93bi5hZGp1c3RTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIFNldCBhdHRyaWJ1dGUgYWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW5kZXJlZCB3aGVuIG92ZXJsYXkgaXMgb3BlbmVkIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlRGVzY2VuZGFudCh0aGlzLl9mb2N1c2VkSW5kZXgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIF9kZXRlY3RBbmREaXNwYXRjaENoYW5nZSgpIHNob3VsZCBub3QgY29uc2lkZXIgdmFsdWUgY2hhbmdlcyBkb25lIGJlZm9yZSBvcGVuaW5nXG4gICAgICB0aGlzLl9sYXN0Q29tbWl0dGVkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vbkNsb3NlZCgpIHtcbiAgICAgIC8vIEhhcHBlbnMgd2hlbiB0aGUgb3ZlcmxheSBpcyBjbG9zZWQgYnkgY2xpY2tpbmcgb3V0c2lkZVxuICAgICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmxvYWRpbmcgfHwgdGhpcy5hbGxvd0N1c3RvbVZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbW1pdFZhbHVlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2NvbW1pdFZhbHVlKCkge1xuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRPdmVybGF5SXRlbXMoKTtcbiAgICAgIGlmIChpdGVtcyAmJiB0aGlzLl9mb2N1c2VkSW5kZXggPiAtMSkge1xuICAgICAgICBjb25zdCBmb2N1c2VkSXRlbSA9IGl0ZW1zW3RoaXMuX2ZvY3VzZWRJbmRleF07XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSAhPT0gZm9jdXNlZEl0ZW0pIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IGZvY3VzZWRJdGVtO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBpbnB1dCBmaWVsZCBpcyB1cGRhdGVkIGluIGNhc2UgdmFsdWUgZG9lc24ndCBjaGFuZ2UgKGkuZS4gRk9PIC0+IGZvbylcbiAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgPSB0aGlzLl9nZXRJdGVtTGFiZWwodGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9PT0gJycgfHwgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuYWxsb3dDdXN0b21WYWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdG9Mb3dlckNhc2UgPSAoaXRlbSkgPT4gaXRlbSAmJiBpdGVtLnRvTG93ZXJDYXNlICYmIGl0ZW0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhbiBpdGVtIHdob3NlIGxhYmVsIG1hdGNoZXMgdGhlIGlucHV0IHZhbHVlLiBBIG1hdGNoaW5nIGl0ZW0gaXMgc2VhcmNoZWQgZnJvbVxuICAgICAgICAvLyB0aGUgZmlsdGVyZWRJdGVtcyBhcnJheSAoaWYgYXZhaWxhYmxlKSBhbmQgdGhlIHNlbGVjdGVkSXRlbSAoaWYgYXZhaWxhYmxlKS5cbiAgICAgICAgY29uc3QgaXRlbU1hdGNoaW5nQnlMYWJlbCA9IFsuLi4odGhpcy5maWx0ZXJlZEl0ZW1zIHx8IFtdKSwgdGhpcy5zZWxlY3RlZEl0ZW1dLmZpbmQoKGl0ZW0pID0+IHtcbiAgICAgICAgICByZXR1cm4gdG9Mb3dlckNhc2UodGhpcy5fZ2V0SXRlbUxhYmVsKGl0ZW0pKSA9PT0gdG9Mb3dlckNhc2UodGhpcy5faW5wdXRFbGVtZW50VmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5hbGxvd0N1c3RvbVZhbHVlICYmXG4gICAgICAgICAgLy8gdG8gcHJldmVudCBhIHJlcGV0aXRpdmUgaW5wdXQgdmFsdWUgYmVpbmcgc2F2ZWQgYWZ0ZXIgcHJlc3NpbmcgRVNDIGFuZCBUYWIuXG4gICAgICAgICAgIWl0ZW1NYXRjaGluZ0J5TGFiZWxcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgY3VzdG9tVmFsdWUgPSB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZTtcblxuICAgICAgICAgIC8vIFN0b3JlIHJlZmVyZW5jZSB0byB0aGUgbGFzdCBjdXN0b20gdmFsdWUgZm9yIGNoZWNraW5nIGl0IG9uIGZvY3Vzb3V0LlxuICAgICAgICAgIHRoaXMuX2xhc3RDdXN0b21WYWx1ZSA9IGN1c3RvbVZhbHVlO1xuXG4gICAgICAgICAgLy8gQW4gaXRlbSBtYXRjaGluZyBieSBsYWJlbCB3YXMgbm90IGZvdW5kLCBidXQgY3VzdG9tIHZhbHVlcyBhcmUgYWxsb3dlZC5cbiAgICAgICAgICAvLyBEaXNwYXRjaCBhIGN1c3RvbS12YWx1ZS1zZXQgZXZlbnQgd2l0aCB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICAgICAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudCgnY3VzdG9tLXZhbHVlLXNldCcsIHtcbiAgICAgICAgICAgIGRldGFpbDogY3VzdG9tVmFsdWUsXG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0SXRlbUZvclZhbHVlKGN1c3RvbVZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjdXN0b21WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYWxsb3dDdXN0b21WYWx1ZSAmJiAhdGhpcy5vcGVuZWQgJiYgaXRlbU1hdGNoaW5nQnlMYWJlbCkge1xuICAgICAgICAgIC8vIEFuIGl0ZW0gbWF0Y2hpbmcgYnkgbGFiZWwgd2FzIGZvdW5kLCBzZWxlY3QgaXQuXG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2dldEl0ZW1WYWx1ZShpdGVtTWF0Y2hpbmdCeUxhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXZlcnQgdGhlIGlucHV0IHZhbHVlXG4gICAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgPSB0aGlzLnNlbGVjdGVkSXRlbSA/IHRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLnNlbGVjdGVkSXRlbSkgOiB0aGlzLnZhbHVlIHx8ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RldGVjdEFuZERpc3BhdGNoQ2hhbmdlKCk7XG5cbiAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcblxuICAgICAgaWYgKCF0aGlzLmRhdGFQcm92aWRlcikge1xuICAgICAgICB0aGlzLmZpbHRlciA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0IF9wcm9wZXJ0eUZvclZhbHVlKCkge1xuICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBgSW5wdXRNaXhpbmAuXG4gICAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbklucHV0KGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMub3BlbmVkICYmICF0aGlzLl9pc0NsZWFyQnV0dG9uKGV2ZW50KSAmJiAhdGhpcy5hdXRvT3BlbkRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2lucHV0RWxlbWVudFZhbHVlO1xuICAgICAgaWYgKHRoaXMuZmlsdGVyID09PSB2YWx1ZSkge1xuICAgICAgICAvLyBGaWx0ZXIgYW5kIGlucHV0IHZhbHVlIG1pZ2h0IGdldCBvdXQgb2Ygc3luYywgd2hpbGUga2V5Ym9hcmQgbmF2aWdhdGluZyBmb3IgZXhhbXBsZS5cbiAgICAgICAgLy8gQWZ0ZXJ3YXJkcywgaW5wdXQgdmFsdWUgbWlnaHQgYmUgY2hhbmdlZCB0byB0aGUgc2FtZSB2YWx1ZSBhcyB1c2VkIGluIGZpbHRlcmluZy5cbiAgICAgICAgLy8gSW4gc2l0dWF0aW9uIGxpa2UgdGhlc2UsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCB0aGUgZmlsdGVyIGNoYW5nZXMgaGFuZGxlcnMgYXJlIHJ1bi5cbiAgICAgICAgdGhpcy5fZmlsdGVyQ2hhbmdlZCh0aGlzLmZpbHRlciwgdGhpcy5pdGVtVmFsdWVQYXRoLCB0aGlzLml0ZW1MYWJlbFBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGBJbnB1dE1peGluYC5cbiAgICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAvLyBTdXBwcmVzcyB0aGUgbmF0aXZlIGNoYW5nZSBldmVudCBmaXJlZCBvbiB0aGUgbmF0aXZlIGlucHV0LlxuICAgICAgLy8gV2UgdXNlIGBfZGV0ZWN0QW5kRGlzcGF0Y2hDaGFuZ2VgIHRvIGZpcmUgYSBjdXN0b20gZXZlbnQuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfaXRlbUxhYmVsUGF0aENoYW5nZWQoaXRlbUxhYmVsUGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtTGFiZWxQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdZb3Ugc2hvdWxkIHNldCBpdGVtTGFiZWxQYXRoIHRvIGEgdmFsaWQgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2ZpbHRlckNoYW5nZWQoZmlsdGVyLCBpdGVtVmFsdWVQYXRoLCBpdGVtTGFiZWxQYXRoKSB7XG4gICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgbGlzdCB3aGVuZXZlciB0aGUgZmlsdGVyIGNoYW5nZXMuXG4gICAgICB0aGlzLiQuZHJvcGRvd24uX3Njcm9sbEludG9WaWV3KDApO1xuXG4gICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSB0aGlzLl9maWx0ZXJJdGVtcyh0aGlzLml0ZW1zLCBmaWx0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2l0aCBjZXJ0YWluIHVzZSBjYXNlcyAoZS4gZy4sIGV4dGVybmFsIGZpbHRlcmluZyksIGBpdGVtc2AgYXJlXG4gICAgICAgIC8vIHVuZGVmaW5lZC4gRmlsdGVyaW5nIGlzIHVubmVjZXNzYXJ5IHBlciBzZSwgYnV0IHRoZSBmaWx0ZXJlZEl0ZW1zXG4gICAgICAgIC8vIG9ic2VydmVyIHNob3VsZCBzdGlsbCBiZSBpbnZva2VkIHRvIHVwZGF0ZSBmb2N1c2VkIGl0ZW0uXG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkSXRlbXNDaGFuZ2VkKHsgcGF0aDogJ2ZpbHRlcmVkSXRlbXMnLCB2YWx1ZTogdGhpcy5maWx0ZXJlZEl0ZW1zIH0sIGl0ZW1WYWx1ZVBhdGgsIGl0ZW1MYWJlbFBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9sb2FkaW5nQ2hhbmdlZChsb2FkaW5nKSB7XG4gICAgICBpZiAobG9hZGluZykge1xuICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIF9yZXZlcnRJbnB1dFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyICE9PSAnJykge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMuZmlsdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmV2ZXJ0SW5wdXRWYWx1ZVRvVmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfcmV2ZXJ0SW5wdXRWYWx1ZVRvVmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5hbGxvd0N1c3RvbVZhbHVlICYmICF0aGlzLnNlbGVjdGVkSXRlbSkge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLnNlbGVjdGVkSXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3NlbGVjdGVkSXRlbUNoYW5nZWQoc2VsZWN0ZWRJdGVtKSB7XG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtID09PSBudWxsIHx8IHNlbGVjdGVkSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkSXRlbXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dDdXN0b21WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3RvZ2dsZUhhc1ZhbHVlKHRoaXMudmFsdWUgIT09ICcnKTtcbiAgICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0SXRlbVZhbHVlKHNlbGVjdGVkSXRlbSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgY2hhbmdlZCB0byBzb21ldGhpbmcgZWxzZSBpbiB2YWx1ZS1jaGFuZ2VkIGxpc3RlbmVyLFxuICAgICAgICAgICAgLy8gc28gcHJldmVudCBmcm9tIHJlc2V0dGluZyBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdG9nZ2xlSGFzVmFsdWUodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudFZhbHVlID0gdGhpcy5fZ2V0SXRlbUxhYmVsKHNlbGVjdGVkSXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJC5kcm9wZG93bi5fc2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtO1xuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRPdmVybGF5SXRlbXMoKTtcbiAgICAgIGlmICh0aGlzLmZpbHRlcmVkSXRlbXMgJiYgaXRlbXMpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZEluZGV4ID0gdGhpcy5maWx0ZXJlZEl0ZW1zLmluZGV4T2Yoc2VsZWN0ZWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBhbiBvYnNlcnZlciBmcm9tIGBJbnB1dE1peGluYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3ZhbHVlQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICcnICYmIG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemluZywgbm8gbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZhYWRpbi92YWFkaW4tY29tYm8tYm94L2lzc3Vlcy81NTRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNWYWxpZFZhbHVlKHZhbHVlKSkge1xuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgaWYgKHRoaXMuX2dldEl0ZW1WYWx1ZSh0aGlzLnNlbGVjdGVkSXRlbSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0SXRlbUZvclZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtID0gdGhpcy5zZWxlY3RlZEl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWl0ZW0gJiYgdGhpcy5hbGxvd0N1c3RvbVZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RvZ2dsZUhhc1ZhbHVlKHRoaXMudmFsdWUgIT09ICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIEluIHRoZSBuZXh0IF9kZXRlY3RBbmREaXNwYXRjaENoYW5nZSgpIGNhbGwsIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIHNob3VsZCBwYXNzXG4gICAgICB0aGlzLl9sYXN0Q29tbWl0dGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2RldGVjdEFuZERpc3BhdGNoQ2hhbmdlKCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHRoaXMuX2xhc3RDb21taXR0ZWRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLl9sYXN0Q29tbWl0dGVkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9pdGVtc0NoYW5nZWQoaXRlbXMsIG9sZEl0ZW1zKSB7XG4gICAgICB0aGlzLl9lbnN1cmVJdGVtc09yRGF0YVByb3ZpZGVyKCgpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG9sZEl0ZW1zO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2l0ZW1zT3JQYXRoc0NoYW5nZWQoZSkge1xuICAgICAgaWYgKGUucGF0aCA9PT0gJ2l0ZW1zJyB8fCBlLnBhdGggPT09ICdpdGVtcy5zcGxpY2VzJykge1xuICAgICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fX3ByZXZpb3VzSXRlbXMpIHtcbiAgICAgICAgICAvLyBPbmx5IGNsZWFyIGZpbHRlcmVkSXRlbXMgaWYgdGhlIGNvbXBvbmVudCBoYWQgaXRlbXMgcHJldmlvdXNseSBidXQgZ290IGNsZWFyZWRcbiAgICAgICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWVJbmRleCA9IHRoaXMuX2luZGV4T2ZWYWx1ZSh0aGlzLnZhbHVlLCB0aGlzLml0ZW1zKTtcbiAgICAgICAgdGhpcy5fZm9jdXNlZEluZGV4ID0gdmFsdWVJbmRleDtcblxuICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVJbmRleCA+IC0xICYmIHRoaXMuaXRlbXNbdmFsdWVJbmRleF07XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9fcHJldmlvdXNJdGVtcyA9IGUudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2ZpbHRlcmVkSXRlbXNDaGFuZ2VkKGUpIHtcbiAgICAgIGlmIChlLnBhdGggPT09ICdmaWx0ZXJlZEl0ZW1zJyB8fCBlLnBhdGggPT09ICdmaWx0ZXJlZEl0ZW1zLnNwbGljZXMnKSB7XG4gICAgICAgIHRoaXMuX3NldE92ZXJsYXlJdGVtcyh0aGlzLmZpbHRlcmVkSXRlbXMpO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlIGV4dGVybmFsIGZpbHRlcmluZyBpcyB1c2VkIGFuZCBgdmFsdWVgIHdhcyBwcm92aWRlZCBiZWZvcmUgYGZpbHRlcmVkSXRlbXNgLFxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZWxlY3RlZCBpdGVtIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaGVyZS4gVGhpcyB3aWxsIGFsc28gY2F1c2VcbiAgICAgICAgLy8gdGhlIGlucHV0IGVsZW1lbnQgdmFsdWUgdG8gc3luYy4gSW4gb3RoZXIgY2FzZXMsIHRoZSBzZWxlY3RlZCBpdGVtIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gaW4gb3RoZXIgb2JzZXJ2ZXJzIHN1Y2ggYXMgYHZhbHVlQ2hhbmdlZGAsIGBfaXRlbXNPclBhdGhzQ2hhbmdlZGAuXG4gICAgICAgIGNvbnN0IHZhbHVlSW5kZXggPSB0aGlzLl9pbmRleE9mVmFsdWUodGhpcy52YWx1ZSwgdGhpcy5maWx0ZXJlZEl0ZW1zKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtID09PSBudWxsICYmIHZhbHVlSW5kZXggPj0gMCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdEl0ZW1Gb3JWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZTtcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpbnB1dFZhbHVlID09PSB0aGlzLl9nZXRJdGVtTGFiZWwodGhpcy5zZWxlY3RlZEl0ZW0pKSB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgaW5wdXQgZWxlbWVudCB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB2YWx1ZSBvciBub3QgZGVmaW5lZCxcbiAgICAgICAgICAvLyBzZXQgdGhlIGZvY3VzZWQgaW5kZXggdG8gdGhlIGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSB2YWx1ZS5cbiAgICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSB0aGlzLiQuZHJvcGRvd24uaW5kZXhPZkxhYmVsKHRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLnNlbGVjdGVkSXRlbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIHVzZXIgZmlsbGVkIGluIHNvbWV0aGluZyB0aGF0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHZhbHVlID0gZmlsdGVyaW5nIGlzIGVuYWJsZWQsXG4gICAgICAgICAgLy8gc2V0IHRoZSBmb2N1c2VkIGluZGV4IHRvIHRoZSBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgZmlsdGVyIHF1ZXJ5LlxuICAgICAgICAgIHRoaXMuX2ZvY3VzZWRJbmRleCA9IHRoaXMuJC5kcm9wZG93bi5pbmRleE9mTGFiZWwodGhpcy5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2ZpbHRlckl0ZW1zKGFyciwgZmlsdGVyKSB7XG4gICAgICBpZiAoIWFycikge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gYXJyLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICBmaWx0ZXIgPSBmaWx0ZXIgPyBmaWx0ZXIudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0ZW0gY29udGFpbnMgaW5wdXQgdmFsdWUuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtTGFiZWwoaXRlbSkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoZmlsdGVyKSA+IC0xO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBmaWx0ZXJlZEl0ZW1zO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9zZWxlY3RJdGVtRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgIGNvbnN0IHZhbHVlSW5kZXggPSB0aGlzLl9pbmRleE9mVmFsdWUodmFsdWUsIHRoaXMuZmlsdGVyZWRJdGVtcyk7XG4gICAgICBjb25zdCBwcmV2aW91c2x5U2VsZWN0ZWRJdGVtID0gdGhpcy5zZWxlY3RlZEl0ZW07XG5cbiAgICAgIGlmICh2YWx1ZUluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSB0aGlzLmZpbHRlcmVkSXRlbXNbdmFsdWVJbmRleF07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVByb3ZpZGVyICYmIHRoaXMuc2VsZWN0ZWRJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSA9PT0gbnVsbCAmJiBwcmV2aW91c2x5U2VsZWN0ZWRJdGVtID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSXRlbUNoYW5nZWQodGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgX2dldEl0ZW1FbGVtZW50cygpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuJC5kcm9wZG93bi5fc2Nyb2xsZXIucXVlcnlTZWxlY3RvckFsbCgndmFhZGluLWNvbWJvLWJveC1pdGVtJykpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9nZXRPdmVybGF5SXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kLmRyb3Bkb3duLl9pdGVtcztcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfc2V0T3ZlcmxheUl0ZW1zKGl0ZW1zKSB7XG4gICAgICB0aGlzLiQuZHJvcGRvd24uc2V0KCdfaXRlbXMnLCBpdGVtcyk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2luZGV4T2ZWYWx1ZSh2YWx1ZSwgaXRlbXMpIHtcbiAgICAgIGlmICghaXRlbXMgfHwgIXRoaXMuX2lzVmFsaWRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXMuZmluZEluZGV4KChpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQ29tYm9Cb3hQbGFjZWhvbGRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtVmFsdWUoaXRlbSkgPT09IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBzdXBwb3J0ZWQgYXMgYW4gaXRlbSB2YWx1ZSBpbiB0aGlzIGNvbnRyb2wuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNWYWxpZFZhbHVlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb3ZlcmxheVNlbGVjdGVkSXRlbUNoYW5nZWQoZSkge1xuICAgICAgLy8gc3RvcCB0aGlzIHByaXZhdGUgZXZlbnQgZnJvbSBsZWFraW5nIG91dHNpZGUuXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoZS5kZXRhaWwuaXRlbSBpbnN0YW5jZW9mIENvbWJvQm94UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgLy8gUGxhY2Vob2xkZXIgaXRlbXMgc2hvdWxkIG5vdCBiZSBzZWxlY3RhYmxlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSB0aGlzLmZpbHRlcmVkSXRlbXMuaW5kZXhPZihlLmRldGFpbC5pdGVtKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSXRlbSAhPT0gZS5kZXRhaWwuaXRlbSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IGUuZGV0YWlsLml0ZW07XG4gICAgICAgIHRoaXMuX2RldGVjdEFuZERpc3BhdGNoQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX19vbkNsZWFyQnV0dG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IG5hdGl2ZSBmb2N1c291dCBldmVudFxuICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb25Gb2N1c291dChldmVudCkge1xuICAgICAgLy8gRml4ZXMgdGhlIHByb2JsZW0gd2l0aCBgZm9jdXNvdXRgIGhhcHBlbmluZyB3aGVuIGNsaWNraW5nIG9uIHRoZSBzY3JvbGwgYmFyIG9uIEVkZ2VcbiAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ID09PSB0aGlzLiQuZHJvcGRvd24uJC5vdmVybGF5KSB7XG4gICAgICAgIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdLmZvY3VzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5yZWFkb25seSAmJiAhdGhpcy5fY2xvc2VPbkJsdXJJc1ByZXZlbnRlZCkge1xuICAgICAgICAvLyBVc2VyJ3MgbG9naWMgaW4gYGN1c3RvbS12YWx1ZS1zZXRgIGV2ZW50IGxpc3RlbmVyIG1pZ2h0IGNhdXNlIGlucHV0IHRvIGJsdXIsXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgcmVzdWx0IGluIGF0dGVtcHRpbmcgdG8gY29tbWl0IHRoZSBzYW1lIGN1c3RvbSB2YWx1ZSBvbmNlIGFnYWluLlxuICAgICAgICBpZiAoIXRoaXMub3BlbmVkICYmIHRoaXMuYWxsb3dDdXN0b21WYWx1ZSAmJiB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9PT0gdGhpcy5fbGFzdEN1c3RvbVZhbHVlKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2xhc3RDdXN0b21WYWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jbG9zZU9yQ29tbWl0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX29uVG91Y2hlbmQoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5jbGVhckVsZW1lbnQgfHwgZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gIT09IHRoaXMuY2xlYXJFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQsIGFuZCBzZXRzIHRoZSBgaW52YWxpZGAgZmxhZyBhcHByb3ByaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdmFsaWQgYW5kIHNldHMgdGhlIGBpbnZhbGlkYCBmbGFnIGFwcHJvcHJpYXRlbHlcbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuaW52YWxpZCA9ICF0aGlzLmNoZWNrVmFsaWRpdHkoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGlucHV0IHZhbHVlIHNhdGlzZmllcyBhbGwgY29uc3RyYWludHMgKGlmIGFueSkuXG4gICAgICogWW91IGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZCBmb3IgY3VzdG9tIHZhbGlkYXRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjaGVja1ZhbGlkaXR5KCkge1xuICAgICAgaWYgKHN1cGVyLmNoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNoZWNrVmFsaWRpdHkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICF0aGlzLnJlcXVpcmVkIHx8ICEhdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGV2ZW50IHZhbHVlLWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGV0YWlsXG4gICAgICogIEBwYXJhbSB7U3RyaW5nfSBkZXRhaWwudmFsdWUgdGhlIGNvbWJvYm94IHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHNlbGVjdGVkIGl0ZW0gY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBldmVudCBzZWxlY3RlZC1pdGVtLWNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGV0YWlsXG4gICAgICogIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGV0YWlsLnZhbHVlIHRoZSBzZWxlY3RlZCBpdGVtLiBUeXBlIGlzIHRoZSBzYW1lIGFzIHRoZSB0eXBlIG9mIGBpdGVtc2AuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIHNldHMgYSBjdXN0b20gdmFsdWUuXG4gICAgICogQGV2ZW50IGN1c3RvbS12YWx1ZS1zZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGV0YWlsIHRoZSBjdXN0b20gdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdmFsdWUgY2hhbmdlcy5cbiAgICAgKiBUbyBjb21wbHkgd2l0aCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvY2hhbmdlXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js":
/*!************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxOverlay\": () => (/* binding */ ComboBoxOverlay)\n/* harmony export */ });\n/* harmony import */ var _vaadin_vaadin_overlay_src_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-overlay/src/vaadin-overlay.js */ \"./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js\");\n/* harmony import */ var _vaadin_vaadin_overlay_src_vaadin_overlay_position_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-overlay/src/vaadin-overlay-position-mixin.js */ \"./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay-position-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__.registerStyles)('vaadin-combo-box-overlay', _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__.css`\n    #overlay {\n      width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));\n    }\n\n    [part='content'] {\n      display: flex;\n      flex-direction: column;\n      height: 100%;\n    }\n  `, {\n  moduleId: 'vaadin-combo-box-overlay-styles'\n});\nlet memoizedTemplate;\n/**\n * An element used internally by `<vaadin-combo-box>`. Not intended to be used separately.\n *\n * @extends OverlayElement\n * @private\n */\n\nclass ComboBoxOverlay extends (0,_vaadin_vaadin_overlay_src_vaadin_overlay_position_mixin_js__WEBPACK_IMPORTED_MODULE_1__.PositionMixin)(_vaadin_vaadin_overlay_src_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_0__.OverlayElement) {\n  static get is() {\n    return 'vaadin-combo-box-overlay';\n  }\n\n  static get template() {\n    if (!memoizedTemplate) {\n      memoizedTemplate = super.template.cloneNode(true);\n      memoizedTemplate.content.querySelector('[part~=\"overlay\"]').removeAttribute('tabindex');\n    }\n\n    return memoizedTemplate;\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    const dropdown = this.__dataHost;\n    const comboBox = dropdown && dropdown.getRootNode().host;\n    const hostDir = comboBox && comboBox.getAttribute('dir');\n\n    if (hostDir) {\n      this.setAttribute('dir', hostDir);\n    }\n  }\n\n  ready() {\n    super.ready();\n    const loader = document.createElement('div');\n    loader.setAttribute('part', 'loader');\n    const content = this.shadowRoot.querySelector('[part~=\"content\"]');\n    content.parentNode.insertBefore(loader, content);\n  }\n\n  _outsideClickListener(event) {\n    const eventPath = event.composedPath();\n\n    if (!eventPath.includes(this.positionTarget) && !eventPath.includes(this)) {\n      this.close();\n    }\n  }\n\n}\ncustomElements.define(ComboBoxOverlay.is, ComboBoxOverlay);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtb3ZlcmxheS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0Q0E7QUF5Q0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L3NyYy92YWFkaW4tY29tYm8tYm94LW92ZXJsYXkuanM/MzNmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IE92ZXJsYXlFbGVtZW50IH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tb3ZlcmxheS9zcmMvdmFhZGluLW92ZXJsYXkuanMnO1xuaW1wb3J0IHsgUG9zaXRpb25NaXhpbiB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLW92ZXJsYXkvc3JjL3ZhYWRpbi1vdmVybGF5LXBvc2l0aW9uLW1peGluLmpzJztcbmltcG9ydCB7IGNzcywgcmVnaXN0ZXJTdHlsZXMgfSBmcm9tICdAdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanMnO1xuXG5yZWdpc3RlclN0eWxlcyhcbiAgJ3ZhYWRpbi1jb21iby1ib3gtb3ZlcmxheScsXG4gIGNzc2BcbiAgICAjb3ZlcmxheSB7XG4gICAgICB3aWR0aDogdmFyKC0tdmFhZGluLWNvbWJvLWJveC1vdmVybGF5LXdpZHRoLCB2YXIoLS1fdmFhZGluLWNvbWJvLWJveC1vdmVybGF5LWRlZmF1bHQtd2lkdGgsIGF1dG8pKTtcbiAgICB9XG5cbiAgICBbcGFydD0nY29udGVudCddIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbiAgYCxcbiAgeyBtb2R1bGVJZDogJ3ZhYWRpbi1jb21iby1ib3gtb3ZlcmxheS1zdHlsZXMnIH0sXG4pO1xuXG5sZXQgbWVtb2l6ZWRUZW1wbGF0ZTtcblxuLyoqXG4gKiBBbiBlbGVtZW50IHVzZWQgaW50ZXJuYWxseSBieSBgPHZhYWRpbi1jb21iby1ib3g+YC4gTm90IGludGVuZGVkIHRvIGJlIHVzZWQgc2VwYXJhdGVseS5cbiAqXG4gKiBAZXh0ZW5kcyBPdmVybGF5RWxlbWVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbWJvQm94T3ZlcmxheSBleHRlbmRzIFBvc2l0aW9uTWl4aW4oT3ZlcmxheUVsZW1lbnQpIHtcbiAgc3RhdGljIGdldCBpcygpIHtcbiAgICByZXR1cm4gJ3ZhYWRpbi1jb21iby1ib3gtb3ZlcmxheSc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIGlmICghbWVtb2l6ZWRUZW1wbGF0ZSkge1xuICAgICAgbWVtb2l6ZWRUZW1wbGF0ZSA9IHN1cGVyLnRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIG1lbW9pemVkVGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKCdbcGFydH49XCJvdmVybGF5XCJdJykucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vaXplZFRlbXBsYXRlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy5fX2RhdGFIb3N0O1xuICAgIGNvbnN0IGNvbWJvQm94ID0gZHJvcGRvd24gJiYgZHJvcGRvd24uZ2V0Um9vdE5vZGUoKS5ob3N0O1xuICAgIGNvbnN0IGhvc3REaXIgPSBjb21ib0JveCAmJiBjb21ib0JveC5nZXRBdHRyaWJ1dGUoJ2RpcicpO1xuICAgIGlmIChob3N0RGlyKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlyJywgaG9zdERpcik7XG4gICAgfVxuICB9XG5cbiAgcmVhZHkoKSB7XG4gICAgc3VwZXIucmVhZHkoKTtcbiAgICBjb25zdCBsb2FkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsb2FkZXIuc2V0QXR0cmlidXRlKCdwYXJ0JywgJ2xvYWRlcicpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignW3BhcnR+PVwiY29udGVudFwiXScpO1xuICAgIGNvbnRlbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobG9hZGVyLCBjb250ZW50KTtcbiAgfVxuXG4gIF9vdXRzaWRlQ2xpY2tMaXN0ZW5lcihldmVudCkge1xuICAgIGNvbnN0IGV2ZW50UGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgIGlmICghZXZlbnRQYXRoLmluY2x1ZGVzKHRoaXMucG9zaXRpb25UYXJnZXQpICYmICFldmVudFBhdGguaW5jbHVkZXModGhpcykpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKENvbWJvQm94T3ZlcmxheS5pcywgQ29tYm9Cb3hPdmVybGF5KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxPlaceholder\": () => (/* binding */ ComboBoxPlaceholder)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/*\n * Placeholder object class representing items being loaded.\n *\n * @private\n */\nconst ComboBoxPlaceholder = class ComboBoxPlaceholder {\n  toString() {\n    return '';\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtcGxhY2Vob2xkZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUhBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9zcmMvdmFhZGluLWNvbWJvLWJveC1wbGFjZWhvbGRlci5qcz84NjRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuXG4vKlxuICogUGxhY2Vob2xkZXIgb2JqZWN0IGNsYXNzIHJlcHJlc2VudGluZyBpdGVtcyBiZWluZyBsb2FkZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IENvbWJvQm94UGxhY2Vob2xkZXIgPSBjbGFzcyBDb21ib0JveFBsYWNlaG9sZGVyIHtcbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxScroller\": () => (/* binding */ ComboBoxScroller)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_component_base_src_virtualizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/component-base/src/virtualizer.js */ \"./node_modules/@vaadin/component-base/src/virtualizer.js\");\n/* harmony import */ var _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vaadin-combo-box-placeholder.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n/**\n * Element for internal use only.\n *\n * @extends HTMLElement\n * @private\n */\n\nclass ComboBoxScroller extends _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.PolymerElement {\n  static get is() {\n    return 'vaadin-combo-box-scroller';\n  }\n\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.html`\n      <style>\n        :host {\n          display: block;\n          min-height: 1px;\n          overflow: auto;\n\n          /* Fixes item background from getting on top of scrollbars on Safari */\n          transform: translate3d(0, 0, 0);\n\n          /* Enable momentum scrolling on iOS */\n          -webkit-overflow-scrolling: touch;\n\n          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */\n          box-shadow: 0 0 0 white;\n        }\n\n        #selector {\n          border-width: var(--_vaadin-combo-box-items-container-border-width);\n          border-style: var(--_vaadin-combo-box-items-container-border-style);\n          border-color: var(--_vaadin-combo-box-items-container-border-color);\n        }\n      </style>\n      <div id=\"selector\">\n        <slot></slot>\n      </div>\n    `;\n  }\n\n  static get properties() {\n    return {\n      /**\n       * A full set of items to filter the visible options from.\n       * Set to an empty array when combo-box is not opened.\n       */\n      items: {\n        type: Array,\n        observer: '__itemsChanged'\n      },\n\n      /**\n       * Index of an item that has focus outline and is scrolled into view.\n       * The actual focus still remains in the input field.\n       */\n      focusedIndex: {\n        type: Number,\n        observer: '__focusedIndexChanged'\n      },\n\n      /**\n       * Set to true while combo-box fetches new page from the data provider.\n       */\n      loading: {\n        type: Boolean,\n        observer: '__loadingChanged'\n      },\n\n      /**\n       * Whether the combo-box is currently opened or not. If set to false,\n       * calling `scrollIntoView` does not have any effect.\n       */\n      opened: {\n        type: Boolean,\n        observer: '__openedChanged'\n      },\n\n      /**\n       * The selected item from the `items` array.\n       */\n      selectedItem: {\n        type: Object\n      },\n\n      /**\n       * Path for the id of the item, used to detect whether the item is selected.\n       */\n      itemIdPath: {\n        type: String\n      },\n\n      /**\n       * Reference to the combo-box, used by the item elements.\n       */\n      comboBox: {\n        type: Object\n      },\n\n      /**\n       * Function used to set a label for every combo-box item.\n       */\n      getItemLabel: {\n        type: Object\n      },\n\n      /**\n       * Function used to render the content of every combo-box item.\n       */\n      renderer: {\n        type: Object,\n        observer: '__rendererChanged'\n      },\n\n      /**\n       * Used to propagate the `theme` attribute from the host element.\n       */\n      theme: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.__boundOnItemClick = this.__onItemClick.bind(this);\n  }\n\n  __openedChanged(opened) {\n    if (opened) {\n      this.requestContentUpdate();\n    }\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready(); // Allow extensions to customize tag name for the items\n\n    this.__hostTagName = this.constructor.is.replace('-scroller', '');\n    this.setAttribute('role', 'listbox');\n    this.addEventListener('click', e => e.stopPropagation());\n\n    this.__patchWheelOverScrolling();\n\n    this.__virtualizer = new _vaadin_component_base_src_virtualizer_js__WEBPACK_IMPORTED_MODULE_1__.Virtualizer({\n      createElements: this.__createElements.bind(this),\n      updateElement: this.__updateElement.bind(this),\n      elementsContainer: this,\n      scrollTarget: this,\n      scrollContainer: this.$.selector\n    });\n  }\n\n  requestContentUpdate() {\n    if (this.__virtualizer) {\n      this.__virtualizer.update();\n    }\n  }\n\n  scrollIntoView(index) {\n    if (!(this.opened && index >= 0)) {\n      return;\n    }\n\n    const visibleItemsCount = this._visibleItemsCount();\n\n    let targetIndex = index;\n\n    if (index > this.__virtualizer.lastVisibleIndex - 1) {\n      // Index is below the bottom, scrolling down. Make the item appear at the bottom.\n      // First scroll to target (will be at the top of the scroller) to make sure it's rendered.\n      this.__virtualizer.scrollToIndex(index); // Then calculate the index for the following scroll (to get the target to bottom of the scroller).\n\n\n      targetIndex = index - visibleItemsCount + 1;\n    } else if (index > this.__virtualizer.firstVisibleIndex) {\n      // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set\n      // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.\n      targetIndex = this.__virtualizer.firstVisibleIndex;\n    }\n\n    this.__virtualizer.scrollToIndex(Math.max(0, targetIndex)); // Sometimes the item is partly below the bottom edge, detect and adjust.\n\n\n    const lastPhysicalItem = [...this.children].find(el => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex);\n\n    if (!lastPhysicalItem || index !== lastPhysicalItem.index) {\n      return;\n    }\n\n    const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();\n    const scrollerRect = this.getBoundingClientRect();\n    const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;\n\n    if (scrollTopAdjust > 0) {\n      this.scrollTop += scrollTopAdjust;\n    }\n  }\n  /** @private */\n\n\n  __getAriaRole(itemIndex) {\n    return itemIndex !== undefined ? 'option' : false;\n  }\n  /** @private */\n\n\n  __getAriaSelected(focusedIndex, itemIndex) {\n    return this.__isItemFocused(focusedIndex, itemIndex).toString();\n  }\n  /** @private */\n\n\n  __isItemFocused(focusedIndex, itemIndex) {\n    return focusedIndex == itemIndex;\n  }\n  /** @private */\n\n\n  __isItemSelected(item, selectedItem, itemIdPath) {\n    if (item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_2__.ComboBoxPlaceholder) {\n      return false;\n    } else if (itemIdPath && item !== undefined && selectedItem !== undefined) {\n      return this.get(itemIdPath, item) === this.get(itemIdPath, selectedItem);\n    } else {\n      return item === selectedItem;\n    }\n  }\n  /** @private */\n\n\n  __itemsChanged(items) {\n    if (this.__virtualizer && items) {\n      this.__virtualizer.size = items.length;\n\n      this.__virtualizer.flush(); // Ensure the total count of items is properly announced.\n\n\n      this.setAttribute('aria-setsize', items.length);\n      this.requestContentUpdate();\n    }\n  }\n  /** @private */\n\n\n  __loadingChanged(loading) {\n    if (this.__virtualizer && !loading) {\n      setTimeout(() => this.requestContentUpdate());\n    }\n  }\n  /** @private */\n\n\n  __focusedIndexChanged(index, oldIndex) {\n    if (!this.__virtualizer) {\n      return;\n    }\n\n    if (index !== oldIndex) {\n      this.requestContentUpdate();\n    } // Do not jump back to the previously focused item while loading\n    // when requesting next page from the data provider on scroll.\n\n\n    if (index >= 0 && !this.loading) {\n      this.scrollIntoView(index);\n    }\n  }\n  /** @private */\n\n\n  __rendererChanged(renderer, oldRenderer) {\n    if (renderer || oldRenderer) {\n      this.requestContentUpdate();\n    }\n  }\n  /** @private */\n\n\n  __createElements(count) {\n    return [...Array(count)].map(() => {\n      const item = document.createElement(`${this.__hostTagName}-item`);\n      item.addEventListener('click', this.__boundOnItemClick); // Negative tabindex prevents the item content from being focused.\n\n      item.tabIndex = '-1';\n      item.style.width = '100%';\n      return item;\n    });\n  }\n  /** @private */\n\n\n  __updateElement(el, index) {\n    const item = this.items[index];\n    const focusedIndex = this.focusedIndex;\n    el.setProperties({\n      item,\n      index: this.__requestItemByIndex(item, index),\n      label: this.getItemLabel(item),\n      selected: this.__isItemSelected(item, this.selectedItem, this.itemIdPath),\n      renderer: this.renderer,\n      focused: this.__isItemFocused(focusedIndex, index)\n    });\n    el.id = `${this.__hostTagName}-item-${index}`;\n    el.setAttribute('role', this.__getAriaRole(index));\n    el.setAttribute('aria-selected', this.__getAriaSelected(focusedIndex, index));\n    el.setAttribute('aria-posinset', index + 1);\n\n    if (this.theme) {\n      el.setAttribute('theme', this.theme);\n    } else {\n      el.removeAttribute('theme');\n    }\n  }\n  /** @private */\n\n\n  __onItemClick(e) {\n    this.dispatchEvent(new CustomEvent('selection-changed', {\n      detail: {\n        item: e.currentTarget.item\n      }\n    }));\n  }\n  /**\n   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.\n   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow\n   * scrolling the parent similarly to touch scrolling.\n   */\n\n\n  __patchWheelOverScrolling() {\n    this.$.selector.addEventListener('wheel', e => {\n      const scrolledToTop = this.scrollTop === 0;\n      const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;\n\n      if (scrolledToTop && e.deltaY < 0) {\n        e.preventDefault();\n      } else if (scrolledToBottom && e.deltaY > 0) {\n        e.preventDefault();\n      }\n    });\n  }\n\n  get _viewportTotalPaddingBottom() {\n    if (this._cachedViewportTotalPaddingBottom === undefined) {\n      const itemsStyle = window.getComputedStyle(this.$.selector);\n      this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth].map(v => {\n        return parseInt(v, 10);\n      }).reduce((sum, v) => {\n        return sum + v;\n      });\n    }\n\n    return this._cachedViewportTotalPaddingBottom;\n  }\n  /**\n   * If dataProvider is used, dispatch a request for the items index if\n   * the item is a placeholder object.\n   *\n   * @return {number}\n   */\n\n\n  __requestItemByIndex(item, index) {\n    if (item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_2__.ComboBoxPlaceholder && index !== undefined) {\n      this.dispatchEvent(new CustomEvent('index-requested', {\n        detail: {\n          index,\n          currentScrollerPos: this._oldScrollerPosition\n        }\n      }));\n    }\n\n    return index;\n  }\n  /** @private */\n\n\n  _visibleItemsCount() {\n    // Ensure items are positioned\n    this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);\n\n    const hasItems = this.__virtualizer.size > 0;\n    return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;\n  }\n\n}\ncustomElements.define(ComboBoxScroller.is, ComboBoxScroller);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtc2Nyb2xsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQTNFQTtBQStFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOzs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBdFdBO0FBeVdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9zcmMvdmFhZGluLWNvbWJvLWJveC1zY3JvbGxlci5qcz84Y2YwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgaHRtbCwgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBWaXJ0dWFsaXplciB9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL3ZpcnR1YWxpemVyLmpzJztcbmltcG9ydCB7IENvbWJvQm94UGxhY2Vob2xkZXIgfSBmcm9tICcuL3ZhYWRpbi1jb21iby1ib3gtcGxhY2Vob2xkZXIuanMnO1xuXG4vKipcbiAqIEVsZW1lbnQgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29tYm9Cb3hTY3JvbGxlciBleHRlbmRzIFBvbHltZXJFbGVtZW50IHtcbiAgc3RhdGljIGdldCBpcygpIHtcbiAgICByZXR1cm4gJ3ZhYWRpbi1jb21iby1ib3gtc2Nyb2xsZXInO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxzdHlsZT5cbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgIG1pbi1oZWlnaHQ6IDFweDtcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcblxuICAgICAgICAgIC8qIEZpeGVzIGl0ZW0gYmFja2dyb3VuZCBmcm9tIGdldHRpbmcgb24gdG9wIG9mIHNjcm9sbGJhcnMgb24gU2FmYXJpICovXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcblxuICAgICAgICAgIC8qIEVuYWJsZSBtb21lbnR1bSBzY3JvbGxpbmcgb24gaU9TICovXG4gICAgICAgICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuXG4gICAgICAgICAgLyogRml4ZXMgc2Nyb2xsYmFyIGRpc2FwcGVhcmluZyB3aGVuICdTaG93IHNjcm9sbCBiYXJzOiBBbHdheXMnIGVuYWJsZWQgaW4gU2FmYXJpICovXG4gICAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgd2hpdGU7XG4gICAgICAgIH1cblxuICAgICAgICAjc2VsZWN0b3Ige1xuICAgICAgICAgIGJvcmRlci13aWR0aDogdmFyKC0tX3ZhYWRpbi1jb21iby1ib3gtaXRlbXMtY29udGFpbmVyLWJvcmRlci13aWR0aCk7XG4gICAgICAgICAgYm9yZGVyLXN0eWxlOiB2YXIoLS1fdmFhZGluLWNvbWJvLWJveC1pdGVtcy1jb250YWluZXItYm9yZGVyLXN0eWxlKTtcbiAgICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLV92YWFkaW4tY29tYm8tYm94LWl0ZW1zLWNvbnRhaW5lci1ib3JkZXItY29sb3IpO1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPGRpdiBpZD1cInNlbGVjdG9yXCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBmdWxsIHNldCBvZiBpdGVtcyB0byBmaWx0ZXIgdGhlIHZpc2libGUgb3B0aW9ucyBmcm9tLlxuICAgICAgICogU2V0IHRvIGFuIGVtcHR5IGFycmF5IHdoZW4gY29tYm8tYm94IGlzIG5vdCBvcGVuZWQuXG4gICAgICAgKi9cbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBvYnNlcnZlcjogJ19faXRlbXNDaGFuZ2VkJyxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSW5kZXggb2YgYW4gaXRlbSB0aGF0IGhhcyBmb2N1cyBvdXRsaW5lIGFuZCBpcyBzY3JvbGxlZCBpbnRvIHZpZXcuXG4gICAgICAgKiBUaGUgYWN0dWFsIGZvY3VzIHN0aWxsIHJlbWFpbnMgaW4gdGhlIGlucHV0IGZpZWxkLlxuICAgICAgICovXG4gICAgICBmb2N1c2VkSW5kZXg6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBvYnNlcnZlcjogJ19fZm9jdXNlZEluZGV4Q2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0byB0cnVlIHdoaWxlIGNvbWJvLWJveCBmZXRjaGVzIG5ldyBwYWdlIGZyb20gdGhlIGRhdGEgcHJvdmlkZXIuXG4gICAgICAgKi9cbiAgICAgIGxvYWRpbmc6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2xvYWRpbmdDaGFuZ2VkJyxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0aGUgY29tYm8tYm94IGlzIGN1cnJlbnRseSBvcGVuZWQgb3Igbm90LiBJZiBzZXQgdG8gZmFsc2UsXG4gICAgICAgKiBjYWxsaW5nIGBzY3JvbGxJbnRvVmlld2AgZG9lcyBub3QgaGF2ZSBhbnkgZWZmZWN0LlxuICAgICAgICovXG4gICAgICBvcGVuZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX29wZW5lZENoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2VsZWN0ZWQgaXRlbSBmcm9tIHRoZSBgaXRlbXNgIGFycmF5LlxuICAgICAgICovXG4gICAgICBzZWxlY3RlZEl0ZW06IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQYXRoIGZvciB0aGUgaWQgb2YgdGhlIGl0ZW0sIHVzZWQgdG8gZGV0ZWN0IHdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgKi9cbiAgICAgIGl0ZW1JZFBhdGg6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvbWJvLWJveCwgdXNlZCBieSB0aGUgaXRlbSBlbGVtZW50cy5cbiAgICAgICAqL1xuICAgICAgY29tYm9Cb3g6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHNldCBhIGxhYmVsIGZvciBldmVyeSBjb21iby1ib3ggaXRlbS5cbiAgICAgICAqL1xuICAgICAgZ2V0SXRlbUxhYmVsOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRnVuY3Rpb24gdXNlZCB0byByZW5kZXIgdGhlIGNvbnRlbnQgb2YgZXZlcnkgY29tYm8tYm94IGl0ZW0uXG4gICAgICAgKi9cbiAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX3JlbmRlcmVyQ2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgIGF0dHJpYnV0ZSBmcm9tIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIHRoZW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX2JvdW5kT25JdGVtQ2xpY2sgPSB0aGlzLl9fb25JdGVtQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9fb3BlbmVkQ2hhbmdlZChvcGVuZWQpIHtcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgcmVhZHkoKSB7XG4gICAgc3VwZXIucmVhZHkoKTtcblxuICAgIC8vIEFsbG93IGV4dGVuc2lvbnMgdG8gY3VzdG9taXplIHRhZyBuYW1lIGZvciB0aGUgaXRlbXNcbiAgICB0aGlzLl9faG9zdFRhZ05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmlzLnJlcGxhY2UoJy1zY3JvbGxlcicsICcnKTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xpc3Rib3gnKTtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSk7XG5cbiAgICB0aGlzLl9fcGF0Y2hXaGVlbE92ZXJTY3JvbGxpbmcoKTtcblxuICAgIHRoaXMuX192aXJ0dWFsaXplciA9IG5ldyBWaXJ0dWFsaXplcih7XG4gICAgICBjcmVhdGVFbGVtZW50czogdGhpcy5fX2NyZWF0ZUVsZW1lbnRzLmJpbmQodGhpcyksXG4gICAgICB1cGRhdGVFbGVtZW50OiB0aGlzLl9fdXBkYXRlRWxlbWVudC5iaW5kKHRoaXMpLFxuICAgICAgZWxlbWVudHNDb250YWluZXI6IHRoaXMsXG4gICAgICBzY3JvbGxUYXJnZXQ6IHRoaXMsXG4gICAgICBzY3JvbGxDb250YWluZXI6IHRoaXMuJC5zZWxlY3RvcixcbiAgICB9KTtcbiAgfVxuXG4gIHJlcXVlc3RDb250ZW50VXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9fdmlydHVhbGl6ZXIpIHtcbiAgICAgIHRoaXMuX192aXJ0dWFsaXplci51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBzY3JvbGxJbnRvVmlldyhpbmRleCkge1xuICAgIGlmICghKHRoaXMub3BlbmVkICYmIGluZGV4ID49IDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdmlzaWJsZUl0ZW1zQ291bnQgPSB0aGlzLl92aXNpYmxlSXRlbXNDb3VudCgpO1xuXG4gICAgbGV0IHRhcmdldEluZGV4ID0gaW5kZXg7XG5cbiAgICBpZiAoaW5kZXggPiB0aGlzLl9fdmlydHVhbGl6ZXIubGFzdFZpc2libGVJbmRleCAtIDEpIHtcbiAgICAgIC8vIEluZGV4IGlzIGJlbG93IHRoZSBib3R0b20sIHNjcm9sbGluZyBkb3duLiBNYWtlIHRoZSBpdGVtIGFwcGVhciBhdCB0aGUgYm90dG9tLlxuICAgICAgLy8gRmlyc3Qgc2Nyb2xsIHRvIHRhcmdldCAod2lsbCBiZSBhdCB0aGUgdG9wIG9mIHRoZSBzY3JvbGxlcikgdG8gbWFrZSBzdXJlIGl0J3MgcmVuZGVyZWQuXG4gICAgICB0aGlzLl9fdmlydHVhbGl6ZXIuc2Nyb2xsVG9JbmRleChpbmRleCk7XG4gICAgICAvLyBUaGVuIGNhbGN1bGF0ZSB0aGUgaW5kZXggZm9yIHRoZSBmb2xsb3dpbmcgc2Nyb2xsICh0byBnZXQgdGhlIHRhcmdldCB0byBib3R0b20gb2YgdGhlIHNjcm9sbGVyKS5cbiAgICAgIHRhcmdldEluZGV4ID0gaW5kZXggLSB2aXNpYmxlSXRlbXNDb3VudCArIDE7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+IHRoaXMuX192aXJ0dWFsaXplci5maXJzdFZpc2libGVJbmRleCkge1xuICAgICAgLy8gVGhlIGl0ZW0gaXMgYWxyZWFkeSB2aXNpYmxlLCBzY3JvbGxpbmcgaXMgdW5uZWNlc3NhcnkgcGVyIHNlLiBCdXQgd2UgbmVlZCB0byB0cmlnZ2VyIGlyb24tbGlzdCB0byBzZXRcbiAgICAgIC8vIHRoZSBjb3JyZWN0IHNjcm9sbFRvcCBvbiB0aGUgc2Nyb2xsVGFyZ2V0LiBTY3JvbGxpbmcgdG8gZmlyc3RWaXNpYmxlSW5kZXguXG4gICAgICB0YXJnZXRJbmRleCA9IHRoaXMuX192aXJ0dWFsaXplci5maXJzdFZpc2libGVJbmRleDtcbiAgICB9XG4gICAgdGhpcy5fX3ZpcnR1YWxpemVyLnNjcm9sbFRvSW5kZXgoTWF0aC5tYXgoMCwgdGFyZ2V0SW5kZXgpKTtcblxuICAgIC8vIFNvbWV0aW1lcyB0aGUgaXRlbSBpcyBwYXJ0bHkgYmVsb3cgdGhlIGJvdHRvbSBlZGdlLCBkZXRlY3QgYW5kIGFkanVzdC5cbiAgICBjb25zdCBsYXN0UGh5c2ljYWxJdGVtID0gWy4uLnRoaXMuY2hpbGRyZW5dLmZpbmQoXG4gICAgICAoZWwpID0+ICFlbC5oaWRkZW4gJiYgZWwuaW5kZXggPT09IHRoaXMuX192aXJ0dWFsaXplci5sYXN0VmlzaWJsZUluZGV4LFxuICAgICk7XG4gICAgaWYgKCFsYXN0UGh5c2ljYWxJdGVtIHx8IGluZGV4ICE9PSBsYXN0UGh5c2ljYWxJdGVtLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RQaHlzaWNhbEl0ZW1SZWN0ID0gbGFzdFBoeXNpY2FsSXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBzY3JvbGxlclJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNjcm9sbFRvcEFkanVzdCA9IGxhc3RQaHlzaWNhbEl0ZW1SZWN0LmJvdHRvbSAtIHNjcm9sbGVyUmVjdC5ib3R0b20gKyB0aGlzLl92aWV3cG9ydFRvdGFsUGFkZGluZ0JvdHRvbTtcbiAgICBpZiAoc2Nyb2xsVG9wQWRqdXN0ID4gMCkge1xuICAgICAgdGhpcy5zY3JvbGxUb3AgKz0gc2Nyb2xsVG9wQWRqdXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX2dldEFyaWFSb2xlKGl0ZW1JbmRleCkge1xuICAgIHJldHVybiBpdGVtSW5kZXggIT09IHVuZGVmaW5lZCA/ICdvcHRpb24nIDogZmFsc2U7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19nZXRBcmlhU2VsZWN0ZWQoZm9jdXNlZEluZGV4LCBpdGVtSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2lzSXRlbUZvY3VzZWQoZm9jdXNlZEluZGV4LCBpdGVtSW5kZXgpLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19pc0l0ZW1Gb2N1c2VkKGZvY3VzZWRJbmRleCwgaXRlbUluZGV4KSB7XG4gICAgcmV0dXJuIGZvY3VzZWRJbmRleCA9PSBpdGVtSW5kZXg7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19pc0l0ZW1TZWxlY3RlZChpdGVtLCBzZWxlY3RlZEl0ZW0sIGl0ZW1JZFBhdGgpIHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbWJvQm94UGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGl0ZW1JZFBhdGggJiYgaXRlbSAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGVkSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoaXRlbUlkUGF0aCwgaXRlbSkgPT09IHRoaXMuZ2V0KGl0ZW1JZFBhdGgsIHNlbGVjdGVkSXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVtID09PSBzZWxlY3RlZEl0ZW07XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9faXRlbXNDaGFuZ2VkKGl0ZW1zKSB7XG4gICAgaWYgKHRoaXMuX192aXJ0dWFsaXplciAmJiBpdGVtcykge1xuICAgICAgdGhpcy5fX3ZpcnR1YWxpemVyLnNpemUgPSBpdGVtcy5sZW5ndGg7XG4gICAgICB0aGlzLl9fdmlydHVhbGl6ZXIuZmx1c2goKTtcbiAgICAgIC8vIEVuc3VyZSB0aGUgdG90YWwgY291bnQgb2YgaXRlbXMgaXMgcHJvcGVybHkgYW5ub3VuY2VkLlxuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2V0c2l6ZScsIGl0ZW1zLmxlbmd0aCk7XG4gICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fbG9hZGluZ0NoYW5nZWQobG9hZGluZykge1xuICAgIGlmICh0aGlzLl9fdmlydHVhbGl6ZXIgJiYgIWxvYWRpbmcpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19mb2N1c2VkSW5kZXhDaGFuZ2VkKGluZGV4LCBvbGRJbmRleCkge1xuICAgIGlmICghdGhpcy5fX3ZpcnR1YWxpemVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9PSBvbGRJbmRleCkge1xuICAgICAgdGhpcy5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBqdW1wIGJhY2sgdG8gdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBpdGVtIHdoaWxlIGxvYWRpbmdcbiAgICAvLyB3aGVuIHJlcXVlc3RpbmcgbmV4dCBwYWdlIGZyb20gdGhlIGRhdGEgcHJvdmlkZXIgb24gc2Nyb2xsLlxuICAgIGlmIChpbmRleCA+PSAwICYmICF0aGlzLmxvYWRpbmcpIHtcbiAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX3JlbmRlcmVyQ2hhbmdlZChyZW5kZXJlciwgb2xkUmVuZGVyZXIpIHtcbiAgICBpZiAocmVuZGVyZXIgfHwgb2xkUmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19jcmVhdGVFbGVtZW50cyhjb3VudCkge1xuICAgIHJldHVybiBbLi4uQXJyYXkoY291bnQpXS5tYXAoKCkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYCR7dGhpcy5fX2hvc3RUYWdOYW1lfS1pdGVtYCk7XG4gICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fX2JvdW5kT25JdGVtQ2xpY2spO1xuICAgICAgLy8gTmVnYXRpdmUgdGFiaW5kZXggcHJldmVudHMgdGhlIGl0ZW0gY29udGVudCBmcm9tIGJlaW5nIGZvY3VzZWQuXG4gICAgICBpdGVtLnRhYkluZGV4ID0gJy0xJztcbiAgICAgIGl0ZW0uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX3VwZGF0ZUVsZW1lbnQoZWwsIGluZGV4KSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IGZvY3VzZWRJbmRleCA9IHRoaXMuZm9jdXNlZEluZGV4O1xuXG4gICAgZWwuc2V0UHJvcGVydGllcyh7XG4gICAgICBpdGVtLFxuICAgICAgaW5kZXg6IHRoaXMuX19yZXF1ZXN0SXRlbUJ5SW5kZXgoaXRlbSwgaW5kZXgpLFxuICAgICAgbGFiZWw6IHRoaXMuZ2V0SXRlbUxhYmVsKGl0ZW0pLFxuICAgICAgc2VsZWN0ZWQ6IHRoaXMuX19pc0l0ZW1TZWxlY3RlZChpdGVtLCB0aGlzLnNlbGVjdGVkSXRlbSwgdGhpcy5pdGVtSWRQYXRoKSxcbiAgICAgIHJlbmRlcmVyOiB0aGlzLnJlbmRlcmVyLFxuICAgICAgZm9jdXNlZDogdGhpcy5fX2lzSXRlbUZvY3VzZWQoZm9jdXNlZEluZGV4LCBpbmRleCksXG4gICAgfSk7XG5cbiAgICBlbC5pZCA9IGAke3RoaXMuX19ob3N0VGFnTmFtZX0taXRlbS0ke2luZGV4fWA7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdyb2xlJywgdGhpcy5fX2dldEFyaWFSb2xlKGluZGV4KSk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdGhpcy5fX2dldEFyaWFTZWxlY3RlZChmb2N1c2VkSW5kZXgsIGluZGV4KSk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLXBvc2luc2V0JywgaW5kZXggKyAxKTtcblxuICAgIGlmICh0aGlzLnRoZW1lKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RoZW1lJywgdGhpcy50aGVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGhlbWUnKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19vbkl0ZW1DbGljayhlKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc2VsZWN0aW9uLWNoYW5nZWQnLCB7IGRldGFpbDogeyBpdGVtOiBlLmN1cnJlbnRUYXJnZXQuaXRlbSB9IH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIHByZXZlbnQgdGhlIGtpbmV0aWMgc2Nyb2xsaW5nIGVuZXJneSBmcm9tIGJlaW5nIHRyYW5zZmVycmVkIGZyb20gdGhlIG92ZXJsYXkgY29udGVudHMgb3ZlciB0byB0aGUgcGFyZW50LlxuICAgKiBGdXJ0aGVyIGltcHJvdmVtZW50IGlkZWFzOiBhZnRlciB0aGUgY29udGVudHMgaGF2ZSBiZWVuIHNjcm9sbGVkIHRvIHRoZSB0b3Agb3IgYm90dG9tIGFuZCBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIGl0IGNvdWxkIGFsbG93XG4gICAqIHNjcm9sbGluZyB0aGUgcGFyZW50IHNpbWlsYXJseSB0byB0b3VjaCBzY3JvbGxpbmcuXG4gICAqL1xuICBfX3BhdGNoV2hlZWxPdmVyU2Nyb2xsaW5nKCkge1xuICAgIHRoaXMuJC5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxlZFRvVG9wID0gdGhpcy5zY3JvbGxUb3AgPT09IDA7XG4gICAgICBjb25zdCBzY3JvbGxlZFRvQm90dG9tID0gdGhpcy5zY3JvbGxIZWlnaHQgLSB0aGlzLnNjcm9sbFRvcCAtIHRoaXMuY2xpZW50SGVpZ2h0IDw9IDE7XG4gICAgICBpZiAoc2Nyb2xsZWRUb1RvcCAmJiBlLmRlbHRhWSA8IDApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxlZFRvQm90dG9tICYmIGUuZGVsdGFZID4gMCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX3ZpZXdwb3J0VG90YWxQYWRkaW5nQm90dG9tKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRWaWV3cG9ydFRvdGFsUGFkZGluZ0JvdHRvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpdGVtc1N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kLnNlbGVjdG9yKTtcbiAgICAgIHRoaXMuX2NhY2hlZFZpZXdwb3J0VG90YWxQYWRkaW5nQm90dG9tID0gW2l0ZW1zU3R5bGUucGFkZGluZ0JvdHRvbSwgaXRlbXNTdHlsZS5ib3JkZXJCb3R0b21XaWR0aF1cbiAgICAgICAgLm1hcCgodikgPT4ge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludCh2LCAxMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgdikgPT4ge1xuICAgICAgICAgIHJldHVybiBzdW0gKyB2O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVmlld3BvcnRUb3RhbFBhZGRpbmdCb3R0b207XG4gIH1cblxuICAvKipcbiAgICogSWYgZGF0YVByb3ZpZGVyIGlzIHVzZWQsIGRpc3BhdGNoIGEgcmVxdWVzdCBmb3IgdGhlIGl0ZW3igJlzIGluZGV4IGlmXG4gICAqIHRoZSBpdGVtIGlzIGEgcGxhY2Vob2xkZXIgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBfX3JlcXVlc3RJdGVtQnlJbmRleChpdGVtLCBpbmRleCkge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQ29tYm9Cb3hQbGFjZWhvbGRlciAmJiBpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudCgnaW5kZXgtcmVxdWVzdGVkJywgeyBkZXRhaWw6IHsgaW5kZXgsIGN1cnJlbnRTY3JvbGxlclBvczogdGhpcy5fb2xkU2Nyb2xsZXJQb3NpdGlvbiB9IH0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3Zpc2libGVJdGVtc0NvdW50KCkge1xuICAgIC8vIEVuc3VyZSBpdGVtcyBhcmUgcG9zaXRpb25lZFxuICAgIHRoaXMuX192aXJ0dWFsaXplci5zY3JvbGxUb0luZGV4KHRoaXMuX192aXJ0dWFsaXplci5maXJzdFZpc2libGVJbmRleCk7XG4gICAgY29uc3QgaGFzSXRlbXMgPSB0aGlzLl9fdmlydHVhbGl6ZXIuc2l6ZSA+IDA7XG4gICAgcmV0dXJuIGhhc0l0ZW1zID8gdGhpcy5fX3ZpcnR1YWxpemVyLmxhc3RWaXNpYmxlSW5kZXggLSB0aGlzLl9fdmlydHVhbGl6ZXIuZmlyc3RWaXNpYmxlSW5kZXggKyAxIDogMDtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoQ29tYm9Cb3hTY3JvbGxlci5pcywgQ29tYm9Cb3hTY3JvbGxlcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_vaadin_material_styles_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_vaadin_overlay_theme_material_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-overlay/theme/material/vaadin-overlay.js */ \"./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_mixins_menu_overlay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/mixins/menu-overlay.js */ \"./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n\n\nconst comboBoxOverlay = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.css`\n  :host {\n    --_vaadin-combo-box-items-container-border-width: 8px 0;\n    --_vaadin-combo-box-items-container-border-style: solid;\n    --_vaadin-combo-box-items-container-border-color: transparent;\n  }\n\n  [part='overlay'] {\n    position: relative;\n    overflow: visible;\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  }\n\n  [part='content'] {\n    padding: 0;\n  }\n\n  :host([loading]) [part='loader'] {\n    height: 2px;\n    position: absolute;\n    z-index: 1;\n    top: -2px;\n    left: 0;\n    right: 0;\n    background: var(--material-background-color)\n      linear-gradient(\n        90deg,\n        transparent 0%,\n        transparent 20%,\n        var(--material-primary-color) 20%,\n        var(--material-primary-color) 40%,\n        transparent 40%,\n        transparent 60%,\n        var(--material-primary-color) 60%,\n        var(--material-primary-color) 80%,\n        transparent 80%,\n        transparent 100%\n      )\n      0 0 / 400% 100% repeat-x;\n    opacity: 0;\n    animation: 3s linear infinite material-combo-box-loader-progress, 0.3s 0.1s both material-combo-box-loader-fade-in;\n  }\n\n  [part='loader']::before {\n    content: '';\n    display: block;\n    height: 100%;\n    opacity: 0.16;\n    background: var(--material-primary-color);\n  }\n\n  @keyframes material-combo-box-loader-fade-in {\n    0% {\n      opacity: 0;\n    }\n\n    100% {\n      opacity: 1;\n    }\n  }\n\n  @keyframes material-combo-box-loader-progress {\n    0% {\n      background-position: 0 0;\n      background-size: 300% 100%;\n    }\n\n    33% {\n      background-position: -100% 0;\n      background-size: 400% 100%;\n    }\n\n    67% {\n      background-position: -200% 0;\n      background-size: 250% 100%;\n    }\n\n    100% {\n      background-position: -300% 0;\n      background-size: 300% 100%;\n    }\n  }\n\n  /* RTL specific styles */\n\n  @keyframes material-combo-box-loader-progress-rtl {\n    0% {\n      background-position: 100% 0;\n      background-size: 300% 100%;\n    }\n\n    33% {\n      background-position: 200% 0;\n      background-size: 400% 100%;\n    }\n\n    67% {\n      background-position: 300% 0;\n      background-size: 250% 100%;\n    }\n\n    100% {\n      background-position: 400% 0;\n      background-size: 300% 100%;\n    }\n  }\n\n  :host([loading][dir='rtl']) [part='loader'] {\n    animation: 3s linear infinite material-combo-box-loader-progress-rtl,\n      0.3s 0.1s both material-combo-box-loader-fade-in;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.registerStyles)('vaadin-combo-box-overlay', [_vaadin_vaadin_material_styles_mixins_menu_overlay_js__WEBPACK_IMPORTED_MODULE_2__.menuOverlay, comboBoxOverlay], {\n  moduleId: 'material-combo-box-overlay'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1kcm9wZG93bi1zdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1jb21iby1ib3gtZHJvcGRvd24tc3R5bGVzLmpzPzNlODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvY29sb3IuanMnO1xuaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1vdmVybGF5L3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1vdmVybGF5LmpzJztcbmltcG9ydCB7IG1lbnVPdmVybGF5IH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9tZW51LW92ZXJsYXkuanMnO1xuaW1wb3J0IHsgY3NzLCByZWdpc3RlclN0eWxlcyB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5cbmNvbnN0IGNvbWJvQm94T3ZlcmxheSA9IGNzc2BcbiAgOmhvc3Qge1xuICAgIC0tX3ZhYWRpbi1jb21iby1ib3gtaXRlbXMtY29udGFpbmVyLWJvcmRlci13aWR0aDogOHB4IDA7XG4gICAgLS1fdmFhZGluLWNvbWJvLWJveC1pdGVtcy1jb250YWluZXItYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgICAtLV92YWFkaW4tY29tYm8tYm94LWl0ZW1zLWNvbnRhaW5lci1ib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xuICB9XG5cbiAgW3BhcnQ9J292ZXJsYXknXSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XG4gIH1cblxuICBbcGFydD0nY29udGVudCddIHtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG5cbiAgOmhvc3QoW2xvYWRpbmddKSBbcGFydD0nbG9hZGVyJ10ge1xuICAgIGhlaWdodDogMnB4O1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiAxO1xuICAgIHRvcDogLTJweDtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJhY2tncm91bmQ6IHZhcigtLW1hdGVyaWFsLWJhY2tncm91bmQtY29sb3IpXG4gICAgICBsaW5lYXItZ3JhZGllbnQoXG4gICAgICAgIDkwZGVnLFxuICAgICAgICB0cmFuc3BhcmVudCAwJSxcbiAgICAgICAgdHJhbnNwYXJlbnQgMjAlLFxuICAgICAgICB2YXIoLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yKSAyMCUsXG4gICAgICAgIHZhcigtLW1hdGVyaWFsLXByaW1hcnktY29sb3IpIDQwJSxcbiAgICAgICAgdHJhbnNwYXJlbnQgNDAlLFxuICAgICAgICB0cmFuc3BhcmVudCA2MCUsXG4gICAgICAgIHZhcigtLW1hdGVyaWFsLXByaW1hcnktY29sb3IpIDYwJSxcbiAgICAgICAgdmFyKC0tbWF0ZXJpYWwtcHJpbWFyeS1jb2xvcikgODAlLFxuICAgICAgICB0cmFuc3BhcmVudCA4MCUsXG4gICAgICAgIHRyYW5zcGFyZW50IDEwMCVcbiAgICAgIClcbiAgICAgIDAgMCAvIDQwMCUgMTAwJSByZXBlYXQteDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIGFuaW1hdGlvbjogM3MgbGluZWFyIGluZmluaXRlIG1hdGVyaWFsLWNvbWJvLWJveC1sb2FkZXItcHJvZ3Jlc3MsIDAuM3MgMC4xcyBib3RoIG1hdGVyaWFsLWNvbWJvLWJveC1sb2FkZXItZmFkZS1pbjtcbiAgfVxuXG4gIFtwYXJ0PSdsb2FkZXInXTo6YmVmb3JlIHtcbiAgICBjb250ZW50OiAnJztcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgb3BhY2l0eTogMC4xNjtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yKTtcbiAgfVxuXG4gIEBrZXlmcmFtZXMgbWF0ZXJpYWwtY29tYm8tYm94LWxvYWRlci1mYWRlLWluIHtcbiAgICAwJSB7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgIH1cblxuICAgIDEwMCUge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIG1hdGVyaWFsLWNvbWJvLWJveC1sb2FkZXItcHJvZ3Jlc3Mge1xuICAgIDAlIHtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDAgMDtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogMzAwJSAxMDAlO1xuICAgIH1cblxuICAgIDMzJSB7XG4gICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAtMTAwJSAwO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiA0MDAlIDEwMCU7XG4gICAgfVxuXG4gICAgNjclIHtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IC0yMDAlIDA7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6IDI1MCUgMTAwJTtcbiAgICB9XG5cbiAgICAxMDAlIHtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IC0zMDAlIDA7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6IDMwMCUgMTAwJTtcbiAgICB9XG4gIH1cblxuICAvKiBSVEwgc3BlY2lmaWMgc3R5bGVzICovXG5cbiAgQGtleWZyYW1lcyBtYXRlcmlhbC1jb21iby1ib3gtbG9hZGVyLXByb2dyZXNzLXJ0bCB7XG4gICAgMCUge1xuICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMTAwJSAwO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiAzMDAlIDEwMCU7XG4gICAgfVxuXG4gICAgMzMlIHtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDIwMCUgMDtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogNDAwJSAxMDAlO1xuICAgIH1cblxuICAgIDY3JSB7XG4gICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAzMDAlIDA7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6IDI1MCUgMTAwJTtcbiAgICB9XG5cbiAgICAxMDAlIHtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDQwMCUgMDtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogMzAwJSAxMDAlO1xuICAgIH1cbiAgfVxuXG4gIDpob3N0KFtsb2FkaW5nXVtkaXI9J3J0bCddKSBbcGFydD0nbG9hZGVyJ10ge1xuICAgIGFuaW1hdGlvbjogM3MgbGluZWFyIGluZmluaXRlIG1hdGVyaWFsLWNvbWJvLWJveC1sb2FkZXItcHJvZ3Jlc3MtcnRsLFxuICAgICAgMC4zcyAwLjFzIGJvdGggbWF0ZXJpYWwtY29tYm8tYm94LWxvYWRlci1mYWRlLWluO1xuICB9XG5gO1xuXG5yZWdpc3RlclN0eWxlcygndmFhZGluLWNvbWJvLWJveC1vdmVybGF5JywgW21lbnVPdmVybGF5LCBjb21ib0JveE92ZXJsYXldLCB7XG4gIG1vZHVsZUlkOiAnbWF0ZXJpYWwtY29tYm8tYm94LW92ZXJsYXknLFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_vaadin_material_styles_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/font-icons.js */ \"./node_modules/@vaadin/vaadin-material-styles/font-icons.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/typography.js */ \"./node_modules/@vaadin/vaadin-material-styles/typography.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vaadin_item_theme_material_vaadin_item_styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/item/theme/material/vaadin-item-styles.js */ \"./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n\n\n\nconst comboBoxItem = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__.css`\n  :host {\n    cursor: pointer;\n    -webkit-tap-highlight-color: transparent;\n    padding: 4px 10px;\n    --_material-item-selected-icon-display: block;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__.registerStyles)('vaadin-combo-box-item', [_vaadin_item_theme_material_vaadin_item_styles_js__WEBPACK_IMPORTED_MODULE_3__.item, comboBoxItem], {\n  moduleId: 'material-combo-box-item'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1pdGVtLXN0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC90aGVtZS9tYXRlcmlhbC92YWFkaW4tY29tYm8tYm94LWl0ZW0tc3R5bGVzLmpzP2Q1MDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvY29sb3IuanMnO1xuaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvZm9udC1pY29ucy5qcyc7XG5pbXBvcnQgJ0B2YWFkaW4vdmFhZGluLW1hdGVyaWFsLXN0eWxlcy90eXBvZ3JhcGh5LmpzJztcbmltcG9ydCB7IGl0ZW0gfSBmcm9tICdAdmFhZGluL2l0ZW0vdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWl0ZW0tc3R5bGVzLmpzJztcbmltcG9ydCB7IGNzcywgcmVnaXN0ZXJTdHlsZXMgfSBmcm9tICdAdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanMnO1xuXG5jb25zdCBjb21ib0JveEl0ZW0gPSBjc3NgXG4gIDpob3N0IHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBwYWRkaW5nOiA0cHggMTBweDtcbiAgICAtLV9tYXRlcmlhbC1pdGVtLXNlbGVjdGVkLWljb24tZGlzcGxheTogYmxvY2s7XG4gIH1cbmA7XG5cbnJlZ2lzdGVyU3R5bGVzKCd2YWFkaW4tY29tYm8tYm94LWl0ZW0nLCBbaXRlbSwgY29tYm9Cb3hJdGVtXSwge1xuICBtb2R1bGVJZDogJ21hdGVyaWFsLWNvbWJvLWJveC1pdGVtJyxcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-light.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-light.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_combo_box_dropdown_styles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-combo-box-dropdown-styles.js */ \"./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js\");\n/* harmony import */ var _vaadin_combo_box_item_styles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-combo-box-item-styles.js */ \"./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js\");\n/* harmony import */ var _src_vaadin_combo_box_light_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/vaadin-combo-box-light.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1saWdodC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1saWdodC5qcz81MTRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi92YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duLXN0eWxlcy5qcyc7XG5pbXBvcnQgJy4vdmFhZGluLWNvbWJvLWJveC1pdGVtLXN0eWxlcy5qcyc7XG5pbXBvcnQgJy4uLy4uL3NyYy92YWFkaW4tY29tYm8tYm94LWxpZ2h0LmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-light.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/async.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/async.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"animationFrame\": () => (/* binding */ animationFrame),\n/* harmony export */   \"idlePeriod\": () => (/* binding */ idlePeriod),\n/* harmony export */   \"microTask\": () => (/* binding */ microTask),\n/* harmony export */   \"timeOut\": () => (/* binding */ timeOut)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\n\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n  }\n\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\n\n\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n\n    };\n  },\n\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n\n};\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\n\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n\n};\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\n\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n\n};\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\n\nconst microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYXN5bmMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFOQTtBQVFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdkNBO0FBeUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcEJBO0FBc0JBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFwQkE7QUFzQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFoQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2FzeW5jLmpzP2U0YjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICpcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgbnVtYmVyIG9mIHN0cmF0ZWdpZXMgZm9yIGVucXVldWluZyBhc3luY2hyb25vdXNcbiAqIHRhc2tzLiBFYWNoIHN1Yi1tb2R1bGUgcHJvdmlkZXMgYSBzdGFuZGFyZCBgcnVuKGZuKWAgaW50ZXJmYWNlIHRoYXQgcmV0dXJucyBhXG4gKiBoYW5kbGUsIGFuZCBhIGBjYW5jZWwoaGFuZGxlKWAgaW50ZXJmYWNlIGZvciBjYW5jZWxpbmcgYXN5bmMgdGFza3MgYmVmb3JlXG4gKiB0aGV5IHJ1bi5cbiAqXG4gKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmdcbiAqIGFzeW5jaHJvbm91cyB0YXNrcy5cbiAqL1xuXG4vLyBNaWNyb3Rhc2sgaW1wbGVtZW50ZWQgdXNpbmcgTXV0YXRpb24gT2JzZXJ2ZXJcbmxldCBtaWNyb3Rhc2tDdXJySGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tMYXN0SGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbmxldCBtaWNyb3Rhc2tOb2RlQ29udGVudCA9IDA7XG5sZXQgbWljcm90YXNrU2NoZWR1bGVkID0gZmFsc2U7XG5sZXQgbWljcm90YXNrTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbm5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtaWNyb3Rhc2tGbHVzaCkub2JzZXJ2ZShtaWNyb3Rhc2tOb2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0ZsdXNoKCkge1xuICBtaWNyb3Rhc2tTY2hlZHVsZWQgPSBmYWxzZTtcbiAgY29uc3QgbGVuID0gbWljcm90YXNrQ2FsbGJhY2tzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBjYiA9IG1pY3JvdGFza0NhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBtaWNyb3Rhc2tDYWxsYmFja3Muc3BsaWNlKDAsIGxlbik7XG4gIG1pY3JvdGFza0xhc3RIYW5kbGUgKz0gbGVuO1xufVxuXG4vKipcbiAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgc2V0VGltZW91dGAuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGBzZXRUaW1lb3V0YC5cbiAqL1xuY29uc3QgdGltZU91dCA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdWItbW9kdWxlIHdpdGggdGhlIGFzeW5jIGludGVyZmFjZSBwcm92aWRpbmcgdGhlIHByb3ZpZGVkXG4gICAqIGRlbGF5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgdGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja3MgaW4gbXNcbiAgICogQHJldHVybiB7IUFzeW5jSW50ZXJmYWNlfSBBbiBhc3luYyB0aW1lb3V0IGludGVyZmFjZVxuICAgKi9cbiAgYWZ0ZXIoZGVsYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcnVuKGZuKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbChoYW5kbGUpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgaW4gdGhlIG5leHQgdGFzay5cbiAgICpcbiAgICogQG1lbWJlcm9mIHRpbWVPdXRcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IERlbGF5IGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGZuLCBkZWxheSkge1xuICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICB9LFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYHRpbWVPdXRgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgdGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgfSxcbn07XG5leHBvcnQgeyB0aW1lT3V0IH07XG5cbi8qKlxuICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAqL1xuY29uc3QgYW5pbWF0aW9uRnJhbWUgPSB7XG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBhbmltYXRpb25GcmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oZm4pIHtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gIH0sXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgYW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgYW5pbWF0aW9uRnJhbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgfSxcbn07XG5leHBvcnQgeyBhbmltYXRpb25GcmFtZSB9O1xuXG4vKipcbiAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AuICBGYWxscyBiYWNrIHRvXG4gKiBgc2V0VGltZW91dGAgb24gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgcmVxdWVzdElkbGVDYWxsYmFja2AuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0SWRsZUNhbGxiYWNrYC5cbiAqL1xuY29uc3QgaWRsZVBlcmlvZCA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBpZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUlkbGVEZWFkbGluZSk6dm9pZH0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oZm4pIHtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPyB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayhmbikgOiB3aW5kb3cuc2V0VGltZW91dChmbiwgMTYpO1xuICB9LFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGlkbGVQZXJpb2RgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgaWRsZVBlcmlvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgPyB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGhhbmRsZSkgOiB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gIH0sXG59O1xuZXhwb3J0IHsgaWRsZVBlcmlvZCB9O1xuXG4vKipcbiAqIEFzeW5jIGludGVyZmFjZSBmb3IgZW5xdWV1aW5nIGNhbGxiYWNrcyB0aGF0IHJ1biBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICpcbiAqIE5vdGUgdGhhdCBtaWNyb3Rhc2sgdGltaW5nIGlzIGFjaGlldmVkIHZpYSBhIHNpbmdsZSBgTXV0YXRpb25PYnNlcnZlcmAsXG4gKiBhbmQgdGh1cyBjYWxsYmFja3MgZW5xdWV1ZWQgd2l0aCB0aGlzIEFQSSB3aWxsIGFsbCBydW4gaW4gYSBzaW5nbGVcbiAqIGJhdGNoLCBhbmQgbm90IGludGVybGVhdmVkIHdpdGggb3RoZXIgbWljcm90YXNrcyBzdWNoIGFzIHByb21pc2VzLlxuICogUHJvbWlzZXMgYXJlIGF2b2lkZWQgYXMgYW4gaW1wbGVtZW50YXRpb24gY2hvaWNlIGZvciB0aGUgdGltZSBiZWluZ1xuICogZHVlIHRvIFNhZmFyaSBidWdzIHRoYXQgY2F1c2UgUHJvbWlzZXMgdG8gbGFjayBtaWNyb3Rhc2sgZ3VhcmFudGVlcy5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWluZyBjYWxsYmFja3MgdGhhdCBydW4gYXQgbWljcm90YXNrXG4gKiAgIHRpbWluZy5cbiAqL1xuY29uc3QgbWljcm9UYXNrID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgbWljcm90YXNrIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1pY3JvVGFza1xuICAgKiBAcGFyYW0geyFGdW5jdGlvbj19IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFtaWNyb3Rhc2tTY2hlZHVsZWQpIHtcbiAgICAgIG1pY3JvdGFza1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBtaWNyb3Rhc2tOb2RlLnRleHRDb250ZW50ID0gbWljcm90YXNrTm9kZUNvbnRlbnQrKztcbiAgICB9XG4gICAgbWljcm90YXNrQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBtaWNyb3Rhc2tDdXJySGFuZGxlKys7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBtaWNyb1Rhc2tgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbWljcm9UYXNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgY29uc3QgaWR4ID0gaGFuZGxlIC0gbWljcm90YXNrTGFzdEhhbmRsZTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFzeW5jIGhhbmRsZTogJyArIGhhbmRsZSk7XG4gICAgICB9XG4gICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgfVxuICB9LFxufTtcbmV4cG9ydCB7IG1pY3JvVGFzayB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/async.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/browser-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/browser-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isAndroid\": () => (/* binding */ isAndroid),\n/* harmony export */   \"isChrome\": () => (/* binding */ isChrome),\n/* harmony export */   \"isFirefox\": () => (/* binding */ isFirefox),\n/* harmony export */   \"isIOS\": () => (/* binding */ isIOS),\n/* harmony export */   \"isIPad\": () => (/* binding */ isIPad),\n/* harmony export */   \"isIPhone\": () => (/* binding */ isIPhone),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari),\n/* harmony export */   \"isTouch\": () => (/* binding */ isTouch)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nconst testUserAgent = regexp => regexp.test(navigator.userAgent);\n\nconst testPlatform = regexp => regexp.test(navigator.platform);\n\nconst testVendor = regexp => regexp.test(navigator.vendor);\n\nconst isAndroid = testUserAgent(/Android/);\nconst isChrome = testUserAgent(/Chrome/) && testVendor(/Google Inc/);\nconst isFirefox = testUserAgent(/Firefox/); // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n\nconst isIPad = testPlatform(/^iPad/) || testPlatform(/^Mac/) && navigator.maxTouchPoints > 1;\nconst isIPhone = testPlatform(/^iPhone/);\nconst isIOS = isIPhone || isIPad;\nconst isSafari = testUserAgent(/^((?!chrome|android).)*safari/i);\nconst isTouch = (() => {\n  try {\n    document.createEvent('TouchEvent');\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYnJvd3Nlci11dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUVBO0FBRUE7O0FBR0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9icm93c2VyLXV0aWxzLmpzP2Q3NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbmNvbnN0IHRlc3RVc2VyQWdlbnQgPSAocmVnZXhwKSA9PiByZWdleHAudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuY29uc3QgdGVzdFBsYXRmb3JtID0gKHJlZ2V4cCkgPT4gcmVnZXhwLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcblxuY29uc3QgdGVzdFZlbmRvciA9IChyZWdleHApID0+IHJlZ2V4cC50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xuXG5leHBvcnQgY29uc3QgaXNBbmRyb2lkID0gdGVzdFVzZXJBZ2VudCgvQW5kcm9pZC8pO1xuXG5leHBvcnQgY29uc3QgaXNDaHJvbWUgPSB0ZXN0VXNlckFnZW50KC9DaHJvbWUvKSAmJiB0ZXN0VmVuZG9yKC9Hb29nbGUgSW5jLyk7XG5cbmV4cG9ydCBjb25zdCBpc0ZpcmVmb3ggPSB0ZXN0VXNlckFnZW50KC9GaXJlZm94Lyk7XG5cbi8vIGlQYWRPUyAxMyBsaWVzIGFuZCBzYXlzIGl0J3MgYSBNYWMsIGJ1dCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYnkgZGV0ZWN0aW5nIHRvdWNoIHN1cHBvcnQuXG5leHBvcnQgY29uc3QgaXNJUGFkID0gdGVzdFBsYXRmb3JtKC9eaVBhZC8pIHx8ICh0ZXN0UGxhdGZvcm0oL15NYWMvKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKTtcblxuZXhwb3J0IGNvbnN0IGlzSVBob25lID0gdGVzdFBsYXRmb3JtKC9eaVBob25lLyk7XG5cbmV4cG9ydCBjb25zdCBpc0lPUyA9IGlzSVBob25lIHx8IGlzSVBhZDtcblxuZXhwb3J0IGNvbnN0IGlzU2FmYXJpID0gdGVzdFVzZXJBZ2VudCgvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaSk7XG5cbmV4cG9ydCBjb25zdCBpc1RvdWNoID0gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFdmVudCgnVG91Y2hFdmVudCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/browser-utils.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/debounce.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/debounce.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Debouncer\": () => (/* binding */ Debouncer),\n/* harmony export */   \"enqueueDebouncer\": () => (/* binding */ enqueueDebouncer),\n/* harmony export */   \"flush\": () => (/* binding */ flush),\n/* harmony export */   \"flushDebouncers\": () => (/* binding */ flushDebouncers)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nclass Debouncer {\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n\n\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n\n      this._callback();\n    });\n  }\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n\n\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync(); // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n\n\n      debouncerQueue.delete(this);\n    }\n  }\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n\n\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel(\n      /** @type {number} */\n      this._timer);\n\n      this._timer = null;\n    }\n  }\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n\n\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n\n      this._callback();\n    }\n  }\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n\n\n  isActive() {\n    return this._timer != null;\n  }\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@vaadin/component-base/src/async.js';\n   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n\n\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n\n}\nlet debouncerQueue = new Set();\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\n\nconst enqueueDebouncer = function (debouncer) {\n  debouncerQueue.add(debouncer);\n};\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\n\nconst flushDebouncers = function () {\n  const didFlush = Boolean(debouncerQueue.size); // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n};\nconst flush = () => {\n  let debouncers;\n\n  do {\n    debouncers = flushDebouncers();\n  } while (debouncers);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGVib3VuY2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFqSEE7QUFvSEE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2RlYm91bmNlLmpzPzViMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBDb2xsYXBzZSBtdWx0aXBsZSBjYWxsYmFja3MgaW50byBvbmUgaW52b2NhdGlvbiBhZnRlciBhIHRpbWVyLlxuICovXG5leHBvcnQgY2xhc3MgRGVib3VuY2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYXN5bmNNb2R1bGUgPSBudWxsO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjaGVkdWxlcjsgdGhhdCBpcywgYSBtb2R1bGUgd2l0aCB0aGUgQXN5bmMgaW50ZXJmYWNlLFxuICAgKiBhIGNhbGxiYWNrIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBydW4gZnVuY3Rpb25cbiAgICogZnJvbSB0aGUgYXN5bmMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0geyFBc3luY0ludGVyZmFjZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hc3luY01vZHVsZSA9IGFzeW5jTW9kdWxlO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZXIgPSB0aGlzLl9hc3luY01vZHVsZS5ydW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgZGVib3VuY2VyUXVldWUuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9jYW5jZWxBc3luYygpO1xuICAgICAgLy8gQ2FuY2VsaW5nIGEgZGVib3VuY2VyIHJlbW92ZXMgaXRzIHNwb3QgZnJvbSB0aGUgZmx1c2ggcXVldWUsXG4gICAgICAvLyBzbyBpZiBhIGRlYm91bmNlciBpcyBtYW51YWxseSBjYW5jZWxlZCBhbmQgcmUtZGVib3VuY2VkLCBpdFxuICAgICAgLy8gd2lsbCByZXNldCBpdHMgZmx1c2ggb3JkZXIgKHRoaXMgaXMgYSB2ZXJ5IG1pbm9yIGRpZmZlcmVuY2UgZnJvbSAxLngpXG4gICAgICAvLyBSZS1kZWJvdW5jaW5nIHZpYSB0aGUgYGRlYm91bmNlYCBBUEkgcmV0YWlucyB0aGUgMS54IEZJRk8gZmx1c2ggb3JkZXJcbiAgICAgIGRlYm91bmNlclF1ZXVlLmRlbGV0ZSh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBkZWJvdW5jZXIncyBhc3luYyBjYWxsYmFjay5cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIF9jYW5jZWxBc3luYygpIHtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9hc3luY01vZHVsZS5jYW5jZWwoLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLl90aW1lcikpO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmx1c2hlcyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFjdGl2ZS5cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lciAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVib3VuY2VyIGlmIG5vIGRlYm91bmNlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICogb3IgaXQgY2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIG90aGVyd2lzZS4gVGhlIGZvbGxvd2luZ1xuICAgKiBleGFtcGxlIHNob3dzIGhvdyBhIGRlYm91bmNlciBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhXG4gICAqIG1pY3JvdGFzayBhbmQgXCJkZWJvdW5jZWRcIiBzdWNoIHRoYXQgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGlzXG4gICAqIGNhbGxlZCBvbmNlLiBBZGQgdGhpcyBtZXRob2QgdG8gYSBjdXN0b20gZWxlbWVudDpcbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHttaWNyb1Rhc2t9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2FzeW5jLmpzJztcbiAgICogaW1wb3J0IHtEZWJvdW5jZXJ9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2RlYm91bmNlLmpzJztcbiAgICogLy8gLi4uXG4gICAqXG4gICAqIF9kZWJvdW5jZVdvcmsoKSB7XG4gICAqICAgdGhpcy5fZGVib3VuY2VKb2IgPSBEZWJvdW5jZXIuZGVib3VuY2UodGhpcy5fZGVib3VuY2VKb2IsXG4gICAqICAgICAgIG1pY3JvVGFzaywgKCkgPT4gdGhpcy5fZG9Xb3JrKCkpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB0aGUgYF9kZWJvdW5jZVdvcmtgIG1ldGhvZCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lXG4gICAqIG1pY3JvdGFzaywgdGhlIGBfZG9Xb3JrYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgYXQgdGhlIG5leHRcbiAgICogbWljcm90YXNrIGNoZWNrcG9pbnQuXG4gICAqXG4gICAqIE5vdGU6IEluIHRlc3RpbmcgaXQgaXMgb2Z0ZW4gY29udmVuaWVudCB0byBhdm9pZCBhc3luY2hyb255LiBUbyBhY2NvbXBsaXNoXG4gICAqIHRoaXMgd2l0aCBhIGRlYm91bmNlciwgeW91IGNhbiB1c2UgYGVucXVldWVEZWJvdW5jZXJgIGFuZFxuICAgKiBgZmx1c2hgLiBGb3IgZXhhbXBsZSwgZXh0ZW5kIHRoZSBhYm92ZSBleGFtcGxlIGJ5IGFkZGluZ1xuICAgKiBgZW5xdWV1ZURlYm91bmNlcih0aGlzLl9kZWJvdW5jZUpvYilgIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAqIGBfZGVib3VuY2VXb3JrYCBtZXRob2QuIFRoZW4gaW4gYSB0ZXN0LCBjYWxsIGBmbHVzaGAgdG8gZW5zdXJlXG4gICAqIHRoZSBkZWJvdW5jZXIgaGFzIGNvbXBsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtEZWJvdW5jZXI/fSBkZWJvdW5jZXIgRGVib3VuY2VyIG9iamVjdC5cbiAgICogQHBhcmFtIHshQXN5bmNJbnRlcmZhY2V9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICogQHJldHVybiB7IURlYm91bmNlcn0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgZGVib3VuY2UoZGVib3VuY2VyLCBhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZGVib3VuY2VyIGluc3RhbmNlb2YgRGVib3VuY2VyKSB7XG4gICAgICAvLyBDYW5jZWwgdGhlIGFzeW5jIGNhbGxiYWNrLCBidXQgbGVhdmUgaW4gZGVib3VuY2VyUXVldWUgaWYgaXQgd2FzXG4gICAgICAvLyBlbnF1ZXVlZCwgdG8gbWFpbnRhaW4gMS54IGZsdXNoIG9yZGVyXG4gICAgICBkZWJvdW5jZXIuX2NhbmNlbEFzeW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYm91bmNlciA9IG5ldyBEZWJvdW5jZXIoKTtcbiAgICB9XG4gICAgZGVib3VuY2VyLnNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBkZWJvdW5jZXI7XG4gIH1cbn1cblxubGV0IGRlYm91bmNlclF1ZXVlID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEFkZHMgYSBgRGVib3VuY2VyYCB0byBhIGxpc3Qgb2YgZ2xvYmFsbHkgZmx1c2hhYmxlIHRhc2tzLlxuICpcbiAqIEBwYXJhbSB7IURlYm91bmNlcn0gZGVib3VuY2VyIERlYm91bmNlciB0byBlbnF1ZXVlXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3QgZW5xdWV1ZURlYm91bmNlciA9IGZ1bmN0aW9uIChkZWJvdW5jZXIpIHtcbiAgZGVib3VuY2VyUXVldWUuYWRkKGRlYm91bmNlcik7XG59O1xuXG4vKipcbiAqIEZsdXNoZXMgYW55IGVucXVldWVkIGRlYm91bmNlcnNcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHdoZXRoZXIgYW55IGRlYm91bmNlcnMgd2VyZSBmbHVzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBmbHVzaERlYm91bmNlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGRpZEZsdXNoID0gQm9vbGVhbihkZWJvdW5jZXJRdWV1ZS5zaXplKTtcbiAgLy8gSWYgbmV3IGRlYm91bmNlcnMgYXJlIGFkZGVkIHdoaWxlIGZsdXNoaW5nLCBTZXQuZm9yRWFjaCB3aWxsIGVuc3VyZVxuICAvLyBuZXdseSBhZGRlZCBvbmVzIGFyZSBhbHNvIGZsdXNoZWRcbiAgZGVib3VuY2VyUXVldWUuZm9yRWFjaCgoZGVib3VuY2VyKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGRlYm91bmNlci5mbHVzaCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRpZEZsdXNoO1xufTtcblxuZXhwb3J0IGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICBsZXQgZGVib3VuY2VycztcbiAgZG8ge1xuICAgIGRlYm91bmNlcnMgPSBmbHVzaERlYm91bmNlcnMoKTtcbiAgfSB3aGlsZSAoZGVib3VuY2Vycyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/debounce.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/dir-helper.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/dir-helper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirHelper\": () => (/* binding */ DirHelper)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Helper that provides a set of functions for RTL.\n */\nclass DirHelper {\n  /**\n   * Get the scroll type in the current browser view.\n   *\n   * @return {string} the scroll type. Possible values are `default|reverse|negative`\n   */\n  static detectScrollType() {\n    const dummy = document.createElement('div');\n    dummy.textContent = 'ABCD';\n    dummy.dir = 'rtl';\n    dummy.style.fontSize = '14px';\n    dummy.style.width = '4px';\n    dummy.style.height = '1px';\n    dummy.style.position = 'absolute';\n    dummy.style.top = '-1000px';\n    dummy.style.overflow = 'scroll';\n    document.body.appendChild(dummy);\n    let cachedType = 'reverse';\n\n    if (dummy.scrollLeft > 0) {\n      cachedType = 'default';\n    } else {\n      dummy.scrollLeft = 2;\n\n      if (dummy.scrollLeft < 2) {\n        cachedType = 'negative';\n      }\n    }\n\n    document.body.removeChild(dummy);\n    return cachedType;\n  }\n  /**\n   * Get the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @return {number} the scrollLeft value.\n   */\n\n\n  static getNormalizedScrollLeft(scrollType, direction, element) {\n    const {\n      scrollLeft\n    } = element;\n\n    if (direction !== 'rtl' || !scrollType) {\n      return scrollLeft;\n    }\n\n    switch (scrollType) {\n      case 'negative':\n        return element.scrollWidth - element.clientWidth + scrollLeft;\n\n      case 'reverse':\n        return element.scrollWidth - element.clientWidth - scrollLeft;\n    }\n\n    return scrollLeft;\n  }\n  /**\n   * Set the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @param {number} scrollLeft the scrollLeft value to be set\n   */\n\n\n  static setNormalizedScrollLeft(scrollType, direction, element, scrollLeft) {\n    if (direction !== 'rtl' || !scrollType) {\n      element.scrollLeft = scrollLeft;\n      return;\n    }\n\n    switch (scrollType) {\n      case 'negative':\n        element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;\n        break;\n\n      case 'reverse':\n        element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;\n        break;\n\n      default:\n        element.scrollLeft = scrollLeft;\n        break;\n    }\n  }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlyLWhlbHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSkE7O0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7O0FBL0VBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9kaXItaGVscGVyLmpzP2ExOTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbi8qKlxuICogSGVscGVyIHRoYXQgcHJvdmlkZXMgYSBzZXQgb2YgZnVuY3Rpb25zIGZvciBSVEwuXG4gKi9cbmNsYXNzIERpckhlbHBlciB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHNjcm9sbCB0eXBlIGluIHRoZSBjdXJyZW50IGJyb3dzZXIgdmlldy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgc2Nyb2xsIHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYGRlZmF1bHR8cmV2ZXJzZXxuZWdhdGl2ZWBcbiAgICovXG4gIHN0YXRpYyBkZXRlY3RTY3JvbGxUeXBlKCkge1xuICAgIGNvbnN0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHVtbXkudGV4dENvbnRlbnQgPSAnQUJDRCc7XG4gICAgZHVtbXkuZGlyID0gJ3J0bCc7XG4gICAgZHVtbXkuc3R5bGUuZm9udFNpemUgPSAnMTRweCc7XG4gICAgZHVtbXkuc3R5bGUud2lkdGggPSAnNHB4JztcbiAgICBkdW1teS5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICBkdW1teS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZHVtbXkuc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGR1bW15LnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkdW1teSk7XG5cbiAgICBsZXQgY2FjaGVkVHlwZSA9ICdyZXZlcnNlJztcbiAgICBpZiAoZHVtbXkuc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgIGNhY2hlZFR5cGUgPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15LnNjcm9sbExlZnQgPSAyO1xuICAgICAgaWYgKGR1bW15LnNjcm9sbExlZnQgPCAyKSB7XG4gICAgICAgIGNhY2hlZFR5cGUgPSAnbmVnYXRpdmUnO1xuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGR1bW15KTtcbiAgICByZXR1cm4gY2FjaGVkVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNjcm9sbExlZnQgdmFsdWUgb2YgdGhlIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2Nyb2xsVHlwZSB0eXBlIG9mIHRoZSBzY3JvbGwgZGV0ZWN0ZWQgd2l0aCBgZGV0ZWN0U2Nyb2xsVHlwZWBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBjdXJyZW50IGRpcmVjdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgc2Nyb2xsTGVmdCB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBnZXROb3JtYWxpemVkU2Nyb2xsTGVmdChzY3JvbGxUeXBlLCBkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICBjb25zdCB7IHNjcm9sbExlZnQgfSA9IGVsZW1lbnQ7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3J0bCcgfHwgIXNjcm9sbFR5cGUpIHtcbiAgICAgIHJldHVybiBzY3JvbGxMZWZ0O1xuICAgIH1cblxuICAgIHN3aXRjaCAoc2Nyb2xsVHlwZSkge1xuICAgICAgY2FzZSAnbmVnYXRpdmUnOlxuICAgICAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxMZWZ0O1xuICAgICAgY2FzZSAncmV2ZXJzZSc6XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCAtIHNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHJldHVybiBzY3JvbGxMZWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2Nyb2xsTGVmdCB2YWx1ZSBvZiB0aGUgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgZGlyZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY3JvbGxUeXBlIHR5cGUgb2YgdGhlIHNjcm9sbCBkZXRlY3RlZCB3aXRoIGBkZXRlY3RTY3JvbGxUeXBlYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIGN1cnJlbnQgZGlyZWN0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsTGVmdCB0aGUgc2Nyb2xsTGVmdCB2YWx1ZSB0byBiZSBzZXRcbiAgICovXG4gIHN0YXRpYyBzZXROb3JtYWxpemVkU2Nyb2xsTGVmdChzY3JvbGxUeXBlLCBkaXJlY3Rpb24sIGVsZW1lbnQsIHNjcm9sbExlZnQpIHtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAncnRsJyB8fCAhc2Nyb2xsVHlwZSkge1xuICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHNjcm9sbFR5cGUpIHtcbiAgICAgIGNhc2UgJ25lZ2F0aXZlJzpcbiAgICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gZWxlbWVudC5jbGllbnRXaWR0aCAtIGVsZW1lbnQuc2Nyb2xsV2lkdGggKyBzY3JvbGxMZWZ0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JldmVyc2UnOlxuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCAtIHNjcm9sbExlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7IERpckhlbHBlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/dir-helper.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/dir-mixin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/dir-mixin.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirMixin\": () => (/* binding */ DirMixin)\n/* harmony export */ });\n/* harmony import */ var _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dir-helper.js */ \"./node_modules/@vaadin/component-base/src/dir-helper.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Array of Vaadin custom element classes that have been subscribed to the dir changes.\n */\n\nconst directionSubscribers = [];\n\nconst directionUpdater = function () {\n  const documentDir = getDocumentDir();\n  directionSubscribers.forEach(element => {\n    alignDirs(element, documentDir);\n  });\n};\n\nlet scrollType;\nconst directionObserver = new MutationObserver(directionUpdater);\ndirectionObserver.observe(document.documentElement, {\n  attributes: true,\n  attributeFilter: ['dir']\n});\n\nconst alignDirs = function (element, documentDir, elementDir = element.getAttribute('dir')) {\n  if (documentDir) {\n    element.setAttribute('dir', documentDir);\n  } else if (elementDir != null) {\n    element.removeAttribute('dir');\n  }\n};\n\nconst getDocumentDir = function () {\n  return document.documentElement.getAttribute('dir');\n};\n/**\n * A mixin to handle `dir` attribute based on the one set on the `<html>` element.\n *\n * @polymerMixin\n */\n\n\nconst DirMixin = superClass => class VaadinDirMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * @protected\n       */\n      dir: {\n        type: String,\n        value: '',\n        reflectToAttribute: true\n      }\n    };\n  }\n  /** @protected */\n\n\n  static finalize() {\n    super.finalize();\n\n    if (!scrollType) {\n      scrollType = _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.detectScrollType();\n    }\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (!this.hasAttribute('dir')) {\n      this.__subscribe();\n\n      alignDirs(this, getDocumentDir(), null);\n    }\n  }\n  /** @protected */\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n\n    if (name !== 'dir') {\n      return;\n    }\n\n    const documentDir = getDocumentDir(); // New value equals to the document direction and the element is not subscribed to the changes\n\n    const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1; // Value was emptied and the element is not subscribed to the changes\n\n    const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1; // New value is different and the old equals to document direction and the element is not subscribed to the changes\n\n    const newDiffValue = newValue !== documentDir && oldValue === documentDir;\n\n    if (newValueEqlDocDir || newValueEmptied) {\n      this.__subscribe();\n\n      alignDirs(this, documentDir, newValue);\n    } else if (newDiffValue) {\n      this.__subscribe(false);\n    }\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    this.__subscribe(false);\n\n    this.removeAttribute('dir');\n  }\n  /** @protected */\n\n\n  _valueToNodeAttribute(node, value, attribute) {\n    // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n    // If the property contains an empty string then it should not create an empty attribute\n    if (attribute === 'dir' && value === '' && !node.hasAttribute('dir')) {\n      return;\n    }\n\n    super._valueToNodeAttribute(node, value, attribute);\n  }\n  /** @protected */\n\n\n  _attributeToProperty(attribute, value, type) {\n    // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n    // If the attribute is removed, then the dir property should contain an empty string instead of null\n    if (attribute === 'dir' && !value) {\n      this.dir = '';\n    } else {\n      super._attributeToProperty(attribute, value, type);\n    }\n  }\n  /** @private */\n\n\n  __subscribe(push = true) {\n    if (push) {\n      directionSubscribers.indexOf(this) === -1 && directionSubscribers.push(this);\n    } else {\n      directionSubscribers.indexOf(this) > -1 && directionSubscribers.splice(directionSubscribers.indexOf(this), 1);\n    }\n  }\n  /**\n   * @param {Element} element\n   * @return {number}\n   * @protected\n   */\n\n\n  __getNormalizedScrollLeft(element) {\n    return _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.getNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element);\n  }\n  /**\n   * @param {Element} element\n   * @param {number} scrollLeft\n   * @protected\n   */\n\n\n  __setNormalizedScrollLeft(element, scrollLeft) {\n    return _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.setNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element, scrollLeft);\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlyLW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUpBO0FBVUE7QUFFQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQTlHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlyLW1peGluLmpzPzRlM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBEaXJIZWxwZXIgfSBmcm9tICcuL2Rpci1oZWxwZXIuanMnO1xuXG4vKipcbiAqIEFycmF5IG9mIFZhYWRpbiBjdXN0b20gZWxlbWVudCBjbGFzc2VzIHRoYXQgaGF2ZSBiZWVuIHN1YnNjcmliZWQgdG8gdGhlIGRpciBjaGFuZ2VzLlxuICovXG5jb25zdCBkaXJlY3Rpb25TdWJzY3JpYmVycyA9IFtdO1xuY29uc3QgZGlyZWN0aW9uVXBkYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgZG9jdW1lbnREaXIgPSBnZXREb2N1bWVudERpcigpO1xuICBkaXJlY3Rpb25TdWJzY3JpYmVycy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgYWxpZ25EaXJzKGVsZW1lbnQsIGRvY3VtZW50RGlyKTtcbiAgfSk7XG59O1xuXG5sZXQgc2Nyb2xsVHlwZTtcblxuY29uc3QgZGlyZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihkaXJlY3Rpb25VcGRhdGVyKTtcbmRpcmVjdGlvbk9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZUZpbHRlcjogWydkaXInXSB9KTtcblxuY29uc3QgYWxpZ25EaXJzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGRvY3VtZW50RGlyLCBlbGVtZW50RGlyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpKSB7XG4gIGlmIChkb2N1bWVudERpcikge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXInLCBkb2N1bWVudERpcik7XG4gIH0gZWxzZSBpZiAoZWxlbWVudERpciAhPSBudWxsKSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RpcicpO1xuICB9XG59O1xuXG5jb25zdCBnZXREb2N1bWVudERpciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpO1xufTtcblxuLyoqXG4gKiBBIG1peGluIHRvIGhhbmRsZSBgZGlyYCBhdHRyaWJ1dGUgYmFzZWQgb24gdGhlIG9uZSBzZXQgb24gdGhlIGA8aHRtbD5gIGVsZW1lbnQuXG4gKlxuICogQHBvbHltZXJNaXhpblxuICovXG5leHBvcnQgY29uc3QgRGlyTWl4aW4gPSAoc3VwZXJDbGFzcykgPT5cbiAgY2xhc3MgVmFhZGluRGlyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGlyOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgc3VwZXIuZmluYWxpemUoKTtcblxuICAgICAgaWYgKCFzY3JvbGxUeXBlKSB7XG4gICAgICAgIHNjcm9sbFR5cGUgPSBEaXJIZWxwZXIuZGV0ZWN0U2Nyb2xsVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdkaXInKSkge1xuICAgICAgICB0aGlzLl9fc3Vic2NyaWJlKCk7XG4gICAgICAgIGFsaWduRGlycyh0aGlzLCBnZXREb2N1bWVudERpcigpLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgaWYgKG5hbWUgIT09ICdkaXInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZG9jdW1lbnREaXIgPSBnZXREb2N1bWVudERpcigpO1xuXG4gICAgICAvLyBOZXcgdmFsdWUgZXF1YWxzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3Rpb24gYW5kIHRoZSBlbGVtZW50IGlzIG5vdCBzdWJzY3JpYmVkIHRvIHRoZSBjaGFuZ2VzXG4gICAgICBjb25zdCBuZXdWYWx1ZUVxbERvY0RpciA9IG5ld1ZhbHVlID09PSBkb2N1bWVudERpciAmJiBkaXJlY3Rpb25TdWJzY3JpYmVycy5pbmRleE9mKHRoaXMpID09PSAtMTtcbiAgICAgIC8vIFZhbHVlIHdhcyBlbXB0aWVkIGFuZCB0aGUgZWxlbWVudCBpcyBub3Qgc3Vic2NyaWJlZCB0byB0aGUgY2hhbmdlc1xuICAgICAgY29uc3QgbmV3VmFsdWVFbXB0aWVkID0gIW5ld1ZhbHVlICYmIG9sZFZhbHVlICYmIGRpcmVjdGlvblN1YnNjcmliZXJzLmluZGV4T2YodGhpcykgPT09IC0xO1xuICAgICAgLy8gTmV3IHZhbHVlIGlzIGRpZmZlcmVudCBhbmQgdGhlIG9sZCBlcXVhbHMgdG8gZG9jdW1lbnQgZGlyZWN0aW9uIGFuZCB0aGUgZWxlbWVudCBpcyBub3Qgc3Vic2NyaWJlZCB0byB0aGUgY2hhbmdlc1xuICAgICAgY29uc3QgbmV3RGlmZlZhbHVlID0gbmV3VmFsdWUgIT09IGRvY3VtZW50RGlyICYmIG9sZFZhbHVlID09PSBkb2N1bWVudERpcjtcblxuICAgICAgaWYgKG5ld1ZhbHVlRXFsRG9jRGlyIHx8IG5ld1ZhbHVlRW1wdGllZCkge1xuICAgICAgICB0aGlzLl9fc3Vic2NyaWJlKCk7XG4gICAgICAgIGFsaWduRGlycyh0aGlzLCBkb2N1bWVudERpciwgbmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChuZXdEaWZmVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3N1YnNjcmliZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLl9fc3Vic2NyaWJlKGZhbHNlKTtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdkaXInKTtcbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IFBvbHltZXIgYXR0cmlidXRlIHJlZmxlY3Rpb24gdG8gbWF0Y2ggbmF0aXZlIGJlaGF2aW9yIG9mIEhUTUxFbGVtZW50LmRpciBwcm9wZXJ0eVxuICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGNvbnRhaW5zIGFuIGVtcHR5IHN0cmluZyB0aGVuIGl0IHNob3VsZCBub3QgY3JlYXRlIGFuIGVtcHR5IGF0dHJpYnV0ZVxuICAgICAgaWYgKGF0dHJpYnV0ZSA9PT0gJ2RpcicgJiYgdmFsdWUgPT09ICcnICYmICFub2RlLmhhc0F0dHJpYnV0ZSgnZGlyJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3VwZXIuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKG5vZGUsIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgX2F0dHJpYnV0ZVRvUHJvcGVydHkoYXR0cmlidXRlLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBQb2x5bWVyIGF0dHJpYnV0ZSByZWZsZWN0aW9uIHRvIG1hdGNoIG5hdGl2ZSBiZWhhdmlvciBvZiBIVE1MRWxlbWVudC5kaXIgcHJvcGVydHlcbiAgICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCwgdGhlbiB0aGUgZGlyIHByb3BlcnR5IHNob3VsZCBjb250YWluIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIG51bGxcbiAgICAgIGlmIChhdHRyaWJ1dGUgPT09ICdkaXInICYmICF2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpciA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIuX2F0dHJpYnV0ZVRvUHJvcGVydHkoYXR0cmlidXRlLCB2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX19zdWJzY3JpYmUocHVzaCA9IHRydWUpIHtcbiAgICAgIGlmIChwdXNoKSB7XG4gICAgICAgIGRpcmVjdGlvblN1YnNjcmliZXJzLmluZGV4T2YodGhpcykgPT09IC0xICYmIGRpcmVjdGlvblN1YnNjcmliZXJzLnB1c2godGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb25TdWJzY3JpYmVycy5pbmRleE9mKHRoaXMpID4gLTEgJiYgZGlyZWN0aW9uU3Vic2NyaWJlcnMuc3BsaWNlKGRpcmVjdGlvblN1YnNjcmliZXJzLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX19nZXROb3JtYWxpemVkU2Nyb2xsTGVmdChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gRGlySGVscGVyLmdldE5vcm1hbGl6ZWRTY3JvbGxMZWZ0KHNjcm9sbFR5cGUsIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXInKSB8fCAnbHRyJywgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbExlZnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX19zZXROb3JtYWxpemVkU2Nyb2xsTGVmdChlbGVtZW50LCBzY3JvbGxMZWZ0KSB7XG4gICAgICByZXR1cm4gRGlySGVscGVyLnNldE5vcm1hbGl6ZWRTY3JvbGxMZWZ0KHNjcm9sbFR5cGUsIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXInKSB8fCAnbHRyJywgZWxlbWVudCwgc2Nyb2xsTGVmdCk7XG4gICAgfVxuICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/dir-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/disabled-mixin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/disabled-mixin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DisabledMixin\": () => (/* binding */ DisabledMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * A mixin to provide disabled property for field components.\n *\n * @polymerMixin\n */\n\nconst DisabledMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superclass => class DisabledMixinClass extends superclass {\n  static get properties() {\n    return {\n      /**\n       * If true, the user cannot interact with this element.\n       */\n      disabled: {\n        type: Boolean,\n        value: false,\n        observer: '_disabledChanged',\n        reflectToAttribute: true\n      }\n    };\n  }\n  /**\n   * @param {boolean} disabled\n   * @protected\n   */\n\n\n  _disabledChanged(disabled) {\n    this._setAriaDisabled(disabled);\n  }\n  /**\n   * @param {boolean} disabled\n   * @protected\n   */\n\n\n  _setAriaDisabled(disabled) {\n    if (disabled) {\n      this.setAttribute('aria-disabled', 'true');\n    } else {\n      this.removeAttribute('aria-disabled');\n    }\n  }\n  /**\n   * Overrides the default element `click` method in order to prevent\n   * firing the `click` event when the element is disabled.\n   * @protected\n   * @override\n   */\n\n\n  click() {\n    if (!this.disabled) {\n      super.click();\n    }\n  }\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlzYWJsZWQtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUpBO0FBV0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTdDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlzYWJsZWQtbWl4aW4uanM/NjYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcyc7XG5cbi8qKlxuICogQSBtaXhpbiB0byBwcm92aWRlIGRpc2FibGVkIHByb3BlcnR5IGZvciBmaWVsZCBjb21wb25lbnRzLlxuICpcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IERpc2FibGVkTWl4aW4gPSBkZWR1cGluZ01peGluKFxuICAoc3VwZXJjbGFzcykgPT5cbiAgICBjbGFzcyBEaXNhYmxlZE1peGluQ2xhc3MgZXh0ZW5kcyBzdXBlcmNsYXNzIHtcbiAgICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiB0cnVlLCB0aGUgdXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZGlzYWJsZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICBvYnNlcnZlcjogJ19kaXNhYmxlZENoYW5nZWQnLFxuICAgICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZGlzYWJsZWRDaGFuZ2VkKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuX3NldEFyaWFEaXNhYmxlZChkaXNhYmxlZCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0QXJpYURpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGVsZW1lbnQgYGNsaWNrYCBtZXRob2QgaW4gb3JkZXIgdG8gcHJldmVudFxuICAgICAgICogZmlyaW5nIHRoZSBgY2xpY2tgIGV2ZW50IHdoZW4gdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQuXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAqL1xuICAgICAgY2xpY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHN1cGVyLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/disabled-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/iron-list-core.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/iron-list-core.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ironList\": () => (/* binding */ ironList)\n/* harmony export */ });\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async.js */ \"./node_modules/@vaadin/component-base/src/async.js\");\n/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debounce.js */ \"./node_modules/@vaadin/component-base/src/debounce.js\");\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n/**\n * @private\n */\n\nconst ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The maximum items per row\n   */\n  _itemsPerRow: 1,\n\n  /**\n   * The width of each grid item\n   */\n  _itemWidth: 0,\n\n  /**\n   * The height of the row in grid layout.\n   */\n  _rowHeight: 0,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * Needed to pass event.model property to declarative event handlers -\n   * see polymer/polymer#4339.\n   */\n  _parentModel: true,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    var size = this.grid ? this._physicalRows * this._rowHeight : this._physicalSize;\n    return size - this._viewportHeight;\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    var virtualCount = this._convertIndexToCompleteRow(this._virtualCount);\n\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n\n    if (this.grid) {\n      val = val - val % this._itemsPerRow;\n    }\n\n    this._virtualStartVal = val;\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val = val % this._physicalCount;\n\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n\n    if (this.grid) {\n      val = val - val % this._itemsPerRow;\n    }\n\n    this._physicalStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    var idx = this._firstVisibleIndexVal;\n\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n      idx = this._iterateItems(function (pidx, vidx) {\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n        if (physicalOffset > this._scrollPosition) {\n          return this.grid ? vidx - vidx % this._itemsPerRow : vidx;\n        } // Handle a partially rendered final row in grid mode\n\n\n        if (this.grid && this._virtualCount - 1 === vidx) {\n          return vidx - vidx % this._itemsPerRow;\n        }\n      }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    var idx = this._lastVisibleIndexVal;\n\n    if (idx == null) {\n      if (this.grid) {\n        idx = Math.min(this._virtualCount, this.firstVisibleIndex + this._estRowsInView * this._itemsPerRow - 1);\n      } else {\n        var physicalOffset = this._physicalTop + this._scrollOffset;\n\n        this._iterateItems(function (pidx, vidx) {\n          if (physicalOffset < this._scrollBottom) {\n            idx = vidx;\n          }\n\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        });\n      }\n\n      this._lastVisibleIndexVal = idx;\n    }\n\n    return idx;\n  },\n\n  get _defaultScrollTarget() {\n    return this;\n  },\n\n  get _virtualRowCount() {\n    return Math.ceil(this._virtualCount / this._itemsPerRow);\n  },\n\n  get _estRowsInView() {\n    return Math.ceil(this._viewportHeight / this._rowHeight);\n  },\n\n  get _physicalRows() {\n    return Math.ceil(this._physicalCount / this._itemsPerRow);\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler: function () {\n    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    var delta = scrollTop - this._scrollPosition;\n    var isScrollingDown = delta >= 0; // Track the current scroll position.\n\n    this._scrollPosition = scrollTop; // Clear indexes for first and last visible indexes.\n\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null; // Random access.\n\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta = delta - this._scrollOffset;\n\n      var idxAdjustment = Math.round(delta / this._physicalAverage) * this._itemsPerRow;\n\n      this._virtualStart = this._virtualStart + idxAdjustment;\n      this._physicalStart = this._physicalStart + idxAdjustment; // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n\n      this._physicalTop = Math.min(Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage, this._scrollPosition);\n\n      this._update();\n    } else if (this._physicalCount > 0) {\n      var reusables = this._getReusables(isScrollingDown);\n\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart = this._virtualStart + reusables.indexes.length;\n        this._physicalStart = this._physicalStart + reusables.indexes.length;\n      } else {\n        this._virtualStart = this._virtualStart - reusables.indexes.length;\n        this._physicalStart = this._physicalStart - reusables.indexes.length;\n      }\n\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), _async_js__WEBPACK_IMPORTED_MODULE_0__.microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables: function (fromTop) {\n    var ith, lastIth, offsetContent, physicalItemHeight;\n    var idxs = [];\n    var protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    var virtualStart = this._virtualStart;\n    var virtualEnd = this._virtualEnd;\n    var physicalCount = this._physicalCount;\n    var top = this._physicalTop + this._scrollOffset;\n    var bottom = this._physicalBottom + this._scrollOffset; // This may be called outside of a scrollHandler, so use last cached position\n\n    var scrollTop = this._scrollPosition;\n    var scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      lastIth = this._physicalEnd;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n      lastIth = this._physicalStart;\n      offsetContent = bottom - scrollBottom;\n    } // eslint-disable-next-line no-constant-condition\n\n\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent = offsetContent - physicalItemHeight;\n\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        } // Check that the index is not visible.\n\n\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n\n        idxs.push(ith);\n        top = top + physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        } // Check that the index is not visible.\n\n\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n\n        idxs.push(ith);\n        top = top - physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n\n    return {\n      indexes: idxs,\n      physicalTop: top - this._scrollOffset\n    };\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update: function (itemSet, movingUp) {\n    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {\n      return;\n    }\n\n    this._manageFocus();\n\n    this._assignModels(itemSet);\n\n    this._updateMetrics(itemSet); // Adjust offset after measuring.\n\n\n    if (movingUp) {\n      while (movingUp.length) {\n        var idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n\n    this._positionItems();\n\n    this._updateScrollerSize();\n  },\n  _isClientFull: function () {\n    return this._scrollBottom != 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded: function (count) {\n    var nextPhysicalCount = this._clamp(this._physicalCount + count, DEFAULT_PHYSICAL_COUNT, this._virtualCount - this._virtualStart);\n\n    nextPhysicalCount = this._convertIndexToCompleteRow(nextPhysicalCount);\n\n    if (this.grid) {\n      var correction = nextPhysicalCount % this._itemsPerRow;\n\n      if (correction && nextPhysicalCount - correction <= this._physicalCount) {\n        nextPhysicalCount += this._itemsPerRow;\n      }\n\n      nextPhysicalCount -= correction;\n    }\n\n    var delta = nextPhysicalCount - this._physicalCount;\n    var nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n\n    if (delta > 0) {\n      var ts = window.performance.now(); // Concat arrays in place.\n\n      [].push.apply(this._physicalItems, this._createPool(delta)); // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n\n      for (var i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n\n      this._physicalCount = this._physicalCount + delta; // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n\n      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {\n        this._physicalStart = this._physicalStart + delta;\n      }\n\n      this._update();\n\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    } // The upper bounds is not fixed when dealing with a grid that doesn't\n    // fill it's last row with the exact number of items per row.\n\n\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {// Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), _async_js__WEBPACK_IMPORTED_MODULE_0__.microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)), _async_js__WEBPACK_IMPORTED_MODULE_0__.idlePeriod);\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render: function () {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n\n    if (this._physicalCount !== 0) {\n      var reusables = this._getReusables(true);\n\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart = this._virtualStart + reusables.indexes.length;\n      this._physicalStart = this._physicalStart + reusables.indexes.length;\n\n      this._update(reusables.indexes);\n\n      this._update();\n\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n  _gridChanged: function (newGrid, oldGrid) {\n    if (typeof oldGrid === 'undefined') return;\n    this.notifyResize();\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__.flush)();\n    newGrid && this._updateGridMetrics();\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged: function (change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n\n      this._removeFocusedItem();\n\n      this._debounce('_render', this._render, _async_js__WEBPACK_IMPORTED_MODULE_0__.animationFrame);\n    } else if (change.path === 'items.splices') {\n      this._adjustVirtualIndex(change.value.indexSplices);\n\n      this._virtualCount = this.items ? this.items.length : 0; // Only blur if at least one item is added or removed.\n\n      var itemAddedOrRemoved = change.value.indexSplices.some(function (splice) {\n        return splice.addedCount > 0 || splice.removed.length > 0;\n      });\n\n      if (itemAddedOrRemoved) {\n        // Only blur activeElement if it is a descendant of the list (#505,\n        // #507).\n        var activeElement = this._getActiveElement();\n\n        if (this.contains(activeElement)) {\n          activeElement.blur();\n        }\n      } // Render only if the affected index is rendered.\n\n\n      var affectedIndexRendered = change.value.indexSplices.some(function (splice) {\n        return splice.index + splice.addedCount >= this._virtualStart && splice.index <= this._virtualEnd;\n      }, this);\n\n      if (!this._isClientFull() || affectedIndexRendered) {\n        this._debounce('_render', this._render, _async_js__WEBPACK_IMPORTED_MODULE_0__.animationFrame);\n      }\n    } else if (change.path !== 'items.length') {\n      this._forwardItemPath(change.path, change.value);\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems: function (fn, itemSet) {\n    var pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx: function (pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics: function (itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__.flush)();\n    var newPhysicalSize = 0;\n    var oldPhysicalSize = 0;\n    var prevAvgCount = this._physicalAverageCount;\n    var prevPhysicalAvg = this._physicalAverage; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    this._iterateItems(function (pidx, vidx) {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = this._physicalItems[pidx].offsetHeight;\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    if (this.grid) {\n      this._updateGridMetrics();\n\n      this._physicalSize = Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n    } else {\n      oldPhysicalSize = this._itemsPerRow === 1 ? oldPhysicalSize : Math.ceil(this._physicalCount / this._itemsPerRow) * this._rowHeight;\n      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n      this._itemsPerRow = 1;\n    } // Update the average if it measured something.\n\n\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);\n    }\n  },\n  _updateGridMetrics: function () {\n    this._itemWidth = this._physicalCount > 0 ? this._physicalItems[0].getBoundingClientRect().width : 200;\n    this._rowHeight = this._physicalCount > 0 ? this._physicalItems[0].offsetHeight : 200;\n    this._itemsPerRow = this._itemWidth ? Math.floor(this._viewportWidth / this._itemWidth) : this._itemsPerRow;\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems: function () {\n    this._adjustScrollPosition();\n\n    var y = this._physicalTop;\n\n    if (this.grid) {\n      var totalItemWidth = this._itemsPerRow * this._itemWidth;\n      var rowOffset = (this._viewportWidth - totalItemWidth) / 2;\n\n      this._iterateItems(function (pidx, vidx) {\n        var modulus = vidx % this._itemsPerRow;\n        var x = Math.floor(modulus * this._itemWidth + rowOffset);\n\n        if (this._isRTL) {\n          x = x * -1;\n        }\n\n        this.translate3d(x + 'px', y + 'px', 0, this._physicalItems[pidx]);\n\n        if (this._shouldRenderNextRow(vidx)) {\n          y += this._rowHeight;\n        }\n      });\n    } else {\n      const order = []; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n      this._iterateItems(function (pidx, vidx) {\n        const item = this._physicalItems[pidx];\n        this.translate3d(0, y + 'px', 0, item);\n        y += this._physicalSizes[pidx];\n        const itemId = item.id;\n\n        if (itemId) {\n          order.push(itemId);\n        }\n      });\n\n      if (order.length) {\n        this.setAttribute('aria-owns', order.join(' '));\n      }\n    }\n  },\n  _getPhysicalSizeIncrement: function (pidx) {\n    if (!this.grid) {\n      return this._physicalSizes[pidx];\n    }\n\n    if (this._computeVidx(pidx) % this._itemsPerRow !== this._itemsPerRow - 1) {\n      return 0;\n    }\n\n    return this._rowHeight;\n  },\n\n  /**\n   * Returns, based on the current index,\n   * whether or not the next index will need\n   * to be rendered on a new row.\n   *\n   * @param {number} vidx Virtual index\n   * @return {boolean}\n   */\n  _shouldRenderNextRow: function (vidx) {\n    return vidx % this._itemsPerRow === this._itemsPerRow - 1;\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition: function () {\n    var deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0); // Note: the delta can be positive or negative.\n\n    if (deltaHeight !== 0) {\n      this._physicalTop = this._physicalTop - deltaHeight; // This may be called outside of a scrollHandler, so use last cached position\n\n      var scrollTop = this._scrollPosition; // juking scroll position during interial scrolling on iOS is no bueno\n\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition: function (pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize: function (forceUpdate) {\n    if (this.grid) {\n      this._estScrollHeight = this._virtualRowCount * this._rowHeight;\n    } else {\n      this._estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n    }\n\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    forceUpdate = forceUpdate || this.grid && this.$.items.style.height < this._estScrollHeight; // Amortize height adjustment, so it won't trigger large repaints too often.\n\n    if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = this._estScrollHeight + 'px';\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex: function (idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__.flush)(); // Items should have been rendered prior scrolling to an index.\n\n    if (this._physicalCount === 0) {\n      return;\n    }\n\n    idx = this._clamp(idx, 0, this._virtualCount - 1); // Update the virtual start only when needed.\n\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = this.grid ? idx - this._itemsPerRow * 2 : idx - 1;\n    }\n\n    this._manageFocus();\n\n    this._assignModels();\n\n    this._updateMetrics(); // Estimate new physical offset.\n\n\n    this._physicalTop = Math.floor(this._virtualStart / this._itemsPerRow) * this._physicalAverage;\n    var currentTopItem = this._physicalStart;\n    var currentVirtualItem = this._virtualStart;\n    var targetOffsetTop = 0;\n    var hiddenContentSize = this._hiddenContentSize; // scroll to the item as much as we can.\n\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop = targetOffsetTop + this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem++;\n    }\n\n    this._updateScrollerSize(true);\n\n    this._positionItems();\n\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n\n    this._increasePoolIfNeeded(0); // clear cached visible index.\n\n\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage: function () {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler: function () {\n    this._debounce('_render', function () {\n      // clear cached visible index.\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n\n      if (this._isVisible) {\n        this.updateViewportBoundaries(); // Reinstall the scroll event listener.\n\n        this.toggleScrollListener(true);\n\n        this._resetAverage();\n\n        this._render();\n      } else {\n        // Uninstall the scroll event listener.\n        this.toggleScrollListener(false);\n      }\n    }, _async_js__WEBPACK_IMPORTED_MODULE_0__.animationFrame);\n  },\n\n  /**\n   * Updates the size of a given list item.\n   *\n   * @method updateSizeForItem\n   * @param {Object} item The item instance.\n   */\n  updateSizeForItem: function (item) {\n    return this.updateSizeForIndex(this.items.indexOf(item));\n  },\n\n  /**\n   * Updates the size of the item at the given index in the items array.\n   *\n   * @method updateSizeForIndex\n   * @param {number} index The index of the item in the items array.\n   */\n  updateSizeForIndex: function (index) {\n    if (!this._isIndexRendered(index)) {\n      return null;\n    }\n\n    this._updateMetrics([this._getPhysicalIndex(index)]);\n\n    this._positionItems();\n\n    return null;\n  },\n\n  /**\n   * Converts a random index to the index of the item that completes it's row.\n   * Allows for better order and fill computation when grid == true.\n   */\n  _convertIndexToCompleteRow: function (idx) {\n    // when grid == false _itemPerRow can be unset.\n    this._itemsPerRow = this._itemsPerRow || 1;\n    return this.grid ? Math.ceil(idx / this._itemsPerRow) * this._itemsPerRow : idx;\n  },\n  _isIndexRendered: function (idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n  _isIndexVisible: function (idx) {\n    return idx >= this.firstVisibleIndex && idx <= this.lastVisibleIndex;\n  },\n  _getPhysicalIndex: function (vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n  _clamp: function (v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n  _debounce: function (name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] = _debounce_js__WEBPACK_IMPORTED_MODULE_1__.Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__.enqueueDebouncer)(this._debouncers[name]);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvaXJvbi1saXN0LWNvcmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUtBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7OztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsNkJBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9pcm9uLWxpc3QtY29yZS5qcz81ZjQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0IHsgYW5pbWF0aW9uRnJhbWUsIGlkbGVQZXJpb2QsIG1pY3JvVGFzayB9IGZyb20gJy4vYXN5bmMuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyLCBlbnF1ZXVlRGVib3VuY2VyLCBmbHVzaCB9IGZyb20gJy4vZGVib3VuY2UuanMnO1xuXG5jb25zdCBJT1MgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUCg/OmhvbmV8YWQ7KD86IFU7KT8gQ1BVKSBPUyAoXFxkKykvKTtcbmNvbnN0IElPU19UT1VDSF9TQ1JPTExJTkcgPSBJT1MgJiYgSU9TWzFdID49IDg7XG5jb25zdCBERUZBVUxUX1BIWVNJQ0FMX0NPVU5UID0gMztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgaXJvbkxpc3QgPSB7XG4gIC8qKlxuICAgKiBUaGUgcmF0aW8gb2YgaGlkZGVuIHRpbGVzIHRoYXQgc2hvdWxkIHJlbWFpbiBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbi5cbiAgICogUmVjb21tZW5kZWQgdmFsdWUgfjAuNSwgc28gaXQgd2lsbCBkaXN0cmlidXRlIHRpbGVzIGV2ZW5seSBpbiBib3RoXG4gICAqIGRpcmVjdGlvbnMuXG4gICAqL1xuICBfcmF0aW86IDAuNSxcblxuICAvKipcbiAgICogVGhlIHBhZGRpbmctdG9wIHZhbHVlIGZvciB0aGUgbGlzdC5cbiAgICovXG4gIF9zY3JvbGxlclBhZGRpbmdUb3A6IDAsXG5cbiAgLyoqXG4gICAqIFRoaXMgdmFsdWUgaXMgYSBjYWNoZWQgdmFsdWUgb2YgYHNjcm9sbFRvcGAgZnJvbSB0aGUgbGFzdCBgc2Nyb2xsYCBldmVudC5cbiAgICovXG4gIF9zY3JvbGxQb3NpdGlvbjogMCxcblxuICAvKipcbiAgICogVGhlIHN1bSBvZiB0aGUgaGVpZ2h0cyBvZiBhbGwgdGhlIHRpbGVzIGluIHRoZSBET00uXG4gICAqL1xuICBfcGh5c2ljYWxTaXplOiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgYXZlcmFnZSBgb2Zmc2V0SGVpZ2h0YCBvZiB0aGUgdGlsZXMgb2JzZXJ2ZWQgdGlsbCBub3cuXG4gICAqL1xuICBfcGh5c2ljYWxBdmVyYWdlOiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHRpbGVzIHdoaWNoIGBvZmZzZXRIZWlnaHRgID4gMCBvYnNlcnZlZCB1bnRpbCBub3cuXG4gICAqL1xuICBfcGh5c2ljYWxBdmVyYWdlQ291bnQ6IDAsXG5cbiAgLyoqXG4gICAqIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHJlbmRlcmVkIGluIHRoZSBgX3BoeXNpY2FsU3RhcnRgXG4gICAqIHRpbGUgcmVsYXRpdmUgdG8gdGhlIHNjcm9sbGluZyBsaXN0LlxuICAgKi9cbiAgX3BoeXNpY2FsVG9wOiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0LlxuICAgKi9cbiAgX3ZpcnR1YWxDb3VudDogMCxcblxuICAvKipcbiAgICogVGhlIGVzdGltYXRlZCBzY3JvbGwgaGVpZ2h0IGJhc2VkIG9uIGBfcGh5c2ljYWxBdmVyYWdlYFxuICAgKi9cbiAgX2VzdFNjcm9sbEhlaWdodDogMCxcblxuICAvKipcbiAgICogVGhlIHNjcm9sbCBoZWlnaHQgb2YgdGhlIGRvbSBub2RlXG4gICAqL1xuICBfc2Nyb2xsSGVpZ2h0OiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBsaXN0LiBUaGlzIGlzIHJlZmVycmVkIGFzIHRoZSB2aWV3cG9ydCBpbiB0aGUgY29udGV4dCBvZlxuICAgKiBsaXN0LlxuICAgKi9cbiAgX3ZpZXdwb3J0SGVpZ2h0OiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIGxpc3QuIFRoaXMgaXMgcmVmZXJyZWQgYXMgdGhlIHZpZXdwb3J0IGluIHRoZSBjb250ZXh0IG9mXG4gICAqIGxpc3QuXG4gICAqL1xuICBfdmlld3BvcnRXaWR0aDogMCxcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgRE9NIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiB0aGUgdHJlZVxuICAgKiBAdHlwZSB7P0FycmF5PCFIVE1MRWxlbWVudD59XG4gICAqL1xuICBfcGh5c2ljYWxJdGVtczogbnVsbCxcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgaGVpZ2h0cyBmb3IgZWFjaCBpdGVtIGluIGBfcGh5c2ljYWxJdGVtc2BcbiAgICogQHR5cGUgez9BcnJheTxudW1iZXI+fVxuICAgKi9cbiAgX3BoeXNpY2FsU2l6ZXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEEgY2FjaGVkIHZhbHVlIGZvciB0aGUgZmlyc3QgdmlzaWJsZSBpbmRleC5cbiAgICogU2VlIGBmaXJzdFZpc2libGVJbmRleGBcbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqL1xuICBfZmlyc3RWaXNpYmxlSW5kZXhWYWw6IG51bGwsXG5cbiAgLyoqXG4gICAqIEEgY2FjaGVkIHZhbHVlIGZvciB0aGUgbGFzdCB2aXNpYmxlIGluZGV4LlxuICAgKiBTZWUgYGxhc3RWaXNpYmxlSW5kZXhgXG4gICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgKi9cbiAgX2xhc3RWaXNpYmxlSW5kZXhWYWw6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRoZSBtYXggbnVtYmVyIG9mIHBhZ2VzIHRvIHJlbmRlci4gT25lIHBhZ2UgaXMgZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mXG4gICAqIHRoZSBsaXN0LlxuICAgKi9cbiAgX21heFBhZ2VzOiAyLFxuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBpdGVtcyBwZXIgcm93XG4gICAqL1xuICBfaXRlbXNQZXJSb3c6IDEsXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgaXRlbVxuICAgKi9cbiAgX2l0ZW1XaWR0aDogMCxcblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgcm93IGluIGdyaWQgbGF5b3V0LlxuICAgKi9cbiAgX3Jvd0hlaWdodDogMCxcblxuICAvKipcbiAgICogVGhlIGNvc3Qgb2Ygc3RhbXBpbmcgYSB0ZW1wbGF0ZSBpbiBtcy5cbiAgICovXG4gIF90ZW1wbGF0ZUNvc3Q6IDAsXG5cbiAgLyoqXG4gICAqIE5lZWRlZCB0byBwYXNzIGV2ZW50Lm1vZGVsIHByb3BlcnR5IHRvIGRlY2xhcmF0aXZlIGV2ZW50IGhhbmRsZXJzIC1cbiAgICogc2VlIHBvbHltZXIvcG9seW1lciM0MzM5LlxuICAgKi9cbiAgX3BhcmVudE1vZGVsOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBUaGUgYm90dG9tIG9mIHRoZSBwaHlzaWNhbCBjb250ZW50LlxuICAgKi9cbiAgZ2V0IF9waHlzaWNhbEJvdHRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGh5c2ljYWxUb3AgKyB0aGlzLl9waHlzaWNhbFNpemU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBib3R0b20gb2YgdGhlIHNjcm9sbC5cbiAgICovXG4gIGdldCBfc2Nyb2xsQm90dG9tKCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdwb3J0SGVpZ2h0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgbi10aCBpdGVtIHJlbmRlcmVkIGluIHRoZSBsYXN0IHBoeXNpY2FsIGl0ZW0uXG4gICAqL1xuICBnZXQgX3ZpcnR1YWxFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxTdGFydCArIHRoaXMuX3BoeXNpY2FsQ291bnQgLSAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBwaHlzaWNhbCBjb250ZW50IHRoYXQgaXNuJ3Qgb24gdGhlIHNjcmVlbi5cbiAgICovXG4gIGdldCBfaGlkZGVuQ29udGVudFNpemUoKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmdyaWQgPyB0aGlzLl9waHlzaWNhbFJvd3MgKiB0aGlzLl9yb3dIZWlnaHQgOiB0aGlzLl9waHlzaWNhbFNpemU7XG4gICAgcmV0dXJuIHNpemUgLSB0aGlzLl92aWV3cG9ydEhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gc2Nyb2xsIHRvcCB2YWx1ZS5cbiAgICovXG4gIGdldCBfbWF4U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9lc3RTY3JvbGxIZWlnaHQgLSB0aGlzLl92aWV3cG9ydEhlaWdodCArIHRoaXMuX3Njcm9sbE9mZnNldDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGxhcmdlc3Qgbi10aCB2YWx1ZSBmb3IgYW4gaXRlbSBzdWNoIHRoYXQgaXQgY2FuIGJlIHJlbmRlcmVkIGluXG4gICAqIGBfcGh5c2ljYWxTdGFydGAuXG4gICAqL1xuICBnZXQgX21heFZpcnR1YWxTdGFydCgpIHtcbiAgICB2YXIgdmlydHVhbENvdW50ID0gdGhpcy5fY29udmVydEluZGV4VG9Db21wbGV0ZVJvdyh0aGlzLl92aXJ0dWFsQ291bnQpO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCB2aXJ0dWFsQ291bnQgLSB0aGlzLl9waHlzaWNhbENvdW50KTtcbiAgfSxcblxuICBzZXQgX3ZpcnR1YWxTdGFydCh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLl9jbGFtcCh2YWwsIDAsIHRoaXMuX21heFZpcnR1YWxTdGFydCk7XG4gICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgdmFsID0gdmFsIC0gKHZhbCAlIHRoaXMuX2l0ZW1zUGVyUm93KTtcbiAgICB9XG4gICAgdGhpcy5fdmlydHVhbFN0YXJ0VmFsID0gdmFsO1xuICB9LFxuXG4gIGdldCBfdmlydHVhbFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl92aXJ0dWFsU3RhcnRWYWwgfHwgMDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGstdGggdGlsZSB0aGF0IGlzIGF0IHRoZSB0b3Agb2YgdGhlIHNjcm9sbGluZyBsaXN0LlxuICAgKi9cbiAgc2V0IF9waHlzaWNhbFN0YXJ0KHZhbCkge1xuICAgIHZhbCA9IHZhbCAlIHRoaXMuX3BoeXNpY2FsQ291bnQ7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgIHZhbCA9IHRoaXMuX3BoeXNpY2FsQ291bnQgKyB2YWw7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgIHZhbCA9IHZhbCAtICh2YWwgJSB0aGlzLl9pdGVtc1BlclJvdyk7XG4gICAgfVxuICAgIHRoaXMuX3BoeXNpY2FsU3RhcnRWYWwgPSB2YWw7XG4gIH0sXG5cbiAgZ2V0IF9waHlzaWNhbFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9waHlzaWNhbFN0YXJ0VmFsIHx8IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBrLXRoIHRpbGUgdGhhdCBpcyBhdCB0aGUgYm90dG9tIG9mIHRoZSBzY3JvbGxpbmcgbGlzdC5cbiAgICovXG4gIGdldCBfcGh5c2ljYWxFbmQoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9waHlzaWNhbFN0YXJ0ICsgdGhpcy5fcGh5c2ljYWxDb3VudCAtIDEpICUgdGhpcy5fcGh5c2ljYWxDb3VudDtcbiAgfSxcblxuICBzZXQgX3BoeXNpY2FsQ291bnQodmFsKSB7XG4gICAgdGhpcy5fcGh5c2ljYWxDb3VudFZhbCA9IHZhbDtcbiAgfSxcblxuICBnZXQgX3BoeXNpY2FsQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsQ291bnRWYWwgfHwgMDtcbiAgfSxcblxuICAvKipcbiAgICogQW4gb3B0aW1hbCBwaHlzaWNhbCBzaXplIHN1Y2ggdGhhdCB3ZSB3aWxsIGhhdmUgZW5vdWdoIHBoeXNpY2FsIGl0ZW1zXG4gICAqIHRvIGZpbGwgdXAgdGhlIHZpZXdwb3J0IGFuZCByZWN5Y2xlIHdoZW4gdGhlIHVzZXIgc2Nyb2xscy5cbiAgICpcbiAgICogVGhpcyBkZWZhdWx0IHZhbHVlIGFzc3VtZXMgdGhhdCB3ZSB3aWxsIGF0IGxlYXN0IGhhdmUgdGhlIGVxdWl2YWxlbnRcbiAgICogdG8gYSB2aWV3cG9ydCBvZiBwaHlzaWNhbCBpdGVtcyBhYm92ZSBhbmQgYmVsb3cgdGhlIHVzZXIncyB2aWV3cG9ydC5cbiAgICovXG4gIGdldCBfb3B0UGh5c2ljYWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydEhlaWdodCA9PT0gMCA/IEluZmluaXR5IDogdGhpcy5fdmlld3BvcnRIZWlnaHQgKiB0aGlzLl9tYXhQYWdlcztcbiAgfSxcblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgY3VycmVudCBsaXN0IGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgX2lzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9mZnNldFdpZHRoIHx8IHRoaXMub2Zmc2V0SGVpZ2h0KTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHZpc2libGUgaXRlbSBpbiB0aGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZmlyc3RWaXNpYmxlSW5kZXgoKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2ZpcnN0VmlzaWJsZUluZGV4VmFsO1xuICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgdmFyIHBoeXNpY2FsT2Zmc2V0ID0gdGhpcy5fcGh5c2ljYWxUb3AgKyB0aGlzLl9zY3JvbGxPZmZzZXQ7XG5cbiAgICAgIGlkeCA9XG4gICAgICAgIHRoaXMuX2l0ZXJhdGVJdGVtcyhmdW5jdGlvbiAocGlkeCwgdmlkeCkge1xuICAgICAgICAgIHBoeXNpY2FsT2Zmc2V0ICs9IHRoaXMuX2dldFBoeXNpY2FsU2l6ZUluY3JlbWVudChwaWR4KTtcblxuICAgICAgICAgIGlmIChwaHlzaWNhbE9mZnNldCA+IHRoaXMuX3Njcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkID8gdmlkeCAtICh2aWR4ICUgdGhpcy5faXRlbXNQZXJSb3cpIDogdmlkeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSGFuZGxlIGEgcGFydGlhbGx5IHJlbmRlcmVkIGZpbmFsIHJvdyBpbiBncmlkIG1vZGVcbiAgICAgICAgICBpZiAodGhpcy5ncmlkICYmIHRoaXMuX3ZpcnR1YWxDb3VudCAtIDEgPT09IHZpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWR4IC0gKHZpZHggJSB0aGlzLl9pdGVtc1BlclJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSB8fCAwO1xuICAgICAgdGhpcy5fZmlyc3RWaXNpYmxlSW5kZXhWYWwgPSBpZHg7XG4gICAgfVxuICAgIHJldHVybiBpZHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHZpc2libGUgaXRlbSBpbiB0aGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbGFzdFZpc2libGVJbmRleCgpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fbGFzdFZpc2libGVJbmRleFZhbDtcbiAgICBpZiAoaWR4ID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgICAgaWR4ID0gTWF0aC5taW4odGhpcy5fdmlydHVhbENvdW50LCB0aGlzLmZpcnN0VmlzaWJsZUluZGV4ICsgdGhpcy5fZXN0Um93c0luVmlldyAqIHRoaXMuX2l0ZW1zUGVyUm93IC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGh5c2ljYWxPZmZzZXQgPSB0aGlzLl9waHlzaWNhbFRvcCArIHRoaXMuX3Njcm9sbE9mZnNldDtcbiAgICAgICAgdGhpcy5faXRlcmF0ZUl0ZW1zKGZ1bmN0aW9uIChwaWR4LCB2aWR4KSB7XG4gICAgICAgICAgaWYgKHBoeXNpY2FsT2Zmc2V0IDwgdGhpcy5fc2Nyb2xsQm90dG9tKSB7XG4gICAgICAgICAgICBpZHggPSB2aWR4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwaHlzaWNhbE9mZnNldCArPSB0aGlzLl9nZXRQaHlzaWNhbFNpemVJbmNyZW1lbnQocGlkeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFzdFZpc2libGVJbmRleFZhbCA9IGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfSxcblxuICBnZXQgX2RlZmF1bHRTY3JvbGxUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZ2V0IF92aXJ0dWFsUm93Q291bnQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLl92aXJ0dWFsQ291bnQgLyB0aGlzLl9pdGVtc1BlclJvdyk7XG4gIH0sXG5cbiAgZ2V0IF9lc3RSb3dzSW5WaWV3KCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5fdmlld3BvcnRIZWlnaHQgLyB0aGlzLl9yb3dIZWlnaHQpO1xuICB9LFxuXG4gIGdldCBfcGh5c2ljYWxSb3dzKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5fcGh5c2ljYWxDb3VudCAvIHRoaXMuX2l0ZW1zUGVyUm93KTtcbiAgfSxcblxuICBnZXQgX3Njcm9sbE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsZXJQYWRkaW5nVG9wICsgdGhpcy5zY3JvbGxPZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY3ljbGVzIHRoZSBwaHlzaWNhbCBpdGVtcyB3aGVuIG5lZWRlZC5cbiAgICovXG4gIF9zY3JvbGxIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX21heFNjcm9sbFRvcCwgdGhpcy5fc2Nyb2xsVG9wKSk7XG4gICAgdmFyIGRlbHRhID0gc2Nyb2xsVG9wIC0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgdmFyIGlzU2Nyb2xsaW5nRG93biA9IGRlbHRhID49IDA7XG4gICAgLy8gVHJhY2sgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLlxuICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gc2Nyb2xsVG9wO1xuICAgIC8vIENsZWFyIGluZGV4ZXMgZm9yIGZpcnN0IGFuZCBsYXN0IHZpc2libGUgaW5kZXhlcy5cbiAgICB0aGlzLl9maXJzdFZpc2libGVJbmRleFZhbCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFZpc2libGVJbmRleFZhbCA9IG51bGw7XG4gICAgLy8gUmFuZG9tIGFjY2Vzcy5cbiAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gdGhpcy5fcGh5c2ljYWxTaXplICYmIHRoaXMuX3BoeXNpY2FsU2l6ZSA+IDApIHtcbiAgICAgIGRlbHRhID0gZGVsdGEgLSB0aGlzLl9zY3JvbGxPZmZzZXQ7XG4gICAgICB2YXIgaWR4QWRqdXN0bWVudCA9IE1hdGgucm91bmQoZGVsdGEgLyB0aGlzLl9waHlzaWNhbEF2ZXJhZ2UpICogdGhpcy5faXRlbXNQZXJSb3c7XG4gICAgICB0aGlzLl92aXJ0dWFsU3RhcnQgPSB0aGlzLl92aXJ0dWFsU3RhcnQgKyBpZHhBZGp1c3RtZW50O1xuICAgICAgdGhpcy5fcGh5c2ljYWxTdGFydCA9IHRoaXMuX3BoeXNpY2FsU3RhcnQgKyBpZHhBZGp1c3RtZW50O1xuICAgICAgLy8gRXN0aW1hdGUgbmV3IHBoeXNpY2FsIG9mZnNldCBiYXNlZCBvbiB0aGUgdmlydHVhbCBzdGFydCBpbmRleC5cbiAgICAgIC8vIGFkanVzdHMgdGhlIHBoeXNpY2FsIHN0YXJ0IHBvc2l0aW9uIHRvIHN0YXkgaW4gc3luYyB3aXRoIHRoZSBjbGFtcGVkXG4gICAgICAvLyB2aXJ0dWFsIHN0YXJ0IGluZGV4LiBJdCdzIGNyaXRpY2FsIG5vdCB0byBsZXQgdGhpcyB2YWx1ZSBiZVxuICAgICAgLy8gbW9yZSB0aGFuIHRoZSBzY3JvbGwgcG9zaXRpb24gaG93ZXZlciwgc2luY2UgdGhhdCB3b3VsZCByZXN1bHQgaW5cbiAgICAgIC8vIHRoZSBwaHlzaWNhbCBpdGVtcyBub3QgY292ZXJpbmcgdGhlIHZpZXdwb3J0LCBhbmQgbGVhZGluZyB0b1xuICAgICAgLy8gX2luY3JlYXNlUG9vbElmTmVlZGVkIHRvIHJ1biBhd2F5IGNyZWF0aW5nIGl0ZW1zIHRvIHRyeSB0byBmaWxsIGl0LlxuICAgICAgdGhpcy5fcGh5c2ljYWxUb3AgPSBNYXRoLm1pbihcbiAgICAgICAgTWF0aC5mbG9vcih0aGlzLl92aXJ0dWFsU3RhcnQgLyB0aGlzLl9pdGVtc1BlclJvdykgKiB0aGlzLl9waHlzaWNhbEF2ZXJhZ2UsXG4gICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uLFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGh5c2ljYWxDb3VudCA+IDApIHtcbiAgICAgIHZhciByZXVzYWJsZXMgPSB0aGlzLl9nZXRSZXVzYWJsZXMoaXNTY3JvbGxpbmdEb3duKTtcbiAgICAgIGlmIChpc1Njcm9sbGluZ0Rvd24pIHtcbiAgICAgICAgdGhpcy5fcGh5c2ljYWxUb3AgPSByZXVzYWJsZXMucGh5c2ljYWxUb3A7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxTdGFydCA9IHRoaXMuX3ZpcnR1YWxTdGFydCArIHJldXNhYmxlcy5pbmRleGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fcGh5c2ljYWxTdGFydCA9IHRoaXMuX3BoeXNpY2FsU3RhcnQgKyByZXVzYWJsZXMuaW5kZXhlcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl92aXJ0dWFsU3RhcnQgPSB0aGlzLl92aXJ0dWFsU3RhcnQgLSByZXVzYWJsZXMuaW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsU3RhcnQgPSB0aGlzLl9waHlzaWNhbFN0YXJ0IC0gcmV1c2FibGVzLmluZGV4ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlKHJldXNhYmxlcy5pbmRleGVzLCBpc1Njcm9sbGluZ0Rvd24gPyBudWxsIDogcmV1c2FibGVzLmluZGV4ZXMpO1xuICAgICAgdGhpcy5fZGVib3VuY2UoJ19pbmNyZWFzZVBvb2xJZk5lZWRlZCcsIHRoaXMuX2luY3JlYXNlUG9vbElmTmVlZGVkLmJpbmQodGhpcywgMCksIG1pY3JvVGFzayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBpbmRleGVzIG9mIHRoZSBwaHlzaWNhbCBpdGVtc1xuICAgKiB0aGF0IG1pZ2h0IGJlIHJldXNlZCBhbmQgdGhlIHBoeXNpY2FsVG9wLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZyb21Ub3AgSWYgdGhlIHBvdGVudGlhbCByZXVzYWJsZSBpdGVtcyBhcmUgYWJvdmUgdGhlIHNjcm9sbGluZyByZWdpb24uXG4gICAqL1xuICBfZ2V0UmV1c2FibGVzOiBmdW5jdGlvbiAoZnJvbVRvcCkge1xuICAgIHZhciBpdGgsIGxhc3RJdGgsIG9mZnNldENvbnRlbnQsIHBoeXNpY2FsSXRlbUhlaWdodDtcbiAgICB2YXIgaWR4cyA9IFtdO1xuICAgIHZhciBwcm90ZWN0ZWRPZmZzZXRDb250ZW50ID0gdGhpcy5faGlkZGVuQ29udGVudFNpemUgKiB0aGlzLl9yYXRpbztcbiAgICB2YXIgdmlydHVhbFN0YXJ0ID0gdGhpcy5fdmlydHVhbFN0YXJ0O1xuICAgIHZhciB2aXJ0dWFsRW5kID0gdGhpcy5fdmlydHVhbEVuZDtcbiAgICB2YXIgcGh5c2ljYWxDb3VudCA9IHRoaXMuX3BoeXNpY2FsQ291bnQ7XG4gICAgdmFyIHRvcCA9IHRoaXMuX3BoeXNpY2FsVG9wICsgdGhpcy5fc2Nyb2xsT2Zmc2V0O1xuICAgIHZhciBib3R0b20gPSB0aGlzLl9waHlzaWNhbEJvdHRvbSArIHRoaXMuX3Njcm9sbE9mZnNldDtcbiAgICAvLyBUaGlzIG1heSBiZSBjYWxsZWQgb3V0c2lkZSBvZiBhIHNjcm9sbEhhbmRsZXIsIHNvIHVzZSBsYXN0IGNhY2hlZCBwb3NpdGlvblxuICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbjtcbiAgICB2YXIgc2Nyb2xsQm90dG9tID0gdGhpcy5fc2Nyb2xsQm90dG9tO1xuXG4gICAgaWYgKGZyb21Ub3ApIHtcbiAgICAgIGl0aCA9IHRoaXMuX3BoeXNpY2FsU3RhcnQ7XG4gICAgICBsYXN0SXRoID0gdGhpcy5fcGh5c2ljYWxFbmQ7XG4gICAgICBvZmZzZXRDb250ZW50ID0gc2Nyb2xsVG9wIC0gdG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGggPSB0aGlzLl9waHlzaWNhbEVuZDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIGxhc3RJdGggPSB0aGlzLl9waHlzaWNhbFN0YXJ0O1xuICAgICAgb2Zmc2V0Q29udGVudCA9IGJvdHRvbSAtIHNjcm9sbEJvdHRvbTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBwaHlzaWNhbEl0ZW1IZWlnaHQgPSB0aGlzLl9nZXRQaHlzaWNhbFNpemVJbmNyZW1lbnQoaXRoKTtcbiAgICAgIG9mZnNldENvbnRlbnQgPSBvZmZzZXRDb250ZW50IC0gcGh5c2ljYWxJdGVtSGVpZ2h0O1xuICAgICAgaWYgKGlkeHMubGVuZ3RoID49IHBoeXNpY2FsQ291bnQgfHwgb2Zmc2V0Q29udGVudCA8PSBwcm90ZWN0ZWRPZmZzZXRDb250ZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGZyb21Ub3ApIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBpbmRleCBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgICBpZiAodmlydHVhbEVuZCArIGlkeHMubGVuZ3RoICsgMSA+PSB0aGlzLl92aXJ0dWFsQ291bnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBpbmRleCBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKHRvcCArIHBoeXNpY2FsSXRlbUhlaWdodCA+PSBzY3JvbGxUb3AgLSB0aGlzLl9zY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZHhzLnB1c2goaXRoKTtcbiAgICAgICAgdG9wID0gdG9wICsgcGh5c2ljYWxJdGVtSGVpZ2h0O1xuICAgICAgICBpdGggPSAoaXRoICsgMSkgJSBwaHlzaWNhbENvdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBpbmRleCBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgICBpZiAodmlydHVhbFN0YXJ0IC0gaWR4cy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGluZGV4IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICBpZiAodG9wICsgdGhpcy5fcGh5c2ljYWxTaXplIC0gcGh5c2ljYWxJdGVtSGVpZ2h0IDw9IHNjcm9sbEJvdHRvbSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlkeHMucHVzaChpdGgpO1xuICAgICAgICB0b3AgPSB0b3AgLSBwaHlzaWNhbEl0ZW1IZWlnaHQ7XG4gICAgICAgIGl0aCA9IGl0aCA9PT0gMCA/IHBoeXNpY2FsQ291bnQgLSAxIDogaXRoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaW5kZXhlczogaWR4cywgcGh5c2ljYWxUb3A6IHRvcCAtIHRoaXMuX3Njcm9sbE9mZnNldCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2YgaXRlbXMsIHN0YXJ0aW5nIGZyb20gdGhlIGBfdmlydHVhbFN0YXJ0YCBpdGVtLlxuICAgKiBAcGFyYW0geyFBcnJheTxudW1iZXI+PX0gaXRlbVNldFxuICAgKiBAcGFyYW0geyFBcnJheTxudW1iZXI+PX0gbW92aW5nVXBcbiAgICovXG4gIF91cGRhdGU6IGZ1bmN0aW9uIChpdGVtU2V0LCBtb3ZpbmdVcCkge1xuICAgIGlmICgoaXRlbVNldCAmJiBpdGVtU2V0Lmxlbmd0aCA9PT0gMCkgfHwgdGhpcy5fcGh5c2ljYWxDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tYW5hZ2VGb2N1cygpO1xuICAgIHRoaXMuX2Fzc2lnbk1vZGVscyhpdGVtU2V0KTtcbiAgICB0aGlzLl91cGRhdGVNZXRyaWNzKGl0ZW1TZXQpO1xuICAgIC8vIEFkanVzdCBvZmZzZXQgYWZ0ZXIgbWVhc3VyaW5nLlxuICAgIGlmIChtb3ZpbmdVcCkge1xuICAgICAgd2hpbGUgKG1vdmluZ1VwLmxlbmd0aCkge1xuICAgICAgICB2YXIgaWR4ID0gbW92aW5nVXAucG9wKCk7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsVG9wIC09IHRoaXMuX2dldFBoeXNpY2FsU2l6ZUluY3JlbWVudChpZHgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wb3NpdGlvbkl0ZW1zKCk7XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsZXJTaXplKCk7XG4gIH0sXG5cbiAgX2lzQ2xpZW50RnVsbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9zY3JvbGxCb3R0b20gIT0gMCAmJlxuICAgICAgdGhpcy5fcGh5c2ljYWxCb3R0b20gLSAxID49IHRoaXMuX3Njcm9sbEJvdHRvbSAmJlxuICAgICAgdGhpcy5fcGh5c2ljYWxUb3AgPD0gdGhpcy5fc2Nyb2xsUG9zaXRpb25cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmNyZWFzZXMgdGhlIHBvb2wgc2l6ZS5cbiAgICovXG4gIF9pbmNyZWFzZVBvb2xJZk5lZWRlZDogZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG5leHRQaHlzaWNhbENvdW50ID0gdGhpcy5fY2xhbXAoXG4gICAgICB0aGlzLl9waHlzaWNhbENvdW50ICsgY291bnQsXG4gICAgICBERUZBVUxUX1BIWVNJQ0FMX0NPVU5ULFxuICAgICAgdGhpcy5fdmlydHVhbENvdW50IC0gdGhpcy5fdmlydHVhbFN0YXJ0LFxuICAgICk7XG4gICAgbmV4dFBoeXNpY2FsQ291bnQgPSB0aGlzLl9jb252ZXJ0SW5kZXhUb0NvbXBsZXRlUm93KG5leHRQaHlzaWNhbENvdW50KTtcbiAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICB2YXIgY29ycmVjdGlvbiA9IG5leHRQaHlzaWNhbENvdW50ICUgdGhpcy5faXRlbXNQZXJSb3c7XG4gICAgICBpZiAoY29ycmVjdGlvbiAmJiBuZXh0UGh5c2ljYWxDb3VudCAtIGNvcnJlY3Rpb24gPD0gdGhpcy5fcGh5c2ljYWxDb3VudCkge1xuICAgICAgICBuZXh0UGh5c2ljYWxDb3VudCArPSB0aGlzLl9pdGVtc1BlclJvdztcbiAgICAgIH1cbiAgICAgIG5leHRQaHlzaWNhbENvdW50IC09IGNvcnJlY3Rpb247XG4gICAgfVxuICAgIHZhciBkZWx0YSA9IG5leHRQaHlzaWNhbENvdW50IC0gdGhpcy5fcGh5c2ljYWxDb3VudDtcbiAgICB2YXIgbmV4dEluY3JlYXNlID0gTWF0aC5yb3VuZCh0aGlzLl9waHlzaWNhbENvdW50ICogMC41KTtcblxuICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgdmFyIHRzID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgLy8gQ29uY2F0IGFycmF5cyBpbiBwbGFjZS5cbiAgICAgIFtdLnB1c2guYXBwbHkodGhpcy5fcGh5c2ljYWxJdGVtcywgdGhpcy5fY3JlYXRlUG9vbChkZWx0YSkpO1xuICAgICAgLy8gUHVzaCAwcyBpbnRvIHBoeXNpY2FsU2l6ZXMuIENhbid0IHVzZSBBcnJheS5maWxsIGJlY2F1c2UgSUUxMSBkb2Vzbid0XG4gICAgICAvLyBzdXBwb3J0IGl0LlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YTsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsU2l6ZXMucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BoeXNpY2FsQ291bnQgPSB0aGlzLl9waHlzaWNhbENvdW50ICsgZGVsdGE7XG4gICAgICAvLyBVcGRhdGUgdGhlIHBoeXNpY2FsIHN0YXJ0IGlmIGl0IG5lZWRzIHRvIHByZXNlcnZlIHRoZSBtb2RlbCBvZiB0aGVcbiAgICAgIC8vIGZvY3VzZWQgaXRlbS4gSW4gdGhpcyBzaXR1YXRpb24sIHRoZSBmb2N1c2VkIGl0ZW0gaXMgY3VycmVudGx5IHJlbmRlcmVkXG4gICAgICAvLyBhbmQgaXRzIG1vZGVsIHdvdWxkIGhhdmUgY2hhbmdlZCBhZnRlciBpbmNyZWFzaW5nIHRoZSBwb29sIGlmIHRoZVxuICAgICAgLy8gcGh5c2ljYWwgc3RhcnQgcmVtYWluZWQgdW5jaGFuZ2VkLlxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9waHlzaWNhbFN0YXJ0ID4gdGhpcy5fcGh5c2ljYWxFbmQgJiZcbiAgICAgICAgdGhpcy5faXNJbmRleFJlbmRlcmVkKHRoaXMuX2ZvY3VzZWRWaXJ0dWFsSW5kZXgpICYmXG4gICAgICAgIHRoaXMuX2dldFBoeXNpY2FsSW5kZXgodGhpcy5fZm9jdXNlZFZpcnR1YWxJbmRleCkgPCB0aGlzLl9waHlzaWNhbEVuZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsU3RhcnQgPSB0aGlzLl9waHlzaWNhbFN0YXJ0ICsgZGVsdGE7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3RlbXBsYXRlQ29zdCA9ICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSB0cykgLyBkZWx0YTtcbiAgICAgIG5leHRJbmNyZWFzZSA9IE1hdGgucm91bmQodGhpcy5fcGh5c2ljYWxDb3VudCAqIDAuNSk7XG4gICAgfVxuICAgIC8vIFRoZSB1cHBlciBib3VuZHMgaXMgbm90IGZpeGVkIHdoZW4gZGVhbGluZyB3aXRoIGEgZ3JpZCB0aGF0IGRvZXNuJ3RcbiAgICAvLyBmaWxsIGl0J3MgbGFzdCByb3cgd2l0aCB0aGUgZXhhY3QgbnVtYmVyIG9mIGl0ZW1zIHBlciByb3cuXG4gICAgaWYgKHRoaXMuX3ZpcnR1YWxFbmQgPj0gdGhpcy5fdmlydHVhbENvdW50IC0gMSB8fCBuZXh0SW5jcmVhc2UgPT09IDApIHtcbiAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNDbGllbnRGdWxsKCkpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlKCdfaW5jcmVhc2VQb29sSWZOZWVkZWQnLCB0aGlzLl9pbmNyZWFzZVBvb2xJZk5lZWRlZC5iaW5kKHRoaXMsIG5leHRJbmNyZWFzZSksIG1pY3JvVGFzayk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9waHlzaWNhbFNpemUgPCB0aGlzLl9vcHRQaHlzaWNhbFNpemUpIHtcbiAgICAgIC8vIFlpZWxkIGFuZCBpbmNyZWFzZSB0aGUgcG9vbCBkdXJpbmcgaWRsZSB0aW1lIHVudGlsIHRoZSBwaHlzaWNhbCBzaXplIGlzXG4gICAgICAvLyBvcHRpbWFsLlxuICAgICAgdGhpcy5fZGVib3VuY2UoXG4gICAgICAgICdfaW5jcmVhc2VQb29sSWZOZWVkZWQnLFxuICAgICAgICB0aGlzLl9pbmNyZWFzZVBvb2xJZk5lZWRlZC5iaW5kKHRoaXMsIHRoaXMuX2NsYW1wKE1hdGgucm91bmQoNTAgLyB0aGlzLl90ZW1wbGF0ZUNvc3QpLCAxLCBuZXh0SW5jcmVhc2UpKSxcbiAgICAgICAgaWRsZVBlcmlvZCxcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBhIG5ldyBsaXN0LlxuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkIHx8ICF0aGlzLl9pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BoeXNpY2FsQ291bnQgIT09IDApIHtcbiAgICAgIHZhciByZXVzYWJsZXMgPSB0aGlzLl9nZXRSZXVzYWJsZXModHJ1ZSk7XG4gICAgICB0aGlzLl9waHlzaWNhbFRvcCA9IHJldXNhYmxlcy5waHlzaWNhbFRvcDtcbiAgICAgIHRoaXMuX3ZpcnR1YWxTdGFydCA9IHRoaXMuX3ZpcnR1YWxTdGFydCArIHJldXNhYmxlcy5pbmRleGVzLmxlbmd0aDtcbiAgICAgIHRoaXMuX3BoeXNpY2FsU3RhcnQgPSB0aGlzLl9waHlzaWNhbFN0YXJ0ICsgcmV1c2FibGVzLmluZGV4ZXMubGVuZ3RoO1xuICAgICAgdGhpcy5fdXBkYXRlKHJldXNhYmxlcy5pbmRleGVzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5faW5jcmVhc2VQb29sSWZOZWVkZWQoMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl92aXJ0dWFsQ291bnQgPiAwKSB7XG4gICAgICAvLyBJbml0aWFsIHJlbmRlclxuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuX2luY3JlYXNlUG9vbElmTmVlZGVkKERFRkFVTFRfUEhZU0lDQUxfQ09VTlQpO1xuICAgIH1cbiAgfSxcblxuICBfZ3JpZENoYW5nZWQ6IGZ1bmN0aW9uIChuZXdHcmlkLCBvbGRHcmlkKSB7XG4gICAgaWYgKHR5cGVvZiBvbGRHcmlkID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIHRoaXMubm90aWZ5UmVzaXplKCk7XG4gICAgZmx1c2goKTtcbiAgICBuZXdHcmlkICYmIHRoaXMuX3VwZGF0ZUdyaWRNZXRyaWNzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBpdGVtcyBoYXZlIGNoYW5nZWQuIFRoYXQgaXMsIHJlYXNzaWdubWVudHNcbiAgICogdG8gYGl0ZW1zYCwgc3BsaWNlcyBvciB1cGRhdGVzIHRvIGEgc2luZ2xlIGl0ZW0uXG4gICAqL1xuICBfaXRlbXNDaGFuZ2VkOiBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS5wYXRoID09PSAnaXRlbXMnKSB7XG4gICAgICB0aGlzLl92aXJ0dWFsU3RhcnQgPSAwO1xuICAgICAgdGhpcy5fcGh5c2ljYWxUb3AgPSAwO1xuICAgICAgdGhpcy5fdmlydHVhbENvdW50ID0gdGhpcy5pdGVtcyA/IHRoaXMuaXRlbXMubGVuZ3RoIDogMDtcbiAgICAgIHRoaXMuX3BoeXNpY2FsSW5kZXhGb3JLZXkgPSB7fTtcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZUluZGV4VmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2xhc3RWaXNpYmxlSW5kZXhWYWwgPSBudWxsO1xuICAgICAgdGhpcy5fcGh5c2ljYWxDb3VudCA9IHRoaXMuX3BoeXNpY2FsQ291bnQgfHwgMDtcbiAgICAgIHRoaXMuX3BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zIHx8IFtdO1xuICAgICAgdGhpcy5fcGh5c2ljYWxTaXplcyA9IHRoaXMuX3BoeXNpY2FsU2l6ZXMgfHwgW107XG4gICAgICB0aGlzLl9waHlzaWNhbFN0YXJ0ID0gMDtcbiAgICAgIGlmICh0aGlzLl9zY3JvbGxUb3AgPiB0aGlzLl9zY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRTY3JvbGxQb3NpdGlvbigwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbW92ZUZvY3VzZWRJdGVtKCk7XG4gICAgICB0aGlzLl9kZWJvdW5jZSgnX3JlbmRlcicsIHRoaXMuX3JlbmRlciwgYW5pbWF0aW9uRnJhbWUpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnBhdGggPT09ICdpdGVtcy5zcGxpY2VzJykge1xuICAgICAgdGhpcy5fYWRqdXN0VmlydHVhbEluZGV4KGNoYW5nZS52YWx1ZS5pbmRleFNwbGljZXMpO1xuICAgICAgdGhpcy5fdmlydHVhbENvdW50ID0gdGhpcy5pdGVtcyA/IHRoaXMuaXRlbXMubGVuZ3RoIDogMDtcbiAgICAgIC8vIE9ubHkgYmx1ciBpZiBhdCBsZWFzdCBvbmUgaXRlbSBpcyBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgdmFyIGl0ZW1BZGRlZE9yUmVtb3ZlZCA9IGNoYW5nZS52YWx1ZS5pbmRleFNwbGljZXMuc29tZShmdW5jdGlvbiAoc3BsaWNlKSB7XG4gICAgICAgIHJldHVybiBzcGxpY2UuYWRkZWRDb3VudCA+IDAgfHwgc3BsaWNlLnJlbW92ZWQubGVuZ3RoID4gMDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGl0ZW1BZGRlZE9yUmVtb3ZlZCkge1xuICAgICAgICAvLyBPbmx5IGJsdXIgYWN0aXZlRWxlbWVudCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIGxpc3QgKCM1MDUsXG4gICAgICAgIC8vICM1MDcpLlxuICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVuZGVyIG9ubHkgaWYgdGhlIGFmZmVjdGVkIGluZGV4IGlzIHJlbmRlcmVkLlxuICAgICAgdmFyIGFmZmVjdGVkSW5kZXhSZW5kZXJlZCA9IGNoYW5nZS52YWx1ZS5pbmRleFNwbGljZXMuc29tZShmdW5jdGlvbiAoc3BsaWNlKSB7XG4gICAgICAgIHJldHVybiBzcGxpY2UuaW5kZXggKyBzcGxpY2UuYWRkZWRDb3VudCA+PSB0aGlzLl92aXJ0dWFsU3RhcnQgJiYgc3BsaWNlLmluZGV4IDw9IHRoaXMuX3ZpcnR1YWxFbmQ7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIGlmICghdGhpcy5faXNDbGllbnRGdWxsKCkgfHwgYWZmZWN0ZWRJbmRleFJlbmRlcmVkKSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlKCdfcmVuZGVyJywgdGhpcy5fcmVuZGVyLCBhbmltYXRpb25GcmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UucGF0aCAhPT0gJ2l0ZW1zLmxlbmd0aCcpIHtcbiAgICAgIHRoaXMuX2ZvcndhcmRJdGVtUGF0aChjaGFuZ2UucGF0aCwgY2hhbmdlLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gcGVyIGV2ZXJ5IHBoeXNpY2FsIGluZGV4IGluIGBpdGVtU2V0YFxuICAgKiBgaXRlbVNldGAgZGVmYXVsdCB2YWx1ZSBpcyBlcXVpdmFsZW50IHRvIHRoZSBlbnRpcmUgc2V0IG9mIHBoeXNpY2FsXG4gICAqIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlciwgbnVtYmVyKX0gZm5cbiAgICogQHBhcmFtIHshQXJyYXk8bnVtYmVyPj19IGl0ZW1TZXRcbiAgICovXG4gIF9pdGVyYXRlSXRlbXM6IGZ1bmN0aW9uIChmbiwgaXRlbVNldCkge1xuICAgIHZhciBwaWR4LCB2aWR4LCBydG4sIGk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiBpdGVtU2V0KSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwaWR4ID0gaXRlbVNldFtpXTtcbiAgICAgICAgdmlkeCA9IHRoaXMuX2NvbXB1dGVWaWR4KHBpZHgpO1xuICAgICAgICBpZiAoKHJ0biA9IGZuLmNhbGwodGhpcywgcGlkeCwgdmlkeCkpICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcnRuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpZHggPSB0aGlzLl9waHlzaWNhbFN0YXJ0O1xuICAgICAgdmlkeCA9IHRoaXMuX3ZpcnR1YWxTdGFydDtcbiAgICAgIGZvciAoOyBwaWR4IDwgdGhpcy5fcGh5c2ljYWxDb3VudDsgcGlkeCsrLCB2aWR4KyspIHtcbiAgICAgICAgaWYgKChydG4gPSBmbi5jYWxsKHRoaXMsIHBpZHgsIHZpZHgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJ0bjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChwaWR4ID0gMDsgcGlkeCA8IHRoaXMuX3BoeXNpY2FsU3RhcnQ7IHBpZHgrKywgdmlkeCsrKSB7XG4gICAgICAgIGlmICgocnRuID0gZm4uY2FsbCh0aGlzLCBwaWR4LCB2aWR4KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBydG47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpcnR1YWwgaW5kZXggZm9yIGEgZ2l2ZW4gcGh5c2ljYWwgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpZHggUGh5c2ljYWwgaW5kZXhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgX2NvbXB1dGVWaWR4OiBmdW5jdGlvbiAocGlkeCkge1xuICAgIGlmIChwaWR4ID49IHRoaXMuX3BoeXNpY2FsU3RhcnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXJ0dWFsU3RhcnQgKyAocGlkeCAtIHRoaXMuX3BoeXNpY2FsU3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmlydHVhbFN0YXJ0ICsgKHRoaXMuX3BoeXNpY2FsQ291bnQgLSB0aGlzLl9waHlzaWNhbFN0YXJ0KSArIHBpZHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGhlaWdodCBmb3IgYSBnaXZlbiBzZXQgb2YgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7IUFycmF5PG51bWJlcj49fSBpdGVtU2V0XG4gICAqL1xuICBfdXBkYXRlTWV0cmljczogZnVuY3Rpb24gKGl0ZW1TZXQpIHtcbiAgICAvLyBNYWtlIHN1cmUgd2UgZGlzdHJpYnV0ZWQgYWxsIHRoZSBwaHlzaWNhbCBpdGVtc1xuICAgIC8vIHNvIHdlIGNhbiBtZWFzdXJlIHRoZW0uXG4gICAgZmx1c2goKTtcblxuICAgIHZhciBuZXdQaHlzaWNhbFNpemUgPSAwO1xuICAgIHZhciBvbGRQaHlzaWNhbFNpemUgPSAwO1xuICAgIHZhciBwcmV2QXZnQ291bnQgPSB0aGlzLl9waHlzaWNhbEF2ZXJhZ2VDb3VudDtcbiAgICB2YXIgcHJldlBoeXNpY2FsQXZnID0gdGhpcy5fcGh5c2ljYWxBdmVyYWdlO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHRoaXMuX2l0ZXJhdGVJdGVtcyhmdW5jdGlvbiAocGlkeCwgdmlkeCkge1xuICAgICAgb2xkUGh5c2ljYWxTaXplICs9IHRoaXMuX3BoeXNpY2FsU2l6ZXNbcGlkeF07XG4gICAgICB0aGlzLl9waHlzaWNhbFNpemVzW3BpZHhdID0gdGhpcy5fcGh5c2ljYWxJdGVtc1twaWR4XS5vZmZzZXRIZWlnaHQ7XG4gICAgICBuZXdQaHlzaWNhbFNpemUgKz0gdGhpcy5fcGh5c2ljYWxTaXplc1twaWR4XTtcbiAgICAgIHRoaXMuX3BoeXNpY2FsQXZlcmFnZUNvdW50ICs9IHRoaXMuX3BoeXNpY2FsU2l6ZXNbcGlkeF0gPyAxIDogMDtcbiAgICB9LCBpdGVtU2V0KTtcblxuICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUdyaWRNZXRyaWNzKCk7XG4gICAgICB0aGlzLl9waHlzaWNhbFNpemUgPSBNYXRoLmNlaWwodGhpcy5fcGh5c2ljYWxDb3VudCAvIHRoaXMuX2l0ZW1zUGVyUm93KSAqIHRoaXMuX3Jvd0hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGh5c2ljYWxTaXplID1cbiAgICAgICAgdGhpcy5faXRlbXNQZXJSb3cgPT09IDFcbiAgICAgICAgICA/IG9sZFBoeXNpY2FsU2l6ZVxuICAgICAgICAgIDogTWF0aC5jZWlsKHRoaXMuX3BoeXNpY2FsQ291bnQgLyB0aGlzLl9pdGVtc1BlclJvdykgKiB0aGlzLl9yb3dIZWlnaHQ7XG4gICAgICB0aGlzLl9waHlzaWNhbFNpemUgPSB0aGlzLl9waHlzaWNhbFNpemUgKyBuZXdQaHlzaWNhbFNpemUgLSBvbGRQaHlzaWNhbFNpemU7XG4gICAgICB0aGlzLl9pdGVtc1BlclJvdyA9IDE7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB0aGUgYXZlcmFnZSBpZiBpdCBtZWFzdXJlZCBzb21ldGhpbmcuXG4gICAgaWYgKHRoaXMuX3BoeXNpY2FsQXZlcmFnZUNvdW50ICE9PSBwcmV2QXZnQ291bnQpIHtcbiAgICAgIHRoaXMuX3BoeXNpY2FsQXZlcmFnZSA9IE1hdGgucm91bmQoXG4gICAgICAgIChwcmV2UGh5c2ljYWxBdmcgKiBwcmV2QXZnQ291bnQgKyBuZXdQaHlzaWNhbFNpemUpIC8gdGhpcy5fcGh5c2ljYWxBdmVyYWdlQ291bnQsXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICBfdXBkYXRlR3JpZE1ldHJpY3M6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pdGVtV2lkdGggPSB0aGlzLl9waHlzaWNhbENvdW50ID4gMCA/IHRoaXMuX3BoeXNpY2FsSXRlbXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggOiAyMDA7XG4gICAgdGhpcy5fcm93SGVpZ2h0ID0gdGhpcy5fcGh5c2ljYWxDb3VudCA+IDAgPyB0aGlzLl9waHlzaWNhbEl0ZW1zWzBdLm9mZnNldEhlaWdodCA6IDIwMDtcbiAgICB0aGlzLl9pdGVtc1BlclJvdyA9IHRoaXMuX2l0ZW1XaWR0aCA/IE1hdGguZmxvb3IodGhpcy5fdmlld3BvcnRXaWR0aCAvIHRoaXMuX2l0ZW1XaWR0aCkgOiB0aGlzLl9pdGVtc1BlclJvdztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBoeXNpY2FsIGl0ZW1zLlxuICAgKi9cbiAgX3Bvc2l0aW9uSXRlbXM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9hZGp1c3RTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgdmFyIHkgPSB0aGlzLl9waHlzaWNhbFRvcDtcblxuICAgIGlmICh0aGlzLmdyaWQpIHtcbiAgICAgIHZhciB0b3RhbEl0ZW1XaWR0aCA9IHRoaXMuX2l0ZW1zUGVyUm93ICogdGhpcy5faXRlbVdpZHRoO1xuICAgICAgdmFyIHJvd09mZnNldCA9ICh0aGlzLl92aWV3cG9ydFdpZHRoIC0gdG90YWxJdGVtV2lkdGgpIC8gMjtcblxuICAgICAgdGhpcy5faXRlcmF0ZUl0ZW1zKGZ1bmN0aW9uIChwaWR4LCB2aWR4KSB7XG4gICAgICAgIHZhciBtb2R1bHVzID0gdmlkeCAlIHRoaXMuX2l0ZW1zUGVyUm93O1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IobW9kdWx1cyAqIHRoaXMuX2l0ZW1XaWR0aCArIHJvd09mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1JUTCkge1xuICAgICAgICAgIHggPSB4ICogLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2xhdGUzZCh4ICsgJ3B4JywgeSArICdweCcsIDAsIHRoaXMuX3BoeXNpY2FsSXRlbXNbcGlkeF0pO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkUmVuZGVyTmV4dFJvdyh2aWR4KSkge1xuICAgICAgICAgIHkgKz0gdGhpcy5fcm93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JkZXIgPSBbXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIHRoaXMuX2l0ZXJhdGVJdGVtcyhmdW5jdGlvbiAocGlkeCwgdmlkeCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcGh5c2ljYWxJdGVtc1twaWR4XTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGUzZCgwLCB5ICsgJ3B4JywgMCwgaXRlbSk7XG4gICAgICAgIHkgKz0gdGhpcy5fcGh5c2ljYWxTaXplc1twaWR4XTtcbiAgICAgICAgY29uc3QgaXRlbUlkID0gaXRlbS5pZDtcbiAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgIG9yZGVyLnB1c2goaXRlbUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAob3JkZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLW93bnMnLCBvcmRlci5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfZ2V0UGh5c2ljYWxTaXplSW5jcmVtZW50OiBmdW5jdGlvbiAocGlkeCkge1xuICAgIGlmICghdGhpcy5ncmlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGh5c2ljYWxTaXplc1twaWR4XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbXB1dGVWaWR4KHBpZHgpICUgdGhpcy5faXRlbXNQZXJSb3cgIT09IHRoaXMuX2l0ZW1zUGVyUm93IC0gMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb3dIZWlnaHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMsIGJhc2VkIG9uIHRoZSBjdXJyZW50IGluZGV4LFxuICAgKiB3aGV0aGVyIG9yIG5vdCB0aGUgbmV4dCBpbmRleCB3aWxsIG5lZWRcbiAgICogdG8gYmUgcmVuZGVyZWQgb24gYSBuZXcgcm93LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlkeCBWaXJ0dWFsIGluZGV4XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBfc2hvdWxkUmVuZGVyTmV4dFJvdzogZnVuY3Rpb24gKHZpZHgpIHtcbiAgICByZXR1cm4gdmlkeCAlIHRoaXMuX2l0ZW1zUGVyUm93ID09PSB0aGlzLl9pdGVtc1BlclJvdyAtIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkanVzdHMgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IHdhcyBvdmVyZXN0aW1hdGVkLlxuICAgKi9cbiAgX2FkanVzdFNjcm9sbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlbHRhSGVpZ2h0ID1cbiAgICAgIHRoaXMuX3ZpcnR1YWxTdGFydCA9PT0gMCA/IHRoaXMuX3BoeXNpY2FsVG9wIDogTWF0aC5taW4odGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl9waHlzaWNhbFRvcCwgMCk7XG4gICAgLy8gTm90ZTogdGhlIGRlbHRhIGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS5cbiAgICBpZiAoZGVsdGFIZWlnaHQgIT09IDApIHtcbiAgICAgIHRoaXMuX3BoeXNpY2FsVG9wID0gdGhpcy5fcGh5c2ljYWxUb3AgLSBkZWx0YUhlaWdodDtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGNhbGxlZCBvdXRzaWRlIG9mIGEgc2Nyb2xsSGFuZGxlciwgc28gdXNlIGxhc3QgY2FjaGVkIHBvc2l0aW9uXG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgICAvLyBqdWtpbmcgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBpbnRlcmlhbCBzY3JvbGxpbmcgb24gaU9TIGlzIG5vIGJ1ZW5vXG4gICAgICBpZiAoIUlPU19UT1VDSF9TQ1JPTExJTkcgJiYgc2Nyb2xsVG9wID4gMCkge1xuICAgICAgICB0aGlzLl9yZXNldFNjcm9sbFBvc2l0aW9uKHNjcm9sbFRvcCAtIGRlbHRhSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwuXG4gICAqL1xuICBfcmVzZXRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldCAmJiBwb3MgPj0gMCkge1xuICAgICAgdGhpcy5fc2Nyb2xsVG9wID0gcG9zO1xuICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9zY3JvbGxUb3A7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY3JvbGwgaGVpZ2h0LCB0aGF0J3MgdGhlIGhlaWdodCBvZiB0aGUgY29udGVudCxcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VVcGRhdGUgSWYgdHJ1ZSwgdXBkYXRlcyB0aGUgaGVpZ2h0IG5vIG1hdHRlciB3aGF0LlxuICAgKi9cbiAgX3VwZGF0ZVNjcm9sbGVyU2l6ZTogZnVuY3Rpb24gKGZvcmNlVXBkYXRlKSB7XG4gICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgdGhpcy5fZXN0U2Nyb2xsSGVpZ2h0ID0gdGhpcy5fdmlydHVhbFJvd0NvdW50ICogdGhpcy5fcm93SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lc3RTY3JvbGxIZWlnaHQgPVxuICAgICAgICB0aGlzLl9waHlzaWNhbEJvdHRvbSArXG4gICAgICAgIE1hdGgubWF4KHRoaXMuX3ZpcnR1YWxDb3VudCAtIHRoaXMuX3BoeXNpY2FsQ291bnQgLSB0aGlzLl92aXJ0dWFsU3RhcnQsIDApICogdGhpcy5fcGh5c2ljYWxBdmVyYWdlO1xuICAgIH1cbiAgICBmb3JjZVVwZGF0ZSA9IGZvcmNlVXBkYXRlIHx8IHRoaXMuX3Njcm9sbEhlaWdodCA9PT0gMDtcbiAgICBmb3JjZVVwZGF0ZSA9IGZvcmNlVXBkYXRlIHx8IHRoaXMuX3Njcm9sbFBvc2l0aW9uID49IHRoaXMuX2VzdFNjcm9sbEhlaWdodCAtIHRoaXMuX3BoeXNpY2FsU2l6ZTtcbiAgICBmb3JjZVVwZGF0ZSA9IGZvcmNlVXBkYXRlIHx8ICh0aGlzLmdyaWQgJiYgdGhpcy4kLml0ZW1zLnN0eWxlLmhlaWdodCA8IHRoaXMuX2VzdFNjcm9sbEhlaWdodCk7XG4gICAgLy8gQW1vcnRpemUgaGVpZ2h0IGFkanVzdG1lbnQsIHNvIGl0IHdvbid0IHRyaWdnZXIgbGFyZ2UgcmVwYWludHMgdG9vIG9mdGVuLlxuICAgIGlmIChmb3JjZVVwZGF0ZSB8fCBNYXRoLmFicyh0aGlzLl9lc3RTY3JvbGxIZWlnaHQgLSB0aGlzLl9zY3JvbGxIZWlnaHQpID49IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgICB0aGlzLiQuaXRlbXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZXN0U2Nyb2xsSGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2VzdFNjcm9sbEhlaWdodDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNjcm9sbCB0byBhIHNwZWNpZmljIGluZGV4IGluIHRoZSB2aXJ0dWFsIGxpc3QgcmVnYXJkbGVzc1xuICAgKiBvZiB0aGUgcGh5c2ljYWwgaXRlbXMgaW4gdGhlIERPTSB0cmVlLlxuICAgKlxuICAgKiBAbWV0aG9kIHNjcm9sbFRvSW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBUaGUgaW5kZXggb2YgdGhlIGl0ZW1cbiAgICovXG4gIHNjcm9sbFRvSW5kZXg6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicgfHwgaWR4IDwgMCB8fCBpZHggPiB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmx1c2goKTtcbiAgICAvLyBJdGVtcyBzaG91bGQgaGF2ZSBiZWVuIHJlbmRlcmVkIHByaW9yIHNjcm9sbGluZyB0byBhbiBpbmRleC5cbiAgICBpZiAodGhpcy5fcGh5c2ljYWxDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZHggPSB0aGlzLl9jbGFtcChpZHgsIDAsIHRoaXMuX3ZpcnR1YWxDb3VudCAtIDEpO1xuICAgIC8vIFVwZGF0ZSB0aGUgdmlydHVhbCBzdGFydCBvbmx5IHdoZW4gbmVlZGVkLlxuICAgIGlmICghdGhpcy5faXNJbmRleFJlbmRlcmVkKGlkeCkgfHwgaWR4ID49IHRoaXMuX21heFZpcnR1YWxTdGFydCkge1xuICAgICAgdGhpcy5fdmlydHVhbFN0YXJ0ID0gdGhpcy5ncmlkID8gaWR4IC0gdGhpcy5faXRlbXNQZXJSb3cgKiAyIDogaWR4IC0gMTtcbiAgICB9XG4gICAgdGhpcy5fbWFuYWdlRm9jdXMoKTtcbiAgICB0aGlzLl9hc3NpZ25Nb2RlbHMoKTtcbiAgICB0aGlzLl91cGRhdGVNZXRyaWNzKCk7XG4gICAgLy8gRXN0aW1hdGUgbmV3IHBoeXNpY2FsIG9mZnNldC5cbiAgICB0aGlzLl9waHlzaWNhbFRvcCA9IE1hdGguZmxvb3IodGhpcy5fdmlydHVhbFN0YXJ0IC8gdGhpcy5faXRlbXNQZXJSb3cpICogdGhpcy5fcGh5c2ljYWxBdmVyYWdlO1xuXG4gICAgdmFyIGN1cnJlbnRUb3BJdGVtID0gdGhpcy5fcGh5c2ljYWxTdGFydDtcbiAgICB2YXIgY3VycmVudFZpcnR1YWxJdGVtID0gdGhpcy5fdmlydHVhbFN0YXJ0O1xuICAgIHZhciB0YXJnZXRPZmZzZXRUb3AgPSAwO1xuICAgIHZhciBoaWRkZW5Db250ZW50U2l6ZSA9IHRoaXMuX2hpZGRlbkNvbnRlbnRTaXplO1xuICAgIC8vIHNjcm9sbCB0byB0aGUgaXRlbSBhcyBtdWNoIGFzIHdlIGNhbi5cbiAgICB3aGlsZSAoY3VycmVudFZpcnR1YWxJdGVtIDwgaWR4ICYmIHRhcmdldE9mZnNldFRvcCA8PSBoaWRkZW5Db250ZW50U2l6ZSkge1xuICAgICAgdGFyZ2V0T2Zmc2V0VG9wID0gdGFyZ2V0T2Zmc2V0VG9wICsgdGhpcy5fZ2V0UGh5c2ljYWxTaXplSW5jcmVtZW50KGN1cnJlbnRUb3BJdGVtKTtcbiAgICAgIGN1cnJlbnRUb3BJdGVtID0gKGN1cnJlbnRUb3BJdGVtICsgMSkgJSB0aGlzLl9waHlzaWNhbENvdW50O1xuICAgICAgY3VycmVudFZpcnR1YWxJdGVtKys7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVNjcm9sbGVyU2l6ZSh0cnVlKTtcbiAgICB0aGlzLl9wb3NpdGlvbkl0ZW1zKCk7XG4gICAgdGhpcy5fcmVzZXRTY3JvbGxQb3NpdGlvbih0aGlzLl9waHlzaWNhbFRvcCArIHRoaXMuX3Njcm9sbE9mZnNldCArIHRhcmdldE9mZnNldFRvcCk7XG4gICAgdGhpcy5faW5jcmVhc2VQb29sSWZOZWVkZWQoMCk7XG4gICAgLy8gY2xlYXIgY2FjaGVkIHZpc2libGUgaW5kZXguXG4gICAgdGhpcy5fZmlyc3RWaXNpYmxlSW5kZXhWYWwgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RWaXNpYmxlSW5kZXhWYWwgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcGh5c2ljYWwgYXZlcmFnZSBhbmQgdGhlIGF2ZXJhZ2UgY291bnQuXG4gICAqL1xuICBfcmVzZXRBdmVyYWdlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGh5c2ljYWxBdmVyYWdlID0gMDtcbiAgICB0aGlzLl9waHlzaWNhbEF2ZXJhZ2VDb3VudCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEEgaGFuZGxlciBmb3IgdGhlIGBpcm9uLXJlc2l6ZWAgZXZlbnQgdHJpZ2dlcmVkIGJ5IGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgXG4gICAqIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVzaXplZC5cbiAgICovXG4gIF9yZXNpemVIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZGVib3VuY2UoXG4gICAgICAnX3JlbmRlcicsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNsZWFyIGNhY2hlZCB2aXNpYmxlIGluZGV4LlxuICAgICAgICB0aGlzLl9maXJzdFZpc2libGVJbmRleFZhbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RWaXNpYmxlSW5kZXhWYWwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5faXNWaXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgICAgICAvLyBSZWluc3RhbGwgdGhlIHNjcm9sbCBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICB0aGlzLnRvZ2dsZVNjcm9sbExpc3RlbmVyKHRydWUpO1xuICAgICAgICAgIHRoaXMuX3Jlc2V0QXZlcmFnZSgpO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVuaW5zdGFsbCB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgIHRoaXMudG9nZ2xlU2Nyb2xsTGlzdGVuZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYW5pbWF0aW9uRnJhbWUsXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBhIGdpdmVuIGxpc3QgaXRlbS5cbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVTaXplRm9ySXRlbVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgaXRlbSBpbnN0YW5jZS5cbiAgICovXG4gIHVwZGF0ZVNpemVGb3JJdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVNpemVGb3JJbmRleCh0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzaXplIG9mIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgaXRlbXMgYXJyYXkuXG4gICAqXG4gICAqIEBtZXRob2QgdXBkYXRlU2l6ZUZvckluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gaW4gdGhlIGl0ZW1zIGFycmF5LlxuICAgKi9cbiAgdXBkYXRlU2l6ZUZvckluZGV4OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2lzSW5kZXhSZW5kZXJlZChpbmRleCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVNZXRyaWNzKFt0aGlzLl9nZXRQaHlzaWNhbEluZGV4KGluZGV4KV0pO1xuICAgIHRoaXMuX3Bvc2l0aW9uSXRlbXMoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSByYW5kb20gaW5kZXggdG8gdGhlIGluZGV4IG9mIHRoZSBpdGVtIHRoYXQgY29tcGxldGVzIGl0J3Mgcm93LlxuICAgKiBBbGxvd3MgZm9yIGJldHRlciBvcmRlciBhbmQgZmlsbCBjb21wdXRhdGlvbiB3aGVuIGdyaWQgPT0gdHJ1ZS5cbiAgICovXG4gIF9jb252ZXJ0SW5kZXhUb0NvbXBsZXRlUm93OiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgLy8gd2hlbiBncmlkID09IGZhbHNlIF9pdGVtUGVyUm93IGNhbiBiZSB1bnNldC5cbiAgICB0aGlzLl9pdGVtc1BlclJvdyA9IHRoaXMuX2l0ZW1zUGVyUm93IHx8IDE7XG4gICAgcmV0dXJuIHRoaXMuZ3JpZCA/IE1hdGguY2VpbChpZHggLyB0aGlzLl9pdGVtc1BlclJvdykgKiB0aGlzLl9pdGVtc1BlclJvdyA6IGlkeDtcbiAgfSxcblxuICBfaXNJbmRleFJlbmRlcmVkOiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA+PSB0aGlzLl92aXJ0dWFsU3RhcnQgJiYgaWR4IDw9IHRoaXMuX3ZpcnR1YWxFbmQ7XG4gIH0sXG5cbiAgX2lzSW5kZXhWaXNpYmxlOiBmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA+PSB0aGlzLmZpcnN0VmlzaWJsZUluZGV4ICYmIGlkeCA8PSB0aGlzLmxhc3RWaXNpYmxlSW5kZXg7XG4gIH0sXG5cbiAgX2dldFBoeXNpY2FsSW5kZXg6IGZ1bmN0aW9uICh2aWR4KSB7XG4gICAgcmV0dXJuICh0aGlzLl9waHlzaWNhbFN0YXJ0ICsgKHZpZHggLSB0aGlzLl92aXJ0dWFsU3RhcnQpKSAlIHRoaXMuX3BoeXNpY2FsQ291bnQ7XG4gIH0sXG5cbiAgX2NsYW1wOiBmdW5jdGlvbiAodiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHYpKTtcbiAgfSxcblxuICBfZGVib3VuY2U6IGZ1bmN0aW9uIChuYW1lLCBjYiwgYXN5bmNNb2R1bGUpIHtcbiAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICB0aGlzLl9kZWJvdW5jZXJzW25hbWVdID0gRGVib3VuY2VyLmRlYm91bmNlKHRoaXMuX2RlYm91bmNlcnNbbmFtZV0sIGFzeW5jTW9kdWxlLCBjYi5iaW5kKHRoaXMpKTtcbiAgICBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX2RlYm91bmNlcnNbbmFtZV0pO1xuICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/iron-list-core.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/keyboard-mixin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/keyboard-mixin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyboardMixin\": () => (/* binding */ KeyboardMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * A mixin that manages keyboard handling.\n * The mixin subscribes to the keyboard events while an actual implementation\n * for the event handlers is left to the client (a component or another mixin).\n *\n * @polymerMixin\n */\n\nconst KeyboardMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superclass => class KeyboardMixinClass extends superclass {\n  /** @protected */\n  ready() {\n    super.ready();\n    this.addEventListener('keydown', event => {\n      this._onKeyDown(event);\n    });\n    this.addEventListener('keyup', event => {\n      this._onKeyUp(event);\n    });\n  }\n  /**\n   * A handler for the `keydown` event. By default, it does nothing.\n   * Override the method to implement your own behavior.\n   *\n   * @param {KeyboardEvent} _event\n   * @protected\n   */\n\n\n  _onKeyDown(_event) {// To be implemented.\n  }\n  /**\n   * A handler for the `keyup` event. By default, it does nothing.\n   * Override the method to implement your own behavior.\n   *\n   * @param {KeyboardEvent} _event\n   * @protected\n   */\n\n\n  _onKeyUp(_event) {// To be implemented.\n  }\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMva2V5Ym9hcmQtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFFQTs7QUFsQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2tleWJvYXJkLW1peGluLmpzPzMwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanMnO1xuXG4vKipcbiAqIEEgbWl4aW4gdGhhdCBtYW5hZ2VzIGtleWJvYXJkIGhhbmRsaW5nLlxuICogVGhlIG1peGluIHN1YnNjcmliZXMgdG8gdGhlIGtleWJvYXJkIGV2ZW50cyB3aGlsZSBhbiBhY3R1YWwgaW1wbGVtZW50YXRpb25cbiAqIGZvciB0aGUgZXZlbnQgaGFuZGxlcnMgaXMgbGVmdCB0byB0aGUgY2xpZW50IChhIGNvbXBvbmVudCBvciBhbm90aGVyIG1peGluKS5cbiAqXG4gKiBAcG9seW1lck1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBLZXlib2FyZE1peGluID0gZGVkdXBpbmdNaXhpbihcbiAgKHN1cGVyY2xhc3MpID0+XG4gICAgY2xhc3MgS2V5Ym9hcmRNaXhpbkNsYXNzIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG4gICAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgICAgcmVhZHkoKSB7XG4gICAgICAgIHN1cGVyLnJlYWR5KCk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldmVudCkgPT4ge1xuICAgICAgICAgIHRoaXMuX29uS2V5VXAoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBIGhhbmRsZXIgZm9yIHRoZSBga2V5ZG93bmAgZXZlbnQuIEJ5IGRlZmF1bHQsIGl0IGRvZXMgbm90aGluZy5cbiAgICAgICAqIE92ZXJyaWRlIHRoZSBtZXRob2QgdG8gaW1wbGVtZW50IHlvdXIgb3duIGJlaGF2aW9yLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gX2V2ZW50XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9vbktleURvd24oX2V2ZW50KSB7XG4gICAgICAgIC8vIFRvIGJlIGltcGxlbWVudGVkLlxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEEgaGFuZGxlciBmb3IgdGhlIGBrZXl1cGAgZXZlbnQuIEJ5IGRlZmF1bHQsIGl0IGRvZXMgbm90aGluZy5cbiAgICAgICAqIE92ZXJyaWRlIHRoZSBtZXRob2QgdG8gaW1wbGVtZW50IHlvdXIgb3duIGJlaGF2aW9yLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gX2V2ZW50XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9vbktleVVwKF9ldmVudCkge1xuICAgICAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZC5cbiAgICAgIH1cbiAgICB9LFxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/keyboard-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/templates.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/templates.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"processTemplates\": () => (/* binding */ processTemplates)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Passes the component to the template renderer callback if the template renderer is imported.\n * Otherwise, if there is a template, it warns that the template renderer needs to be imported.\n *\n * @param {HTMLElement} component\n */\nfunction processTemplates(component) {\n  if (window.Vaadin && window.Vaadin.templateRendererCallback) {\n    window.Vaadin.templateRendererCallback(component);\n    return;\n  }\n\n  if (component.querySelector('template')) {\n    console.warn(`WARNING: <template> inside <${component.localName}> is no longer supported. Import @vaadin/polymer-legacy-adapter/template-renderer.js to enable compatibility.`);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdGVtcGxhdGVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL3RlbXBsYXRlcy5qcz84ZTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuXG4vKipcbiAqIFBhc3NlcyB0aGUgY29tcG9uZW50IHRvIHRoZSB0ZW1wbGF0ZSByZW5kZXJlciBjYWxsYmFjayBpZiB0aGUgdGVtcGxhdGUgcmVuZGVyZXIgaXMgaW1wb3J0ZWQuXG4gKiBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIGEgdGVtcGxhdGUsIGl0IHdhcm5zIHRoYXQgdGhlIHRlbXBsYXRlIHJlbmRlcmVyIG5lZWRzIHRvIGJlIGltcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbXBvbmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1RlbXBsYXRlcyhjb21wb25lbnQpIHtcbiAgaWYgKHdpbmRvdy5WYWFkaW4gJiYgd2luZG93LlZhYWRpbi50ZW1wbGF0ZVJlbmRlcmVyQ2FsbGJhY2spIHtcbiAgICB3aW5kb3cuVmFhZGluLnRlbXBsYXRlUmVuZGVyZXJDYWxsYmFjayhjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb21wb25lbnQucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBXQVJOSU5HOiA8dGVtcGxhdGU+IGluc2lkZSA8JHtjb21wb25lbnQubG9jYWxOYW1lfT4gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gSW1wb3J0IEB2YWFkaW4vcG9seW1lci1sZWdhY3ktYWRhcHRlci90ZW1wbGF0ZS1yZW5kZXJlci5qcyB0byBlbmFibGUgY29tcGF0aWJpbGl0eS5gLFxuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/templates.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IronListAdapter\": () => (/* binding */ IronListAdapter)\n/* harmony export */ });\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async.js */ \"./node_modules/@vaadin/component-base/src/async.js\");\n/* harmony import */ var _browser_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browser-utils.js */ \"./node_modules/@vaadin/component-base/src/browser-utils.js\");\n/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debounce.js */ \"./node_modules/@vaadin/component-base/src/debounce.js\");\n/* harmony import */ var _iron_list_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./iron-list-core.js */ \"./node_modules/@vaadin/component-base/src/iron-list-core.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n // iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\n\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\nclass IronListAdapter {\n  constructor({\n    createElements,\n    updateElement,\n    scrollTarget,\n    scrollContainer,\n    elementsContainer,\n    reorderElements\n  }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements; // Iron-list uses this value to determine how many pages of elements to render\n\n    this._maxPages = 1.3;\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500\n    };\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n\n    this.__resizeObserver.observe(this.scrollTarget);\n\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', e => this.__onWheel(e));\n\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => this.__mouseDown = true);\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n\n  _manageFocus() {}\n\n  _removeFocusedItem() {}\n\n  get scrollOffset() {\n    return 0;\n  }\n\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n\n    index = this._clamp(index, 0, this.size - 1);\n\n    const visibleElementCount = this.__getVisibleElements().length;\n\n    let targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);\n\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n\n    this._scrollHandler();\n  }\n\n  flush() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._resizeHandler();\n\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)();\n\n    this._scrollHandler();\n\n    this.__scrollReorderDebouncer && this.__scrollReorderDebouncer.flush();\n    this.__debouncerWheelAnimationFrame && this.__debouncerWheelAnimationFrame.flush();\n  }\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__getVisibleElements().forEach(el => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n      }\n    });\n  }\n\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary min height\n    if (el.style.minHeight) {\n      el.style.minHeight = '';\n    }\n\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n\n    if (el.offsetHeight === 0) {\n      // If the elements have 0 height after update (for example due to lazy rendering),\n      // it results in iron-list requesting to create an unlimited count of elements.\n      // Assign a temporary min height to elements that would otherwise end up having\n      // no height.\n      el.style.minHeight = '200px';\n    }\n  }\n\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find(el => el.__virtualIndex === index);\n\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n\n  set size(size) {\n    if (size === this.size) {\n      return;\n    } // Prevent element update while the scroll position is being restored\n\n\n    this.__preventElementUpdates = true; // Record the scroll position before changing the size\n\n    let fvi; // first visible index\n\n    let fviOffsetBefore; // scroll offset of the first visible index\n\n    if (size > 0) {\n      fvi = this.adjustedFirstVisibleIndex;\n      fviOffsetBefore = this.__getIndexScrollOffset(fvi);\n    } // Change the size\n\n\n    this.__size = size; // Flush before invoking items change to avoid\n    // creating excess elements on the following flush()\n\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)();\n\n    this._itemsChanged({\n      path: 'items'\n    });\n\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)(); // Try to restore the scroll position if the new size is larger than 0\n\n    if (size > 0) {\n      fvi = Math.min(fvi, size - 1);\n      this.scrollToIndex(fvi);\n\n      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);\n\n      if (fviOffsetBefore !== undefined && fviOffsetAfter !== undefined) {\n        this._scrollTop += fviOffsetBefore - fviOffsetAfter;\n      }\n    }\n\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    this.__preventElementUpdates = false; // Schedule and flush a resize handler\n\n    this._resizeHandler();\n\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)();\n  }\n\n  get size() {\n    return this.__size;\n  }\n  /** @private */\n\n\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n  /** @private */\n\n\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n  /** @private */\n\n\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT)\n    };\n  }\n  /** @private */\n\n\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n  /** @private */\n\n\n  get $() {\n    return {\n      items: this.scrollContainer\n    };\n  }\n  /** @private */\n\n\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    this.grid && this._updateGridMetrics();\n  }\n  /** @private */\n\n\n  setAttribute() {}\n  /** @private */\n\n\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach(el => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n  /** @private */\n\n\n  _assignModels(itemSet) {\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n\n        this.__updateElement(el, el.__virtualIndex);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n  }\n  /** @private */\n\n\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => this.__clientFull = true);\n    return this.__clientFull || super._isClientFull();\n  }\n  /** @private */\n\n\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n  /** @private */\n\n\n  toggleScrollListener() {}\n\n  _scrollHandler() {\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n\n    super._scrollHandler();\n\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = _debounce_js__WEBPACK_IMPORTED_MODULE_2__.Debouncer.debounce(this.__scrollReorderDebouncer, _async_js__WEBPACK_IMPORTED_MODULE_0__.timeOut.after(this.timeouts.SCROLL_REORDER), () => this.__reorderElements());\n    }\n\n    this.__previousScrollTop = this._scrollTop;\n  }\n  /** @private */\n\n\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n\n    let deltaY = e.deltaY;\n\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n\n    this._deltaYAcc = this._deltaYAcc || 0;\n\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = _debounce_js__WEBPACK_IMPORTED_MODULE_2__.Debouncer.debounce(this.__debouncerWheelAnimationFrame, _async_js__WEBPACK_IMPORTED_MODULE_0__.animationFrame, () => this._wheelAnimationFrame = false);\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n      this._hasResidualMomentum = true;\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = _debounce_js__WEBPACK_IMPORTED_MODULE_2__.Debouncer.debounce(this._debouncerIgnoreNewWheel, _async_js__WEBPACK_IMPORTED_MODULE_0__.timeOut.after(this.timeouts.IGNORE_WHEEL), () => this._ignoreNewWheel = false);\n    } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n\n    this._previousMomentum = momentum;\n  }\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n\n\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n\n  _canScroll(el, deltaX, deltaY) {\n    return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;\n  }\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n\n\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter(element => !element.hidden);\n  }\n  /** @private */\n\n\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n\n    this.__pendingReorder = false;\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0); // Which row to use as a target?\n\n    const visibleElements = this.__getVisibleElements();\n\n    const elementWithFocus = visibleElements.find(element => element.contains(this.elementsContainer.getRootNode().activeElement) || element.contains(this.scrollTarget.getRootNode().activeElement));\n    const targetElement = elementWithFocus || visibleElements[0];\n\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    } // Where the target row should be?\n\n\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart; // Reodrer the DOM elements to keep the target row at the target physical index\n\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    } // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n\n\n    if (_browser_utils_js__WEBPACK_IMPORTED_MODULE_1__.isSafari) {\n      const {\n        transform\n      } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => this.scrollTarget.style.transform = transform);\n    }\n  }\n  /** @private */\n\n\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n      return;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100; // Near start\n\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      } // Near end\n\n\n      const maxOffset = this.size - this._virtualCount;\n\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n\n}\nObject.setPrototypeOf(IronListAdapter.prototype, _iron_list_core_js__WEBPACK_IMPORTED_MODULE_3__.ironList);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdmlydHVhbGl6ZXItaXJvbi1saXN0LWFkYXB0ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFHQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFHQTs7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBR0E7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQUdBOztBQUVBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBeGVBO0FBMmVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy92aXJ0dWFsaXplci1pcm9uLWxpc3QtYWRhcHRlci5qcz9kYjdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgYW5pbWF0aW9uRnJhbWUsIHRpbWVPdXQgfSBmcm9tICcuL2FzeW5jLmpzJztcbmltcG9ydCB7IGlzU2FmYXJpIH0gZnJvbSAnLi9icm93c2VyLXV0aWxzLmpzJztcbmltcG9ydCB7IERlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuL2RlYm91bmNlLmpzJztcbmltcG9ydCB7IGlyb25MaXN0IH0gZnJvbSAnLi9pcm9uLWxpc3QtY29yZS5qcyc7XG5cbi8vIGlyb24tbGlzdCBjYW4gYnkgZGVmYXVsdCBoYW5kbGUgc2l6ZXMgdXAgdG8gYXJvdW5kIDEwMDAwMC5cbi8vIFdoZW4gdGhlIHNpemUgaXMgbGFyZ2VyIHRoYW4gTUFYX1ZJUlRVQUxfQ09VTlQgX3ZpZHhPZmZzZXQgaXMgdXNlZFxuY29uc3QgTUFYX1ZJUlRVQUxfQ09VTlQgPSAxMDAwMDA7XG5jb25zdCBPRkZTRVRfQURKVVNUX01JTl9USFJFU0hPTEQgPSAxMDAwO1xuXG5leHBvcnQgY2xhc3MgSXJvbkxpc3RBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoeyBjcmVhdGVFbGVtZW50cywgdXBkYXRlRWxlbWVudCwgc2Nyb2xsVGFyZ2V0LCBzY3JvbGxDb250YWluZXIsIGVsZW1lbnRzQ29udGFpbmVyLCByZW9yZGVyRWxlbWVudHMgfSkge1xuICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy5fdmlkeE9mZnNldCA9IDA7XG4gICAgdGhpcy5jcmVhdGVFbGVtZW50cyA9IGNyZWF0ZUVsZW1lbnRzO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudCA9IHVwZGF0ZUVsZW1lbnQ7XG4gICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSBzY3JvbGxDb250YWluZXI7XG4gICAgdGhpcy5lbGVtZW50c0NvbnRhaW5lciA9IGVsZW1lbnRzQ29udGFpbmVyIHx8IHNjcm9sbENvbnRhaW5lcjtcbiAgICB0aGlzLnJlb3JkZXJFbGVtZW50cyA9IHJlb3JkZXJFbGVtZW50cztcbiAgICAvLyBJcm9uLWxpc3QgdXNlcyB0aGlzIHZhbHVlIHRvIGRldGVybWluZSBob3cgbWFueSBwYWdlcyBvZiBlbGVtZW50cyB0byByZW5kZXJcbiAgICB0aGlzLl9tYXhQYWdlcyA9IDEuMztcblxuICAgIHRoaXMudGltZW91dHMgPSB7XG4gICAgICBTQ1JPTExfUkVPUkRFUjogNTAwLFxuICAgICAgSUdOT1JFX1dIRUVMOiA1MDAsXG4gICAgfTtcblxuICAgIHRoaXMuX19yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLl9yZXNpemVIYW5kbGVyKCkpO1xuXG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxUYXJnZXQpLm92ZXJmbG93ID09PSAndmlzaWJsZScpIHtcbiAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMuc2Nyb2xsQ29udGFpbmVyKS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG5cbiAgICB0aGlzLl9fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnNjcm9sbFRhcmdldCk7XG4gICAgdGhpcy5zY3JvbGxUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4gdGhpcy5fc2Nyb2xsSGFuZGxlcigpKTtcblxuICAgIHRoaXMuX3Njcm9sbExpbmVIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxMaW5lSGVpZ2h0KCk7XG4gICAgdGhpcy5zY3JvbGxUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZSkgPT4gdGhpcy5fX29uV2hlZWwoZSkpO1xuXG4gICAgaWYgKHRoaXMucmVvcmRlckVsZW1lbnRzKSB7XG4gICAgICAvLyBSZW9yZGVyaW5nIHRoZSBwaHlzaWNhbCBlbGVtZW50cyBjYW5jZWxzIHRoZSB1c2VyJ3MgZ3JhYiBvZiB0aGUgc2Nyb2xsIGJhciBoYW5kbGUgb24gU2FmYXJpLlxuICAgICAgLy8gTmVlZCB0byBkZWZlciByZW9yZGVyaW5nIHVudGlsIHRoZSB1c2VyIGxldHMgZ28gb2YgdGhlIHNjcm9sbCBiYXIgaGFuZGxlLlxuICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4gKHRoaXMuX19tb3VzZURvd24gPSB0cnVlKSk7XG4gICAgICB0aGlzLnNjcm9sbFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9fbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9fcGVuZGluZ1Jlb3JkZXIpIHtcbiAgICAgICAgICB0aGlzLl9fcmVvcmRlckVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9tYW5hZ2VGb2N1cygpIHt9XG5cbiAgX3JlbW92ZUZvY3VzZWRJdGVtKCkge31cblxuICBnZXQgc2Nyb2xsT2Zmc2V0KCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0IGFkanVzdGVkRmlyc3RWaXNpYmxlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RWaXNpYmxlSW5kZXggKyB0aGlzLl92aWR4T2Zmc2V0O1xuICB9XG5cbiAgZ2V0IGFkanVzdGVkTGFzdFZpc2libGVJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0VmlzaWJsZUluZGV4ICsgdGhpcy5fdmlkeE9mZnNldDtcbiAgfVxuXG4gIHNjcm9sbFRvSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyB8fCBpc05hTihpbmRleCkgfHwgdGhpcy5zaXplID09PSAwIHx8ICF0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5kZXggPSB0aGlzLl9jbGFtcChpbmRleCwgMCwgdGhpcy5zaXplIC0gMSk7XG5cbiAgICBjb25zdCB2aXNpYmxlRWxlbWVudENvdW50ID0gdGhpcy5fX2dldFZpc2libGVFbGVtZW50cygpLmxlbmd0aDtcbiAgICBsZXQgdGFyZ2V0VmlydHVhbEluZGV4ID0gTWF0aC5mbG9vcigoaW5kZXggLyB0aGlzLnNpemUpICogdGhpcy5fdmlydHVhbENvdW50KTtcbiAgICBpZiAodGhpcy5fdmlydHVhbENvdW50IC0gdGFyZ2V0VmlydHVhbEluZGV4IDwgdmlzaWJsZUVsZW1lbnRDb3VudCkge1xuICAgICAgdGFyZ2V0VmlydHVhbEluZGV4ID0gdGhpcy5fdmlydHVhbENvdW50IC0gKHRoaXMuc2l6ZSAtIGluZGV4KTtcbiAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSB0aGlzLnNpemUgLSB0aGlzLl92aXJ0dWFsQ291bnQ7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRWaXJ0dWFsSW5kZXggPCB2aXNpYmxlRWxlbWVudENvdW50KSB7XG4gICAgICBpZiAoaW5kZXggPCBPRkZTRVRfQURKVVNUX01JTl9USFJFU0hPTEQpIHtcbiAgICAgICAgdGFyZ2V0VmlydHVhbEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0VmlydHVhbEluZGV4ID0gT0ZGU0VUX0FESlVTVF9NSU5fVEhSRVNIT0xEO1xuICAgICAgICB0aGlzLl92aWR4T2Zmc2V0ID0gaW5kZXggLSB0YXJnZXRWaXJ0dWFsSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSBpbmRleCAtIHRhcmdldFZpcnR1YWxJbmRleDtcbiAgICB9XG5cbiAgICB0aGlzLl9fc2tpcE5leHRWaXJ0dWFsSW5kZXhBZGp1c3QgPSB0cnVlO1xuICAgIHN1cGVyLnNjcm9sbFRvSW5kZXgodGFyZ2V0VmlydHVhbEluZGV4KTtcblxuICAgIGlmICh0aGlzLmFkanVzdGVkRmlyc3RWaXNpYmxlSW5kZXggIT09IGluZGV4ICYmIHRoaXMuX3Njcm9sbFRvcCA8IHRoaXMuX21heFNjcm9sbFRvcCAmJiAhdGhpcy5ncmlkKSB7XG4gICAgICAvLyBXb3JrYXJvdW5kIGFuIGlyb24tbGlzdCBpc3N1ZSBieSBtYW51YWxseSBhZGp1c3RpbmcgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgdGhpcy5fc2Nyb2xsVG9wIC09IHRoaXMuX19nZXRJbmRleFNjcm9sbE9mZnNldChpbmRleCkgfHwgMDtcbiAgICB9XG4gICAgdGhpcy5fc2Nyb2xsSGFuZGxlcigpO1xuICB9XG5cbiAgZmx1c2goKSB7XG4gICAgLy8gVGhlIHNjcm9sbCB0YXJnZXQgaXMgaGlkZGVuLlxuICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyKCk7XG4gICAgZmx1c2goKTtcbiAgICB0aGlzLl9zY3JvbGxIYW5kbGVyKCk7XG4gICAgdGhpcy5fX3Njcm9sbFJlb3JkZXJEZWJvdW5jZXIgJiYgdGhpcy5fX3Njcm9sbFJlb3JkZXJEZWJvdW5jZXIuZmx1c2goKTtcbiAgICB0aGlzLl9fZGVib3VuY2VyV2hlZWxBbmltYXRpb25GcmFtZSAmJiB0aGlzLl9fZGVib3VuY2VyV2hlZWxBbmltYXRpb25GcmFtZS5mbHVzaCgpO1xuICB9XG5cbiAgdXBkYXRlKHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9IHRoaXMuc2l6ZSAtIDEpIHtcbiAgICB0aGlzLl9fZ2V0VmlzaWJsZUVsZW1lbnRzKCkuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGlmIChlbC5fX3ZpcnR1YWxJbmRleCA+PSBzdGFydEluZGV4ICYmIGVsLl9fdmlydHVhbEluZGV4IDw9IGVuZEluZGV4KSB7XG4gICAgICAgIHRoaXMuX191cGRhdGVFbGVtZW50KGVsLCBlbC5fX3ZpcnR1YWxJbmRleCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfX3VwZGF0ZUVsZW1lbnQoZWwsIGluZGV4LCBmb3JjZVNhbWVJbmRleFVwZGF0ZXMpIHtcbiAgICAvLyBDbGVhbiB1cCB0ZW1wb3JhcnkgbWluIGhlaWdodFxuICAgIGlmIChlbC5zdHlsZS5taW5IZWlnaHQpIHtcbiAgICAgIGVsLnN0eWxlLm1pbkhlaWdodCA9ICcnO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fX3ByZXZlbnRFbGVtZW50VXBkYXRlcyAmJiAoZWwuX19sYXN0VXBkYXRlZEluZGV4ICE9PSBpbmRleCB8fCBmb3JjZVNhbWVJbmRleFVwZGF0ZXMpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoZWwsIGluZGV4KTtcbiAgICAgIGVsLl9fbGFzdFVwZGF0ZWRJbmRleCA9IGluZGV4O1xuICAgIH1cblxuICAgIGlmIChlbC5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50cyBoYXZlIDAgaGVpZ2h0IGFmdGVyIHVwZGF0ZSAoZm9yIGV4YW1wbGUgZHVlIHRvIGxhenkgcmVuZGVyaW5nKSxcbiAgICAgIC8vIGl0IHJlc3VsdHMgaW4gaXJvbi1saXN0IHJlcXVlc3RpbmcgdG8gY3JlYXRlIGFuIHVubGltaXRlZCBjb3VudCBvZiBlbGVtZW50cy5cbiAgICAgIC8vIEFzc2lnbiBhIHRlbXBvcmFyeSBtaW4gaGVpZ2h0IHRvIGVsZW1lbnRzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGVuZCB1cCBoYXZpbmdcbiAgICAgIC8vIG5vIGhlaWdodC5cbiAgICAgIGVsLnN0eWxlLm1pbkhlaWdodCA9ICcyMDBweCc7XG4gICAgfVxuICB9XG5cbiAgX19nZXRJbmRleFNjcm9sbE9mZnNldChpbmRleCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9fZ2V0VmlzaWJsZUVsZW1lbnRzKCkuZmluZCgoZWwpID0+IGVsLl9fdmlydHVhbEluZGV4ID09PSBpbmRleCk7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyB0aGlzLnNjcm9sbFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHNldCBzaXplKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdGhpcy5zaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBlbGVtZW50IHVwZGF0ZSB3aGlsZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHJlc3RvcmVkXG4gICAgdGhpcy5fX3ByZXZlbnRFbGVtZW50VXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBSZWNvcmQgdGhlIHNjcm9sbCBwb3NpdGlvbiBiZWZvcmUgY2hhbmdpbmcgdGhlIHNpemVcbiAgICBsZXQgZnZpOyAvLyBmaXJzdCB2aXNpYmxlIGluZGV4XG4gICAgbGV0IGZ2aU9mZnNldEJlZm9yZTsgLy8gc2Nyb2xsIG9mZnNldCBvZiB0aGUgZmlyc3QgdmlzaWJsZSBpbmRleFxuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgZnZpID0gdGhpcy5hZGp1c3RlZEZpcnN0VmlzaWJsZUluZGV4O1xuICAgICAgZnZpT2Zmc2V0QmVmb3JlID0gdGhpcy5fX2dldEluZGV4U2Nyb2xsT2Zmc2V0KGZ2aSk7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzaXplXG4gICAgdGhpcy5fX3NpemUgPSBzaXplO1xuXG4gICAgLy8gRmx1c2ggYmVmb3JlIGludm9raW5nIGl0ZW1zIGNoYW5nZSB0byBhdm9pZFxuICAgIC8vIGNyZWF0aW5nIGV4Y2VzcyBlbGVtZW50cyBvbiB0aGUgZm9sbG93aW5nIGZsdXNoKClcbiAgICBmbHVzaCgpO1xuXG4gICAgdGhpcy5faXRlbXNDaGFuZ2VkKHtcbiAgICAgIHBhdGg6ICdpdGVtcycsXG4gICAgfSk7XG4gICAgZmx1c2goKTtcblxuICAgIC8vIFRyeSB0byByZXN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgdGhlIG5ldyBzaXplIGlzIGxhcmdlciB0aGFuIDBcbiAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgIGZ2aSA9IE1hdGgubWluKGZ2aSwgc2l6ZSAtIDEpO1xuICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGZ2aSk7XG5cbiAgICAgIGNvbnN0IGZ2aU9mZnNldEFmdGVyID0gdGhpcy5fX2dldEluZGV4U2Nyb2xsT2Zmc2V0KGZ2aSk7XG4gICAgICBpZiAoZnZpT2Zmc2V0QmVmb3JlICE9PSB1bmRlZmluZWQgJiYgZnZpT2Zmc2V0QWZ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb3AgKz0gZnZpT2Zmc2V0QmVmb3JlIC0gZnZpT2Zmc2V0QWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fX3ByZXZlbnRFbGVtZW50VXBkYXRlcyA9IGZhbHNlO1xuICAgIC8vIFNjaGVkdWxlIGFuZCBmbHVzaCBhIHJlc2l6ZSBoYW5kbGVyXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlcigpO1xuICAgIGZsdXNoKCk7XG4gIH1cblxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3NpemU7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IF9zY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXQgX3Njcm9sbFRvcCh0b3ApIHtcbiAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSB0b3A7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IE1hdGgubWluKHRoaXMuc2l6ZSwgTUFYX1ZJUlRVQUxfQ09VTlQpLFxuICAgIH07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IG9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQub2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGdldCAkKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtczogdGhpcy5zY3JvbGxDb250YWluZXIsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1cGRhdGVWaWV3cG9ydEJvdW5kYXJpZXMoKSB7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgIHRoaXMuX3Njcm9sbGVyUGFkZGluZ1RvcCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzID8gMCA6IHBhcnNlSW50KHN0eWxlc1sncGFkZGluZy10b3AnXSwgMTApO1xuICAgIHRoaXMuX2lzUlRMID0gQm9vbGVhbihzdHlsZXMuZGlyZWN0aW9uID09PSAncnRsJyk7XG4gICAgdGhpcy5fdmlld3BvcnRXaWR0aCA9IHRoaXMuZWxlbWVudHNDb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5fdmlld3BvcnRIZWlnaHQgPSB0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5fc2Nyb2xsUGFnZUhlaWdodCA9IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0IC0gdGhpcy5fc2Nyb2xsTGluZUhlaWdodDtcbiAgICB0aGlzLmdyaWQgJiYgdGhpcy5fdXBkYXRlR3JpZE1ldHJpY3MoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXRBdHRyaWJ1dGUoKSB7fVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfY3JlYXRlUG9vbChzaXplKSB7XG4gICAgY29uc3QgcGh5c2ljYWxJdGVtcyA9IHRoaXMuY3JlYXRlRWxlbWVudHMoc2l6ZSk7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgcGh5c2ljYWxJdGVtcy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgdGhpcy5fX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWwpO1xuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIHJldHVybiBwaHlzaWNhbEl0ZW1zO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9hc3NpZ25Nb2RlbHMoaXRlbVNldCkge1xuICAgIHRoaXMuX2l0ZXJhdGVJdGVtcygocGlkeCwgdmlkeCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLl9waHlzaWNhbEl0ZW1zW3BpZHhdO1xuICAgICAgZWwuaGlkZGVuID0gdmlkeCA+PSB0aGlzLnNpemU7XG4gICAgICBpZiAoIWVsLmhpZGRlbikge1xuICAgICAgICBlbC5fX3ZpcnR1YWxJbmRleCA9IHZpZHggKyAodGhpcy5fdmlkeE9mZnNldCB8fCAwKTtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUVsZW1lbnQoZWwsIGVsLl9fdmlydHVhbEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBlbC5fX2xhc3RVcGRhdGVkSW5kZXg7XG4gICAgICB9XG4gICAgfSwgaXRlbVNldCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2lzQ2xpZW50RnVsbCgpIHtcbiAgICAvLyBXb3JrYXJvdW5kIGFuIGlzc3VlIGluIGlyb24tbGlzdCB0aGF0IGNhbiBjYXVzZSBpdCB0byBmcmVlemUgb24gZmFzdCBzY3JvbGxcbiAgICBzZXRUaW1lb3V0KCgpID0+ICh0aGlzLl9fY2xpZW50RnVsbCA9IHRydWUpKTtcbiAgICByZXR1cm4gdGhpcy5fX2NsaWVudEZ1bGwgfHwgc3VwZXIuX2lzQ2xpZW50RnVsbCgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRyYW5zbGF0ZTNkKF94LCB5LCBfeiwgZWwpIHtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke3l9KWA7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdG9nZ2xlU2Nyb2xsTGlzdGVuZXIoKSB7fVxuXG4gIF9zY3JvbGxIYW5kbGVyKCkge1xuICAgIHRoaXMuX2FkanVzdFZpcnR1YWxJbmRleE9mZnNldCh0aGlzLl9zY3JvbGxUb3AgLSAodGhpcy5fX3ByZXZpb3VzU2Nyb2xsVG9wIHx8IDApKTtcblxuICAgIHN1cGVyLl9zY3JvbGxIYW5kbGVyKCk7XG5cbiAgICBpZiAodGhpcy5yZW9yZGVyRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuX19zY3JvbGxSZW9yZGVyRGVib3VuY2VyID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICB0aGlzLl9fc2Nyb2xsUmVvcmRlckRlYm91bmNlcixcbiAgICAgICAgdGltZU91dC5hZnRlcih0aGlzLnRpbWVvdXRzLlNDUk9MTF9SRU9SREVSKSxcbiAgICAgICAgKCkgPT4gdGhpcy5fX3Jlb3JkZXJFbGVtZW50cygpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9fcHJldmlvdXNTY3JvbGxUb3AgPSB0aGlzLl9zY3JvbGxUb3A7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19vbldoZWVsKGUpIHtcbiAgICBpZiAoZS5jdHJsS2V5IHx8IHRoaXMuX2hhc1Njcm9sbGVkQW5jZXN0b3IoZS50YXJnZXQsIGUuZGVsdGFYLCBlLmRlbHRhWSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZGVsdGFZID0gZS5kZWx0YVk7XG4gICAgaWYgKGUuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICAvLyBTY3JvbGxpbmcgYnkgXCJsaW5lcyBvZiB0ZXh0XCIgaW5zdGVhZCBvZiBwaXhlbHNcbiAgICAgIGRlbHRhWSAqPSB0aGlzLl9zY3JvbGxMaW5lSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoZS5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UpIHtcbiAgICAgIC8vIFNjcm9sbGluZyBieSBcInBhZ2VzXCIgaW5zdGVhZCBvZiBwaXhlbHNcbiAgICAgIGRlbHRhWSAqPSB0aGlzLl9zY3JvbGxQYWdlSGVpZ2h0O1xuICAgIH1cblxuICAgIHRoaXMuX2RlbHRhWUFjYyA9IHRoaXMuX2RlbHRhWUFjYyB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3doZWVsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIC8vIEFjY3VtdWxhdGUgd2hlZWwgZGVsdGEgd2hpbGUgYSBmcmFtZSBpcyBiZWluZyBwcm9jZXNzZWRcbiAgICAgIHRoaXMuX2RlbHRhWUFjYyArPSBkZWx0YVk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsdGFZICs9IHRoaXMuX2RlbHRhWUFjYztcbiAgICB0aGlzLl9kZWx0YVlBY2MgPSAwO1xuXG4gICAgdGhpcy5fd2hlZWxBbmltYXRpb25GcmFtZSA9IHRydWU7XG4gICAgdGhpcy5fX2RlYm91bmNlcldoZWVsQW5pbWF0aW9uRnJhbWUgPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICB0aGlzLl9fZGVib3VuY2VyV2hlZWxBbmltYXRpb25GcmFtZSxcbiAgICAgIGFuaW1hdGlvbkZyYW1lLFxuICAgICAgKCkgPT4gKHRoaXMuX3doZWVsQW5pbWF0aW9uRnJhbWUgPSBmYWxzZSksXG4gICAgKTtcblxuICAgIGNvbnN0IG1vbWVudHVtID0gTWF0aC5hYnMoZS5kZWx0YVgpICsgTWF0aC5hYnMoZGVsdGFZKTtcblxuICAgIGlmICh0aGlzLl9jYW5TY3JvbGwodGhpcy5zY3JvbGxUYXJnZXQsIGUuZGVsdGFYLCBkZWx0YVkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3AgKz0gZGVsdGFZO1xuICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsTGVmdCArPSBlLmRlbHRhWDtcblxuICAgICAgdGhpcy5faGFzUmVzaWR1YWxNb21lbnR1bSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2lnbm9yZU5ld1doZWVsID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2RlYm91bmNlcklnbm9yZU5ld1doZWVsID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICB0aGlzLl9kZWJvdW5jZXJJZ25vcmVOZXdXaGVlbCxcbiAgICAgICAgdGltZU91dC5hZnRlcih0aGlzLnRpbWVvdXRzLklHTk9SRV9XSEVFTCksXG4gICAgICAgICgpID0+ICh0aGlzLl9pZ25vcmVOZXdXaGVlbCA9IGZhbHNlKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgodGhpcy5faGFzUmVzaWR1YWxNb21lbnR1bSAmJiBtb21lbnR1bSA8PSB0aGlzLl9wcmV2aW91c01vbWVudHVtKSB8fCB0aGlzLl9pZ25vcmVOZXdXaGVlbCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAobW9tZW50dW0gPiB0aGlzLl9wcmV2aW91c01vbWVudHVtKSB7XG4gICAgICB0aGlzLl9oYXNSZXNpZHVhbE1vbWVudHVtID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZpb3VzTW9tZW50dW0gPSBtb21lbnR1bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IGhhcyBhbiBhbmNlc3RvciB0aGF0IGhhbmRsZXMgdGhlIHNjcm9sbCBkZWx0YSBwcmlvciB0byB0aGlzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFzU2Nyb2xsZWRBbmNlc3RvcihlbCwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBpZiAoZWwgPT09IHRoaXMuc2Nyb2xsVGFyZ2V0IHx8IGVsID09PSB0aGlzLnNjcm9sbFRhcmdldC5nZXRSb290Tm9kZSgpLmhvc3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fY2FuU2Nyb2xsKGVsLCBkZWx0YVgsIGRlbHRhWSkgJiZcbiAgICAgIFsnYXV0bycsICdzY3JvbGwnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWwpLm92ZXJmbG93KSAhPT0gLTFcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWwgIT09IHRoaXMgJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Njcm9sbGVkQW5jZXN0b3IoZWwucGFyZW50RWxlbWVudCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIH1cbiAgfVxuXG4gIF9jYW5TY3JvbGwoZWwsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChkZWx0YVkgPiAwICYmIGVsLnNjcm9sbFRvcCA8IGVsLnNjcm9sbEhlaWdodCAtIGVsLm9mZnNldEhlaWdodCkgfHxcbiAgICAgIChkZWx0YVkgPCAwICYmIGVsLnNjcm9sbFRvcCA+IDApIHx8XG4gICAgICAoZGVsdGFYID4gMCAmJiBlbC5zY3JvbGxMZWZ0IDwgZWwuc2Nyb2xsV2lkdGggLSBlbC5vZmZzZXRXaWR0aCkgfHxcbiAgICAgIChkZWx0YVggPCAwICYmIGVsLnNjcm9sbExlZnQgPiAwKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge051bWJlcnx1bmRlZmluZWR9IC0gVGhlIGJyb3dzZXIncyBkZWZhdWx0IGZvbnQtc2l6ZSBpbiBwaXhlbHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRTY3JvbGxMaW5lSGVpZ2h0KCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUuZm9udFNpemUgPSAnaW5pdGlhbCc7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5mb250U2l6ZTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gZm9udFNpemUgPyB3aW5kb3cucGFyc2VJbnQoZm9udFNpemUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgX19nZXRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50c0NvbnRhaW5lci5jaGlsZHJlbikuZmlsdGVyKChlbGVtZW50KSA9PiAhZWxlbWVudC5oaWRkZW4pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fcmVvcmRlckVsZW1lbnRzKCkge1xuICAgIGlmICh0aGlzLl9fbW91c2VEb3duKSB7XG4gICAgICB0aGlzLl9fcGVuZGluZ1Jlb3JkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fcGVuZGluZ1Jlb3JkZXIgPSBmYWxzZTtcblxuICAgIGNvbnN0IGFkanVzdGVkVmlydHVhbFN0YXJ0ID0gdGhpcy5fdmlydHVhbFN0YXJ0ICsgKHRoaXMuX3ZpZHhPZmZzZXQgfHwgMCk7XG5cbiAgICAvLyBXaGljaCByb3cgdG8gdXNlIGFzIGEgdGFyZ2V0P1xuICAgIGNvbnN0IHZpc2libGVFbGVtZW50cyA9IHRoaXMuX19nZXRWaXNpYmxlRWxlbWVudHMoKTtcblxuICAgIGNvbnN0IGVsZW1lbnRXaXRoRm9jdXMgPSB2aXNpYmxlRWxlbWVudHMuZmluZChcbiAgICAgIChlbGVtZW50KSA9PlxuICAgICAgICBlbGVtZW50LmNvbnRhaW5zKHRoaXMuZWxlbWVudHNDb250YWluZXIuZ2V0Um9vdE5vZGUoKS5hY3RpdmVFbGVtZW50KSB8fFxuICAgICAgICBlbGVtZW50LmNvbnRhaW5zKHRoaXMuc2Nyb2xsVGFyZ2V0LmdldFJvb3ROb2RlKCkuYWN0aXZlRWxlbWVudCksXG4gICAgKTtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZWxlbWVudFdpdGhGb2N1cyB8fCB2aXNpYmxlRWxlbWVudHNbMF07XG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgICAvLyBBbGwgZWxlbWVudHMgYXJlIGhpZGRlbiwgZG9uJ3QgcmVvcmRlclxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoZXJlIHRoZSB0YXJnZXQgcm93IHNob3VsZCBiZT9cbiAgICBjb25zdCB0YXJnZXRQaHlzaWNhbEluZGV4ID0gdGFyZ2V0RWxlbWVudC5fX3ZpcnR1YWxJbmRleCAtIGFkanVzdGVkVmlydHVhbFN0YXJ0O1xuXG4gICAgLy8gUmVvZHJlciB0aGUgRE9NIGVsZW1lbnRzIHRvIGtlZXAgdGhlIHRhcmdldCByb3cgYXQgdGhlIHRhcmdldCBwaHlzaWNhbCBpbmRleFxuICAgIGNvbnN0IGRlbHRhID0gdmlzaWJsZUVsZW1lbnRzLmluZGV4T2YodGFyZ2V0RWxlbWVudCkgLSB0YXJnZXRQaHlzaWNhbEluZGV4O1xuICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGE7IGkrKykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzQ29udGFpbmVyLmFwcGVuZENoaWxkKHZpc2libGVFbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSB2aXNpYmxlRWxlbWVudHMubGVuZ3RoICsgZGVsdGE7IGkgPCB2aXNpYmxlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c0NvbnRhaW5lci5pbnNlcnRCZWZvcmUodmlzaWJsZUVsZW1lbnRzW2ldLCB2aXNpYmxlRWxlbWVudHNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIER1ZSB0byBhIHJlbmRlcmluZyBidWcsIHJlb3JkZXJpbmcgdGhlIHJvd3MgY2FuIG1ha2UgcGFydHMgb2YgdGhlIHNjcm9sbCB0YXJnZXQgZGlzYXBwZWFyXG4gICAgLy8gb24gU2FmYXJpIHdoZW4gdXNpbmcgc3RpY2t5IHBvc2l0aW9uaW5nIGluIGNhc2UgdGhlIHNjcm9sbCB0YXJnZXQgaXMgaW5zaWRlIGEgZmxleGJveC5cbiAgICAvLyBUaGlzIGlzc3VlIG1hbmlmZXN0cyB3aXRoIGdyaWQgKHRoZSBoZWFkZXIgY2FuIGRpc2FwcGVhciBpZiBncmlkIGlzIHVzZWQgaW5zaWRlIGEgZmxleGJveClcbiAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNmb3JtIH0gPSB0aGlzLnNjcm9sbFRhcmdldC5zdHlsZTtcbiAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gKHRoaXMuc2Nyb2xsVGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfYWRqdXN0VmlydHVhbEluZGV4T2Zmc2V0KGRlbHRhKSB7XG4gICAgaWYgKHRoaXMuX3ZpcnR1YWxDb3VudCA+PSB0aGlzLnNpemUpIHtcbiAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fX3NraXBOZXh0VmlydHVhbEluZGV4QWRqdXN0KSB7XG4gICAgICB0aGlzLl9fc2tpcE5leHRWaXJ0dWFsSW5kZXhBZGp1c3QgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlbHRhKSA+IDEwMDAwKSB7XG4gICAgICAvLyBQcm9jZXNzIGEgbGFyZ2Ugc2Nyb2xsIHBvc2l0aW9uIGNoYW5nZVxuICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zY3JvbGxUb3AgLyAodGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5zY3JvbGxUYXJnZXQub2Zmc2V0SGVpZ2h0KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHNjYWxlICogdGhpcy5zaXplO1xuICAgICAgdGhpcy5fdmlkeE9mZnNldCA9IE1hdGgucm91bmQob2Zmc2V0IC0gc2NhbGUgKiB0aGlzLl92aXJ0dWFsQ291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdXNlciBjYW4gYWx3YXlzIHN3aXBlL3doZWVsIHNjcm9sbCB0byB0aGUgc3RhcnQgYW5kIGVuZFxuICAgICAgY29uc3Qgb2xkT2Zmc2V0ID0gdGhpcy5fdmlkeE9mZnNldDtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IE9GRlNFVF9BREpVU1RfTUlOX1RIUkVTSE9MRDtcbiAgICAgIGNvbnN0IG1heFNoaWZ0ID0gMTAwO1xuXG4gICAgICAvLyBOZWFyIHN0YXJ0XG4gICAgICBpZiAodGhpcy5fc2Nyb2xsVG9wID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSAwO1xuICAgICAgICBpZiAob2xkT2Zmc2V0ICE9PSB0aGlzLl92aWR4T2Zmc2V0KSB7XG4gICAgICAgICAgc3VwZXIuc2Nyb2xsVG9JbmRleCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0VmlzaWJsZUluZGV4IDwgdGhyZXNob2xkICYmIHRoaXMuX3ZpZHhPZmZzZXQgPiAwKSB7XG4gICAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgLT0gTWF0aC5taW4odGhpcy5fdmlkeE9mZnNldCwgbWF4U2hpZnQpO1xuICAgICAgICBzdXBlci5zY3JvbGxUb0luZGV4KHRoaXMuZmlyc3RWaXNpYmxlSW5kZXggKyAob2xkT2Zmc2V0IC0gdGhpcy5fdmlkeE9mZnNldCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWFyIGVuZFxuICAgICAgY29uc3QgbWF4T2Zmc2V0ID0gdGhpcy5zaXplIC0gdGhpcy5fdmlydHVhbENvdW50O1xuICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA+PSB0aGlzLl9tYXhTY3JvbGxUb3AgJiYgdGhpcy5fbWF4U2Nyb2xsVG9wID4gMCkge1xuICAgICAgICB0aGlzLl92aWR4T2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgICBpZiAob2xkT2Zmc2V0ICE9PSB0aGlzLl92aWR4T2Zmc2V0KSB7XG4gICAgICAgICAgc3VwZXIuc2Nyb2xsVG9JbmRleCh0aGlzLl92aXJ0dWFsQ291bnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0VmlzaWJsZUluZGV4ID4gdGhpcy5fdmlydHVhbENvdW50IC0gdGhyZXNob2xkICYmIHRoaXMuX3ZpZHhPZmZzZXQgPCBtYXhPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fdmlkeE9mZnNldCArPSBNYXRoLm1pbihtYXhPZmZzZXQgLSB0aGlzLl92aWR4T2Zmc2V0LCBtYXhTaGlmdCk7XG4gICAgICAgIHN1cGVyLnNjcm9sbFRvSW5kZXgodGhpcy5maXJzdFZpc2libGVJbmRleCAtICh0aGlzLl92aWR4T2Zmc2V0IC0gb2xkT2Zmc2V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihJcm9uTGlzdEFkYXB0ZXIucHJvdG90eXBlLCBpcm9uTGlzdCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/virtualizer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/virtualizer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Virtualizer\": () => (/* binding */ Virtualizer)\n/* harmony export */ });\n/* harmony import */ var _virtualizer_iron_list_adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./virtualizer-iron-list-adapter.js */ \"./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js\");\n\nclass Virtualizer {\n  /**\n   * @typedef {Object} VirtualizerConfig\n   * @property {Function} createElements Function that returns the given number of new elements\n   * @property {Function} updateElement Function that updates the element at a specific index\n   * @property {HTMLElement} scrollTarget Reference to the scrolling element\n   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget\n   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer\n   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM\n   * @param {VirtualizerConfig} config Configuration for the virtualizer\n   */\n  constructor(config) {\n    this.__adapter = new _virtualizer_iron_list_adapter_js__WEBPACK_IMPORTED_MODULE_0__.IronListAdapter(config);\n  }\n  /**\n   * The size of the virtualizer\n   * @param {number} size The size of the virtualizer\n   */\n\n\n  set size(size) {\n    this.__adapter.size = size;\n  }\n  /**\n   * The size of the virtualizer\n   * @return {number | undefined} The size of the virtualizer\n   */\n\n\n  get size() {\n    return this.__adapter.size;\n  }\n  /**\n   * Scroll to a specific index in the virtual list\n   *\n   * @method scrollToIndex\n   * @param {number} index The index of the item\n   */\n\n\n  scrollToIndex(index) {\n    this.__adapter.scrollToIndex(index);\n  }\n  /**\n   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__adapter.update(startIndex, endIndex);\n  }\n  /**\n   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n\n\n  flush() {\n    this.__adapter.flush();\n  }\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @return {number}\n   */\n\n\n  get firstVisibleIndex() {\n    return this.__adapter.adjustedFirstVisibleIndex;\n  }\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @return {number}\n   */\n\n\n  get lastVisibleIndex() {\n    return this.__adapter.adjustedLastVisibleIndex;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdmlydHVhbGl6ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBL0VBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy92aXJ0dWFsaXplci5qcz85ZmY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElyb25MaXN0QWRhcHRlciB9IGZyb20gJy4vdmlydHVhbGl6ZXItaXJvbi1saXN0LWFkYXB0ZXIuanMnO1xuXG5leHBvcnQgY2xhc3MgVmlydHVhbGl6ZXIge1xuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gVmlydHVhbGl6ZXJDb25maWdcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY3JlYXRlRWxlbWVudHMgRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBnaXZlbiBudW1iZXIgb2YgbmV3IGVsZW1lbnRzXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVwZGF0ZUVsZW1lbnQgRnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gc2Nyb2xsVGFyZ2V0IFJlZmVyZW5jZSB0byB0aGUgc2Nyb2xsaW5nIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gc2Nyb2xsQ29udGFpbmVyIFJlZmVyZW5jZSB0byBhIHdyYXBwZXIgZm9yIHRoZSBpdGVtIGVsZW1lbnRzIChvciBhIHNsb3QpIGluc2lkZSB0aGUgc2Nyb2xsVGFyZ2V0XG4gICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9IGVsZW1lbnRzQ29udGFpbmVyIFJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGluIHdoaWNoIHRoZSBpdGVtIGVsZW1lbnRzIGFyZSBwbGFjZWQsIGRlZmF1bHRzIHRvIHNjcm9sbENvbnRhaW5lclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IHJlb3JkZXJFbGVtZW50cyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBoeXNpY2FsIGl0ZW0gZWxlbWVudHMgc2hvdWxkIGJlIGtlcHQgaW4gb3JkZXIgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1ZpcnR1YWxpemVyQ29uZmlnfSBjb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZpcnR1YWxpemVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9fYWRhcHRlciA9IG5ldyBJcm9uTGlzdEFkYXB0ZXIoY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgdmlydHVhbGl6ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIHNpemUgb2YgdGhlIHZpcnR1YWxpemVyXG4gICAqL1xuICBzZXQgc2l6ZShzaXplKSB7XG4gICAgdGhpcy5fX2FkYXB0ZXIuc2l6ZSA9IHNpemU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIHZpcnR1YWxpemVyXG4gICAqIEByZXR1cm4ge251bWJlciB8IHVuZGVmaW5lZH0gVGhlIHNpemUgb2YgdGhlIHZpcnR1YWxpemVyXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2FkYXB0ZXIuc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gYSBzcGVjaWZpYyBpbmRleCBpbiB0aGUgdmlydHVhbCBsaXN0XG4gICAqXG4gICAqIEBtZXRob2Qgc2Nyb2xsVG9JbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpdGVtXG4gICAqL1xuICBzY3JvbGxUb0luZGV4KGluZGV4KSB7XG4gICAgdGhpcy5fX2FkYXB0ZXIuc2Nyb2xsVG9JbmRleChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHZpcnR1YWxpemVyIHRvIHJlLXJlbmRlciB0aGUgaXRlbSBlbGVtZW50cyBvbiBhbiBpbmRleCByYW5nZSwgaWYgY3VycmVudGx5IGluIHRoZSBET01cbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZVxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2VcbiAgICovXG4gIHVwZGF0ZShzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSB0aGlzLnNpemUgLSAxKSB7XG4gICAgdGhpcy5fX2FkYXB0ZXIudXBkYXRlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGVzIGFjdGl2ZSBhc3luY2hyb25vdXMgdGFza3Mgc28gdGhhdCB0aGUgY29tcG9uZW50IGFuZCB0aGUgRE9NIGVuZCB1cCBpbiBhIHN0YWJsZSBzdGF0ZVxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZVxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgdGhpcy5fX2FkYXB0ZXIuZmx1c2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmlzaWJsZSBpdGVtIGluIHRoZSB2aWV3cG9ydC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZpcnN0VmlzaWJsZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9fYWRhcHRlci5hZGp1c3RlZEZpcnN0VmlzaWJsZUluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHZpc2libGUgaXRlbSBpbiB0aGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBsYXN0VmlzaWJsZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9fYWRhcHRlci5hZGp1c3RlZExhc3RWaXNpYmxlSW5kZXg7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/field-base/src/input-mixin.js":
/*!************************************************************!*\
  !*** ./node_modules/@vaadin/field-base/src/input-mixin.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputMixin\": () => (/* binding */ InputMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * A mixin to store the reference to an input element\n * and add input and change event listeners to it.\n *\n * @polymerMixin\n */\n\nconst InputMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superclass => class InputMixinClass extends superclass {\n  static get properties() {\n    return {\n      /**\n       * A reference to the input element controlled by the mixin.\n       * Any component implementing this mixin is expected to provide it\n       * by using `this._setInputElement(input)` Polymer API.\n       *\n       * A typical case is using `InputController` that does this automatically.\n       * However, the input element does not have to always be native <input>:\n       * as an example, <vaadin-combo-box-light> accepts other components.\n       *\n       * @protected\n       * @type {!HTMLElement}\n       */\n      inputElement: {\n        type: Object,\n        readOnly: true,\n        observer: '_inputElementChanged'\n      },\n\n      /**\n       * String used to define input type.\n       * @protected\n       */\n      type: {\n        type: String,\n        readOnly: true\n      },\n\n      /**\n       * The value of the field.\n       */\n      value: {\n        type: String,\n        value: '',\n        observer: '_valueChanged',\n        notify: true\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this._boundOnInput = this._onInput.bind(this);\n    this._boundOnChange = this._onChange.bind(this);\n  }\n  /**\n   * Clear the value of the field.\n   */\n\n\n  clear() {\n    this.value = '';\n  }\n  /**\n   * Add event listeners to the input element instance.\n   * Override this method to add custom listeners.\n   * @param {!HTMLElement} input\n   */\n\n\n  _addInputListeners(input) {\n    input.addEventListener('input', this._boundOnInput);\n    input.addEventListener('change', this._boundOnChange);\n  }\n  /**\n   * Remove event listeners from the input element instance.\n   * @param {!HTMLElement} input\n   */\n\n\n  _removeInputListeners(input) {\n    input.removeEventListener('input', this._boundOnInput);\n    input.removeEventListener('change', this._boundOnChange);\n  }\n  /**\n   * A method to forward the value property set on the field\n   * programmatically back to the input element value.\n   * Override this method to perform additional checks,\n   * for example to skip this in certain conditions.\n   * @param {string} value\n   * @protected\n   * @override\n   */\n\n\n  _forwardInputValue(value) {\n    // Value might be set before an input element is initialized.\n    // This case should be handled separately by a component that\n    // implements this mixin, for example in `connectedCallback`.\n    if (!this.inputElement) {\n      return;\n    }\n\n    if (value != undefined) {\n      this.inputElement.value = value;\n    } else {\n      this.inputElement.value = '';\n    }\n  }\n  /** @protected */\n\n\n  _inputElementChanged(input, oldInput) {\n    if (input) {\n      this._addInputListeners(input);\n    } else if (oldInput) {\n      this._removeInputListeners(oldInput);\n    }\n  }\n  /**\n   * An input event listener used to update the field value.\n   * Override this method with an actual implementation.\n   * @param {Event} _event\n   * @protected\n   * @override\n   */\n\n\n  _onInput(event) {\n    // Ignore fake input events e.g. used by clear button.\n    this.__userInput = event.isTrusted;\n    this.value = event.target.value;\n    this.__userInput = false;\n  }\n  /**\n   * A change event listener.\n   * Override this method with an actual implementation.\n   * @param {Event} _event\n   * @protected\n   * @override\n   */\n\n\n  _onChange(_event) {}\n  /**\n   * Toggle the has-value attribute based on the value property.\n   * @param {boolean} hasValue\n   * @protected\n   */\n\n\n  _toggleHasValue(hasValue) {\n    this.toggleAttribute('has-value', hasValue);\n  }\n  /**\n   * Observer called when a value property changes.\n   * @param {string | undefined} newVal\n   * @param {string | undefined} oldVal\n   * @protected\n   * @override\n   */\n\n\n  _valueChanged(newVal, oldVal) {\n    this._toggleHasValue(newVal !== '' && newVal != null); // Setting initial value to empty string, do nothing.\n\n\n    if (newVal === '' && oldVal === undefined) {\n      return;\n    } // Value is set by the user, no need to sync it back to input.\n\n\n    if (this.__userInput) {\n      return;\n    } // Setting a value programmatically, sync it to input element.\n\n\n    this._forwardInputValue(newVal);\n  }\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL3NyYy9pbnB1dC1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBL0JBO0FBc0NBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQWxLQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL3NyYy9pbnB1dC1taXhpbi5qcz80Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzJztcblxuLyoqXG4gKiBBIG1peGluIHRvIHN0b3JlIHRoZSByZWZlcmVuY2UgdG8gYW4gaW5wdXQgZWxlbWVudFxuICogYW5kIGFkZCBpbnB1dCBhbmQgY2hhbmdlIGV2ZW50IGxpc3RlbmVycyB0byBpdC5cbiAqXG4gKiBAcG9seW1lck1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBJbnB1dE1peGluID0gZGVkdXBpbmdNaXhpbihcbiAgKHN1cGVyY2xhc3MpID0+XG4gICAgY2xhc3MgSW5wdXRNaXhpbkNsYXNzIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG4gICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGlucHV0IGVsZW1lbnQgY29udHJvbGxlZCBieSB0aGUgbWl4aW4uXG4gICAgICAgICAgICogQW55IGNvbXBvbmVudCBpbXBsZW1lbnRpbmcgdGhpcyBtaXhpbiBpcyBleHBlY3RlZCB0byBwcm92aWRlIGl0XG4gICAgICAgICAgICogYnkgdXNpbmcgYHRoaXMuX3NldElucHV0RWxlbWVudChpbnB1dClgIFBvbHltZXIgQVBJLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQSB0eXBpY2FsIGNhc2UgaXMgdXNpbmcgYElucHV0Q29udHJvbGxlcmAgdGhhdCBkb2VzIHRoaXMgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgKiBIb3dldmVyLCB0aGUgaW5wdXQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIHRvIGFsd2F5cyBiZSBuYXRpdmUgPGlucHV0PjpcbiAgICAgICAgICAgKiBhcyBhbiBleGFtcGxlLCA8dmFhZGluLWNvbWJvLWJveC1saWdodD4gYWNjZXB0cyBvdGhlciBjb21wb25lbnRzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAqIEB0eXBlIHshSFRNTEVsZW1lbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgaW5wdXRFbGVtZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICAgIG9ic2VydmVyOiAnX2lucHV0RWxlbWVudENoYW5nZWQnLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTdHJpbmcgdXNlZCB0byBkZWZpbmUgaW5wdXQgdHlwZS5cbiAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICovXG4gICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgZmllbGQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgIG9ic2VydmVyOiAnX3ZhbHVlQ2hhbmdlZCcsXG4gICAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5fYm91bmRPbklucHV0ID0gdGhpcy5fb25JbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhciB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkLlxuICAgICAgICovXG4gICAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGlucHV0IGVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgY3VzdG9tIGxpc3RlbmVycy5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBpbnB1dFxuICAgICAgICovXG4gICAgICBfYWRkSW5wdXRMaXN0ZW5lcnMoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGlucHV0IGVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gaW5wdXRcbiAgICAgICAqL1xuICAgICAgX3JlbW92ZUlucHV0TGlzdGVuZXJzKGlucHV0KSB7XG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fYm91bmRPbkNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBtZXRob2QgdG8gZm9yd2FyZCB0aGUgdmFsdWUgcHJvcGVydHkgc2V0IG9uIHRoZSBmaWVsZFxuICAgICAgICogcHJvZ3JhbW1hdGljYWxseSBiYWNrIHRvIHRoZSBpbnB1dCBlbGVtZW50IHZhbHVlLlxuICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBhZGRpdGlvbmFsIGNoZWNrcyxcbiAgICAgICAqIGZvciBleGFtcGxlIHRvIHNraXAgdGhpcyBpbiBjZXJ0YWluIGNvbmRpdGlvbnMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICovXG4gICAgICBfZm9yd2FyZElucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgLy8gVmFsdWUgbWlnaHQgYmUgc2V0IGJlZm9yZSBhbiBpbnB1dCBlbGVtZW50IGlzIGluaXRpYWxpemVkLlxuICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIGJlIGhhbmRsZWQgc2VwYXJhdGVseSBieSBhIGNvbXBvbmVudCB0aGF0XG4gICAgICAgIC8vIGltcGxlbWVudHMgdGhpcyBtaXhpbiwgZm9yIGV4YW1wbGUgaW4gYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgICAgaWYgKCF0aGlzLmlucHV0RWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICAgIF9pbnB1dEVsZW1lbnRDaGFuZ2VkKGlucHV0LCBvbGRJbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICB0aGlzLl9hZGRJbnB1dExpc3RlbmVycyhpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkSW5wdXQpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVJbnB1dExpc3RlbmVycyhvbGRJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBpbnB1dCBldmVudCBsaXN0ZW5lciB1c2VkIHRvIHVwZGF0ZSB0aGUgZmllbGQgdmFsdWUuXG4gICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB3aXRoIGFuIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IF9ldmVudFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9vbklucHV0KGV2ZW50KSB7XG4gICAgICAgIC8vIElnbm9yZSBmYWtlIGlucHV0IGV2ZW50cyBlLmcuIHVzZWQgYnkgY2xlYXIgYnV0dG9uLlxuICAgICAgICB0aGlzLl9fdXNlcklucHV0ID0gZXZlbnQuaXNUcnVzdGVkO1xuICAgICAgICB0aGlzLnZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICB0aGlzLl9fdXNlcklucHV0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBjaGFuZ2UgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB3aXRoIGFuIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IF9ldmVudFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF9vbkNoYW5nZShfZXZlbnQpIHt9XG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIHRoZSBoYXMtdmFsdWUgYXR0cmlidXRlIGJhc2VkIG9uIHRoZSB2YWx1ZSBwcm9wZXJ0eS5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzVmFsdWVcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3RvZ2dsZUhhc1ZhbHVlKGhhc1ZhbHVlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlQXR0cmlidXRlKCdoYXMtdmFsdWUnLCBoYXNWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT2JzZXJ2ZXIgY2FsbGVkIHdoZW4gYSB2YWx1ZSBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IG5ld1ZhbFxuICAgICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IG9sZFZhbFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIF92YWx1ZUNoYW5nZWQobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlSGFzVmFsdWUobmV3VmFsICE9PSAnJyAmJiBuZXdWYWwgIT0gbnVsbCk7XG5cbiAgICAgICAgLy8gU2V0dGluZyBpbml0aWFsIHZhbHVlIHRvIGVtcHR5IHN0cmluZywgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKG5ld1ZhbCA9PT0gJycgJiYgb2xkVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZSBpcyBzZXQgYnkgdGhlIHVzZXIsIG5vIG5lZWQgdG8gc3luYyBpdCBiYWNrIHRvIGlucHV0LlxuICAgICAgICBpZiAodGhpcy5fX3VzZXJJbnB1dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHRpbmcgYSB2YWx1ZSBwcm9ncmFtbWF0aWNhbGx5LCBzeW5jIGl0IHRvIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIHRoaXMuX2ZvcndhcmRJbnB1dFZhbHVlKG5ld1ZhbCk7XG4gICAgICB9XG4gICAgfSxcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/field-base/src/input-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js":
/*!************************************************************************!*\
  !*** ./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"item\": () => (/* binding */ item)\n/* harmony export */ });\n/* harmony import */ var _vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/font-icons.js */ \"./node_modules/@vaadin/vaadin-material-styles/font-icons.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vaadin_vaadin_material_styles_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/typography.js */ \"./node_modules/@vaadin/vaadin-material-styles/typography.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n\n\nconst item = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.css`\n  :host {\n    display: flex;\n    align-items: center;\n    box-sizing: border-box;\n    min-height: 36px;\n    padding: 8px 32px 8px 10px;\n    overflow: hidden;\n    font-family: var(--material-font-family);\n    font-size: var(--material-small-font-size);\n    line-height: 24px;\n  }\n\n  /* It's the list-box's responsibility to add the focus style */\n  :host([focused]) {\n    outline: none;\n  }\n\n  /* Checkmark */\n  [part='checkmark']::before {\n    display: var(--_material-item-selected-icon-display, none);\n    content: '';\n    font-family: material-icons;\n    font-size: 24px;\n    line-height: 1;\n    font-weight: 400;\n    width: 24px;\n    text-align: center;\n    margin-right: 10px;\n    color: var(--material-secondary-text-color);\n    flex: none;\n  }\n\n  :host([selected]) [part='checkmark']::before {\n    content: var(--material-icons-check);\n  }\n\n  @media (any-hover: hover) {\n    :host(:hover:not([disabled])) {\n      background-color: var(--material-secondary-background-color);\n    }\n\n    :host([focused]:not([disabled])) {\n      background-color: var(--material-divider-color);\n    }\n  }\n\n  /* Disabled */\n  :host([disabled]) {\n    color: var(--material-disabled-text-color);\n    cursor: default;\n    pointer-events: none;\n  }\n\n  /* RTL specific styles */\n  :host([dir='rtl']) {\n    padding: 8px 10px 8px 32px;\n  }\n\n  :host([dir='rtl']) [part='checkmark']::before {\n    margin-right: 0;\n    margin-left: 10px;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.registerStyles)('vaadin-item', item, {\n  moduleId: 'material-item'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9pdGVtL3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1pdGVtLXN0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9pdGVtL3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1pdGVtLXN0eWxlcy5qcz83Y2UyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2ZvbnQtaWNvbnMuanMnO1xuaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvY29sb3IuanMnO1xuaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvdHlwb2dyYXBoeS5qcyc7XG5pbXBvcnQgeyBjc3MsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuY29uc3QgaXRlbSA9IGNzc2BcbiAgOmhvc3Qge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIG1pbi1oZWlnaHQ6IDM2cHg7XG4gICAgcGFkZGluZzogOHB4IDMycHggOHB4IDEwcHg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBmb250LWZhbWlseTogdmFyKC0tbWF0ZXJpYWwtZm9udC1mYW1pbHkpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tbWF0ZXJpYWwtc21hbGwtZm9udC1zaXplKTtcbiAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgfVxuXG4gIC8qIEl0J3MgdGhlIGxpc3QtYm94J3MgcmVzcG9uc2liaWxpdHkgdG8gYWRkIHRoZSBmb2N1cyBzdHlsZSAqL1xuICA6aG9zdChbZm9jdXNlZF0pIHtcbiAgICBvdXRsaW5lOiBub25lO1xuICB9XG5cbiAgLyogQ2hlY2ttYXJrICovXG4gIFtwYXJ0PSdjaGVja21hcmsnXTo6YmVmb3JlIHtcbiAgICBkaXNwbGF5OiB2YXIoLS1fbWF0ZXJpYWwtaXRlbS1zZWxlY3RlZC1pY29uLWRpc3BsYXksIG5vbmUpO1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIGZvbnQtZmFtaWx5OiBtYXRlcmlhbC1pY29ucztcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICB3aWR0aDogMjRweDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xuICAgIGNvbG9yOiB2YXIoLS1tYXRlcmlhbC1zZWNvbmRhcnktdGV4dC1jb2xvcik7XG4gICAgZmxleDogbm9uZTtcbiAgfVxuXG4gIDpob3N0KFtzZWxlY3RlZF0pIFtwYXJ0PSdjaGVja21hcmsnXTo6YmVmb3JlIHtcbiAgICBjb250ZW50OiB2YXIoLS1tYXRlcmlhbC1pY29ucy1jaGVjayk7XG4gIH1cblxuICBAbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpIHtcbiAgICA6aG9zdCg6aG92ZXI6bm90KFtkaXNhYmxlZF0pKSB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1zZWNvbmRhcnktYmFja2dyb3VuZC1jb2xvcik7XG4gICAgfVxuXG4gICAgOmhvc3QoW2ZvY3VzZWRdOm5vdChbZGlzYWJsZWRdKSkge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbWF0ZXJpYWwtZGl2aWRlci1jb2xvcik7XG4gICAgfVxuICB9XG5cbiAgLyogRGlzYWJsZWQgKi9cbiAgOmhvc3QoW2Rpc2FibGVkXSkge1xuICAgIGNvbG9yOiB2YXIoLS1tYXRlcmlhbC1kaXNhYmxlZC10ZXh0LWNvbG9yKTtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cblxuICAvKiBSVEwgc3BlY2lmaWMgc3R5bGVzICovXG4gIDpob3N0KFtkaXI9J3J0bCddKSB7XG4gICAgcGFkZGluZzogOHB4IDEwcHggOHB4IDMycHg7XG4gIH1cblxuICA6aG9zdChbZGlyPSdydGwnXSkgW3BhcnQ9J2NoZWNrbWFyayddOjpiZWZvcmUge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcbiAgfVxuYDtcblxucmVnaXN0ZXJTdHlsZXMoJ3ZhYWRpbi1pdGVtJywgaXRlbSwgeyBtb2R1bGVJZDogJ21hdGVyaWFsLWl0ZW0nIH0pO1xuXG5leHBvcnQgeyBpdGVtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/color.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/color.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"colorBase\": () => (/* binding */ colorBase),\n/* harmony export */   \"colorDark\": () => (/* binding */ colorDark),\n/* harmony export */   \"colorLight\": () => (/* binding */ colorLight)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"./node_modules/@vaadin/vaadin-material-styles/version.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\nconst colorLight = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  :host {\n    /* Text colors */\n    --material-body-text-color: var(--light-theme-text-color, rgba(0, 0, 0, 0.87));\n    --material-secondary-text-color: var(--light-theme-secondary-color, rgba(0, 0, 0, 0.54));\n    --material-disabled-text-color: var(--light-theme-disabled-color, rgba(0, 0, 0, 0.38));\n\n    /* Primary colors */\n    --material-primary-color: var(--primary-color, #6200ee);\n    --material-primary-contrast-color: var(--dark-theme-base-color, #fff);\n    --material-primary-text-color: var(--material-primary-color);\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #b00020);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--light-theme-background-color, #fff);\n    --material-secondary-background-color: var(--light-theme-secondary-background-color, #f5f5f5);\n    --material-disabled-color: rgba(0, 0, 0, 0.26);\n\n    /* Divider colors */\n    --material-divider-color: rgba(0, 0, 0, 0.12);\n\n    /* Undocumented internal properties (prefixed with three dashes) */\n\n    /* Text field tweaks */\n    --_material-text-field-input-line-background-color: initial;\n    --_material-text-field-input-line-opacity: initial;\n    --_material-text-field-input-line-hover-opacity: initial;\n    --_material-text-field-focused-label-opacity: initial;\n\n    /* Button tweaks */\n    --_material-button-raised-background-color: initial;\n    --_material-button-outline-color: initial;\n\n    /* Grid tweaks */\n    --_material-grid-row-hover-background-color: initial;\n\n    /* Split layout tweaks */\n    --_material-split-layout-splitter-background-color: initial;\n\n    background-color: var(--material-background-color);\n    color: var(--material-body-text-color);\n  }\n\n  [theme~='dark'] {\n    /* Text colors */\n    --material-body-text-color: var(--dark-theme-text-color, rgba(255, 255, 255, 1));\n    --material-secondary-text-color: var(--dark-theme-secondary-color, rgba(255, 255, 255, 0.7));\n    --material-disabled-text-color: var(--dark-theme-disabled-color, rgba(255, 255, 255, 0.5));\n\n    /* Primary colors */\n    --material-primary-color: var(--light-primary-color, #7e3ff2);\n    --material-primary-text-color: #b794f6;\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #de2839);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--dark-theme-background-color, #303030);\n    --material-secondary-background-color: var(--dark-theme-secondary-background-color, #3b3b3b);\n    --material-disabled-color: rgba(255, 255, 255, 0.3);\n\n    /* Divider colors */\n    --material-divider-color: rgba(255, 255, 255, 0.12);\n\n    /* Undocumented internal properties (prefixed with three dashes) */\n\n    /* Text field tweaks */\n    --_material-text-field-input-line-background-color: #fff;\n    --_material-text-field-input-line-opacity: 0.7;\n    --_material-text-field-input-line-hover-opacity: 1;\n    --_material-text-field-focused-label-opacity: 1;\n\n    /* Button tweaks */\n    --_material-button-raised-background-color: rgba(255, 255, 255, 0.08);\n    --_material-button-outline-color: rgba(255, 255, 255, 0.2);\n\n    /* Grid tweaks */\n    --_material-grid-row-hover-background-color: rgba(255, 255, 255, 0.08);\n    --_material-grid-row-selected-overlay-opacity: 0.16;\n\n    /* Split layout tweaks */\n    --_material-split-layout-splitter-background-color: rgba(255, 255, 255, 0.8);\n\n    background-color: var(--material-background-color);\n    color: var(--material-body-text-color);\n  }\n\n  a {\n    color: inherit;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.registerStyles)('', colorLight, {\n  moduleId: 'material-color-light'\n});\nconst colorDark = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  :host {\n    /* Text colors */\n    --material-body-text-color: var(--dark-theme-text-color, rgba(255, 255, 255, 1));\n    --material-secondary-text-color: var(--dark-theme-secondary-color, rgba(255, 255, 255, 0.7));\n    --material-disabled-text-color: var(--dark-theme-disabled-color, rgba(255, 255, 255, 0.5));\n\n    /* Primary colors */\n    --material-primary-color: var(--light-primary-color, #7e3ff2);\n    --material-primary-text-color: #b794f6;\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #de2839);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--dark-theme-background-color, #303030);\n    --material-secondary-background-color: var(--dark-theme-secondary-background-color, #3b3b3b);\n    --material-disabled-color: rgba(255, 255, 255, 0.3);\n\n    /* Divider colors */\n    --material-divider-color: rgba(255, 255, 255, 0.12);\n\n    /* Undocumented internal properties (prefixed with three dashes) */\n\n    /* Text field tweaks */\n    --_material-text-field-input-line-background-color: #fff;\n    --_material-text-field-input-line-opacity: 0.7;\n    --_material-text-field-input-line-hover-opacity: 1;\n    --_material-text-field-focused-label-opacity: 1;\n\n    /* Button tweaks */\n    --_material-button-raised-background-color: rgba(255, 255, 255, 0.08);\n    --_material-button-outline-color: rgba(255, 255, 255, 0.2);\n\n    /* Grid tweaks */\n    --_material-grid-row-hover-background-color: rgba(255, 255, 255, 0.08);\n    --_material-grid-row-selected-overlay-opacity: 0.16;\n\n    /* Split layout tweaks */\n    --_material-split-layout-splitter-background-color: rgba(255, 255, 255, 0.8);\n\n    background-color: var(--material-background-color);\n    color: var(--material-body-text-color);\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.registerStyles)('', colorDark, {\n  moduleId: 'material-color-dark'\n});\nconst colorBase = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  :host {\n    /* Text colors */\n    --material-body-text-color: var(--light-theme-text-color, rgba(0, 0, 0, 0.87));\n    --material-secondary-text-color: var(--light-theme-secondary-color, rgba(0, 0, 0, 0.54));\n    --material-disabled-text-color: var(--light-theme-disabled-color, rgba(0, 0, 0, 0.38));\n\n    /* Primary colors */\n    --material-primary-color: var(--primary-color, #6200ee);\n    --material-primary-contrast-color: var(--dark-theme-base-color, #fff);\n    --material-primary-text-color: var(--material-primary-color);\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #b00020);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--light-theme-background-color, #fff);\n    --material-secondary-background-color: var(--light-theme-secondary-background-color, #f5f5f5);\n    --material-disabled-color: rgba(0, 0, 0, 0.26);\n\n    /* Divider colors */\n    --material-divider-color: rgba(0, 0, 0, 0.12);\n  }\n`;\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${colorBase.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2NvbG9yLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2NvbG9yLmpzPzVkY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgJy4vdmVyc2lvbi5qcyc7XG5pbXBvcnQgeyBjc3MsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuY29uc3QgY29sb3JMaWdodCA9IGNzc2BcbiAgOmhvc3Qge1xuICAgIC8qIFRleHQgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1ib2R5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXRleHQtY29sb3IsIHJnYmEoMCwgMCwgMCwgMC44NykpO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjU0KSk7XG4gICAgLS1tYXRlcmlhbC1kaXNhYmxlZC10ZXh0LWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1kaXNhYmxlZC1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjM4KSk7XG5cbiAgICAvKiBQcmltYXJ5IGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtcHJpbWFyeS1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvciwgIzYyMDBlZSk7XG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LWNvbnRyYXN0LWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLWJhc2UtY29sb3IsICNmZmYpO1xuICAgIC0tbWF0ZXJpYWwtcHJpbWFyeS10ZXh0LWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yKTtcblxuICAgIC8qIEVycm9yIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtZXJyb3ItY29sb3I6IHZhcigtLWVycm9yLWNvbG9yLCAjYjAwMDIwKTtcbiAgICAtLW1hdGVyaWFsLWVycm9yLXRleHQtY29sb3I6IHZhcigtLW1hdGVyaWFsLWVycm9yLWNvbG9yKTtcblxuICAgIC8qIEJhY2tncm91bmQgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKTtcbiAgICAtLW1hdGVyaWFsLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1zZWNvbmRhcnktYmFja2dyb3VuZC1jb2xvciwgI2Y1ZjVmNSk7XG4gICAgLS1tYXRlcmlhbC1kaXNhYmxlZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjI2KTtcblxuICAgIC8qIERpdmlkZXIgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1kaXZpZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMTIpO1xuXG4gICAgLyogVW5kb2N1bWVudGVkIGludGVybmFsIHByb3BlcnRpZXMgKHByZWZpeGVkIHdpdGggdGhyZWUgZGFzaGVzKSAqL1xuXG4gICAgLyogVGV4dCBmaWVsZCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtYmFja2dyb3VuZC1jb2xvcjogaW5pdGlhbDtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtb3BhY2l0eTogaW5pdGlhbDtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtaG92ZXItb3BhY2l0eTogaW5pdGlhbDtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWZvY3VzZWQtbGFiZWwtb3BhY2l0eTogaW5pdGlhbDtcblxuICAgIC8qIEJ1dHRvbiB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1idXR0b24tcmFpc2VkLWJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XG4gICAgLS1fbWF0ZXJpYWwtYnV0dG9uLW91dGxpbmUtY29sb3I6IGluaXRpYWw7XG5cbiAgICAvKiBHcmlkIHR3ZWFrcyAqL1xuICAgIC0tX21hdGVyaWFsLWdyaWQtcm93LWhvdmVyLWJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XG5cbiAgICAvKiBTcGxpdCBsYXlvdXQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtc3BsaXQtbGF5b3V0LXNwbGl0dGVyLWJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgICBjb2xvcjogdmFyKC0tbWF0ZXJpYWwtYm9keS10ZXh0LWNvbG9yKTtcbiAgfVxuXG4gIFt0aGVtZX49J2RhcmsnXSB7XG4gICAgLyogVGV4dCBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWJvZHktdGV4dC1jb2xvcjogdmFyKC0tZGFyay10aGVtZS10ZXh0LWNvbG9yLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDEpKTtcbiAgICAtLW1hdGVyaWFsLXNlY29uZGFyeS10ZXh0LWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLXNlY29uZGFyeS1jb2xvciwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpKTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLXRleHQtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtZGlzYWJsZWQtY29sb3IsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSk7XG5cbiAgICAvKiBQcmltYXJ5IGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtcHJpbWFyeS1jb2xvcjogdmFyKC0tbGlnaHQtcHJpbWFyeS1jb2xvciwgIzdlM2ZmMik7XG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LXRleHQtY29sb3I6ICNiNzk0ZjY7XG5cbiAgICAvKiBFcnJvciBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWVycm9yLWNvbG9yOiB2YXIoLS1lcnJvci1jb2xvciwgI2RlMjgzOSk7XG4gICAgLS1tYXRlcmlhbC1lcnJvci10ZXh0LWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1lcnJvci1jb2xvcik7XG5cbiAgICAvKiBCYWNrZ3JvdW5kIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZGFyay10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yLCAjMzAzMDMwKTtcbiAgICAtLW1hdGVyaWFsLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yLCAjM2IzYjNiKTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG5cbiAgICAvKiBEaXZpZGVyIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtZGl2aWRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKTtcblxuICAgIC8qIFVuZG9jdW1lbnRlZCBpbnRlcm5hbCBwcm9wZXJ0aWVzIChwcmVmaXhlZCB3aXRoIHRocmVlIGRhc2hlcykgKi9cblxuICAgIC8qIFRleHQgZmllbGQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtdGV4dC1maWVsZC1pbnB1dC1saW5lLWJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgLS1fbWF0ZXJpYWwtdGV4dC1maWVsZC1pbnB1dC1saW5lLW9wYWNpdHk6IDAuNztcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtaG92ZXItb3BhY2l0eTogMTtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWZvY3VzZWQtbGFiZWwtb3BhY2l0eTogMTtcblxuICAgIC8qIEJ1dHRvbiB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1idXR0b24tcmFpc2VkLWJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOCk7XG4gICAgLS1fbWF0ZXJpYWwtYnV0dG9uLW91dGxpbmUtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcblxuICAgIC8qIEdyaWQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtZ3JpZC1yb3ctaG92ZXItYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KTtcbiAgICAtLV9tYXRlcmlhbC1ncmlkLXJvdy1zZWxlY3RlZC1vdmVybGF5LW9wYWNpdHk6IDAuMTY7XG5cbiAgICAvKiBTcGxpdCBsYXlvdXQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtc3BsaXQtbGF5b3V0LXNwbGl0dGVyLWJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW1hdGVyaWFsLWJhY2tncm91bmQtY29sb3IpO1xuICAgIGNvbG9yOiB2YXIoLS1tYXRlcmlhbC1ib2R5LXRleHQtY29sb3IpO1xuICB9XG5cbiAgYSB7XG4gICAgY29sb3I6IGluaGVyaXQ7XG4gIH1cbmA7XG5cbnJlZ2lzdGVyU3R5bGVzKCcnLCBjb2xvckxpZ2h0LCB7IG1vZHVsZUlkOiAnbWF0ZXJpYWwtY29sb3ItbGlnaHQnIH0pO1xuXG5jb25zdCBjb2xvckRhcmsgPSBjc3NgXG4gIDpob3N0IHtcbiAgICAvKiBUZXh0IGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtYm9keS10ZXh0LWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLXRleHQtY29sb3IsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMSkpO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LXRleHQtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWNvbG9yLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNykpO1xuICAgIC0tbWF0ZXJpYWwtZGlzYWJsZWQtdGV4dC1jb2xvcjogdmFyKC0tZGFyay10aGVtZS1kaXNhYmxlZC1jb2xvciwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpKTtcblxuICAgIC8qIFByaW1hcnkgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1saWdodC1wcmltYXJ5LWNvbG9yLCAjN2UzZmYyKTtcbiAgICAtLW1hdGVyaWFsLXByaW1hcnktdGV4dC1jb2xvcjogI2I3OTRmNjtcblxuICAgIC8qIEVycm9yIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtZXJyb3ItY29sb3I6IHZhcigtLWVycm9yLWNvbG9yLCAjZGUyODM5KTtcbiAgICAtLW1hdGVyaWFsLWVycm9yLXRleHQtY29sb3I6IHZhcigtLW1hdGVyaWFsLWVycm9yLWNvbG9yKTtcblxuICAgIC8qIEJhY2tncm91bmQgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLWJhY2tncm91bmQtY29sb3IsICMzMDMwMzApO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LWJhY2tncm91bmQtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWJhY2tncm91bmQtY29sb3IsICMzYjNiM2IpO1xuICAgIC0tbWF0ZXJpYWwtZGlzYWJsZWQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcblxuICAgIC8qIERpdmlkZXIgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1kaXZpZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpO1xuXG4gICAgLyogVW5kb2N1bWVudGVkIGludGVybmFsIHByb3BlcnRpZXMgKHByZWZpeGVkIHdpdGggdGhyZWUgZGFzaGVzKSAqL1xuXG4gICAgLyogVGV4dCBmaWVsZCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtb3BhY2l0eTogMC43O1xuICAgIC0tX21hdGVyaWFsLXRleHQtZmllbGQtaW5wdXQtbGluZS1ob3Zlci1vcGFjaXR5OiAxO1xuICAgIC0tX21hdGVyaWFsLXRleHQtZmllbGQtZm9jdXNlZC1sYWJlbC1vcGFjaXR5OiAxO1xuXG4gICAgLyogQnV0dG9uIHR3ZWFrcyAqL1xuICAgIC0tX21hdGVyaWFsLWJ1dHRvbi1yYWlzZWQtYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KTtcbiAgICAtLV9tYXRlcmlhbC1idXR0b24tb3V0bGluZS1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuXG4gICAgLyogR3JpZCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1ncmlkLXJvdy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDgpO1xuICAgIC0tX21hdGVyaWFsLWdyaWQtcm93LXNlbGVjdGVkLW92ZXJsYXktb3BhY2l0eTogMC4xNjtcblxuICAgIC8qIFNwbGl0IGxheW91dCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1zcGxpdC1sYXlvdXQtc3BsaXR0ZXItYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbWF0ZXJpYWwtYmFja2dyb3VuZC1jb2xvcik7XG4gICAgY29sb3I6IHZhcigtLW1hdGVyaWFsLWJvZHktdGV4dC1jb2xvcik7XG4gIH1cbmA7XG5cbnJlZ2lzdGVyU3R5bGVzKCcnLCBjb2xvckRhcmssIHsgbW9kdWxlSWQ6ICdtYXRlcmlhbC1jb2xvci1kYXJrJyB9KTtcblxuY29uc3QgY29sb3JCYXNlID0gY3NzYFxuICA6aG9zdCB7XG4gICAgLyogVGV4dCBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWJvZHktdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjg3KSk7XG4gICAgLS1tYXRlcmlhbC1zZWNvbmRhcnktdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtc2Vjb25kYXJ5LWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuNTQpKTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuMzgpKTtcblxuICAgIC8qIFByaW1hcnkgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yLCAjNjIwMGVlKTtcbiAgICAtLW1hdGVyaWFsLXByaW1hcnktY29udHJhc3QtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtYmFzZS1jb2xvciwgI2ZmZik7XG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LXRleHQtY29sb3I6IHZhcigtLW1hdGVyaWFsLXByaW1hcnktY29sb3IpO1xuXG4gICAgLyogRXJyb3IgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1lcnJvci1jb2xvcjogdmFyKC0tZXJyb3ItY29sb3IsICNiMDAwMjApO1xuICAgIC0tbWF0ZXJpYWwtZXJyb3ItdGV4dC1jb2xvcjogdmFyKC0tbWF0ZXJpYWwtZXJyb3ItY29sb3IpO1xuXG4gICAgLyogQmFja2dyb3VuZCBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWJhY2tncm91bmQtY29sb3IsICNmZmYpO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LWJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yLCAjZjVmNWY1KTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMjYpO1xuXG4gICAgLyogRGl2aWRlciBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWRpdmlkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xMik7XG4gIH1cbmA7XG5cbmNvbnN0ICR0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuJHRwbC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7Y29sb3JCYXNlLnRvU3RyaW5nKCkucmVwbGFjZSgnOmhvc3QnLCAnaHRtbCcpfTwvc3R5bGU+YDtcbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJHRwbC5jb250ZW50KTtcblxuZXhwb3J0IHsgY29sb3JCYXNlLCBjb2xvckRhcmssIGNvbG9yTGlnaHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/color.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"menuOverlay\": () => (/* binding */ menuOverlay)\n/* harmony export */ });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/mixins/overlay.js */ \"./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\nconst menuOverlay = _overlay_js__WEBPACK_IMPORTED_MODULE_1__.overlay;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__.registerStyles)('', menuOverlay, {\n  moduleId: 'material-menu-overlay'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9tZW51LW92ZXJsYXkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvbWl4aW5zL21lbnUtb3ZlcmxheS5qcz8zNjJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0ICcuLi9jb2xvci5qcyc7XG5pbXBvcnQgJy4vb3ZlcmxheS5qcyc7XG5pbXBvcnQgeyBvdmVybGF5IH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9vdmVybGF5LmpzJztcbmltcG9ydCB7IHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuY29uc3QgbWVudU92ZXJsYXkgPSBvdmVybGF5O1xuXG5yZWdpc3RlclN0eWxlcygnJywgbWVudU92ZXJsYXksIHsgbW9kdWxlSWQ6ICdtYXRlcmlhbC1tZW51LW92ZXJsYXknIH0pO1xuXG5leHBvcnQgeyBtZW51T3ZlcmxheSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"overlay\": () => (/* binding */ overlay)\n/* harmony export */ });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _typography_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typography.js */ \"./node_modules/@vaadin/vaadin-material-styles/typography.js\");\n/* harmony import */ var _typography_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_typography_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _shadow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shadow.js */ \"./node_modules/@vaadin/vaadin-material-styles/shadow.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\nconst overlay = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.css`\n  :host {\n    top: 16px;\n    right: 16px;\n    /* TODO (@jouni): remove unnecessary multiplication after https://github.com/vaadin/vaadin-overlay/issues/90 is fixed */\n    bottom: calc(1px * var(--vaadin-overlay-viewport-bottom) + 16px);\n    left: 16px;\n  }\n\n  [part='overlay'] {\n    background-color: var(--material-background-color);\n    border-radius: 4px;\n    box-shadow: var(--material-shadow-elevation-4dp);\n    color: var(--material-body-text-color);\n    font-family: var(--material-font-family);\n    font-size: var(--material-body-font-size);\n    font-weight: 400;\n  }\n\n  [part='content'] {\n    padding: 8px 0;\n  }\n\n  [part='backdrop'] {\n    opacity: 0.2;\n    animation: 0.2s vaadin-overlay-backdrop-enter;\n    will-change: opacity;\n  }\n\n  @keyframes vaadin-overlay-backdrop-enter {\n    0% {\n      opacity: 0;\n    }\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.registerStyles)('', overlay, {\n  moduleId: 'material-overlay'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9vdmVybGF5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLW1hdGVyaWFsLXN0eWxlcy9taXhpbnMvb3ZlcmxheS5qcz81OGI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0ICcuLi9jb2xvci5qcyc7XG5pbXBvcnQgJy4uL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0ICcuLi9zaGFkb3cuanMnO1xuaW1wb3J0IHsgY3NzLCByZWdpc3RlclN0eWxlcyB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5cbmNvbnN0IG92ZXJsYXkgPSBjc3NgXG4gIDpob3N0IHtcbiAgICB0b3A6IDE2cHg7XG4gICAgcmlnaHQ6IDE2cHg7XG4gICAgLyogVE9ETyAoQGpvdW5pKTogcmVtb3ZlIHVubmVjZXNzYXJ5IG11bHRpcGxpY2F0aW9uIGFmdGVyIGh0dHBzOi8vZ2l0aHViLmNvbS92YWFkaW4vdmFhZGluLW92ZXJsYXkvaXNzdWVzLzkwIGlzIGZpeGVkICovXG4gICAgYm90dG9tOiBjYWxjKDFweCAqIHZhcigtLXZhYWRpbi1vdmVybGF5LXZpZXdwb3J0LWJvdHRvbSkgKyAxNnB4KTtcbiAgICBsZWZ0OiAxNnB4O1xuICB9XG5cbiAgW3BhcnQ9J292ZXJsYXknXSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbWF0ZXJpYWwtYmFja2dyb3VuZC1jb2xvcik7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGJveC1zaGFkb3c6IHZhcigtLW1hdGVyaWFsLXNoYWRvdy1lbGV2YXRpb24tNGRwKTtcbiAgICBjb2xvcjogdmFyKC0tbWF0ZXJpYWwtYm9keS10ZXh0LWNvbG9yKTtcbiAgICBmb250LWZhbWlseTogdmFyKC0tbWF0ZXJpYWwtZm9udC1mYW1pbHkpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tbWF0ZXJpYWwtYm9keS1mb250LXNpemUpO1xuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIH1cblxuICBbcGFydD0nY29udGVudCddIHtcbiAgICBwYWRkaW5nOiA4cHggMDtcbiAgfVxuXG4gIFtwYXJ0PSdiYWNrZHJvcCddIHtcbiAgICBvcGFjaXR5OiAwLjI7XG4gICAgYW5pbWF0aW9uOiAwLjJzIHZhYWRpbi1vdmVybGF5LWJhY2tkcm9wLWVudGVyO1xuICAgIHdpbGwtY2hhbmdlOiBvcGFjaXR5O1xuICB9XG5cbiAgQGtleWZyYW1lcyB2YWFkaW4tb3ZlcmxheS1iYWNrZHJvcC1lbnRlciB7XG4gICAgMCUge1xuICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG4gIH1cbmA7XG5cbnJlZ2lzdGVyU3R5bGVzKCcnLCBvdmVybGF5LCB7IG1vZHVsZUlkOiAnbWF0ZXJpYWwtb3ZlcmxheScgfSk7XG5cbmV4cG9ydCB7IG92ZXJsYXkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/shadow.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/shadow.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shadow\": () => (/* binding */ shadow)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"./node_modules/@vaadin/vaadin-material-styles/version.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\nconst shadow = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  /* prettier-ignore */\n  :host {\n    /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */\n    --material-shadow-elevation-2dp: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);\n    --material-shadow-elevation-3dp: 0 3px 4px 0 rgba(0, 0, 0, 0.14), 0 1px 8px 0 rgba(0, 0, 0, 0.12), 0 3px 3px -2px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-4dp: 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12), 0 2px 4px -1px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-6dp: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-8dp: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-12dp: 0 12px 16px 1px rgba(0, 0, 0, 0.14), 0 4px 22px 3px rgba(0, 0, 0, 0.12), 0 6px 7px -4px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-16dp: 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-24dp: 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12), 0 11px 15px -7px rgba(0, 0, 0, 0.4);\n  }\n`;\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${shadow.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL3NoYWRvdy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLW1hdGVyaWFsLXN0eWxlcy9zaGFkb3cuanM/ODViYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCAnLi92ZXJzaW9uLmpzJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5cbmNvbnN0IHNoYWRvdyA9IGNzc2BcbiAgLyogcHJldHRpZXItaWdub3JlICovXG4gIDpob3N0IHtcbiAgICAvKiBmcm9tIGh0dHA6Ly9jb2RlcGVuLmlvL3NoeW5kbWFuL3Blbi9jNTM5NGRkZjJlOGIyYTVjOTE4NTkwNGI1NzQyMWNkYiAqL1xuICAgIC0tbWF0ZXJpYWwtc2hhZG93LWVsZXZhdGlvbi0yZHA6IDAgMnB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICAtLW1hdGVyaWFsLXNoYWRvdy1lbGV2YXRpb24tM2RwOiAwIDNweCA0cHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDFweCA4cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDNweCAzcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgLS1tYXRlcmlhbC1zaGFkb3ctZWxldmF0aW9uLTRkcDogMCA0cHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAxcHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgMnB4IDRweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAtLW1hdGVyaWFsLXNoYWRvdy1lbGV2YXRpb24tNmRwOiAwIDZweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAxcHggMThweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgM3B4IDVweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAtLW1hdGVyaWFsLXNoYWRvdy1lbGV2YXRpb24tOGRwOiAwIDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDNweCAxNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgLS1tYXRlcmlhbC1zaGFkb3ctZWxldmF0aW9uLTEyZHA6IDAgMTJweCAxNnB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDRweCAyMnB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDZweCA3cHggLTRweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgLS1tYXRlcmlhbC1zaGFkb3ctZWxldmF0aW9uLTE2ZHA6IDAgMTZweCAyNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDZweCAzMHB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDhweCAxMHB4IC01cHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgIC0tbWF0ZXJpYWwtc2hhZG93LWVsZXZhdGlvbi0yNGRwOiAwIDI0cHggMzhweCAzcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCA5cHggNDZweCA4cHggcmdiYSgwLCAwLCAwLCAwLjEyKSwgMCAxMXB4IDE1cHggLTdweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gIH1cbmA7XG5cbmNvbnN0ICR0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuJHRwbC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7c2hhZG93LnRvU3RyaW5nKCkucmVwbGFjZSgnOmhvc3QnLCAnaHRtbCcpfTwvc3R5bGU+YDtcbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJHRwbC5jb250ZW50KTtcblxuZXhwb3J0IHsgc2hhZG93IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/shadow.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Material\": () => (/* binding */ Material)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nclass Material extends HTMLElement {\n  static get version() {\n    return '22.0.16';\n  }\n\n}\n\ncustomElements.define('vaadin-material-styles', Material);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL3ZlcnNpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTs7QUFNQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL3ZlcnNpb24uanM/MzYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuICcyMi4wLjE2JztcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMnLCBNYXRlcmlhbCk7XG5cbmV4cG9ydCB7IE1hdGVyaWFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/version.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-overlay/src/vaadin-focusables-helper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-overlay/src/vaadin-focusables-helper.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FocusablesHelper\": () => (/* binding */ FocusablesHelper)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * `Polymer.IronFocusablesHelper` relies on some Polymer-specific legacy API,\n * especially the `root` property which does not exist for native shadow DOM.\n * That's why we have this helper here.\n * See https://github.com/PolymerElements/iron-overlay-behavior/issues/282\n */\nclass FocusablesHelper {\n  /**\n   * Returns a sorted array of tabbable nodes, including the root node.\n   * It searches the tabbable nodes in the light and shadow dom of the children,\n   * sorting the result by tabindex.\n   * @param {!Node} node\n   * @return {!Array<!HTMLElement>}\n   */\n  static getTabbableNodes(node) {\n    const result = []; // If there is at least one element with tabindex > 0, we need to sort\n    // the final array by tabindex.\n\n    const needsSortByTabIndex = this._collectTabbableNodes(node, result);\n\n    if (needsSortByTabIndex) {\n      return this._sortByTabIndex(result);\n    }\n\n    return result;\n  }\n  /**\n   * Returns if a element is focusable.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n\n\n  static isFocusable(element) {\n    // From http://stackoverflow.com/a/1600194/4228703:\n    // There isn't a definite list, it's up to the browser. The only\n    // standard we have is DOM Level 2 HTML\n    // https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the\n    // only elements that have a focus() method are HTMLInputElement,\n    // HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This\n    // notably omits HTMLButtonElement and HTMLAreaElement. Referring to these\n    // tests with tabbables in different browsers\n    // http://allyjs.io/data-tables/focusable.html\n    // Elements that cannot be focused if they have [disabled] attribute.\n    if (element.matches('input, select, textarea, button, object')) {\n      return element.matches(':not([disabled])');\n    } // Elements that can be focused even if they have [disabled] attribute.\n\n\n    return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\n  }\n  /**\n   * Returns if a element is tabbable. To be tabbable, a element must be\n   * focusable, visible, and with a tabindex !== -1.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n\n\n  static isTabbable(element) {\n    return this.isFocusable(element) && element.matches(':not([tabindex=\"-1\"])') && this._isVisible(element);\n  }\n  /**\n   * Returns the normalized element tabindex. If not focusable, returns -1.\n   * It checks for the attribute \"tabindex\" instead of the element property\n   * `tabIndex` since browsers assign different values to it.\n   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n   * @param {!HTMLElement} element\n   * @return {!number}\n   * @private\n   */\n\n\n  static _normalizedTabIndex(element) {\n    if (this.isFocusable(element)) {\n      const tabIndex = element.getAttribute('tabindex') || 0;\n      return Number(tabIndex);\n    }\n\n    return -1;\n  }\n  /**\n   * Searches for nodes that are tabbable and adds them to the `result` array.\n   * Returns if the `result` array needs to be sorted by tabindex.\n   * @param {!Node} node The starting point for the search; added to `result` if tabbable.\n   * @param {!Array<!HTMLElement>} result\n   * @return {boolean}\n   * @private\n   */\n\n\n  static _collectTabbableNodes(node, result) {\n    // If not an element or not visible, no need to explore children.\n    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {\n      return false;\n    }\n\n    const element =\n    /** @type {!HTMLElement} */\n    node;\n\n    const tabIndex = this._normalizedTabIndex(element);\n\n    let needsSort = tabIndex > 0;\n\n    if (tabIndex >= 0) {\n      result.push(element);\n    } // In ShadowDOM v1, tab order is affected by the order of distribution.\n    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];\n    // in ShadowDOM v0 tab order is not affected by the distribution order,\n    // in fact getTabbableNodes(#root) returns [#B, #A].\n    //  <div id=\"root\">\n    //   <!-- shadow -->\n    //     <slot name=\"a\">\n    //     <slot name=\"b\">\n    //   <!-- /shadow -->\n    //   <input id=\"A\" slot=\"a\">\n    //   <input id=\"B\" slot=\"b\" tabindex=\"1\">\n    //  </div>\n\n\n    let children;\n\n    if (element.localName === 'slot') {\n      children = element.assignedNodes({\n        flatten: true\n      });\n    } else {\n      // Use shadow root if possible, will check for distributed nodes.\n      children = (element.shadowRoot || element).children;\n    }\n\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        // Ensure method is always invoked to collect tabbable children.\n        needsSort = this._collectTabbableNodes(children[i], result) || needsSort;\n      }\n    }\n\n    return needsSort;\n  }\n  /**\n   * Returns false if the element has `visibility: hidden` or `display: none`\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   * @private\n   */\n\n\n  static _isVisible(element) {\n    // Check inline style first to save a re-flow. If looks good, check also\n    // computed style.\n    let style = element.style;\n\n    if (style.visibility !== 'hidden' && style.display !== 'none') {\n      style = window.getComputedStyle(element);\n      return style.visibility !== 'hidden' && style.display !== 'none';\n    }\n\n    return false;\n  }\n  /**\n   * Sorts an array of tabbable elements by tabindex. Returns a new array.\n   * @param {!Array<!HTMLElement>} tabbables\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n\n\n  static _sortByTabIndex(tabbables) {\n    // Implement a merge sort as Array.prototype.sort does a non-stable sort\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n    const len = tabbables.length;\n\n    if (len < 2) {\n      return tabbables;\n    }\n\n    const pivot = Math.ceil(len / 2);\n\n    const left = this._sortByTabIndex(tabbables.slice(0, pivot));\n\n    const right = this._sortByTabIndex(tabbables.slice(pivot));\n\n    return this._mergeSortByTabIndex(left, right);\n  }\n  /**\n   * Merge sort iterator, merges the two arrays into one, sorted by tab index.\n   * @param {!Array<!HTMLElement>} left\n   * @param {!Array<!HTMLElement>} right\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n\n\n  static _mergeSortByTabIndex(left, right) {\n    const result = [];\n\n    while (left.length > 0 && right.length > 0) {\n      if (this._hasLowerTabOrder(left[0], right[0])) {\n        result.push(right.shift());\n      } else {\n        result.push(left.shift());\n      }\n    }\n\n    return result.concat(left, right);\n  }\n  /**\n   * Returns if element `a` has lower tab order compared to element `b`\n   * (both elements are assumed to be focusable and tabbable).\n   * Elements with tabindex = 0 have lower tab order compared to elements\n   * with tabindex > 0.\n   * If both have same tabindex, it returns false.\n   * @param {!HTMLElement} a\n   * @param {!HTMLElement} b\n   * @return {boolean}\n   * @private\n   */\n\n\n  static _hasLowerTabOrder(a, b) {\n    // Normalize tabIndexes\n    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n    const ati = Math.max(a.tabIndex, 0);\n    const bti = Math.max(b.tabIndex, 0);\n    return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n  }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS9zcmMvdmFhZGluLWZvY3VzYWJsZXMtaGVscGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9MQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS9zcmMvdmFhZGluLWZvY3VzYWJsZXMtaGVscGVyLmpzPzBmMWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cblxuLyoqXG4gKiBgUG9seW1lci5Jcm9uRm9jdXNhYmxlc0hlbHBlcmAgcmVsaWVzIG9uIHNvbWUgUG9seW1lci1zcGVjaWZpYyBsZWdhY3kgQVBJLFxuICogZXNwZWNpYWxseSB0aGUgYHJvb3RgIHByb3BlcnR5IHdoaWNoIGRvZXMgbm90IGV4aXN0IGZvciBuYXRpdmUgc2hhZG93IERPTS5cbiAqIFRoYXQncyB3aHkgd2UgaGF2ZSB0aGlzIGhlbHBlciBoZXJlLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyRWxlbWVudHMvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lzc3Vlcy8yODJcbiAqL1xuY2xhc3MgRm9jdXNhYmxlc0hlbHBlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc29ydGVkIGFycmF5IG9mIHRhYmJhYmxlIG5vZGVzLCBpbmNsdWRpbmcgdGhlIHJvb3Qgbm9kZS5cbiAgICogSXQgc2VhcmNoZXMgdGhlIHRhYmJhYmxlIG5vZGVzIGluIHRoZSBsaWdodCBhbmQgc2hhZG93IGRvbSBvZiB0aGUgY2hpbGRyZW4sXG4gICAqIHNvcnRpbmcgdGhlIHJlc3VsdCBieSB0YWJpbmRleC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHshQXJyYXk8IUhUTUxFbGVtZW50Pn1cbiAgICovXG4gIHN0YXRpYyBnZXRUYWJiYWJsZU5vZGVzKG5vZGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAvLyBJZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZWxlbWVudCB3aXRoIHRhYmluZGV4ID4gMCwgd2UgbmVlZCB0byBzb3J0XG4gICAgLy8gdGhlIGZpbmFsIGFycmF5IGJ5IHRhYmluZGV4LlxuICAgIGNvbnN0IG5lZWRzU29ydEJ5VGFiSW5kZXggPSB0aGlzLl9jb2xsZWN0VGFiYmFibGVOb2Rlcyhub2RlLCByZXN1bHQpO1xuICAgIGlmIChuZWVkc1NvcnRCeVRhYkluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc29ydEJ5VGFiSW5kZXgocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIGEgZWxlbWVudCBpcyBmb2N1c2FibGUuXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNGb2N1c2FibGUoZWxlbWVudCkge1xuICAgIC8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYwMDE5NC80MjI4NzAzOlxuICAgIC8vIFRoZXJlIGlzbid0IGEgZGVmaW5pdGUgbGlzdCwgaXQncyB1cCB0byB0aGUgYnJvd3Nlci4gVGhlIG9ubHlcbiAgICAvLyBzdGFuZGFyZCB3ZSBoYXZlIGlzIERPTSBMZXZlbCAyIEhUTUxcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwsIGFjY29yZGluZyB0byB3aGljaCB0aGVcbiAgICAvLyBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGZvY3VzKCkgbWV0aG9kIGFyZSBIVE1MSW5wdXRFbGVtZW50LFxuICAgIC8vIEhUTUxTZWxlY3RFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50IGFuZCBIVE1MQW5jaG9yRWxlbWVudC4gVGhpc1xuICAgIC8vIG5vdGFibHkgb21pdHMgSFRNTEJ1dHRvbkVsZW1lbnQgYW5kIEhUTUxBcmVhRWxlbWVudC4gUmVmZXJyaW5nIHRvIHRoZXNlXG4gICAgLy8gdGVzdHMgd2l0aCB0YWJiYWJsZXMgaW4gZGlmZmVyZW50IGJyb3dzZXJzXG4gICAgLy8gaHR0cDovL2FsbHlqcy5pby9kYXRhLXRhYmxlcy9mb2N1c2FibGUuaHRtbFxuXG4gICAgLy8gRWxlbWVudHMgdGhhdCBjYW5ub3QgYmUgZm9jdXNlZCBpZiB0aGV5IGhhdmUgW2Rpc2FibGVkXSBhdHRyaWJ1dGUuXG4gICAgaWYgKGVsZW1lbnQubWF0Y2hlcygnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwgb2JqZWN0JykpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoJzpub3QoW2Rpc2FibGVkXSknKTtcbiAgICB9XG4gICAgLy8gRWxlbWVudHMgdGhhdCBjYW4gYmUgZm9jdXNlZCBldmVuIGlmIHRoZXkgaGF2ZSBbZGlzYWJsZWRdIGF0dHJpYnV0ZS5cbiAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpZnJhbWUsIFt0YWJpbmRleF0sIFtjb250ZW50RWRpdGFibGVdJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiBhIGVsZW1lbnQgaXMgdGFiYmFibGUuIFRvIGJlIHRhYmJhYmxlLCBhIGVsZW1lbnQgbXVzdCBiZVxuICAgKiBmb2N1c2FibGUsIHZpc2libGUsIGFuZCB3aXRoIGEgdGFiaW5kZXggIT09IC0xLlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVGFiYmFibGUoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmlzRm9jdXNhYmxlKGVsZW1lbnQpICYmIGVsZW1lbnQubWF0Y2hlcygnOm5vdChbdGFiaW5kZXg9XCItMVwiXSknKSAmJiB0aGlzLl9pc1Zpc2libGUoZWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBlbGVtZW50IHRhYmluZGV4LiBJZiBub3QgZm9jdXNhYmxlLCByZXR1cm5zIC0xLlxuICAgKiBJdCBjaGVja3MgZm9yIHRoZSBhdHRyaWJ1dGUgXCJ0YWJpbmRleFwiIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgcHJvcGVydHlcbiAgICogYHRhYkluZGV4YCBzaW5jZSBicm93c2VycyBhc3NpZ24gZGlmZmVyZW50IHZhbHVlcyB0byBpdC5cbiAgICogZS5nLiBpbiBGaXJlZm94IGA8ZGl2IGNvbnRlbnRlZGl0YWJsZT5gIGhhcyBgdGFiSW5kZXggPSAtMWBcbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7IW51bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfbm9ybWFsaXplZFRhYkluZGV4KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5pc0ZvY3VzYWJsZShlbGVtZW50KSkge1xuICAgICAgY29uc3QgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAwO1xuICAgICAgcmV0dXJuIE51bWJlcih0YWJJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3Igbm9kZXMgdGhhdCBhcmUgdGFiYmFibGUgYW5kIGFkZHMgdGhlbSB0byB0aGUgYHJlc3VsdGAgYXJyYXkuXG4gICAqIFJldHVybnMgaWYgdGhlIGByZXN1bHRgIGFycmF5IG5lZWRzIHRvIGJlIHNvcnRlZCBieSB0YWJpbmRleC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBzZWFyY2g7IGFkZGVkIHRvIGByZXN1bHRgIGlmIHRhYmJhYmxlLlxuICAgKiBAcGFyYW0geyFBcnJheTwhSFRNTEVsZW1lbnQ+fSByZXN1bHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfY29sbGVjdFRhYmJhYmxlTm9kZXMobm9kZSwgcmVzdWx0KSB7XG4gICAgLy8gSWYgbm90IGFuIGVsZW1lbnQgb3Igbm90IHZpc2libGUsIG5vIG5lZWQgdG8gZXhwbG9yZSBjaGlsZHJlbi5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgfHwgIXRoaXMuX2lzVmlzaWJsZShub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovIChub2RlKTtcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuX25vcm1hbGl6ZWRUYWJJbmRleChlbGVtZW50KTtcbiAgICBsZXQgbmVlZHNTb3J0ID0gdGFiSW5kZXggPiAwO1xuICAgIGlmICh0YWJJbmRleCA+PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBJbiBTaGFkb3dET00gdjEsIHRhYiBvcmRlciBpcyBhZmZlY3RlZCBieSB0aGUgb3JkZXIgb2YgZGlzdHJpYnV0aW9uLlxuICAgIC8vIEUuZy4gZ2V0VGFiYmFibGVOb2Rlcygjcm9vdCkgaW4gU2hhZG93RE9NIHYxIHNob3VsZCByZXR1cm4gWyNBLCAjQl07XG4gICAgLy8gaW4gU2hhZG93RE9NIHYwIHRhYiBvcmRlciBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIGRpc3RyaWJ1dGlvbiBvcmRlcixcbiAgICAvLyBpbiBmYWN0IGdldFRhYmJhYmxlTm9kZXMoI3Jvb3QpIHJldHVybnMgWyNCLCAjQV0uXG4gICAgLy8gIDxkaXYgaWQ9XCJyb290XCI+XG4gICAgLy8gICA8IS0tIHNoYWRvdyAtLT5cbiAgICAvLyAgICAgPHNsb3QgbmFtZT1cImFcIj5cbiAgICAvLyAgICAgPHNsb3QgbmFtZT1cImJcIj5cbiAgICAvLyAgIDwhLS0gL3NoYWRvdyAtLT5cbiAgICAvLyAgIDxpbnB1dCBpZD1cIkFcIiBzbG90PVwiYVwiPlxuICAgIC8vICAgPGlucHV0IGlkPVwiQlwiIHNsb3Q9XCJiXCIgdGFiaW5kZXg9XCIxXCI+XG4gICAgLy8gIDwvZGl2PlxuICAgIGxldCBjaGlsZHJlbjtcbiAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgY2hpbGRyZW4gPSBlbGVtZW50LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2Ugc2hhZG93IHJvb3QgaWYgcG9zc2libGUsIHdpbGwgY2hlY2sgZm9yIGRpc3RyaWJ1dGVkIG5vZGVzLlxuICAgICAgY2hpbGRyZW4gPSAoZWxlbWVudC5zaGFkb3dSb290IHx8IGVsZW1lbnQpLmNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRW5zdXJlIG1ldGhvZCBpcyBhbHdheXMgaW52b2tlZCB0byBjb2xsZWN0IHRhYmJhYmxlIGNoaWxkcmVuLlxuICAgICAgICBuZWVkc1NvcnQgPSB0aGlzLl9jb2xsZWN0VGFiYmFibGVOb2RlcyhjaGlsZHJlbltpXSwgcmVzdWx0KSB8fCBuZWVkc1NvcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZWVkc1NvcnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYHZpc2liaWxpdHk6IGhpZGRlbmAgb3IgYGRpc3BsYXk6IG5vbmVgXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgX2lzVmlzaWJsZShlbGVtZW50KSB7XG4gICAgLy8gQ2hlY2sgaW5saW5lIHN0eWxlIGZpcnN0IHRvIHNhdmUgYSByZS1mbG93LiBJZiBsb29rcyBnb29kLCBjaGVjayBhbHNvXG4gICAgLy8gY29tcHV0ZWQgc3R5bGUuXG4gICAgbGV0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBpZiAoc3R5bGUudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbicgJiYgc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHN0eWxlLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nICYmIHN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIGFuIGFycmF5IG9mIHRhYmJhYmxlIGVsZW1lbnRzIGJ5IHRhYmluZGV4LiBSZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgKiBAcGFyYW0geyFBcnJheTwhSFRNTEVsZW1lbnQ+fSB0YWJiYWJsZXNcbiAgICogQHJldHVybiB7IUFycmF5PCFIVE1MRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgX3NvcnRCeVRhYkluZGV4KHRhYmJhYmxlcykge1xuICAgIC8vIEltcGxlbWVudCBhIG1lcmdlIHNvcnQgYXMgQXJyYXkucHJvdG90eXBlLnNvcnQgZG9lcyBhIG5vbi1zdGFibGUgc29ydFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnRcbiAgICBjb25zdCBsZW4gPSB0YWJiYWJsZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gPCAyKSB7XG4gICAgICByZXR1cm4gdGFiYmFibGVzO1xuICAgIH1cbiAgICBjb25zdCBwaXZvdCA9IE1hdGguY2VpbChsZW4gLyAyKTtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5fc29ydEJ5VGFiSW5kZXgodGFiYmFibGVzLnNsaWNlKDAsIHBpdm90KSk7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLl9zb3J0QnlUYWJJbmRleCh0YWJiYWJsZXMuc2xpY2UocGl2b3QpKTtcbiAgICByZXR1cm4gdGhpcy5fbWVyZ2VTb3J0QnlUYWJJbmRleChsZWZ0LCByaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2Ugc29ydCBpdGVyYXRvciwgbWVyZ2VzIHRoZSB0d28gYXJyYXlzIGludG8gb25lLCBzb3J0ZWQgYnkgdGFiIGluZGV4LlxuICAgKiBAcGFyYW0geyFBcnJheTwhSFRNTEVsZW1lbnQ+fSBsZWZ0XG4gICAqIEBwYXJhbSB7IUFycmF5PCFIVE1MRWxlbWVudD59IHJpZ2h0XG4gICAqIEByZXR1cm4geyFBcnJheTwhSFRNTEVsZW1lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIF9tZXJnZVNvcnRCeVRhYkluZGV4KGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKGxlZnQubGVuZ3RoID4gMCAmJiByaWdodC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5faGFzTG93ZXJUYWJPcmRlcihsZWZ0WzBdLCByaWdodFswXSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmlnaHQuc2hpZnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChsZWZ0LnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuY29uY2F0KGxlZnQsIHJpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIGVsZW1lbnQgYGFgIGhhcyBsb3dlciB0YWIgb3JkZXIgY29tcGFyZWQgdG8gZWxlbWVudCBgYmBcbiAgICogKGJvdGggZWxlbWVudHMgYXJlIGFzc3VtZWQgdG8gYmUgZm9jdXNhYmxlIGFuZCB0YWJiYWJsZSkuXG4gICAqIEVsZW1lbnRzIHdpdGggdGFiaW5kZXggPSAwIGhhdmUgbG93ZXIgdGFiIG9yZGVyIGNvbXBhcmVkIHRvIGVsZW1lbnRzXG4gICAqIHdpdGggdGFiaW5kZXggPiAwLlxuICAgKiBJZiBib3RoIGhhdmUgc2FtZSB0YWJpbmRleCwgaXQgcmV0dXJucyBmYWxzZS5cbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGFcbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfaGFzTG93ZXJUYWJPcmRlcihhLCBiKSB7XG4gICAgLy8gTm9ybWFsaXplIHRhYkluZGV4ZXNcbiAgICAvLyBlLmcuIGluIEZpcmVmb3ggYDxkaXYgY29udGVudGVkaXRhYmxlPmAgaGFzIGB0YWJJbmRleCA9IC0xYFxuICAgIGNvbnN0IGF0aSA9IE1hdGgubWF4KGEudGFiSW5kZXgsIDApO1xuICAgIGNvbnN0IGJ0aSA9IE1hdGgubWF4KGIudGFiSW5kZXgsIDApO1xuICAgIHJldHVybiBhdGkgPT09IDAgfHwgYnRpID09PSAwID8gYnRpID4gYXRpIDogYXRpID4gYnRpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZvY3VzYWJsZXNIZWxwZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-overlay/src/vaadin-focusables-helper.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay-position-mixin.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay-position-mixin.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PositionMixin\": () => (/* binding */ PositionMixin)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom'\n};\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right'\n};\n/**\n * @polymerMixin\n */\n\nconst PositionMixin = superClass => class PositionMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * The element next to which this overlay should be aligned.\n       * The position of the overlay relative to the positionTarget can be adjusted\n       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n       * and `noVerticalOverlap`.\n       */\n      positionTarget: {\n        type: Object,\n        value: null\n      },\n\n      /**\n       * When `positionTarget` is set, this property defines whether to align the overlay's\n       * left or right side to the target element by default.\n       * Possible values are `start` and `end`.\n       * RTL is taken into account when interpreting the value.\n       * The overlay is automatically flipped to the opposite side when it doesn't fit into\n       * the default side defined by this property.\n       */\n      horizontalAlign: {\n        type: String,\n        value: 'start'\n      },\n\n      /**\n       * When `positionTarget` is set, this property defines whether to align the overlay's\n       * top or bottom side to the target element by default.\n       * Possible values are `top` and `bottom`.\n       * The overlay is automatically flipped to the opposite side when it doesn't fit into\n       * the default side defined by this property.\n       */\n      verticalAlign: {\n        type: String,\n        value: 'top'\n      },\n\n      /**\n       * When `positionTarget` is set, this property defines whether the overlay should overlap\n       * the target element in the x-axis, or be positioned right next to it.\n       */\n      noHorizontalOverlap: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * When `positionTarget` is set, this property defines whether the overlay should overlap\n       * the target element in the y-axis, or be positioned right above/below it.\n       */\n      noVerticalOverlap: {\n        type: Boolean,\n        value: false\n      }\n    };\n  }\n\n  static get observers() {\n    return ['__positionSettingsChanged(positionTarget, horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap)', '__overlayOpenedChanged(opened)'];\n  }\n\n  constructor() {\n    super();\n    this.__boundUpdatePosition = this._updatePosition.bind(this);\n  }\n\n  __overlayOpenedChanged(opened) {\n    // Toggle the event listeners that cause the overlay to update its position\n    ['scroll', 'resize'].forEach(eventName => {\n      if (opened) {\n        window.addEventListener(eventName, this.__boundUpdatePosition);\n      } else {\n        window.removeEventListener(eventName, this.__boundUpdatePosition);\n      }\n    });\n\n    if (opened) {\n      const computedStyle = getComputedStyle(this);\n\n      if (!this.__margins) {\n        this.__margins = {};\n        ['top', 'bottom', 'left', 'right'].forEach(propName => {\n          this.__margins[propName] = parseInt(computedStyle[propName], 10);\n        });\n      }\n\n      this.setAttribute('dir', computedStyle.direction);\n\n      this._updatePosition(); // Schedule another position update (to cover virtual keyboard opening for example)\n\n\n      requestAnimationFrame(() => this._updatePosition());\n    }\n  }\n\n  get __isRTL() {\n    return this.getAttribute('dir') === 'rtl';\n  }\n\n  __positionSettingsChanged() {\n    this._updatePosition();\n  }\n\n  _updatePosition() {\n    if (!this.positionTarget || !this.opened) {\n      return;\n    }\n\n    const targetRect = this.positionTarget.getBoundingClientRect(); // Detect the desired alignment and update the layout accordingly\n\n    const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n\n    this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n\n    const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, this.__isRTL);\n\n    const flexStart = !this.__isRTL && shouldAlignStartHorizontally || this.__isRTL && !shouldAlignStartHorizontally;\n    this.style.alignItems = flexStart ? 'flex-start' : 'flex-end'; // Get the overlay rect after possible overlay alignment changes\n\n    const overlayRect = this.getBoundingClientRect(); // Obtain vertical positioning properties\n\n    const verticalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noVerticalOverlap, PROP_NAMES_VERTICAL, this, shouldAlignStartVertically); // Obtain horizontal positioning properties\n\n\n    const horizontalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL, this, shouldAlignStartHorizontally); // Apply the positioning properties to the overlay\n\n\n    Object.assign(this.style, verticalProps, horizontalProps);\n    this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n    this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n    this.toggleAttribute('end-aligned', !flexStart);\n    this.toggleAttribute('start-aligned', flexStart);\n  }\n\n  __shouldAlignStartHorizontally(targetRect, rtl) {\n    // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n    // smaller than its current space before the fit-calculations.\n    const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n    this.__oldContentWidth = this.$.overlay.offsetWidth;\n    const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n    const defaultAlignLeft = !rtl && this.horizontalAlign === 'start' || rtl && this.horizontalAlign === 'end';\n    return this.__shouldAlignStart(targetRect, contentWidth, viewportWidth, this.__margins, defaultAlignLeft, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL);\n  }\n\n  __shouldAlignStartVertically(targetRect) {\n    // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n    // smaller than its current space before the fit-calculations.\n    const contentHeight = Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n    this.__oldContentHeight = this.$.overlay.offsetHeight;\n    const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n    const defaultAlignTop = this.verticalAlign === 'top';\n    return this.__shouldAlignStart(targetRect, contentHeight, viewportHeight, this.__margins, defaultAlignTop, this.noVerticalOverlap, PROP_NAMES_VERTICAL);\n  }\n\n  __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n    const spaceForStartAlignment = viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n    const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n    const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n    const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n    const shouldGoToDefaultSide = spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n    return defaultAlignStart === shouldGoToDefaultSide;\n  }\n  /**\n   * Returns an object with CSS position properties to set,\n   * e.g. { top: \"100px\", bottom: \"\" }\n   */\n\n\n  __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n    const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n    const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n    const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n    const diff = overlayRect[shouldAlignStart ? propNames.start : propNames.end] - targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n    return {\n      [cssPropNameToSet]: currentValue + diff * (shouldAlignStart ? -1 : 1) + 'px',\n      [cssPropNameToClear]: ''\n    };\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS9zcmMvdmFhZGluLW92ZXJsYXktcG9zaXRpb24tbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQWxEQTtBQXVEQTs7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFHQTs7QUFDQTs7QUFFQTs7QUFDQTtBQUVBOztBQUdBOztBQUdBOzs7QUFVQTs7O0FBVUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBU0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFsT0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLW92ZXJsYXkvc3JjL3ZhYWRpbi1vdmVybGF5LXBvc2l0aW9uLW1peGluLmpzP2IzZTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbmNvbnN0IFBST1BfTkFNRVNfVkVSVElDQUwgPSB7XG4gIHN0YXJ0OiAndG9wJyxcbiAgZW5kOiAnYm90dG9tJyxcbn07XG5cbmNvbnN0IFBST1BfTkFNRVNfSE9SSVpPTlRBTCA9IHtcbiAgc3RhcnQ6ICdsZWZ0JyxcbiAgZW5kOiAncmlnaHQnLFxufTtcblxuLyoqXG4gKiBAcG9seW1lck1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBQb3NpdGlvbk1peGluID0gKHN1cGVyQ2xhc3MpID0+XG4gIGNsYXNzIFBvc2l0aW9uTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVsZW1lbnQgbmV4dCB0byB3aGljaCB0aGlzIG92ZXJsYXkgc2hvdWxkIGJlIGFsaWduZWQuXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSByZWxhdGl2ZSB0byB0aGUgcG9zaXRpb25UYXJnZXQgY2FuIGJlIGFkanVzdGVkXG4gICAgICAgICAqIHdpdGggcHJvcGVydGllcyBgaG9yaXpvbnRhbEFsaWduYCwgYHZlcnRpY2FsQWxpZ25gLCBgbm9Ib3Jpem9udGFsT3ZlcmxhcGBcbiAgICAgICAgICogYW5kIGBub1ZlcnRpY2FsT3ZlcmxhcGAuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvblRhcmdldDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgcG9zaXRpb25UYXJnZXRgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIHdoZXRoZXIgdG8gYWxpZ24gdGhlIG92ZXJsYXknc1xuICAgICAgICAgKiBsZWZ0IG9yIHJpZ2h0IHNpZGUgdG8gdGhlIHRhcmdldCBlbGVtZW50IGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmUgYHN0YXJ0YCBhbmQgYGVuZGAuXG4gICAgICAgICAqIFJUTCBpcyB0YWtlbiBpbnRvIGFjY291bnQgd2hlbiBpbnRlcnByZXRpbmcgdGhlIHZhbHVlLlxuICAgICAgICAgKiBUaGUgb3ZlcmxheSBpcyBhdXRvbWF0aWNhbGx5IGZsaXBwZWQgdG8gdGhlIG9wcG9zaXRlIHNpZGUgd2hlbiBpdCBkb2Vzbid0IGZpdCBpbnRvXG4gICAgICAgICAqIHRoZSBkZWZhdWx0IHNpZGUgZGVmaW5lZCBieSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgaG9yaXpvbnRhbEFsaWduOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAnc3RhcnQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBwb3NpdGlvblRhcmdldGAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IGRlZmluZXMgd2hldGhlciB0byBhbGlnbiB0aGUgb3ZlcmxheSdzXG4gICAgICAgICAqIHRvcCBvciBib3R0b20gc2lkZSB0byB0aGUgdGFyZ2V0IGVsZW1lbnQgYnkgZGVmYXVsdC5cbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgdG9wYCBhbmQgYGJvdHRvbWAuXG4gICAgICAgICAqIFRoZSBvdmVybGF5IGlzIGF1dG9tYXRpY2FsbHkgZmxpcHBlZCB0byB0aGUgb3Bwb3NpdGUgc2lkZSB3aGVuIGl0IGRvZXNuJ3QgZml0IGludG9cbiAgICAgICAgICogdGhlIGRlZmF1bHQgc2lkZSBkZWZpbmVkIGJ5IHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHZhbHVlOiAndG9wJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgcG9zaXRpb25UYXJnZXRgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIHdoZXRoZXIgdGhlIG92ZXJsYXkgc2hvdWxkIG92ZXJsYXBcbiAgICAgICAgICogdGhlIHRhcmdldCBlbGVtZW50IGluIHRoZSB4LWF4aXMsIG9yIGJlIHBvc2l0aW9uZWQgcmlnaHQgbmV4dCB0byBpdC5cbiAgICAgICAgICovXG4gICAgICAgIG5vSG9yaXpvbnRhbE92ZXJsYXA6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgcG9zaXRpb25UYXJnZXRgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIHdoZXRoZXIgdGhlIG92ZXJsYXkgc2hvdWxkIG92ZXJsYXBcbiAgICAgICAgICogdGhlIHRhcmdldCBlbGVtZW50IGluIHRoZSB5LWF4aXMsIG9yIGJlIHBvc2l0aW9uZWQgcmlnaHQgYWJvdmUvYmVsb3cgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBub1ZlcnRpY2FsT3ZlcmxhcDoge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnX19wb3NpdGlvblNldHRpbmdzQ2hhbmdlZChwb3NpdGlvblRhcmdldCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBub0hvcml6b250YWxPdmVybGFwLCBub1ZlcnRpY2FsT3ZlcmxhcCknLFxuICAgICAgICAnX19vdmVybGF5T3BlbmVkQ2hhbmdlZChvcGVuZWQpJyxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLl9fYm91bmRVcGRhdGVQb3NpdGlvbiA9IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgX19vdmVybGF5T3BlbmVkQ2hhbmdlZChvcGVuZWQpIHtcbiAgICAgIC8vIFRvZ2dsZSB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgY2F1c2UgdGhlIG92ZXJsYXkgdG8gdXBkYXRlIGl0cyBwb3NpdGlvblxuICAgICAgWydzY3JvbGwnLCAncmVzaXplJ10uZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIGlmIChvcGVuZWQpIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMuX19ib3VuZFVwZGF0ZVBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMuX19ib3VuZFVwZGF0ZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcGVuZWQpIHtcbiAgICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5fX21hcmdpbnMpIHtcbiAgICAgICAgICB0aGlzLl9fbWFyZ2lucyA9IHt9O1xuICAgICAgICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaCgocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX19tYXJnaW5zW3Byb3BOYW1lXSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbcHJvcE5hbWVdLCAxMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2RpcicsIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAvLyBTY2hlZHVsZSBhbm90aGVyIHBvc2l0aW9uIHVwZGF0ZSAodG8gY292ZXIgdmlydHVhbCBrZXlib2FyZCBvcGVuaW5nIGZvciBleGFtcGxlKVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IF9faXNSVEwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcicpID09PSAncnRsJztcbiAgICB9XG5cbiAgICBfX3Bvc2l0aW9uU2V0dGluZ3NDaGFuZ2VkKCkge1xuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucG9zaXRpb25UYXJnZXQgfHwgIXRoaXMub3BlbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRoaXMucG9zaXRpb25UYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIERldGVjdCB0aGUgZGVzaXJlZCBhbGlnbm1lbnQgYW5kIHVwZGF0ZSB0aGUgbGF5b3V0IGFjY29yZGluZ2x5XG4gICAgICBjb25zdCBzaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSA9IHRoaXMuX19zaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSh0YXJnZXRSZWN0KTtcbiAgICAgIHRoaXMuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBzaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSA/ICdmbGV4LXN0YXJ0JyA6ICdmbGV4LWVuZCc7XG5cbiAgICAgIGNvbnN0IHNob3VsZEFsaWduU3RhcnRIb3Jpem9udGFsbHkgPSB0aGlzLl9fc2hvdWxkQWxpZ25TdGFydEhvcml6b250YWxseSh0YXJnZXRSZWN0LCB0aGlzLl9faXNSVEwpO1xuICAgICAgY29uc3QgZmxleFN0YXJ0ID1cbiAgICAgICAgKCF0aGlzLl9faXNSVEwgJiYgc2hvdWxkQWxpZ25TdGFydEhvcml6b250YWxseSkgfHwgKHRoaXMuX19pc1JUTCAmJiAhc2hvdWxkQWxpZ25TdGFydEhvcml6b250YWxseSk7XG4gICAgICB0aGlzLnN0eWxlLmFsaWduSXRlbXMgPSBmbGV4U3RhcnQgPyAnZmxleC1zdGFydCcgOiAnZmxleC1lbmQnO1xuXG4gICAgICAvLyBHZXQgdGhlIG92ZXJsYXkgcmVjdCBhZnRlciBwb3NzaWJsZSBvdmVybGF5IGFsaWdubWVudCBjaGFuZ2VzXG4gICAgICBjb25zdCBvdmVybGF5UmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIE9idGFpbiB2ZXJ0aWNhbCBwb3NpdGlvbmluZyBwcm9wZXJ0aWVzXG4gICAgICBjb25zdCB2ZXJ0aWNhbFByb3BzID0gdGhpcy5fX2NhbGN1bGF0ZVBvc2l0aW9uSW5PbmVEaW1lbnNpb24oXG4gICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgIG92ZXJsYXlSZWN0LFxuICAgICAgICB0aGlzLm5vVmVydGljYWxPdmVybGFwLFxuICAgICAgICBQUk9QX05BTUVTX1ZFUlRJQ0FMLFxuICAgICAgICB0aGlzLFxuICAgICAgICBzaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSxcbiAgICAgICk7XG5cbiAgICAgIC8vIE9idGFpbiBob3Jpem9udGFsIHBvc2l0aW9uaW5nIHByb3BlcnRpZXNcbiAgICAgIGNvbnN0IGhvcml6b250YWxQcm9wcyA9IHRoaXMuX19jYWxjdWxhdGVQb3NpdGlvbkluT25lRGltZW5zaW9uKFxuICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICBvdmVybGF5UmVjdCxcbiAgICAgICAgdGhpcy5ub0hvcml6b250YWxPdmVybGFwLFxuICAgICAgICBQUk9QX05BTUVTX0hPUklaT05UQUwsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHNob3VsZEFsaWduU3RhcnRIb3Jpem9udGFsbHksXG4gICAgICApO1xuXG4gICAgICAvLyBBcHBseSB0aGUgcG9zaXRpb25pbmcgcHJvcGVydGllcyB0byB0aGUgb3ZlcmxheVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0eWxlLCB2ZXJ0aWNhbFByb3BzLCBob3Jpem9udGFsUHJvcHMpO1xuXG4gICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZSgnYm90dG9tLWFsaWduZWQnLCAhc2hvdWxkQWxpZ25TdGFydFZlcnRpY2FsbHkpO1xuICAgICAgdGhpcy50b2dnbGVBdHRyaWJ1dGUoJ3RvcC1hbGlnbmVkJywgc2hvdWxkQWxpZ25TdGFydFZlcnRpY2FsbHkpO1xuXG4gICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZSgnZW5kLWFsaWduZWQnLCAhZmxleFN0YXJ0KTtcbiAgICAgIHRoaXMudG9nZ2xlQXR0cmlidXRlKCdzdGFydC1hbGlnbmVkJywgZmxleFN0YXJ0KTtcbiAgICB9XG5cbiAgICBfX3Nob3VsZEFsaWduU3RhcnRIb3Jpem9udGFsbHkodGFyZ2V0UmVjdCwgcnRsKSB7XG4gICAgICAvLyBVc2luZyBwcmV2aW91cyBzaXplIHRvIGZpeCBhIGNhc2Ugd2hlcmUgd2luZG93IHJlc2l6ZSBtYXkgY2F1c2UgdGhlIG92ZXJsYXkgdG8gYmUgc3F1ZWV6ZWRcbiAgICAgIC8vIHNtYWxsZXIgdGhhbiBpdHMgY3VycmVudCBzcGFjZSBiZWZvcmUgdGhlIGZpdC1jYWxjdWxhdGlvbnMuXG4gICAgICBjb25zdCBjb250ZW50V2lkdGggPSBNYXRoLm1heCh0aGlzLl9fb2xkQ29udGVudFdpZHRoIHx8IDAsIHRoaXMuJC5vdmVybGF5Lm9mZnNldFdpZHRoKTtcbiAgICAgIHRoaXMuX19vbGRDb250ZW50V2lkdGggPSB0aGlzLiQub3ZlcmxheS5vZmZzZXRXaWR0aDtcblxuICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgICAgY29uc3QgZGVmYXVsdEFsaWduTGVmdCA9ICghcnRsICYmIHRoaXMuaG9yaXpvbnRhbEFsaWduID09PSAnc3RhcnQnKSB8fCAocnRsICYmIHRoaXMuaG9yaXpvbnRhbEFsaWduID09PSAnZW5kJyk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc2hvdWxkQWxpZ25TdGFydChcbiAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgY29udGVudFdpZHRoLFxuICAgICAgICB2aWV3cG9ydFdpZHRoLFxuICAgICAgICB0aGlzLl9fbWFyZ2lucyxcbiAgICAgICAgZGVmYXVsdEFsaWduTGVmdCxcbiAgICAgICAgdGhpcy5ub0hvcml6b250YWxPdmVybGFwLFxuICAgICAgICBQUk9QX05BTUVTX0hPUklaT05UQUwsXG4gICAgICApO1xuICAgIH1cblxuICAgIF9fc2hvdWxkQWxpZ25TdGFydFZlcnRpY2FsbHkodGFyZ2V0UmVjdCkge1xuICAgICAgLy8gVXNpbmcgcHJldmlvdXMgc2l6ZSB0byBmaXggYSBjYXNlIHdoZXJlIHdpbmRvdyByZXNpemUgbWF5IGNhdXNlIHRoZSBvdmVybGF5IHRvIGJlIHNxdWVlemVkXG4gICAgICAvLyBzbWFsbGVyIHRoYW4gaXRzIGN1cnJlbnQgc3BhY2UgYmVmb3JlIHRoZSBmaXQtY2FsY3VsYXRpb25zLlxuICAgICAgY29uc3QgY29udGVudEhlaWdodCA9IE1hdGgubWF4KHRoaXMuX19vbGRDb250ZW50SGVpZ2h0IHx8IDAsIHRoaXMuJC5vdmVybGF5Lm9mZnNldEhlaWdodCk7XG4gICAgICB0aGlzLl9fb2xkQ29udGVudEhlaWdodCA9IHRoaXMuJC5vdmVybGF5Lm9mZnNldEhlaWdodDtcblxuICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgY29uc3QgZGVmYXVsdEFsaWduVG9wID0gdGhpcy52ZXJ0aWNhbEFsaWduID09PSAndG9wJztcblxuICAgICAgcmV0dXJuIHRoaXMuX19zaG91bGRBbGlnblN0YXJ0KFxuICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICBjb250ZW50SGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydEhlaWdodCxcbiAgICAgICAgdGhpcy5fX21hcmdpbnMsXG4gICAgICAgIGRlZmF1bHRBbGlnblRvcCxcbiAgICAgICAgdGhpcy5ub1ZlcnRpY2FsT3ZlcmxhcCxcbiAgICAgICAgUFJPUF9OQU1FU19WRVJUSUNBTCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgX19zaG91bGRBbGlnblN0YXJ0KHRhcmdldFJlY3QsIGNvbnRlbnRTaXplLCB2aWV3cG9ydFNpemUsIG1hcmdpbnMsIGRlZmF1bHRBbGlnblN0YXJ0LCBub092ZXJsYXAsIHByb3BOYW1lcykge1xuICAgICAgY29uc3Qgc3BhY2VGb3JTdGFydEFsaWdubWVudCA9XG4gICAgICAgIHZpZXdwb3J0U2l6ZSAtIHRhcmdldFJlY3Rbbm9PdmVybGFwID8gcHJvcE5hbWVzLmVuZCA6IHByb3BOYW1lcy5zdGFydF0gLSBtYXJnaW5zW3Byb3BOYW1lcy5lbmRdO1xuICAgICAgY29uc3Qgc3BhY2VGb3JFbmRBbGlnbm1lbnQgPSB0YXJnZXRSZWN0W25vT3ZlcmxhcCA/IHByb3BOYW1lcy5zdGFydCA6IHByb3BOYW1lcy5lbmRdIC0gbWFyZ2luc1twcm9wTmFtZXMuc3RhcnRdO1xuXG4gICAgICBjb25zdCBzcGFjZUZvckRlZmF1bHRBbGlnbm1lbnQgPSBkZWZhdWx0QWxpZ25TdGFydCA/IHNwYWNlRm9yU3RhcnRBbGlnbm1lbnQgOiBzcGFjZUZvckVuZEFsaWdubWVudDtcbiAgICAgIGNvbnN0IHNwYWNlRm9yT3RoZXJBbGlnbm1lbnQgPSBkZWZhdWx0QWxpZ25TdGFydCA/IHNwYWNlRm9yRW5kQWxpZ25tZW50IDogc3BhY2VGb3JTdGFydEFsaWdubWVudDtcblxuICAgICAgY29uc3Qgc2hvdWxkR29Ub0RlZmF1bHRTaWRlID1cbiAgICAgICAgc3BhY2VGb3JEZWZhdWx0QWxpZ25tZW50ID4gc3BhY2VGb3JPdGhlckFsaWdubWVudCB8fCBzcGFjZUZvckRlZmF1bHRBbGlnbm1lbnQgPiBjb250ZW50U2l6ZTtcblxuICAgICAgcmV0dXJuIGRlZmF1bHRBbGlnblN0YXJ0ID09PSBzaG91bGRHb1RvRGVmYXVsdFNpZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBDU1MgcG9zaXRpb24gcHJvcGVydGllcyB0byBzZXQsXG4gICAgICogZS5nLiB7IHRvcDogXCIxMDBweFwiLCBib3R0b206IFwiXCIgfVxuICAgICAqL1xuICAgIF9fY2FsY3VsYXRlUG9zaXRpb25Jbk9uZURpbWVuc2lvbih0YXJnZXRSZWN0LCBvdmVybGF5UmVjdCwgbm9PdmVybGFwLCBwcm9wTmFtZXMsIG92ZXJsYXksIHNob3VsZEFsaWduU3RhcnQpIHtcbiAgICAgIGNvbnN0IGNzc1Byb3BOYW1lVG9TZXQgPSBzaG91bGRBbGlnblN0YXJ0ID8gcHJvcE5hbWVzLnN0YXJ0IDogcHJvcE5hbWVzLmVuZDtcbiAgICAgIGNvbnN0IGNzc1Byb3BOYW1lVG9DbGVhciA9IHNob3VsZEFsaWduU3RhcnQgPyBwcm9wTmFtZXMuZW5kIDogcHJvcE5hbWVzLnN0YXJ0O1xuXG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KG92ZXJsYXkuc3R5bGVbY3NzUHJvcE5hbWVUb1NldF0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShvdmVybGF5KVtjc3NQcm9wTmFtZVRvU2V0XSk7XG5cbiAgICAgIGNvbnN0IGRpZmYgPVxuICAgICAgICBvdmVybGF5UmVjdFtzaG91bGRBbGlnblN0YXJ0ID8gcHJvcE5hbWVzLnN0YXJ0IDogcHJvcE5hbWVzLmVuZF0gLVxuICAgICAgICB0YXJnZXRSZWN0W25vT3ZlcmxhcCA9PT0gc2hvdWxkQWxpZ25TdGFydCA/IHByb3BOYW1lcy5lbmQgOiBwcm9wTmFtZXMuc3RhcnRdO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBbY3NzUHJvcE5hbWVUb1NldF06IGN1cnJlbnRWYWx1ZSArIGRpZmYgKiAoc2hvdWxkQWxpZ25TdGFydCA/IC0xIDogMSkgKyAncHgnLFxuICAgICAgICBbY3NzUHJvcE5hbWVUb0NsZWFyXTogJycsXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay-position-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OverlayElement\": () => (/* binding */ OverlayElement)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_flattened_nodes_observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/flattened-nodes-observer.js */ \"./node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/render-status.js */ \"./node_modules/@polymer/polymer/lib/utils/render-status.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_templatize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/utils/templatize.js */ \"./node_modules/@polymer/polymer/lib/utils/templatize.js\");\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/component-base/src/browser-utils.js */ \"./node_modules/@vaadin/component-base/src/browser-utils.js\");\n/* harmony import */ var _vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @vaadin/component-base/src/dir-mixin.js */ \"./node_modules/@vaadin/component-base/src/dir-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/* harmony import */ var _vaadin_focusables_helper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vaadin-focusables-helper.js */ \"./node_modules/@vaadin/vaadin-overlay/src/vaadin-focusables-helper.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n\n\n\n/**\n *\n * `<vaadin-overlay>` is a Web Component for creating overlays. The content of the overlay\n * can be populated in two ways: imperatively by using renderer callback function and\n * declaratively by using Polymer's Templates.\n *\n * ### Rendering\n *\n * By default, the overlay uses the content provided by using the renderer callback function.\n *\n * The renderer function provides `root`, `owner`, `model` arguments when applicable.\n * Generate DOM content by using `model` object properties if needed, append it to the `root`\n * element and control the state of the host element by accessing `owner`. Before generating new\n * content, users are able to check if there is already content in `root` for reusing it.\n *\n * ```html\n * <vaadin-overlay id=\"overlay\"></vaadin-overlay>\n * ```\n * ```js\n * const overlay = document.querySelector('#overlay');\n * overlay.renderer = function(root) {\n *  root.textContent = \"Overlay content\";\n * };\n * ```\n *\n * Renderer is called on the opening of the overlay and each time the related model is updated.\n * DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * **NOTE:** when the renderer property is defined, the `<template>` content is not used.\n *\n * ### Templating\n *\n * Alternatively, the content can be provided with Polymer Template.\n * Overlay finds the first child template and uses that in case renderer callback function\n * is not provided. You can also set a custom template using the `template` property.\n *\n * After the content from the template is stamped, the `content` property\n * points to the content container.\n *\n * The overlay provides `forwardHostProp` when calling\n * `Polymer.Templatize.templatize` for the template, so that the bindings\n * from the parent scope propagate to the content.  You can also pass\n * custom `instanceProps` object using the `instanceProps` property.\n *\n * ```html\n * <vaadin-overlay>\n *   <template>Overlay content</template>\n * </vaadin-overlay>\n * ```\n *\n * **NOTE:** when using `instanceProps`: because of the Polymer limitation,\n * every template can only be templatized once, so it is important\n * to set `instanceProps` before the `template` is assigned to the overlay.\n *\n * ### Styling\n *\n * To style the overlay content, use styles in the parent scope:\n *\n * - If the overlay is used in a component, then the component styles\n *   apply the overlay content.\n * - If the overlay is used in the global DOM scope, then global styles\n *   apply to the overlay content.\n *\n * See examples for styling the overlay content in the live demos.\n *\n * The following Shadow DOM parts are available for styling the overlay component itself:\n *\n * Part name  | Description\n * -----------|---------------------------------------------------------|\n * `backdrop` | Backdrop of the overlay\n * `overlay`  | Container for position/sizing/alignment of the content\n * `content`  | Content of the overlay\n *\n * The following state attributes are available for styling:\n *\n * Attribute | Description | Part\n * ---|---|---\n * `opening` | Applied just after the overlay is attached to the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n * `closing` | Applied just before the overlay is detached from the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n *\n * The following custom CSS properties are available for styling:\n *\n * Custom CSS property | Description | Default value\n * ---|---|---\n * `--vaadin-overlay-viewport-bottom` | Bottom offset of the visible viewport area | `0` or detected offset\n *\n * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.\n *\n * @fires {CustomEvent} opened-changed - Fired when the `opened` property changes.\n *\n * @extends HTMLElement\n * @mixes ThemableMixin\n * @mixes DirMixin\n */\n\nclass OverlayElement extends (0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_6__.ThemableMixin)((0,_vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_5__.DirMixin)(_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__.PolymerElement)) {\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__.html`\n      <style>\n        :host {\n          z-index: 200;\n          position: fixed;\n\n          /* Despite of what the names say, <vaadin-overlay> is just a container\n          for position/sizing/alignment. The actual overlay is the overlay part. */\n\n          /* Default position constraints: the entire viewport. Note: themes can\n          override this to introduce gaps between the overlay and the viewport. */\n          top: 0;\n          right: 0;\n          bottom: var(--vaadin-overlay-viewport-bottom);\n          left: 0;\n\n          /* Use flexbox alignment for the overlay part. */\n          display: flex;\n          flex-direction: column; /* makes dropdowns sizing easier */\n          /* Align to center by default. */\n          align-items: center;\n          justify-content: center;\n\n          /* Allow centering when max-width/max-height applies. */\n          margin: auto;\n\n          /* The host is not clickable, only the overlay part is. */\n          pointer-events: none;\n\n          /* Remove tap highlight on touch devices. */\n          -webkit-tap-highlight-color: transparent;\n\n          /* CSS API for host */\n          --vaadin-overlay-viewport-bottom: 0;\n        }\n\n        :host([hidden]),\n        :host(:not([opened]):not([closing])) {\n          display: none !important;\n        }\n\n        [part='overlay'] {\n          -webkit-overflow-scrolling: touch;\n          overflow: auto;\n          pointer-events: auto;\n\n          /* Prevent overflowing the host in MSIE 11 */\n          max-width: 100%;\n          box-sizing: border-box;\n\n          -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */\n        }\n\n        [part='backdrop'] {\n          z-index: -1;\n          content: '';\n          background: rgba(0, 0, 0, 0.5);\n          position: fixed;\n          top: 0;\n          left: 0;\n          bottom: 0;\n          right: 0;\n          pointer-events: auto;\n        }\n      </style>\n\n      <div id=\"backdrop\" part=\"backdrop\" hidden$=\"[[!withBackdrop]]\"></div>\n      <div part=\"overlay\" id=\"overlay\" tabindex=\"0\">\n        <div part=\"content\" id=\"content\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n\n  static get is() {\n    return 'vaadin-overlay';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * When true, the overlay is visible and attached to body.\n       */\n      opened: {\n        type: Boolean,\n        notify: true,\n        observer: '_openedChanged',\n        reflectToAttribute: true\n      },\n\n      /**\n       * Owner element passed with renderer function\n       * @type {HTMLElement}\n       */\n      owner: Element,\n\n      /**\n       * Custom function for rendering the content of the overlay.\n       * Receives three arguments:\n       *\n       * - `root` The root container DOM element. Append your content to it.\n       * - `owner` The host element of the renderer function.\n       * - `model` The object with the properties related with rendering.\n       * @type {OverlayRenderer | null | undefined}\n       */\n      renderer: Function,\n\n      /**\n       * The template of the overlay content.\n       * @type {HTMLTemplateElement | null | undefined}\n       */\n      template: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * Optional argument for `Polymer.Templatize.templatize`.\n       */\n      instanceProps: {\n        type: Object\n      },\n\n      /**\n       * References the content container after the template is stamped.\n       * @type {!HTMLElement | undefined}\n       */\n      content: {\n        type: Object,\n        notify: true\n      },\n\n      /**\n       * When true the overlay has backdrop on top of content when opened.\n       * @type {boolean}\n       */\n      withBackdrop: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n\n      /**\n       * Object with properties that is passed to `renderer` function\n       */\n      model: Object,\n\n      /**\n       * When true the overlay won't disable the main content, showing\n       * it doesnt change the functionality of the user interface.\n       * @type {boolean}\n       */\n      modeless: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_modelessChanged'\n      },\n\n      /**\n       * When set to true, the overlay is hidden. This also closes the overlay\n       * immediately in case there is a closing animation in progress.\n       * @type {boolean}\n       */\n      hidden: {\n        type: Boolean,\n        reflectToAttribute: true,\n        observer: '_hiddenChanged'\n      },\n\n      /**\n       * When true move focus to the first focusable element in the overlay,\n       * or to the overlay if there are no focusable elements.\n       * @type {boolean}\n       */\n      focusTrap: {\n        type: Boolean,\n        value: false\n      },\n\n      /**\n       * Set to true to enable restoring of focus when overlay is closed.\n       * @type {boolean}\n       */\n      restoreFocusOnClose: {\n        type: Boolean,\n        value: false\n      },\n\n      /** @private */\n      _mouseDownInside: {\n        type: Boolean\n      },\n\n      /** @private */\n      _mouseUpInside: {\n        type: Boolean\n      },\n\n      /** @private */\n      _instance: {\n        type: Object\n      },\n\n      /** @private */\n      _originalContentPart: Object,\n\n      /** @private */\n      _contentNodes: Array,\n\n      /** @private */\n      _oldOwner: Element,\n\n      /** @private */\n      _oldModel: Object,\n\n      /** @private */\n      _oldTemplate: Object,\n\n      /** @private */\n      _oldInstanceProps: Object,\n\n      /** @private */\n      _oldRenderer: Object,\n\n      /** @private */\n      _oldOpened: Boolean\n    };\n  }\n\n  static get observers() {\n    return ['_templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened)'];\n  }\n\n  constructor() {\n    super();\n    this._boundMouseDownListener = this._mouseDownListener.bind(this);\n    this._boundMouseUpListener = this._mouseUpListener.bind(this);\n    this._boundOutsideClickListener = this._outsideClickListener.bind(this);\n    this._boundKeydownListener = this._keydownListener.bind(this);\n    this._observer = new _polymer_polymer_lib_utils_flattened_nodes_observer_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedNodesObserver(this, info => {\n      this._setTemplateFromNodes(info.addedNodes);\n    }); // Listener for preventing closing of the paper-dialog and all components extending `iron-overlay-behavior`.\n\n    this._boundIronOverlayCanceledListener = this._ironOverlayCanceled.bind(this);\n    /* c8 ignore next 3 */\n\n    if (_vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_4__.isIOS) {\n      this._boundIosResizeListener = () => this._detectIosNavbar();\n    }\n  }\n  /** @protected */\n\n\n  ready() {\n    super.ready();\n\n    this._observer.flush(); // Need to add dummy click listeners to this and the backdrop or else\n    // the document click event listener (_outsideClickListener) may never\n    // get invoked on iOS Safari (reproducible in <vaadin-dialog>\n    // and <vaadin-context-menu>).\n\n\n    this.addEventListener('click', () => {});\n    this.$.backdrop.addEventListener('click', () => {});\n  }\n  /** @private */\n\n\n  _detectIosNavbar() {\n    /* c8 ignore next 15 */\n    if (!this.opened) {\n      return;\n    }\n\n    const innerHeight = window.innerHeight;\n    const innerWidth = window.innerWidth;\n    const landscape = innerWidth > innerHeight;\n    const clientHeight = document.documentElement.clientHeight;\n\n    if (landscape && clientHeight > innerHeight) {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', clientHeight - innerHeight + 'px');\n    } else {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', '0');\n    }\n  }\n  /**\n   * @param {!Array<!Element>} nodes\n   * @protected\n   */\n\n\n  _setTemplateFromNodes(nodes) {\n    this.template = nodes.filter(node => node.localName && node.localName === 'template')[0] || this.template;\n  }\n  /**\n   * @param {Event=} sourceEvent\n   * @event vaadin-overlay-close\n   * fired before the `vaadin-overlay` will be closed. If canceled the closing of the overlay is canceled as well.\n   */\n\n\n  close(sourceEvent) {\n    var evt = new CustomEvent('vaadin-overlay-close', {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        sourceEvent: sourceEvent\n      }\n    });\n    this.dispatchEvent(evt);\n\n    if (!evt.defaultPrevented) {\n      this.opened = false;\n    }\n  }\n  /** @protected */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n    /* c8 ignore next 3 */\n\n    if (this._boundIosResizeListener) {\n      this._detectIosNavbar();\n\n      window.addEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n  /** @protected */\n\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    /* c8 ignore next 3 */\n\n    if (this._boundIosResizeListener) {\n      window.removeEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n  /**\n   * Requests an update for the content of the overlay.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n\n\n  requestContentUpdate() {\n    if (this.renderer) {\n      this.renderer.call(this.owner, this.content, this.owner, this.model);\n    }\n  }\n  /** @private */\n\n\n  _ironOverlayCanceled(event) {\n    event.preventDefault();\n  }\n  /** @private */\n\n\n  _mouseDownListener(event) {\n    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n  /** @private */\n\n\n  _mouseUpListener(event) {\n    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n  /**\n   * We need to listen on 'click' / 'tap' event and capture it and close the overlay before\n   * propagating the event to the listener in the button. Otherwise, if the clicked button would call\n   * open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4\n   *\n   * @event vaadin-overlay-outside-click\n   * fired before the `vaadin-overlay` will be closed on outside click. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n\n\n  _outsideClickListener(event) {\n    if (event.composedPath().indexOf(this.$.overlay) !== -1 || this._mouseDownInside || this._mouseUpInside) {\n      this._mouseDownInside = false;\n      this._mouseUpInside = false;\n      return;\n    }\n\n    if (!this._last) {\n      return;\n    }\n\n    const evt = new CustomEvent('vaadin-overlay-outside-click', {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        sourceEvent: event\n      }\n    });\n    this.dispatchEvent(evt);\n\n    if (this.opened && !evt.defaultPrevented) {\n      this.close(event);\n    }\n  }\n  /**\n   * @event vaadin-overlay-escape-press\n   * fired before the `vaadin-overlay` will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n\n\n  _keydownListener(event) {\n    if (!this._last) {\n      return;\n    } // TAB\n\n\n    if (event.key === 'Tab' && this.focusTrap && !event.defaultPrevented) {\n      // if only tab key is pressed, cycle forward, else cycle backwards.\n      this._cycleTab(event.shiftKey ? -1 : 1);\n\n      event.preventDefault(); // ESC\n    } else if (event.key === 'Escape' || event.key === 'Esc') {\n      const evt = new CustomEvent('vaadin-overlay-escape-press', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          sourceEvent: event\n        }\n      });\n      this.dispatchEvent(evt);\n\n      if (this.opened && !evt.defaultPrevented) {\n        this.close(event);\n      }\n    }\n  }\n  /** @protected */\n\n\n  _ensureTemplatized() {\n    this._setTemplateFromNodes(Array.from(this.children));\n  }\n  /**\n   * @event vaadin-overlay-open\n   * fired after the `vaadin-overlay` is opened.\n   *\n   * @private\n   */\n\n\n  _openedChanged(opened, wasOpened) {\n    if (!this._instance) {\n      this._ensureTemplatized();\n    }\n\n    if (opened) {\n      // Store focused node.\n      this.__restoreFocusNode = this._getActiveElement();\n\n      this._animatedOpening();\n\n      (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_1__.afterNextRender)(this, () => {\n        if (this.focusTrap && !this.contains(document.activeElement)) {\n          this._cycleTab(0, 0);\n        }\n\n        const evt = new CustomEvent('vaadin-overlay-open', {\n          bubbles: true\n        });\n        this.dispatchEvent(evt);\n      });\n\n      if (!this.modeless) {\n        this._addGlobalListeners();\n      }\n    } else if (wasOpened) {\n      this._animatedClosing();\n\n      if (!this.modeless) {\n        this._removeGlobalListeners();\n      }\n    }\n  }\n  /** @private */\n\n\n  _hiddenChanged(hidden) {\n    if (hidden && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n  }\n  /**\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _shouldAnimate() {\n    const name = getComputedStyle(this).getPropertyValue('animation-name');\n    const hidden = getComputedStyle(this).getPropertyValue('display') === 'none';\n    return !hidden && name && name != 'none';\n  }\n  /**\n   * @param {string} type\n   * @param {Function} callback\n   * @protected\n   */\n\n\n  _enqueueAnimation(type, callback) {\n    const handler = `__${type}Handler`;\n\n    const listener = event => {\n      if (event && event.target !== this) {\n        return;\n      }\n\n      callback();\n      this.removeEventListener('animationend', listener);\n      delete this[handler];\n    };\n\n    this[handler] = listener;\n    this.addEventListener('animationend', listener);\n  }\n  /**\n   * @param {string} type\n   * @protected\n   */\n\n\n  _flushAnimation(type) {\n    const handler = `__${type}Handler`;\n\n    if (typeof this[handler] === 'function') {\n      this[handler]();\n    }\n  }\n  /** @protected */\n\n\n  _animatedOpening() {\n    if (this.parentNode === document.body && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n\n    this._attachOverlay();\n\n    if (!this.modeless) {\n      this._enterModalState();\n    }\n\n    this.setAttribute('opening', '');\n\n    const finishOpening = () => {\n      document.addEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n      this.removeAttribute('opening');\n    };\n\n    if (this._shouldAnimate()) {\n      this._enqueueAnimation('opening', finishOpening);\n    } else {\n      finishOpening();\n    }\n  }\n  /** @protected */\n\n\n  _attachOverlay() {\n    this._placeholder = document.createComment('vaadin-overlay-placeholder');\n    this.parentNode.insertBefore(this._placeholder, this);\n    document.body.appendChild(this);\n    this.bringToFront();\n  }\n  /** @protected */\n\n\n  _animatedClosing() {\n    if (this.hasAttribute('opening')) {\n      this._flushAnimation('opening');\n    }\n\n    if (this._placeholder) {\n      this._exitModalState();\n\n      if (this.restoreFocusOnClose && this.__restoreFocusNode) {\n        // If the activeElement is `<body>` or inside the overlay,\n        // we are allowed to restore the focus. In all the other\n        // cases focus might have been moved elsewhere by another\n        // component or by the user interaction (e.g. click on a\n        // button outside the overlay).\n        const activeElement = this._getActiveElement();\n\n        if (activeElement === document.body || this._deepContains(activeElement)) {\n          this.__restoreFocusNode.focus();\n        }\n\n        this.__restoreFocusNode = null;\n      }\n\n      this.setAttribute('closing', '');\n\n      const finishClosing = () => {\n        document.removeEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n\n        this._detachOverlay();\n\n        this.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n        this.removeAttribute('closing');\n      };\n\n      if (this._shouldAnimate()) {\n        this._enqueueAnimation('closing', finishClosing);\n      } else {\n        finishClosing();\n      }\n    }\n  }\n  /** @protected */\n\n\n  _detachOverlay() {\n    this._placeholder.parentNode.insertBefore(this, this._placeholder);\n\n    this._placeholder.parentNode.removeChild(this._placeholder);\n  }\n  /**\n   * Returns all attached overlays in visual stacking order.\n   * @private\n   */\n\n\n  static get __attachedInstances() {\n    return Array.from(document.body.children).filter(el => el instanceof OverlayElement && !el.hasAttribute('closing')).sort((a, b) => a.__zIndex - b.__zIndex || 0);\n  }\n  /**\n   * returns true if this is the last one in the opened overlays stack\n   * @return {boolean}\n   * @protected\n   */\n\n\n  get _last() {\n    return this === OverlayElement.__attachedInstances.pop();\n  }\n  /** @private */\n\n\n  _modelessChanged(modeless) {\n    if (!modeless) {\n      if (this.opened) {\n        this._addGlobalListeners();\n\n        this._enterModalState();\n      }\n    } else {\n      this._removeGlobalListeners();\n\n      this._exitModalState();\n    }\n  }\n  /** @protected */\n\n\n  _addGlobalListeners() {\n    document.addEventListener('mousedown', this._boundMouseDownListener);\n    document.addEventListener('mouseup', this._boundMouseUpListener); // Firefox leaks click to document on contextmenu even if prevented\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=990614\n\n    document.documentElement.addEventListener('click', this._boundOutsideClickListener, true);\n    document.addEventListener('keydown', this._boundKeydownListener);\n  }\n  /** @protected */\n\n\n  _enterModalState() {\n    if (document.body.style.pointerEvents !== 'none') {\n      // Set body pointer-events to 'none' to disable mouse interactions with\n      // other document nodes.\n      this._previousDocumentPointerEvents = document.body.style.pointerEvents;\n      document.body.style.pointerEvents = 'none';\n    } // Disable pointer events in other attached overlays\n\n\n    OverlayElement.__attachedInstances.forEach(el => {\n      if (el !== this) {\n        el.shadowRoot.querySelector('[part=\"overlay\"]').style.pointerEvents = 'none';\n      }\n    });\n  }\n  /** @protected */\n\n\n  _removeGlobalListeners() {\n    document.removeEventListener('mousedown', this._boundMouseDownListener);\n    document.removeEventListener('mouseup', this._boundMouseUpListener);\n    document.documentElement.removeEventListener('click', this._boundOutsideClickListener, true);\n    document.removeEventListener('keydown', this._boundKeydownListener);\n  }\n  /** @protected */\n\n\n  _exitModalState() {\n    if (this._previousDocumentPointerEvents !== undefined) {\n      // Restore body pointer-events\n      document.body.style.pointerEvents = this._previousDocumentPointerEvents;\n      delete this._previousDocumentPointerEvents;\n    } // Restore pointer events in the previous overlay(s)\n\n\n    const instances = OverlayElement.__attachedInstances;\n    let el; // Use instances.pop() to ensure the reverse order\n\n    while (el = instances.pop()) {\n      if (el === this) {\n        // Skip the current instance\n        continue;\n      }\n\n      el.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n\n      if (!el.modeless) {\n        // Stop after the last modal\n        break;\n      }\n    }\n  }\n  /** @protected */\n\n\n  _removeOldContent() {\n    if (!this.content || !this._contentNodes) {\n      return;\n    }\n\n    this._observer.disconnect();\n\n    this._contentNodes.forEach(node => {\n      if (node.parentNode === this.content) {\n        this.content.removeChild(node);\n      }\n    });\n\n    if (this._originalContentPart) {\n      // Restore the original <div part=\"content\">\n      this.$.content.parentNode.replaceChild(this._originalContentPart, this.$.content);\n      this.$.content = this._originalContentPart;\n      this._originalContentPart = undefined;\n    }\n\n    this._observer.connect();\n\n    this._contentNodes = undefined;\n    this.content = undefined;\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {object} instanceProps\n   * @protected\n   */\n\n\n  _stampOverlayTemplate(template, instanceProps) {\n    this._removeOldContent();\n\n    if (!template._Templatizer) {\n      template._Templatizer = (0,_polymer_polymer_lib_utils_templatize_js__WEBPACK_IMPORTED_MODULE_2__.templatize)(template, this, {\n        instanceProps: instanceProps,\n        forwardHostProp: function (prop, value) {\n          if (this._instance) {\n            this._instance.forwardHostProp(prop, value);\n          }\n        }\n      });\n    }\n\n    this._instance = new template._Templatizer({});\n    this._contentNodes = Array.from(this._instance.root.childNodes);\n    const templateRoot = template._templateRoot || (template._templateRoot = template.getRootNode());\n\n    if (templateRoot !== document) {\n      if (!this.$.content.shadowRoot) {\n        this.$.content.attachShadow({\n          mode: 'open'\n        });\n      }\n\n      let scopeCssText = Array.from(templateRoot.querySelectorAll('style')).reduce((result, style) => result + style.textContent, ''); // The overlay roots :host styles should not apply inside the overlay\n\n      scopeCssText = scopeCssText.replace(/:host/g, ':host-nomatch');\n\n      if (scopeCssText) {\n        // Append a style to the content shadowRoot\n        const style = document.createElement('style');\n        style.textContent = scopeCssText;\n        this.$.content.shadowRoot.appendChild(style);\n\n        this._contentNodes.unshift(style);\n      }\n\n      this.$.content.shadowRoot.appendChild(this._instance.root);\n      this.content = this.$.content.shadowRoot;\n    } else {\n      this.appendChild(this._instance.root);\n      this.content = this;\n    }\n  }\n  /** @private */\n\n\n  _removeNewRendererOrTemplate(template, oldTemplate, renderer, oldRenderer) {\n    if (template !== oldTemplate) {\n      this.template = undefined;\n    } else if (renderer !== oldRenderer) {\n      this.renderer = undefined;\n    }\n  }\n  /** @private */\n\n\n  _templateOrRendererChanged(template, renderer, owner, model, instanceProps, opened) {\n    if (template && renderer) {\n      this._removeNewRendererOrTemplate(template, this._oldTemplate, renderer, this._oldRenderer);\n\n      throw new Error('You should only use either a renderer or a template for overlay content');\n    }\n\n    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;\n    this._oldModel = model;\n    this._oldOwner = owner;\n    const templateOrInstancePropsChanged = this._oldInstanceProps !== instanceProps || this._oldTemplate !== template;\n    this._oldInstanceProps = instanceProps;\n    this._oldTemplate = template;\n    const rendererChanged = this._oldRenderer !== renderer;\n    this._oldRenderer = renderer;\n    const openedChanged = this._oldOpened !== opened;\n    this._oldOpened = opened;\n\n    if (rendererChanged) {\n      this.content = this;\n      this.content.innerHTML = ''; // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n      // When clearing the rendered content, this part needs to be manually disposed of.\n      // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n\n      delete this.content._$litPart$;\n    }\n\n    if (template && templateOrInstancePropsChanged) {\n      this._stampOverlayTemplate(template, instanceProps);\n    } else if (renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {\n      if (opened) {\n        this.requestContentUpdate();\n      }\n    }\n  }\n  /**\n   * @param {Element} element\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _isFocused(element) {\n    return element && element.getRootNode().activeElement === element;\n  }\n  /**\n   * @param {Element[]} elements\n   * @return {number}\n   * @protected\n   */\n\n\n  _focusedIndex(elements) {\n    elements = elements || this._getFocusableElements();\n    return elements.indexOf(elements.filter(this._isFocused).pop());\n  }\n  /**\n   * @param {number} increment\n   * @param {number | undefined} index\n   * @protected\n   */\n\n\n  _cycleTab(increment, index) {\n    const focusableElements = this._getFocusableElements();\n\n    if (index === undefined) {\n      index = this._focusedIndex(focusableElements);\n    }\n\n    index += increment; // rollover to first item\n\n    if (index >= focusableElements.length) {\n      index = 0; // go to last item\n    } else if (index < 0) {\n      index = focusableElements.length - 1;\n    }\n\n    focusableElements[index].focus();\n  }\n  /**\n   * @return {!Array<!HTMLElement>}\n   * @protected\n   */\n\n\n  _getFocusableElements() {\n    // collect all focusable elements\n    return _vaadin_focusables_helper_js__WEBPACK_IMPORTED_MODULE_7__.FocusablesHelper.getTabbableNodes(this.$.overlay);\n  }\n  /**\n   * @return {!Element}\n   * @protected\n   */\n\n\n  _getActiveElement() {\n    // document.activeElement can be null\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n    let active = document.activeElement || document.body;\n\n    while (active.shadowRoot && active.shadowRoot.activeElement) {\n      active = active.shadowRoot.activeElement;\n    }\n\n    return active;\n  }\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   * @protected\n   */\n\n\n  _deepContains(node) {\n    if (this.contains(node)) {\n      return true;\n    }\n\n    let n = node;\n    const doc = node.ownerDocument; // walk from node to `this` or `document`\n\n    while (n && n !== doc && n !== this) {\n      n = n.parentNode || n.host;\n    }\n\n    return n === this;\n  }\n  /**\n   * Brings the overlay as visually the frontmost one\n   */\n\n\n  bringToFront() {\n    let zIndex = '';\n\n    const frontmost = OverlayElement.__attachedInstances.filter(o => o !== this).pop();\n\n    if (frontmost) {\n      const frontmostZIndex = frontmost.__zIndex;\n      zIndex = frontmostZIndex + 1;\n    }\n\n    this.style.zIndex = zIndex;\n    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);\n  }\n\n}\n\ncustomElements.define(OverlayElement.is, OverlayElement);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS9zcmMvdmFhZGluLW92ZXJsYXkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQURBOztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQW5KQTtBQXFKQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQWo1QkE7O0FBbzVCQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS9zcmMvdmFhZGluLW92ZXJsYXkuanM/ZjljZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgYWZ0ZXJOZXh0UmVuZGVyIH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0aXplIH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5pbXBvcnQgeyBodG1sLCBQb2x5bWVyRWxlbWVudCB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGlzSU9TIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYnJvd3Nlci11dGlscy5qcyc7XG5pbXBvcnQgeyBEaXJNaXhpbiB9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2Rpci1taXhpbi5qcyc7XG5pbXBvcnQgeyBUaGVtYWJsZU1peGluIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcbmltcG9ydCB7IEZvY3VzYWJsZXNIZWxwZXIgfSBmcm9tICcuL3ZhYWRpbi1mb2N1c2FibGVzLWhlbHBlci5qcyc7XG5cbi8qKlxuICpcbiAqIGA8dmFhZGluLW92ZXJsYXk+YCBpcyBhIFdlYiBDb21wb25lbnQgZm9yIGNyZWF0aW5nIG92ZXJsYXlzLiBUaGUgY29udGVudCBvZiB0aGUgb3ZlcmxheVxuICogY2FuIGJlIHBvcHVsYXRlZCBpbiB0d28gd2F5czogaW1wZXJhdGl2ZWx5IGJ5IHVzaW5nIHJlbmRlcmVyIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZFxuICogZGVjbGFyYXRpdmVseSBieSB1c2luZyBQb2x5bWVyJ3MgVGVtcGxhdGVzLlxuICpcbiAqICMjIyBSZW5kZXJpbmdcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgb3ZlcmxheSB1c2VzIHRoZSBjb250ZW50IHByb3ZpZGVkIGJ5IHVzaW5nIHRoZSByZW5kZXJlciBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgcmVuZGVyZXIgZnVuY3Rpb24gcHJvdmlkZXMgYHJvb3RgLCBgb3duZXJgLCBgbW9kZWxgIGFyZ3VtZW50cyB3aGVuIGFwcGxpY2FibGUuXG4gKiBHZW5lcmF0ZSBET00gY29udGVudCBieSB1c2luZyBgbW9kZWxgIG9iamVjdCBwcm9wZXJ0aWVzIGlmIG5lZWRlZCwgYXBwZW5kIGl0IHRvIHRoZSBgcm9vdGBcbiAqIGVsZW1lbnQgYW5kIGNvbnRyb2wgdGhlIHN0YXRlIG9mIHRoZSBob3N0IGVsZW1lbnQgYnkgYWNjZXNzaW5nIGBvd25lcmAuIEJlZm9yZSBnZW5lcmF0aW5nIG5ld1xuICogY29udGVudCwgdXNlcnMgYXJlIGFibGUgdG8gY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBjb250ZW50IGluIGByb290YCBmb3IgcmV1c2luZyBpdC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8dmFhZGluLW92ZXJsYXkgaWQ9XCJvdmVybGF5XCI+PC92YWFkaW4tb3ZlcmxheT5cbiAqIGBgYFxuICogYGBganNcbiAqIGNvbnN0IG92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3ZlcmxheScpO1xuICogb3ZlcmxheS5yZW5kZXJlciA9IGZ1bmN0aW9uKHJvb3QpIHtcbiAqICByb290LnRleHRDb250ZW50ID0gXCJPdmVybGF5IGNvbnRlbnRcIjtcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBSZW5kZXJlciBpcyBjYWxsZWQgb24gdGhlIG9wZW5pbmcgb2YgdGhlIG92ZXJsYXkgYW5kIGVhY2ggdGltZSB0aGUgcmVsYXRlZCBtb2RlbCBpcyB1cGRhdGVkLlxuICogRE9NIGdlbmVyYXRlZCBkdXJpbmcgdGhlIHJlbmRlcmVyIGNhbGwgY2FuIGJlIHJldXNlZFxuICogaW4gdGhlIG5leHQgcmVuZGVyZXIgY2FsbCBhbmQgd2lsbCBiZSBwcm92aWRlZCB3aXRoIHRoZSBgcm9vdGAgYXJndW1lbnQuXG4gKiBPbiBmaXJzdCBjYWxsIGl0IHdpbGwgYmUgZW1wdHkuXG4gKlxuICogKipOT1RFOioqIHdoZW4gdGhlIHJlbmRlcmVyIHByb3BlcnR5IGlzIGRlZmluZWQsIHRoZSBgPHRlbXBsYXRlPmAgY29udGVudCBpcyBub3QgdXNlZC5cbiAqXG4gKiAjIyMgVGVtcGxhdGluZ1xuICpcbiAqIEFsdGVybmF0aXZlbHksIHRoZSBjb250ZW50IGNhbiBiZSBwcm92aWRlZCB3aXRoIFBvbHltZXIgVGVtcGxhdGUuXG4gKiBPdmVybGF5IGZpbmRzIHRoZSBmaXJzdCBjaGlsZCB0ZW1wbGF0ZSBhbmQgdXNlcyB0aGF0IGluIGNhc2UgcmVuZGVyZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIGlzIG5vdCBwcm92aWRlZC4gWW91IGNhbiBhbHNvIHNldCBhIGN1c3RvbSB0ZW1wbGF0ZSB1c2luZyB0aGUgYHRlbXBsYXRlYCBwcm9wZXJ0eS5cbiAqXG4gKiBBZnRlciB0aGUgY29udGVudCBmcm9tIHRoZSB0ZW1wbGF0ZSBpcyBzdGFtcGVkLCB0aGUgYGNvbnRlbnRgIHByb3BlcnR5XG4gKiBwb2ludHMgdG8gdGhlIGNvbnRlbnQgY29udGFpbmVyLlxuICpcbiAqIFRoZSBvdmVybGF5IHByb3ZpZGVzIGBmb3J3YXJkSG9zdFByb3BgIHdoZW4gY2FsbGluZ1xuICogYFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplYCBmb3IgdGhlIHRlbXBsYXRlLCBzbyB0aGF0IHRoZSBiaW5kaW5nc1xuICogZnJvbSB0aGUgcGFyZW50IHNjb3BlIHByb3BhZ2F0ZSB0byB0aGUgY29udGVudC4gIFlvdSBjYW4gYWxzbyBwYXNzXG4gKiBjdXN0b20gYGluc3RhbmNlUHJvcHNgIG9iamVjdCB1c2luZyB0aGUgYGluc3RhbmNlUHJvcHNgIHByb3BlcnR5LlxuICpcbiAqIGBgYGh0bWxcbiAqIDx2YWFkaW4tb3ZlcmxheT5cbiAqICAgPHRlbXBsYXRlPk92ZXJsYXkgY29udGVudDwvdGVtcGxhdGU+XG4gKiA8L3ZhYWRpbi1vdmVybGF5PlxuICogYGBgXG4gKlxuICogKipOT1RFOioqIHdoZW4gdXNpbmcgYGluc3RhbmNlUHJvcHNgOiBiZWNhdXNlIG9mIHRoZSBQb2x5bWVyIGxpbWl0YXRpb24sXG4gKiBldmVyeSB0ZW1wbGF0ZSBjYW4gb25seSBiZSB0ZW1wbGF0aXplZCBvbmNlLCBzbyBpdCBpcyBpbXBvcnRhbnRcbiAqIHRvIHNldCBgaW5zdGFuY2VQcm9wc2AgYmVmb3JlIHRoZSBgdGVtcGxhdGVgIGlzIGFzc2lnbmVkIHRvIHRoZSBvdmVybGF5LlxuICpcbiAqICMjIyBTdHlsaW5nXG4gKlxuICogVG8gc3R5bGUgdGhlIG92ZXJsYXkgY29udGVudCwgdXNlIHN0eWxlcyBpbiB0aGUgcGFyZW50IHNjb3BlOlxuICpcbiAqIC0gSWYgdGhlIG92ZXJsYXkgaXMgdXNlZCBpbiBhIGNvbXBvbmVudCwgdGhlbiB0aGUgY29tcG9uZW50IHN0eWxlc1xuICogICBhcHBseSB0aGUgb3ZlcmxheSBjb250ZW50LlxuICogLSBJZiB0aGUgb3ZlcmxheSBpcyB1c2VkIGluIHRoZSBnbG9iYWwgRE9NIHNjb3BlLCB0aGVuIGdsb2JhbCBzdHlsZXNcbiAqICAgYXBwbHkgdG8gdGhlIG92ZXJsYXkgY29udGVudC5cbiAqXG4gKiBTZWUgZXhhbXBsZXMgZm9yIHN0eWxpbmcgdGhlIG92ZXJsYXkgY29udGVudCBpbiB0aGUgbGl2ZSBkZW1vcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIFNoYWRvdyBET00gcGFydHMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZyB0aGUgb3ZlcmxheSBjb21wb25lbnQgaXRzZWxmOlxuICpcbiAqIFBhcnQgbmFtZSAgfCBEZXNjcmlwdGlvblxuICogLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogYGJhY2tkcm9wYCB8IEJhY2tkcm9wIG9mIHRoZSBvdmVybGF5XG4gKiBgb3ZlcmxheWAgIHwgQ29udGFpbmVyIGZvciBwb3NpdGlvbi9zaXppbmcvYWxpZ25tZW50IG9mIHRoZSBjb250ZW50XG4gKiBgY29udGVudGAgIHwgQ29udGVudCBvZiB0aGUgb3ZlcmxheVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgc3RhdGUgYXR0cmlidXRlcyBhcmUgYXZhaWxhYmxlIGZvciBzdHlsaW5nOlxuICpcbiAqIEF0dHJpYnV0ZSB8IERlc2NyaXB0aW9uIHwgUGFydFxuICogLS0tfC0tLXwtLS1cbiAqIGBvcGVuaW5nYCB8IEFwcGxpZWQganVzdCBhZnRlciB0aGUgb3ZlcmxheSBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLiBZb3UgY2FuIGFwcGx5IGEgQ1NTIEBrZXlmcmFtZSBhbmltYXRpb24gZm9yIHRoaXMgc3RhdGUuIHwgYDpob3N0YFxuICogYGNsb3NpbmdgIHwgQXBwbGllZCBqdXN0IGJlZm9yZSB0aGUgb3ZlcmxheSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBET00uIFlvdSBjYW4gYXBwbHkgYSBDU1MgQGtleWZyYW1lIGFuaW1hdGlvbiBmb3IgdGhpcyBzdGF0ZS4gfCBgOmhvc3RgXG4gKlxuICogVGhlIGZvbGxvd2luZyBjdXN0b20gQ1NTIHByb3BlcnRpZXMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcbiAqXG4gKiBDdXN0b20gQ1NTIHByb3BlcnR5IHwgRGVzY3JpcHRpb24gfCBEZWZhdWx0IHZhbHVlXG4gKiAtLS18LS0tfC0tLVxuICogYC0tdmFhZGluLW92ZXJsYXktdmlld3BvcnQtYm90dG9tYCB8IEJvdHRvbSBvZmZzZXQgb2YgdGhlIHZpc2libGUgdmlld3BvcnQgYXJlYSB8IGAwYCBvciBkZXRlY3RlZCBvZmZzZXRcbiAqXG4gKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50c10oaHR0cHM6Ly92YWFkaW4uY29tL2RvY3MvbGF0ZXN0L2RzL2N1c3RvbWl6YXRpb24vc3R5bGluZy1jb21wb25lbnRzKSBkb2N1bWVudGF0aW9uLlxuICpcbiAqIEBmaXJlcyB7Q3VzdG9tRXZlbnR9IG9wZW5lZC1jaGFuZ2VkIC0gRmlyZWQgd2hlbiB0aGUgYG9wZW5lZGAgcHJvcGVydHkgY2hhbmdlcy5cbiAqXG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQG1peGVzIFRoZW1hYmxlTWl4aW5cbiAqIEBtaXhlcyBEaXJNaXhpblxuICovXG5jbGFzcyBPdmVybGF5RWxlbWVudCBleHRlbmRzIFRoZW1hYmxlTWl4aW4oRGlyTWl4aW4oUG9seW1lckVsZW1lbnQpKSB7XG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICB6LWluZGV4OiAyMDA7XG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuXG4gICAgICAgICAgLyogRGVzcGl0ZSBvZiB3aGF0IHRoZSBuYW1lcyBzYXksIDx2YWFkaW4tb3ZlcmxheT4gaXMganVzdCBhIGNvbnRhaW5lclxuICAgICAgICAgIGZvciBwb3NpdGlvbi9zaXppbmcvYWxpZ25tZW50LiBUaGUgYWN0dWFsIG92ZXJsYXkgaXMgdGhlIG92ZXJsYXkgcGFydC4gKi9cblxuICAgICAgICAgIC8qIERlZmF1bHQgcG9zaXRpb24gY29uc3RyYWludHM6IHRoZSBlbnRpcmUgdmlld3BvcnQuIE5vdGU6IHRoZW1lcyBjYW5cbiAgICAgICAgICBvdmVycmlkZSB0aGlzIHRvIGludHJvZHVjZSBnYXBzIGJldHdlZW4gdGhlIG92ZXJsYXkgYW5kIHRoZSB2aWV3cG9ydC4gKi9cbiAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgYm90dG9tOiB2YXIoLS12YWFkaW4tb3ZlcmxheS12aWV3cG9ydC1ib3R0b20pO1xuICAgICAgICAgIGxlZnQ6IDA7XG5cbiAgICAgICAgICAvKiBVc2UgZmxleGJveCBhbGlnbm1lbnQgZm9yIHRoZSBvdmVybGF5IHBhcnQuICovXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyAvKiBtYWtlcyBkcm9wZG93bnMgc2l6aW5nIGVhc2llciAqL1xuICAgICAgICAgIC8qIEFsaWduIHRvIGNlbnRlciBieSBkZWZhdWx0LiAqL1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cbiAgICAgICAgICAvKiBBbGxvdyBjZW50ZXJpbmcgd2hlbiBtYXgtd2lkdGgvbWF4LWhlaWdodCBhcHBsaWVzLiAqL1xuICAgICAgICAgIG1hcmdpbjogYXV0bztcblxuICAgICAgICAgIC8qIFRoZSBob3N0IGlzIG5vdCBjbGlja2FibGUsIG9ubHkgdGhlIG92ZXJsYXkgcGFydCBpcy4gKi9cbiAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcblxuICAgICAgICAgIC8qIFJlbW92ZSB0YXAgaGlnaGxpZ2h0IG9uIHRvdWNoIGRldmljZXMuICovXG4gICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblxuICAgICAgICAgIC8qIENTUyBBUEkgZm9yIGhvc3QgKi9cbiAgICAgICAgICAtLXZhYWRpbi1vdmVybGF5LXZpZXdwb3J0LWJvdHRvbTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIDpob3N0KFtoaWRkZW5dKSxcbiAgICAgICAgOmhvc3QoOm5vdChbb3BlbmVkXSk6bm90KFtjbG9zaW5nXSkpIHtcbiAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBbcGFydD0nb3ZlcmxheSddIHtcbiAgICAgICAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XG4gICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG5cbiAgICAgICAgICAvKiBQcmV2ZW50IG92ZXJmbG93aW5nIHRoZSBob3N0IGluIE1TSUUgMTEgKi9cbiAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcblxuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogaW5pdGlhbDsgLyogcmVlbmFibGUgdGFwIGhpZ2hsaWdodCBpbnNpZGUgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIFtwYXJ0PSdiYWNrZHJvcCddIHtcbiAgICAgICAgICB6LWluZGV4OiAtMTtcbiAgICAgICAgICBjb250ZW50OiAnJztcbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIHRvcDogMDtcbiAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICByaWdodDogMDtcbiAgICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgPGRpdiBpZD1cImJhY2tkcm9wXCIgcGFydD1cImJhY2tkcm9wXCIgaGlkZGVuJD1cIltbIXdpdGhCYWNrZHJvcF1dXCI+PC9kaXY+XG4gICAgICA8ZGl2IHBhcnQ9XCJvdmVybGF5XCIgaWQ9XCJvdmVybGF5XCIgdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgIDxkaXYgcGFydD1cImNvbnRlbnRcIiBpZD1cImNvbnRlbnRcIj5cbiAgICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXMoKSB7XG4gICAgcmV0dXJuICd2YWFkaW4tb3ZlcmxheSc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0cnVlLCB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlIGFuZCBhdHRhY2hlZCB0byBib2R5LlxuICAgICAgICovXG4gICAgICBvcGVuZWQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICBvYnNlcnZlcjogJ19vcGVuZWRDaGFuZ2VkJyxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBPd25lciBlbGVtZW50IHBhc3NlZCB3aXRoIHJlbmRlcmVyIGZ1bmN0aW9uXG4gICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIG93bmVyOiBFbGVtZW50LFxuXG4gICAgICAvKipcbiAgICAgICAqIEN1c3RvbSBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxuICAgICAgICogUmVjZWl2ZXMgdGhyZWUgYXJndW1lbnRzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHJvb3RgIFRoZSByb290IGNvbnRhaW5lciBET00gZWxlbWVudC4gQXBwZW5kIHlvdXIgY29udGVudCB0byBpdC5cbiAgICAgICAqIC0gYG93bmVyYCBUaGUgaG9zdCBlbGVtZW50IG9mIHRoZSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICAgICAqIC0gYG1vZGVsYCBUaGUgb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcmVsYXRlZCB3aXRoIHJlbmRlcmluZy5cbiAgICAgICAqIEB0eXBlIHtPdmVybGF5UmVuZGVyZXIgfCBudWxsIHwgdW5kZWZpbmVkfVxuICAgICAgICovXG4gICAgICByZW5kZXJlcjogRnVuY3Rpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRlbXBsYXRlIG9mIHRoZSBvdmVybGF5IGNvbnRlbnQuXG4gICAgICAgKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWR9XG4gICAgICAgKi9cbiAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBPcHRpb25hbCBhcmd1bWVudCBmb3IgYFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplYC5cbiAgICAgICAqL1xuICAgICAgaW5zdGFuY2VQcm9wczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZmVyZW5jZXMgdGhlIGNvbnRlbnQgY29udGFpbmVyIGFmdGVyIHRoZSB0ZW1wbGF0ZSBpcyBzdGFtcGVkLlxuICAgICAgICogQHR5cGUgeyFIVE1MRWxlbWVudCB8IHVuZGVmaW5lZH1cbiAgICAgICAqL1xuICAgICAgY29udGVudDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0cnVlIHRoZSBvdmVybGF5IGhhcyBiYWNrZHJvcCBvbiB0b3Agb2YgY29udGVudCB3aGVuIG9wZW5lZC5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICB3aXRoQmFja2Ryb3A6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBpcyBwYXNzZWQgdG8gYHJlbmRlcmVyYCBmdW5jdGlvblxuICAgICAgICovXG4gICAgICBtb2RlbDogT2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdHJ1ZSB0aGUgb3ZlcmxheSB3b24ndCBkaXNhYmxlIHRoZSBtYWluIGNvbnRlbnQsIHNob3dpbmdcbiAgICAgICAqIGl0IGRvZXNu4oCZdCBjaGFuZ2UgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHVzZXIgaW50ZXJmYWNlLlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIG1vZGVsZXNzOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBvYnNlcnZlcjogJ19tb2RlbGVzc0NoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHNldCB0byB0cnVlLCB0aGUgb3ZlcmxheSBpcyBoaWRkZW4uIFRoaXMgYWxzbyBjbG9zZXMgdGhlIG92ZXJsYXlcbiAgICAgICAqIGltbWVkaWF0ZWx5IGluIGNhc2UgdGhlcmUgaXMgYSBjbG9zaW5nIGFuaW1hdGlvbiBpbiBwcm9ncmVzcy5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBoaWRkZW46IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICBvYnNlcnZlcjogJ19oaWRkZW5DaGFuZ2VkJyxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0cnVlIG1vdmUgZm9jdXMgdG8gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGluIHRoZSBvdmVybGF5LFxuICAgICAgICogb3IgdG8gdGhlIG92ZXJsYXkgaWYgdGhlcmUgYXJlIG5vIGZvY3VzYWJsZSBlbGVtZW50cy5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBmb2N1c1RyYXA6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgcmVzdG9yaW5nIG9mIGZvY3VzIHdoZW4gb3ZlcmxheSBpcyBjbG9zZWQuXG4gICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgcmVzdG9yZUZvY3VzT25DbG9zZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICB9LFxuXG4gICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgIF9tb3VzZURvd25JbnNpZGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX21vdXNlVXBJbnNpZGU6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX2luc3RhbmNlOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX29yaWdpbmFsQ29udGVudFBhcnQ6IE9iamVjdCxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfY29udGVudE5vZGVzOiBBcnJheSxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb2xkT3duZXI6IEVsZW1lbnQsXG5cbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX29sZE1vZGVsOiBPYmplY3QsXG5cbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX29sZFRlbXBsYXRlOiBPYmplY3QsXG5cbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX29sZEluc3RhbmNlUHJvcHM6IE9iamVjdCxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb2xkUmVuZGVyZXI6IE9iamVjdCxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb2xkT3BlbmVkOiBCb29sZWFuLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICByZXR1cm4gWydfdGVtcGxhdGVPclJlbmRlcmVyQ2hhbmdlZCh0ZW1wbGF0ZSwgcmVuZGVyZXIsIG93bmVyLCBtb2RlbCwgaW5zdGFuY2VQcm9wcywgb3BlbmVkKSddO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9ib3VuZE1vdXNlRG93bkxpc3RlbmVyID0gdGhpcy5fbW91c2VEb3duTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE1vdXNlVXBMaXN0ZW5lciA9IHRoaXMuX21vdXNlVXBMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT3V0c2lkZUNsaWNrTGlzdGVuZXIgPSB0aGlzLl9vdXRzaWRlQ2xpY2tMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kS2V5ZG93bkxpc3RlbmVyID0gdGhpcy5fa2V5ZG93bkxpc3RlbmVyLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMsIChpbmZvKSA9PiB7XG4gICAgICB0aGlzLl9zZXRUZW1wbGF0ZUZyb21Ob2RlcyhpbmZvLmFkZGVkTm9kZXMpO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuZXIgZm9yIHByZXZlbnRpbmcgY2xvc2luZyBvZiB0aGUgcGFwZXItZGlhbG9nIGFuZCBhbGwgY29tcG9uZW50cyBleHRlbmRpbmcgYGlyb24tb3ZlcmxheS1iZWhhdmlvcmAuXG4gICAgdGhpcy5fYm91bmRJcm9uT3ZlcmxheUNhbmNlbGVkTGlzdGVuZXIgPSB0aGlzLl9pcm9uT3ZlcmxheUNhbmNlbGVkLmJpbmQodGhpcyk7XG5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKGlzSU9TKSB7XG4gICAgICB0aGlzLl9ib3VuZElvc1Jlc2l6ZUxpc3RlbmVyID0gKCkgPT4gdGhpcy5fZGV0ZWN0SW9zTmF2YmFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgcmVhZHkoKSB7XG4gICAgc3VwZXIucmVhZHkoKTtcblxuICAgIHRoaXMuX29ic2VydmVyLmZsdXNoKCk7XG5cbiAgICAvLyBOZWVkIHRvIGFkZCBkdW1teSBjbGljayBsaXN0ZW5lcnMgdG8gdGhpcyBhbmQgdGhlIGJhY2tkcm9wIG9yIGVsc2VcbiAgICAvLyB0aGUgZG9jdW1lbnQgY2xpY2sgZXZlbnQgbGlzdGVuZXIgKF9vdXRzaWRlQ2xpY2tMaXN0ZW5lcikgbWF5IG5ldmVyXG4gICAgLy8gZ2V0IGludm9rZWQgb24gaU9TIFNhZmFyaSAocmVwcm9kdWNpYmxlIGluIDx2YWFkaW4tZGlhbG9nPlxuICAgIC8vIGFuZCA8dmFhZGluLWNvbnRleHQtbWVudT4pLlxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7fSk7XG4gICAgdGhpcy4kLmJhY2tkcm9wLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge30pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9kZXRlY3RJb3NOYXZiYXIoKSB7XG4gICAgLyogYzggaWdub3JlIG5leHQgMTUgKi9cbiAgICBpZiAoIXRoaXMub3BlbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW5uZXJIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgY29uc3QgbGFuZHNjYXBlID0gaW5uZXJXaWR0aCA+IGlubmVySGVpZ2h0O1xuXG4gICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblxuICAgIGlmIChsYW5kc2NhcGUgJiYgY2xpZW50SGVpZ2h0ID4gaW5uZXJIZWlnaHQpIHtcbiAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoJy0tdmFhZGluLW92ZXJsYXktdmlld3BvcnQtYm90dG9tJywgY2xpZW50SGVpZ2h0IC0gaW5uZXJIZWlnaHQgKyAncHgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12YWFkaW4tb3ZlcmxheS12aWV3cG9ydC1ib3R0b20nLCAnMCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTwhRWxlbWVudD59IG5vZGVzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zZXRUZW1wbGF0ZUZyb21Ob2Rlcyhub2Rlcykge1xuICAgIHRoaXMudGVtcGxhdGUgPSBub2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUubG9jYWxOYW1lICYmIG5vZGUubG9jYWxOYW1lID09PSAndGVtcGxhdGUnKVswXSB8fCB0aGlzLnRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBzb3VyY2VFdmVudFxuICAgKiBAZXZlbnQgdmFhZGluLW92ZXJsYXktY2xvc2VcbiAgICogZmlyZWQgYmVmb3JlIHRoZSBgdmFhZGluLW92ZXJsYXlgIHdpbGwgYmUgY2xvc2VkLiBJZiBjYW5jZWxlZCB0aGUgY2xvc2luZyBvZiB0aGUgb3ZlcmxheSBpcyBjYW5jZWxlZCBhcyB3ZWxsLlxuICAgKi9cbiAgY2xvc2Uoc291cmNlRXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCd2YWFkaW4tb3ZlcmxheS1jbG9zZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHNvdXJjZUV2ZW50OiBzb3VyY2VFdmVudCB9LFxuICAgIH0pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIGlmICghZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAodGhpcy5fYm91bmRJb3NSZXNpemVMaXN0ZW5lcikge1xuICAgICAgdGhpcy5fZGV0ZWN0SW9zTmF2YmFyKCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRJb3NSZXNpemVMaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICBpZiAodGhpcy5fYm91bmRJb3NSZXNpemVMaXN0ZW5lcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kSW9zUmVzaXplTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbiB1cGRhdGUgZm9yIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxuICAgKiBXaGlsZSBwZXJmb3JtaW5nIHRoZSB1cGRhdGUsIGl0IGludm9rZXMgdGhlIHJlbmRlcmVyIHBhc3NlZCBpbiB0aGUgYHJlbmRlcmVyYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCB0aGUgdXBkYXRlIGhhcHBlbnMgaW1tZWRpYXRlbHkgKHN5bmNocm9ub3VzbHkpIGFmdGVyIGl0IGlzIHJlcXVlc3RlZC5cbiAgICovXG4gIHJlcXVlc3RDb250ZW50VXBkYXRlKCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmNhbGwodGhpcy5vd25lciwgdGhpcy5jb250ZW50LCB0aGlzLm93bmVyLCB0aGlzLm1vZGVsKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2lyb25PdmVybGF5Q2FuY2VsZWQoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9tb3VzZURvd25MaXN0ZW5lcihldmVudCkge1xuICAgIHRoaXMuX21vdXNlRG93bkluc2lkZSA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluZGV4T2YodGhpcy4kLm92ZXJsYXkpID49IDA7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX21vdXNlVXBMaXN0ZW5lcihldmVudCkge1xuICAgIHRoaXMuX21vdXNlVXBJbnNpZGUgPSBldmVudC5jb21wb3NlZFBhdGgoKS5pbmRleE9mKHRoaXMuJC5vdmVybGF5KSA+PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIG5lZWQgdG8gbGlzdGVuIG9uICdjbGljaycgLyAndGFwJyBldmVudCBhbmQgY2FwdHVyZSBpdCBhbmQgY2xvc2UgdGhlIG92ZXJsYXkgYmVmb3JlXG4gICAqIHByb3BhZ2F0aW5nIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIgaW4gdGhlIGJ1dHRvbi4gT3RoZXJ3aXNlLCBpZiB0aGUgY2xpY2tlZCBidXR0b24gd291bGQgY2FsbFxuICAgKiBvcGVuKCksIHRoaXMgd291bGQgaGFwcGVuOiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PVo4NlZfSUNVQ0Q0XG4gICAqXG4gICAqIEBldmVudCB2YWFkaW4tb3ZlcmxheS1vdXRzaWRlLWNsaWNrXG4gICAqIGZpcmVkIGJlZm9yZSB0aGUgYHZhYWRpbi1vdmVybGF5YCB3aWxsIGJlIGNsb3NlZCBvbiBvdXRzaWRlIGNsaWNrLiBJZiBjYW5jZWxlZCB0aGUgY2xvc2luZyBvZiB0aGUgb3ZlcmxheSBpcyBjYW5jZWxlZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX291dHNpZGVDbGlja0xpc3RlbmVyKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluZGV4T2YodGhpcy4kLm92ZXJsYXkpICE9PSAtMSB8fCB0aGlzLl9tb3VzZURvd25JbnNpZGUgfHwgdGhpcy5fbW91c2VVcEluc2lkZSkge1xuICAgICAgdGhpcy5fbW91c2VEb3duSW5zaWRlID0gZmFsc2U7XG4gICAgICB0aGlzLl9tb3VzZVVwSW5zaWRlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5fbGFzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV2dCA9IG5ldyBDdXN0b21FdmVudCgndmFhZGluLW92ZXJsYXktb3V0c2lkZS1jbGljaycsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgZGV0YWlsOiB7IHNvdXJjZUV2ZW50OiBldmVudCB9LFxuICAgIH0pO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgaWYgKHRoaXMub3BlbmVkICYmICFldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgdGhpcy5jbG9zZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBldmVudCB2YWFkaW4tb3ZlcmxheS1lc2NhcGUtcHJlc3NcbiAgICogZmlyZWQgYmVmb3JlIHRoZSBgdmFhZGluLW92ZXJsYXlgIHdpbGwgYmUgY2xvc2VkIG9uIEVTQyBidXR0b24gcHJlc3MuIElmIGNhbmNlbGVkIHRoZSBjbG9zaW5nIG9mIHRoZSBvdmVybGF5IGlzIGNhbmNlbGVkIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfa2V5ZG93bkxpc3RlbmVyKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9sYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVEFCXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicgJiYgdGhpcy5mb2N1c1RyYXAgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIC8vIGlmIG9ubHkgdGFiIGtleSBpcyBwcmVzc2VkLCBjeWNsZSBmb3J3YXJkLCBlbHNlIGN5Y2xlIGJhY2t3YXJkcy5cbiAgICAgIHRoaXMuX2N5Y2xlVGFiKGV2ZW50LnNoaWZ0S2V5ID8gLTEgOiAxKTtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gRVNDXG4gICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2ZW50LmtleSA9PT0gJ0VzYycpIHtcbiAgICAgIGNvbnN0IGV2dCA9IG5ldyBDdXN0b21FdmVudCgndmFhZGluLW92ZXJsYXktZXNjYXBlLXByZXNzJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICBkZXRhaWw6IHsgc291cmNlRXZlbnQ6IGV2ZW50IH0sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAodGhpcy5vcGVuZWQgJiYgIWV2dC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIF9lbnN1cmVUZW1wbGF0aXplZCgpIHtcbiAgICB0aGlzLl9zZXRUZW1wbGF0ZUZyb21Ob2RlcyhBcnJheS5mcm9tKHRoaXMuY2hpbGRyZW4pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZXZlbnQgdmFhZGluLW92ZXJsYXktb3BlblxuICAgKiBmaXJlZCBhZnRlciB0aGUgYHZhYWRpbi1vdmVybGF5YCBpcyBvcGVuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb3BlbmVkQ2hhbmdlZChvcGVuZWQsIHdhc09wZW5lZCkge1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVRlbXBsYXRpemVkKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wZW5lZCkge1xuICAgICAgLy8gU3RvcmUgZm9jdXNlZCBub2RlLlxuICAgICAgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgICB0aGlzLl9hbmltYXRlZE9wZW5pbmcoKTtcblxuICAgICAgYWZ0ZXJOZXh0UmVuZGVyKHRoaXMsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNUcmFwICYmICF0aGlzLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5fY3ljbGVUYWIoMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3ZhYWRpbi1vdmVybGF5LW9wZW4nLCB7IGJ1YmJsZXM6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5tb2RlbGVzcykge1xuICAgICAgICB0aGlzLl9hZGRHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdhc09wZW5lZCkge1xuICAgICAgdGhpcy5fYW5pbWF0ZWRDbG9zaW5nKCk7XG5cbiAgICAgIGlmICghdGhpcy5tb2RlbGVzcykge1xuICAgICAgICB0aGlzLl9yZW1vdmVHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2hpZGRlbkNoYW5nZWQoaGlkZGVuKSB7XG4gICAgaWYgKGhpZGRlbiAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2xvc2luZycpKSB7XG4gICAgICB0aGlzLl9mbHVzaEFuaW1hdGlvbignY2xvc2luZycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvdWxkQW5pbWF0ZSgpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKCdhbmltYXRpb24tbmFtZScpO1xuICAgIGNvbnN0IGhpZGRlbiA9IGdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpID09PSAnbm9uZSc7XG4gICAgcmV0dXJuICFoaWRkZW4gJiYgbmFtZSAmJiBuYW1lICE9ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZW5xdWV1ZUFuaW1hdGlvbih0eXBlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBgX18ke3R5cGV9SGFuZGxlcmA7XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudCAmJiBldmVudC50YXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgbGlzdGVuZXIpO1xuICAgICAgZGVsZXRlIHRoaXNbaGFuZGxlcl07XG4gICAgfTtcbiAgICB0aGlzW2hhbmRsZXJdID0gbGlzdGVuZXI7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2ZsdXNoQW5pbWF0aW9uKHR5cGUpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gYF9fJHt0eXBlfUhhbmRsZXJgO1xuICAgIGlmICh0eXBlb2YgdGhpc1toYW5kbGVyXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1toYW5kbGVyXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIF9hbmltYXRlZE9wZW5pbmcoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQuYm9keSAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2xvc2luZycpKSB7XG4gICAgICB0aGlzLl9mbHVzaEFuaW1hdGlvbignY2xvc2luZycpO1xuICAgIH1cbiAgICB0aGlzLl9hdHRhY2hPdmVybGF5KCk7XG4gICAgaWYgKCF0aGlzLm1vZGVsZXNzKSB7XG4gICAgICB0aGlzLl9lbnRlck1vZGFsU3RhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ29wZW5pbmcnLCAnJyk7XG5cbiAgICBjb25zdCBmaW5pc2hPcGVuaW5nID0gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaXJvbi1vdmVybGF5LWNhbmNlbGVkJywgdGhpcy5fYm91bmRJcm9uT3ZlcmxheUNhbmNlbGVkTGlzdGVuZXIpO1xuXG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnb3BlbmluZycpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5fc2hvdWxkQW5pbWF0ZSgpKSB7XG4gICAgICB0aGlzLl9lbnF1ZXVlQW5pbWF0aW9uKCdvcGVuaW5nJywgZmluaXNoT3BlbmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaE9wZW5pbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfYXR0YWNoT3ZlcmxheSgpIHtcbiAgICB0aGlzLl9wbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3ZhYWRpbi1vdmVybGF5LXBsYWNlaG9sZGVyJyk7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9wbGFjZWhvbGRlciwgdGhpcyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICB0aGlzLmJyaW5nVG9Gcm9udCgpO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2FuaW1hdGVkQ2xvc2luZygpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29wZW5pbmcnKSkge1xuICAgICAgdGhpcy5fZmx1c2hBbmltYXRpb24oJ29wZW5pbmcnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLl9leGl0TW9kYWxTdGF0ZSgpO1xuXG4gICAgICBpZiAodGhpcy5yZXN0b3JlRm9jdXNPbkNsb3NlICYmIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlKSB7XG4gICAgICAgIC8vIElmIHRoZSBhY3RpdmVFbGVtZW50IGlzIGA8Ym9keT5gIG9yIGluc2lkZSB0aGUgb3ZlcmxheSxcbiAgICAgICAgLy8gd2UgYXJlIGFsbG93ZWQgdG8gcmVzdG9yZSB0aGUgZm9jdXMuIEluIGFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgZm9jdXMgbWlnaHQgaGF2ZSBiZWVuIG1vdmVkIGVsc2V3aGVyZSBieSBhbm90aGVyXG4gICAgICAgIC8vIGNvbXBvbmVudCBvciBieSB0aGUgdXNlciBpbnRlcmFjdGlvbiAoZS5nLiBjbGljayBvbiBhXG4gICAgICAgIC8vIGJ1dHRvbiBvdXRzaWRlIHRoZSBvdmVybGF5KS5cbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnQoKTtcblxuICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kZWVwQ29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Nsb3NpbmcnLCAnJyk7XG5cbiAgICAgIGNvbnN0IGZpbmlzaENsb3NpbmcgPSAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lyb24tb3ZlcmxheS1jYW5jZWxlZCcsIHRoaXMuX2JvdW5kSXJvbk92ZXJsYXlDYW5jZWxlZExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fZGV0YWNoT3ZlcmxheSgpO1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignW3BhcnQ9XCJvdmVybGF5XCJdJykuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BvaW50ZXItZXZlbnRzJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdjbG9zaW5nJyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc2hvdWxkQW5pbWF0ZSgpKSB7XG4gICAgICAgIHRoaXMuX2VucXVldWVBbmltYXRpb24oJ2Nsb3NpbmcnLCBmaW5pc2hDbG9zaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaENsb3NpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfZGV0YWNoT3ZlcmxheSgpIHtcbiAgICB0aGlzLl9wbGFjZWhvbGRlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLl9wbGFjZWhvbGRlcik7XG4gICAgdGhpcy5fcGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9wbGFjZWhvbGRlcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0YWNoZWQgb3ZlcmxheXMgaW4gdmlzdWFsIHN0YWNraW5nIG9yZGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGdldCBfX2F0dGFjaGVkSW5zdGFuY2VzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pXG4gICAgICAuZmlsdGVyKChlbCkgPT4gZWwgaW5zdGFuY2VvZiBPdmVybGF5RWxlbWVudCAmJiAhZWwuaGFzQXR0cmlidXRlKCdjbG9zaW5nJykpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5fX3pJbmRleCAtIGIuX196SW5kZXggfHwgMCk7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb25lIGluIHRoZSBvcGVuZWQgb3ZlcmxheXMgc3RhY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0IF9sYXN0KCkge1xuICAgIHJldHVybiB0aGlzID09PSBPdmVybGF5RWxlbWVudC5fX2F0dGFjaGVkSW5zdGFuY2VzLnBvcCgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9tb2RlbGVzc0NoYW5nZWQobW9kZWxlc3MpIHtcbiAgICBpZiAoIW1vZGVsZXNzKSB7XG4gICAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgICAgdGhpcy5fYWRkR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX2VudGVyTW9kYWxTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW1vdmVHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX2V4aXRNb2RhbFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2FkZEdsb2JhbExpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9ib3VuZE1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fYm91bmRNb3VzZVVwTGlzdGVuZXIpO1xuICAgIC8vIEZpcmVmb3ggbGVha3MgY2xpY2sgdG8gZG9jdW1lbnQgb24gY29udGV4dG1lbnUgZXZlbiBpZiBwcmV2ZW50ZWRcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05OTA2MTRcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE91dHNpZGVDbGlja0xpc3RlbmVyLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRLZXlkb3duTGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2VudGVyTW9kYWxTdGF0ZSgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzICE9PSAnbm9uZScpIHtcbiAgICAgIC8vIFNldCBib2R5IHBvaW50ZXItZXZlbnRzIHRvICdub25lJyB0byBkaXNhYmxlIG1vdXNlIGludGVyYWN0aW9ucyB3aXRoXG4gICAgICAvLyBvdGhlciBkb2N1bWVudCBub2Rlcy5cbiAgICAgIHRoaXMuX3ByZXZpb3VzRG9jdW1lbnRQb2ludGVyRXZlbnRzID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIERpc2FibGUgcG9pbnRlciBldmVudHMgaW4gb3RoZXIgYXR0YWNoZWQgb3ZlcmxheXNcbiAgICBPdmVybGF5RWxlbWVudC5fX2F0dGFjaGVkSW5zdGFuY2VzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBpZiAoZWwgIT09IHRoaXMpIHtcbiAgICAgICAgZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdbcGFydD1cIm92ZXJsYXlcIl0nKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX3JlbW92ZUdsb2JhbExpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9ib3VuZE1vdXNlRG93bkxpc3RlbmVyKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fYm91bmRNb3VzZVVwTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT3V0c2lkZUNsaWNrTGlzdGVuZXIsIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEtleWRvd25MaXN0ZW5lcik7XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfZXhpdE1vZGFsU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzRG9jdW1lbnRQb2ludGVyRXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFJlc3RvcmUgYm9keSBwb2ludGVyLWV2ZW50c1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gdGhpcy5fcHJldmlvdXNEb2N1bWVudFBvaW50ZXJFdmVudHM7XG4gICAgICBkZWxldGUgdGhpcy5fcHJldmlvdXNEb2N1bWVudFBvaW50ZXJFdmVudHM7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBwb2ludGVyIGV2ZW50cyBpbiB0aGUgcHJldmlvdXMgb3ZlcmxheShzKVxuICAgIGNvbnN0IGluc3RhbmNlcyA9IE92ZXJsYXlFbGVtZW50Ll9fYXR0YWNoZWRJbnN0YW5jZXM7XG4gICAgbGV0IGVsO1xuICAgIC8vIFVzZSBpbnN0YW5jZXMucG9wKCkgdG8gZW5zdXJlIHRoZSByZXZlcnNlIG9yZGVyXG4gICAgd2hpbGUgKChlbCA9IGluc3RhbmNlcy5wb3AoKSkpIHtcbiAgICAgIGlmIChlbCA9PT0gdGhpcykge1xuICAgICAgICAvLyBTa2lwIHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdbcGFydD1cIm92ZXJsYXlcIl0nKS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnKTtcbiAgICAgIGlmICghZWwubW9kZWxlc3MpIHtcbiAgICAgICAgLy8gU3RvcCBhZnRlciB0aGUgbGFzdCBtb2RhbFxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfcmVtb3ZlT2xkQ29udGVudCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudCB8fCAhdGhpcy5fY29udGVudE5vZGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy5fY29udGVudE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgPT09IHRoaXMuY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fb3JpZ2luYWxDb250ZW50UGFydCkge1xuICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgPGRpdiBwYXJ0PVwiY29udGVudFwiPlxuICAgICAgdGhpcy4kLmNvbnRlbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodGhpcy5fb3JpZ2luYWxDb250ZW50UGFydCwgdGhpcy4kLmNvbnRlbnQpO1xuICAgICAgdGhpcy4kLmNvbnRlbnQgPSB0aGlzLl9vcmlnaW5hbENvbnRlbnRQYXJ0O1xuICAgICAgdGhpcy5fb3JpZ2luYWxDb250ZW50UGFydCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl9vYnNlcnZlci5jb25uZWN0KCk7XG5cbiAgICB0aGlzLl9jb250ZW50Tm9kZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb250ZW50ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0YW5jZVByb3BzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zdGFtcE92ZXJsYXlUZW1wbGF0ZSh0ZW1wbGF0ZSwgaW5zdGFuY2VQcm9wcykge1xuICAgIHRoaXMuX3JlbW92ZU9sZENvbnRlbnQoKTtcblxuICAgIGlmICghdGVtcGxhdGUuX1RlbXBsYXRpemVyKSB7XG4gICAgICB0ZW1wbGF0ZS5fVGVtcGxhdGl6ZXIgPSB0ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgIGluc3RhbmNlUHJvcHM6IGluc3RhbmNlUHJvcHMsXG4gICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IHRlbXBsYXRlLl9UZW1wbGF0aXplcih7fSk7XG4gICAgdGhpcy5fY29udGVudE5vZGVzID0gQXJyYXkuZnJvbSh0aGlzLl9pbnN0YW5jZS5yb290LmNoaWxkTm9kZXMpO1xuXG4gICAgY29uc3QgdGVtcGxhdGVSb290ID0gdGVtcGxhdGUuX3RlbXBsYXRlUm9vdCB8fCAodGVtcGxhdGUuX3RlbXBsYXRlUm9vdCA9IHRlbXBsYXRlLmdldFJvb3ROb2RlKCkpO1xuXG4gICAgaWYgKHRlbXBsYXRlUm9vdCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIGlmICghdGhpcy4kLmNvbnRlbnQuc2hhZG93Um9vdCkge1xuICAgICAgICB0aGlzLiQuY29udGVudC5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzY29wZUNzc1RleHQgPSBBcnJheS5mcm9tKHRlbXBsYXRlUm9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpKS5yZWR1Y2UoXG4gICAgICAgIChyZXN1bHQsIHN0eWxlKSA9PiByZXN1bHQgKyBzdHlsZS50ZXh0Q29udGVudCxcbiAgICAgICAgJycsXG4gICAgICApO1xuXG4gICAgICAvLyBUaGUgb3ZlcmxheSByb2904oCZcyA6aG9zdCBzdHlsZXMgc2hvdWxkIG5vdCBhcHBseSBpbnNpZGUgdGhlIG92ZXJsYXlcbiAgICAgIHNjb3BlQ3NzVGV4dCA9IHNjb3BlQ3NzVGV4dC5yZXBsYWNlKC86aG9zdC9nLCAnOmhvc3Qtbm9tYXRjaCcpO1xuXG4gICAgICBpZiAoc2NvcGVDc3NUZXh0KSB7XG4gICAgICAgIC8vIEFwcGVuZCBhIHN0eWxlIHRvIHRoZSBjb250ZW50IHNoYWRvd1Jvb3RcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHNjb3BlQ3NzVGV4dDtcbiAgICAgICAgdGhpcy4kLmNvbnRlbnQuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnROb2Rlcy51bnNoaWZ0KHN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kLmNvbnRlbnQuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLl9pbnN0YW5jZS5yb290KTtcbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuJC5jb250ZW50LnNoYWRvd1Jvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5faW5zdGFuY2Uucm9vdCk7XG4gICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfcmVtb3ZlTmV3UmVuZGVyZXJPclRlbXBsYXRlKHRlbXBsYXRlLCBvbGRUZW1wbGF0ZSwgcmVuZGVyZXIsIG9sZFJlbmRlcmVyKSB7XG4gICAgaWYgKHRlbXBsYXRlICE9PSBvbGRUZW1wbGF0ZSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBvbGRSZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3RlbXBsYXRlT3JSZW5kZXJlckNoYW5nZWQodGVtcGxhdGUsIHJlbmRlcmVyLCBvd25lciwgbW9kZWwsIGluc3RhbmNlUHJvcHMsIG9wZW5lZCkge1xuICAgIGlmICh0ZW1wbGF0ZSAmJiByZW5kZXJlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTmV3UmVuZGVyZXJPclRlbXBsYXRlKHRlbXBsYXRlLCB0aGlzLl9vbGRUZW1wbGF0ZSwgcmVuZGVyZXIsIHRoaXMuX29sZFJlbmRlcmVyKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHNob3VsZCBvbmx5IHVzZSBlaXRoZXIgYSByZW5kZXJlciBvciBhIHRlbXBsYXRlIGZvciBvdmVybGF5IGNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvd25lck9yTW9kZWxDaGFuZ2VkID0gdGhpcy5fb2xkT3duZXIgIT09IG93bmVyIHx8IHRoaXMuX29sZE1vZGVsICE9PSBtb2RlbDtcbiAgICB0aGlzLl9vbGRNb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuX29sZE93bmVyID0gb3duZXI7XG5cbiAgICBjb25zdCB0ZW1wbGF0ZU9ySW5zdGFuY2VQcm9wc0NoYW5nZWQgPSB0aGlzLl9vbGRJbnN0YW5jZVByb3BzICE9PSBpbnN0YW5jZVByb3BzIHx8IHRoaXMuX29sZFRlbXBsYXRlICE9PSB0ZW1wbGF0ZTtcbiAgICB0aGlzLl9vbGRJbnN0YW5jZVByb3BzID0gaW5zdGFuY2VQcm9wcztcbiAgICB0aGlzLl9vbGRUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gICAgY29uc3QgcmVuZGVyZXJDaGFuZ2VkID0gdGhpcy5fb2xkUmVuZGVyZXIgIT09IHJlbmRlcmVyO1xuICAgIHRoaXMuX29sZFJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICBjb25zdCBvcGVuZWRDaGFuZ2VkID0gdGhpcy5fb2xkT3BlbmVkICE9PSBvcGVuZWQ7XG4gICAgdGhpcy5fb2xkT3BlbmVkID0gb3BlbmVkO1xuXG4gICAgaWYgKHJlbmRlcmVyQ2hhbmdlZCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gdGhpcztcbiAgICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgIC8vIFdoZW5ldmVyIGEgTGl0LWJhc2VkIHJlbmRlcmVyIGlzIHVzZWQsIGl0IGFzc2lnbnMgYSBMaXQgcGFydCB0byB0aGUgbm9kZSBpdCB3YXMgcmVuZGVyZWQgaW50by5cbiAgICAgIC8vIFdoZW4gY2xlYXJpbmcgdGhlIHJlbmRlcmVkIGNvbnRlbnQsIHRoaXMgcGFydCBuZWVkcyB0byBiZSBtYW51YWxseSBkaXNwb3NlZCBvZi5cbiAgICAgIC8vIE90aGVyd2lzZSwgdXNpbmcgYSBMaXQtYmFzZWQgcmVuZGVyZXIgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBvciByZW5kZXIgbm90aGluZyBhZnRlcndhcmQuXG4gICAgICBkZWxldGUgdGhpcy5jb250ZW50Ll8kbGl0UGFydCQ7XG4gICAgfVxuXG4gICAgaWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlT3JJbnN0YW5jZVByb3BzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fc3RhbXBPdmVybGF5VGVtcGxhdGUodGVtcGxhdGUsIGluc3RhbmNlUHJvcHMpO1xuICAgIH0gZWxzZSBpZiAocmVuZGVyZXIgJiYgKHJlbmRlcmVyQ2hhbmdlZCB8fCBvcGVuZWRDaGFuZ2VkIHx8IG93bmVyT3JNb2RlbENoYW5nZWQpKSB7XG4gICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9pc0ZvY3VzZWQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQuZ2V0Um9vdE5vZGUoKS5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50c1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9mb2N1c2VkSW5kZXgoZWxlbWVudHMpIHtcbiAgICBlbGVtZW50cyA9IGVsZW1lbnRzIHx8IHRoaXMuX2dldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgcmV0dXJuIGVsZW1lbnRzLmluZGV4T2YoZWxlbWVudHMuZmlsdGVyKHRoaXMuX2lzRm9jdXNlZCkucG9wKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmNyZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGluZGV4XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9jeWNsZVRhYihpbmNyZW1lbnQsIGluZGV4KSB7XG4gICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSB0aGlzLl9nZXRGb2N1c2FibGVFbGVtZW50cygpO1xuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5fZm9jdXNlZEluZGV4KGZvY3VzYWJsZUVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBpbmRleCArPSBpbmNyZW1lbnQ7XG5cbiAgICAvLyByb2xsb3ZlciB0byBmaXJzdCBpdGVtXG4gICAgaWYgKGluZGV4ID49IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgLy8gZ28gdG8gbGFzdCBpdGVtXG4gICAgfSBlbHNlIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBmb2N1c2FibGVFbGVtZW50c1tpbmRleF0uZm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQXJyYXk8IUhUTUxFbGVtZW50Pn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2dldEZvY3VzYWJsZUVsZW1lbnRzKCkge1xuICAgIC8vIGNvbGxlY3QgYWxsIGZvY3VzYWJsZSBlbGVtZW50c1xuICAgIHJldHVybiBGb2N1c2FibGVzSGVscGVyLmdldFRhYmJhYmxlTm9kZXModGhpcy4kLm92ZXJsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFFbGVtZW50fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudCgpIHtcbiAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2FjdGl2ZUVsZW1lbnRcbiAgICBsZXQgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHdoaWxlIChhY3RpdmUuc2hhZG93Um9vdCAmJiBhY3RpdmUuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICBhY3RpdmUgPSBhY3RpdmUuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2RlZXBDb250YWlucyhub2RlKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnMobm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgbiA9IG5vZGU7XG4gICAgY29uc3QgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIC8vIHdhbGsgZnJvbSBub2RlIHRvIGB0aGlzYCBvciBgZG9jdW1lbnRgXG4gICAgd2hpbGUgKG4gJiYgbiAhPT0gZG9jICYmIG4gIT09IHRoaXMpIHtcbiAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgIH1cbiAgICByZXR1cm4gbiA9PT0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCcmluZ3MgdGhlIG92ZXJsYXkgYXMgdmlzdWFsbHkgdGhlIGZyb250bW9zdCBvbmVcbiAgICovXG4gIGJyaW5nVG9Gcm9udCgpIHtcbiAgICBsZXQgekluZGV4ID0gJyc7XG4gICAgY29uc3QgZnJvbnRtb3N0ID0gT3ZlcmxheUVsZW1lbnQuX19hdHRhY2hlZEluc3RhbmNlcy5maWx0ZXIoKG8pID0+IG8gIT09IHRoaXMpLnBvcCgpO1xuICAgIGlmIChmcm9udG1vc3QpIHtcbiAgICAgIGNvbnN0IGZyb250bW9zdFpJbmRleCA9IGZyb250bW9zdC5fX3pJbmRleDtcbiAgICAgIHpJbmRleCA9IGZyb250bW9zdFpJbmRleCArIDE7XG4gICAgfVxuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gekluZGV4O1xuICAgIHRoaXMuX196SW5kZXggPSB6SW5kZXggfHwgcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRoaXMpLnpJbmRleCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKE92ZXJsYXlFbGVtZW50LmlzLCBPdmVybGF5RWxlbWVudCk7XG5leHBvcnQgeyBPdmVybGF5RWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay-styles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay-styles.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_vaadin_material_styles_mixins_overlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/mixins/overlay.js */ \"./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.registerStyles)('vaadin-overlay', _vaadin_vaadin_material_styles_mixins_overlay_js__WEBPACK_IMPORTED_MODULE_0__.overlay, {\n  moduleId: 'material-vaadin-overlay'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS90aGVtZS9tYXRlcmlhbC92YWFkaW4tb3ZlcmxheS1zdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS90aGVtZS9tYXRlcmlhbC92YWFkaW4tb3ZlcmxheS1zdHlsZXMuanM/NTlmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvdmVybGF5IH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9vdmVybGF5LmpzJztcbmltcG9ydCB7IHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxucmVnaXN0ZXJTdHlsZXMoJ3ZhYWRpbi1vdmVybGF5Jywgb3ZlcmxheSwgeyBtb2R1bGVJZDogJ21hdGVyaWFsLXZhYWRpbi1vdmVybGF5JyB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_overlay_styles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-overlay-styles.js */ \"./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay-styles.js\");\n/* harmony import */ var _src_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/vaadin-overlay.js */ \"./node_modules/@vaadin/vaadin-overlay/src/vaadin-overlay.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS90aGVtZS9tYXRlcmlhbC92YWFkaW4tb3ZlcmxheS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tb3ZlcmxheS90aGVtZS9tYXRlcmlhbC92YWFkaW4tb3ZlcmxheS5qcz8wMmJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi92YWFkaW4tb3ZlcmxheS1zdHlsZXMuanMnO1xuaW1wb3J0ICcuLi8uLi9zcmMvdmFhZGluLW92ZXJsYXkuanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-overlay/theme/material/vaadin-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/register-styles.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/register-styles.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"css\": () => (/* reexport safe */ _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* reexport safe */ _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__.registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vcmVnaXN0ZXItc3R5bGVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi9yZWdpc3Rlci1zdHlsZXMuanM/NjIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmV4cG9ydCB7IHJlZ2lzdGVyU3R5bGVzLCBjc3MsIHVuc2FmZUNTUyB9IGZyb20gJy4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-themable-mixin/register-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemableMixin\": () => (/* binding */ ThemableMixin),\n/* harmony export */   \"__themeRegistry\": () => (/* binding */ themeRegistry),\n/* harmony export */   \"css\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* binding */ registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var _vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-theme-property-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\n\nconst themeRegistry = [];\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\n\nfunction registerStyles(themeFor, styles, options = {}) {\n  if (themeFor) {\n    const elementClass = customElements.get(themeFor);\n\n    if (elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__finalized')) {\n      console.warn(`The custom element definition for \"${themeFor}\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element.`);\n    }\n  }\n\n  styles = recursiveFlattenStyles(styles);\n\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId\n    });\n  }\n}\n/**\n * Returns all registered themes. By default the themeRegistry is returend as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\n\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  } else {\n    return themeRegistry;\n  }\n}\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\n\n\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some(themeForToken => {\n    return new RegExp('^' + themeForToken.split('*').join('.*') + '$').test(tagName);\n  });\n}\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\n\n\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n\n  if (moduleName.indexOf('lumo-') === 0 || moduleName.indexOf('material-') === 0) {\n    includePriority = 1;\n  } else if (moduleName.indexOf('vaadin-') === 0) {\n    includePriority = 2;\n  }\n\n  return includePriority;\n}\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\n\n\nfunction recursiveFlattenStyles(styles = [], result = []) {\n  if (styles instanceof lit__WEBPACK_IMPORTED_MODULE_0__.CSSResult) {\n    result.push(styles);\n  } else if (Array.isArray(styles)) {\n    styles.forEach(style => recursiveFlattenStyles(style, result));\n  } else {\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n  }\n\n  return result;\n}\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\n\n\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n\n  if (theme.include) {\n    [].concat(theme.include).forEach(includeModuleId => {\n      const includedTheme = getAllThemes().find(s => s.moduleId === includeModuleId);\n\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n\n  return includedStyles;\n}\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\n\n\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = styles // Remove duplicates so that the last occurrence remains\n  .filter((style, index) => index === styles.lastIndexOf(style)).map(style => style.cssText).join('\\n');\n  template.content.appendChild(styleEl);\n}\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\n\n\nfunction getThemes(tagName) {\n  const defaultModuleName = tagName + '-default-theme';\n  const themes = getAllThemes() // Filter by matching themeFor properties\n  .filter(theme => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map(theme => ({ ...theme,\n    // Prepend styles from included themes\n    styles: [...getIncludedStyles(theme), ...theme.styles],\n    // Map moduleId to includePriority\n    includePriority: getIncludePriority(theme.moduleId)\n  })) // Sort by includePriority\n  .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n\n  if (themes.length > 0) {\n    return themes;\n  } else {\n    // No theme modules found, return the default module if it exists\n    return getAllThemes().filter(theme => theme.moduleId === defaultModuleName);\n  }\n}\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\n\n\nconst ThemableMixin = superClass => class VaadinThemableMixin extends (0,_vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ThemePropertyMixin)(superClass) {\n  /**\n   * Covers PolymerElement based component styling\n   * @protected\n   */\n  static finalize() {\n    super.finalize();\n    const template = this.prototype._template;\n\n    if (!template || template.__themes) {\n      return;\n    }\n\n    const inheritedTemplate = Object.getPrototypeOf(this.prototype)._template;\n\n    const inheritedThemes = (inheritedTemplate ? inheritedTemplate.__themes : []) || [];\n    template.__themes = [...inheritedThemes, ...getThemes(this.is)]; // Get flattened styles array\n\n    const styles = template.__themes.reduce((styles, theme) => [...styles, ...theme.styles], []);\n\n    addStylesToTemplate(styles, template);\n  }\n  /**\n   * Covers LitElement based component styling\n   *\n   * NOTE: This is not yet an offically supported API!\n   *\n   * TODO: Add tests (run a variation of themable-mixin.test.js where the components get created as LitElements)\n   * @protected\n   */\n\n\n  static finalizeStyles(styles) {\n    return getThemes(this.is) // Get flattened styles array\n    .reduce((styles, theme) => [...styles, ...theme.styles], []).concat(styles);\n  }\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUhBOztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBRUE7O0FBR0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQXRDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzP2FlMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBjc3MsIENTU1Jlc3VsdCwgdW5zYWZlQ1NTIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IFRoZW1lUHJvcGVydHlNaXhpbiB9IGZyb20gJy4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzJztcblxuZXhwb3J0IHsgY3NzLCB1bnNhZmVDU1MgfTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaGVtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRoZW1lRm9yXG4gKiBAcHJvcGVydHkge0NTU1Jlc3VsdFtdfSBzdHlsZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgc3RyaW5nW119IFtpbmNsdWRlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2R1bGVJZF1cbiAqXG4gKiBAdHlwZWRlZiB7Q1NTUmVzdWx0W10gfCBDU1NSZXN1bHR9IENTU1Jlc3VsdEdyb3VwXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7VGhlbWVbXX1cbiAqL1xuY29uc3QgdGhlbWVSZWdpc3RyeSA9IFtdO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBDU1Mgc3R5bGVzIGZvciBhIGNvbXBvbmVudCB0eXBlLiBNYWtlIHN1cmUgdG8gcmVnaXN0ZXIgdGhlIHN0eWxlcyBiZWZvcmVcbiAqIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBvZiB0aGUgdHlwZSBpcyBhdHRhY2hlZCB0byBET00uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lRm9yIFRoZSBsb2NhbC90YWcgbmFtZSBvZiB0aGUgY29tcG9uZW50IHR5cGUgdG8gcmVnaXN0ZXIgdGhlIHN0eWxlcyBmb3JcbiAqIEBwYXJhbSB7Q1NTUmVzdWx0R3JvdXB9IHN0eWxlcyBUaGUgQ1NTIHN0eWxlIHJ1bGVzIHRvIGJlIHJlZ2lzdGVyZWQgZm9yIHRoZSBjb21wb25lbnQgdHlwZVxuICogbWF0Y2hpbmcgdGhlbWVGb3IgYW5kIGluY2x1ZGVkIGluIHRoZSBsb2NhbCBzY29wZSBvZiBlYWNoIGNvbXBvbmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHt7bW9kdWxlSWQ/OiBzdHJpbmcsIGluY2x1ZGU/OiBzdHJpbmcgfCBzdHJpbmdbXX19IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXModGhlbWVGb3IsIHN0eWxlcywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0aGVtZUZvcikge1xuICAgIGNvbnN0IGVsZW1lbnRDbGFzcyA9IGN1c3RvbUVsZW1lbnRzLmdldCh0aGVtZUZvcik7XG4gICAgaWYgKGVsZW1lbnRDbGFzcyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWxlbWVudENsYXNzLCAnX19maW5hbGl6ZWQnKSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgY3VzdG9tIGVsZW1lbnQgZGVmaW5pdGlvbiBmb3IgXCIke3RoZW1lRm9yfVwiXG4gICAgICB3YXMgZmluYWxpemVkIGJlZm9yZSBhIHN0eWxlIG1vZHVsZSB3YXMgcmVnaXN0ZXJlZC5cbiAgICAgIE1ha2Ugc3VyZSB0byBhZGQgY29tcG9uZW50IHNwZWNpZmljIHN0eWxlIG1vZHVsZXMgYmVmb3JlXG4gICAgICBpbXBvcnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgfVxuICB9XG5cbiAgc3R5bGVzID0gcmVjdXJzaXZlRmxhdHRlblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmICh3aW5kb3cuVmFhZGluICYmIHdpbmRvdy5WYWFkaW4uc3R5bGVNb2R1bGVzKSB7XG4gICAgd2luZG93LlZhYWRpbi5zdHlsZU1vZHVsZXMucmVnaXN0ZXJTdHlsZXModGhlbWVGb3IsIHN0eWxlcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhlbWVSZWdpc3RyeS5wdXNoKHtcbiAgICAgIHRoZW1lRm9yLFxuICAgICAgc3R5bGVzLFxuICAgICAgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlLFxuICAgICAgbW9kdWxlSWQ6IG9wdGlvbnMubW9kdWxlSWQsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHRoZW1lcy4gQnkgZGVmYXVsdCB0aGUgdGhlbWVSZWdpc3RyeSBpcyByZXR1cmVuZCBhcyBpcy5cbiAqIEluIGNhc2UgdGhlIHN0eWxlLW1vZHVsZXMgYWRhcHRlciBpcyBpbXBvcnRlZCwgdGhlIHRoZW1lcyBhcmUgb2J0YWluZWQgZnJvbSB0aGVyZSBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7VGhlbWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsVGhlbWVzKCkge1xuICBpZiAod2luZG93LlZhYWRpbiAmJiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcykge1xuICAgIHJldHVybiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcy5nZXRBbGxUaGVtZXMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhlbWVSZWdpc3RyeTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGhlbWVGb3Igc3RyaW5nIG1hdGNoZXMgdGhlIHRhZyBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhlbWVGb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1RoZW1lRm9yKHRoZW1lRm9yLCB0YWdOYW1lKSB7XG4gIHJldHVybiAodGhlbWVGb3IgfHwgJycpLnNwbGl0KCcgJykuc29tZSgodGhlbWVGb3JUb2tlbikgPT4ge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHRoZW1lRm9yVG9rZW4uc3BsaXQoJyonKS5qb2luKCcuKicpICsgJyQnKS50ZXN0KHRhZ05hbWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNYXBzIHRoZSBtb2R1bGVOYW1lIHRvIGFuIGluY2x1ZGUgcHJpb3JpdHkgbnVtYmVyIHdoaWNoIGlzIHVzZWQgZm9yXG4gKiBkZXRlcm1pbmluZyB0aGUgb3JkZXIgaW4gd2hpY2ggc3R5bGVzIGFyZSBhcHBsaWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEluY2x1ZGVQcmlvcml0eShtb2R1bGVOYW1lID0gJycpIHtcbiAgbGV0IGluY2x1ZGVQcmlvcml0eSA9IDA7XG4gIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoJ2x1bW8tJykgPT09IDAgfHwgbW9kdWxlTmFtZS5pbmRleE9mKCdtYXRlcmlhbC0nKSA9PT0gMCkge1xuICAgIGluY2x1ZGVQcmlvcml0eSA9IDE7XG4gIH0gZWxzZSBpZiAobW9kdWxlTmFtZS5pbmRleE9mKCd2YWFkaW4tJykgPT09IDApIHtcbiAgICBpbmNsdWRlUHJpb3JpdHkgPSAyO1xuICB9XG4gIHJldHVybiBpbmNsdWRlUHJpb3JpdHk7XG59XG5cbi8qKlxuICogRmxhdHRlbnMgdGhlIHN0eWxlcyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIHN0eWxlcy5cbiAqIEBwYXJhbSB7Q1NTUmVzdWx0R3JvdXB9IHN0eWxlc1xuICogQHBhcmFtIHtDU1NSZXN1bHRbXX0gcmVzdWx0XG4gKiBAcmV0dXJucyB7Q1NTUmVzdWx0W119XG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZUZsYXR0ZW5TdHlsZXMoc3R5bGVzID0gW10sIHJlc3VsdCA9IFtdKSB7XG4gIGlmIChzdHlsZXMgaW5zdGFuY2VvZiBDU1NSZXN1bHQpIHtcbiAgICByZXN1bHQucHVzaChzdHlsZXMpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSkgPT4gcmVjdXJzaXZlRmxhdHRlblN0eWxlcyhzdHlsZSwgcmVzdWx0KSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdBbiBpdGVtIGluIHN0eWxlcyBpcyBub3Qgb2YgdHlwZSBDU1NSZXN1bHQuIFVzZSBgdW5zYWZlQ1NTYCBvciBgY3NzYC4nKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgYW4gYXJyYXkgb2YgQ1NTUmVzdWx0cyBtYXRjaGluZyB0aGUgaW5jbHVkZSBwcm9wZXJ0eSBvZiB0aGUgdGhlbWUuXG4gKiBAcGFyYW0ge1RoZW1lfSB0aGVtZVxuICogQHJldHVybnMge0NTU1Jlc3VsdFtdfVxuICovXG5mdW5jdGlvbiBnZXRJbmNsdWRlZFN0eWxlcyh0aGVtZSkge1xuICBjb25zdCBpbmNsdWRlZFN0eWxlcyA9IFtdO1xuICBpZiAodGhlbWUuaW5jbHVkZSkge1xuICAgIFtdLmNvbmNhdCh0aGVtZS5pbmNsdWRlKS5mb3JFYWNoKChpbmNsdWRlTW9kdWxlSWQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVkVGhlbWUgPSBnZXRBbGxUaGVtZXMoKS5maW5kKChzKSA9PiBzLm1vZHVsZUlkID09PSBpbmNsdWRlTW9kdWxlSWQpO1xuICAgICAgaWYgKGluY2x1ZGVkVGhlbWUpIHtcbiAgICAgICAgaW5jbHVkZWRTdHlsZXMucHVzaCguLi5nZXRJbmNsdWRlZFN0eWxlcyhpbmNsdWRlZFRoZW1lKSwgLi4uaW5jbHVkZWRUaGVtZS5zdHlsZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbmNsdWRlZCBtb2R1bGVJZCAke2luY2x1ZGVNb2R1bGVJZH0gbm90IGZvdW5kIGluIHN0eWxlIHJlZ2lzdHJ5YCk7XG4gICAgICB9XG4gICAgfSwgdGhlbWUuc3R5bGVzKTtcbiAgfVxuICByZXR1cm4gaW5jbHVkZWRTdHlsZXM7XG59XG5cbi8qKlxuICogSW5jbHVkZXMgdGhlIHN0eWxlcyB0byB0aGUgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdFtdfSBzdHlsZXNcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZnVuY3Rpb24gYWRkU3R5bGVzVG9UZW1wbGF0ZShzdHlsZXMsIHRlbXBsYXRlKSB7XG4gIGNvbnN0IHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZUVsLmlubmVySFRNTCA9IHN0eWxlc1xuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzIHNvIHRoYXQgdGhlIGxhc3Qgb2NjdXJyZW5jZSByZW1haW5zXG4gICAgLmZpbHRlcigoc3R5bGUsIGluZGV4KSA9PiBpbmRleCA9PT0gc3R5bGVzLmxhc3RJbmRleE9mKHN0eWxlKSlcbiAgICAubWFwKChzdHlsZSkgPT4gc3R5bGUuY3NzVGV4dClcbiAgICAuam9pbignXFxuJyk7XG4gIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGVtZXMgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3Igc3R5bGluZyBhIGNvbXBvbmVudCBtYXRjaGluZ1xuICogdGhlIHRhZyBuYW1lLiBUaGUgYXJyYXkgaXMgc29ydGVkIGJ5IHRoZSBpbmNsdWRlIG9yZGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAqIEByZXR1cm5zIHtUaGVtZVtdfVxuICovXG5mdW5jdGlvbiBnZXRUaGVtZXModGFnTmFtZSkge1xuICBjb25zdCBkZWZhdWx0TW9kdWxlTmFtZSA9IHRhZ05hbWUgKyAnLWRlZmF1bHQtdGhlbWUnO1xuXG4gIGNvbnN0IHRoZW1lcyA9IGdldEFsbFRoZW1lcygpXG4gICAgLy8gRmlsdGVyIGJ5IG1hdGNoaW5nIHRoZW1lRm9yIHByb3BlcnRpZXNcbiAgICAuZmlsdGVyKCh0aGVtZSkgPT4gdGhlbWUubW9kdWxlSWQgIT09IGRlZmF1bHRNb2R1bGVOYW1lICYmIG1hdGNoZXNUaGVtZUZvcih0aGVtZS50aGVtZUZvciwgdGFnTmFtZSkpXG4gICAgLm1hcCgodGhlbWUpID0+ICh7XG4gICAgICAuLi50aGVtZSxcbiAgICAgIC8vIFByZXBlbmQgc3R5bGVzIGZyb20gaW5jbHVkZWQgdGhlbWVzXG4gICAgICBzdHlsZXM6IFsuLi5nZXRJbmNsdWRlZFN0eWxlcyh0aGVtZSksIC4uLnRoZW1lLnN0eWxlc10sXG4gICAgICAvLyBNYXAgbW9kdWxlSWQgdG8gaW5jbHVkZVByaW9yaXR5XG4gICAgICBpbmNsdWRlUHJpb3JpdHk6IGdldEluY2x1ZGVQcmlvcml0eSh0aGVtZS5tb2R1bGVJZCksXG4gICAgfSkpXG4gICAgLy8gU29ydCBieSBpbmNsdWRlUHJpb3JpdHlcbiAgICAuc29ydCgodGhlbWVBLCB0aGVtZUIpID0+IHRoZW1lQi5pbmNsdWRlUHJpb3JpdHkgLSB0aGVtZUEuaW5jbHVkZVByaW9yaXR5KTtcblxuICBpZiAodGhlbWVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdGhlbWVzO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIHRoZW1lIG1vZHVsZXMgZm91bmQsIHJldHVybiB0aGUgZGVmYXVsdCBtb2R1bGUgaWYgaXQgZXhpc3RzXG4gICAgcmV0dXJuIGdldEFsbFRoZW1lcygpLmZpbHRlcigodGhlbWUpID0+IHRoZW1lLm1vZHVsZUlkID09PSBkZWZhdWx0TW9kdWxlTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcG9seW1lck1peGluXG4gKiBAbWl4ZXMgVGhlbWVQcm9wZXJ0eU1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBUaGVtYWJsZU1peGluID0gKHN1cGVyQ2xhc3MpID0+XG4gIGNsYXNzIFZhYWRpblRoZW1hYmxlTWl4aW4gZXh0ZW5kcyBUaGVtZVByb3BlcnR5TWl4aW4oc3VwZXJDbGFzcykge1xuICAgIC8qKlxuICAgICAqIENvdmVycyBQb2x5bWVyRWxlbWVudCBiYXNlZCBjb21wb25lbnQgc3R5bGluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICBzdXBlci5maW5hbGl6ZSgpO1xuXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZTtcbiAgICAgIGlmICghdGVtcGxhdGUgfHwgdGVtcGxhdGUuX190aGVtZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmhlcml0ZWRUZW1wbGF0ZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLnByb3RvdHlwZSkuX3RlbXBsYXRlO1xuICAgICAgY29uc3QgaW5oZXJpdGVkVGhlbWVzID0gKGluaGVyaXRlZFRlbXBsYXRlID8gaW5oZXJpdGVkVGVtcGxhdGUuX190aGVtZXMgOiBbXSkgfHwgW107XG5cbiAgICAgIHRlbXBsYXRlLl9fdGhlbWVzID0gWy4uLmluaGVyaXRlZFRoZW1lcywgLi4uZ2V0VGhlbWVzKHRoaXMuaXMpXTtcblxuICAgICAgLy8gR2V0IGZsYXR0ZW5lZCBzdHlsZXMgYXJyYXlcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHRlbXBsYXRlLl9fdGhlbWVzLnJlZHVjZSgoc3R5bGVzLCB0aGVtZSkgPT4gWy4uLnN0eWxlcywgLi4udGhlbWUuc3R5bGVzXSwgW10pO1xuICAgICAgYWRkU3R5bGVzVG9UZW1wbGF0ZShzdHlsZXMsIHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3ZlcnMgTGl0RWxlbWVudCBiYXNlZCBjb21wb25lbnQgc3R5bGluZ1xuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBub3QgeWV0IGFuIG9mZmljYWxseSBzdXBwb3J0ZWQgQVBJIVxuICAgICAqXG4gICAgICogVE9ETzogQWRkIHRlc3RzIChydW4gYSB2YXJpYXRpb24gb2YgdGhlbWFibGUtbWl4aW4udGVzdC5qcyB3aGVyZSB0aGUgY29tcG9uZW50cyBnZXQgY3JlYXRlZCBhcyBMaXRFbGVtZW50cylcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplU3R5bGVzKHN0eWxlcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZ2V0VGhlbWVzKHRoaXMuaXMpXG4gICAgICAgICAgLy8gR2V0IGZsYXR0ZW5lZCBzdHlsZXMgYXJyYXlcbiAgICAgICAgICAucmVkdWNlKChzdHlsZXMsIHRoZW1lKSA9PiBbLi4uc3R5bGVzLCAuLi50aGVtZS5zdHlsZXNdLCBbXSlcbiAgICAgICAgICAuY29uY2F0KHN0eWxlcylcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG5leHBvcnQgeyB0aGVtZVJlZ2lzdHJ5IGFzIF9fdGhlbWVSZWdpc3RyeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemePropertyMixin\": () => (/* binding */ ThemePropertyMixin)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * @polymerMixin\n */\nconst ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/ds/customization/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @protected\n       */\n      theme: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n  /** @protected */\n\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n\n    if (name === 'theme') {\n      this._setTheme(newValue);\n    }\n  }\n\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQWxCQTtBQXVCQTtBQUVBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQWxDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzP2I4YjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IFRoZW1lUHJvcGVydHlNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5UaGVtZVByb3BlcnR5TWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHByb3BlcnR5IHdpdGggdGhlbWUgYXR0cmlidXRlIHZhbHVlIGZhY2lsaXRhdGluZyBwcm9wYWdhdGlvblxuICAgICAgICAgKiBpbiBzaGFkb3cgRE9NLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgXG4gICAgICAgICAqIGF0dHJpYnV0ZSB2YWx1ZSB0byB0aGUgc3ViLWNvbXBvbmVudHMgaW4gU2hhZG93IERPTSBieSBiaW5kaW5nXG4gICAgICAgICAqIHRoZSBzdWItY29tcG9uZW504oCZcyBcInRoZW1lXCIgYXR0cmlidXRlIHRvIHRoZSBgdGhlbWVgIHByb3BlcnR5IG9mXG4gICAgICAgICAqIHRoZSBob3N0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEU6KiogRXh0ZW5kaW5nIHRoZSBtaXhpbiBvbmx5IHByb3ZpZGVzIHRoZSBwcm9wZXJ0eSBmb3IgYmluZGluZyxcbiAgICAgICAgICogYW5kIGRvZXMgbm90IG1ha2UgdGhlIHByb3BhZ2F0aW9uIGFsb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50czogU3ViLWNvbXBvbmVudHNdKGh0dHBzOi8vdmFhZGluLmNvbS9kb2NzL2xhdGVzdC9kcy9jdXN0b21pemF0aW9uL3N0eWxpbmctY29tcG9uZW50cy8jc3ViLWNvbXBvbmVudHMpLlxuICAgICAgICAgKiBwYWdlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcblxuICAgICAgaWYgKG5hbWUgPT09ICd0aGVtZScpIHtcbiAgICAgICAgdGhpcy5fc2V0VGhlbWUobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\n");

/***/ }),

/***/ "./node_modules/js-yaml/dist/js-yaml.mjs":
/*!***********************************************!*\
  !*** ./node_modules/js-yaml/dist/js-yaml.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CORE_SCHEMA\": () => (/* binding */ CORE_SCHEMA),\n/* harmony export */   \"DEFAULT_SCHEMA\": () => (/* binding */ DEFAULT_SCHEMA),\n/* harmony export */   \"FAILSAFE_SCHEMA\": () => (/* binding */ FAILSAFE_SCHEMA),\n/* harmony export */   \"JSON_SCHEMA\": () => (/* binding */ JSON_SCHEMA),\n/* harmony export */   \"Schema\": () => (/* binding */ Schema),\n/* harmony export */   \"Type\": () => (/* binding */ Type),\n/* harmony export */   \"YAMLException\": () => (/* binding */ YAMLException),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"dump\": () => (/* binding */ dump),\n/* harmony export */   \"load\": () => (/* binding */ load),\n/* harmony export */   \"loadAll\": () => (/* binding */ loadAll),\n/* harmony export */   \"safeDump\": () => (/* binding */ safeDump),\n/* harmony export */   \"safeLoad\": () => (/* binding */ safeLoad),\n/* harmony export */   \"safeLoadAll\": () => (/* binding */ safeLoadAll),\n/* harmony export */   \"types\": () => (/* binding */ types)\n/* harmony export */ });\n/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */\nfunction isNothing(subject) {\n  return typeof subject === 'undefined' || subject === null;\n}\n\nfunction isObject(subject) {\n  return typeof subject === 'object' && subject !== null;\n}\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n  return [sequence];\n}\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction repeat(string, count) {\n  var result = '',\n      cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\nfunction isNegativeZero(number) {\n  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n}\n\nvar isNothing_1 = isNothing;\nvar isObject_1 = isObject;\nvar toArray_1 = toArray;\nvar repeat_1 = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1 = extend;\nvar common = {\n  isNothing: isNothing_1,\n  isObject: isObject_1,\n  toArray: toArray_1,\n  repeat: repeat_1,\n  isNegativeZero: isNegativeZero_1,\n  extend: extend_1\n}; // YAML error class. http://stackoverflow.com/questions/8458984\n\nfunction formatError(exception, compact) {\n  var where = '',\n      message = exception.reason || '(unknown reason)';\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\nfunction YAMLException$1(reason, mark) {\n  // Super constructor\n  Error.call(this);\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false); // Include stack trace in error object\n\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = new Error().stack || '';\n  }\n} // Inherit from Error\n\n\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\n\nYAMLException$1.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\nvar exception = YAMLException$1; // get snippet for a single line, respecting maxLength\n\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '') + tail,\n    pos: position - lineStart + head.length // relative position\n\n  };\n}\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n  if (!mark.buffer) return null;\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent !== 'number') options.indent = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter !== 'number') options.linesAfter = 2;\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [0];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while (match = re.exec(mark.buffer)) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n  var result = '',\n      i,\n      line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\nvar snippet = makeSnippet;\nvar TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'multi', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'representName', 'defaultStyle', 'styleAliases'];\nvar YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type$1(tag, options) {\n  options = options || {};\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  }); // TODO: Add tag format check.\n\n  this.options = options; // keep original options in case user wants to extend this type later\n\n  this.tag = tag;\n  this.kind = options['kind'] || null;\n\n  this.resolve = options['resolve'] || function () {\n    return true;\n  };\n\n  this.construct = options['construct'] || function (data) {\n    return data;\n  };\n\n  this.instanceOf = options['instanceOf'] || null;\n  this.predicate = options['predicate'] || null;\n  this.represent = options['represent'] || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.multi = options['multi'] || false;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type$1;\n/*eslint-disable max-len*/\n\nfunction compileList(schema, name) {\n  var result = [];\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {\n        newIndex = previousIndex;\n      }\n    });\n    result[newIndex] = currentType;\n  });\n  return result;\n}\n\nfunction\n  /* lists... */\ncompileMap() {\n  var result = {\n    scalar: {},\n    sequence: {},\n    mapping: {},\n    fallback: {},\n    multi: {\n      scalar: [],\n      sequence: [],\n      mapping: [],\n      fallback: []\n    }\n  },\n      index,\n      length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n\n  return result;\n}\n\nfunction Schema$1(definition) {\n  return this.extend(definition);\n}\n\nSchema$1.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n  } else {\n    throw new exception('Schema.extend argument should be a Type, [ Type ], ' + 'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type$1.multi) {\n      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n  explicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n  var result = Object.create(Schema$1.prototype);\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\n  return result;\n};\n\nvar schema = Schema$1;\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) {\n    return data !== null ? data : '';\n  }\n});\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) {\n    return data !== null ? data : [];\n  }\n});\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) {\n    return data !== null ? data : {};\n  }\n});\nvar failsafe = new schema({\n  explicit: [str, seq, map]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n  var max = data.length;\n  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () {\n      return '~';\n    },\n    lowercase: function () {\n      return 'null';\n    },\n    uppercase: function () {\n      return 'NULL';\n    },\n    camelcase: function () {\n      return 'Null';\n    },\n    empty: function () {\n      return '';\n    }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n  var max = data.length;\n  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' || data === 'True' || data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) {\n      return object ? 'true' : 'false';\n    },\n    uppercase: function (object) {\n      return object ? 'TRUE' : 'FALSE';\n    },\n    camelcase: function (object) {\n      return object ? 'True' : 'False';\n    }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  || 0x41\n  /* A */\n  <= c && c <= 0x46\n  /* F */\n  || 0x61\n  /* a */\n  <= c && c <= 0x66\n  /* f */\n  ;\n}\n\nfunction isOctCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x37\n  /* 7 */\n  ;\n}\n\nfunction isDecCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ;\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n  if (!max) return false;\n  ch = data[index]; // sign\n\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index]; // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n\n      return hasDigits && ch !== '_';\n    }\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n\n      return hasDigits && ch !== '_';\n    }\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n\n      return hasDigits && ch !== '_';\n    }\n  } // base 10 (except 0)\n  // value should not start with `_`;\n\n\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n\n    hasDigits = true;\n  } // Should have digits and should not end with `_`\n\n\n  if (!hasDigits || ch === '_') return false;\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data,\n      sign = 1,\n      ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary: function (obj) {\n      return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n    },\n    octal: function (obj) {\n      return obj >= 0 ? '0o' + obj.toString(8) : '-0o' + obj.toString(8).slice(1);\n    },\n    decimal: function (obj) {\n      return obj.toString(10);\n    },\n\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) {\n      return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n    }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary: [2, 'bin'],\n    octal: [8, 'oct'],\n    decimal: [10, 'dec'],\n    hexadecimal: [16, 'hex']\n  }\n});\nvar YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers\n'^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2\n// special case, seems not from spec\n'|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // .inf\n'|[-+]?\\\\.(?:inf|Inf|INF)' + // .nan\n'|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n  // Probably should update regexp & check speed\n  data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n  value = data.replace(/_/g, '').toLowerCase();\n  sign = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  } else if (value === '.nan') {\n    return NaN;\n  }\n\n  return sign * parseFloat(value, 10);\n}\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase':\n        return '.nan';\n\n      case 'uppercase':\n        return '.NAN';\n\n      case 'camelcase':\n        return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '.inf';\n\n      case 'uppercase':\n        return '.INF';\n\n      case 'camelcase':\n        return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '-.inf';\n\n      case 'uppercase':\n        return '-.INF';\n\n      case 'camelcase':\n        return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\nvar json = failsafe.extend({\n  implicit: [_null, bool, int, float]\n});\nvar core = json;\nvar YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n'-([0-9][0-9])' + // [2] month\n'-([0-9][0-9])$'); // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n'-([0-9][0-9]?)' + // [2] month\n'-([0-9][0-9]?)' + // [3] day\n'(?:[Tt]|[ \\\\t]+)' + // ...\n'([0-9][0-9]?)' + // [4] hour\n':([0-9][0-9])' + // [5] minute\n':([0-9][0-9])' + // [6] second\n'(?:\\\\.([0-9]*))?' + // [7] fraction\n'(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n'(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match,\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      fraction = 0,\n      delta = null,\n      tz_hour,\n      tz_minute,\n      date;\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n  if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day\n\n  year = +match[1];\n  month = +match[2] - 1; // JS month starts with 0\n\n  day = +match[3];\n\n  if (!match[4]) {\n    // no hour\n    return new Date(Date.UTC(year, month, day));\n  } // match: [4] hour [5] minute [6] second [7] fraction\n\n\n  hour = +match[4];\n  minute = +match[5];\n  second = +match[6];\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n\n    while (fraction.length < 3) {\n      // milli-seconds\n      fraction += '0';\n    }\n\n    fraction = +fraction;\n  } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n\n  if (match[9]) {\n    tz_hour = +match[10];\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n  if (delta) date.setTime(date.getTime() - delta);\n  return date;\n}\n\nfunction representYamlTimestamp(object\n/*, style*/\n) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n/*eslint-disable no-bitwise*/\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n  var code,\n      idx,\n      bitlen = 0,\n      max = data.length,\n      map = BASE64_MAP; // Convert one by one.\n\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx)); // Skip CR/LF\n\n    if (code > 64) continue; // Fail on illegal characters\n\n    if (code < 0) return false;\n    bitlen += 6;\n  } // If there are any bits left, source was corrupted\n\n\n  return bitlen % 8 === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx,\n      tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''),\n      // remove CR/LF & padding to simplify scan\n  max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = []; // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  } // Dump tail\n\n\n  tailbits = max % 4 * 6;\n\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object\n/*, style*/\n) {\n  var result = '',\n      bits = 0,\n      idx,\n      tail,\n      max = object.length,\n      map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  } // Dump tail\n\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) === '[object Uint8Array]';\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2 = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n  var objectKeys = [],\n      index,\n      length,\n      pair,\n      pairKey,\n      pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n    if (_toString$2.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty$3.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n  var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n    keys = Object.keys(pair);\n    if (keys.length !== 1) return false;\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n  var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    keys = Object.keys(pair);\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n  var key,\n      object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$2.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar _default = core.extend({\n  implicit: [timestamp, merge],\n  explicit: [binary, omap, pairs, set]\n});\n/*eslint-disable max-len,no-use-before-define*/\n\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar CONTEXT_FLOW_IN = 1;\nvar CONTEXT_FLOW_OUT = 2;\nvar CONTEXT_BLOCK_IN = 3;\nvar CONTEXT_BLOCK_OUT = 4;\nvar CHOMPING_CLIP = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP = 3;\nvar PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\nfunction _class(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction is_EOL(c) {\n  return c === 0x0A\n  /* LF */\n  || c === 0x0D\n  /* CR */\n  ;\n}\n\nfunction is_WHITE_SPACE(c) {\n  return c === 0x09\n  /* Tab */\n  || c === 0x20\n  /* Space */\n  ;\n}\n\nfunction is_WS_OR_EOL(c) {\n  return c === 0x09\n  /* Tab */\n  || c === 0x20\n  /* Space */\n  || c === 0x0A\n  /* LF */\n  || c === 0x0D\n  /* CR */\n  ;\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C\n  /* , */\n  || c === 0x5B\n  /* [ */\n  || c === 0x5D\n  /* ] */\n  || c === 0x7B\n  /* { */\n  || c === 0x7D\n  /* } */\n  ;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if (0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ) {\n    return c - 0x30;\n  }\n  /*eslint-disable no-bitwise*/\n\n\n  lc = c | 0x20;\n\n  if (0x61\n  /* a */\n  <= lc && lc <= 0x66\n  /* f */\n  ) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78\n  /* x */\n  ) {\n    return 2;\n  }\n\n  if (c === 0x75\n  /* u */\n  ) {\n    return 4;\n  }\n\n  if (c === 0x55\n  /* U */\n  ) {\n    return 8;\n  }\n\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if (0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return c === 0x30\n  /* 0 */\n  ? '\\x00' : c === 0x61\n  /* a */\n  ? '\\x07' : c === 0x62\n  /* b */\n  ? '\\x08' : c === 0x74\n  /* t */\n  ? '\\x09' : c === 0x09\n  /* Tab */\n  ? '\\x09' : c === 0x6E\n  /* n */\n  ? '\\x0A' : c === 0x76\n  /* v */\n  ? '\\x0B' : c === 0x66\n  /* f */\n  ? '\\x0C' : c === 0x72\n  /* r */\n  ? '\\x0D' : c === 0x65\n  /* e */\n  ? '\\x1B' : c === 0x20\n  /* Space */\n  ? ' ' : c === 0x22\n  /* \" */\n  ? '\\x22' : c === 0x2F\n  /* / */\n  ? '/' : c === 0x5C\n  /* \\ */\n  ? '\\x5C' : c === 0x4E\n  /* N */\n  ? '\\x85' : c === 0x5F\n  /* _ */\n  ? '\\xA0' : c === 0x4C\n  /* L */\n  ? '\\u2028' : c === 0x50\n  /* P */\n  ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  } // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n\n\n  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\n\nvar simpleEscapeMap = new Array(256);\n\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\nfunction State$1(input, options) {\n  this.input = input;\n  this.filename = options['filename'] || null;\n  this.schema = options['schema'] || _default;\n  this.onWarning = options['onWarning'] || null; // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n\n  this.legacy = options['legacy'] || false;\n  this.json = options['json'] || false;\n  this.listener = options['listener'] || null;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap = this.schema.compiledTypeMap;\n  this.length = input.length;\n  this.position = 0;\n  this.line = 0;\n  this.lineStart = 0;\n  this.lineIndent = 0; // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n\n  this.firstTabInLine = -1;\n  this.documents = [];\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n}\n\nfunction generateError(state, message) {\n  var mark = {\n    name: state.filename,\n    buffer: state.input.slice(0, -1),\n    // omit trailing \\0\n    position: state.position,\n    line: state.line,\n    column: state.position - state.lineStart\n  };\n  mark.snippet = snippet(mark);\n  return new exception(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\nvar directiveHandlers = {\n  YAML: function handleYamlDirective(state, name, args) {\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = minor < 2;\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n  TAG: function handleTagDirective(state, name, args) {\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n\n        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$1.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {\n  var index, quantity; // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  } // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n\n\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    } // used for this specific key only because Object.defineProperty is slow\n\n\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A\n  /* LF */\n  ) {\n    state.position++;\n  } else if (ch === 0x0D\n  /* CR */\n  ) {\n    state.position++;\n\n    if (state.input.charCodeAt(state.position) === 0x0A\n    /* LF */\n    ) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09\n      /* Tab */\n      && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23\n    /* # */\n    ) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A\n      /* LF */\n      && ch !== 0x0D\n      /* CR */\n      && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20\n      /* Space */\n      ) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n  ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n\n  if ((ch === 0x2D\n  /* - */\n  || ch === 0x2E\n  /* . */\n  ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n    _position += 3;\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23\n  /* # */\n  || ch === 0x26\n  /* & */\n  || ch === 0x2A\n  /* * */\n  || ch === 0x21\n  /* ! */\n  || ch === 0x7C\n  /* | */\n  || ch === 0x3E\n  /* > */\n  || ch === 0x27\n  /* ' */\n  || ch === 0x22\n  /* \" */\n  || ch === 0x25\n  /* % */\n  || ch === 0x40\n  /* @ */\n  || ch === 0x60\n  /* ` */\n  ) {\n    return false;\n  }\n\n  if (ch === 0x3F\n  /* ? */\n  || ch === 0x2D\n  /* - */\n  ) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A\n    /* : */\n    ) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n    } else if (ch === 0x23\n    /* # */\n    ) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch, captureStart, captureEnd;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27\n  /* ' */\n  ) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27\n    /* ' */\n    ) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27\n      /* ' */\n      ) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22\n  /* \" */\n  ) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22\n    /* \" */\n    ) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n    } else if (ch === 0x5C\n    /* \\ */\n    ) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n        state.position++;\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag = state.tag,\n      _result,\n      _anchor = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B\n  /* [ */\n  ) {\n    terminator = 0x5D;\n    /* ] */\n\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B\n  /* { */\n  ) {\n    terminator = 0x7D;\n    /* } */\n\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C\n    /* , */\n    ) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F\n    /* ? */\n    ) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A\n    /* : */\n    ) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C\n    /* , */\n    ) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent = nodeIndent,\n      emptyLines = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C\n  /* | */\n  ) {\n    folding = false;\n  } else if (ch === 0x3E\n  /* > */\n  ) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B\n    /* + */\n    || ch === 0x2D\n    /* - */\n    ) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = ch === 0x2B\n        /* + */\n        ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23\n    /* # */\n    ) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (!is_EOL(ch) && ch !== 0);\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20\n    /* Space */\n    ) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    } // End of the scalar.\n\n\n    if (state.lineIndent < textIndent) {\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) {\n          // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      } // Break this `while` cycle and go to the funciton's epilogue.\n\n\n      break;\n    } // Folded style: use fancy rules to handle line breaks.\n\n\n    if (folding) {\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true; // except for the first content line (cf. Example 8.1)\n\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1); // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) {\n          // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        } // Several line breaks - perceive as different lines.\n\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      } // Literal style: just add exact number of line breaks between content lines.\n\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && ch !== 0) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = [],\n      following,\n      detected = false,\n      ch; // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n\n\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D\n    /* - */\n    ) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n\n    _result.push(state.result);\n\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = {},\n      overridableKeys = Object.create(null),\n      keyTag = null,\n      keyNode = null,\n      valueNode = null,\n      atExplicitKey = false,\n      detected = false,\n      ch; // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n\n\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n\n    if ((ch === 0x3F\n    /* ? */\n    || ch === 0x3A\n    /* : */\n    ) && is_WS_OR_EOL(following)) {\n      if (ch === 0x3F\n      /* ? */\n      ) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following; //\n      // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n      //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A\n        /* : */\n        ) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    } //\n    // Common reading code for both explicit and implicit notations.\n    //\n\n\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  } //\n  // Epilogue.\n  //\n  // Special case: last mapping's node contains only the key in explicit notation.\n\n\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  } // Expose the resulting mapping.\n\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x21\n  /* ! */\n  ) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C\n  /* < */\n  ) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n  } else if (ch === 0x21\n  /* ! */\n  ) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (ch !== 0 && ch !== 0x3E\n    /* > */\n    );\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      if (ch === 0x21\n      /* ! */\n      ) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position, ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x26\n  /* & */\n  ) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias, ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x2A\n  /* * */\n  ) return false;\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1,\n      // 1: this>parent, 0: this=parent, -1: this<parent\n  atNewLine = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag = null;\n  state.anchor = null;\n  state.kind = null;\n  state.result = null;\n  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) {\n        // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) {\n      // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n\n  return state.tag !== null || state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25\n    /* % */\n    ) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23\n      /* # */\n      ) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0 && !is_EOL(ch));\n\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D\n  /* - */\n  && state.input.charCodeAt(state.position + 1) === 0x2D\n  /* - */\n  && state.input.charCodeAt(state.position + 2) === 0x2D\n  /* - */\n  ) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n    if (state.input.charCodeAt(state.position) === 0x2E\n    /* . */\n    ) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n\n    return;\n  }\n\n  if (state.position < state.length - 1) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A\n    /* LF */\n    && input.charCodeAt(input.length - 1) !== 0x0D\n    /* CR */\n    ) {\n      input += '\\n';\n    } // Strip BOM\n\n\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State$1(input, options);\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  } // Use 0 as string terminator. That significantly simplifies bounds check.\n\n\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20\n  /* Space */\n  ) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < state.length - 1) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\nfunction loadAll$1(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\nfunction load$1(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n\n  throw new exception('expected a single document in the stream, but found more');\n}\n\nvar loadAll_1 = loadAll$1;\nvar load_1 = load$1;\nvar loader = {\n  loadAll: loadAll_1,\n  load: load_1\n};\n/*eslint-disable no-use-before-define*/\n\nvar _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_BOM = 0xFEFF;\nvar CHAR_TAB = 0x09;\n/* Tab */\n\nvar CHAR_LINE_FEED = 0x0A;\n/* LF */\n\nvar CHAR_CARRIAGE_RETURN = 0x0D;\n/* CR */\n\nvar CHAR_SPACE = 0x20;\n/* Space */\n\nvar CHAR_EXCLAMATION = 0x21;\n/* ! */\n\nvar CHAR_DOUBLE_QUOTE = 0x22;\n/* \" */\n\nvar CHAR_SHARP = 0x23;\n/* # */\n\nvar CHAR_PERCENT = 0x25;\n/* % */\n\nvar CHAR_AMPERSAND = 0x26;\n/* & */\n\nvar CHAR_SINGLE_QUOTE = 0x27;\n/* ' */\n\nvar CHAR_ASTERISK = 0x2A;\n/* * */\n\nvar CHAR_COMMA = 0x2C;\n/* , */\n\nvar CHAR_MINUS = 0x2D;\n/* - */\n\nvar CHAR_COLON = 0x3A;\n/* : */\n\nvar CHAR_EQUALS = 0x3D;\n/* = */\n\nvar CHAR_GREATER_THAN = 0x3E;\n/* > */\n\nvar CHAR_QUESTION = 0x3F;\n/* ? */\n\nvar CHAR_COMMERCIAL_AT = 0x40;\n/* @ */\n\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n/* [ */\n\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n/* ] */\n\nvar CHAR_GRAVE_ACCENT = 0x60;\n/* ` */\n\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B;\n/* { */\n\nvar CHAR_VERTICAL_LINE = 0x7C;\n/* | */\n\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n/* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (map === null) return {};\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema = options['schema'] || _default;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.lineWidth = options['lineWidth'] || 80;\n  this.noRefs = options['noRefs'] || false;\n  this.noCompatMode = options['noCompatMode'] || false;\n  this.condenseFlow = options['condenseFlow'] || false;\n  this.quotingType = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes = options['forceQuotes'] || false;\n  this.replacer = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n} // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n} // [33] s-white ::= s-space | s-tab\n\n\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n} // Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnt mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\nfunction isPrintable(c) {\n  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;\n} // [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\n\n\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c) && c !== CHAR_BOM // - b-char\n  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n} // [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out\n//                             c = flow-in    ns-plain-safe-in\n//                             c = block-key  ns-plain-safe-out\n//                             c = flow-key   ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )\n//                            | ( /* An ns-char preceding */ # )\n//                            | ( : /* Followed by an ns-plain-safe(c) */ )\n\n\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return ( // ns-plain-safe\n  inblock ? // c = flow-in\n  cIsNsCharOrWhitespace : cIsNsCharOrWhitespace // - c-flow-indicator\n  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // ns-plain-char\n  ) && c !== CHAR_SHARP // false on '#'\n  && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n  || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'\n  || prev === CHAR_COLON && cIsNsChar; // change to true on ':[^ ]'\n} // Simplified test for values allowed as the first character in plain style.\n\n\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white\n  // - (c-indicator ::=\n  // - | ? | : | , | [ | ] | { | }\n  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | # | & | * | ! | | | = | > | ' | \"\n  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | % | @ | `)\n  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n} // Simplified test for values allowed as the last character in plain style.\n\n\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n} // Same as 'string'.codePointAt(pos), but works in older browsers.\n\n\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos),\n      second;\n\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n\n  return first;\n} // Determines whether block indentation indicator is required.\n\n\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN = 1,\n    STYLE_SINGLE = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED = 4,\n    STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n\n  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true; // Check if any line can be folded.\n\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    } // in case the end is missing a \\n\n\n\n    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n  } // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n\n\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  } // Edge case: block indentation indicator can only have one digit.\n\n\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  } // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n\n\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n} // Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//     No ending newline => unaffected; already using strip \"-\" chomping.\n//     Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"' + string + '\"' : \"'\" + string + \"'\";\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n\n    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n    var singleLineOnly = iskey // No block styles in flow mode.\n    || state.flowLevel > -1 && level >= state.flowLevel;\n\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n      case STYLE_PLAIN:\n        return string;\n\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }();\n} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n  var clip = string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : clip ? '' : '-';\n  return indentIndicator + chomp + '\\n';\n} // (See the note for writeScalar.)\n\n\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n} // Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n  var result = function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented; // rest of the lines\n\n  var match;\n\n  while (match = lineRe.exec(string)) {\n    var prefix = match[1],\n        line = match[2];\n    moreIndented = line[0] === ' ';\n    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n} // Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n  var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n  var start = 0,\n      end,\n      curr = 0,\n      next = 0;\n  var result = ''; // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n\n  while (match = breakRe.exec(line)) {\n    next = match.index; // maintain invariant: curr - start <= width\n\n    if (next - start > width) {\n      end = curr > start ? curr : next; // derive end <= length-2\n\n      result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n      start = end + 1; // derive start <= length-1\n    }\n\n    curr = next;\n  } // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n\n\n  result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n} // Escapes a double-quoted string.\n\n\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    } // Write only valid elements, put null instead of invalid elements.\n\n\n    if (writeNode(state, level, value, false, false) || typeof value === 'undefined' && writeNode(state, level, null, false, false)) {\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    } // Write only valid elements, put null instead of invalid elements.\n\n\n    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === 'undefined' && writeNode(state, level + 1, null, true, true, false, true)) {\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n    if (state.condenseFlow) pairBuffer += '\"';\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\n\n\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = state.flowLevel < 0 || state.flowLevel > level;\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n\n    if (type === '[object Object]') {\n      if (block && Object.keys(state.dump).length !== 0) {\n        writeBlockMapping(state, level, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && state.dump.length !== 0) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -\n      // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #\n      //                         | ; | / | ? | : | @ | & | = | + | $ | ,\n      //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(state.tag[0] === '!' ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList, index, length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump$1(input, options) {\n  options = options || {};\n  var state = new State(options);\n  if (!state.noRefs) getDuplicateReferences(input, state);\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({\n      '': value\n    }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n  return '';\n}\n\nvar dump_1 = dump$1;\nvar dumper = {\n  dump: dump_1\n};\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' + 'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\nvar Type = type;\nvar Schema = schema;\nvar FAILSAFE_SCHEMA = failsafe;\nvar JSON_SCHEMA = json;\nvar CORE_SCHEMA = core;\nvar DEFAULT_SCHEMA = _default;\nvar load = loader.load;\nvar loadAll = loader.loadAll;\nvar dump = dumper.dump;\nvar YAMLException = exception; // Re-export all types in case user wants to create custom schema\n\nvar types = {\n  binary: binary,\n  float: float,\n  map: map,\n  null: _null,\n  pairs: pairs,\n  set: set,\n  timestamp: timestamp,\n  bool: bool,\n  int: int,\n  merge: merge,\n  omap: omap,\n  seq: seq,\n  str: str\n}; // Removed functions from JS-YAML 3.0.x\n\nvar safeLoad = renamed('safeLoad', 'load');\nvar safeLoadAll = renamed('safeLoadAll', 'loadAll');\nvar safeDump = renamed('safeDump', 'dump');\nvar jsYaml = {\n  Type: Type,\n  Schema: Schema,\n  FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n  JSON_SCHEMA: JSON_SCHEMA,\n  CORE_SCHEMA: CORE_SCHEMA,\n  DEFAULT_SCHEMA: DEFAULT_SCHEMA,\n  load: load,\n  loadAll: loadAll,\n  dump: dump,\n  YAMLException: YAMLException,\n  types: types,\n  safeLoad: safeLoad,\n  safeLoadAll: safeLoadAll,\n  safeDump: safeDump\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jsYaml);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanMteWFtbC9kaXN0L2pzLXlhbWwubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBR0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTs7QUFZQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUZBO0FBSUE7O0FBR0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7O0FBRUE7QUFDQTs7QUFHQTtBQUVBO0FBYUE7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFMQTtBQUFBO0FBQUE7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBS0E7QUFDQTtBQURBOztBQVFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFMQTtBQU9BO0FBWkE7O0FBZUE7QUFDQTtBQUVBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFWQTs7QUFhQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUZBO0FBR0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFiQTtBQXFCQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBO0FBREE7QUFTQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBRUE7O0FBSUE7QUFDQTs7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBTUE7O0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTs7QUFHQTs7QUFHQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBRkE7QUFBQTtBQUFBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUlBO0FBTEE7QUFhQTs7O0FBUUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBRkE7QUFHQTtBQUhBO0FBSUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFGQTtBQUdBO0FBSEE7QUFJQTtBQUpBO0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFJQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFqRUE7O0FBcUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFHQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFZQTs7QUFFQTtBQUVBO0FBRkE7QUFHQTtBQUhBO0FBSUE7QUFKQTtBQUtBO0FBTEE7QUFNQTtBQU5BO0FBT0E7QUFQQTtBQVFBO0FBUkE7QUFTQTtBQVRBO0FBVUE7QUFWQTtBQVdBO0FBWEE7QUFZQTtBQVpBO0FBYUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWtCQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7OztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBa0JBOzs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BO0FBRUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFEQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFhQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBR0E7QUFIQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7O0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBaUJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQTBCQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUdBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUlBO0FBQUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTs7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFHQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUdBOztBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBOztBQWlCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWlCQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvanMteWFtbC9kaXN0L2pzLXlhbWwubWpzP2UyYzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiEganMteWFtbCA0LjEuMCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL2pzLXlhbWwgQGxpY2Vuc2UgTUlUICovXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKHN1YmplY3QgPT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChzdWJqZWN0ICE9PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO1xuICBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIFsgc2VxdWVuY2UgXTtcbn1cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIGtleSwgc291cmNlS2V5cztcblxuICBpZiAoc291cmNlKSB7XG4gICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsIGN5Y2xlO1xuXG4gIGZvciAoY3ljbGUgPSAwOyBjeWNsZSA8IGNvdW50OyBjeWNsZSArPSAxKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyID09PSAwKSAmJiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSAxIC8gbnVtYmVyKTtcbn1cblxuXG52YXIgaXNOb3RoaW5nXzEgICAgICA9IGlzTm90aGluZztcbnZhciBpc09iamVjdF8xICAgICAgID0gaXNPYmplY3Q7XG52YXIgdG9BcnJheV8xICAgICAgICA9IHRvQXJyYXk7XG52YXIgcmVwZWF0XzEgICAgICAgICA9IHJlcGVhdDtcbnZhciBpc05lZ2F0aXZlWmVyb18xID0gaXNOZWdhdGl2ZVplcm87XG52YXIgZXh0ZW5kXzEgICAgICAgICA9IGV4dGVuZDtcblxudmFyIGNvbW1vbiA9IHtcblx0aXNOb3RoaW5nOiBpc05vdGhpbmdfMSxcblx0aXNPYmplY3Q6IGlzT2JqZWN0XzEsXG5cdHRvQXJyYXk6IHRvQXJyYXlfMSxcblx0cmVwZWF0OiByZXBlYXRfMSxcblx0aXNOZWdhdGl2ZVplcm86IGlzTmVnYXRpdmVaZXJvXzEsXG5cdGV4dGVuZDogZXh0ZW5kXzFcbn07XG5cbi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGV4Y2VwdGlvbiwgY29tcGFjdCkge1xuICB2YXIgd2hlcmUgPSAnJywgbWVzc2FnZSA9IGV4Y2VwdGlvbi5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknO1xuXG4gIGlmICghZXhjZXB0aW9uLm1hcmspIHJldHVybiBtZXNzYWdlO1xuXG4gIGlmIChleGNlcHRpb24ubWFyay5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIGV4Y2VwdGlvbi5tYXJrLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICcoJyArIChleGNlcHRpb24ubWFyay5saW5lICsgMSkgKyAnOicgKyAoZXhjZXB0aW9uLm1hcmsuY29sdW1uICsgMSkgKyAnKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQpIHtcbiAgICB3aGVyZSArPSAnXFxuXFxuJyArIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQ7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZSArICcgJyArIHdoZXJlO1xufVxuXG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24kMShyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSBmb3JtYXRFcnJvcih0aGlzLCBmYWxzZSk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24kMS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBZQU1MRXhjZXB0aW9uJDE7XG5cblxuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyBmb3JtYXRFcnJvcih0aGlzLCBjb21wYWN0KTtcbn07XG5cblxudmFyIGV4Y2VwdGlvbiA9IFlBTUxFeGNlcHRpb24kMTtcblxuLy8gZ2V0IHNuaXBwZXQgZm9yIGEgc2luZ2xlIGxpbmUsIHJlc3BlY3RpbmcgbWF4TGVuZ3RoXG5mdW5jdGlvbiBnZXRMaW5lKGJ1ZmZlciwgbGluZVN0YXJ0LCBsaW5lRW5kLCBwb3NpdGlvbiwgbWF4TGluZUxlbmd0aCkge1xuICB2YXIgaGVhZCA9ICcnO1xuICB2YXIgdGFpbCA9ICcnO1xuICB2YXIgbWF4SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IobWF4TGluZUxlbmd0aCAvIDIpIC0gMTtcblxuICBpZiAocG9zaXRpb24gLSBsaW5lU3RhcnQgPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgaGVhZCA9ICcgLi4uICc7XG4gICAgbGluZVN0YXJ0ID0gcG9zaXRpb24gLSBtYXhIYWxmTGVuZ3RoICsgaGVhZC5sZW5ndGg7XG4gIH1cblxuICBpZiAobGluZUVuZCAtIHBvc2l0aW9uID4gbWF4SGFsZkxlbmd0aCkge1xuICAgIHRhaWwgPSAnIC4uLic7XG4gICAgbGluZUVuZCA9IHBvc2l0aW9uICsgbWF4SGFsZkxlbmd0aCAtIHRhaWwubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdHI6IGhlYWQgKyBidWZmZXIuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kKS5yZXBsYWNlKC9cXHQvZywgJ+KGkicpICsgdGFpbCxcbiAgICBwb3M6IHBvc2l0aW9uIC0gbGluZVN0YXJ0ICsgaGVhZC5sZW5ndGggLy8gcmVsYXRpdmUgcG9zaXRpb25cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIG1heCkge1xuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIG1heCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIG1ha2VTbmlwcGV0KG1hcmssIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBudWxsKTtcblxuICBpZiAoIW1hcmsuYnVmZmVyKSByZXR1cm4gbnVsbDtcblxuICBpZiAoIW9wdGlvbnMubWF4TGVuZ3RoKSBvcHRpb25zLm1heExlbmd0aCA9IDc5O1xuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ICAgICAgIT09ICdudW1iZXInKSBvcHRpb25zLmluZGVudCAgICAgID0gMTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQmVmb3JlICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0JlZm9yZSA9IDM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lc0FmdGVyICAhPT0gJ251bWJlcicpIG9wdGlvbnMubGluZXNBZnRlciAgPSAyO1xuXG4gIHZhciByZSA9IC9cXHI/XFxufFxccnxcXDAvZztcbiAgdmFyIGxpbmVTdGFydHMgPSBbIDAgXTtcbiAgdmFyIGxpbmVFbmRzID0gW107XG4gIHZhciBtYXRjaDtcbiAgdmFyIGZvdW5kTGluZU5vID0gLTE7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMobWFyay5idWZmZXIpKSkge1xuICAgIGxpbmVFbmRzLnB1c2gobWF0Y2guaW5kZXgpO1xuICAgIGxpbmVTdGFydHMucHVzaChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICBpZiAobWFyay5wb3NpdGlvbiA8PSBtYXRjaC5pbmRleCAmJiBmb3VuZExpbmVObyA8IDApIHtcbiAgICAgIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAyO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZExpbmVObyA8IDApIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAxO1xuXG4gIHZhciByZXN1bHQgPSAnJywgaSwgbGluZTtcbiAgdmFyIGxpbmVOb0xlbmd0aCA9IE1hdGgubWluKG1hcmsubGluZSArIG9wdGlvbnMubGluZXNBZnRlciwgbGluZUVuZHMubGVuZ3RoKS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIG1heExpbmVMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCAtIChvcHRpb25zLmluZGVudCArIGxpbmVOb0xlbmd0aCArIDMpO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0JlZm9yZTsgaSsrKSB7XG4gICAgaWYgKGZvdW5kTGluZU5vIC0gaSA8IDApIGJyZWFrO1xuICAgIGxpbmUgPSBnZXRMaW5lKFxuICAgICAgbWFyay5idWZmZXIsXG4gICAgICBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBsaW5lRW5kc1tmb3VuZExpbmVObyAtIGldLFxuICAgICAgbWFyay5wb3NpdGlvbiAtIChsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSAtIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSksXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICByZXN1bHQgPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSAtIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJyArIHJlc3VsdDtcbiAgfVxuXG4gIGxpbmUgPSBnZXRMaW5lKG1hcmsuYnVmZmVyLCBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSwgbGluZUVuZHNbZm91bmRMaW5lTm9dLCBtYXJrLnBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKTtcbiAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnLScsIG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyArIGxpbmUucG9zKSArICdeJyArICdcXG4nO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0FmdGVyOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gKyBpID49IGxpbmVFbmRzLmxlbmd0aCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vICsgaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSArIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFxuJC8sICcnKTtcbn1cblxuXG52YXIgc25pcHBldCA9IG1ha2VTbmlwcGV0O1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdtdWx0aScsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAncmVwcmVzZW50TmFtZScsXG4gICdkZWZhdWx0U3R5bGUnLFxuICAnc3R5bGVBbGlhc2VzJ1xuXTtcblxudmFyIFlBTUxfTk9ERV9LSU5EUyA9IFtcbiAgJ3NjYWxhcicsXG4gICdzZXF1ZW5jZScsXG4gICdtYXBwaW5nJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlQWxpYXNlcyhtYXApIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBtYXBbc3R5bGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBUeXBlJDEodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy5vcHRpb25zICAgICAgID0gb3B0aW9uczsgLy8ga2VlcCBvcmlnaW5hbCBvcHRpb25zIGluIGNhc2UgdXNlciB3YW50cyB0byBleHRlbmQgdGhpcyB0eXBlIGxhdGVyXG4gIHRoaXMudGFnICAgICAgICAgICA9IHRhZztcbiAgdGhpcy5raW5kICAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgICA9IG9wdGlvbnNbJ3Jlc29sdmUnXSAgICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICAgfHwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH07XG4gIHRoaXMuaW5zdGFuY2VPZiAgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICAgPSBvcHRpb25zWydwcmVkaWNhdGUnXSAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50TmFtZSA9IG9wdGlvbnNbJ3JlcHJlc2VudE5hbWUnXSB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSAgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSAgfHwgbnVsbDtcbiAgdGhpcy5tdWx0aSAgICAgICAgID0gb3B0aW9uc1snbXVsdGknXSAgICAgICAgIHx8IGZhbHNlO1xuICB0aGlzLnN0eWxlQWxpYXNlcyAgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmIChZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbnZhciB0eXBlID0gVHlwZSQxO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiZcbiAgICAgICAgICBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5tdWx0aSA9PT0gY3VycmVudFR5cGUubXVsdGkpIHtcblxuICAgICAgICBuZXdJbmRleCA9IHByZXZpb3VzSW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHRbbmV3SW5kZXhdID0gY3VycmVudFR5cGU7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge30sXG4gICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgc2NhbGFyOiBbXSxcbiAgICAgICAgICBzZXF1ZW5jZTogW10sXG4gICAgICAgICAgbWFwcGluZzogW10sXG4gICAgICAgICAgZmFsbGJhY2s6IFtdXG4gICAgICAgIH1cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlLm11bHRpKSB7XG4gICAgICByZXN1bHQubXVsdGlbdHlwZS5raW5kXS5wdXNoKHR5cGUpO1xuICAgICAgcmVzdWx0Lm11bHRpWydmYWxsYmFjayddLnB1c2godHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEkMShkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZChkZWZpbml0aW9uKTtcbn1cblxuXG5TY2hlbWEkMS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGRlZmluaXRpb24pIHtcbiAgdmFyIGltcGxpY2l0ID0gW107XG4gIHZhciBleHBsaWNpdCA9IFtdO1xuXG4gIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgdHlwZSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQodHlwZSlcbiAgICBleHBsaWNpdC5wdXNoKGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoWyB0eXBlMSwgdHlwZTIsIC4uLiBdKVxuICAgIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoZGVmaW5pdGlvbiAmJiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uLmltcGxpY2l0KSB8fCBBcnJheS5pc0FycmF5KGRlZmluaXRpb24uZXhwbGljaXQpKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoeyBleHBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdLCBpbXBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdIH0pXG4gICAgaWYgKGRlZmluaXRpb24uaW1wbGljaXQpIGltcGxpY2l0ID0gaW1wbGljaXQuY29uY2F0KGRlZmluaXRpb24uaW1wbGljaXQpO1xuICAgIGlmIChkZWZpbml0aW9uLmV4cGxpY2l0KSBleHBsaWNpdCA9IGV4cGxpY2l0LmNvbmNhdChkZWZpbml0aW9uLmV4cGxpY2l0KTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NjaGVtYS5leHRlbmQgYXJndW1lbnQgc2hvdWxkIGJlIGEgVHlwZSwgWyBUeXBlIF0sICcgK1xuICAgICAgJ29yIGEgc2NoZW1hIGRlZmluaXRpb24gKHsgaW1wbGljaXQ6IFsuLi5dLCBleHBsaWNpdDogWy4uLl0gfSknKTtcbiAgfVxuXG4gIGltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUkMSkge1xuICAgIGlmICghKHR5cGUkMSBpbnN0YW5jZW9mIHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUkMS5sb2FkS2luZCAmJiB0eXBlJDEubG9hZEtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSQxLm11bHRpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdUaGVyZSBpcyBhIG11bHRpIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIE11bHRpIHRhZ3MgY2FuIG9ubHkgYmUgbGlzdGVkIGFzIGV4cGxpY2l0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXhwbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSQxKSB7XG4gICAgaWYgKCEodHlwZSQxIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKFNjaGVtYSQxLnByb3RvdHlwZSk7XG5cbiAgcmVzdWx0LmltcGxpY2l0ID0gKHRoaXMuaW1wbGljaXQgfHwgW10pLmNvbmNhdChpbXBsaWNpdCk7XG4gIHJlc3VsdC5leHBsaWNpdCA9ICh0aGlzLmV4cGxpY2l0IHx8IFtdKS5jb25jYXQoZXhwbGljaXQpO1xuXG4gIHJlc3VsdC5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QocmVzdWx0LCAnaW1wbGljaXQnKTtcbiAgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdleHBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAocmVzdWx0LmNvbXBpbGVkSW1wbGljaXQsIHJlc3VsdC5jb21waWxlZEV4cGxpY2l0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG52YXIgc2NoZW1hID0gU2NoZW1hJDE7XG5cbnZhciBzdHIgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiAnJzsgfVxufSk7XG5cbnZhciBzZXEgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdOyB9XG59KTtcblxudmFyIG1hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG5cbnZhciBmYWlsc2FmZSA9IG5ldyBzY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHN0cixcbiAgICBzZXEsXG4gICAgbWFwXG4gIF1cbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG52YXIgX251bGwgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9LFxuICAgIGVtcHR5OiAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7ICAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRScpKSB8fFxuICAgICAgICAgKG1heCA9PT0gNSAmJiAoZGF0YSA9PT0gJ2ZhbHNlJyB8fCBkYXRhID09PSAnRmFsc2UnIHx8IGRhdGEgPT09ICdGQUxTRScpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUUlVFJztcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cblxudmFyIGJvb2wgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQm9vbGVhbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQm9vbGVhbixcbiAgcHJlZGljYXRlOiBpc0Jvb2xlYW4sXG4gIHJlcHJlc2VudDoge1xuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ28nKSB7XG4gICAgICAvLyBiYXNlIDhcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApXG5cbiAgLy8gdmFsdWUgc2hvdWxkIG5vdCBzdGFydCB3aXRoIGBfYDtcbiAgaWYgKGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSBzaWduID0gLTE7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICBjaCA9IHZhbHVlWzBdO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnMCcpIHJldHVybiAwO1xuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnYicpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnbycpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDgpO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxudmFyIGludCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEludGVnZXIsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEludGVnZXIsXG4gIHByZWRpY2F0ZTogaXNJbnRlZ2VyLFxuICByZXByZXNlbnQ6IHtcbiAgICBiaW5hcnk6ICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMGInICsgb2JqLnRvU3RyaW5nKDIpIDogJy0wYicgKyBvYmoudG9TdHJpbmcoMikuc2xpY2UoMSk7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBvJyAgKyBvYmoudG9TdHJpbmcoOCkgOiAnLTBvJyAgKyBvYmoudG9TdHJpbmcoOCkuc2xpY2UoMSk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iai50b1N0cmluZygxMCk7IH0sXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcweCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgOiAgJy0weCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkuc2xpY2UoMSk7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnZGVjaW1hbCcsXG4gIHN0eWxlQWxpYXNlczoge1xuICAgIGJpbmFyeTogICAgICBbIDIsICAnYmluJyBdLFxuICAgIG9jdGFsOiAgICAgICBbIDgsICAnb2N0JyBdLFxuICAgIGRlY2ltYWw6ICAgICBbIDEwLCAnZGVjJyBdLFxuICAgIGhleGFkZWNpbWFsOiBbIDE2LCAnaGV4JyBdXG4gIH1cbn0pO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OlswLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC4yZTQsIC4yXG4gIC8vIHNwZWNpYWwgY2FzZSwgc2VlbXMgbm90IGZyb20gc3BlY1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcubmFuJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLk5BTic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy0uaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLS5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7XG5cbiAgLy8gSlMgc3RyaW5naWZpZXIgY2FuIGJ1aWxkIHNjaWVudGlmaWMgZm9ybWF0IHdpdGhvdXQgZG90czogNWUtMTAwLFxuICAvLyB3aGlsZSBZQU1MIHJlcXVyZXMgZG90OiA1LmUtMTAwLiBGaXggaXQgd2l0aCBzaW1wbGUgaGFja1xuXG4gIHJldHVybiBTQ0lFTlRJRklDX1dJVEhPVVRfRE9ULnRlc3QocmVzKSA/IHJlcy5yZXBsYWNlKCdlJywgJy5lJykgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgIT09IDAgfHwgY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG52YXIgZmxvYXQgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbnZhciBqc29uID0gZmFpbHNhZmUuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICBfbnVsbCxcbiAgICBib29sLFxuICAgIGludCxcbiAgICBmbG9hdFxuICBdXG59KTtcblxudmFyIGNvcmUgPSBqc29uO1xuXG52YXIgWUFNTF9EQVRFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0pJCcpOyAgICAgICAgICAgICAgICAgICAvLyBbM10gZGF5XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8kJyk7ICAgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICBpZiAoWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsIHR6X2hvdXIsIHR6X21pbnV0ZSwgZGF0ZTtcblxuICBtYXRjaCA9IFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcblxuICAvLyBtYXRjaDogWzFdIHllYXIgWzJdIG1vbnRoIFszXSBkYXlcblxuICB5ZWFyID0gKyhtYXRjaFsxXSk7XG4gIG1vbnRoID0gKyhtYXRjaFsyXSkgLSAxOyAvLyBKUyBtb250aCBzdGFydHMgd2l0aCAwXG4gIGRheSA9ICsobWF0Y2hbM10pO1xuXG4gIGlmICghbWF0Y2hbNF0pIHsgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH1cblxuICAvLyBtYXRjaDogWzRdIGhvdXIgWzVdIG1pbnV0ZSBbNl0gc2Vjb25kIFs3XSBmcmFjdGlvblxuXG4gIGhvdXIgPSArKG1hdGNoWzRdKTtcbiAgbWludXRlID0gKyhtYXRjaFs1XSk7XG4gIHNlY29uZCA9ICsobWF0Y2hbNl0pO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDMpIHsgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9ICtmcmFjdGlvbjtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cbiAgaWYgKG1hdGNoWzldKSB7XG4gICAgdHpfaG91ciA9ICsobWF0Y2hbMTBdKTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuICAgIGlmIChtYXRjaFs5XSA9PT0gJy0nKSBkZWx0YSA9IC1kZWx0YTtcbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG52YXIgdGltZXN0YW1wID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJzw8JyB8fCBkYXRhID09PSBudWxsO1xufVxuXG52YXIgbWVyZ2UgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG5cblxuXG4vLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG52YXIgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVxcblxccic7XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgY29kZSA9IG1hcC5pbmRleE9mKGRhdGEuY2hhckF0KGlkeCkpO1xuXG4gICAgLy8gU2tpcCBDUi9MRlxuICAgIGlmIChjb2RlID4gNjQpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTApICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMikgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA0KSAmIDB4RkYpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAgJ1tvYmplY3QgVWludDhBcnJheV0nO1xufVxuXG52YXIgYmluYXJ5ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkkMyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nJDIgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKF90b1N0cmluZyQyLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQzLmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbnZhciBvbWFwID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG5cbnZhciBfdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZyQxLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwYWlycyA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuXG52YXIgX2hhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMi5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxudmFyIHNldCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG5cbnZhciBfZGVmYXVsdCA9IGNvcmUuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICB0aW1lc3RhbXAsXG4gICAgbWVyZ2VcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICBiaW5hcnksXG4gICAgb21hcCxcbiAgICBwYWlycyxcbiAgICBzZXRcbiAgXVxufSk7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbixuby11c2UtYmVmb3JlLWRlZmluZSovXG5cblxuXG5cblxuXG5cbnZhciBfaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiBjID09PSAweDJDLyogLCAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1Qi8qIFsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUQvKiBdICovIHx8XG4gICAgICAgICBjID09PSAweDdCLyogeyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3RC8qIH0gKi87XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDBcbiAgKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBfZGVmYXVsdDtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICAvLyAoSGlkZGVuKSBSZW1vdmU/IG1ha2VzIHRoZSBsb2FkZXIgdG8gZXhwZWN0IFlBTUwgMS4xIGRvY3VtZW50c1xuICAvLyBpZiBzdWNoIGRvY3VtZW50cyBoYXZlIG5vIGV4cGxpY2l0ICVZQU1MIGRpcmVjdGl2ZVxuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuXG4gIHRoaXMuanNvbiAgICAgID0gb3B0aW9uc1snanNvbiddICAgICAgfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgID0gb3B0aW9uc1snbGlzdGVuZXInXSAgfHwgbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIC8vIHBvc2l0aW9uIG9mIGZpcnN0IGxlYWRpbmcgdGFiIGluIHRoZSBjdXJyZW50IGxpbmUsXG4gIC8vIHVzZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGFyZSBubyB0YWJzIGluIHRoZSBpbmRlbnRhdGlvblxuICB0aGlzLmZpcnN0VGFiSW5MaW5lID0gLTE7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB2YXIgbWFyayA9IHtcbiAgICBuYW1lOiAgICAgc3RhdGUuZmlsZW5hbWUsXG4gICAgYnVmZmVyOiAgIHN0YXRlLmlucHV0LnNsaWNlKDAsIC0xKSwgLy8gb21pdCB0cmFpbGluZyBcXDBcbiAgICBwb3NpdGlvbjogc3RhdGUucG9zaXRpb24sXG4gICAgbGluZTogICAgIHN0YXRlLmxpbmUsXG4gICAgY29sdW1uOiAgIHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0XG4gIH07XG5cbiAgbWFyay5zbmlwcGV0ID0gc25pcHBldChtYXJrKTtcblxuICByZXR1cm4gbmV3IGV4Y2VwdGlvbihtZXNzYWdlLCBtYXJrKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcmVmaXggPSBkZWNvZGVVUklDb21wb25lbnQocHJlZml4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgcHJlZml4IGlzIG1hbGZvcm1lZDogJyArIHByZWZpeCk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5JDEuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLFxuICBzdGFydExpbmUsIHN0YXJ0TGluZVN0YXJ0LCBzdGFydFBvcykge1xuXG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG4gIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGtleU5vZGUgPSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkkMS5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiZcbiAgICAgICAgX2hhc093blByb3BlcnR5JDEuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUubGluZVN0YXJ0ID0gc3RhcnRMaW5lU3RhcnQgfHwgc3RhdGUubGluZVN0YXJ0O1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgLy8gdXNlZCBmb3IgdGhpcyBzcGVjaWZpYyBrZXkgb25seSBiZWNhdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBzbG93XG4gICAgaWYgKGtleU5vZGUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3Jlc3VsdCwga2V5Tm9kZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWVOb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdFtrZXlOb2RlXSA9IHZhbHVlTm9kZTtcbiAgICB9XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkvKiBUYWIgKi8gJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLmZpcnN0VGFiSW5MaW5lID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX3BvcyxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGtleU5vZGUsXG4gICAgICBrZXlUYWcsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg1RDsvKiBdICovXG4gICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgX3Jlc3VsdCA9IFtdO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDdCLyogeyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDdEOy8qIH0gKi9cbiAgICBpc01hcHBpbmcgPSB0cnVlO1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gdGVybWluYXRvcikge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgc3RhdGUua2luZCA9IGlzTWFwcGluZyA/ICdtYXBwaW5nJyA6ICdzZXF1ZW5jZSc7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghcmVhZE5leHQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllcycpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICAvLyBcImZsb3cgY29sbGVjdGlvbiBlbnRyaWVzIGNhbiBuZXZlciBiZSBjb21wbGV0ZWx5IGVtcHR5XCIsIGFzIHBlciBZQU1MIDEuMiwgc2VjdGlvbiA3LjRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsIFwiZXhwZWN0ZWQgdGhlIG5vZGUgY29udGVudCwgYnV0IGZvdW5kICcsJ1wiKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChpc0V4cGxpY2l0UGFpciB8fCBzdGF0ZS5saW5lID09PSBfbGluZSkgJiYgY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFwcGluZykge1xuICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIC8vIHRoZXJlIGlzIGEgbGVhZGluZyB0YWIgYmVmb3JlIHRoaXMgdG9rZW4sIHNvIGl0IGNhbid0IGJlIGEgYmxvY2sgc2VxdWVuY2UvbWFwcGluZztcbiAgLy8gaXQgY2FuIHN0aWxsIGJlIGZsb3cgc2VxdWVuY2UvbWFwcGluZyBvciBhIHNjYWxhclxuICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGF0ZS5maXJzdFRhYkluTGluZTtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWIgY2hhcmFjdGVycyBtdXN0IG5vdCBiZSB1c2VkIGluIGluZGVudGF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfa2V5TGluZSxcbiAgICAgIF9rZXlMaW5lU3RhcnQsXG4gICAgICBfa2V5UG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoIWF0RXhwbGljaXRLZXkgJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQ7IG9yIGZvbGxvd2VkIGJ5IGEgbm9uLXRhYnVsYXRlZCBlbXB0eSBsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2Uge1xuICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2tleUxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYgKCFjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIC8vIE5laXRoZXIgaW1wbGljaXQgbm9yIGV4cGxpY2l0IG5vdGF0aW9uLlxuICAgICAgICAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgICBfa2V5UG9zID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGFnTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0YWdOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGlzIG1hbGZvcm1lZDogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchJykge1xuICAgIHN0YXRlLnRhZyA9ICchJyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchIScpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjYvKiAmICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDJBLyogKiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlTGlzdCxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy5cbiAgICAvL1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAvLyB0YWcsIGZvciBleGFtcGxlIGxpa2UgdGhpczogXCIhPD8+IFswXVwiXG4gICAgLy9cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITw/PiB0YWc7IGl0IHNob3VsZCBiZSBcInNjYWxhclwiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9va2luZyBmb3IgbXVsdGkgdHlwZVxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB0eXBlTGlzdCA9IHN0YXRlLnR5cGVNYXAubXVsdGlbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXTtcblxuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSB0eXBlTGlzdC5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRhZy5zbGljZSgwLCB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZy5sZW5ndGgpID09PSB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZykge1xuICAgICAgICAgIHR5cGUgPSB0eXBlTGlzdFt0eXBlSW5kZXhdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQsIHN0YXRlLnRhZykpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKTtcbiAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgIHN0YXRlLmFuY2hvciAhPT0gbnVsbCB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RhdGUuYW5jaG9yTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICAgICA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyRS8qIC4gKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEEvKiBMRiAqLyAmJlxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBELyogQ1IgKi8pIHtcbiAgICAgIGlucHV0ICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIEJPTVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHZhciBudWxscG9zID0gaW5wdXQuaW5kZXhPZignXFwwJyk7XG5cbiAgaWYgKG51bGxwb3MgIT09IC0xKSB7XG4gICAgc3RhdGUucG9zaXRpb24gPSBudWxscG9zO1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdudWxsIGJ5dGUgaXMgbm90IGFsbG93ZWQgaW4gaW5wdXQnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsJDEoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IGV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG52YXIgbG9hZEFsbF8xID0gbG9hZEFsbCQxO1xudmFyIGxvYWRfMSAgICA9IGxvYWQkMTtcblxudmFyIGxvYWRlciA9IHtcblx0bG9hZEFsbDogbG9hZEFsbF8xLFxuXHRsb2FkOiBsb2FkXzFcbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG5cblxuXG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX0JPTSAgICAgICAgICAgICAgICAgID0gMHhGRUZGO1xudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxudmFyIERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWCA9IC9eWy0rXT9bMC05X10rKD86OlswLTlfXSspKyg/OlxcLlswLTlfXSopPyQvO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbnZhciBRVU9USU5HX1RZUEVfU0lOR0xFID0gMSxcbiAgICBRVU9USU5HX1RZUEVfRE9VQkxFID0gMjtcblxuZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSAgICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBfZGVmYXVsdDtcbiAgdGhpcy5pbmRlbnQgICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkICAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgICA9IG9wdGlvbnNbJ25vUmVmcyddIHx8IGZhbHNlO1xuICB0aGlzLm5vQ29tcGF0TW9kZSAgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG4gIHRoaXMucXVvdGluZ1R5cGUgICA9IG9wdGlvbnNbJ3F1b3RpbmdUeXBlJ10gPT09ICdcIicgPyBRVU9USU5HX1RZUEVfRE9VQkxFIDogUVVPVElOR19UWVBFX1NJTkdMRTtcbiAgdGhpcy5mb3JjZVF1b3RlcyAgID0gb3B0aW9uc1snZm9yY2VRdW90ZXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5yZXBsYWNlciAgICAgID0gdHlwZW9mIG9wdGlvbnNbJ3JlcGxhY2VyJ10gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zWydyZXBsYWNlciddIDogbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbi8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcblxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBbMzNdIHMtd2hpdGUgOjo9IHMtc3BhY2UgfCBzLXRhYlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzbuKAmXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAgKDB4MDAwMjAgPD0gYyAmJiBjIDw9IDB4MDAwMDdFKVxuICAgICAgfHwgKCgweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRikgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSlcbiAgICAgIHx8ICgoMHgwRTAwMCA8PSBjICYmIGMgPD0gMHgwMEZGRkQpICYmIGMgIT09IENIQVJfQk9NKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBJbmNsdWRpbmcgcy13aGl0ZSAoZm9yIHNvbWUgcmVhc29uLCBleGFtcGxlcyBkb2Vzbid0IG1hdGNoIHNwZWNzIGluIHRoaXMgYXNwZWN0KVxuLy8gbnMtY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWxpbmUtZmVlZCAtIGItY2FycmlhZ2UtcmV0dXJuIC0gYy1ieXRlLW9yZGVyLW1hcmtcbmZ1bmN0aW9uIGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpXG4gICAgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAvLyAtIGItY2hhclxuICAgICYmIGMgIT09IENIQVJfQ0FSUklBR0VfUkVUVVJOXG4gICAgJiYgYyAhPT0gQ0hBUl9MSU5FX0ZFRUQ7XG59XG5cbi8vIFsxMjddICBucy1wbGFpbi1zYWZlKGMpIDo6PSBjID0gZmxvdy1vdXQgIOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWluICAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gYmxvY2sta2V5IOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWtleSAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vIFsxMjhdIG5zLXBsYWluLXNhZmUtb3V0IDo6PSBucy1jaGFyXG4vLyBbMTI5XSAgbnMtcGxhaW4tc2FmZS1pbiA6Oj0gbnMtY2hhciAtIGMtZmxvdy1pbmRpY2F0b3Jcbi8vIFsxMzBdICBucy1wbGFpbi1jaGFyKGMpIDo6PSAgKCBucy1wbGFpbi1zYWZlKGMpIC0g4oCcOuKAnSAtIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIOKAnDrigJ0gLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSAqLyApXG5mdW5jdGlvbiBpc1BsYWluU2FmZShjLCBwcmV2LCBpbmJsb2NrKSB7XG4gIHZhciBjSXNOc0NoYXJPcldoaXRlc3BhY2UgPSBpc05zQ2hhck9yV2hpdGVzcGFjZShjKTtcbiAgdmFyIGNJc05zQ2hhciA9IGNJc05zQ2hhck9yV2hpdGVzcGFjZSAmJiAhaXNXaGl0ZXNwYWNlKGMpO1xuICByZXR1cm4gKFxuICAgIC8vIG5zLXBsYWluLXNhZmVcbiAgICBpbmJsb2NrID8gLy8gYyA9IGZsb3ctaW5cbiAgICAgIGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgOiBjSXNOc0NoYXJPcldoaXRlc3BhY2VcbiAgICAgICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gIClcbiAgICAvLyBucy1wbGFpbi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUCAvLyBmYWxzZSBvbiAnIydcbiAgICAmJiAhKHByZXYgPT09IENIQVJfQ09MT04gJiYgIWNJc05zQ2hhcikgLy8gZmFsc2Ugb24gJzogJ1xuICAgIHx8IChpc05zQ2hhck9yV2hpdGVzcGFjZShwcmV2KSAmJiAhaXNXaGl0ZXNwYWNlKHByZXYpICYmIGMgPT09IENIQVJfU0hBUlApIC8vIGNoYW5nZSB0byB0cnVlIG9uICdbXiBdIydcbiAgICB8fCAocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiBjSXNOc0NoYXIpOyAvLyBjaGFuZ2UgdG8gdHJ1ZSBvbiAnOlteIF0nXG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlRmlyc3QoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5zLWNoYXIgLSBjLWluZGljYXRvclxuICAvLyB3aGVyZSBucy1jaGFyID0gbmItY2hhciAtIHMtd2hpdGUuXG4gIC8vIE5vIHN1cHBvcnQgb2YgKCAoIOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLeKAnSApIC8qIEZvbGxvd2VkIGJ5IGFuIG5zLXBsYWluLXNhZmUoYykpICovICkgcGFydFxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAmJiAhaXNXaGl0ZXNwYWNlKGMpIC8vIC0gcy13aGl0ZVxuICAgIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAgIC8vIOKAnC3igJ0gfCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnCzigJ0gfCDigJxb4oCdIHwg4oCcXeKAnSB8IOKAnHvigJ0gfCDigJx94oCdXG4gICAgJiYgYyAhPT0gQ0hBUl9NSU5VU1xuICAgICYmIGMgIT09IENIQVJfUVVFU1RJT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIHwg4oCcI+KAnSB8IOKAnCbigJ0gfCDigJwq4oCdIHwg4oCcIeKAnSB8IOKAnHzigJ0gfCDigJw94oCdIHwg4oCcPuKAnSB8IOKAnCfigJ0gfCDigJxcIuKAnVxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9FUVVBTFNcbiAgICAmJiBjICE9PSBDSEFSX0dSRUFURVJfVEhBTlxuICAgICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFXG4gICAgJiYgYyAhPT0gQ0hBUl9ET1VCTEVfUVVPVEVcbiAgICAvLyB8IOKAnCXigJ0gfCDigJxA4oCdIHwg4oCcYOKAnSlcbiAgICAmJiBjICE9PSBDSEFSX1BFUkNFTlRcbiAgICAmJiBjICE9PSBDSEFSX0NPTU1FUkNJQUxfQVRcbiAgICAmJiBjICE9PSBDSEFSX0dSQVZFX0FDQ0VOVDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUxhc3QoYykge1xuICAvLyBqdXN0IG5vdCB3aGl0ZXNwYWNlIG9yIGNvbG9uLCBpdCB3aWxsIGJlIGNoZWNrZWQgdG8gYmUgcGxhaW4gY2hhcmFjdGVyIGxhdGVyXG4gIHJldHVybiAhaXNXaGl0ZXNwYWNlKGMpICYmIGMgIT09IENIQVJfQ09MT047XG59XG5cbi8vIFNhbWUgYXMgJ3N0cmluZycuY29kZVBvaW50QXQocG9zKSwgYnV0IHdvcmtzIGluIG9sZGVyIGJyb3dzZXJzLlxuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyaW5nLCBwb3MpIHtcbiAgdmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zKSwgc2Vjb25kO1xuICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBwb3MgKyAxIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgcmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdDtcbn1cblxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLFxuICB0ZXN0QW1iaWd1b3VzVHlwZSwgcXVvdGluZ1R5cGUsIGZvcmNlUXVvdGVzLCBpbmJsb2NrKSB7XG5cbiAgdmFyIGk7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIHByZXZDaGFyID0gbnVsbDtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KGNvZGVQb2ludEF0KHN0cmluZywgMCkpXG4gICAgICAgICAgJiYgaXNQbGFpblNhZmVMYXN0KGNvZGVQb2ludEF0KHN0cmluZywgc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkgfHwgZm9yY2VRdW90ZXMpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2Q2hhciwgaW5ibG9jayk7XG4gICAgICBwcmV2Q2hhciA9IGNoYXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoY2hhciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgaGFzTGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgY2FuIGJlIGZvbGRlZC5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrV2lkdGgpIHtcbiAgICAgICAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHxcbiAgICAgICAgICAgIC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKTtcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICBpZiAocGxhaW4gJiYgIWZvcmNlUXVvdGVzICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gU1RZTEVfUExBSU47XG4gICAgfVxuICAgIHJldHVybiBxdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/IFNUWUxFX0RPVUJMRSA6IFNUWUxFX1NJTkdMRTtcbiAgfVxuICAvLyBFZGdlIGNhc2U6IGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBjYW4gb25seSBoYXZlIG9uZSBkaWdpdC5cbiAgaWYgKGluZGVudFBlckxldmVsID4gOSAmJiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuICBpZiAoIWZvcmNlUXVvdGVzKSB7XG4gICAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG4gIH1cbiAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xufVxuXG4vLyBOb3RlOiBsaW5lIGJyZWFraW5nL2ZvbGRpbmcgaXMgaW1wbGVtZW50ZWQgZm9yIG9ubHkgdGhlIGZvbGRlZCBzdHlsZS5cbi8vIE5CLiBXZSBkcm9wIHRoZSBsYXN0IHRyYWlsaW5nIG5ld2xpbmUgKGlmIGFueSkgb2YgYSByZXR1cm5lZCBibG9jayBzY2FsYXJcbi8vICBzaW5jZSB0aGUgZHVtcGVyIGFkZHMgaXRzIG93biBuZXdsaW5lLiBUaGlzIGFsd2F5cyB3b3Jrczpcbi8vICAgIOKAoiBObyBlbmRpbmcgbmV3bGluZSA9PiB1bmFmZmVjdGVkOyBhbHJlYWR5IHVzaW5nIHN0cmlwIFwiLVwiIGNob21waW5nLlxuLy8gICAg4oCiIEVuZGluZyBuZXdsaW5lICAgID0+IHJlbW92ZWQgdGhlbiByZXN0b3JlZC5cbi8vICBJbXBvcnRhbnRseSwgdGhpcyBrZWVwcyB0aGUgXCIrXCIgY2hvbXAgaW5kaWNhdG9yIGZyb20gZ2FpbmluZyBhbiBleHRyYSBsaW5lLlxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKSB7XG4gIHN0YXRlLmR1bXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RhdGUucXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyAnXCJcIicgOiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlKSB7XG4gICAgICBpZiAoREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSB8fCBERVBSRUNBVEVEX0JBU0U2MF9TWU5UQVgudGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICgnXCInICsgc3RyaW5nICsgJ1wiJykgOiAoXCInXCIgKyBzdHJpbmcgKyBcIidcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMVxuICAgICAgPyAtMSA6IE1hdGgubWF4KE1hdGgubWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLCBzdGF0ZS5saW5lV2lkdGggLSBpbmRlbnQpO1xuXG4gICAgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleVxuICAgICAgLy8gTm8gYmxvY2sgc3R5bGVzIGluIGZsb3cgbW9kZS5cbiAgICAgIHx8IChzdGF0ZS5mbG93TGV2ZWwgPiAtMSAmJiBsZXZlbCA+PSBzdGF0ZS5mbG93TGV2ZWwpO1xuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsXG4gICAgICB0ZXN0QW1iaWd1aXR5LCBzdGF0ZS5xdW90aW5nVHlwZSwgc3RhdGUuZm9yY2VRdW90ZXMgJiYgIWlza2V5LCBpbmJsb2NrKSkge1xuXG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgY2FzZSBTVFlMRV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBcIidcIiArIHN0cmluZy5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKHN0cmluZywgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKGZvbGRTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyaW5nIGlzIHZhbGlkIGZvciBhIGJsb2NrIHNjYWxhciwgMSA8PSBpbmRlbnRQZXJMZXZlbCA8PSA5LlxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpID8gU3RyaW5nKGluZGVudFBlckxldmVsKSA6ICcnO1xuXG4gIC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZTogdGhlIHN0cmluZyAnXFxuJyBjb3VudHMgYXMgYSBcInRyYWlsaW5nXCIgZW1wdHkgbGluZS5cbiAgdmFyIGNsaXAgPSAgICAgICAgICBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJztcbiAgdmFyIGtlZXAgPSBjbGlwICYmIChzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDJdID09PSAnXFxuJyB8fCBzdHJpbmcgPT09ICdcXG4nKTtcbiAgdmFyIGNob21wID0ga2VlcCA/ICcrJyA6IChjbGlwID8gJycgOiAnLScpO1xuXG4gIHJldHVybiBpbmRlbnRJbmRpY2F0b3IgKyBjaG9tcCArICdcXG4nO1xufVxuXG4vLyAoU2VlIHRoZSBub3RlIGZvciB3cml0ZVNjYWxhci4pXG5mdW5jdGlvbiBkcm9wRW5kaW5nTmV3bGluZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn1cblxuLy8gTm90ZTogYSBsb25nIGxpbmUgd2l0aG91dCBhIHN1aXRhYmxlIGJyZWFrIHBvaW50IHdpbGwgZXhjZWVkIHRoZSB3aWR0aCBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBldmVyeSBjaGFyIGluIHN0ciBpc1ByaW50YWJsZSwgc3RyLmxlbmd0aCA+IDAsIHdpZHRoID4gMC5cbmZ1bmN0aW9uIGZvbGRTdHJpbmcoc3RyaW5nLCB3aWR0aCkge1xuICAvLyBJbiBmb2xkZWQgc3R5bGUsICRrJCBjb25zZWN1dGl2ZSBuZXdsaW5lcyBvdXRwdXQgYXMgJGsrMSQgbmV3bGluZXPigJRcbiAgLy8gdW5sZXNzIHRoZXkncmUgYmVmb3JlIG9yIGFmdGVyIGEgbW9yZS1pbmRlbnRlZCBsaW5lLCBvciBhdCB0aGUgdmVyeVxuICAvLyBiZWdpbm5pbmcgb3IgZW5kLCBpbiB3aGljaCBjYXNlICRrJCBtYXBzIHRvICRrJC5cbiAgLy8gVGhlcmVmb3JlLCBwYXJzZSBlYWNoIGNodW5rIGFzIG5ld2xpbmUocykgZm9sbG93ZWQgYnkgYSBjb250ZW50IGxpbmUuXG4gIHZhciBsaW5lUmUgPSAvKFxcbispKFteXFxuXSopL2c7XG5cbiAgLy8gZmlyc3QgbGluZSAocG9zc2libHkgYW4gZW1wdHkgbGluZSlcbiAgdmFyIHJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRMRiA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcbiAgICBuZXh0TEYgPSBuZXh0TEYgIT09IC0xID8gbmV4dExGIDogc3RyaW5nLmxlbmd0aDtcbiAgICBsaW5lUmUubGFzdEluZGV4ID0gbmV4dExGO1xuICAgIHJldHVybiBmb2xkTGluZShzdHJpbmcuc2xpY2UoMCwgbmV4dExGKSwgd2lkdGgpO1xuICB9KCkpO1xuICAvLyBJZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSB5ZXQsIGRvbid0IGFkZCBhbiBleHRyYSBcXG4uXG4gIHZhciBwcmV2TW9yZUluZGVudGVkID0gc3RyaW5nWzBdID09PSAnXFxuJyB8fCBzdHJpbmdbMF0gPT09ICcgJztcbiAgdmFyIG1vcmVJbmRlbnRlZDtcblxuICAvLyByZXN0IG9mIHRoZSBsaW5lc1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBsaW5lUmUuZXhlYyhzdHJpbmcpKSkge1xuICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXSwgbGluZSA9IG1hdGNoWzJdO1xuICAgIG1vcmVJbmRlbnRlZCA9IChsaW5lWzBdID09PSAnICcpO1xuICAgIHJlc3VsdCArPSBwcmVmaXhcbiAgICAgICsgKCFwcmV2TW9yZUluZGVudGVkICYmICFtb3JlSW5kZW50ZWQgJiYgbGluZSAhPT0gJydcbiAgICAgICAgPyAnXFxuJyA6ICcnKVxuICAgICAgKyBmb2xkTGluZShsaW5lLCB3aWR0aCk7XG4gICAgcHJldk1vcmVJbmRlbnRlZCA9IG1vcmVJbmRlbnRlZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdyZWVkeSBsaW5lIGJyZWFraW5nLlxuLy8gUGlja3MgdGhlIGxvbmdlc3QgbGluZSB1bmRlciB0aGUgbGltaXQgZWFjaCB0aW1lLFxuLy8gb3RoZXJ3aXNlIHNldHRsZXMgZm9yIHRoZSBzaG9ydGVzdCBsaW5lIG92ZXIgdGhlIGxpbWl0LlxuLy8gTkIuIE1vcmUtaW5kZW50ZWQgbGluZXMgKmNhbm5vdCogYmUgZm9sZGVkLCBhcyB0aGF0IHdvdWxkIGFkZCBhbiBleHRyYSBcXG4uXG5mdW5jdGlvbiBmb2xkTGluZShsaW5lLCB3aWR0aCkge1xuICBpZiAobGluZSA9PT0gJycgfHwgbGluZVswXSA9PT0gJyAnKSByZXR1cm4gbGluZTtcblxuICAvLyBTaW5jZSBhIG1vcmUtaW5kZW50ZWQgbGluZSBhZGRzIGEgXFxuLCBicmVha3MgY2FuJ3QgYmUgZm9sbG93ZWQgYnkgYSBzcGFjZS5cbiAgdmFyIGJyZWFrUmUgPSAvIFteIF0vZzsgLy8gbm90ZTogdGhlIG1hdGNoIGluZGV4IHdpbGwgYWx3YXlzIGJlIDw9IGxlbmd0aC0yLlxuICB2YXIgbWF0Y2g7XG4gIC8vIHN0YXJ0IGlzIGFuIGluY2x1c2l2ZSBpbmRleC4gZW5kLCBjdXJyLCBhbmQgbmV4dCBhcmUgZXhjbHVzaXZlLlxuICB2YXIgc3RhcnQgPSAwLCBlbmQsIGN1cnIgPSAwLCBuZXh0ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIC8vIEludmFyaWFudHM6IDAgPD0gc3RhcnQgPD0gbGVuZ3RoLTEuXG4gIC8vICAgMCA8PSBjdXJyIDw9IG5leHQgPD0gbWF4KDAsIGxlbmd0aC0yKS4gY3VyciAtIHN0YXJ0IDw9IHdpZHRoLlxuICAvLyBJbnNpZGUgdGhlIGxvb3A6XG4gIC8vICAgQSBtYXRjaCBpbXBsaWVzIGxlbmd0aCA+PSAyLCBzbyBjdXJyIGFuZCBuZXh0IGFyZSA8PSBsZW5ndGgtMi5cbiAgd2hpbGUgKChtYXRjaCA9IGJyZWFrUmUuZXhlYyhsaW5lKSkpIHtcbiAgICBuZXh0ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gbWFpbnRhaW4gaW52YXJpYW50OiBjdXJyIC0gc3RhcnQgPD0gd2lkdGhcbiAgICBpZiAobmV4dCAtIHN0YXJ0ID4gd2lkdGgpIHtcbiAgICAgIGVuZCA9IChjdXJyID4gc3RhcnQpID8gY3VyciA6IG5leHQ7IC8vIGRlcml2ZSBlbmQgPD0gbGVuZ3RoLTJcbiAgICAgIHJlc3VsdCArPSAnXFxuJyArIGxpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAvLyBza2lwIHRoZSBzcGFjZSB0aGF0IHdhcyBvdXRwdXQgYXMgXFxuXG4gICAgICBzdGFydCA9IGVuZCArIDE7ICAgICAgICAgICAgICAgICAgICAvLyBkZXJpdmUgc3RhcnQgPD0gbGVuZ3RoLTFcbiAgICB9XG4gICAgY3VyciA9IG5leHQ7XG4gIH1cblxuICAvLyBCeSB0aGUgaW52YXJpYW50cywgc3RhcnQgPD0gbGVuZ3RoLTEsIHNvIHRoZXJlIGlzIHNvbWV0aGluZyBsZWZ0IG92ZXIuXG4gIC8vIEl0IGlzIGVpdGhlciB0aGUgd2hvbGUgc3RyaW5nIG9yIGEgcGFydCBzdGFydGluZyBmcm9tIG5vbi13aGl0ZXNwYWNlLlxuICByZXN1bHQgKz0gJ1xcbic7XG4gIC8vIEluc2VydCBhIGJyZWFrIGlmIHRoZSByZW1haW5kZXIgaXMgdG9vIGxvbmcgYW5kIHRoZXJlIGlzIGEgYnJlYWsgYXZhaWxhYmxlLlxuICBpZiAobGluZS5sZW5ndGggLSBzdGFydCA+IHdpZHRoICYmIGN1cnIgPiBzdGFydCkge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0LCBjdXJyKSArICdcXG4nICsgbGluZS5zbGljZShjdXJyICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTsgLy8gZHJvcCBleHRyYSBcXG4gam9pbmVyXG59XG5cbi8vIEVzY2FwZXMgYSBkb3VibGUtcXVvdGVkIHN0cmluZy5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY2hhciA9IDA7XG4gIHZhciBlc2NhcGVTZXE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuXG4gICAgaWYgKCFlc2NhcGVTZXEgJiYgaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdbaV07XG4gICAgICBpZiAoY2hhciA+PSAweDEwMDAwKSByZXN1bHQgKz0gc3RyaW5nW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGVzY2FwZVNlcSB8fCBlbmNvZGVIZXgoY2hhcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgdmFsdWUsIGZhbHNlLCBmYWxzZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG51bGwsIGZhbHNlLCBmYWxzZSkpKSB7XG5cbiAgICAgIGlmIChfcmVzdWx0ICE9PSAnJykgX3Jlc3VsdCArPSAnLCcgKyAoIXN0YXRlLmNvbmRlbnNlRmxvdyA/ICcgJyA6ICcnKTtcbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ1snICsgX3Jlc3VsdCArICddJztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIFN0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLCBwdXQgbnVsbCBpbnN0ZWFkIG9mIGludmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgbnVsbCwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpKSkge1xuXG4gICAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgICAgX3Jlc3VsdCArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0ICs9ICctICc7XG4gICAgICB9XG5cbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAnW10nOyAvLyBFbXB0eSBzZXF1ZW5jZSBpZiBubyB2YWxpZCB2YWx1ZXMuXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgIHBhaXJCdWZmZXIgPSAnJztcbiAgICBpZiAoX3Jlc3VsdCAhPT0gJycpIHBhaXJCdWZmZXIgKz0gJywgJztcblxuICAgIGlmIChzdGF0ZS5jb25kZW5zZUZsb3cpIHBhaXJCdWZmZXIgKz0gJ1wiJztcblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IF9yZXN1bHQgIT09ICcnKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICBvYmplY3RWYWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBvYmplY3RLZXksIG9iamVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JykgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBpZiAoZXhwbGljaXQpIHtcbiAgICAgICAgaWYgKHR5cGUubXVsdGkgJiYgdHlwZS5yZXByZXNlbnROYW1lKSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS5yZXByZXNlbnROYW1lKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXksIGlzYmxvY2tzZXEpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG4gIHZhciBpbmJsb2NrID0gYmxvY2s7XG4gIHZhciB0YWdTdHI7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ub0FycmF5SW5kZW50ICYmICFpc2Jsb2Nrc2VxICYmIGxldmVsID4gMCkge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwgLSAxLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVuZGVmaW5lZF0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5za2lwSW52YWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIC8vIE5lZWQgdG8gZW5jb2RlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCB0aG9zZSBhbGxvd2VkIGJ5IHRoZSBzcGVjOlxuICAgICAgLy9cbiAgICAgIC8vIFszNV0gbnMtZGVjLWRpZ2l0ICAgIDo6PSAgWyN4MzAtI3gzOV0gLyogMC05ICovXG4gICAgICAvLyBbMzZdIG5zLWhleC1kaWdpdCAgICA6Oj0gIG5zLWRlYy1kaWdpdFxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCBbI3g0MS0jeDQ2XSAvKiBBLUYgKi8gfCBbI3g2MS0jeDY2XSAvKiBhLWYgKi9cbiAgICAgIC8vIFszN10gbnMtYXNjaWktbGV0dGVyIDo6PSAgWyN4NDEtI3g1QV0gLyogQS1aICovIHwgWyN4NjEtI3g3QV0gLyogYS16ICovXG4gICAgICAvLyBbMzhdIG5zLXdvcmQtY2hhciAgICA6Oj0gIG5zLWRlYy1kaWdpdCB8IG5zLWFzY2lpLWxldHRlciB8IOKAnC3igJ1cbiAgICAgIC8vIFszOV0gbnMtdXJpLWNoYXIgICAgIDo6PSAg4oCcJeKAnSBucy1oZXgtZGlnaXQgbnMtaGV4LWRpZ2l0IHwgbnMtd29yZC1jaGFyIHwg4oCcI+KAnVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCDigJw74oCdIHwg4oCcL+KAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcQOKAnSB8IOKAnCbigJ0gfCDigJw94oCdIHwg4oCcK+KAnSB8IOKAnCTigJ0gfCDigJws4oCdXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IOKAnF/igJ0gfCDigJwu4oCdIHwg4oCcIeKAnSB8IOKAnH7igJ0gfCDigJwq4oCdIHwg4oCcJ+KAnSB8IOKAnCjigJ0gfCDigJwp4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ1cbiAgICAgIC8vXG4gICAgICAvLyBBbHNvIG5lZWQgdG8gZW5jb2RlICchJyBiZWNhdXNlIGl0IGhhcyBzcGVjaWFsIG1lYW5pbmcgKGVuZCBvZiB0YWcgcHJlZml4KS5cbiAgICAgIC8vXG4gICAgICB0YWdTdHIgPSBlbmNvZGVVUkkoXG4gICAgICAgIHN0YXRlLnRhZ1swXSA9PT0gJyEnID8gc3RhdGUudGFnLnNsaWNlKDEpIDogc3RhdGUudGFnXG4gICAgICApLnJlcGxhY2UoLyEvZywgJyUyMScpO1xuXG4gICAgICBpZiAoc3RhdGUudGFnWzBdID09PSAnIScpIHtcbiAgICAgICAgdGFnU3RyID0gJyEnICsgdGFnU3RyO1xuICAgICAgfSBlbHNlIGlmICh0YWdTdHIuc2xpY2UoMCwgMTgpID09PSAndGFnOnlhbWwub3JnLDIwMDI6Jykge1xuICAgICAgICB0YWdTdHIgPSAnISEnICsgdGFnU3RyLnNsaWNlKDE4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ1N0ciA9ICchPCcgKyB0YWdTdHIgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmR1bXAgPSB0YWdTdHIgKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcCQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIHZhciB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgdmFsdWUsIHRydWUsIHRydWUpKSByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGR1bXBfMSA9IGR1bXAkMTtcblxudmFyIGR1bXBlciA9IHtcblx0ZHVtcDogZHVtcF8xXG59O1xuXG5mdW5jdGlvbiByZW5hbWVkKGZyb20sIHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiB5YW1sLicgKyBmcm9tICsgJyBpcyByZW1vdmVkIGluIGpzLXlhbWwgNC4gJyArXG4gICAgICAnVXNlIHlhbWwuJyArIHRvICsgJyBpbnN0ZWFkLCB3aGljaCBpcyBub3cgc2FmZSBieSBkZWZhdWx0LicpO1xuICB9O1xufVxuXG5cbnZhciBUeXBlICAgICAgICAgICAgICAgID0gdHlwZTtcbnZhciBTY2hlbWEgICAgICAgICAgICAgID0gc2NoZW1hO1xudmFyIEZBSUxTQUZFX1NDSEVNQSAgICAgPSBmYWlsc2FmZTtcbnZhciBKU09OX1NDSEVNQSAgICAgICAgID0ganNvbjtcbnZhciBDT1JFX1NDSEVNQSAgICAgICAgID0gY29yZTtcbnZhciBERUZBVUxUX1NDSEVNQSAgICAgID0gX2RlZmF1bHQ7XG52YXIgbG9hZCAgICAgICAgICAgICAgICA9IGxvYWRlci5sb2FkO1xudmFyIGxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbnZhciBkdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IGV4Y2VwdGlvbjtcblxuLy8gUmUtZXhwb3J0IGFsbCB0eXBlcyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gY3JlYXRlIGN1c3RvbSBzY2hlbWFcbnZhciB0eXBlcyA9IHtcbiAgYmluYXJ5OiAgICBiaW5hcnksXG4gIGZsb2F0OiAgICAgZmxvYXQsXG4gIG1hcDogICAgICAgbWFwLFxuICBudWxsOiAgICAgIF9udWxsLFxuICBwYWlyczogICAgIHBhaXJzLFxuICBzZXQ6ICAgICAgIHNldCxcbiAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gIGJvb2w6ICAgICAgYm9vbCxcbiAgaW50OiAgICAgICBpbnQsXG4gIG1lcmdlOiAgICAgbWVyZ2UsXG4gIG9tYXA6ICAgICAgb21hcCxcbiAgc2VxOiAgICAgICBzZXEsXG4gIHN0cjogICAgICAgc3RyXG59O1xuXG4vLyBSZW1vdmVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMy4wLnhcbnZhciBzYWZlTG9hZCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUxvYWQnLCAnbG9hZCcpO1xudmFyIHNhZmVMb2FkQWxsICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZEFsbCcsICdsb2FkQWxsJyk7XG52YXIgc2FmZUR1bXAgICAgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVEdW1wJywgJ2R1bXAnKTtcblxudmFyIGpzWWFtbCA9IHtcblx0VHlwZTogVHlwZSxcblx0U2NoZW1hOiBTY2hlbWEsXG5cdEZBSUxTQUZFX1NDSEVNQTogRkFJTFNBRkVfU0NIRU1BLFxuXHRKU09OX1NDSEVNQTogSlNPTl9TQ0hFTUEsXG5cdENPUkVfU0NIRU1BOiBDT1JFX1NDSEVNQSxcblx0REVGQVVMVF9TQ0hFTUE6IERFRkFVTFRfU0NIRU1BLFxuXHRsb2FkOiBsb2FkLFxuXHRsb2FkQWxsOiBsb2FkQWxsLFxuXHRkdW1wOiBkdW1wLFxuXHRZQU1MRXhjZXB0aW9uOiBZQU1MRXhjZXB0aW9uLFxuXHR0eXBlczogdHlwZXMsXG5cdHNhZmVMb2FkOiBzYWZlTG9hZCxcblx0c2FmZUxvYWRBbGw6IHNhZmVMb2FkQWxsLFxuXHRzYWZlRHVtcDogc2FmZUR1bXBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGpzWWFtbDtcbmV4cG9ydCB7IENPUkVfU0NIRU1BLCBERUZBVUxUX1NDSEVNQSwgRkFJTFNBRkVfU0NIRU1BLCBKU09OX1NDSEVNQSwgU2NoZW1hLCBUeXBlLCBZQU1MRXhjZXB0aW9uLCBkdW1wLCBsb2FkLCBsb2FkQWxsLCBzYWZlRHVtcCwgc2FmZUxvYWQsIHNhZmVMb2FkQWxsLCB0eXBlcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/js-yaml/dist/js-yaml.mjs\n");

/***/ }),

/***/ "./node_modules/lit-html/development/async-directive.js":
/*!**************************************************************!*\
  !*** ./node_modules/lit-html/development/async-directive.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AsyncDirective\": () => (/* binding */ AsyncDirective),\n/* harmony export */   \"directive\": () => (/* reexport safe */ _directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)\n/* harmony export */ });\n/* harmony import */ var _directive_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./directive-helpers.js */ \"./node_modules/lit-html/development/directive-helpers.js\");\n/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./directive.js */ \"./node_modules/lit-html/development/directive.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\nconst DEV_MODE = true;\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\n\nconst notifyChildrenConnectedChanged = (parent, isConnected) => {\n  var _a, _b;\n\n  const children = parent._$disconnectableChildren;\n\n  if (children === undefined) {\n    return false;\n  }\n\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (_b = (_a = obj)['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(_a, isConnected, false); // Disconnect Part/TemplateInstance\n\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n\n  return true;\n};\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\n\n\nconst removeDisconnectableFromParent = obj => {\n  let parent, children;\n\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n\n    children = parent._$disconnectableChildren;\n    children.delete(obj);\n    obj = parent;\n  } while ((children === null || children === void 0 ? void 0 : children.size) === 0);\n};\n\nconst addDisconnectableToParent = obj => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; parent = obj._$parent; obj = parent) {\n    let children = parent._$disconnectableChildren;\n\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\n\n\nfunction reparentDisconnectables(newParent) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\n\n\nfunction notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value, false);\n      removeDisconnectableFromParent(value);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n/**\n * Patches disconnection API onto ChildParts.\n */\n\n\nconst installDisconnectAPI = obj => {\n  var _a, _b;\n\n  var _c, _d;\n\n  if (obj.type == _directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.CHILD) {\n    (_a = (_c = obj)._$notifyConnectionChanged) !== null && _a !== void 0 ? _a : _c._$notifyConnectionChanged = notifyChildPartConnectedChanged;\n    (_b = (_d = obj)._$reparentDisconnectables) !== null && _b !== void 0 ? _b : _d._$reparentDisconnectables = reparentDisconnectables;\n  }\n};\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\n\n\nclass AsyncDirective extends _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {\n  constructor() {\n    super(...arguments); // @internal\n\n    this._$disconnectableChildren = undefined;\n  }\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n\n\n  _$initialize(part, parent, attributeIndex) {\n    super._$initialize(part, parent, attributeIndex);\n\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  } // This property needs to remain unminified.\n\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n\n\n  ['_$notifyDirectiveConnectionChanged'](isConnected, isClearingDirective = true) {\n    var _a, _b;\n\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n\n      if (isConnected) {\n        (_a = this.reconnected) === null || _a === void 0 ? void 0 : _a.call(this);\n      } else {\n        (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this);\n      }\n    }\n\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n\n\n  setValue(value) {\n    if ((0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isSingleExpression)(this.__part)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n\n      const newValues = [...this.__part._$committedValue];\n      newValues[this.__attributeIndex] = value;\n\n      this.__part._$setValue(newValues, this, 0);\n    }\n  }\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n\n\n  disconnected() {}\n\n  reconnected() {}\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGV2ZWxvcG1lbnQvYXN5bmMtZGlyZWN0aXZlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7QUF5SEE7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7QUFPQTs7O0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQU1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTs7Ozs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFBQTtBQUFBOztBQVlBO0FBZ0ZBO0FBL0VBOzs7Ozs7OztBQU1BO0FBS0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQVlBOzs7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BOztBQUNBOztBQTNGQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL2FzeW5jLWRpcmVjdGl2ZS50cz84OGZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIE92ZXJ2aWV3OlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGRlc2lnbmVkIHRvIGFkZCBzdXBwb3J0IGZvciBhbiBhc3luYyBgc2V0VmFsdWVgIEFQSSBhbmRcbiAqIGBkaXNjb25uZWN0ZWRgIGNhbGxiYWNrIHRvIGRpcmVjdGl2ZXMgd2l0aCB0aGUgbGVhc3QgaW1wYWN0IG9uIHRoZSBjb3JlXG4gKiBydW50aW1lIG9yIHBheWxvYWQgd2hlbiB0aGF0IGZlYXR1cmUgaXMgbm90IHVzZWQuXG4gKlxuICogVGhlIHN0cmF0ZWd5IGlzIHRvIGludHJvZHVjZSBhIGBBc3luY0RpcmVjdGl2ZWAgc3ViY2xhc3Mgb2ZcbiAqIGBEaXJlY3RpdmVgIHRoYXQgY2xpbWJzIHRoZSBcInBhcmVudFwiIHRyZWUgaW4gaXRzIGNvbnN0cnVjdG9yIHRvIG5vdGUgd2hpY2hcbiAqIGJyYW5jaGVzIG9mIGxpdC1odG1sJ3MgXCJsb2dpY2FsIHRyZWVcIiBvZiBkYXRhIHN0cnVjdHVyZXMgY29udGFpbiBzdWNoXG4gKiBkaXJlY3RpdmVzIGFuZCB0aHVzIG5lZWQgdG8gYmUgY3Jhd2xlZCB3aGVuIGEgc3VidHJlZSBpcyBiZWluZyBjbGVhcmVkIChvclxuICogbWFudWFsbHkgZGlzY29ubmVjdGVkKSBpbiBvcmRlciB0byBydW4gdGhlIGBkaXNjb25uZWN0ZWRgIGNhbGxiYWNrLlxuICpcbiAqIFRoZSBcIm5vZGVzXCIgb2YgdGhlIGxvZ2ljYWwgdHJlZSBpbmNsdWRlIFBhcnRzLCBUZW1wbGF0ZUluc3RhbmNlcyAoZm9yIHdoZW4gYVxuICogVGVtcGxhdGVSZXN1bHQgaXMgY29tbWl0dGVkIHRvIGEgdmFsdWUgb2YgYSBDaGlsZFBhcnQpLCBhbmQgRGlyZWN0aXZlczsgdGhlc2VcbiAqIGFsbCBpbXBsZW1lbnQgYSBjb21tb24gaW50ZXJmYWNlIGNhbGxlZCBgRGlzY29ubmVjdGFibGVDaGlsZGAuIEVhY2ggaGFzIGFcbiAqIGBfJHBhcmVudGAgcmVmZXJlbmNlIHdoaWNoIGlzIHNldCBkdXJpbmcgY29uc3RydWN0aW9uIGluIHRoZSBjb3JlIGNvZGUsIGFuZCBhXG4gKiBgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuYCBmaWVsZCB3aGljaCBpcyBpbml0aWFsbHkgdW5kZWZpbmVkLlxuICpcbiAqIFRoZSBzcGFyc2UgdHJlZSBjcmVhdGVkIGJ5IG1lYW5zIG9mIHRoZSBgQXN5bmNEaXJlY3RpdmVgIGNvbnN0cnVjdG9yXG4gKiBjcmF3bGluZyB1cCB0aGUgYF8kcGFyZW50YCB0cmVlIGFuZCBwbGFjaW5nIGEgYF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbmAgU2V0XG4gKiBvbiBlYWNoIHBhcmVudCB0aGF0IGluY2x1ZGVzIGVhY2ggY2hpbGQgdGhhdCBjb250YWlucyBhXG4gKiBgQXN5bmNEaXJlY3RpdmVgIGRpcmVjdGx5IG9yIHRyYW5zaXRpdmVseSB2aWEgaXRzIGNoaWxkcmVuLiBJbiBvcmRlciB0b1xuICogbm90aWZ5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBhbmQgZGlzY29ubmVjdCAob3IgcmVjb25uZWN0KSBhIHRyZWUsIHRoZVxuICogYF8kbm90aWZ5Q29ubmVjdGlvbkNoYW5nZWRgIEFQSSBpcyBwYXRjaGVkIG9udG8gQ2hpbGRQYXJ0cyBhcyBhIGRpcmVjdGl2ZVxuICogY2xpbWJzIHRoZSBwYXJlbnQgdHJlZSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoZSBjb3JlIHdoZW4gY2xlYXJpbmcgYSBwYXJ0IGlmXG4gKiBpdCBleGlzdHMuIFdoZW4gY2FsbGVkLCB0aGF0IG1ldGhvZCBpdGVyYXRlcyBvdmVyIHRoZSBzcGFyc2UgdHJlZSBvZlxuICogU2V0PERpc2Nvbm5lY3RhYmxlQ2hpbGRyZW4+IGJ1aWx0IHVwIGJ5IEFzeW5jRGlyZWN0aXZlcywgYW5kIGNhbGxzXG4gKiBgXyRub3RpZnlEaXJlY3RpdmVDb25uZWN0aW9uQ2hhbmdlZGAgb24gYW55IGRpcmVjdGl2ZXMgdGhhdCBhcmUgZW5jb3VudGVyZWRcbiAqIGluIHRoYXQgdHJlZSwgcnVubmluZyB0aGUgcmVxdWlyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEEgZ2l2ZW4gXCJsb2dpY2FsIHRyZWVcIiBvZiBsaXQtaHRtbCBkYXRhLXN0cnVjdHVyZXMgbWlnaHQgbG9vayBsaWtlIHRoaXM6XG4gKlxuICogIENoaWxkUGFydChOMSkgXyRkQz1bRDIsVDNdXG4gKiAgIC5fZGlyZWN0aXZlXG4gKiAgICAgQXN5bmNEaXJlY3RpdmUoRDIpXG4gKiAgIC5fdmFsdWUgLy8gdXNlciB2YWx1ZSB3YXMgVGVtcGxhdGVSZXN1bHRcbiAqICAgICBUZW1wbGF0ZUluc3RhbmNlKFQzKSBfJGRDPVtBNCxBNixOMTAsTjEyXVxuICogICAgICAuX3BhcnRzW11cbiAqICAgICAgICBBdHRyaWJ1dGVQYXJ0KEE0KSBfJGRDPVtENV1cbiAqICAgICAgICAgLl9kaXJlY3RpdmVzW11cbiAqICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShENSlcbiAqICAgICAgICBBdHRyaWJ1dGVQYXJ0KEE2KSBfJGRDPVtENyxEOF1cbiAqICAgICAgICAgLl9kaXJlY3RpdmVzW11cbiAqICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShENylcbiAqICAgICAgICAgICBEaXJlY3RpdmUoRDgpIF8kZEM9W0Q5XVxuICogICAgICAgICAgICAuX2RpcmVjdGl2ZVxuICogICAgICAgICAgICAgIEFzeW5jRGlyZWN0aXZlKEQ5KVxuICogICAgICAgIENoaWxkUGFydChOMTApIF8kZEM9W0QxMV1cbiAqICAgICAgICAgLl9kaXJlY3RpdmVcbiAqICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShEMTEpXG4gKiAgICAgICAgIC5fdmFsdWVcbiAqICAgICAgICAgICBzdHJpbmdcbiAqICAgICAgICBDaGlsZFBhcnQoTjEyKSBfJGRDPVtEMTMsTjE0LE4xNl1cbiAqICAgICAgICAgLl9kaXJlY3RpdmVcbiAqICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShEMTMpXG4gKiAgICAgICAgIC5fdmFsdWUgLy8gdXNlciB2YWx1ZSB3YXMgaXRlcmFibGVcbiAqICAgICAgICAgICBBcnJheTxDaGlsZFBhcnQ+XG4gKiAgICAgICAgICAgICBDaGlsZFBhcnQoTjE0KSBfJGRDPVtEMTVdXG4gKiAgICAgICAgICAgICAgLl92YWx1ZVxuICogICAgICAgICAgICAgICAgc3RyaW5nXG4gKiAgICAgICAgICAgICBDaGlsZFBhcnQoTjE2KSBfJGRDPVtEMTcsVDE4XVxuICogICAgICAgICAgICAgIC5fZGlyZWN0aXZlXG4gKiAgICAgICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShEMTcpXG4gKiAgICAgICAgICAgICAgLl92YWx1ZSAvLyB1c2VyIHZhbHVlIHdhcyBUZW1wbGF0ZVJlc3VsdFxuICogICAgICAgICAgICAgICAgVGVtcGxhdGVJbnN0YW5jZShUMTgpIF8kZEM9W0ExOSxBMjEsTjI1XVxuICogICAgICAgICAgICAgICAgIC5fcGFydHNbXVxuICogICAgICAgICAgICAgICAgICAgQXR0cmlidXRlUGFydChBMTkpIF8kZEM9W0QyMF1cbiAqICAgICAgICAgICAgICAgICAgICAuX2RpcmVjdGl2ZXNbXVxuICogICAgICAgICAgICAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDIwKVxuICogICAgICAgICAgICAgICAgICAgQXR0cmlidXRlUGFydChBMjEpIF8kZEM9WzIyLDIzXVxuICogICAgICAgICAgICAgICAgICAgIC5fZGlyZWN0aXZlc1tdXG4gKiAgICAgICAgICAgICAgICAgICAgICBBc3luY0RpcmVjdGl2ZShEMjIpXG4gKiAgICAgICAgICAgICAgICAgICAgICBEaXJlY3RpdmUoRDIzKSBfJGRDPVtEMjRdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgLl9kaXJlY3RpdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEFzeW5jRGlyZWN0aXZlKEQyNClcbiAqICAgICAgICAgICAgICAgICAgIENoaWxkUGFydChOMjUpIF8kZEM9W0QyNl1cbiAqICAgICAgICAgICAgICAgICAgICAuX2RpcmVjdGl2ZVxuICogICAgICAgICAgICAgICAgICAgICAgQXN5bmNEaXJlY3RpdmUoRDI2KVxuICogICAgICAgICAgICAgICAgICAgIC5fdmFsdWVcbiAqICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ1xuICpcbiAqIEV4YW1wbGUgMTogVGhlIGRpcmVjdGl2ZSBpbiBDaGlsZFBhcnQoTjEyKSB1cGRhdGVzIGFuZCByZXR1cm5zIGBub3RoaW5nYC4gVGhlXG4gKiBDaGlsZFBhcnQgd2lsbCBfY2xlYXIoKSBpdHNlbGYsIGFuZCBzbyB3ZSBuZWVkIHRvIGRpc2Nvbm5lY3QgdGhlIFwidmFsdWVcIiBvZlxuICogdGhlIENoaWxkUGFydCAoYnV0IG5vdCBpdHMgZGlyZWN0aXZlKS4gSW4gdGhpcyBjYXNlLCB3aGVuIGBfY2xlYXIoKWAgY2FsbHNcbiAqIGBfJG5vdGlmeUNvbm5lY3Rpb25DaGFuZ2VkKClgLCB3ZSBkb24ndCBpdGVyYXRlIGFsbCBvZiB0aGVcbiAqIF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbiwgcmF0aGVyIHdlIGRvIGEgdmFsdWUtc3BlY2lmaWMgZGlzY29ubmVjdGlvbjogaS5lLlxuICogc2luY2UgdGhlIF92YWx1ZSB3YXMgYW4gQXJyYXk8Q2hpbGRQYXJ0PiAoYmVjYXVzZSBhbiBpdGVyYWJsZSBoYWQgYmVlblxuICogY29tbWl0dGVkKSwgd2UgaXRlcmF0ZSB0aGUgYXJyYXkgb2YgQ2hpbGRQYXJ0cyAoTjE0LCBOMTYpIGFuZCBydW5cbiAqIGBzZXRDb25uZWN0ZWRgIG9uIHRoZW0gKHdoaWNoIGRvZXMgcmVjdXJzZSBkb3duIHRoZSBmdWxsIHRyZWUgb2ZcbiAqIGBfJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW5gIGJlbG93IGl0LCBhbmQgYWxzbyByZW1vdmVzIE4xNCBhbmQgTjE2IGZyb20gTjEyJ3NcbiAqIGBfJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW5gKS4gT25jZSB0aGUgdmFsdWVzIGhhdmUgYmVlbiBkaXNjb25uZWN0ZWQsIHdlIHRoZW5cbiAqIGNoZWNrIHdoZXRoZXIgdGhlIENoaWxkUGFydChOMTIpJ3MgbGlzdCBvZiBgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuYCBpcyBlbXB0eVxuICogKGFuZCB3b3VsZCByZW1vdmUgaXQgZnJvbSBpdHMgcGFyZW50IFRlbXBsYXRlSW5zdGFuY2UoVDMpIGlmIHNvKSwgYnV0IHNpbmNlXG4gKiBpdCB3b3VsZCBzdGlsbCBjb250YWluIGl0cyBkaXJlY3RpdmUgRDEzLCBpdCBzdGF5cyBpbiB0aGUgZGlzY29ubmVjdGFibGVcbiAqIHRyZWUuXG4gKlxuICogRXhhbXBsZSAyOiBJbiB0aGUgY291cnNlIG9mIEV4YW1wbGUgMSwgYHNldENvbm5lY3RlZGAgd2lsbCByZWFjaFxuICogQ2hpbGRQYXJ0KE4xNik7IGluIHRoaXMgY2FzZSB0aGUgZW50aXJlIHBhcnQgaXMgYmVpbmcgZGlzY29ubmVjdGVkLCBzbyB3ZVxuICogc2ltcGx5IGl0ZXJhdGUgYWxsIG9mIE4xNidzIGBfJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW5gIChEMTcsVDE4KSBhbmRcbiAqIHJlY3Vyc2l2ZWx5IHJ1biBgc2V0Q29ubmVjdGVkYCBvbiB0aGVtLiBOb3RlIHRoYXQgd2Ugb25seSByZW1vdmUgY2hpbGRyZW5cbiAqIGZyb20gYF8kZGlzY29ubmVjdGFibGVDaGlsZHJlbmAgZm9yIHRoZSB0b3AtbGV2ZWwgdmFsdWVzIGJlaW5nIGRpc2Nvbm5lY3RlZFxuICogb24gYSBjbGVhcjsgZG9pbmcgdGhpcyBib29ra2VlcGluZyBsb3dlciBpbiB0aGUgdHJlZSBpcyB3YXN0ZWZ1bCBzaW5jZSBpdCdzXG4gKiBhbGwgYmVpbmcgdGhyb3duIGF3YXkuXG4gKlxuICogRXhhbXBsZSAzOiBJZiB0aGUgTGl0RWxlbWVudCBjb250YWluaW5nIHRoZSBlbnRpcmUgdHJlZSBhYm92ZSBiZWNvbWVzXG4gKiBkaXNjb25uZWN0ZWQsIGl0IHdpbGwgcnVuIGBjaGlsZFBhcnQuc2V0Q29ubmVjdGVkKClgICh3aGljaCBjYWxsc1xuICogYGNoaWxkUGFydC5fJG5vdGlmeUNvbm5lY3Rpb25DaGFuZ2VkKClgIGlmIGl0IGV4aXN0cyk7IGluIHRoaXMgY2FzZSwgd2VcbiAqIHJlY3Vyc2l2ZWx5IHJ1biBgc2V0Q29ubmVjdGVkKClgIG92ZXIgdGhlIGVudGlyZSB0cmVlLCB3aXRob3V0IHJlbW92aW5nIGFueVxuICogY2hpbGRyZW4gZnJvbSBgXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuYCwgc2luY2UgdGhpcyB0cmVlIGlzIHJlcXVpcmVkIHRvXG4gKiByZS1jb25uZWN0IHRoZSB0cmVlLCB3aGljaCBkb2VzIHRoZSBzYW1lIG9wZXJhdGlvbiwgc2ltcGx5IHBhc3NpbmdcbiAqIGBpc0Nvbm5lY3RlZDogdHJ1ZWAgZG93biB0aGUgdHJlZSwgc2lnbmFsaW5nIHdoaWNoIGNhbGxiYWNrIHRvIHJ1bi5cbiAqL1xuXG5pbXBvcnQge0F0dHJpYnV0ZVBhcnQsIENoaWxkUGFydCwgRGlzY29ubmVjdGFibGUsIFBhcnR9IGZyb20gJy4vbGl0LWh0bWwuanMnO1xuaW1wb3J0IHtpc1NpbmdsZUV4cHJlc3Npb259IGZyb20gJy4vZGlyZWN0aXZlLWhlbHBlcnMuanMnO1xuaW1wb3J0IHtEaXJlY3RpdmUsIFBhcnRJbmZvLCBQYXJ0VHlwZX0gZnJvbSAnLi9kaXJlY3RpdmUuanMnO1xuZXhwb3J0IHtkaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlLmpzJztcblxuY29uc3QgREVWX01PREUgPSB0cnVlO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHdhbGtzIGRvd24gdGhlIHRyZWUgb2YgUGFydHMvVGVtcGxhdGVJbnN0YW5jZXMvRGlyZWN0aXZlcyB0byBzZXRcbiAqIHRoZSBjb25uZWN0ZWQgc3RhdGUgb2YgZGlyZWN0aXZlcyBhbmQgcnVuIGBkaXNjb25uZWN0ZWRgLyBgcmVjb25uZWN0ZWRgXG4gKiBjYWxsYmFja3MuXG4gKlxuICogQHJldHVybiBUcnVlIGlmIHRoZXJlIHdlcmUgY2hpbGRyZW4gdG8gZGlzY29ubmVjdDsgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IG5vdGlmeUNoaWxkcmVuQ29ubmVjdGVkQ2hhbmdlZCA9IChcbiAgcGFyZW50OiBEaXNjb25uZWN0YWJsZSxcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW5cbik6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5fJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qgb2JqIG9mIGNoaWxkcmVuKSB7XG4gICAgLy8gVGhlIGV4aXN0ZW5jZSBvZiBgXyRub3RpZnlEaXJlY3RpdmVDb25uZWN0aW9uQ2hhbmdlZGAgaXMgdXNlZCBhcyBhIFwiYnJhbmRcIiB0b1xuICAgIC8vIGRpc2FtYmlndWF0ZSBBc3luY0RpcmVjdGl2ZXMgZnJvbSBvdGhlciBEaXNjb25uZWN0YWJsZUNoaWxkcmVuXG4gICAgLy8gKGFzIG9wcG9zZWQgdG8gdXNpbmcgYW4gaW5zdGFuY2VvZiBjaGVjayB0byBrbm93IHdoZW4gdG8gY2FsbCBpdCk7IHRoZVxuICAgIC8vIHJlZHVuZGFuY3kgb2YgXCJEaXJlY3RpdmVcIiBpbiB0aGUgQVBJIG5hbWUgaXMgdG8gYXZvaWQgY29uZmxpY3Rpbmcgd2l0aFxuICAgIC8vIGBfJG5vdGlmeUNvbm5lY3Rpb25DaGFuZ2VkYCwgd2hpY2ggZXhpc3RzIGBDaGlsZFBhcnRzYCB3aGljaCBhcmUgYWxzbyBpblxuICAgIC8vIHRoaXMgbGlzdFxuICAgIC8vIERpc2Nvbm5lY3QgRGlyZWN0aXZlIChhbmQgYW55IG5lc3RlZCBkaXJlY3RpdmVzIGNvbnRhaW5lZCB3aXRoaW4pXG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgICAob2JqIGFzIEFzeW5jRGlyZWN0aXZlKVsnXyRub3RpZnlEaXJlY3RpdmVDb25uZWN0aW9uQ2hhbmdlZCddPy4oXG4gICAgICBpc0Nvbm5lY3RlZCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICAvLyBEaXNjb25uZWN0IFBhcnQvVGVtcGxhdGVJbnN0YW5jZVxuICAgIG5vdGlmeUNoaWxkcmVuQ29ubmVjdGVkQ2hhbmdlZChvYmosIGlzQ29ubmVjdGVkKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gY2hpbGQgZnJvbSBpdHMgcGFyZW50IGxpc3Qgb2YgZGlzY29ubmVjdGFibGUgY2hpbGRyZW4sIGFuZFxuICogaWYgdGhlIHBhcmVudCBsaXN0IGJlY29tZXMgZW1wdHkgYXMgYSByZXN1bHQsIHJlbW92ZXMgdGhlIHBhcmVudCBmcm9tIGl0c1xuICogcGFyZW50LCBhbmQgc28gZm9ydGggdXAgdGhlIHRyZWUgd2hlbiB0aGF0IGNhdXNlcyBzdWJzZXF1ZW50IHBhcmVudCBsaXN0cyB0b1xuICogYmVjb21lIGVtcHR5LlxuICovXG5jb25zdCByZW1vdmVEaXNjb25uZWN0YWJsZUZyb21QYXJlbnQgPSAob2JqOiBEaXNjb25uZWN0YWJsZSkgPT4ge1xuICBsZXQgcGFyZW50LCBjaGlsZHJlbjtcbiAgZG8ge1xuICAgIGlmICgocGFyZW50ID0gb2JqLl8kcGFyZW50KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2hpbGRyZW4gPSBwYXJlbnQuXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuITtcbiAgICBjaGlsZHJlbi5kZWxldGUob2JqKTtcbiAgICBvYmogPSBwYXJlbnQ7XG4gIH0gd2hpbGUgKGNoaWxkcmVuPy5zaXplID09PSAwKTtcbn07XG5cbmNvbnN0IGFkZERpc2Nvbm5lY3RhYmxlVG9QYXJlbnQgPSAob2JqOiBEaXNjb25uZWN0YWJsZSkgPT4ge1xuICAvLyBDbGltYiB0aGUgcGFyZW50IHRyZWUsIGNyZWF0aW5nIGEgc3BhcnNlIHRyZWUgb2YgY2hpbGRyZW4gbmVlZGluZ1xuICAvLyBkaXNjb25uZWN0aW9uXG4gIGZvciAobGV0IHBhcmVudDsgKHBhcmVudCA9IG9iai5fJHBhcmVudCk7IG9iaiA9IHBhcmVudCkge1xuICAgIGxldCBjaGlsZHJlbiA9IHBhcmVudC5fJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmVudC5fJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuLmhhcyhvYmopKSB7XG4gICAgICAvLyBPbmNlIHdlJ3ZlIHJlYWNoZWQgYSBwYXJlbnQgdGhhdCBhbHJlYWR5IGNvbnRhaW5zIHRoaXMgY2hpbGQsIHdlXG4gICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNoaWxkcmVuLmFkZChvYmopO1xuICAgIGluc3RhbGxEaXNjb25uZWN0QVBJKHBhcmVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgcGFyZW50IHJlZmVyZW5jZSBvZiB0aGUgQ2hpbGRQYXJ0LCBhbmQgdXBkYXRlcyB0aGUgc3BhcnNlIHRyZWUgb2ZcbiAqIERpc2Nvbm5lY3RhYmxlIGNoaWxkcmVuIGFjY29yZGluZ2x5LlxuICpcbiAqIE5vdGUsIHRoaXMgbWV0aG9kIHdpbGwgYmUgcGF0Y2hlZCBvbnRvIENoaWxkUGFydCBpbnN0YW5jZXMgYW5kIGNhbGxlZCBmcm9tXG4gKiB0aGUgY29yZSBjb2RlIHdoZW4gcGFydHMgYXJlIG1vdmVkIGJldHdlZW4gZGlmZmVyZW50IHBhcmVudHMuXG4gKi9cbmZ1bmN0aW9uIHJlcGFyZW50RGlzY29ubmVjdGFibGVzKHRoaXM6IENoaWxkUGFydCwgbmV3UGFyZW50OiBEaXNjb25uZWN0YWJsZSkge1xuICBpZiAodGhpcy5fJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHJlbW92ZURpc2Nvbm5lY3RhYmxlRnJvbVBhcmVudCh0aGlzKTtcbiAgICB0aGlzLl8kcGFyZW50ID0gbmV3UGFyZW50O1xuICAgIGFkZERpc2Nvbm5lY3RhYmxlVG9QYXJlbnQodGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fJHBhcmVudCA9IG5ld1BhcmVudDtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3RlZCBzdGF0ZSBvbiBhbnkgZGlyZWN0aXZlcyBjb250YWluZWQgd2l0aGluIHRoZSBjb21taXR0ZWRcbiAqIHZhbHVlIG9mIHRoaXMgcGFydCAoaS5lLiB3aXRoaW4gYSBUZW1wbGF0ZUluc3RhbmNlIG9yIGl0ZXJhYmxlIG9mXG4gKiBDaGlsZFBhcnRzKSBhbmQgcnVucyB0aGVpciBgZGlzY29ubmVjdGVkYC9gcmVjb25uZWN0ZWRgcywgYXMgd2VsbCBhcyB3aXRoaW5cbiAqIGFueSBkaXJlY3RpdmVzIHN0b3JlZCBvbiB0aGUgQ2hpbGRQYXJ0ICh3aGVuIGB2YWx1ZU9ubHlgIGlzIGZhbHNlKS5cbiAqXG4gKiBgaXNDbGVhcmluZ1ZhbHVlYCBzaG91bGQgYmUgcGFzc2VkIGFzIGB0cnVlYCBvbiBhIHRvcC1sZXZlbCBwYXJ0IHRoYXQgaXNcbiAqIGNsZWFyaW5nIGl0c2VsZiwgYW5kIG5vdCBhcyBhIHJlc3VsdCBvZiByZWN1cnNpdmVseSBkaXNjb25uZWN0aW5nIGRpcmVjdGl2ZXNcbiAqIGFzIHBhcnQgb2YgYSBgY2xlYXJgIG9wZXJhdGlvbiBoaWdoZXIgdXAgdGhlIHRyZWUuIFRoaXMgYm90aCBlbnN1cmVzIHRoYXQgYW55XG4gKiBkaXJlY3RpdmUgb24gdGhpcyBDaGlsZFBhcnQgdGhhdCBwcm9kdWNlZCBhIHZhbHVlIHRoYXQgY2F1c2VkIHRoZSBjbGVhclxuICogb3BlcmF0aW9uIGlzIG5vdCBkaXNjb25uZWN0ZWQsIGFuZCBhbHNvIHNlcnZlcyBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxuICogdG8gYXZvaWQgbmVlZGxlc3MgYm9va2tlZXBpbmcgd2hlbiBhIHN1YnRyZWUgaXMgZ29pbmcgYXdheTsgd2hlbiBjbGVhcmluZyBhXG4gKiBzdWJ0cmVlLCBvbmx5IHRoZSB0b3AtbW9zdCBwYXJ0IG5lZWQgdG8gcmVtb3ZlIGl0c2VsZiBmcm9tIHRoZSBwYXJlbnQuXG4gKlxuICogYGZyb21QYXJ0SW5kZXhgIGlzIHBhc3NlZCBvbmx5IGluIHRoZSBjYXNlIG9mIGEgcGFydGlhbCBgX2NsZWFyYCBydW5uaW5nIGFzIGFcbiAqIHJlc3VsdCBvZiB0cnVuY2F0aW5nIGFuIGl0ZXJhYmxlLlxuICpcbiAqIE5vdGUsIHRoaXMgbWV0aG9kIHdpbGwgYmUgcGF0Y2hlZCBvbnRvIENoaWxkUGFydCBpbnN0YW5jZXMgYW5kIGNhbGxlZCBmcm9tIHRoZVxuICogY29yZSBjb2RlIHdoZW4gcGFydHMgYXJlIGNsZWFyZWQgb3IgdGhlIGNvbm5lY3Rpb24gc3RhdGUgaXMgY2hhbmdlZCBieSB0aGVcbiAqIHVzZXIuXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeUNoaWxkUGFydENvbm5lY3RlZENoYW5nZWQoXG4gIHRoaXM6IENoaWxkUGFydCxcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW4sXG4gIGlzQ2xlYXJpbmdWYWx1ZSA9IGZhbHNlLFxuICBmcm9tUGFydEluZGV4ID0gMFxuKSB7XG4gIGNvbnN0IHZhbHVlID0gdGhpcy5fJGNvbW1pdHRlZFZhbHVlO1xuICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuXyRkaXNjb25uZWN0YWJsZUNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBjaGlsZHJlbi5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0NsZWFyaW5nVmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIEl0ZXJhYmxlIGNhc2U6IEFueSBDaGlsZFBhcnRzIGNyZWF0ZWQgYnkgdGhlIGl0ZXJhYmxlIHNob3VsZCBiZVxuICAgICAgLy8gZGlzY29ubmVjdGVkIGFuZCByZW1vdmVkIGZyb20gdGhpcyBDaGlsZFBhcnQncyBkaXNjb25uZWN0YWJsZVxuICAgICAgLy8gY2hpbGRyZW4gKHN0YXJ0aW5nIGF0IGBmcm9tUGFydEluZGV4YCBpbiB0aGUgY2FzZSBvZiB0cnVuY2F0aW9uKVxuICAgICAgZm9yIChsZXQgaSA9IGZyb21QYXJ0SW5kZXg7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBub3RpZnlDaGlsZHJlbkNvbm5lY3RlZENoYW5nZWQodmFsdWVbaV0sIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlRGlzY29ubmVjdGFibGVGcm9tUGFyZW50KHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIFRlbXBsYXRlSW5zdGFuY2UgY2FzZTogSWYgdGhlIHZhbHVlIGhhcyBkaXNjb25uZWN0YWJsZSBjaGlsZHJlbiAod2lsbFxuICAgICAgLy8gb25seSBiZSBpbiB0aGUgY2FzZSB0aGF0IGl0IGlzIGEgVGVtcGxhdGVJbnN0YW5jZSksIHdlIGRpc2Nvbm5lY3QgaXRcbiAgICAgIC8vIGFuZCByZW1vdmUgaXQgZnJvbSB0aGlzIENoaWxkUGFydCdzIGRpc2Nvbm5lY3RhYmxlIGNoaWxkcmVuXG4gICAgICBub3RpZnlDaGlsZHJlbkNvbm5lY3RlZENoYW5nZWQodmFsdWUgYXMgRGlzY29ubmVjdGFibGUsIGZhbHNlKTtcbiAgICAgIHJlbW92ZURpc2Nvbm5lY3RhYmxlRnJvbVBhcmVudCh2YWx1ZSBhcyBEaXNjb25uZWN0YWJsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vdGlmeUNoaWxkcmVuQ29ubmVjdGVkQ2hhbmdlZCh0aGlzLCBpc0Nvbm5lY3RlZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXRjaGVzIGRpc2Nvbm5lY3Rpb24gQVBJIG9udG8gQ2hpbGRQYXJ0cy5cbiAqL1xuY29uc3QgaW5zdGFsbERpc2Nvbm5lY3RBUEkgPSAob2JqOiBEaXNjb25uZWN0YWJsZSkgPT4ge1xuICBpZiAoKG9iaiBhcyBDaGlsZFBhcnQpLnR5cGUgPT0gUGFydFR5cGUuQ0hJTEQpIHtcbiAgICAob2JqIGFzIENoaWxkUGFydCkuXyRub3RpZnlDb25uZWN0aW9uQ2hhbmdlZCA/Pz1cbiAgICAgIG5vdGlmeUNoaWxkUGFydENvbm5lY3RlZENoYW5nZWQ7XG4gICAgKG9iaiBhcyBDaGlsZFBhcnQpLl8kcmVwYXJlbnREaXNjb25uZWN0YWJsZXMgPz89IHJlcGFyZW50RGlzY29ubmVjdGFibGVzO1xuICB9XG59O1xuXG4vKipcbiAqIEFuIGFic3RyYWN0IGBEaXJlY3RpdmVgIGJhc2UgY2xhc3Mgd2hvc2UgYGRpc2Nvbm5lY3RlZGAgbWV0aG9kIHdpbGwgYmVcbiAqIGNhbGxlZCB3aGVuIHRoZSBwYXJ0IGNvbnRhaW5pbmcgdGhlIGRpcmVjdGl2ZSBpcyBjbGVhcmVkIGFzIGEgcmVzdWx0IG9mXG4gKiByZS1yZW5kZXJpbmcsIG9yIHdoZW4gdGhlIHVzZXIgY2FsbHMgYHBhcnQuc2V0Q29ubmVjdGVkKGZhbHNlKWAgb25cbiAqIGEgcGFydCB0aGF0IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGNvbnRhaW5pbmcgdGhlIGRpcmVjdGl2ZSAoYXMgaGFwcGVuc1xuICogd2hlbiBlLmcuIGEgTGl0RWxlbWVudCBkaXNjb25uZWN0cyBmcm9tIHRoZSBET00pLlxuICpcbiAqIElmIGBwYXJ0LnNldENvbm5lY3RlZCh0cnVlKWAgaXMgc3Vic2VxdWVudGx5IGNhbGxlZCBvbiBhXG4gKiBjb250YWluaW5nIHBhcnQsIHRoZSBkaXJlY3RpdmUncyBgcmVjb25uZWN0ZWRgIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBwcmlvclxuICogdG8gaXRzIG5leHQgYHVwZGF0ZWAvYHJlbmRlcmAgY2FsbGJhY2tzLiBXaGVuIGltcGxlbWVudGluZyBgZGlzY29ubmVjdGVkYCxcbiAqIGByZWNvbm5lY3RlZGAgc2hvdWxkIGFsc28gYmUgaW1wbGVtZW50ZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgdXBkYXRlcyBtYXkgb2NjdXIgd2hpbGUgdGhlIGRpcmVjdGl2ZSBpcyBkaXNjb25uZWN0ZWQuIEFzIHN1Y2gsXG4gKiBkaXJlY3RpdmVzIHNob3VsZCBnZW5lcmFsbHkgY2hlY2sgdGhlIGB0aGlzLmlzQ29ubmVjdGVkYCBmbGFnIGR1cmluZ1xuICogcmVuZGVyL3VwZGF0ZSB0byBkZXRlcm1pbmUgd2hldGhlciBpdCBpcyBzYWZlIHRvIHN1YnNjcmliZSB0byByZXNvdXJjZXNcbiAqIHRoYXQgbWF5IHByZXZlbnQgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXN5bmNEaXJlY3RpdmUgZXh0ZW5kcyBEaXJlY3RpdmUge1xuICAvLyBBcyBvcHBvc2VkIHRvIG90aGVyIERpc2Nvbm5lY3RhYmxlcywgQXN5bmNEaXJlY3RpdmVzIGFsd2F5cyBnZXQgbm90aWZpZWRcbiAgLy8gd2hlbiB0aGUgUm9vdFBhcnQgY29ubmVjdGlvbiBjaGFuZ2VzLCBzbyB0aGUgcHVibGljIGBpc0Nvbm5lY3RlZGBcbiAgLy8gaXMgYSBsb2NhbGx5IHN0b3JlZCB2YXJpYWJsZSBpbml0aWFsaXplZCB2aWEgaXRzIHBhcnQncyBnZXR0ZXIgYW5kIHN5bmNlZFxuICAvLyB2aWEgYF8kbm90aWZ5RGlyZWN0aXZlQ29ubmVjdGlvbkNoYW5nZWRgLiBUaGlzIGlzIGNoZWFwZXIgdGhhbiB1c2luZ1xuICAvLyB0aGUgXyRpc0Nvbm5lY3RlZCBnZXR0ZXIsIHdoaWNoIGhhcyB0byBsb29rIGJhY2sgdXAgdGhlIHRyZWUgZWFjaCB0aW1lLlxuICAvKipcbiAgICogVGhlIGNvbm5lY3Rpb24gc3RhdGUgZm9yIHRoaXMgRGlyZWN0aXZlLlxuICAgKi9cbiAgaXNDb25uZWN0ZWQhOiBib29sZWFuO1xuXG4gIC8vIEBpbnRlcm5hbFxuICBvdmVycmlkZSBfJGRpc2Nvbm5lY3RhYmxlQ2hpbGRyZW4/OiBTZXQ8RGlzY29ubmVjdGFibGU+ID0gdW5kZWZpbmVkO1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgcGFydCB3aXRoIGludGVybmFsIGZpZWxkc1xuICAgKiBAcGFyYW0gcGFydFxuICAgKiBAcGFyYW0gcGFyZW50XG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVJbmRleFxuICAgKi9cbiAgb3ZlcnJpZGUgXyRpbml0aWFsaXplKFxuICAgIHBhcnQ6IFBhcnQsXG4gICAgcGFyZW50OiBEaXNjb25uZWN0YWJsZSxcbiAgICBhdHRyaWJ1dGVJbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyLl8kaW5pdGlhbGl6ZShwYXJ0LCBwYXJlbnQsIGF0dHJpYnV0ZUluZGV4KTtcbiAgICBhZGREaXNjb25uZWN0YWJsZVRvUGFyZW50KHRoaXMpO1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBwYXJ0Ll8kaXNDb25uZWN0ZWQ7XG4gIH1cbiAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgLyoqXG4gICAqIENhbGxlZCBmcm9tIHRoZSBjb3JlIGNvZGUgd2hlbiBhIGRpcmVjdGl2ZSBpcyBnb2luZyBhd2F5IGZyb20gYSBwYXJ0IChpblxuICAgKiB3aGljaCBjYXNlIGBzaG91bGRSZW1vdmVGcm9tUGFyZW50YCBzaG91bGQgYmUgdHJ1ZSksIGFuZCBmcm9tIHRoZVxuICAgKiBgc2V0Q2hpbGRyZW5Db25uZWN0ZWRgIGhlbHBlciBmdW5jdGlvbiB3aGVuIHJlY3Vyc2l2ZWx5IGNoYW5naW5nIHRoZVxuICAgKiBjb25uZWN0aW9uIHN0YXRlIG9mIGEgdHJlZSAoaW4gd2hpY2ggY2FzZSBgc2hvdWxkUmVtb3ZlRnJvbVBhcmVudGAgc2hvdWxkXG4gICAqIGJlIGZhbHNlKS5cbiAgICpcbiAgICogQHBhcmFtIGlzQ29ubmVjdGVkXG4gICAqIEBwYXJhbSBpc0NsZWFyaW5nRGlyZWN0aXZlIC0gVHJ1ZSB3aGVuIHRoZSBkaXJlY3RpdmUgaXRzZWxmIGlzIGJlaW5nXG4gICAqICAgICByZW1vdmVkOyBmYWxzZSB3aGVuIHRoZSB0cmVlIGlzIGJlaW5nIGRpc2Nvbm5lY3RlZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG92ZXJyaWRlIFsnXyRub3RpZnlEaXJlY3RpdmVDb25uZWN0aW9uQ2hhbmdlZCddKFxuICAgIGlzQ29ubmVjdGVkOiBib29sZWFuLFxuICAgIGlzQ2xlYXJpbmdEaXJlY3RpdmUgPSB0cnVlXG4gICkge1xuICAgIGlmIChpc0Nvbm5lY3RlZCAhPT0gdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGlzQ29ubmVjdGVkO1xuICAgICAgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0ZWQ/LigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0ZWQ/LigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDbGVhcmluZ0RpcmVjdGl2ZSkge1xuICAgICAgbm90aWZ5Q2hpbGRyZW5Db25uZWN0ZWRDaGFuZ2VkKHRoaXMsIGlzQ29ubmVjdGVkKTtcbiAgICAgIHJlbW92ZURpc2Nvbm5lY3RhYmxlRnJvbVBhcmVudCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGRpcmVjdGl2ZSdzIFBhcnQgb3V0c2lkZSB0aGUgbm9ybWFsIGB1cGRhdGVgL2ByZW5kZXJgXG4gICAqIGxpZmVjeWNsZSBvZiBhIGRpcmVjdGl2ZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIGEgZGlyZWN0aXZlJ3MgYHVwZGF0ZWBcbiAgICogb3IgYHJlbmRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSBkaXJlY3RpdmUgVGhlIGRpcmVjdGl2ZSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXRcbiAgICovXG4gIHNldFZhbHVlKHZhbHVlOiB1bmtub3duKSB7XG4gICAgaWYgKGlzU2luZ2xlRXhwcmVzc2lvbih0aGlzLl9fcGFydCBhcyB1bmtub3duIGFzIFBhcnRJbmZvKSkge1xuICAgICAgdGhpcy5fX3BhcnQuXyRzZXRWYWx1ZSh2YWx1ZSwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMuX19hdHRyaWJ1dGVJbmRleCB3aWxsIGJlIGRlZmluZWQgaW4gdGhpcyBjYXNlLCBidXRcbiAgICAgIC8vIGFzc2VydCBpdCBpbiBkZXYgbW9kZVxuICAgICAgaWYgKERFVl9NT0RFICYmIHRoaXMuX19hdHRyaWJ1dGVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdGhpcy5fX2F0dHJpYnV0ZUluZGV4IHRvIGJlIGEgbnVtYmVyYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdWYWx1ZXMgPSBbLi4uKHRoaXMuX19wYXJ0Ll8kY29tbWl0dGVkVmFsdWUgYXMgQXJyYXk8dW5rbm93bj4pXTtcbiAgICAgIG5ld1ZhbHVlc1t0aGlzLl9fYXR0cmlidXRlSW5kZXghXSA9IHZhbHVlO1xuICAgICAgKHRoaXMuX19wYXJ0IGFzIEF0dHJpYnV0ZVBhcnQpLl8kc2V0VmFsdWUobmV3VmFsdWVzLCB0aGlzLCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlciBjYWxsYmFja3MgZm9yIGltcGxlbWVudGluZyBsb2dpYyB0byByZWxlYXNlIGFueSByZXNvdXJjZXMvc3Vic2NyaXB0aW9uc1xuICAgKiB0aGF0IG1heSBoYXZlIGJlZW4gcmV0YWluZWQgYnkgdGhpcyBkaXJlY3RpdmUuIFNpbmNlIGRpcmVjdGl2ZXMgbWF5IGFsc28gYmVcbiAgICogcmUtY29ubmVjdGVkLCBgcmVjb25uZWN0ZWRgIHNob3VsZCBhbHNvIGJlIGltcGxlbWVudGVkIHRvIHJlc3RvcmUgdGhlXG4gICAqIHdvcmtpbmcgc3RhdGUgb2YgdGhlIGRpcmVjdGl2ZSBwcmlvciB0byB0aGUgbmV4dCByZW5kZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgZGlzY29ubmVjdGVkKCkge31cbiAgcHJvdGVjdGVkIHJlY29ubmVjdGVkKCkge31cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-html/development/async-directive.js\n");

/***/ }),

/***/ "./node_modules/lit-html/development/directives/guard.js":
/*!***************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/guard.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"guard\": () => (/* binding */ guard)\n/* harmony export */ });\n/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ \"./node_modules/lit-html/development/lit-html.js\");\n/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../directive.js */ \"./node_modules/lit-html/development/directive.js\");\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n // A sentinal that indicates guard() hasn't rendered anything yet\n\nconst initialValue = {};\n\nclass GuardDirective extends _directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {\n  constructor() {\n    super(...arguments);\n    this._previousValue = initialValue;\n  }\n\n  render(_value, f) {\n    return f();\n  }\n\n  update(_part, [value, f]) {\n    if (Array.isArray(value)) {\n      // Dirty-check arrays by item\n      if (Array.isArray(this._previousValue) && this._previousValue.length === value.length && value.every((v, i) => v === this._previousValue[i])) {\n        return _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.noChange;\n      }\n    } else if (this._previousValue === value) {\n      // Dirty-check non-arrays by identity\n      return _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.noChange;\n    } // Copy the value if it's an array so that if it's mutated we don't forget\n    // what the previous values were.\n\n\n    this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n    const r = this.render(value, f);\n    return r;\n  }\n\n}\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Values are checked against previous values with strict equality (`===`), and\n * so the check won't detect nested property changes inside objects or arrays.\n * Arrays values have each item checked against the previous value at the same\n * index with strict equality. Nested arrays are also checked only by strict\n * equality.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * `\n * ```\n *\n * In this case, the template only rerenders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * `\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\n\n\nconst guard = (0,_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(GuardDirective);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGV2ZWxvcG1lbnQvZGlyZWN0aXZlcy9ndWFyZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7QUFNQTtBQUNBOztBQUdBOztBQUVBO0FBQUE7O0FBQ0E7QUEyQkE7O0FBekJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQkE7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uLy4uL3NyYy9kaXJlY3RpdmVzL2d1YXJkLnRzPzU1MGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7bm9DaGFuZ2UsIFBhcnR9IGZyb20gJy4uL2xpdC1odG1sLmpzJztcbmltcG9ydCB7ZGlyZWN0aXZlLCBEaXJlY3RpdmUsIERpcmVjdGl2ZVBhcmFtZXRlcnN9IGZyb20gJy4uL2RpcmVjdGl2ZS5qcyc7XG5cbi8vIEEgc2VudGluYWwgdGhhdCBpbmRpY2F0ZXMgZ3VhcmQoKSBoYXNuJ3QgcmVuZGVyZWQgYW55dGhpbmcgeWV0XG5jb25zdCBpbml0aWFsVmFsdWUgPSB7fTtcblxuY2xhc3MgR3VhcmREaXJlY3RpdmUgZXh0ZW5kcyBEaXJlY3RpdmUge1xuICBwcml2YXRlIF9wcmV2aW91c1ZhbHVlOiB1bmtub3duID0gaW5pdGlhbFZhbHVlO1xuXG4gIHJlbmRlcihfdmFsdWU6IHVua25vd24sIGY6ICgpID0+IHVua25vd24pIHtcbiAgICByZXR1cm4gZigpO1xuICB9XG5cbiAgb3ZlcnJpZGUgdXBkYXRlKF9wYXJ0OiBQYXJ0LCBbdmFsdWUsIGZdOiBEaXJlY3RpdmVQYXJhbWV0ZXJzPHRoaXM+KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBEaXJ0eS1jaGVjayBhcnJheXMgYnkgaXRlbVxuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuX3ByZXZpb3VzVmFsdWUpICYmXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUubGVuZ3RoID09PSB2YWx1ZS5sZW5ndGggJiZcbiAgICAgICAgdmFsdWUuZXZlcnkoKHYsIGkpID0+IHYgPT09ICh0aGlzLl9wcmV2aW91c1ZhbHVlIGFzIEFycmF5PHVua25vd24+KVtpXSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbm9DaGFuZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcmV2aW91c1ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgLy8gRGlydHktY2hlY2sgbm9uLWFycmF5cyBieSBpZGVudGl0eVxuICAgICAgcmV0dXJuIG5vQ2hhbmdlO1xuICAgIH1cblxuICAgIC8vIENvcHkgdGhlIHZhbHVlIGlmIGl0J3MgYW4gYXJyYXkgc28gdGhhdCBpZiBpdCdzIG11dGF0ZWQgd2UgZG9uJ3QgZm9yZ2V0XG4gICAgLy8gd2hhdCB0aGUgcHJldmlvdXMgdmFsdWVzIHdlcmUuXG4gICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gQXJyYXkuZnJvbSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICBjb25zdCByID0gdGhpcy5yZW5kZXIodmFsdWUsIGYpO1xuICAgIHJldHVybiByO1xuICB9XG59XG5cbi8qKlxuICogUHJldmVudHMgcmUtcmVuZGVyIG9mIGEgdGVtcGxhdGUgZnVuY3Rpb24gdW50aWwgYSBzaW5nbGUgdmFsdWUgb3IgYW4gYXJyYXkgb2ZcbiAqIHZhbHVlcyBjaGFuZ2VzLlxuICpcbiAqIFZhbHVlcyBhcmUgY2hlY2tlZCBhZ2FpbnN0IHByZXZpb3VzIHZhbHVlcyB3aXRoIHN0cmljdCBlcXVhbGl0eSAoYD09PWApLCBhbmRcbiAqIHNvIHRoZSBjaGVjayB3b24ndCBkZXRlY3QgbmVzdGVkIHByb3BlcnR5IGNoYW5nZXMgaW5zaWRlIG9iamVjdHMgb3IgYXJyYXlzLlxuICogQXJyYXlzIHZhbHVlcyBoYXZlIGVhY2ggaXRlbSBjaGVja2VkIGFnYWluc3QgdGhlIHByZXZpb3VzIHZhbHVlIGF0IHRoZSBzYW1lXG4gKiBpbmRleCB3aXRoIHN0cmljdCBlcXVhbGl0eS4gTmVzdGVkIGFycmF5cyBhcmUgYWxzbyBjaGVja2VkIG9ubHkgYnkgc3RyaWN0XG4gKiBlcXVhbGl0eS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBodG1sYFxuICogICA8ZGl2PlxuICogICAgICR7Z3VhcmQoW3VzZXIuaWQsIGNvbXBhbnkuaWRdLCAoKSA9PiBodG1sYC4uLmApfVxuICogICA8L2Rpdj5cbiAqIGBcbiAqIGBgYFxuICpcbiAqIEluIHRoaXMgY2FzZSwgdGhlIHRlbXBsYXRlIG9ubHkgcmVyZW5kZXJzIGlmIGVpdGhlciBgdXNlci5pZGAgb3IgYGNvbXBhbnkuaWRgXG4gKiBjaGFuZ2VzLlxuICpcbiAqIGd1YXJkKCkgaXMgdXNlZnVsIHdpdGggaW1tdXRhYmxlIGRhdGEgcGF0dGVybnMsIGJ5IHByZXZlbnRpbmcgZXhwZW5zaXZlIHdvcmtcbiAqIHVudGlsIGRhdGEgdXBkYXRlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBodG1sYFxuICogICA8ZGl2PlxuICogICAgICR7Z3VhcmQoW2ltbXV0YWJsZUl0ZW1zXSwgKCkgPT4gaW1tdXRhYmxlSXRlbXMubWFwKGkgPT4gaHRtbGAke2l9YCkpfVxuICogICA8L2Rpdj5cbiAqIGBcbiAqIGBgYFxuICpcbiAqIEluIHRoaXMgY2FzZSwgaXRlbXMgYXJlIG1hcHBlZCBvdmVyIG9ubHkgd2hlbiB0aGUgYXJyYXkgcmVmZXJlbmNlIGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjaGVjayBiZWZvcmUgcmUtcmVuZGVyaW5nXG4gKiBAcGFyYW0gZiB0aGUgdGVtcGxhdGUgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGd1YXJkID0gZGlyZWN0aXZlKEd1YXJkRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgY2xhc3MgdGhhdCBwb3dlcnMgdGhpcyBkaXJlY3RpdmUuIE5lY2Vzc2FyeSBmb3IgbmFtaW5nIHRoZVxuICogZGlyZWN0aXZlJ3MgcmV0dXJuIHR5cGUuXG4gKi9cbmV4cG9ydCB0eXBlIHtHdWFyZERpcmVjdGl2ZX07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-html/development/directives/guard.js\n");

/***/ }),

/***/ "./node_modules/lit-html/development/directives/private-async-helpers.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/private-async-helpers.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pauser\": () => (/* binding */ Pauser),\n/* harmony export */   \"PseudoWeakRef\": () => (/* binding */ PseudoWeakRef),\n/* harmony export */   \"forAwaitOf\": () => (/* binding */ forAwaitOf)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nconst forAwaitOf = async (iterable, callback) => {\n  for await (const v of iterable) {\n    if ((await callback(v)) === false) {\n      return;\n    }\n  }\n};\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\n\nclass PseudoWeakRef {\n  constructor(ref) {\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n\n\n  disconnect() {\n    this._ref = undefined;\n  }\n  /**\n   * Reassociates the ref with the backing instance.\n   */\n\n\n  reconnect(ref) {\n    this._ref = ref;\n  }\n  /**\n   * Retrieves the backing instance (will be undefined when disconnected)\n   */\n\n\n  deref() {\n    return this._ref;\n  }\n\n}\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\n\nclass Pauser {\n  constructor() {\n    this._promise = undefined;\n    this._resolve = undefined;\n  }\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n\n\n  get() {\n    return this._promise;\n  }\n  /**\n   * Creates a promise to be awaited\n   */\n\n\n  pause() {\n    var _a;\n\n    (_a = this._promise) !== null && _a !== void 0 ? _a : this._promise = new Promise(resolve => this._resolve = resolve);\n  }\n  /**\n   * Resolves the promise which may be awaited\n   */\n\n\n  resume() {\n    var _a;\n\n    (_a = this._resolve) === null || _a === void 0 ? void 0 : _a.call(this);\n    this._promise = this._resolve = undefined;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGV2ZWxvcG1lbnQvZGlyZWN0aXZlcy9wcml2YXRlLWFzeW5jLWhlbHBlcnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7O0FBdEJBO0FBeUJBOzs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUF3QkE7QUF2QkE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBR0E7OztBQUNBO0FBQ0E7QUFDQTs7QUF6QkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uLy4uL3NyYy9kaXJlY3RpdmVzL3ByaXZhdGUtYXN5bmMtaGVscGVycy50cz8wNmNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBOb3RlLCB0aGlzIG1vZHVsZSBpcyBub3QgaW5jbHVkZWQgaW4gcGFja2FnZSBleHBvcnRzIHNvIHRoYXQgaXQncyBwcml2YXRlIHRvXG4vLyBvdXIgZmlyc3QtcGFydHkgZGlyZWN0aXZlcy4gSWYgaXQgZW5kcyB1cCBiZWluZyB1c2VmdWwsIHdlIGNhbiBvcGVuIGl0IHVwIGFuZFxuLy8gZXhwb3J0IGl0LlxuXG4vKipcbiAqIEhlbHBlciB0byBpdGVyYXRlIGFuIEFzeW5jSXRlcmFibGUgaW4gaXRzIG93biBjbG9zdXJlLlxuICogQHBhcmFtIGl0ZXJhYmxlIFRoZSBpdGVyYWJsZSB0byBpdGVyYXRlXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggdmFsdWUuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gKiBgZmFsc2VgLCB0aGUgbG9vcCB3aWxsIGJlIGJyb2tlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckF3YWl0T2YgPSBhc3luYyA8VD4oXG4gIGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFQ+LFxuICBjYWxsYmFjazogKHZhbHVlOiBUKSA9PiBQcm9taXNlPGJvb2xlYW4+XG4pID0+IHtcbiAgZm9yIGF3YWl0IChjb25zdCB2IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKChhd2FpdCBjYWxsYmFjayh2KSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIGFuIGluc3RhbmNlIHRoYXQgY2FuIGJlIGRpc2Nvbm5lY3RlZCBhbmQgcmVjb25uZWN0ZWQsXG4gKiBzbyB0aGF0IGEgY2xvc3VyZSBvdmVyIHRoZSByZWYgKGUuZy4gaW4gYSB0aGVuIGZ1bmN0aW9uIHRvIGEgcHJvbWlzZSkgZG9lc1xuICogbm90IHN0cm9uZ2x5IGhvbGQgYSByZWYgdG8gdGhlIGluc3RhbmNlLiBBcHByb3hpbWF0ZXMgYSBXZWFrUmVmIGJ1dCBtdXN0XG4gKiBiZSBtYW51YWxseSBjb25uZWN0ZWQgJiBkaXNjb25uZWN0ZWQgdG8gdGhlIGJhY2tpbmcgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBQc2V1ZG9XZWFrUmVmPFQ+IHtcbiAgcHJpdmF0ZSBfcmVmPzogVDtcbiAgY29uc3RydWN0b3IocmVmOiBUKSB7XG4gICAgdGhpcy5fcmVmID0gcmVmO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhc3NvY2lhdGVzIHRoZSByZWYgd2l0aCB0aGUgYmFja2luZyBpbnN0YW5jZS5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fcmVmID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBSZWFzc29jaWF0ZXMgdGhlIHJlZiB3aXRoIHRoZSBiYWNraW5nIGluc3RhbmNlLlxuICAgKi9cbiAgcmVjb25uZWN0KHJlZjogVCkge1xuICAgIHRoaXMuX3JlZiA9IHJlZjtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBiYWNraW5nIGluc3RhbmNlICh3aWxsIGJlIHVuZGVmaW5lZCB3aGVuIGRpc2Nvbm5lY3RlZClcbiAgICovXG4gIGRlcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWY7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGhlbHBlciB0byBwYXVzZSBhbmQgcmVzdW1lIHdhaXRpbmcgb24gYSBjb25kaXRpb24gaW4gYW4gYXN5bmMgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFBhdXNlciB7XG4gIHByaXZhdGUgX3Byb21pc2U/OiBQcm9taXNlPHZvaWQ+ID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIF9yZXNvbHZlPzogKCkgPT4gdm9pZCA9IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIFdoZW4gcGF1c2VkLCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSBhd2FpdGVkOyB3aGVuIHVucGF1c2VkLCByZXR1cm5zXG4gICAqIHVuZGVmaW5lZC4gTm90ZSB0aGF0IGluIHRoZSBtaWNyb3Rhc2sgYmV0d2VlbiB0aGUgcGF1c2VyIGJlaW5nIHJlc3VtZWRcbiAgICogYW4gYW4gYXdhaXQgb2YgdGhpcyBwcm9taXNlIHJlc29sdmluZywgdGhlIHBhdXNlciBjb3VsZCBiZSBwYXVzZWQgYWdhaW4sXG4gICAqIGhlbmNlIGNhbGxlcnMgc2hvdWxkIGNoZWNrIHRoZSBwcm9taXNlIGluIGEgbG9vcCB3aGVuIGF3YWl0aW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdG8gYmUgYXdhaXRlZCB3aGVuIHBhdXNlZCBvciB1bmRlZmluZWRcbiAgICovXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHByb21pc2UgdG8gYmUgYXdhaXRlZFxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fcHJvbWlzZSA/Pz0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+ICh0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgcHJvbWlzZSB3aGljaCBtYXkgYmUgYXdhaXRlZFxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIHRoaXMuX3Jlc29sdmU/LigpO1xuICAgIHRoaXMuX3Byb21pc2UgPSB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-html/development/directives/private-async-helpers.js\n");

/***/ }),

/***/ "./node_modules/lit-html/development/directives/until.js":
/*!***************************************************************!*\
  !*** ./node_modules/lit-html/development/directives/until.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UntilDirective\": () => (/* binding */ UntilDirective),\n/* harmony export */   \"until\": () => (/* binding */ until)\n/* harmony export */ });\n/* harmony import */ var _lit_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lit-html.js */ \"./node_modules/lit-html/development/lit-html.js\");\n/* harmony import */ var _directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../directive.js */ \"./node_modules/lit-html/development/directive.js\");\n/* harmony import */ var _directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../directive-helpers.js */ \"./node_modules/lit-html/development/directive-helpers.js\");\n/* harmony import */ var _async_directive_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../async-directive.js */ \"./node_modules/lit-html/development/async-directive.js\");\n/* harmony import */ var _private_async_helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./private-async-helpers.js */ \"./node_modules/lit-html/development/directives/private-async-helpers.js\");\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n\n\n\nconst isPromise = x => {\n  return !(0,_directive_helpers_js__WEBPACK_IMPORTED_MODULE_2__.isPrimitive)(x) && typeof x.then === 'function';\n}; // Effectively infinity, but a SMI.\n\n\nconst _infinity = 0x3fffffff;\nclass UntilDirective extends _async_directive_js__WEBPACK_IMPORTED_MODULE_3__.AsyncDirective {\n  constructor() {\n    super(...arguments);\n    this.__lastRenderedIndex = _infinity;\n    this.__values = [];\n    this.__weakThis = new _private_async_helpers_js__WEBPACK_IMPORTED_MODULE_4__.PseudoWeakRef(this);\n    this.__pauser = new _private_async_helpers_js__WEBPACK_IMPORTED_MODULE_4__.Pauser();\n  }\n\n  render(...args) {\n    var _a;\n\n    return (_a = args.find(x => !isPromise(x))) !== null && _a !== void 0 ? _a : _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.noChange;\n  }\n\n  update(_part, args) {\n    const previousValues = this.__values;\n    let previousLength = previousValues.length;\n    this.__values = args;\n    const weakThis = this.__weakThis;\n    const pauser = this.__pauser; // If our initial render occurs while disconnected, ensure that the pauser\n    // and weakThis are in the disconnected state\n\n    if (!this.isConnected) {\n      this.disconnected();\n    }\n\n    for (let i = 0; i < args.length; i++) {\n      // If we've rendered a higher-priority value already, stop.\n      if (i > this.__lastRenderedIndex) {\n        break;\n      }\n\n      const value = args[i]; // Render non-Promise values immediately\n\n      if (!isPromise(value)) {\n        this.__lastRenderedIndex = i; // Since a lower-priority value will never overwrite a higher-priority\n        // synchronous value, we can stop processing now.\n\n        return value;\n      } // If this is a Promise we've already handled, skip it.\n\n\n      if (i < previousLength && value === previousValues[i]) {\n        continue;\n      } // We have a Promise that we haven't seen before, so priorities may have\n      // changed. Forget what we rendered before.\n\n\n      this.__lastRenderedIndex = _infinity;\n      previousLength = 0; // Note, the callback avoids closing over `this` so that the directive\n      // can be gc'ed before the promise resolves; instead `this` is retrieved\n      // from `weakThis`, which can break the hard reference in the closure when\n      // the directive disconnects\n\n      Promise.resolve(value).then(async result => {\n        // If we're disconnected, wait until we're (maybe) reconnected\n        // The while loop here handles the case that the connection state\n        // thrashes, causing the pauser to resume and then get re-paused\n        while (pauser.get()) {\n          await pauser.get();\n        } // If the callback gets here and there is no `this`, it means that the\n        // directive has been disconnected and garbage collected and we don't\n        // need to do anything else\n\n\n        const _this = weakThis.deref();\n\n        if (_this !== undefined) {\n          const index = _this.__values.indexOf(value); // If state.values doesn't contain the value, we've re-rendered without\n          // the value, so don't render it. Then, only render if the value is\n          // higher-priority than what's already been rendered.\n\n\n          if (index > -1 && index < _this.__lastRenderedIndex) {\n            _this.__lastRenderedIndex = index;\n\n            _this.setValue(result);\n          }\n        }\n      });\n    }\n\n    return _lit_html_js__WEBPACK_IMPORTED_MODULE_0__.noChange;\n  }\n\n  disconnected() {\n    this.__weakThis.disconnect();\n\n    this.__pauser.pause();\n  }\n\n  reconnected() {\n    this.__weakThis.reconnect(this);\n\n    this.__pauser.resume();\n  }\n\n}\n/**\n * Renders one of a series of values, including Promises, to a Part.\n *\n * Values are rendered in priority order, with the first argument having the\n * highest priority and the last argument having the lowest priority. If a\n * value is a Promise, low-priority values will be rendered until it resolves.\n *\n * The priority of values can be used to create placeholder content for async\n * data. For example, a Promise with pending content can be the first,\n * highest-priority, argument, and a non_promise loading indicator template can\n * be used as the second, lower-priority, argument. The loading indicator will\n * render immediately, and the primary content will render when the Promise\n * resolves.\n *\n * Example:\n *\n * ```js\n * const content = fetch('./content.txt').then(r => r.text());\n * html`${until(content, html`<span>Loading...</span>`)}`\n * ```\n */\n\nconst until = (0,_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(UntilDirective);\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\n// export type {UntilDirective};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGV2ZWxvcG1lbnQvZGlyZWN0aXZlcy91bnRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNGQTs7QUFwRkE7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBekZBO0FBNEZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBRUE7Ozs7QUFJQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vLi4vc3JjL2RpcmVjdGl2ZXMvdW50aWwudHM/MDAzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtQYXJ0LCBub0NoYW5nZX0gZnJvbSAnLi4vbGl0LWh0bWwuanMnO1xuaW1wb3J0IHtkaXJlY3RpdmV9IGZyb20gJy4uL2RpcmVjdGl2ZS5qcyc7XG5pbXBvcnQge2lzUHJpbWl0aXZlfSBmcm9tICcuLi9kaXJlY3RpdmUtaGVscGVycy5qcyc7XG5pbXBvcnQge0FzeW5jRGlyZWN0aXZlfSBmcm9tICcuLi9hc3luYy1kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHtQYXVzZXIsIFBzZXVkb1dlYWtSZWZ9IGZyb20gJy4vcHJpdmF0ZS1hc3luYy1oZWxwZXJzLmpzJztcblxuY29uc3QgaXNQcm9taXNlID0gKHg6IHVua25vd24pID0+IHtcbiAgcmV0dXJuICFpc1ByaW1pdGl2ZSh4KSAmJiB0eXBlb2YgKHggYXMge3RoZW4/OiB1bmtub3dufSkudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBFZmZlY3RpdmVseSBpbmZpbml0eSwgYnV0IGEgU01JLlxuY29uc3QgX2luZmluaXR5ID0gMHgzZmZmZmZmZjtcblxuZXhwb3J0IGNsYXNzIFVudGlsRGlyZWN0aXZlIGV4dGVuZHMgQXN5bmNEaXJlY3RpdmUge1xuICBwcml2YXRlIF9fbGFzdFJlbmRlcmVkSW5kZXg6IG51bWJlciA9IF9pbmZpbml0eTtcbiAgcHJpdmF0ZSBfX3ZhbHVlczogdW5rbm93bltdID0gW107XG4gIHByaXZhdGUgX193ZWFrVGhpcyA9IG5ldyBQc2V1ZG9XZWFrUmVmKHRoaXMpO1xuICBwcml2YXRlIF9fcGF1c2VyID0gbmV3IFBhdXNlcigpO1xuXG4gIHJlbmRlciguLi5hcmdzOiBBcnJheTx1bmtub3duPikge1xuICAgIHJldHVybiBhcmdzLmZpbmQoKHgpID0+ICFpc1Byb21pc2UoeCkpID8/IG5vQ2hhbmdlO1xuICB9XG5cbiAgb3ZlcnJpZGUgdXBkYXRlKF9wYXJ0OiBQYXJ0LCBhcmdzOiBBcnJheTx1bmtub3duPikge1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWVzID0gdGhpcy5fX3ZhbHVlcztcbiAgICBsZXQgcHJldmlvdXNMZW5ndGggPSBwcmV2aW91c1ZhbHVlcy5sZW5ndGg7XG4gICAgdGhpcy5fX3ZhbHVlcyA9IGFyZ3M7XG5cbiAgICBjb25zdCB3ZWFrVGhpcyA9IHRoaXMuX193ZWFrVGhpcztcbiAgICBjb25zdCBwYXVzZXIgPSB0aGlzLl9fcGF1c2VyO1xuXG4gICAgLy8gSWYgb3VyIGluaXRpYWwgcmVuZGVyIG9jY3VycyB3aGlsZSBkaXNjb25uZWN0ZWQsIGVuc3VyZSB0aGF0IHRoZSBwYXVzZXJcbiAgICAvLyBhbmQgd2Vha1RoaXMgYXJlIGluIHRoZSBkaXNjb25uZWN0ZWQgc3RhdGVcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdGVkKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBJZiB3ZSd2ZSByZW5kZXJlZCBhIGhpZ2hlci1wcmlvcml0eSB2YWx1ZSBhbHJlYWR5LCBzdG9wLlxuICAgICAgaWYgKGkgPiB0aGlzLl9fbGFzdFJlbmRlcmVkSW5kZXgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1tpXTtcblxuICAgICAgLy8gUmVuZGVyIG5vbi1Qcm9taXNlIHZhbHVlcyBpbW1lZGlhdGVseVxuICAgICAgaWYgKCFpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX19sYXN0UmVuZGVyZWRJbmRleCA9IGk7XG4gICAgICAgIC8vIFNpbmNlIGEgbG93ZXItcHJpb3JpdHkgdmFsdWUgd2lsbCBuZXZlciBvdmVyd3JpdGUgYSBoaWdoZXItcHJpb3JpdHlcbiAgICAgICAgLy8gc3luY2hyb25vdXMgdmFsdWUsIHdlIGNhbiBzdG9wIHByb2Nlc3Npbmcgbm93LlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBQcm9taXNlIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCwgc2tpcCBpdC5cbiAgICAgIGlmIChpIDwgcHJldmlvdXNMZW5ndGggJiYgdmFsdWUgPT09IHByZXZpb3VzVmFsdWVzW2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBoYXZlIGEgUHJvbWlzZSB0aGF0IHdlIGhhdmVuJ3Qgc2VlbiBiZWZvcmUsIHNvIHByaW9yaXRpZXMgbWF5IGhhdmVcbiAgICAgIC8vIGNoYW5nZWQuIEZvcmdldCB3aGF0IHdlIHJlbmRlcmVkIGJlZm9yZS5cbiAgICAgIHRoaXMuX19sYXN0UmVuZGVyZWRJbmRleCA9IF9pbmZpbml0eTtcbiAgICAgIHByZXZpb3VzTGVuZ3RoID0gMDtcblxuICAgICAgLy8gTm90ZSwgdGhlIGNhbGxiYWNrIGF2b2lkcyBjbG9zaW5nIG92ZXIgYHRoaXNgIHNvIHRoYXQgdGhlIGRpcmVjdGl2ZVxuICAgICAgLy8gY2FuIGJlIGdjJ2VkIGJlZm9yZSB0aGUgcHJvbWlzZSByZXNvbHZlczsgaW5zdGVhZCBgdGhpc2AgaXMgcmV0cmlldmVkXG4gICAgICAvLyBmcm9tIGB3ZWFrVGhpc2AsIHdoaWNoIGNhbiBicmVhayB0aGUgaGFyZCByZWZlcmVuY2UgaW4gdGhlIGNsb3N1cmUgd2hlblxuICAgICAgLy8gdGhlIGRpcmVjdGl2ZSBkaXNjb25uZWN0c1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGFzeW5jIChyZXN1bHQ6IHVua25vd24pID0+IHtcbiAgICAgICAgLy8gSWYgd2UncmUgZGlzY29ubmVjdGVkLCB3YWl0IHVudGlsIHdlJ3JlIChtYXliZSkgcmVjb25uZWN0ZWRcbiAgICAgICAgLy8gVGhlIHdoaWxlIGxvb3AgaGVyZSBoYW5kbGVzIHRoZSBjYXNlIHRoYXQgdGhlIGNvbm5lY3Rpb24gc3RhdGVcbiAgICAgICAgLy8gdGhyYXNoZXMsIGNhdXNpbmcgdGhlIHBhdXNlciB0byByZXN1bWUgYW5kIHRoZW4gZ2V0IHJlLXBhdXNlZFxuICAgICAgICB3aGlsZSAocGF1c2VyLmdldCgpKSB7XG4gICAgICAgICAgYXdhaXQgcGF1c2VyLmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjYWxsYmFjayBnZXRzIGhlcmUgYW5kIHRoZXJlIGlzIG5vIGB0aGlzYCwgaXQgbWVhbnMgdGhhdCB0aGVcbiAgICAgICAgLy8gZGlyZWN0aXZlIGhhcyBiZWVuIGRpc2Nvbm5lY3RlZCBhbmQgZ2FyYmFnZSBjb2xsZWN0ZWQgYW5kIHdlIGRvbid0XG4gICAgICAgIC8vIG5lZWQgdG8gZG8gYW55dGhpbmcgZWxzZVxuICAgICAgICBjb25zdCBfdGhpcyA9IHdlYWtUaGlzLmRlcmVmKCk7XG4gICAgICAgIGlmIChfdGhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBfdGhpcy5fX3ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAvLyBJZiBzdGF0ZS52YWx1ZXMgZG9lc24ndCBjb250YWluIHRoZSB2YWx1ZSwgd2UndmUgcmUtcmVuZGVyZWQgd2l0aG91dFxuICAgICAgICAgIC8vIHRoZSB2YWx1ZSwgc28gZG9uJ3QgcmVuZGVyIGl0LiBUaGVuLCBvbmx5IHJlbmRlciBpZiB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAvLyBoaWdoZXItcHJpb3JpdHkgdGhhbiB3aGF0J3MgYWxyZWFkeSBiZWVuIHJlbmRlcmVkLlxuICAgICAgICAgIGlmIChpbmRleCA+IC0xICYmIGluZGV4IDwgX3RoaXMuX19sYXN0UmVuZGVyZWRJbmRleCkge1xuICAgICAgICAgICAgX3RoaXMuX19sYXN0UmVuZGVyZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgX3RoaXMuc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBub0NoYW5nZTtcbiAgfVxuXG4gIG92ZXJyaWRlIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICB0aGlzLl9fd2Vha1RoaXMuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuX19wYXVzZXIucGF1c2UoKTtcbiAgfVxuXG4gIG92ZXJyaWRlIHJlY29ubmVjdGVkKCkge1xuICAgIHRoaXMuX193ZWFrVGhpcy5yZWNvbm5lY3QodGhpcyk7XG4gICAgdGhpcy5fX3BhdXNlci5yZXN1bWUoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgb25lIG9mIGEgc2VyaWVzIG9mIHZhbHVlcywgaW5jbHVkaW5nIFByb21pc2VzLCB0byBhIFBhcnQuXG4gKlxuICogVmFsdWVzIGFyZSByZW5kZXJlZCBpbiBwcmlvcml0eSBvcmRlciwgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQgaGF2aW5nIHRoZVxuICogaGlnaGVzdCBwcmlvcml0eSBhbmQgdGhlIGxhc3QgYXJndW1lbnQgaGF2aW5nIHRoZSBsb3dlc3QgcHJpb3JpdHkuIElmIGFcbiAqIHZhbHVlIGlzIGEgUHJvbWlzZSwgbG93LXByaW9yaXR5IHZhbHVlcyB3aWxsIGJlIHJlbmRlcmVkIHVudGlsIGl0IHJlc29sdmVzLlxuICpcbiAqIFRoZSBwcmlvcml0eSBvZiB2YWx1ZXMgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHBsYWNlaG9sZGVyIGNvbnRlbnQgZm9yIGFzeW5jXG4gKiBkYXRhLiBGb3IgZXhhbXBsZSwgYSBQcm9taXNlIHdpdGggcGVuZGluZyBjb250ZW50IGNhbiBiZSB0aGUgZmlyc3QsXG4gKiBoaWdoZXN0LXByaW9yaXR5LCBhcmd1bWVudCwgYW5kIGEgbm9uX3Byb21pc2UgbG9hZGluZyBpbmRpY2F0b3IgdGVtcGxhdGUgY2FuXG4gKiBiZSB1c2VkIGFzIHRoZSBzZWNvbmQsIGxvd2VyLXByaW9yaXR5LCBhcmd1bWVudC4gVGhlIGxvYWRpbmcgaW5kaWNhdG9yIHdpbGxcbiAqIHJlbmRlciBpbW1lZGlhdGVseSwgYW5kIHRoZSBwcmltYXJ5IGNvbnRlbnQgd2lsbCByZW5kZXIgd2hlbiB0aGUgUHJvbWlzZVxuICogcmVzb2x2ZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgY29udGVudCA9IGZldGNoKCcuL2NvbnRlbnQudHh0JykudGhlbihyID0+IHIudGV4dCgpKTtcbiAqIGh0bWxgJHt1bnRpbChjb250ZW50LCBodG1sYDxzcGFuPkxvYWRpbmcuLi48L3NwYW4+YCl9YFxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB1bnRpbCA9IGRpcmVjdGl2ZShVbnRpbERpcmVjdGl2ZSk7XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIGNsYXNzIHRoYXQgcG93ZXJzIHRoaXMgZGlyZWN0aXZlLiBOZWNlc3NhcnkgZm9yIG5hbWluZyB0aGVcbiAqIGRpcmVjdGl2ZSdzIHJldHVybiB0eXBlLlxuICovXG4vLyBleHBvcnQgdHlwZSB7VW50aWxEaXJlY3RpdmV9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-html/development/directives/until.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/abstract-grid-column-renderer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/abstract-grid-column-renderer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractGridColumnRenderer\": () => (/* binding */ AbstractGridColumnRenderer)\n/* harmony export */ });\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/lit-vaadin-helpers/dist/utils.js\");\n\n\nclass AbstractGridColumnRenderer extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_0__.AbstractRendererDirective {\n  /**\n   * Run renderer callback on the element.\n   */\n  runRenderer(element) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const grid = element._grid;\n\n    if (grid) {\n      // Only call grid.requestContentUpdate() once per property change\n      // in case if that property is used by several column renderers.\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.debounce)(grid, () => {\n        grid.requestContentUpdate();\n      });\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvYWJzdHJhY3QtZ3JpZC1jb2x1bW4tcmVuZGVyZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvYWJzdHJhY3QtZ3JpZC1jb2x1bW4tcmVuZGVyZXIudHM/MDE0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcmlkLCBHcmlkQ29sdW1uIH0gZnJvbSAnQHZhYWRpbi9ncmlkJztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmUsIEFic3RyYWN0TGl0UmVuZGVyZXIgfSBmcm9tICcuL2Fic3RyYWN0LXJlbmRlcmVyLmpzJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdEdyaWRDb2x1bW5SZW5kZXJlcjxcbiAgVCBleHRlbmRzIEdyaWRDb2x1bW4sXG4gIFIgZXh0ZW5kcyBBYnN0cmFjdExpdFJlbmRlcmVyXG4+IGV4dGVuZHMgQWJzdHJhY3RSZW5kZXJlckRpcmVjdGl2ZTxULCBSPiB7XG4gIC8qKlxuICAgKiBSdW4gcmVuZGVyZXIgY2FsbGJhY2sgb24gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBydW5SZW5kZXJlcihlbGVtZW50OiBHcmlkQ29sdW1uKTogdm9pZCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBncmlkID0gKGVsZW1lbnQgYXMgYW55KS5fZ3JpZCBhcyBHcmlkO1xuICAgIGlmIChncmlkKSB7XG4gICAgICAvLyBPbmx5IGNhbGwgZ3JpZC5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpIG9uY2UgcGVyIHByb3BlcnR5IGNoYW5nZVxuICAgICAgLy8gaW4gY2FzZSBpZiB0aGF0IHByb3BlcnR5IGlzIHVzZWQgYnkgc2V2ZXJhbCBjb2x1bW4gcmVuZGVyZXJzLlxuICAgICAgZGVib3VuY2UoZ3JpZCwgKCkgPT4ge1xuICAgICAgICBncmlkLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/abstract-grid-column-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractRendererDirective\": () => (/* binding */ AbstractRendererDirective)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n\n // A sentinel that indicates renderer hasn't been initialized\n\nconst initialValue = {};\nclass AbstractRendererDirective extends lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.Directive {\n  constructor(part) {\n    super(part);\n    this.previousValue = initialValue;\n\n    if (part.type !== lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.PartType.ELEMENT) {\n      throw new Error('renderer only supports binding to element');\n    }\n  }\n\n  render(_renderer, _value) {\n    return lit__WEBPACK_IMPORTED_MODULE_0__.nothing;\n  }\n\n  update(part, [renderer, value]) {\n    var _a;\n\n    const firstRender = this.previousValue === initialValue;\n\n    if (!this.hasChanged(value)) {\n      return lit__WEBPACK_IMPORTED_MODULE_0__.nothing;\n    } // Copy the value if it's an array so that if it's mutated we don't forget\n    // what the previous values were.\n\n\n    this.previousValue = Array.isArray(value) ? Array.from(value) : value;\n    const element = part.element; // TODO: support re-assigning renderer function.\n\n    if (firstRender) {\n      const host = (_a = part.options) === null || _a === void 0 ? void 0 : _a.host;\n      this.addRenderer(element, renderer, {\n        host\n      });\n    } else {\n      this.runRenderer(element);\n    }\n\n    return lit__WEBPACK_IMPORTED_MODULE_0__.nothing;\n  }\n\n  hasChanged(value) {\n    let result = true;\n\n    if (Array.isArray(value)) {\n      // Dirty-check arrays by item\n      if (Array.isArray(this.previousValue) && this.previousValue.length === value.length && value.every((v, i) => v === this.previousValue[i])) {\n        result = false;\n      }\n    } else if (this.previousValue === value) {\n      // Dirty-check non-arrays by identity\n      result = false;\n    }\n\n    return result;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvYWJzdHJhY3QtcmVuZGVyZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFNQTtBQUVBO0FBTUE7QUFDQTtBQUhBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBdkRBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvYWJzdHJhY3QtcmVuZGVyZXIudHM/ODA2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3RoaW5nLCBSZW5kZXJPcHRpb25zLCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRQYXJ0LCBQYXJ0SW5mbywgUGFydFR5cGUgfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCB0eXBlIEFic3RyYWN0TGl0UmVuZGVyZXIgPSAoLi4uYXJnczogYW55W10pID0+IFRlbXBsYXRlUmVzdWx0O1xuXG4vLyBBIHNlbnRpbmVsIHRoYXQgaW5kaWNhdGVzIHJlbmRlcmVyIGhhc24ndCBiZWVuIGluaXRpYWxpemVkXG5jb25zdCBpbml0aWFsVmFsdWUgPSB7fTtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmU8XG4gIFQgZXh0ZW5kcyBFbGVtZW50LFxuICBSIGV4dGVuZHMgQWJzdHJhY3RMaXRSZW5kZXJlclxuPiBleHRlbmRzIERpcmVjdGl2ZSB7XG4gIHByZXZpb3VzVmFsdWU6IHVua25vd24gPSBpbml0aWFsVmFsdWU7XG5cbiAgY29uc3RydWN0b3IocGFydDogUGFydEluZm8pIHtcbiAgICBzdXBlcihwYXJ0KTtcbiAgICBpZiAocGFydC50eXBlICE9PSBQYXJ0VHlwZS5FTEVNRU5UKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbmRlcmVyIG9ubHkgc3VwcG9ydHMgYmluZGluZyB0byBlbGVtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKF9yZW5kZXJlcjogUiwgX3ZhbHVlPzogdW5rbm93bik6IHR5cGVvZiBub3RoaW5nIHtcbiAgICByZXR1cm4gbm90aGluZztcbiAgfVxuXG4gIHVwZGF0ZShwYXJ0OiBFbGVtZW50UGFydCwgW3JlbmRlcmVyLCB2YWx1ZV06IFtSLCB1bmtub3duXSk6IHVua25vd24ge1xuICAgIGNvbnN0IGZpcnN0UmVuZGVyID0gdGhpcy5wcmV2aW91c1ZhbHVlID09PSBpbml0aWFsVmFsdWU7XG5cbiAgICBpZiAoIXRoaXMuaGFzQ2hhbmdlZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBub3RoaW5nO1xuICAgIH1cblxuICAgIC8vIENvcHkgdGhlIHZhbHVlIGlmIGl0J3MgYW4gYXJyYXkgc28gdGhhdCBpZiBpdCdzIG11dGF0ZWQgd2UgZG9uJ3QgZm9yZ2V0XG4gICAgLy8gd2hhdCB0aGUgcHJldmlvdXMgdmFsdWVzIHdlcmUuXG4gICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBBcnJheS5mcm9tKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IHBhcnQuZWxlbWVudCBhcyBUO1xuXG4gICAgLy8gVE9ETzogc3VwcG9ydCByZS1hc3NpZ25pbmcgcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAgaWYgKGZpcnN0UmVuZGVyKSB7XG4gICAgICBjb25zdCBob3N0ID0gcGFydC5vcHRpb25zPy5ob3N0O1xuICAgICAgdGhpcy5hZGRSZW5kZXJlcihlbGVtZW50LCByZW5kZXJlciwgeyBob3N0IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1blJlbmRlcmVyKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub3RoaW5nO1xuICB9XG5cbiAgaGFzQ2hhbmdlZCh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4ge1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBEaXJ0eS1jaGVjayBhcnJheXMgYnkgaXRlbVxuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMucHJldmlvdXNWYWx1ZSkgJiZcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlLmxlbmd0aCA9PT0gdmFsdWUubGVuZ3RoICYmXG4gICAgICAgIHZhbHVlLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSAodGhpcy5wcmV2aW91c1ZhbHVlIGFzIEFycmF5PHVua25vd24+KVtpXSlcbiAgICAgICkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXNWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIC8vIERpcnR5LWNoZWNrIG5vbi1hcnJheXMgYnkgaWRlbnRpdHlcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCByZW5kZXJlciBjYWxsYmFjayB0byB0aGUgZWxlbWVudC5cbiAgICovXG4gIGFic3RyYWN0IGFkZFJlbmRlcmVyKGVsZW1lbnQ6IFQsIHJlbmRlcmVyOiBSLCBvcHRpb25zOiBSZW5kZXJPcHRpb25zKTogdm9pZDtcblxuICAvKipcbiAgICogUnVuIHJlbmRlcmVyIGNhbGxiYWNrIG9uIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgYWJzdHJhY3QgcnVuUmVuZGVyZXIoZWxlbWVudDogVCk6IHZvaWQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/combo-box-renderer.js":
/*!********************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/combo-box-renderer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"comboBoxRenderer\": () => (/* binding */ comboBoxRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n\n\n\n\nclass ComboBoxRendererDirective extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractRendererDirective {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.renderer = (root, comboBox, model) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, model.item, model, comboBox), root, options);\n    };\n  }\n  /**\n   * Run renderer callback on the element.\n   */\n\n\n  runRenderer(element) {\n    element.requestContentUpdate();\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(ComboBoxRendererDirective);\nconst comboBoxRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvY29tYm8tYm94LXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBUUE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTs7QUFmQTs7QUFrQkE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL2NvbWJvLWJveC1yZW5kZXJlci50cz8zNjE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgUmVuZGVyT3B0aW9ucywgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgZGlyZWN0aXZlLCBEaXJlY3RpdmVSZXN1bHQgfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IENvbWJvQm94LCBDb21ib0JveEl0ZW1Nb2RlbCB9IGZyb20gJ0B2YWFkaW4vY29tYm8tYm94JztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmUgfSBmcm9tICcuL2Fic3RyYWN0LXJlbmRlcmVyLmpzJztcblxuZXhwb3J0IHR5cGUgQ29tYm9Cb3hMaXRSZW5kZXJlcjxUPiA9IChcbiAgaXRlbTogVCxcbiAgbW9kZWw6IENvbWJvQm94SXRlbU1vZGVsPFQ+LFxuICBjb21ib0JveDogQ29tYm9Cb3g8VD5cbikgPT4gVGVtcGxhdGVSZXN1bHQ7XG5cbmNsYXNzIENvbWJvQm94UmVuZGVyZXJEaXJlY3RpdmUgZXh0ZW5kcyBBYnN0cmFjdFJlbmRlcmVyRGlyZWN0aXZlPFxuICBDb21ib0JveCxcbiAgQ29tYm9Cb3hMaXRSZW5kZXJlcjx1bmtub3duPlxuPiB7XG4gIC8qKlxuICAgKiBTZXQgcmVuZGVyZXIgY2FsbGJhY2sgdG8gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBhZGRSZW5kZXJlcjxUPihlbGVtZW50OiBDb21ib0JveCwgcmVuZGVyZXI6IENvbWJvQm94TGl0UmVuZGVyZXI8VD4sIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMpIHtcbiAgICBlbGVtZW50LnJlbmRlcmVyID0gKHJvb3Q6IEhUTUxFbGVtZW50LCBjb21ib0JveDogQ29tYm9Cb3g8VD4sIG1vZGVsOiBDb21ib0JveEl0ZW1Nb2RlbDxUPikgPT4ge1xuICAgICAgcmVuZGVyKHJlbmRlcmVyLmNhbGwob3B0aW9ucy5ob3N0LCBtb2RlbC5pdGVtLCBtb2RlbCwgY29tYm9Cb3gpLCByb290LCBvcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biByZW5kZXJlciBjYWxsYmFjayBvbiB0aGUgZWxlbWVudC5cbiAgICovXG4gIHJ1blJlbmRlcmVyKGVsZW1lbnQ6IENvbWJvQm94KSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICB9XG59XG5cbmNvbnN0IHJlbmRlcmVyRGlyZWN0aXZlID0gZGlyZWN0aXZlKENvbWJvQm94UmVuZGVyZXJEaXJlY3RpdmUpO1xuXG5leHBvcnQgY29uc3QgY29tYm9Cb3hSZW5kZXJlciA9IDxUPihcbiAgcmVuZGVyZXI6IENvbWJvQm94TGl0UmVuZGVyZXI8VD4sXG4gIHZhbHVlPzogdW5rbm93blxuKTogRGlyZWN0aXZlUmVzdWx0PHR5cGVvZiBDb21ib0JveFJlbmRlcmVyRGlyZWN0aXZlPiA9PlxuICByZW5kZXJlckRpcmVjdGl2ZShyZW5kZXJlciBhcyBDb21ib0JveExpdFJlbmRlcmVyPHVua25vd24+LCB2YWx1ZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/combo-box-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/context-menu-renderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/context-menu-renderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"contextMenuRenderer\": () => (/* binding */ contextMenuRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n\n\n\n\nclass ContextMenuRendererDirective extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractRendererDirective {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.renderer = (root, menu, context) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, context, menu), root, options);\n    };\n  }\n  /**\n   * Run renderer callback on the element.\n   */\n\n\n  runRenderer(element) {\n    element.requestContentUpdate();\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(ContextMenuRendererDirective);\nconst contextMenuRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvY29udGV4dC1tZW51LXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBT0E7QUFJQTs7O0FBR0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTs7QUF2QkE7O0FBMEJBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9jb250ZXh0LW1lbnUtcmVuZGVyZXIudHM/OTA2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIFJlbmRlck9wdGlvbnMsIFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IGRpcmVjdGl2ZSwgRGlyZWN0aXZlUmVzdWx0IH0gZnJvbSAnbGl0L2RpcmVjdGl2ZS5qcyc7XG5pbXBvcnQgeyBDb250ZXh0TWVudSwgQ29udGV4dE1lbnVSZW5kZXJlckNvbnRleHQgfSBmcm9tICdAdmFhZGluL2NvbnRleHQtbWVudSc7XG5pbXBvcnQgeyBBYnN0cmFjdFJlbmRlcmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9hYnN0cmFjdC1yZW5kZXJlci5qcyc7XG5cbmV4cG9ydCB0eXBlIENvbnRleHRNZW51TGl0UmVuZGVyZXIgPSAoXG4gIGNvbnRleHQ6IENvbnRleHRNZW51UmVuZGVyZXJDb250ZXh0LFxuICBtZW51OiBDb250ZXh0TWVudVxuKSA9PiBUZW1wbGF0ZVJlc3VsdDtcblxuY2xhc3MgQ29udGV4dE1lbnVSZW5kZXJlckRpcmVjdGl2ZSBleHRlbmRzIEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmU8XG4gIENvbnRleHRNZW51LFxuICBDb250ZXh0TWVudUxpdFJlbmRlcmVyXG4+IHtcbiAgLyoqXG4gICAqIFNldCByZW5kZXJlciBjYWxsYmFjayB0byB0aGUgZWxlbWVudC5cbiAgICovXG4gIGFkZFJlbmRlcmVyKGVsZW1lbnQ6IENvbnRleHRNZW51LCByZW5kZXJlcjogQ29udGV4dE1lbnVMaXRSZW5kZXJlciwgb3B0aW9uczogUmVuZGVyT3B0aW9ucykge1xuICAgIGVsZW1lbnQucmVuZGVyZXIgPSAoXG4gICAgICByb290OiBIVE1MRWxlbWVudCxcbiAgICAgIG1lbnU/OiBDb250ZXh0TWVudSxcbiAgICAgIGNvbnRleHQ/OiBDb250ZXh0TWVudVJlbmRlcmVyQ29udGV4dFxuICAgICkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICByZW5kZXJlci5jYWxsKG9wdGlvbnMuaG9zdCwgY29udGV4dCBhcyBDb250ZXh0TWVudVJlbmRlcmVyQ29udGV4dCwgbWVudSBhcyBDb250ZXh0TWVudSksXG4gICAgICAgIHJvb3QsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gcmVuZGVyZXIgY2FsbGJhY2sgb24gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBydW5SZW5kZXJlcihlbGVtZW50OiBDb250ZXh0TWVudSkge1xuICAgIGVsZW1lbnQucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgfVxufVxuXG5jb25zdCByZW5kZXJlckRpcmVjdGl2ZSA9IGRpcmVjdGl2ZShDb250ZXh0TWVudVJlbmRlcmVyRGlyZWN0aXZlKTtcblxuZXhwb3J0IGNvbnN0IGNvbnRleHRNZW51UmVuZGVyZXIgPSAoXG4gIHJlbmRlcmVyOiBDb250ZXh0TWVudUxpdFJlbmRlcmVyLFxuICB2YWx1ZT86IHVua25vd25cbik6IERpcmVjdGl2ZVJlc3VsdDx0eXBlb2YgQ29udGV4dE1lbnVSZW5kZXJlckRpcmVjdGl2ZT4gPT4gcmVuZGVyZXJEaXJlY3RpdmUocmVuZGVyZXIsIHZhbHVlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/context-menu-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/dialog-renderer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/dialog-renderer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dialogRenderer\": () => (/* binding */ dialogRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n\n\n\n\nclass DialogRendererDirective extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractRendererDirective {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.renderer = (root, dialog) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, dialog), root, options);\n    };\n  }\n  /**\n   * Run renderer callback on the element.\n   */\n\n\n  runRenderer(element) {\n    element.requestContentUpdate();\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(DialogRendererDirective);\nconst dialogRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvZGlhbG9nLXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTs7QUFmQTs7QUFrQkE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL2RpYWxvZy1yZW5kZXJlci50cz8yZDM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgUmVuZGVyT3B0aW9ucywgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgZGlyZWN0aXZlLCBEaXJlY3RpdmVSZXN1bHQgfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IERpYWxvZyB9IGZyb20gJ0B2YWFkaW4vZGlhbG9nJztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmUgfSBmcm9tICcuL2Fic3RyYWN0LXJlbmRlcmVyLmpzJztcblxuZXhwb3J0IHR5cGUgRGlhbG9nTGl0UmVuZGVyZXIgPSAoZGlhbG9nOiBEaWFsb2cpID0+IFRlbXBsYXRlUmVzdWx0O1xuXG5jbGFzcyBEaWFsb2dSZW5kZXJlckRpcmVjdGl2ZSBleHRlbmRzIEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmU8RGlhbG9nLCBEaWFsb2dMaXRSZW5kZXJlcj4ge1xuICAvKipcbiAgICogU2V0IHJlbmRlcmVyIGNhbGxiYWNrIHRvIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgYWRkUmVuZGVyZXIoZWxlbWVudDogRGlhbG9nLCByZW5kZXJlcjogRGlhbG9nTGl0UmVuZGVyZXIsIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMpIHtcbiAgICBlbGVtZW50LnJlbmRlcmVyID0gKHJvb3Q6IEhUTUxFbGVtZW50LCBkaWFsb2c/OiBEaWFsb2cpID0+IHtcbiAgICAgIHJlbmRlcihyZW5kZXJlci5jYWxsKG9wdGlvbnMuaG9zdCwgZGlhbG9nIGFzIERpYWxvZyksIHJvb3QsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUnVuIHJlbmRlcmVyIGNhbGxiYWNrIG9uIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgcnVuUmVuZGVyZXIoZWxlbWVudDogRGlhbG9nKSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICB9XG59XG5cbmNvbnN0IHJlbmRlcmVyRGlyZWN0aXZlID0gZGlyZWN0aXZlKERpYWxvZ1JlbmRlcmVyRGlyZWN0aXZlKTtcblxuZXhwb3J0IGNvbnN0IGRpYWxvZ1JlbmRlcmVyID0gKFxuICByZW5kZXJlcjogRGlhbG9nTGl0UmVuZGVyZXIsXG4gIHZhbHVlPzogdW5rbm93blxuKTogRGlyZWN0aXZlUmVzdWx0PHR5cGVvZiBEaWFsb2dSZW5kZXJlckRpcmVjdGl2ZT4gPT4gcmVuZGVyZXJEaXJlY3RpdmUocmVuZGVyZXIsIHZhbHVlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/dialog-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/grid-column-body-renderer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/grid-column-body-renderer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"columnBodyRenderer\": () => (/* binding */ columnBodyRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_grid_column_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-grid-column-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-grid-column-renderer.js\");\n\n\n\n\nclass GridColumnBodyRendererDirective extends _abstract_grid_column_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractGridColumnRenderer {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.renderer = (root, column, model) => {\n      if (model) {\n        (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, model.item, model, column), root, options);\n      }\n    };\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(GridColumnBodyRendererDirective);\nconst columnBodyRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvZ3JpZC1jb2x1bW4tYm9keS1yZW5kZXJlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUVBOztBQVFBO0FBSUE7OztBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBOztBQWlCQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvZ3JpZC1jb2x1bW4tYm9keS1yZW5kZXJlci50cz81YjI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgUmVuZGVyT3B0aW9ucywgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgZGlyZWN0aXZlLCBEaXJlY3RpdmVSZXN1bHQgfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IEdyaWRDb2x1bW4sIEdyaWRJdGVtTW9kZWwgfSBmcm9tICdAdmFhZGluL2dyaWQnO1xuaW1wb3J0IHsgQWJzdHJhY3RHcmlkQ29sdW1uUmVuZGVyZXIgfSBmcm9tICcuL2Fic3RyYWN0LWdyaWQtY29sdW1uLXJlbmRlcmVyLmpzJztcblxuZXhwb3J0IHR5cGUgR3JpZENvbHVtbkJvZHlMaXRSZW5kZXJlcjxUPiA9IChcbiAgaXRlbTogVCxcbiAgbW9kZWw6IEdyaWRJdGVtTW9kZWw8VD4sXG4gIGNvbHVtbjogR3JpZENvbHVtbjxUPlxuKSA9PiBUZW1wbGF0ZVJlc3VsdDtcblxuY2xhc3MgR3JpZENvbHVtbkJvZHlSZW5kZXJlckRpcmVjdGl2ZSBleHRlbmRzIEFic3RyYWN0R3JpZENvbHVtblJlbmRlcmVyPFxuICBHcmlkQ29sdW1uLFxuICBHcmlkQ29sdW1uQm9keUxpdFJlbmRlcmVyPHVua25vd24+XG4+IHtcbiAgLyoqXG4gICAqIFNldCByZW5kZXJlciBjYWxsYmFjayB0byB0aGUgZWxlbWVudC5cbiAgICovXG4gIGFkZFJlbmRlcmVyPFQ+KFxuICAgIGVsZW1lbnQ6IEdyaWRDb2x1bW4sXG4gICAgcmVuZGVyZXI6IEdyaWRDb2x1bW5Cb2R5TGl0UmVuZGVyZXI8VD4sXG4gICAgb3B0aW9uczogUmVuZGVyT3B0aW9uc1xuICApIHtcbiAgICBlbGVtZW50LnJlbmRlcmVyID0gKHJvb3Q6IEhUTUxFbGVtZW50LCBjb2x1bW4/OiBHcmlkQ29sdW1uLCBtb2RlbD86IEdyaWRJdGVtTW9kZWw8VD4pID0+IHtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICByZW5kZXIocmVuZGVyZXIuY2FsbChvcHRpb25zLmhvc3QsIG1vZGVsLml0ZW0sIG1vZGVsLCBjb2x1bW4gYXMgR3JpZENvbHVtbiksIHJvb3QsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuY29uc3QgcmVuZGVyZXJEaXJlY3RpdmUgPSBkaXJlY3RpdmUoR3JpZENvbHVtbkJvZHlSZW5kZXJlckRpcmVjdGl2ZSk7XG5cbmV4cG9ydCBjb25zdCBjb2x1bW5Cb2R5UmVuZGVyZXIgPSA8VD4oXG4gIHJlbmRlcmVyOiBHcmlkQ29sdW1uQm9keUxpdFJlbmRlcmVyPFQ+LFxuICB2YWx1ZT86IHVua25vd25cbik6IERpcmVjdGl2ZVJlc3VsdDx0eXBlb2YgR3JpZENvbHVtbkJvZHlSZW5kZXJlckRpcmVjdGl2ZT4gPT5cbiAgcmVuZGVyZXJEaXJlY3RpdmUocmVuZGVyZXIgYXMgR3JpZENvbHVtbkJvZHlMaXRSZW5kZXJlcjx1bmtub3duPiwgdmFsdWUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/grid-column-body-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/grid-column-footer-renderer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/grid-column-footer-renderer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"columnFooterRenderer\": () => (/* binding */ columnFooterRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_grid_column_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-grid-column-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-grid-column-renderer.js\");\n\n\n\n\nclass GridColumnFooterRendererDirective extends _abstract_grid_column_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractGridColumnRenderer {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.footerRenderer = (root, column) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, column), root, options);\n    };\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(GridColumnFooterRendererDirective);\nconst columnFooterRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvZ3JpZC1jb2x1bW4tZm9vdGVyLXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBSUE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFSQTs7QUFXQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvZ3JpZC1jb2x1bW4tZm9vdGVyLXJlbmRlcmVyLnRzPzE2YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBSZW5kZXJPcHRpb25zLCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBkaXJlY3RpdmUsIERpcmVjdGl2ZVJlc3VsdCB9IGZyb20gJ2xpdC9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgR3JpZENvbHVtbiB9IGZyb20gJ0B2YWFkaW4vZ3JpZCc7XG5pbXBvcnQgeyBBYnN0cmFjdEdyaWRDb2x1bW5SZW5kZXJlciB9IGZyb20gJy4vYWJzdHJhY3QtZ3JpZC1jb2x1bW4tcmVuZGVyZXIuanMnO1xuXG5leHBvcnQgdHlwZSBHcmlkQ29sdW1uRm9vdGVyTGl0UmVuZGVyZXIgPSAoY29sdW1uOiBHcmlkQ29sdW1uKSA9PiBUZW1wbGF0ZVJlc3VsdDtcblxuY2xhc3MgR3JpZENvbHVtbkZvb3RlclJlbmRlcmVyRGlyZWN0aXZlIGV4dGVuZHMgQWJzdHJhY3RHcmlkQ29sdW1uUmVuZGVyZXI8XG4gIEdyaWRDb2x1bW4sXG4gIEdyaWRDb2x1bW5Gb290ZXJMaXRSZW5kZXJlclxuPiB7XG4gIC8qKlxuICAgKiBTZXQgcmVuZGVyZXIgY2FsbGJhY2sgdG8gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBhZGRSZW5kZXJlcihlbGVtZW50OiBHcmlkQ29sdW1uLCByZW5kZXJlcjogR3JpZENvbHVtbkZvb3RlckxpdFJlbmRlcmVyLCBvcHRpb25zOiBSZW5kZXJPcHRpb25zKSB7XG4gICAgZWxlbWVudC5mb290ZXJSZW5kZXJlciA9IChyb290OiBIVE1MRWxlbWVudCwgY29sdW1uPzogR3JpZENvbHVtbikgPT4ge1xuICAgICAgcmVuZGVyKHJlbmRlcmVyLmNhbGwob3B0aW9ucy5ob3N0LCBjb2x1bW4gYXMgR3JpZENvbHVtbiksIHJvb3QsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cbn1cblxuY29uc3QgcmVuZGVyZXJEaXJlY3RpdmUgPSBkaXJlY3RpdmUoR3JpZENvbHVtbkZvb3RlclJlbmRlcmVyRGlyZWN0aXZlKTtcblxuZXhwb3J0IGNvbnN0IGNvbHVtbkZvb3RlclJlbmRlcmVyID0gKFxuICByZW5kZXJlcjogR3JpZENvbHVtbkZvb3RlckxpdFJlbmRlcmVyLFxuICB2YWx1ZT86IHVua25vd25cbik6IERpcmVjdGl2ZVJlc3VsdDx0eXBlb2YgR3JpZENvbHVtbkZvb3RlclJlbmRlcmVyRGlyZWN0aXZlPiA9PiByZW5kZXJlckRpcmVjdGl2ZShyZW5kZXJlciwgdmFsdWUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/grid-column-footer-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/grid-column-header-renderer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/grid-column-header-renderer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"columnHeaderRenderer\": () => (/* binding */ columnHeaderRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_grid_column_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-grid-column-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-grid-column-renderer.js\");\n\n\n\n\nclass GridColumnHeaderRendererDirective extends _abstract_grid_column_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractGridColumnRenderer {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.headerRenderer = (root, column) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, column), root, options);\n    };\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(GridColumnHeaderRendererDirective);\nconst columnHeaderRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvZ3JpZC1jb2x1bW4taGVhZGVyLXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBSUE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFSQTs7QUFXQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvZ3JpZC1jb2x1bW4taGVhZGVyLXJlbmRlcmVyLnRzPzdiZDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBSZW5kZXJPcHRpb25zLCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBkaXJlY3RpdmUsIERpcmVjdGl2ZVJlc3VsdCB9IGZyb20gJ2xpdC9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgR3JpZENvbHVtbiB9IGZyb20gJ0B2YWFkaW4vZ3JpZCc7XG5pbXBvcnQgeyBBYnN0cmFjdEdyaWRDb2x1bW5SZW5kZXJlciB9IGZyb20gJy4vYWJzdHJhY3QtZ3JpZC1jb2x1bW4tcmVuZGVyZXIuanMnO1xuXG5leHBvcnQgdHlwZSBHcmlkQ29sdW1uSGVhZGVyTGl0UmVuZGVyZXIgPSAoY29sdW1uOiBHcmlkQ29sdW1uKSA9PiBUZW1wbGF0ZVJlc3VsdDtcblxuY2xhc3MgR3JpZENvbHVtbkhlYWRlclJlbmRlcmVyRGlyZWN0aXZlIGV4dGVuZHMgQWJzdHJhY3RHcmlkQ29sdW1uUmVuZGVyZXI8XG4gIEdyaWRDb2x1bW4sXG4gIEdyaWRDb2x1bW5IZWFkZXJMaXRSZW5kZXJlclxuPiB7XG4gIC8qKlxuICAgKiBTZXQgcmVuZGVyZXIgY2FsbGJhY2sgdG8gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBhZGRSZW5kZXJlcihlbGVtZW50OiBHcmlkQ29sdW1uLCByZW5kZXJlcjogR3JpZENvbHVtbkhlYWRlckxpdFJlbmRlcmVyLCBvcHRpb25zOiBSZW5kZXJPcHRpb25zKSB7XG4gICAgZWxlbWVudC5oZWFkZXJSZW5kZXJlciA9IChyb290OiBIVE1MRWxlbWVudCwgY29sdW1uPzogR3JpZENvbHVtbikgPT4ge1xuICAgICAgcmVuZGVyKHJlbmRlcmVyLmNhbGwob3B0aW9ucy5ob3N0LCBjb2x1bW4gYXMgR3JpZENvbHVtbiksIHJvb3QsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cbn1cblxuY29uc3QgcmVuZGVyZXJEaXJlY3RpdmUgPSBkaXJlY3RpdmUoR3JpZENvbHVtbkhlYWRlclJlbmRlcmVyRGlyZWN0aXZlKTtcblxuZXhwb3J0IGNvbnN0IGNvbHVtbkhlYWRlclJlbmRlcmVyID0gKFxuICByZW5kZXJlcjogR3JpZENvbHVtbkhlYWRlckxpdFJlbmRlcmVyLFxuICB2YWx1ZT86IHVua25vd25cbik6IERpcmVjdGl2ZVJlc3VsdDx0eXBlb2YgR3JpZENvbHVtbkhlYWRlclJlbmRlcmVyRGlyZWN0aXZlPiA9PiByZW5kZXJlckRpcmVjdGl2ZShyZW5kZXJlciwgdmFsdWUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/grid-column-header-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/grid-row-details-renderer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/grid-row-details-renderer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"gridRowDetailsRenderer\": () => (/* binding */ gridRowDetailsRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/lit-vaadin-helpers/dist/utils.js\");\n\n\n\n\n\nclass GridRowDetailsRendererDirective extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractRendererDirective {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.rowDetailsRenderer = (root, grid, model) => {\n      if (model) {\n        const item = model.item;\n        (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, item, model, grid), root, options);\n      }\n    };\n  }\n  /**\n   * Run renderer callback on the element.\n   */\n\n\n  runRenderer(element) {\n    // Only call grid.requestContentUpdate() once per property change\n    // in case if that property is used by several column renderers.\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.debounce)(element, () => {\n      element.requestContentUpdate();\n    });\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(GridRowDetailsRendererDirective);\nconst gridRowDetailsRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvZ3JpZC1yb3ctZGV0YWlscy1yZW5kZXJlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBOztBQVFBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF0QkE7O0FBeUJBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9ncmlkLXJvdy1kZXRhaWxzLXJlbmRlcmVyLnRzPzcwYTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBSZW5kZXJPcHRpb25zLCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBkaXJlY3RpdmUsIERpcmVjdGl2ZVJlc3VsdCB9IGZyb20gJ2xpdC9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgR3JpZCwgR3JpZEl0ZW1Nb2RlbCB9IGZyb20gJ0B2YWFkaW4vZ3JpZCc7XG5pbXBvcnQgeyBBYnN0cmFjdFJlbmRlcmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9hYnN0cmFjdC1yZW5kZXJlci5qcyc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5leHBvcnQgdHlwZSBHcmlkUm93RGV0YWlsc0xpdFJlbmRlcmVyPFQ+ID0gKFxuICBpdGVtOiBULFxuICBtb2RlbDogR3JpZEl0ZW1Nb2RlbDxUPixcbiAgZ3JpZDogR3JpZFxuKSA9PiBUZW1wbGF0ZVJlc3VsdDtcblxuY2xhc3MgR3JpZFJvd0RldGFpbHNSZW5kZXJlckRpcmVjdGl2ZSBleHRlbmRzIEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmU8XG4gIEdyaWQsXG4gIEdyaWRSb3dEZXRhaWxzTGl0UmVuZGVyZXI8dW5rbm93bj5cbj4ge1xuICAvKipcbiAgICogU2V0IHJlbmRlcmVyIGNhbGxiYWNrIHRvIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgYWRkUmVuZGVyZXI8VD4oZWxlbWVudDogR3JpZCwgcmVuZGVyZXI6IEdyaWRSb3dEZXRhaWxzTGl0UmVuZGVyZXI8VD4sIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMpIHtcbiAgICBlbGVtZW50LnJvd0RldGFpbHNSZW5kZXJlciA9IChyb290OiBIVE1MRWxlbWVudCwgZ3JpZD86IEdyaWQsIG1vZGVsPzogR3JpZEl0ZW1Nb2RlbDxUPikgPT4ge1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBtb2RlbC5pdGVtO1xuICAgICAgICByZW5kZXIocmVuZGVyZXIuY2FsbChvcHRpb25zLmhvc3QsIGl0ZW0sIG1vZGVsLCBncmlkIGFzIEdyaWQpLCByb290LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biByZW5kZXJlciBjYWxsYmFjayBvbiB0aGUgZWxlbWVudC5cbiAgICovXG4gIHJ1blJlbmRlcmVyKGVsZW1lbnQ6IEdyaWQpIHtcbiAgICAvLyBPbmx5IGNhbGwgZ3JpZC5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpIG9uY2UgcGVyIHByb3BlcnR5IGNoYW5nZVxuICAgIC8vIGluIGNhc2UgaWYgdGhhdCBwcm9wZXJ0eSBpcyB1c2VkIGJ5IHNldmVyYWwgY29sdW1uIHJlbmRlcmVycy5cbiAgICBkZWJvdW5jZShlbGVtZW50LCAoKSA9PiB7XG4gICAgICBlbGVtZW50LnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgcmVuZGVyZXJEaXJlY3RpdmUgPSBkaXJlY3RpdmUoR3JpZFJvd0RldGFpbHNSZW5kZXJlckRpcmVjdGl2ZSk7XG5cbmV4cG9ydCBjb25zdCBncmlkUm93RGV0YWlsc1JlbmRlcmVyID0gPFQ+KFxuICByZW5kZXJlcjogR3JpZFJvd0RldGFpbHNMaXRSZW5kZXJlcjxUPixcbiAgdmFsdWU/OiB1bmtub3duXG4pOiBEaXJlY3RpdmVSZXN1bHQ8dHlwZW9mIEdyaWRSb3dEZXRhaWxzUmVuZGVyZXJEaXJlY3RpdmU+ID0+XG4gIHJlbmRlcmVyRGlyZWN0aXZlKHJlbmRlcmVyIGFzIEdyaWRSb3dEZXRhaWxzTGl0UmVuZGVyZXI8dW5rbm93bj4sIHZhbHVlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/grid-row-details-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"columnBodyRenderer\": () => (/* reexport safe */ _grid_column_body_renderer_js__WEBPACK_IMPORTED_MODULE_3__.columnBodyRenderer),\n/* harmony export */   \"columnFooterRenderer\": () => (/* reexport safe */ _grid_column_footer_renderer_js__WEBPACK_IMPORTED_MODULE_5__.columnFooterRenderer),\n/* harmony export */   \"columnHeaderRenderer\": () => (/* reexport safe */ _grid_column_header_renderer_js__WEBPACK_IMPORTED_MODULE_4__.columnHeaderRenderer),\n/* harmony export */   \"comboBoxRenderer\": () => (/* reexport safe */ _combo_box_renderer_js__WEBPACK_IMPORTED_MODULE_0__.comboBoxRenderer),\n/* harmony export */   \"contextMenuRenderer\": () => (/* reexport safe */ _context_menu_renderer_js__WEBPACK_IMPORTED_MODULE_1__.contextMenuRenderer),\n/* harmony export */   \"dialogRenderer\": () => (/* reexport safe */ _dialog_renderer_js__WEBPACK_IMPORTED_MODULE_2__.dialogRenderer),\n/* harmony export */   \"gridRowDetailsRenderer\": () => (/* reexport safe */ _grid_row_details_renderer_js__WEBPACK_IMPORTED_MODULE_6__.gridRowDetailsRenderer),\n/* harmony export */   \"notificationRenderer\": () => (/* reexport safe */ _notification_renderer_js__WEBPACK_IMPORTED_MODULE_7__.notificationRenderer),\n/* harmony export */   \"selectRenderer\": () => (/* reexport safe */ _select_renderer_js__WEBPACK_IMPORTED_MODULE_8__.selectRenderer),\n/* harmony export */   \"virtualListRenderer\": () => (/* reexport safe */ _virtual_list_renderer_js__WEBPACK_IMPORTED_MODULE_9__.virtualListRenderer)\n/* harmony export */ });\n/* harmony import */ var _combo_box_renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combo-box-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/combo-box-renderer.js\");\n/* harmony import */ var _context_menu_renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context-menu-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/context-menu-renderer.js\");\n/* harmony import */ var _dialog_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dialog-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/dialog-renderer.js\");\n/* harmony import */ var _grid_column_body_renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./grid-column-body-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/grid-column-body-renderer.js\");\n/* harmony import */ var _grid_column_header_renderer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grid-column-header-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/grid-column-header-renderer.js\");\n/* harmony import */ var _grid_column_footer_renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./grid-column-footer-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/grid-column-footer-renderer.js\");\n/* harmony import */ var _grid_row_details_renderer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./grid-row-details-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/grid-row-details-renderer.js\");\n/* harmony import */ var _notification_renderer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./notification-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/notification-renderer.js\");\n/* harmony import */ var _select_renderer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/select-renderer.js\");\n/* harmony import */ var _virtual_list_renderer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./virtual-list-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/virtual-list-renderer.js\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9pbmRleC50cz82ZjM3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vY29tYm8tYm94LXJlbmRlcmVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29udGV4dC1tZW51LXJlbmRlcmVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZGlhbG9nLXJlbmRlcmVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZ3JpZC1jb2x1bW4tYm9keS1yZW5kZXJlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2dyaWQtY29sdW1uLWhlYWRlci1yZW5kZXJlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2dyaWQtY29sdW1uLWZvb3Rlci1yZW5kZXJlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2dyaWQtcm93LWRldGFpbHMtcmVuZGVyZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ub3RpZmljYXRpb24tcmVuZGVyZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zZWxlY3QtcmVuZGVyZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi92aXJ0dWFsLWxpc3QtcmVuZGVyZXIuanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/index.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/notification-renderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/notification-renderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"notificationRenderer\": () => (/* binding */ notificationRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n\n\n\n\nclass NotificationRendererDirective extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractRendererDirective {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.renderer = (root, notification) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, notification), root, options);\n    };\n  }\n  /**\n   * Run renderer callback on the element.\n   */\n\n\n  runRenderer(element) {\n    element.requestContentUpdate();\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(NotificationRendererDirective);\nconst notificationRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3Qvbm90aWZpY2F0aW9uLXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBSUE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTs7QUFmQTs7QUFrQkE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL25vdGlmaWNhdGlvbi1yZW5kZXJlci50cz82YzdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgUmVuZGVyT3B0aW9ucywgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgZGlyZWN0aXZlLCBEaXJlY3RpdmVSZXN1bHQgfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvbiB9IGZyb20gJ0B2YWFkaW4vbm90aWZpY2F0aW9uJztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmUgfSBmcm9tICcuL2Fic3RyYWN0LXJlbmRlcmVyLmpzJztcblxuZXhwb3J0IHR5cGUgTm90aWZpY2F0aW9uTGl0UmVuZGVyZXIgPSAobm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24pID0+IFRlbXBsYXRlUmVzdWx0O1xuXG5jbGFzcyBOb3RpZmljYXRpb25SZW5kZXJlckRpcmVjdGl2ZSBleHRlbmRzIEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmU8XG4gIE5vdGlmaWNhdGlvbixcbiAgTm90aWZpY2F0aW9uTGl0UmVuZGVyZXJcbj4ge1xuICAvKipcbiAgICogU2V0IHJlbmRlcmVyIGNhbGxiYWNrIHRvIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgYWRkUmVuZGVyZXIoZWxlbWVudDogTm90aWZpY2F0aW9uLCByZW5kZXJlcjogTm90aWZpY2F0aW9uTGl0UmVuZGVyZXIsIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMpIHtcbiAgICBlbGVtZW50LnJlbmRlcmVyID0gKHJvb3Q6IEhUTUxFbGVtZW50LCBub3RpZmljYXRpb24/OiBOb3RpZmljYXRpb24pID0+IHtcbiAgICAgIHJlbmRlcihyZW5kZXJlci5jYWxsKG9wdGlvbnMuaG9zdCwgbm90aWZpY2F0aW9uIGFzIE5vdGlmaWNhdGlvbiksIHJvb3QsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUnVuIHJlbmRlcmVyIGNhbGxiYWNrIG9uIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgcnVuUmVuZGVyZXIoZWxlbWVudDogTm90aWZpY2F0aW9uKSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICB9XG59XG5cbmNvbnN0IHJlbmRlcmVyRGlyZWN0aXZlID0gZGlyZWN0aXZlKE5vdGlmaWNhdGlvblJlbmRlcmVyRGlyZWN0aXZlKTtcblxuZXhwb3J0IGNvbnN0IG5vdGlmaWNhdGlvblJlbmRlcmVyID0gKFxuICByZW5kZXJlcjogTm90aWZpY2F0aW9uTGl0UmVuZGVyZXIsXG4gIHZhbHVlPzogdW5rbm93blxuKTogRGlyZWN0aXZlUmVzdWx0PHR5cGVvZiBOb3RpZmljYXRpb25SZW5kZXJlckRpcmVjdGl2ZT4gPT4gcmVuZGVyZXJEaXJlY3RpdmUocmVuZGVyZXIsIHZhbHVlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/notification-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/select-renderer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/select-renderer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"selectRenderer\": () => (/* binding */ selectRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n\n\n\n\nclass SelectRendererDirective extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractRendererDirective {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.renderer = (root, select) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, select), root, options);\n    };\n  }\n  /**\n   * Run renderer callback on the element.\n   */\n\n\n  runRenderer(element) {\n    element.requestContentUpdate();\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(SelectRendererDirective);\nconst selectRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3Qvc2VsZWN0LXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTs7QUFmQTs7QUFrQkE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL3NlbGVjdC1yZW5kZXJlci50cz9hZmVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgUmVuZGVyT3B0aW9ucywgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgZGlyZWN0aXZlLCBEaXJlY3RpdmVSZXN1bHQgfSBmcm9tICdsaXQvZGlyZWN0aXZlLmpzJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJ0B2YWFkaW4vc2VsZWN0JztcbmltcG9ydCB7IEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmUgfSBmcm9tICcuL2Fic3RyYWN0LXJlbmRlcmVyLmpzJztcblxuZXhwb3J0IHR5cGUgU2VsZWN0TGl0UmVuZGVyZXIgPSAoc2VsZWN0OiBTZWxlY3QpID0+IFRlbXBsYXRlUmVzdWx0O1xuXG5jbGFzcyBTZWxlY3RSZW5kZXJlckRpcmVjdGl2ZSBleHRlbmRzIEFic3RyYWN0UmVuZGVyZXJEaXJlY3RpdmU8U2VsZWN0LCBTZWxlY3RMaXRSZW5kZXJlcj4ge1xuICAvKipcbiAgICogU2V0IHJlbmRlcmVyIGNhbGxiYWNrIHRvIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgYWRkUmVuZGVyZXIoZWxlbWVudDogU2VsZWN0LCByZW5kZXJlcjogU2VsZWN0TGl0UmVuZGVyZXIsIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMpIHtcbiAgICBlbGVtZW50LnJlbmRlcmVyID0gKHJvb3Q6IEhUTUxFbGVtZW50LCBzZWxlY3Q/OiBTZWxlY3QpID0+IHtcbiAgICAgIHJlbmRlcihyZW5kZXJlci5jYWxsKG9wdGlvbnMuaG9zdCwgc2VsZWN0IGFzIFNlbGVjdCksIHJvb3QsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUnVuIHJlbmRlcmVyIGNhbGxiYWNrIG9uIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgcnVuUmVuZGVyZXIoZWxlbWVudDogU2VsZWN0KSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICB9XG59XG5cbmNvbnN0IHJlbmRlcmVyRGlyZWN0aXZlID0gZGlyZWN0aXZlKFNlbGVjdFJlbmRlcmVyRGlyZWN0aXZlKTtcblxuZXhwb3J0IGNvbnN0IHNlbGVjdFJlbmRlcmVyID0gKFxuICByZW5kZXJlcjogU2VsZWN0TGl0UmVuZGVyZXIsXG4gIHZhbHVlPzogdW5rbm93blxuKTogRGlyZWN0aXZlUmVzdWx0PHR5cGVvZiBTZWxlY3RSZW5kZXJlckRpcmVjdGl2ZT4gPT4gcmVuZGVyZXJEaXJlY3RpdmUocmVuZGVyZXIsIHZhbHVlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/select-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debounce\": () => (/* binding */ debounce)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_debounce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/debounce.js */ \"./node_modules/@polymer/polymer/lib/utils/debounce.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_async_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/async.js */ \"./node_modules/@polymer/polymer/lib/utils/async.js\");\n\n\nfunction debounce(target, cb) {\n  const el = target;\n  el._debounceLitRender = _polymer_polymer_lib_utils_debounce_js__WEBPACK_IMPORTED_MODULE_0__.Debouncer.debounce(el._debounceLitRender, _polymer_polymer_lib_utils_async_js__WEBPACK_IMPORTED_MODULE_1__.microTask, cb);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvdXRpbHMudHM/N2YzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcyc7XG5cbmludGVyZmFjZSBIYXNMaXREZWJvdW5jZXIge1xuICBfZGVib3VuY2VMaXRSZW5kZXI6IERlYm91bmNlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKHRhcmdldDogdW5rbm93biwgY2I6ICgpID0+IHVua25vd24pOiB2b2lkIHtcbiAgY29uc3QgZWwgPSB0YXJnZXQgYXMgSGFzTGl0RGVib3VuY2VyO1xuICBlbC5fZGVib3VuY2VMaXRSZW5kZXIgPSBEZWJvdW5jZXIuZGVib3VuY2UoZWwuX2RlYm91bmNlTGl0UmVuZGVyLCBtaWNyb1Rhc2ssIGNiKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/utils.js\n");

/***/ }),

/***/ "./node_modules/lit-vaadin-helpers/dist/virtual-list-renderer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lit-vaadin-helpers/dist/virtual-list-renderer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"virtualListRenderer\": () => (/* binding */ virtualListRenderer)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/lit/directive.js\");\n/* harmony import */ var _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-renderer.js */ \"./node_modules/lit-vaadin-helpers/dist/abstract-renderer.js\");\n\n\n\n\nclass VirtualListRendererDirective extends _abstract_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AbstractRendererDirective {\n  /**\n   * Set renderer callback to the element.\n   */\n  addRenderer(element, renderer, options) {\n    element.renderer = (root, list, model) => {\n      (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(renderer.call(options.host, model.item, model, list), root, options);\n    };\n  }\n  /**\n   * Run renderer callback on the element.\n   */\n\n\n  runRenderer(element) {\n    element.requestContentUpdate();\n  }\n\n}\n\nconst rendererDirective = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_1__.directive)(VirtualListRendererDirective);\nconst virtualListRenderer = (renderer, value) => rendererDirective(renderer, value);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl0LXZhYWRpbi1oZWxwZXJzL2Rpc3QvdmlydHVhbC1saXN0LXJlbmRlcmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7O0FBUUE7QUFJQTs7O0FBR0E7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTs7QUF2QkE7O0FBMEJBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy92aXJ0dWFsLWxpc3QtcmVuZGVyZXIudHM/NGYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIFJlbmRlck9wdGlvbnMsIFRlbXBsYXRlUmVzdWx0IH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IGRpcmVjdGl2ZSwgRGlyZWN0aXZlUmVzdWx0IH0gZnJvbSAnbGl0L2RpcmVjdGl2ZS5qcyc7XG5pbXBvcnQgeyBWaXJ0dWFsTGlzdCwgVmlydHVhbExpc3RJdGVtTW9kZWwgfSBmcm9tICdAdmFhZGluL3ZpcnR1YWwtbGlzdCc7XG5pbXBvcnQgeyBBYnN0cmFjdFJlbmRlcmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9hYnN0cmFjdC1yZW5kZXJlci5qcyc7XG5cbmV4cG9ydCB0eXBlIFZpcnR1YWxMaXN0TGl0UmVuZGVyZXI8VD4gPSAoXG4gIGl0ZW06IFQsXG4gIG1vZGVsOiBWaXJ0dWFsTGlzdEl0ZW1Nb2RlbDxUPixcbiAgbGlzdDogVmlydHVhbExpc3Q8VD5cbikgPT4gVGVtcGxhdGVSZXN1bHQ7XG5cbmNsYXNzIFZpcnR1YWxMaXN0UmVuZGVyZXJEaXJlY3RpdmUgZXh0ZW5kcyBBYnN0cmFjdFJlbmRlcmVyRGlyZWN0aXZlPFxuICBWaXJ0dWFsTGlzdCxcbiAgVmlydHVhbExpc3RMaXRSZW5kZXJlcjx1bmtub3duPlxuPiB7XG4gIC8qKlxuICAgKiBTZXQgcmVuZGVyZXIgY2FsbGJhY2sgdG8gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBhZGRSZW5kZXJlcjxUPihcbiAgICBlbGVtZW50OiBWaXJ0dWFsTGlzdDxUPixcbiAgICByZW5kZXJlcjogVmlydHVhbExpc3RMaXRSZW5kZXJlcjxUPixcbiAgICBvcHRpb25zOiBSZW5kZXJPcHRpb25zXG4gICkge1xuICAgIGVsZW1lbnQucmVuZGVyZXIgPSAoXG4gICAgICByb290OiBIVE1MRWxlbWVudCxcbiAgICAgIGxpc3Q6IFZpcnR1YWxMaXN0PFQ+LFxuICAgICAgbW9kZWw6IFZpcnR1YWxMaXN0SXRlbU1vZGVsPFQ+XG4gICAgKSA9PiB7XG4gICAgICByZW5kZXIocmVuZGVyZXIuY2FsbChvcHRpb25zLmhvc3QsIG1vZGVsLml0ZW0sIG1vZGVsLCBsaXN0IGFzIFZpcnR1YWxMaXN0PFQ+KSwgcm9vdCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gcmVuZGVyZXIgY2FsbGJhY2sgb24gdGhlIGVsZW1lbnQuXG4gICAqL1xuICBydW5SZW5kZXJlcihlbGVtZW50OiBWaXJ0dWFsTGlzdCkge1xuICAgIGVsZW1lbnQucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgfVxufVxuXG5jb25zdCByZW5kZXJlckRpcmVjdGl2ZSA9IGRpcmVjdGl2ZShWaXJ0dWFsTGlzdFJlbmRlcmVyRGlyZWN0aXZlKTtcblxuZXhwb3J0IGNvbnN0IHZpcnR1YWxMaXN0UmVuZGVyZXIgPSA8VD4oXG4gIHJlbmRlcmVyOiBWaXJ0dWFsTGlzdExpdFJlbmRlcmVyPFQ+LFxuICB2YWx1ZT86IHVua25vd25cbik6IERpcmVjdGl2ZVJlc3VsdDx0eXBlb2YgVmlydHVhbExpc3RSZW5kZXJlckRpcmVjdGl2ZT4gPT5cbiAgcmVuZGVyZXJEaXJlY3RpdmUocmVuZGVyZXIgYXMgVmlydHVhbExpc3RMaXRSZW5kZXJlcjx1bmtub3duPiwgdmFsdWUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lit-vaadin-helpers/dist/virtual-list-renderer.js\n");

/***/ }),

/***/ "./node_modules/lit/directives/guard.js":
/*!**********************************************!*\
  !*** ./node_modules/lit/directives/guard.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "guard": () => (/* reexport safe */ lit_html_directives_guard_js__WEBPACK_IMPORTED_MODULE_0__.guard)
/* harmony export */ });
/* harmony import */ var lit_html_directives_guard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/guard.js */ "./node_modules/lit-html/development/directives/guard.js");


/***/ }),

/***/ "./node_modules/lit/directives/until.js":
/*!**********************************************!*\
  !*** ./node_modules/lit/directives/until.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UntilDirective": () => (/* reexport safe */ lit_html_directives_until_js__WEBPACK_IMPORTED_MODULE_0__.UntilDirective),
/* harmony export */   "until": () => (/* reexport safe */ lit_html_directives_until_js__WEBPACK_IMPORTED_MODULE_0__.until)
/* harmony export */ });
/* harmony import */ var lit_html_directives_until_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directives/until.js */ "./node_modules/lit-html/development/directives/until.js");


/***/ }),

/***/ "./node_modules/superstruct/lib/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/superstruct/lib/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Struct\": () => (/* binding */ Struct),\n/* harmony export */   \"StructError\": () => (/* binding */ StructError),\n/* harmony export */   \"any\": () => (/* binding */ any),\n/* harmony export */   \"array\": () => (/* binding */ array),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"assign\": () => (/* binding */ assign),\n/* harmony export */   \"bigint\": () => (/* binding */ bigint),\n/* harmony export */   \"boolean\": () => (/* binding */ boolean),\n/* harmony export */   \"coerce\": () => (/* binding */ coerce),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"date\": () => (/* binding */ date),\n/* harmony export */   \"defaulted\": () => (/* binding */ defaulted),\n/* harmony export */   \"define\": () => (/* binding */ define),\n/* harmony export */   \"deprecated\": () => (/* binding */ deprecated),\n/* harmony export */   \"dynamic\": () => (/* binding */ dynamic),\n/* harmony export */   \"empty\": () => (/* binding */ empty),\n/* harmony export */   \"enums\": () => (/* binding */ enums),\n/* harmony export */   \"func\": () => (/* binding */ func),\n/* harmony export */   \"instance\": () => (/* binding */ instance),\n/* harmony export */   \"integer\": () => (/* binding */ integer),\n/* harmony export */   \"intersection\": () => (/* binding */ intersection),\n/* harmony export */   \"is\": () => (/* binding */ is),\n/* harmony export */   \"lazy\": () => (/* binding */ lazy),\n/* harmony export */   \"literal\": () => (/* binding */ literal),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"mask\": () => (/* binding */ mask),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"never\": () => (/* binding */ never),\n/* harmony export */   \"nonempty\": () => (/* binding */ nonempty),\n/* harmony export */   \"nullable\": () => (/* binding */ nullable),\n/* harmony export */   \"number\": () => (/* binding */ number),\n/* harmony export */   \"object\": () => (/* binding */ object),\n/* harmony export */   \"omit\": () => (/* binding */ omit),\n/* harmony export */   \"optional\": () => (/* binding */ optional),\n/* harmony export */   \"partial\": () => (/* binding */ partial),\n/* harmony export */   \"pattern\": () => (/* binding */ pattern),\n/* harmony export */   \"pick\": () => (/* binding */ pick),\n/* harmony export */   \"record\": () => (/* binding */ record),\n/* harmony export */   \"refine\": () => (/* binding */ refine),\n/* harmony export */   \"regexp\": () => (/* binding */ regexp),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"size\": () => (/* binding */ size),\n/* harmony export */   \"string\": () => (/* binding */ string),\n/* harmony export */   \"struct\": () => (/* binding */ struct),\n/* harmony export */   \"trimmed\": () => (/* binding */ trimmed),\n/* harmony export */   \"tuple\": () => (/* binding */ tuple),\n/* harmony export */   \"type\": () => (/* binding */ type),\n/* harmony export */   \"union\": () => (/* binding */ union),\n/* harmony export */   \"unknown\": () => (/* binding */ unknown),\n/* harmony export */   \"validate\": () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    this.value = void 0;\n    this.key = void 0;\n    this.type = void 0;\n    this.refinement = void 0;\n    this.path = void 0;\n    this.branch = void 0;\n    this.failures = void 0;\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];\n    };\n  }\n\n}\n/**\n * Check if a value is an iterator.\n */\n\n\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\"\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\n\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\n\nfunction* run(value, struct, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    path = [],\n    branch = [value],\n    coerce = false,\n    mask = false\n  } = options;\n  const ctx = {\n    path,\n    branch\n  };\n\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n\n    if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let valid = true;\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false;\n    yield [failure, undefined];\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask\n    });\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false;\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          value[k] = v;\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value, ctx)) {\n      valid = false;\n      yield [failure, undefined];\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value];\n  }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\n\nclass Struct {\n  constructor(props) {\n    this.TYPE = void 0;\n    this.type = void 0;\n    this.schema = void 0;\n    this.coercer = void 0;\n    this.validator = void 0;\n    this.refiner = void 0;\n    this.entries = void 0;\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\n\nfunction create(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\n\nfunction mask(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\n\nfunction validate(value, struct, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\n\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n\n  const isType = Structs[0].type === 'type';\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\n\nfunction deprecated(struct, log) {\n  return new Struct({ ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    },\n\n    refiner(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.refiner(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\n\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n\n    *entries(value, ctx) {\n      var _struct;\n\n      (_struct = struct) != null ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    },\n\n    refiner(value, ctx) {\n      var _struct4;\n\n      (_struct4 = struct) != null ? _struct4 : struct = fn();\n      return struct.refiner(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\n\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = { ...schema\n  };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema);\n\n    default:\n      return object(subschema);\n  }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\n\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? { ...struct.schema\n  } : { ...struct\n  };\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\n\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */\n\n\nfunction any() {\n  return define('any', () => true);\n}\n\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a bigint.\n */\n\n\nfunction bigint() {\n  return define('bigint', value => {\n    return typeof value === 'bigint';\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\n\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\n\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\n\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\n\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\n\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\n\n\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n\n  });\n}\n\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n\n    validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\n\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\n\nfunction nullable(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\n\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n\n    coercer(value) {\n      return isObject(value) ? { ...value\n      } : value;\n    }\n\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\n\nfunction optional(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\n\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\n\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\n\nfunction tuple(Structs) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\n\n\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n\n    coercer(value, ctx) {\n      const firstMatch = Structs.find(s => {\n        const [e] = s.validate(value, {\n          coerce: true\n        });\n        return !e;\n      }) || unknown();\n      return firstMatch.coercer(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value), ...failures];\n    }\n\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction coerce(struct, condition, coercer) {\n  return new Struct({ ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction defaulted(struct, fallback, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x\n      };\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\n\nfunction empty(struct) {\n  return refine(struct, 'empty', value => {\n    const size = getSize(value);\n    return size === 0 || \"Expected an empty \" + struct.type + \" but received one with a size of `\" + size + \"`\";\n  });\n}\n\nfunction getSize(value) {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size;\n  } else {\n    return value.length;\n  }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\n\nfunction max(struct, threshold, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" less than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\n\nfunction min(struct, threshold, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\n\n\nfunction nonempty(struct) {\n  return refine(struct, 'nonempty', value => {\n    const size = getSize(value);\n    return size > 0 || \"Expected a nonempty \" + struct.type + \" but received an empty one\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\n\nfunction size(struct, min, max) {\n  if (max === void 0) {\n    max = min;\n  }\n\n  const expected = \"Expected a \" + struct.type;\n  const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\n\nfunction refine(struct, name, refiner) {\n  return new Struct({ ...struct,\n\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure,\n          refinement: name\n        };\n      }\n    }\n\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOztBQVlBOzs7Ozs7O0FBT0E7QUFFQTtBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7O0FBQ0E7QUFBQTs7QUFDQTtBQURBO0FBR0E7O0FBdEJBO0FDcEJBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUVBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBRUE7O0FBRUE7OztBQUVBO0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7O0FBRUE7QUFRQTtBQUxBO0FBS0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FDOUxBOzs7O0FBSUE7OztBQUVBO0FBWUE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBQ0E7QUFDQTtBQUVBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFPQTs7O0FBRUE7QUFJQTtBQUZBO0FBRUE7O0FBRUE7QUFDQTs7QUF0R0E7QUF5R0E7O0FBRUE7OztBQUVBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFFQTtBQU1BO0FBSEE7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7O0FBR0E7OztBQUVBO0FBSUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBWUE7QUFFQTs7Ozs7O0FBTUE7OztBQUVBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQU9BO0FBQ0E7QUFDQTtBQVRBOztBQVdBO0FBQ0E7QUFDQTtBQWJBOztBQWVBO0FBQ0E7QUFDQTtBQUNBOztBQWxCQTtBQW9CQTtBQUVBOzs7Ozs7O0FBT0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBTEE7O0FBT0E7QUFBQTs7QUFDQTtBQUNBO0FBVEE7O0FBV0E7QUFBQTs7QUFDQTtBQUNBO0FBYkE7O0FBZUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBbEJBO0FBb0JBO0FBRUE7Ozs7O0FBS0E7OztBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7Ozs7O0FBS0E7OztBQUVBO0FBR0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBS0E7OztBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7OztBQUlBOzs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQ2hPQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOztBQVlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBOztBQVVBO0FBQ0E7QUFYQTs7QUFhQTtBQUNBO0FBSUE7O0FBbEJBO0FBb0JBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBOzs7OztBQUtBOzs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQU1BOztBQWVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFJQTs7QUFSQTtBQVVBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBTUE7QUFFQTs7QUFFQTs7O0FBRUE7QUFHQTtBQUNBO0FBREE7QUFNQTtBQUVBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQU1BO0FBRUE7O0FBRUE7OztBQUVBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFYQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpCQTtBQW1CQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQVRBO0FBV0E7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTs7QUFXQTtBQUNBO0FBWkE7O0FBY0E7QUFDQTtBQUlBOztBQW5CQTtBQXFCQTtBQUVBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBTUE7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWZBOztBQWlCQTtBQUNBO0FBbEJBOztBQXNCQTtBQUNBO0FBQUE7QUFDQTs7QUF4QkE7QUEwQkE7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFKQTtBQU1BO0FBRUE7Ozs7O0FBS0E7OztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTs7QUFZQTtBQUNBO0FBR0E7O0FBaEJBO0FBa0JBO0FBRUE7Ozs7O0FBS0E7OztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7O0FBVUE7QUFDQTtBQVhBOztBQWFBO0FBQ0E7QUFJQTs7QUFsQkE7QUFvQkE7QUFFQTs7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFNQTtBQUVBOzs7QUFHQTs7O0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFWQTs7QUFZQTtBQUNBO0FBSUE7O0FBakJBO0FBbUJBO0FBRUE7Ozs7O0FBS0E7OztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7O0FBVUE7QUFDQTtBQUdBOztBQWRBO0FBZ0JBO0FBRUE7O0FBRUE7OztBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFJQTtBQVRBOztBQVdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTUE7O0FBbkNBO0FBcUNBO0FBRUE7O0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQ3RoQkE7Ozs7Ozs7OztBQVNBOzs7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUdBO0FBTkE7QUFRQTtBQUVBOzs7OztBQUtBOzs7QUFFQTtBQUtBO0FBRkE7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUF2QkE7QUF5QkE7QUFFQTs7Ozs7QUFLQTs7O0FBRUE7QUFDQTtBQUNBO0FDN0VBOztBQUVBOzs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBRUE7QUFLQTtBQUZBO0FBRUE7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBUUE7QUFFQTs7QUFFQTs7O0FBRUE7QUFLQTtBQUZBO0FBRUE7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBUUE7QUFFQTs7QUFFQTs7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBRUE7O0FBRUE7OztBQUVBO0FBSUE7QUFDQTtBQURBO0FBTUE7QUFFQTs7QUFFQTs7O0FBRUE7QUFHQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFGQTtBQU9BO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFsQkE7QUFvQkE7QUFFQTs7Ozs7O0FBTUE7OztBQUVBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQVZBO0FBWUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9lcnJvci50cz85MjBmIiwid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL3V0aWxzLnRzPzdmMzMiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvc3RydWN0LnRzPzJjNDgiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvc3RydWN0cy91dGlsaXRpZXMudHM/NzY2MCIsIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9zdHJ1Y3RzL3R5cGVzLnRzP2UwNjkiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvc3RydWN0cy9jb2VyY2lvbnMudHM/MTRmYiIsIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9zdHJ1Y3RzL3JlZmluZW1lbnRzLnRzP2MxMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuXG5leHBvcnQgdHlwZSBGYWlsdXJlID0ge1xuICB2YWx1ZTogYW55XG4gIGtleTogYW55XG4gIHR5cGU6IHN0cmluZ1xuICByZWZpbmVtZW50OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgbWVzc2FnZTogc3RyaW5nXG4gIGJyYW5jaDogQXJyYXk8YW55PlxuICBwYXRoOiBBcnJheTxhbnk+XG59XG5cbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgdmFsdWU6IGFueVxuICBrZXkhOiBhbnlcbiAgdHlwZSE6IHN0cmluZ1xuICByZWZpbmVtZW50ITogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHBhdGghOiBBcnJheTxhbnk+XG4gIGJyYW5jaCE6IEFycmF5PGFueT5cbiAgZmFpbHVyZXM6ICgpID0+IEFycmF5PEZhaWx1cmU+O1xuICBbeDogc3RyaW5nXTogYW55XG5cbiAgY29uc3RydWN0b3IoZmFpbHVyZTogRmFpbHVyZSwgZmFpbHVyZXM6ICgpID0+IEdlbmVyYXRvcjxGYWlsdXJlPikge1xuICAgIGxldCBjYWNoZWQ6IEFycmF5PEZhaWx1cmU+IHwgdW5kZWZpbmVkXG4gICAgY29uc3QgeyBtZXNzYWdlLCAuLi5yZXN0IH0gPSBmYWlsdXJlXG4gICAgY29uc3QgeyBwYXRoIH0gPSBmYWlsdXJlXG4gICAgY29uc3QgbXNnID1cbiAgICAgIHBhdGgubGVuZ3RoID09PSAwID8gbWVzc2FnZSA6IGBBdCBwYXRoOiAke3BhdGguam9pbignLicpfSAtLSAke21lc3NhZ2V9YFxuICAgIHN1cGVyKG1zZylcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpXG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoY2FjaGVkID8/PSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBTdHJ1Y3QsIEluZmVyLCBSZXN1bHQsIENvbnRleHQsIERlc2NyaWJlIH0gZnJvbSAnLi9zdHJ1Y3QnXG5pbXBvcnQgeyBGYWlsdXJlIH0gZnJvbSAnLi9lcnJvcidcblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIGlzSXRlcmFibGU8VD4oeDogdW5rbm93bik6IHggaXMgSXRlcmFibGU8VD4ge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHg6IHVua25vd24pOiB4IGlzIG9iamVjdCB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4OiB1bmtub3duKTogeCBpcyB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KVxuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZVxufVxuXG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnQodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYCR7dmFsdWV9YFxufVxuXG4vKipcbiAqIFNoaWZ0cyAocmVtb3ZlcyBhbmQgcmV0dXJucykgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gKiBMaWtlIGBBcnJheS5wcm90b3R5cGUuc2hpZnQoKWAgYnV0IGZvciBhbiBgSXRlcmF0b3JgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzaGlmdEl0ZXJhdG9yPFQ+KGlucHV0OiBJdGVyYXRvcjxUPik6IFQgfCB1bmRlZmluZWQge1xuICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KClcbiAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0ZhaWx1cmU8VCwgUz4oXG4gIHJlc3VsdDogc3RyaW5nIHwgYm9vbGVhbiB8IFBhcnRpYWw8RmFpbHVyZT4sXG4gIGNvbnRleHQ6IENvbnRleHQsXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICB2YWx1ZTogYW55XG4pOiBGYWlsdXJlIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICByZXN1bHQgPSB7fVxuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0geyBtZXNzYWdlOiByZXN1bHQgfVxuICB9XG5cbiAgY29uc3QgeyBwYXRoLCBicmFuY2ggfSA9IGNvbnRleHRcbiAgY29uc3QgeyB0eXBlIH0gPSBzdHJ1Y3RcbiAgY29uc3Qge1xuICAgIHJlZmluZW1lbnQsXG4gICAgbWVzc2FnZSA9IGBFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgXFxgJHt0eXBlfVxcYCR7XG4gICAgICByZWZpbmVtZW50ID8gYCB3aXRoIHJlZmluZW1lbnQgXFxgJHtyZWZpbmVtZW50fVxcYGAgOiAnJ1xuICAgIH0sIGJ1dCByZWNlaXZlZDogXFxgJHtwcmludCh2YWx1ZSl9XFxgYCxcbiAgfSA9IHJlc3VsdFxuXG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICByZWZpbmVtZW50LFxuICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgIHBhdGgsXG4gICAgYnJhbmNoLFxuICAgIC4uLnJlc3VsdCxcbiAgICBtZXNzYWdlLFxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiogdG9GYWlsdXJlczxULCBTPihcbiAgcmVzdWx0OiBSZXN1bHQsXG4gIGNvbnRleHQ6IENvbnRleHQsXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICB2YWx1ZTogYW55XG4pOiBJdGVyYWJsZUl0ZXJhdG9yPEZhaWx1cmU+IHtcbiAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBbcmVzdWx0XVxuICB9XG5cbiAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgIGNvbnN0IGZhaWx1cmUgPSB0b0ZhaWx1cmUociwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSlcblxuICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICB5aWVsZCBmYWlsdXJlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uKiBydW48VCwgUz4oXG4gIHZhbHVlOiB1bmtub3duLFxuICBzdHJ1Y3Q6IFN0cnVjdDxULCBTPixcbiAgb3B0aW9uczoge1xuICAgIHBhdGg/OiBhbnlbXVxuICAgIGJyYW5jaD86IGFueVtdXG4gICAgY29lcmNlPzogYm9vbGVhblxuICAgIG1hc2s/OiBib29sZWFuXG4gIH0gPSB7fVxuKTogSXRlcmFibGVJdGVyYXRvcjxbRmFpbHVyZSwgdW5kZWZpbmVkXSB8IFt1bmRlZmluZWQsIFRdPiB7XG4gIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zXG4gIGNvbnN0IGN0eDogQ29udGV4dCA9IHsgcGF0aCwgYnJhbmNoIH1cblxuICBpZiAoY29lcmNlKSB7XG4gICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KVxuXG4gICAgaWYgKFxuICAgICAgbWFzayAmJlxuICAgICAgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJlxuICAgICAgaXNPYmplY3Qoc3RydWN0LnNjaGVtYSkgJiZcbiAgICAgIGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHZhbGlkID0gdHJ1ZVxuXG4gIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpKSB7XG4gICAgdmFsaWQgPSBmYWxzZVxuICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdXG4gIH1cblxuICBmb3IgKGxldCBbaywgdiwgc10gb2Ygc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCkpIHtcbiAgICBjb25zdCB0cyA9IHJ1bih2LCBzIGFzIFN0cnVjdCwge1xuICAgICAgcGF0aDogayA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IFsuLi5wYXRoLCBrXSxcbiAgICAgIGJyYW5jaDogayA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgdl0sXG4gICAgICBjb2VyY2UsXG4gICAgICBtYXNrLFxuICAgIH0pXG5cbiAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2VcbiAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF1cbiAgICAgIH0gZWxzZSBpZiAoY29lcmNlKSB7XG4gICAgICAgIHYgPSB0WzFdXG5cbiAgICAgICAgaWYgKGsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlID0gdlxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgdmFsdWUuc2V0KGssIHYpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICB2YWx1ZS5hZGQodilcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZVtrXSA9IHZcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWxpZCkge1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSBhcyBULCBjdHgpKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlXG4gICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWxpZCkge1xuICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlIGFzIFRdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdW5pb24gb2YgdHlwZSB0byBhbiBpbnRlcnNlY3Rpb24uXG4gKi9cblxuZXhwb3J0IHR5cGUgVW5pb25Ub0ludGVyc2VjdGlvbjxVPiA9IChcbiAgVSBleHRlbmRzIGFueSA/IChhcmc6IFUpID0+IGFueSA6IG5ldmVyXG4pIGV4dGVuZHMgKGFyZzogaW5mZXIgSSkgPT4gdm9pZFxuICA/IElcbiAgOiBuZXZlclxuXG4vKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gb25lIHR5cGUgdG8gYW5vdGhlciwgb3ZlcndyaXRpbmcgZXhpc3RpbmcuXG4gKi9cblxuZXhwb3J0IHR5cGUgQXNzaWduPFQsIFU+ID0gU2ltcGxpZnk8VSAmIE9taXQ8VCwga2V5b2YgVT4+XG5cbi8qKlxuICogQSBzY2hlbWEgZm9yIGVudW0gc3RydWN0cy5cbiAqL1xuXG5leHBvcnQgdHlwZSBFbnVtU2NoZW1hPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQ+ID0ge1xuICBbSyBpbiBOb25OdWxsYWJsZTxUPl06IEtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHR5cGUgaXMgYSBtYXRjaCBmb3IgYW5vdGhlciB3aGlsc3QgdHJlYXRpbmcgb3ZlcmxhcHBpbmdcbiAqIHVuaW9ucyBhcyBhIG1hdGNoLlxuICovXG5cbmV4cG9ydCB0eXBlIElzTWF0Y2g8VCwgRz4gPSBUIGV4dGVuZHMgRyA/IChHIGV4dGVuZHMgVCA/IFQgOiBuZXZlcikgOiBuZXZlclxuXG4vKipcbiAqIENoZWNrIGlmIGEgdHlwZSBpcyBhbiBleGFjdCBtYXRjaC5cbiAqL1xuXG5leHBvcnQgdHlwZSBJc0V4YWN0TWF0Y2g8VCwgVT4gPSAoPEc+KCkgPT4gRyBleHRlbmRzIFQgPyAxIDogMikgZXh0ZW5kcyA8XG4gIEdcbj4oKSA9PiBHIGV4dGVuZHMgVSA/IDEgOiAyXG4gID8gVFxuICA6IG5ldmVyXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgcmVjb3JkIHR5cGUuXG4gKi9cblxuZXhwb3J0IHR5cGUgSXNSZWNvcmQ8VD4gPSBUIGV4dGVuZHMgb2JqZWN0XG4gID8gc3RyaW5nIGV4dGVuZHMga2V5b2YgVFxuICAgID8gVFxuICAgIDogbmV2ZXJcbiAgOiBuZXZlclxuLyoqXG4gKiBDaGVjayBpZiBhIHR5cGUgaXMgYSB0dXBsZS5cbiAqL1xuXG5leHBvcnQgdHlwZSBJc1R1cGxlPFQ+ID0gVCBleHRlbmRzIFthbnldXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBbYW55LCBhbnldXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBbYW55LCBhbnksIGFueV1cbiAgPyBUXG4gIDogVCBleHRlbmRzIFthbnksIGFueSwgYW55LCBhbnldXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBbYW55LCBhbnksIGFueSwgYW55LCBhbnldXG4gID8gVFxuICA6IG5ldmVyXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgdW5pb24uXG4gKi9cblxuZXhwb3J0IHR5cGUgSXNVbmlvbjxULCBVIGV4dGVuZHMgVCA9IFQ+ID0gKFxuICBUIGV4dGVuZHMgYW55ID8gKFUgZXh0ZW5kcyBUID8gZmFsc2UgOiB0cnVlKSA6IGZhbHNlXG4pIGV4dGVuZHMgZmFsc2VcbiAgPyBuZXZlclxuICA6IFRcblxuLyoqXG4gKiBBIHNjaGVtYSBmb3Igb2JqZWN0IHN0cnVjdHMuXG4gKi9cblxuZXhwb3J0IHR5cGUgT2JqZWN0U2NoZW1hID0gUmVjb3JkPHN0cmluZywgU3RydWN0PGFueSwgYW55Pj5cblxuLyoqXG4gKiBJbmZlciBhIHR5cGUgZnJvbSBhbiBvYmplY3Qgc3RydWN0IHNjaGVtYS5cbiAqL1xuXG5leHBvcnQgdHlwZSBPYmplY3RUeXBlPFMgZXh0ZW5kcyBPYmplY3RTY2hlbWE+ID0gU2ltcGxpZnk8XG4gIE9wdGlvbmFsaXplPHsgW0sgaW4ga2V5b2YgU106IEluZmVyPFNbS10+IH0+XG4+XG5cbi8qKlxuICogT21pdCBwcm9wZXJ0aWVzIGZyb20gYSB0eXBlIHRoYXQgZXh0ZW5kIGZyb20gYSBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmV4cG9ydCB0eXBlIE9taXRCeTxULCBWPiA9IE9taXQ8XG4gIFQsXG4gIHsgW0sgaW4ga2V5b2YgVF06IFYgZXh0ZW5kcyBFeHRyYWN0PFRbS10sIFY+ID8gSyA6IG5ldmVyIH1ba2V5b2YgVF1cbj5cblxuLyoqXG4gKiBOb3JtYWxpemUgcHJvcGVydGllcyBvZiBhIHR5cGUgdGhhdCBhbGxvdyBgdW5kZWZpbmVkYCB0byBtYWtlIHRoZW0gb3B0aW9uYWwuXG4gKi9cblxuZXhwb3J0IHR5cGUgT3B0aW9uYWxpemU8UyBleHRlbmRzIG9iamVjdD4gPSBPbWl0Qnk8UywgdW5kZWZpbmVkPiAmXG4gIFBhcnRpYWw8UGlja0J5PFMsIHVuZGVmaW5lZD4+XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIG9iamVjdCBzY2hlbWEgdHlwZSB0byByZXByZXNlbnQgYSBwYXJ0aWFsLlxuICovXG5cbmV4cG9ydCB0eXBlIFBhcnRpYWxPYmplY3RTY2hlbWE8UyBleHRlbmRzIE9iamVjdFNjaGVtYT4gPSB7XG4gIFtLIGluIGtleW9mIFNdOiBTdHJ1Y3Q8SW5mZXI8U1tLXT4gfCB1bmRlZmluZWQ+XG59XG5cbi8qKlxuICogUGljayBwcm9wZXJ0aWVzIGZyb20gYSB0eXBlIHRoYXQgZXh0ZW5kIGZyb20gYSBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmV4cG9ydCB0eXBlIFBpY2tCeTxULCBWPiA9IFBpY2s8XG4gIFQsXG4gIHsgW0sgaW4ga2V5b2YgVF06IFYgZXh0ZW5kcyBFeHRyYWN0PFRbS10sIFY+ID8gSyA6IG5ldmVyIH1ba2V5b2YgVF1cbj5cblxuLyoqXG4gKiBTaW1wbGlmaWVzIGEgdHlwZSBkZWZpbml0aW9uIHRvIGl0cyBtb3N0IGJhc2ljIHJlcHJlc2VudGF0aW9uLlxuICovXG5cbmV4cG9ydCB0eXBlIFNpbXBsaWZ5PFQ+ID0gVCBleHRlbmRzIGFueVtdIHwgRGF0ZVxuICA/IFRcbiAgOiB7IFtLIGluIGtleW9mIFRdOiBUW0tdIH0gJiB7fVxuXG5leHBvcnQgdHlwZSBJZjxCIGV4dGVuZHMgQm9vbGVhbiwgVGhlbiwgRWxzZT4gPSBCIGV4dGVuZHMgdHJ1ZSA/IFRoZW4gOiBFbHNlXG5cbi8qKlxuICogQSBzY2hlbWEgZm9yIGFueSB0eXBlIG9mIHN0cnVjdC5cbiAqL1xuXG5leHBvcnQgdHlwZSBTdHJ1Y3RTY2hlbWE8VD4gPSBbVF0gZXh0ZW5kcyBbc3RyaW5nIHwgdW5kZWZpbmVkXVxuICA/IFtUXSBleHRlbmRzIFtJc01hdGNoPFQsIHN0cmluZyB8IHVuZGVmaW5lZD5dXG4gICAgPyBudWxsXG4gICAgOiBbVF0gZXh0ZW5kcyBbSXNVbmlvbjxUPl1cbiAgICA/IEVudW1TY2hlbWE8VD5cbiAgICA6IFRcbiAgOiBbVF0gZXh0ZW5kcyBbbnVtYmVyIHwgdW5kZWZpbmVkXVxuICA/IFtUXSBleHRlbmRzIFtJc01hdGNoPFQsIG51bWJlciB8IHVuZGVmaW5lZD5dXG4gICAgPyBudWxsXG4gICAgOiBbVF0gZXh0ZW5kcyBbSXNVbmlvbjxUPl1cbiAgICA/IEVudW1TY2hlbWE8VD5cbiAgICA6IFRcbiAgOiBbVF0gZXh0ZW5kcyBbYm9vbGVhbl1cbiAgPyBbVF0gZXh0ZW5kcyBbSXNFeGFjdE1hdGNoPFQsIGJvb2xlYW4+XVxuICAgID8gbnVsbFxuICAgIDogVFxuICA6IFQgZXh0ZW5kc1xuICAgICAgfCBiaWdpbnRcbiAgICAgIHwgc3ltYm9sXG4gICAgICB8IHVuZGVmaW5lZFxuICAgICAgfCBudWxsXG4gICAgICB8IEZ1bmN0aW9uXG4gICAgICB8IERhdGVcbiAgICAgIHwgRXJyb3JcbiAgICAgIHwgUmVnRXhwXG4gICAgICB8IE1hcDxhbnksIGFueT5cbiAgICAgIHwgV2Vha01hcDxhbnksIGFueT5cbiAgICAgIHwgU2V0PGFueT5cbiAgICAgIHwgV2Vha1NldDxhbnk+XG4gICAgICB8IFByb21pc2U8YW55PlxuICA/IG51bGxcbiAgOiBUIGV4dGVuZHMgQXJyYXk8aW5mZXIgRT5cbiAgPyBUIGV4dGVuZHMgSXNUdXBsZTxUPlxuICAgID8gbnVsbFxuICAgIDogU3RydWN0PEU+XG4gIDogVCBleHRlbmRzIG9iamVjdFxuICA/IFQgZXh0ZW5kcyBJc1JlY29yZDxUPlxuICAgID8gbnVsbFxuICAgIDogeyBbSyBpbiBrZXlvZiBUXTogRGVzY3JpYmU8VFtLXT4gfVxuICA6IG51bGxcblxuLyoqXG4gKiBBIHNjaGVtYSBmb3IgdHVwbGUgc3RydWN0cy5cbiAqL1xuXG5leHBvcnQgdHlwZSBUdXBsZVNjaGVtYTxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFN0cnVjdDxUW0tdPiB9XG5cbi8qKlxuICogU2hvcnRoYW5kIHR5cGUgZm9yIG1hdGNoaW5nIGFueSBgU3RydWN0YC5cbiAqL1xuXG5leHBvcnQgdHlwZSBBbnlTdHJ1Y3QgPSBTdHJ1Y3Q8YW55LCBhbnk+XG5cbi8qKlxuICogSW5mZXIgYSB0dXBsZSBvZiB0eXBlcyBmcm9tIGEgdHVwbGUgb2YgYFN0cnVjdGBzLlxuICpcbiAqIFRoaXMgaXMgdXNlZCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgdHlwZSBmcm9tIGB1bmlvbmAgYGludGVyc2VjdGlvbmAgYW5kXG4gKiBgdHVwbGVgIHN0cnVjdHMuXG4gKi9cblxuZXhwb3J0IHR5cGUgSW5mZXJTdHJ1Y3RUdXBsZTxcbiAgVHVwbGUgZXh0ZW5kcyBBbnlTdHJ1Y3RbXSxcbiAgTGVuZ3RoIGV4dGVuZHMgbnVtYmVyID0gVHVwbGVbJ2xlbmd0aCddXG4+ID0gTGVuZ3RoIGV4dGVuZHMgTGVuZ3RoXG4gID8gbnVtYmVyIGV4dGVuZHMgTGVuZ3RoXG4gICAgPyBUdXBsZVxuICAgIDogX0luZmVyVHVwbGU8VHVwbGUsIExlbmd0aCwgW10+XG4gIDogbmV2ZXJcbnR5cGUgX0luZmVyVHVwbGU8XG4gIFR1cGxlIGV4dGVuZHMgQW55U3RydWN0W10sXG4gIExlbmd0aCBleHRlbmRzIG51bWJlcixcbiAgQWNjdW11bGF0ZWQgZXh0ZW5kcyB1bmtub3duW10sXG4gIEluZGV4IGV4dGVuZHMgbnVtYmVyID0gQWNjdW11bGF0ZWRbJ2xlbmd0aCddXG4+ID0gSW5kZXggZXh0ZW5kcyBMZW5ndGhcbiAgPyBBY2N1bXVsYXRlZFxuICA6IF9JbmZlclR1cGxlPFR1cGxlLCBMZW5ndGgsIFsuLi5BY2N1bXVsYXRlZCwgSW5mZXI8VHVwbGVbSW5kZXhdPl0+XG4iLCJpbXBvcnQgeyB0b0ZhaWx1cmVzLCBzaGlmdEl0ZXJhdG9yLCBTdHJ1Y3RTY2hlbWEsIHJ1biB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgeyBTdHJ1Y3RFcnJvciwgRmFpbHVyZSB9IGZyb20gJy4vZXJyb3InXG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuXG5leHBvcnQgY2xhc3MgU3RydWN0PFQgPSB1bmtub3duLCBTID0gdW5rbm93bj4ge1xuICByZWFkb25seSBUWVBFITogVFxuICB0eXBlOiBzdHJpbmdcbiAgc2NoZW1hOiBTXG4gIGNvZXJjZXI6ICh2YWx1ZTogdW5rbm93biwgY29udGV4dDogQ29udGV4dCkgPT4gdW5rbm93blxuICB2YWxpZGF0b3I6ICh2YWx1ZTogdW5rbm93biwgY29udGV4dDogQ29udGV4dCkgPT4gSXRlcmFibGU8RmFpbHVyZT5cbiAgcmVmaW5lcjogKHZhbHVlOiBULCBjb250ZXh0OiBDb250ZXh0KSA9PiBJdGVyYWJsZTxGYWlsdXJlPlxuICBlbnRyaWVzOiAoXG4gICAgdmFsdWU6IHVua25vd24sXG4gICAgY29udGV4dDogQ29udGV4dFxuICApID0+IEl0ZXJhYmxlPFtzdHJpbmcgfCBudW1iZXIsIHVua25vd24sIFN0cnVjdDxhbnk+IHwgU3RydWN0PG5ldmVyPl0+XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IHtcbiAgICB0eXBlOiBzdHJpbmdcbiAgICBzY2hlbWE6IFNcbiAgICBjb2VyY2VyPzogQ29lcmNlclxuICAgIHZhbGlkYXRvcj86IFZhbGlkYXRvclxuICAgIHJlZmluZXI/OiBSZWZpbmVyPFQ+XG4gICAgZW50cmllcz86IFN0cnVjdDxULCBTPlsnZW50cmllcyddXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgc2NoZW1hLFxuICAgICAgdmFsaWRhdG9yLFxuICAgICAgcmVmaW5lcixcbiAgICAgIGNvZXJjZXIgPSAodmFsdWU6IHVua25vd24pID0+IHZhbHVlLFxuICAgICAgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7fSxcbiAgICB9ID0gcHJvcHNcblxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYVxuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXNcbiAgICB0aGlzLmNvZXJjZXIgPSBjb2VyY2VyXG5cbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpXG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW11cbiAgICB9XG5cbiAgICBpZiAocmVmaW5lcikge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGNvbnRleHQpXG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmaW5lciA9ICgpID0+IFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgKi9cblxuICBhc3NlcnQodmFsdWU6IHVua25vd24pOiBhc3NlcnRzIHZhbHVlIGlzIFQge1xuICAgIHJldHVybiBhc3NlcnQodmFsdWUsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAqL1xuXG4gIGNyZWF0ZSh2YWx1ZTogdW5rbm93bik6IFQge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAqL1xuXG4gIGlzKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgVCB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIE1hc2sgYSB2YWx1ZSwgY29lcmNpbmcgYW5kIHZhbGlkYXRpbmcgaXQsIGJ1dCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mXG4gICAqIHByb3BlcnRpZXMgZGVmaW5lZCBieSB0aGUgc3RydWN0J3Mgc2NoZW1hLlxuICAgKi9cblxuICBtYXNrKHZhbHVlOiB1bmtub3duKTogVCB7XG4gICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICpcbiAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgKi9cblxuICB2YWxpZGF0ZShcbiAgICB2YWx1ZTogdW5rbm93bixcbiAgICBvcHRpb25zOiB7XG4gICAgICBjb2VyY2U/OiBib29sZWFuXG4gICAgfSA9IHt9XG4gICk6IFtTdHJ1Y3RFcnJvciwgdW5kZWZpbmVkXSB8IFt1bmRlZmluZWQsIFRdIHtcbiAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0PFQsIFM+KFxuICB2YWx1ZTogdW5rbm93bixcbiAgc3RydWN0OiBTdHJ1Y3Q8VCwgUz5cbik6IGFzc2VydHMgdmFsdWUgaXMgVCB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpXG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgY29lcmNpb24gbG9naWMgb2Ygc3RydWN0IGFuZCB2YWxpZGF0ZSBpdC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlPFQsIFM+KHZhbHVlOiB1bmtub3duLCBzdHJ1Y3Q6IFN0cnVjdDxULCBTPik6IFQge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSB9KVxuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdXG4gIH1cbn1cblxuLyoqXG4gKiBNYXNrIGEgdmFsdWUsIHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyBkZWZpbmVkIGJ5IGEgc3RydWN0LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXNrPFQsIFM+KHZhbHVlOiB1bmtub3duLCBzdHJ1Y3Q6IFN0cnVjdDxULCBTPik6IFQge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWFzazogdHJ1ZSB9KVxuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXM8VCwgUz4odmFsdWU6IHVua25vd24sIHN0cnVjdDogU3RydWN0PFQsIFM+KTogdmFsdWUgaXMgVCB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpXG4gIHJldHVybiAhcmVzdWx0WzBdXG59XG5cbi8qKlxuICogVmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCByZXR1cm5pbmcgYW4gZXJyb3IgaWYgaW52YWxpZCwgb3IgdGhlXG4gKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZTxULCBTPihcbiAgdmFsdWU6IHVua25vd24sXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICBvcHRpb25zOiB7XG4gICAgY29lcmNlPzogYm9vbGVhblxuICAgIG1hc2s/OiBib29sZWFuXG4gIH0gPSB7fVxuKTogW1N0cnVjdEVycm9yLCB1bmRlZmluZWRdIHwgW3VuZGVmaW5lZCwgVF0ge1xuICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucylcbiAgY29uc3QgdHVwbGUgPSBzaGlmdEl0ZXJhdG9yKHR1cGxlcykhXG5cbiAgaWYgKHR1cGxlWzBdKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHQgb2YgdHVwbGVzKSB7XG4gICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgeWllbGQgdFswXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2ID0gdHVwbGVbMV1cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl1cbiAgfVxufVxuXG4vKipcbiAqIEEgYENvbnRleHRgIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGxvY2F0aW9uIG9mIHRoZVxuICogdmFsaWRhdGlvbiBpbnNpZGUgdGhlIGluaXRpYWwgaW5wdXQgdmFsdWUuXG4gKi9cblxuZXhwb3J0IHR5cGUgQ29udGV4dCA9IHtcbiAgYnJhbmNoOiBBcnJheTxhbnk+XG4gIHBhdGg6IEFycmF5PGFueT5cbn1cblxuLyoqXG4gKiBBIHR5cGUgdXRpbGl0eSB0byBleHRyYWN0IHRoZSB0eXBlIGZyb20gYSBgU3RydWN0YCBjbGFzcy5cbiAqL1xuXG5leHBvcnQgdHlwZSBJbmZlcjxUIGV4dGVuZHMgU3RydWN0PGFueSwgYW55Pj4gPSBUWydUWVBFJ11cblxuLyoqXG4gKiBBIHR5cGUgdXRpbGl0eSB0byBkZXNjcmliZSB0aGF0IGEgc3RydWN0IHJlcHJlc2VudHMgYSBUeXBlU2NyaXB0IHR5cGUuXG4gKi9cblxuZXhwb3J0IHR5cGUgRGVzY3JpYmU8VD4gPSBTdHJ1Y3Q8VCwgU3RydWN0U2NoZW1hPFQ+PlxuXG4vKipcbiAqIEEgYFJlc3VsdGAgaXMgcmV0dXJuZWQgZnJvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy5cbiAqL1xuXG5leHBvcnQgdHlwZSBSZXN1bHQgPVxuICB8IGJvb2xlYW5cbiAgfCBzdHJpbmdcbiAgfCBQYXJ0aWFsPEZhaWx1cmU+XG4gIHwgSXRlcmFibGU8Ym9vbGVhbiB8IHN0cmluZyB8IFBhcnRpYWw8RmFpbHVyZT4+XG5cbi8qKlxuICogQSBgQ29lcmNlcmAgdGFrZXMgYW4gdW5rbm93biB2YWx1ZSBhbmQgb3B0aW9uYWxseSBjb2VyY2VzIGl0LlxuICovXG5cbmV4cG9ydCB0eXBlIENvZXJjZXI8VCA9IHVua25vd24+ID0gKHZhbHVlOiBULCBjb250ZXh0OiBDb250ZXh0KSA9PiB1bmtub3duXG5cbi8qKlxuICogQSBgVmFsaWRhdG9yYCB0YWtlcyBhbiB1bmtub3duIHZhbHVlIGFuZCB2YWxpZGF0ZXMgaXQuXG4gKi9cblxuZXhwb3J0IHR5cGUgVmFsaWRhdG9yID0gKHZhbHVlOiB1bmtub3duLCBjb250ZXh0OiBDb250ZXh0KSA9PiBSZXN1bHRcblxuLyoqXG4gKiBBIGBSZWZpbmVyYCB0YWtlcyBhIHZhbHVlIG9mIGEga25vd24gdHlwZSBhbmQgdmFsaWRhdGVzIGl0IGFnYWluc3QgYSBmdXJ0aGVyXG4gKiBjb25zdHJhaW50LlxuICovXG5cbmV4cG9ydCB0eXBlIFJlZmluZXI8VD4gPSAodmFsdWU6IFQsIGNvbnRleHQ6IENvbnRleHQpID0+IFJlc3VsdFxuIiwiaW1wb3J0IHsgU3RydWN0LCBDb250ZXh0LCBWYWxpZGF0b3IgfSBmcm9tICcuLi9zdHJ1Y3QnXG5pbXBvcnQgeyBvYmplY3QsIG9wdGlvbmFsLCB0eXBlIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB7IE9iamVjdFNjaGVtYSwgQXNzaWduLCBPYmplY3RUeXBlLCBQYXJ0aWFsT2JqZWN0U2NoZW1hIH0gZnJvbSAnLi4vdXRpbHMnXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCB0aGF0IGNvbWJpbmVzIHRoZSBwcm9wZXJ0aWVzIHByb3BlcnRpZXMgZnJvbSBtdWx0aXBsZVxuICogb2JqZWN0IG9yIHR5cGUgc3RydWN0cy4gSXRzIHJldHVybiB0eXBlIHdpbGwgbWF0Y2ggdGhlIGZpcnN0IHBhcmFtZXRlcidzIHR5cGUuXG4gKlxuICogTGlrZSBKYXZhU2NyaXB0J3MgYE9iamVjdC5hc3NpZ25gIHV0aWxpdHkuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxBIGV4dGVuZHMgT2JqZWN0U2NoZW1hLCBCIGV4dGVuZHMgT2JqZWN0U2NoZW1hPihcbiAgQTogU3RydWN0PE9iamVjdFR5cGU8QT4sIEE+LFxuICBCOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxCPiwgQj5cbik6IFN0cnVjdDxPYmplY3RUeXBlPEFzc2lnbjxBLCBCPj4sIEFzc2lnbjxBLCBCPj5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248XG4gIEEgZXh0ZW5kcyBPYmplY3RTY2hlbWEsXG4gIEIgZXh0ZW5kcyBPYmplY3RTY2hlbWEsXG4gIEMgZXh0ZW5kcyBPYmplY3RTY2hlbWFcbj4oXG4gIEE6IFN0cnVjdDxPYmplY3RUeXBlPEE+LCBBPixcbiAgQjogU3RydWN0PE9iamVjdFR5cGU8Qj4sIEI+LFxuICBDOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxDPiwgQz5cbik6IFN0cnVjdDxPYmplY3RUeXBlPEFzc2lnbjxBc3NpZ248QSwgQj4sIEM+PiwgQXNzaWduPEFzc2lnbjxBLCBCPiwgQz4+XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFxuICBBIGV4dGVuZHMgT2JqZWN0U2NoZW1hLFxuICBCIGV4dGVuZHMgT2JqZWN0U2NoZW1hLFxuICBDIGV4dGVuZHMgT2JqZWN0U2NoZW1hLFxuICBEIGV4dGVuZHMgT2JqZWN0U2NoZW1hXG4+KFxuICBBOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxBPiwgQT4sXG4gIEI6IFN0cnVjdDxPYmplY3RUeXBlPEI+LCBCPixcbiAgQzogU3RydWN0PE9iamVjdFR5cGU8Qz4sIEM+LFxuICBEOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxEPiwgRD5cbik6IFN0cnVjdDxcbiAgT2JqZWN0VHlwZTxBc3NpZ248QXNzaWduPEFzc2lnbjxBLCBCPiwgQz4sIEQ+PixcbiAgQXNzaWduPEFzc2lnbjxBc3NpZ248QSwgQj4sIEM+LCBEPlxuPlxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxcbiAgQSBleHRlbmRzIE9iamVjdFNjaGVtYSxcbiAgQiBleHRlbmRzIE9iamVjdFNjaGVtYSxcbiAgQyBleHRlbmRzIE9iamVjdFNjaGVtYSxcbiAgRCBleHRlbmRzIE9iamVjdFNjaGVtYSxcbiAgRSBleHRlbmRzIE9iamVjdFNjaGVtYVxuPihcbiAgQTogU3RydWN0PE9iamVjdFR5cGU8QT4sIEE+LFxuICBCOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxCPiwgQj4sXG4gIEM6IFN0cnVjdDxPYmplY3RUeXBlPEM+LCBDPixcbiAgRDogU3RydWN0PE9iamVjdFR5cGU8RD4sIEQ+LFxuICBFOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxFPiwgRT5cbik6IFN0cnVjdDxcbiAgT2JqZWN0VHlwZTxBc3NpZ248QXNzaWduPEFzc2lnbjxBc3NpZ248QSwgQj4sIEM+LCBEPiwgRT4+LFxuICBBc3NpZ248QXNzaWduPEFzc2lnbjxBc3NpZ248QSwgQj4sIEM+LCBEPiwgRT5cbj5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oLi4uU3RydWN0czogU3RydWN0PGFueT5bXSk6IGFueSB7XG4gIGNvbnN0IGlzVHlwZSA9IFN0cnVjdHNbMF0udHlwZSA9PT0gJ3R5cGUnXG4gIGNvbnN0IHNjaGVtYXMgPSBTdHJ1Y3RzLm1hcCgocykgPT4gcy5zY2hlbWEpXG4gIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpXG4gIHJldHVybiBpc1R5cGUgPyB0eXBlKHNjaGVtYSkgOiBvYmplY3Qoc2NoZW1hKVxufVxuXG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZTxUPihuYW1lOiBzdHJpbmcsIHZhbGlkYXRvcjogVmFsaWRhdG9yKTogU3RydWN0PFQsIG51bGw+IHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyB0eXBlOiBuYW1lLCBzY2hlbWE6IG51bGwsIHZhbGlkYXRvciB9KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgc3RydWN0LCBidXQgdGhlIHZhbHVlIGlzIGFsbG93ZWQgdG9cbiAqIGJlIGB1bmRlZmluZWRgLiBgbG9nYCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVkPFQ+KFxuICBzdHJ1Y3Q6IFN0cnVjdDxUPixcbiAgbG9nOiAodmFsdWU6IHVua25vd24sIGN0eDogQ29udGV4dCkgPT4gdm9pZFxuKTogU3RydWN0PFQ+IHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyh2YWx1ZSwgY3R4KVxuICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdGhlIHZhbHVlIGN1cnJlbnRseSBiZWluZyB2YWxpZGF0ZWQsIGFuZCBtdXN0XG4gKiByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHZhbGlkYXRlIGl0IHdpdGguIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBtb2RlbFxuICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljPFQ+KFxuICBmbjogKHZhbHVlOiB1bmtub3duLCBjdHg6IENvbnRleHQpID0+IFN0cnVjdDxULCBhbnk+XG4pOiBTdHJ1Y3Q8VCwgbnVsbD4ge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KVxuICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpXG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eClcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpXG4gICAgfSxcbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpXG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eClcbiAgICB9LFxuICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eClcbiAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHZhbGlkYXRpb24gaXMgcnVuIHdpdGggdGhlIHN0cnVjdCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICogd2FudCB0byBoYXZlIHNlbGYtcmVmZXJlbnRpYWwgc3RydWN0cyBmb3IgbmVzdGVkIGRhdGEgc3RydWN0dXJlcyB0byBhdm9pZCBhXG4gKiBjaXJjdWxhciBkZWZpbml0aW9uIHByb2JsZW0uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxhenk8VD4oZm46ICgpID0+IFN0cnVjdDxULCBhbnk+KTogU3RydWN0PFQsIG51bGw+IHtcbiAgbGV0IHN0cnVjdDogU3RydWN0PFQsIGFueT4gfCB1bmRlZmluZWRcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdsYXp5JyxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgc3RydWN0ID8/PSBmbigpXG4gICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eClcbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBzdHJ1Y3QgPz89IGZuKClcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpXG4gICAgfSxcbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHN0cnVjdCA/Pz0gZm4oKVxuICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpXG4gICAgfSxcbiAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHN0cnVjdCA/Pz0gZm4oKVxuICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBleGNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYE9taXRgIHV0aWxpdHkuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9taXQ8UyBleHRlbmRzIE9iamVjdFNjaGVtYSwgSyBleHRlbmRzIGtleW9mIFM+KFxuICBzdHJ1Y3Q6IFN0cnVjdDxPYmplY3RUeXBlPFM+LCBTPixcbiAga2V5czogS1tdXG4pOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxPbWl0PFMsIEs+PiwgT21pdDxTLCBLPj4ge1xuICBjb25zdCB7IHNjaGVtYSB9ID0gc3RydWN0XG4gIGNvbnN0IHN1YnNjaGVtYTogYW55ID0geyAuLi5zY2hlbWEgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgc3Vic2NoZW1hW2tleV1cbiAgfVxuXG4gIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICBjYXNlICd0eXBlJzpcbiAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSBhcyBPbWl0PFMsIEs+KVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSBhcyBPbWl0PFMsIEs+KVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgd2l0aCBhbGwgb2YgaXRzXG4gKiBwcm9wZXJ0aWVzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBhcnRpYWxgIHV0aWxpdHkuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWw8UyBleHRlbmRzIE9iamVjdFNjaGVtYT4oXG4gIHN0cnVjdDogU3RydWN0PE9iamVjdFR5cGU8Uz4sIFM+IHwgU1xuKTogU3RydWN0PE9iamVjdFR5cGU8UGFydGlhbE9iamVjdFNjaGVtYTxTPj4sIFBhcnRpYWxPYmplY3RTY2hlbWE8Uz4+IHtcbiAgY29uc3Qgc2NoZW1hOiBhbnkgPVxuICAgIHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYSB9IDogeyAuLi5zdHJ1Y3QgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pXG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHNjaGVtYSkgYXMgYW55XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBpY2s8UyBleHRlbmRzIE9iamVjdFNjaGVtYSwgSyBleHRlbmRzIGtleW9mIFM+KFxuICBzdHJ1Y3Q6IFN0cnVjdDxPYmplY3RUeXBlPFM+LCBTPixcbiAga2V5czogS1tdXG4pOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxQaWNrPFMsIEs+PiwgUGljazxTLCBLPj4ge1xuICBjb25zdCB7IHNjaGVtYSB9ID0gc3RydWN0XG4gIGNvbnN0IHN1YnNjaGVtYTogYW55ID0ge31cblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgc3Vic2NoZW1hW2tleV0gPSBzY2hlbWFba2V5XVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEgYXMgUGljazxTLCBLPilcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICpcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBgZGVmaW5lYC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RydWN0PFQ+KG5hbWU6IHN0cmluZywgdmFsaWRhdG9yOiBWYWxpZGF0b3IpOiBTdHJ1Y3Q8VCwgbnVsbD4ge1xuICBjb25zb2xlLndhcm4oXG4gICAgJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJ1xuICApXG5cbiAgcmV0dXJuIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpXG59XG4iLCJpbXBvcnQgeyBJbmZlciwgU3RydWN0IH0gZnJvbSAnLi4vc3RydWN0J1xuaW1wb3J0IHsgZGVmaW5lIH0gZnJvbSAnLi91dGlsaXRpZXMnXG5pbXBvcnQge1xuICBPYmplY3RTY2hlbWEsXG4gIE9iamVjdFR5cGUsXG4gIHByaW50LFxuICBydW4sXG4gIGlzT2JqZWN0LFxuICBBbnlTdHJ1Y3QsXG4gIEluZmVyU3RydWN0VHVwbGUsXG4gIFVuaW9uVG9JbnRlcnNlY3Rpb24sXG59IGZyb20gJy4uL3V0aWxzJ1xuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW55KCk6IFN0cnVjdDxhbnksIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnYW55JywgKCkgPT4gdHJ1ZSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGFycmF5IGFuZCB0aGF0IGl0cyBlbGVtZW50cyBhcmUgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIE5vdGU6IElmIHlvdSBvbWl0IHRoZSBlbGVtZW50IHN0cnVjdCwgdGhlIGFycmF5cyBlbGVtZW50cyB3aWxsIG5vdCBiZVxuICogaXRlcmF0ZWQgYXQgYWxsLiBUaGlzIGNhbiBiZSBoZWxwZnVsIGZvciBjYXNlcyB3aGVyZSBwZXJmb3JtYW5jZSBpcyBjcml0aWNhbCxcbiAqIGFuZCBpdCBpcyBwcmVmZXJyZWQgdG8gdXNpbmcgYGFycmF5KGFueSgpKWAuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5PFQgZXh0ZW5kcyBTdHJ1Y3Q8YW55Pj4oRWxlbWVudDogVCk6IFN0cnVjdDxJbmZlcjxUPltdLCBUPlxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5KCk6IFN0cnVjdDx1bmtub3duW10sIHVuZGVmaW5lZD5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheTxUIGV4dGVuZHMgU3RydWN0PGFueT4+KEVsZW1lbnQ/OiBUKTogYW55IHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgc2NoZW1hOiBFbGVtZW50LFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaSwgdiwgRWxlbWVudF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlXG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gXG4gICAgICApXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiaWdpbnQoKTogU3RydWN0PGJpZ2ludCwgbnVsbD4ge1xuICByZXR1cm4gZGVmaW5lKCdiaWdpbnQnLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50J1xuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBib29sZWFuKCk6IFN0cnVjdDxib29sZWFuLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkYXRlKCk6IFN0cnVjdDxEYXRlLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ2RhdGUnLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICApXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBvbmUgb2YgYSBzZXQgb2YgcG90ZW50aWFsIHZhbHVlcy5cbiAqXG4gKiBOb3RlOiBhZnRlciBjcmVhdGluZyB0aGUgc3RydWN0LCB5b3UgY2FuIGFjY2VzcyB0aGUgZGVmaW5pdGlvbiBvZiB0aGVcbiAqIHBvdGVudGlhbCB2YWx1ZXMgYXMgYHN0cnVjdC5zY2hlbWFgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbnVtczxUIGV4dGVuZHMgbnVtYmVyPihcbiAgdmFsdWVzOiByZWFkb25seSBUW11cbik6IFN0cnVjdDxULCB7IFtLIGluIFRbXVtudW1iZXJdXTogSyB9PlxuZXhwb3J0IGZ1bmN0aW9uIGVudW1zPFQgZXh0ZW5kcyBzdHJpbmc+KFxuICB2YWx1ZXM6IHJlYWRvbmx5IFRbXVxuKTogU3RydWN0PFQsIHsgW0sgaW4gVFtdW251bWJlcl1dOiBLIH0+XG5leHBvcnQgZnVuY3Rpb24gZW51bXM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZz4odmFsdWVzOiByZWFkb25seSBUW10pOiBhbnkge1xuICBjb25zdCBzY2hlbWE6IGFueSA9IHt9XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVzLm1hcCgodikgPT4gcHJpbnQodikpLmpvaW4oKVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgIHNjaGVtYVtrZXldID0ga2V5XG4gIH1cblxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2VudW1zJyxcbiAgICBzY2hlbWEsXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZXMuaW5jbHVkZXModmFsdWUgYXMgYW55KSB8fFxuICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnVuYygpOiBTdHJ1Y3Q8RnVuY3Rpb24sIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnZnVuYycsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICApXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIHNwZWNpZmljIGNsYXNzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnN0YW5jZTxUIGV4dGVuZHMgeyBuZXcgKC4uLmFyZ3M6IGFueSk6IGFueSB9PihcbiAgQ2xhc3M6IFRcbik6IFN0cnVjdDxJbnN0YW5jZVR5cGU8VD4sIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBDbGFzcyB8fFxuICAgICAgYEV4cGVjdGVkIGEgXFxgJHtDbGFzcy5uYW1lfVxcYCBpbnN0YW5jZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gXG4gICAgKVxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlcigpOiBTdHJ1Y3Q8bnVtYmVyLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ2ludGVnZXInLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgIGBFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICApXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIGFsbCBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0aW9uPEEgZXh0ZW5kcyBBbnlTdHJ1Y3QsIEIgZXh0ZW5kcyBBbnlTdHJ1Y3RbXT4oXG4gIFN0cnVjdHM6IFtBLCAuLi5CXVxuKTogU3RydWN0PEluZmVyPEE+ICYgVW5pb25Ub0ludGVyc2VjdGlvbjxJbmZlclN0cnVjdFR1cGxlPEI+W251bWJlcl0+LCBudWxsPiB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnaW50ZXJzZWN0aW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KVxuICAgICAgfVxuICAgIH0sXG4gICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy52YWxpZGF0b3IodmFsdWUsIGN0eClcbiAgICAgIH1cbiAgICB9LFxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eClcbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gZXhhY3QgdmFsdWUsIHVzaW5nIGA9PT1gIGZvciBjb21wYXJpc29uLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsPFQgZXh0ZW5kcyBib29sZWFuPihjb25zdGFudDogVCk6IFN0cnVjdDxULCBUPlxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWw8VCBleHRlbmRzIG51bWJlcj4oY29uc3RhbnQ6IFQpOiBTdHJ1Y3Q8VCwgVD5cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsPFQgZXh0ZW5kcyBzdHJpbmc+KGNvbnN0YW50OiBUKTogU3RydWN0PFQsIFQ+XG5leHBvcnQgZnVuY3Rpb24gbGl0ZXJhbDxUPihjb25zdGFudDogVCk6IFN0cnVjdDxULCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWw8VD4oY29uc3RhbnQ6IFQpOiBhbnkge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KVxuICBjb25zdCB0ID0gdHlwZW9mIGNvbnN0YW50XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgc2NoZW1hOlxuICAgICAgdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdmFsdWUgPT09IGNvbnN0YW50IHx8XG4gICAgICAgIGBFeHBlY3RlZCB0aGUgbGl0ZXJhbCBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gXG4gICAgICApXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYE1hcGAgb2JqZWN0LCBhbmQgdGhhdCBpdHMga2V5cyBhbmQgdmFsdWVzIGFyZSBvZlxuICogc3BlY2lmaWMgdHlwZXMuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcCgpOiBTdHJ1Y3Q8TWFwPHVua25vd24sIHVua25vd24+LCBudWxsPlxuZXhwb3J0IGZ1bmN0aW9uIG1hcDxLLCBWPihcbiAgS2V5OiBTdHJ1Y3Q8Sz4sXG4gIFZhbHVlOiBTdHJ1Y3Q8Vj5cbik6IFN0cnVjdDxNYXA8SywgVj4sIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gbWFwPEssIFY+KEtleT86IFN0cnVjdDxLPiwgVmFsdWU/OiBTdHJ1Y3Q8Vj4pOiBhbnkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ21hcCcsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtrIGFzIHN0cmluZywgaywgS2V5XVxuICAgICAgICAgIHlpZWxkIFtrIGFzIHN0cmluZywgdiwgVmFsdWVdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWVcbiAgICB9LFxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgYEV4cGVjdGVkIGEgXFxgTWFwXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gXG4gICAgICApXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBuZXZlcigpOiBTdHJ1Y3Q8bmV2ZXIsIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSlcbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBudWxsYWJsZTxULCBTPihzdHJ1Y3Q6IFN0cnVjdDxULCBTPik6IFN0cnVjdDxUIHwgbnVsbCwgUz4ge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgLi4uc3RydWN0LFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlcigpOiBTdHJ1Y3Q8bnVtYmVyLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICApXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoYXQgaXMgaGFzIGEga25vd24gc2V0IG9mIHByb3BlcnRpZXMsXG4gKiBhbmQgdGhhdCBpdHMgcHJvcGVydGllcyBhcmUgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgd2lsbCBmYWlsIHZhbGlkYXRpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdCgpOiBTdHJ1Y3Q8UmVjb3JkPHN0cmluZywgdW5rbm93bj4sIG51bGw+XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0PFMgZXh0ZW5kcyBPYmplY3RTY2hlbWE+KFxuICBzY2hlbWE6IFNcbik6IFN0cnVjdDxPYmplY3RUeXBlPFM+LCBTPlxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdDxTIGV4dGVuZHMgT2JqZWN0U2NoZW1hPihzY2hlbWE/OiBTKTogYW55IHtcbiAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdXG4gIGNvbnN0IE5ldmVyID0gbmV2ZXIoKVxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgIHVua25vd25zLmRlbGV0ZShrZXkpXG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIE5ldmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsPFQsIFM+KHN0cnVjdDogU3RydWN0PFQsIFM+KTogU3RydWN0PFQgfCB1bmRlZmluZWQsIFM+IHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PlxuICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGgga2V5cyBhbmQgdmFsdWVzIG9mIHNwZWNpZmljIHR5cGVzLCBidXRcbiAqIHdpdGhvdXQgZW5zdXJpbmcgYW55IHNwZWNpZmljIHNoYXBlIG9mIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFJlY29yZGAgdXRpbGl0eS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcsIFY+KFxuICBLZXk6IFN0cnVjdDxLPixcbiAgVmFsdWU6IFN0cnVjdDxWPlxuKTogU3RydWN0PFJlY29yZDxLLCBWPiwgbnVsbD4ge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3JlY29yZCcsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtrXVxuICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldXG4gICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgUmVnRXhwYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAqIHlvdSBuZWVkIHRvIHVzZSB0aGUgYHBhdHRlcm4oKWAgcmVmaW5lbWVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnZXhwKCk6IFN0cnVjdDxSZWdFeHAsIG51bGw+IHtcbiAgcmV0dXJuIGRlZmluZSgncmVnZXhwJywgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBTZXRgIG9iamVjdCwgYW5kIHRoYXQgaXRzIGVsZW1lbnRzIGFyZSBvZiBhXG4gKiBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQoKTogU3RydWN0PFNldDx1bmtub3duPiwgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBzZXQ8VD4oRWxlbWVudDogU3RydWN0PFQ+KTogU3RydWN0PFNldDxUPiwgbnVsbD5cbmV4cG9ydCBmdW5jdGlvbiBzZXQ8VD4oRWxlbWVudD86IFN0cnVjdDxUPik6IGFueSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgIHlpZWxkIFt2IGFzIHN0cmluZywgdiwgRWxlbWVudF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFNldCB8fFxuICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZygpOiBTdHJ1Y3Q8c3RyaW5nLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICBgRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YFxuICAgIClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPEEgZXh0ZW5kcyBBbnlTdHJ1Y3QsIEIgZXh0ZW5kcyBBbnlTdHJ1Y3RbXT4oXG4gIFN0cnVjdHM6IFtBLCAuLi5CXVxuKTogU3RydWN0PFtJbmZlcjxBPiwgLi4uSW5mZXJTdHJ1Y3RUdXBsZTxCPl0sIG51bGw+IHtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpXG5cbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd0dXBsZScsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoU3RydWN0cy5sZW5ndGgsIHZhbHVlLmxlbmd0aClcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgeWllbGQgW2ksIHZhbHVlW2ldLCBTdHJ1Y3RzW2ldIHx8IE5ldmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgIGBFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gXG4gICAgICApXG4gICAgfSxcbiAgfSlcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIGFyZSBhbGxvd2VkIGFuZCB1bnRvdWNoZWQuIFRoaXMgaXMgc2ltaWxhciB0b1xuICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHlwZTxTIGV4dGVuZHMgT2JqZWN0U2NoZW1hPihcbiAgc2NoZW1hOiBTXG4pOiBTdHJ1Y3Q8T2JqZWN0VHlwZTxTPiwgUz4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKVxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R5cGUnLFxuICAgIHNjaGVtYSxcbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWBcbiAgICAgIClcbiAgICB9LFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uPEEgZXh0ZW5kcyBBbnlTdHJ1Y3QsIEIgZXh0ZW5kcyBBbnlTdHJ1Y3RbXT4oXG4gIFN0cnVjdHM6IFtBLCAuLi5CXVxuKTogU3RydWN0PEluZmVyPEE+IHwgSW5mZXJTdHJ1Y3RUdXBsZTxCPltudW1iZXJdLCBudWxsPiB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAoKHMpID0+IHMudHlwZSkuam9pbignIHwgJylcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd1bmlvbicsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmlyc3RNYXRjaCA9XG4gICAgICAgIFN0cnVjdHMuZmluZCgocykgPT4ge1xuICAgICAgICAgIGNvbnN0IFtlXSA9IHMudmFsaWRhdGUodmFsdWUsIHsgY29lcmNlOiB0cnVlIH0pXG4gICAgICAgICAgcmV0dXJuICFlXG4gICAgICAgIH0pIHx8IHVua25vd24oKVxuICAgICAgcmV0dXJuIGZpcnN0TWF0Y2guY29lcmNlcih2YWx1ZSwgY3R4KVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gW11cblxuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIFMsIGN0eClcbiAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlc1xuXG4gICAgICAgIGlmICghZmlyc3RbMF0pIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludChcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICApfWAsXG4gICAgICAgIC4uLmZhaWx1cmVzLFxuICAgICAgXVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLCB3aXRob3V0IHdpZGVuaW5nIGl0cyB0eXBlIHRvIGBhbnlgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB1bmtub3duKCk6IFN0cnVjdDx1bmtub3duLCBudWxsPiB7XG4gIHJldHVybiBkZWZpbmUoJ3Vua25vd24nLCAoKSA9PiB0cnVlKVxufVxuIiwiaW1wb3J0IHsgU3RydWN0LCBpcywgQ29lcmNlciB9IGZyb20gJy4uL3N0cnVjdCdcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IHN0cmluZywgdW5rbm93biB9IGZyb20gJy4vdHlwZXMnXG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZTxULCBTLCBDPihcbiAgc3RydWN0OiBTdHJ1Y3Q8VCwgUz4sXG4gIGNvbmRpdGlvbjogU3RydWN0PEMsIGFueT4sXG4gIGNvZXJjZXI6IENvZXJjZXI8Qz5cbik6IFN0cnVjdDxULCBTPiB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAuLi5zdHJ1Y3QsXG4gICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eClcbiAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KVxuICAgIH0sXG4gIH0pXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdGVkPFQsIFM+KFxuICBzdHJ1Y3Q6IFN0cnVjdDxULCBTPixcbiAgZmFsbGJhY2s6IGFueSxcbiAgb3B0aW9uczoge1xuICAgIHN0cmljdD86IGJvb2xlYW5cbiAgfSA9IHt9XG4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCAoeCkgPT4ge1xuICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2tcblxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgLi4ueCB9XG4gICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlXG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGZba2V5XVxuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4XG4gIH0pXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyaW1tZWQ8VCwgUz4oc3RydWN0OiBTdHJ1Y3Q8VCwgUz4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgc3RyaW5nKCksICh4KSA9PiB4LnRyaW0oKSlcbn1cbiIsImltcG9ydCB7IFN0cnVjdCwgUmVmaW5lciB9IGZyb20gJy4uL3N0cnVjdCdcbmltcG9ydCB7IHRvRmFpbHVyZXMgfSBmcm9tICcuLi91dGlscydcblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eTxcbiAgVCBleHRlbmRzIHN0cmluZyB8IGFueVtdIHwgTWFwPGFueSwgYW55PiB8IFNldDxhbnk+LFxuICBTIGV4dGVuZHMgYW55XG4+KHN0cnVjdDogU3RydWN0PFQsIFM+KTogU3RydWN0PFQsIFM+IHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKVxuICAgIHJldHVybiAoXG4gICAgICBzaXplID09PSAwIHx8XG4gICAgICBgRXhwZWN0ZWQgYW4gZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYFxuICAgIClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZSh2YWx1ZTogc3RyaW5nIHwgYW55W10gfCBNYXA8YW55LCBhbnk+IHwgU2V0PGFueT4pOiBudW1iZXIge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICByZXR1cm4gdmFsdWUuc2l6ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGhcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heDxUIGV4dGVuZHMgbnVtYmVyIHwgRGF0ZSwgUyBleHRlbmRzIGFueT4oXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICB0aHJlc2hvbGQ6IFQsXG4gIG9wdGlvbnM6IHtcbiAgICBleGNsdXNpdmU/OiBib29sZWFuXG4gIH0gPSB7fVxuKTogU3RydWN0PFQsIFM+IHtcbiAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnNcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICA/IHZhbHVlIDwgdGhyZXNob2xkXG4gICAgICA6IHZhbHVlIDw9IHRocmVzaG9sZCB8fFxuICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGxlc3MgdGhhbiAke1xuICAgICAgICAgICAgZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ1xuICAgICAgICAgIH0ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbjxUIGV4dGVuZHMgbnVtYmVyIHwgRGF0ZSwgUyBleHRlbmRzIGFueT4oXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICB0aHJlc2hvbGQ6IFQsXG4gIG9wdGlvbnM6IHtcbiAgICBleGNsdXNpdmU/OiBib29sZWFuXG4gIH0gPSB7fVxuKTogU3RydWN0PFQsIFM+IHtcbiAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnNcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICA/IHZhbHVlID4gdGhyZXNob2xkXG4gICAgICA6IHZhbHVlID49IHRocmVzaG9sZCB8fFxuICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke1xuICAgICAgICAgICAgZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ1xuICAgICAgICAgIH0ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYFxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vbmVtcHR5PFxuICBUIGV4dGVuZHMgc3RyaW5nIHwgYW55W10gfCBNYXA8YW55LCBhbnk+IHwgU2V0PGFueT4sXG4gIFMgZXh0ZW5kcyBhbnlcbj4oc3RydWN0OiBTdHJ1Y3Q8VCwgUz4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpXG4gICAgcmV0dXJuIChcbiAgICAgIHNpemUgPiAwIHx8IGBFeHBlY3RlZCBhIG5vbmVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVgXG4gICAgKVxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdHRlcm48VCBleHRlbmRzIHN0cmluZywgUyBleHRlbmRzIGFueT4oXG4gIHN0cnVjdDogU3RydWN0PFQsIFM+LFxuICByZWdleHA6IFJlZ0V4cFxuKTogU3RydWN0PFQsIFM+IHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJlZ2V4cC50ZXN0KHZhbHVlKSB8fFxuICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgXG4gICAgKVxuICB9KVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzaXplPFxuICBUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgRGF0ZSB8IGFueVtdIHwgTWFwPGFueSwgYW55PiB8IFNldDxhbnk+LFxuICBTIGV4dGVuZHMgYW55XG4+KHN0cnVjdDogU3RydWN0PFQsIFM+LCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIgPSBtaW4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YFxuICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gYG9mIFxcYCR7bWlufVxcYGAgOiBgYmV0d2VlbiBcXGAke21pbn1cXGAgYW5kIFxcYCR7bWF4fVxcYGBcblxuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4KSB8fFxuICAgICAgICBgJHtleHBlY3RlZH0gJHtvZn0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gdmFsdWVcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlIGFzIHN0cmluZyB8IGFueVtdXG4gICAgICByZXR1cm4gKFxuICAgICAgICAobWluIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4KSB8fFxuICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIGxlbmd0aCAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgXFxgJHtsZW5ndGh9XFxgYFxuICAgICAgKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVmaW5lPFQsIFM+KFxuICBzdHJ1Y3Q6IFN0cnVjdDxULCBTPixcbiAgbmFtZTogc3RyaW5nLFxuICByZWZpbmVyOiBSZWZpbmVyPFQ+XG4pOiBTdHJ1Y3Q8VCwgUz4ge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgLi4uc3RydWN0LFxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KVxuICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKVxuXG4gICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH1cbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/superstruct/lib/index.es.js\n");

/***/ })

}]);