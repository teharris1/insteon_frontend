"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_flow_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/flow.js":
/*!************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/flow.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FlowLayout\": () => (/* binding */ FlowLayout),\n/* harmony export */   \"flow\": () => (/* binding */ flow)\n/* harmony export */ });\n/* harmony import */ var _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/SizeCache.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\");\n/* harmony import */ var _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/BaseLayout.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\nconst flow = config => Object.assign({\n  type: FlowLayout\n}, config);\n\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a, b) {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\n\nclass MetricsCache {\n  constructor() {\n    this._childSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._marginSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._metricsCache = new Map();\n  }\n\n  update(metrics, direction) {\n    var _a, _b;\n\n    const marginsToUpdate = new Set();\n    Object.keys(metrics).forEach(key => {\n      const k = Number(key);\n\n      this._metricsCache.set(k, metrics[k]);\n\n      this._childSizeCache.set(k, metrics[k][(0,_shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.dim1)(direction)]);\n\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n\n    for (const k of marginsToUpdate) {\n      const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n      const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n\n  get averageChildSize() {\n    return this._childSizeCache.averageSize;\n  }\n\n  get totalChildSize() {\n    return this._childSizeCache.totalSize;\n  }\n\n  get averageMarginSize() {\n    return this._marginSizeCache.averageSize;\n  }\n\n  get totalMarginSize() {\n    return this._marginSizeCache.totalSize;\n  }\n\n  getLeadingMarginValue(index, direction) {\n    var _a;\n\n    return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n  }\n\n  getChildSize(index) {\n    return this._childSizeCache.getSize(index);\n  }\n\n  getMarginSize(index) {\n    return this._marginSizeCache.getSize(index);\n  }\n\n  clear() {\n    this._childSizeCache.clear();\n\n    this._marginSizeCache.clear();\n\n    this._metricsCache.clear();\n  }\n\n}\n\nclass FlowLayout extends _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.BaseLayout {\n  constructor() {\n    super(...arguments);\n    /**\n     * Initial estimate of item size\n     */\n\n    this._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n\n    this._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n\n    this._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n\n    this._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n\n    this._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n\n    this._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n\n    this._stable = true;\n    /**\n     * Whether to remeasure children during the next reflow.\n     */\n\n    this._needsRemeasure = false;\n    this._measureChildren = true;\n    this._estimate = true;\n  } // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n\n  get measureChildren() {\n    return this._measureChildren;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n\n\n  updateItemSizes(sizes) {\n    this._metricsCache.update(sizes, this.direction); // if (this._nMeasured) {\n    // this._updateItemSize();\n\n\n    this._scheduleReflow(); // }\n\n  }\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n\n\n  _getPhysicalItem(idx) {\n    var _a;\n\n    return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n  }\n\n  _getSize(idx) {\n    const item = this._getPhysicalItem(idx);\n\n    return item && this._metricsCache.getChildSize(idx);\n  }\n\n  _getAverageSize() {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n\n\n  _getPosition(idx) {\n    var _a;\n\n    const item = this._getPhysicalItem(idx);\n\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return idx === 0 ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize : item ? item.pos : averageMarginSize + idx * (averageMarginSize + this._getAverageSize());\n  }\n\n  _calculateAnchor(lower, upper) {\n    if (lower <= 0) {\n      return 0;\n    }\n\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this._totalItems - 1;\n    }\n\n    return Math.max(0, Math.min(this._totalItems - 1, Math.floor((lower + upper) / 2 / this._delta)));\n  }\n\n  _getAnchor(lower, upper) {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n\n    if (this._first < 0) {\n      console.error('_getAnchor: negative _first');\n      return this._calculateAnchor(lower, upper);\n    }\n\n    if (this._last < 0) {\n      console.error('_getAnchor: negative _last');\n      return this._calculateAnchor(lower, upper);\n    }\n\n    const firstItem = this._getPhysicalItem(this._first),\n          lastItem = this._getPhysicalItem(this._last),\n          firstMin = firstItem.pos,\n          lastMin = lastItem.pos,\n          lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    } // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n\n\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n\n      cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n    }\n\n    return candidateIdx;\n  }\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n\n\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this._totalItems === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n  /**\n   * Sets the range to empty.\n   */\n\n\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n\n    this._newPhysicalItems.clear();\n\n    this._physicalItems = items;\n    this._stable = true;\n  }\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n\n\n  _getItems() {\n    var _a, _b;\n\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper; // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n    // If we have a scrollToIndex, we anchor on the given\n    // index and set the scroll position accordingly\n\n    if (this._scrollToIndex >= 0) {\n      this._anchorIdx = Math.min(this._scrollToIndex, this._totalItems - 1);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n\n      this._scrollIfNeeded();\n    } // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n\n\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n\n      return;\n    } // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n\n\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n\n    let anchorSize = this._getSize(this._anchorIdx);\n\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n\n    let anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n    let anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n\n    if (this._anchorIdx === this._totalItems - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    } // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n\n\n    let anchorErr = 0;\n\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n\n    items.set(this._anchorIdx, {\n      pos: this._anchorPos,\n      size: anchorSize\n    });\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos;\n    this._physicalMax = this._anchorPos + anchorSize;\n\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n\n      let margin = this._metricsCache.getMarginSize(this._first + 1);\n\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n\n      this._physicalMin -= size + margin;\n      const pos = this._physicalMin;\n      items.set(this._first, {\n        pos,\n        size\n      });\n\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n\n    while (this._physicalMax < upper && this._last < this._totalItems - 1) {\n      let margin = this._metricsCache.getMarginSize(++this._last);\n\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n\n      let size = this._getSize(this._last);\n\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n\n      const pos = this._physicalMax + margin;\n      items.set(this._last, {\n        pos,\n        size\n      });\n      this._physicalMax += margin + size;\n\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    } // This handles the cases where we were relying on estimated sizes.\n\n\n    const extentErr = this._calculateError();\n\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach(item => item.pos -= extentErr);\n      this._scrollError += extentErr;\n    }\n\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n\n      this._newPhysicalItems.clear();\n\n      this._physicalItems = items;\n    }\n  }\n\n  _calculateError() {\n    var _a, _b;\n\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n\n    if (this._first === 0) {\n      return this._physicalMin - ((_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize);\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this._totalItems - 1) {\n      return this._physicalMax + ((_b = this._metricsCache.getMarginSize(this._totalItems)) !== null && _b !== void 0 ? _b : averageMarginSize) - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return this._physicalMax - this._scrollSize + (this._totalItems - 1 - this._last) * this._delta;\n    }\n\n    return 0;\n  } // TODO: Can this be made to inherit from base, with proper hooks?\n\n\n  _reflow() {\n    const {\n      _first,\n      _last,\n      _scrollSize\n    } = this;\n\n    this._updateScrollSize();\n\n    this._getActiveItems();\n\n    if (this._scrollSize !== _scrollSize) {\n      this._emitScrollSize();\n    }\n\n    this._updateVisibleIndices();\n\n    this._emitRange();\n\n    if (this._first === -1 && this._last === -1) {\n      this._resetReflowState();\n    } else if (this._first !== _first || this._last !== _last || this._needsRemeasure) {\n      this._emitChildPositions();\n\n      this._emitScrollError();\n    } else {\n      this._emitChildPositions();\n\n      this._emitScrollError();\n\n      this._resetReflowState();\n    }\n  }\n\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n\n  _updateScrollSize() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    this._scrollSize = Math.max(1, this._totalItems * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n  }\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n\n\n  get _delta() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n\n\n  _getItemPosition(idx) {\n    var _a;\n\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize)\n    };\n  }\n  /**\n   * Returns the height and width of the item at idx.\n   */\n\n\n  _getItemSize(idx) {\n    var _a;\n\n    return {\n      [this._sizeDim]: (this._getSize(idx) || this._getAverageSize()) + ((_a = this._metricsCache.getMarginSize(idx + 1)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]\n    };\n  }\n\n  _viewDim2Changed() {\n    this._needsRemeasure = true;\n\n    this._scheduleReflow();\n  }\n\n  _emitRange() {\n    const remeasure = this._needsRemeasure;\n    const stable = this._stable;\n    this._needsRemeasure = false;\n\n    super._emitRange({\n      remeasure,\n      stable\n    });\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvZmxvdy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFDQTtBQW1CQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBS0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQW1EQTs7QUFqREE7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBckRBOztBQXdEQTtBQUFBOztBQUNBOzs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7QUFHQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7O0FBR0E7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBO0FBRUE7QUFvWEE7QUFoWEE7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBRUE7OztBQUNBOztBQUVBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTs7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7Ozs7O0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBbGFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvbGF5b3V0cy9mbG93LnRzPzE4NGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7IFNpemVDYWNoZSB9IGZyb20gJy4vc2hhcmVkL1NpemVDYWNoZS5qcyc7XG5pbXBvcnQge0Jhc2VMYXlvdXQsIEJhc2VMYXlvdXRDb25maWcsIGRpbTF9IGZyb20gJy4vc2hhcmVkL0Jhc2VMYXlvdXQuanMnO1xuaW1wb3J0IHtJdGVtQm94LCBQb3NpdGlvbnMsIFNpemUsIE1hcmdpbnMsIG1hcmdpbiwgU2Nyb2xsRGlyZWN0aW9uLCBvZmZzZXRBeGlzfSBmcm9tICcuL3NoYXJlZC9MYXlvdXQuanMnO1xuXG50eXBlIEl0ZW1Cb3VuZHMgPSB7XG4gIHBvczogbnVtYmVyLFxuICBzaXplOiBudW1iZXJcbn07XG5cbnR5cGUgRmxvd0xheW91dENvbnN0cnVjdG9yID0ge1xuICBwcm90b3R5cGU6IEZsb3dMYXlvdXQsXG4gIG5ldyhjb25maWc/OiBCYXNlTGF5b3V0Q29uZmlnKTogRmxvd0xheW91dFxufVxuXG50eXBlIEZsb3dMYXlvdXRTcGVjaWZpZXIgPSBCYXNlTGF5b3V0Q29uZmlnICYge1xuICB0eXBlOiBGbG93TGF5b3V0Q29uc3RydWN0b3Jcbn1cblxudHlwZSBGbG93TGF5b3V0U3BlY2lmaWVyRmFjdG9yeSA9IChjb25maWc/OiBCYXNlTGF5b3V0Q29uZmlnKSA9PiBGbG93TGF5b3V0U3BlY2lmaWVyO1xuXG5leHBvcnQgY29uc3QgZmxvdzogRmxvd0xheW91dFNwZWNpZmllckZhY3RvcnkgPSAoY29uZmlnPzogQmFzZUxheW91dENvbmZpZykgPT4gT2JqZWN0LmFzc2lnbih7XG4gIHR5cGU6IEZsb3dMYXlvdXRcbn0sIGNvbmZpZyk7XG5cbmZ1bmN0aW9uIGxlYWRpbmdNYXJnaW4oZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBtYXJnaW4ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luVG9wJztcbn1cblxuZnVuY3Rpb24gdHJhaWxpbmdNYXJnaW4oZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBtYXJnaW4ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkJvdHRvbSc7XG59XG5cbmZ1bmN0aW9uIG9mZnNldChkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IG9mZnNldEF4aXMge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAneE9mZnNldCcgOiAneU9mZnNldCc7XG59XG5cbmZ1bmN0aW9uIGNvbGxhcHNlTWFyZ2lucyhhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG0gPSBbYSwgYl0uc29ydCgpO1xuICByZXR1cm4gbVsxXSA8PSAwXG4gID8gTWF0aC5taW4oLi4ubSlcbiAgOiBtWzBdID49IDBcbiAgICA/IE1hdGgubWF4KC4uLm0pXG4gICAgOiBtWzBdICsgbVsxXTtcbn1cblxuY2xhc3MgTWV0cmljc0NhY2hlIHtcbiAgcHJpdmF0ZSBfY2hpbGRTaXplQ2FjaGUgPSBuZXcgU2l6ZUNhY2hlKCk7XG4gIHByaXZhdGUgX21hcmdpblNpemVDYWNoZSA9IG5ldyBTaXplQ2FjaGUoKTtcbiAgcHJpdmF0ZSBfbWV0cmljc0NhY2hlOiBNYXA8bnVtYmVyLCBTaXplICYgTWFyZ2lucz4gPSBuZXcgTWFwKCk7XG5cbiAgdXBkYXRlKG1ldHJpY3M6IHtba2V5OiBudW1iZXJdOiBTaXplICYgTWFyZ2luc30sIGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgY29uc3QgbWFyZ2luc1RvVXBkYXRlOiBTZXQ8bnVtYmVyPiA9IG5ldyBTZXQoKTtcbiAgICBPYmplY3Qua2V5cyhtZXRyaWNzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGsgPSBOdW1iZXIoa2V5KTtcbiAgICAgIHRoaXMuX21ldHJpY3NDYWNoZS5zZXQoaywgbWV0cmljc1trXSk7XG4gICAgICB0aGlzLl9jaGlsZFNpemVDYWNoZS5zZXQoaywgbWV0cmljc1trXVtkaW0xKGRpcmVjdGlvbildKTtcbiAgICAgIG1hcmdpbnNUb1VwZGF0ZS5hZGQoayk7XG4gICAgICBtYXJnaW5zVG9VcGRhdGUuYWRkKGsgKyAxKTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgbWFyZ2luc1RvVXBkYXRlKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldChrKT8uW2xlYWRpbmdNYXJnaW4oZGlyZWN0aW9uKV0gfHwgMDtcbiAgICAgIGNvbnN0IGIgPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0KGsgLSAxKT8uW3RyYWlsaW5nTWFyZ2luKGRpcmVjdGlvbildIHx8IDA7XG4gICAgICB0aGlzLl9tYXJnaW5TaXplQ2FjaGUuc2V0KGssIGNvbGxhcHNlTWFyZ2lucyhhLCBiKSlcbiAgICB9XG4gIH1cblxuICBnZXQgYXZlcmFnZUNoaWxkU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZFNpemVDYWNoZS5hdmVyYWdlU2l6ZTtcbiAgfVxuXG4gIGdldCB0b3RhbENoaWxkU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZFNpemVDYWNoZS50b3RhbFNpemU7XG4gIH1cblxuICBnZXQgYXZlcmFnZU1hcmdpblNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLmF2ZXJhZ2VTaXplO1xuICB9XG5cbiAgZ2V0IHRvdGFsTWFyZ2luU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9tYXJnaW5TaXplQ2FjaGUudG90YWxTaXplO1xuICB9XG5cbiAgZ2V0TGVhZGluZ01hcmdpblZhbHVlKGluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldHJpY3NDYWNoZS5nZXQoaW5kZXgpPy5bbGVhZGluZ01hcmdpbihkaXJlY3Rpb24pXSB8fCAwO1xuICB9XG5cbiAgZ2V0Q2hpbGRTaXplKGluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRTaXplQ2FjaGUuZ2V0U2l6ZShpbmRleCk7XG4gIH1cblxuICBnZXRNYXJnaW5TaXplKGluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLmdldFNpemUoaW5kZXgpO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2hpbGRTaXplQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9tYXJnaW5TaXplQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuY2xlYXIoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmxvd0xheW91dCBleHRlbmRzIEJhc2VMYXlvdXQ8QmFzZUxheW91dENvbmZpZz4ge1xuICAvKipcbiAgICogSW5pdGlhbCBlc3RpbWF0ZSBvZiBpdGVtIHNpemVcbiAgICovXG4gIF9pdGVtU2l6ZTogU2l6ZSA9IHt3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH07XG5cbiAgLyoqXG4gICAqIEluZGljZXMgb2YgY2hpbGRyZW4gbWFwcGVkIHRvIHRoZWlyIChwb3NpdGlvbiBhbmQgbGVuZ3RoKSBpbiB0aGUgc2Nyb2xsaW5nXG4gICAqIGRpcmVjdGlvbi4gVXNlZCB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIHRoYXQgYXJlIGluIHJhbmdlLlxuICAgKi9cbiAgX3BoeXNpY2FsSXRlbXM6IE1hcDxudW1iZXIsIEl0ZW1Cb3VuZHM+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGluIHRhbmRlbSB3aXRoIF9waHlzaWNhbEl0ZW1zIHRvIHRyYWNrIGNoaWxkcmVuIGluIHJhbmdlIGFjcm9zc1xuICAgKiByZWZsb3dzLlxuICAgKi9cbiAgX25ld1BoeXNpY2FsSXRlbXM6IE1hcDxudW1iZXIsIEl0ZW1Cb3VuZHM+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBXaWR0aCBhbmQgaGVpZ2h0IG9mIGNoaWxkcmVuIGJ5IHRoZWlyIGluZGV4LlxuICAgKi9cbiAgX21ldHJpY3NDYWNoZSA9IG5ldyBNZXRyaWNzQ2FjaGUoKTtcblxuICAvKipcbiAgICogYW5jaG9ySWR4IGlzIHRoZSBhbmNob3IgYXJvdW5kIHdoaWNoIHdlIHJlZmxvdy4gSXQgaXMgZGVzaWduZWQgdG8gYWxsb3dcbiAgICoganVtcGluZyB0byBhbnkgcG9pbnQgb2YgdGhlIHNjcm9sbCBzaXplLiBXZSBjaG9vc2UgaXQgb25jZSBhbmQgc3RpY2sgd2l0aFxuICAgKiBpdCB1bnRpbCBzdGFibGUuIF9maXJzdCBhbmQgX2xhc3QgYXJlIGRlZHVjZWQgYXJvdW5kIGl0LlxuICAgKi9cbiAgX2FuY2hvcklkeDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uIG9mIHRoZSBhbmNob3IgY2hpbGQuXG4gICAqL1xuICBfYW5jaG9yUG9zOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciBhbGwgY2hpbGRyZW4gaW4gcmFuZ2Ugd2VyZSBpbiByYW5nZSBkdXJpbmcgdGhlIHByZXZpb3VzIHJlZmxvdy5cbiAgICovXG4gIF9zdGFibGUgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlbWVhc3VyZSBjaGlsZHJlbiBkdXJpbmcgdGhlIG5leHQgcmVmbG93LlxuICAgKi9cbiAgX25lZWRzUmVtZWFzdXJlID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfbWVhc3VyZUNoaWxkcmVuID0gdHJ1ZTtcblxuICBfZXN0aW1hdGUgPSB0cnVlO1xuXG4gIC8vIHByb3RlY3RlZCBfZGVmYXVsdENvbmZpZzogQmFzZUxheW91dENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLl9kZWZhdWx0Q29uZmlnLCB7XG5cbiAgLy8gfSlcblxuICAvLyBjb25zdHJ1Y3Rvcihjb25maWc6IExheW91dDFkQ29uZmlnKSB7XG4gIC8vICAgc3VwZXIoY29uZmlnKTtcbiAgLy8gfVxuXG4gIGdldCBtZWFzdXJlQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lYXN1cmVDaGlsZHJlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGF2ZXJhZ2Ugc2l6ZSBvZiBhbGwgY2hpbGRyZW4gcmVwcmVzZW50ZWQgaW4gdGhlIHNpemVzXG4gICAqIGFyZ3VtZW50LlxuICAgKi9cbiAgdXBkYXRlSXRlbVNpemVzKHNpemVzOiB7W2tleTogbnVtYmVyXTogSXRlbUJveH0pIHtcbiAgICB0aGlzLl9tZXRyaWNzQ2FjaGUudXBkYXRlKHNpemVzIGFzIFNpemUgJiBNYXJnaW5zLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgLy8gaWYgKHRoaXMuX25NZWFzdXJlZCkge1xuICAgICAgLy8gdGhpcy5fdXBkYXRlSXRlbVNpemUoKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgLy8gfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXZlcmFnZSBpdGVtIHNpemUgYmFzZWQgb24gdGhlIHRvdGFsIGxlbmd0aCBhbmQgbnVtYmVyIG9mIGNoaWxkcmVuXG4gICAqIGluIHJhbmdlLlxuICAgKi9cbiAgLy8gX3VwZGF0ZUl0ZW1TaXplKCkge1xuICAvLyAgIC8vIEtlZXAgaW50ZWdlciB2YWx1ZXMuXG4gIC8vICAgdGhpcy5faXRlbVNpemVbdGhpcy5fc2l6ZURpbV0gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZUNoaWxkU2l6ZTtcbiAgLy8gfVxuXG4gIF9nZXRQaHlzaWNhbEl0ZW0oaWR4OiBudW1iZXIpOiBJdGVtQm91bmRzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fbmV3UGh5c2ljYWxJdGVtcy5nZXQoaWR4KSA/PyB0aGlzLl9waHlzaWNhbEl0ZW1zLmdldChpZHgpO1xuICB9XG5cbiAgX2dldFNpemUoaWR4OiBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0oaWR4KTtcbiAgICByZXR1cm4gaXRlbSAmJiB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0Q2hpbGRTaXplKGlkeCk7XG4gIH1cblxuICBfZ2V0QXZlcmFnZVNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VDaGlsZFNpemUgfHwgdGhpcy5faXRlbVNpemVbdGhpcy5fc2l6ZURpbV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24gb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgKiBFc3RpbWF0ZXMgaXQgaWYgdGhlIGl0ZW0gYXQgaWR4IGlzIG5vdCBpbiB0aGUgRE9NLlxuICAgKi9cbiAgX2dldFBvc2l0aW9uKGlkeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKGlkeCk7XG4gICAgY29uc3QgeyBhdmVyYWdlTWFyZ2luU2l6ZSB9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHJldHVybiBpZHggPT09IDBcbiAgICAgID8gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUoMCkgPz8gYXZlcmFnZU1hcmdpblNpemVcbiAgICAgIDogaXRlbVxuICAgICAgICA/IGl0ZW0ucG9zXG4gICAgICAgIDogYXZlcmFnZU1hcmdpblNpemUgKyBpZHggKiAoYXZlcmFnZU1hcmdpblNpemUgKyB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpKTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVBbmNob3IobG93ZXI6IG51bWJlciwgdXBwZXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGxvd2VyIDw9IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodXBwZXIgPiB0aGlzLl9zY3JvbGxTaXplIC0gdGhpcy5fdmlld0RpbTEpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3RhbEl0ZW1zIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsSXRlbXMgLSAxLFxuICAgICAgICAgICAgTWF0aC5mbG9vcigoKGxvd2VyICsgdXBwZXIpIC8gMikgLyB0aGlzLl9kZWx0YSkpKTtcbiAgfVxuXG4gIF9nZXRBbmNob3IobG93ZXI6IG51bWJlciwgdXBwZXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX3BoeXNpY2FsSXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZmlyc3QgPCAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdfZ2V0QW5jaG9yOiBuZWdhdGl2ZSBfZmlyc3QnKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xhc3QgPCAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdfZ2V0QW5jaG9yOiBuZWdhdGl2ZSBfbGFzdCcpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbSh0aGlzLl9maXJzdCksXG4gICAgICAgICAgbGFzdEl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0odGhpcy5fbGFzdCksXG4gICAgICAgICAgZmlyc3RNaW4gPSBmaXJzdEl0ZW0hLnBvcyxcbiAgICAgICAgICBsYXN0TWluID0gbGFzdEl0ZW0hLnBvcyxcbiAgICAgICAgICBsYXN0TWF4ID0gbGFzdE1pbiArIHRoaXMuX21ldHJpY3NDYWNoZS5nZXRDaGlsZFNpemUodGhpcy5fbGFzdCkhO1xuXG4gICAgaWYgKGxhc3RNYXggPCBsb3dlcikge1xuICAgICAgLy8gV2luZG93IGlzIGVudGlyZWx5IHBhc3QgcGh5c2ljYWwgaXRlbXMsIGNhbGN1bGF0ZSBuZXcgYW5jaG9yXG4gICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuICAgIGlmIChmaXJzdE1pbiA+IHVwcGVyKSB7XG4gICAgICAvLyBXaW5kb3cgaXMgZW50aXJlbHkgYmVmb3JlIHBoeXNpY2FsIGl0ZW1zLCBjYWxjdWxhdGUgbmV3IGFuY2hvclxuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cbiAgICAvLyBXaW5kb3cgY29udGFpbnMgYSBwaHlzaWNhbCBpdGVtXG4gICAgLy8gRmluZCBvbmUsIHN0YXJ0aW5nIHdpdGggdGhlIG9uZSB0aGF0IHdhcyBwcmV2aW91c2x5IGZpcnN0IHZpc2libGVcbiAgICBsZXQgY2FuZGlkYXRlSWR4ID0gdGhpcy5fZmlyc3RWaXNpYmxlIC0gMTtcbiAgICBsZXQgY01heCA9IC1JbmZpbml0eTtcbiAgICB3aGlsZSAoY01heCA8IGxvd2VyKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0oKytjYW5kaWRhdGVJZHgpO1xuICAgICAgY01heCA9IGNhbmRpZGF0ZSEucG9zICsgdGhpcy5fbWV0cmljc0NhY2hlLmdldENoaWxkU2l6ZShjYW5kaWRhdGVJZHgpITtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmRpZGF0ZUlkeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIF9maXJzdCBhbmQgX2xhc3QgYmFzZWQgb24gaXRlbXMgdGhhdCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnRcbiAgICogdmlld2VkIHJhbmdlLlxuICAgKi9cbiAgX2dldEFjdGl2ZUl0ZW1zKCkge1xuICAgIGlmICh0aGlzLl92aWV3RGltMSA9PT0gMCB8fCB0aGlzLl90b3RhbEl0ZW1zID09PSAwKSB7XG4gICAgICB0aGlzLl9jbGVhckl0ZW1zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2dldEl0ZW1zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJhbmdlIHRvIGVtcHR5LlxuICAgKi9cbiAgX2NsZWFySXRlbXMoKSB7XG4gICAgdGhpcy5fZmlyc3QgPSAtMTtcbiAgICB0aGlzLl9sYXN0ID0gLTE7XG4gICAgdGhpcy5fcGh5c2ljYWxNaW4gPSAwO1xuICAgIHRoaXMuX3BoeXNpY2FsTWF4ID0gMDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX25ld1BoeXNpY2FsSXRlbXM7XG4gICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcyA9IHRoaXMuX3BoeXNpY2FsSXRlbXM7XG4gICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcy5jbGVhcigpO1xuICAgIHRoaXMuX3BoeXNpY2FsSXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLl9zdGFibGUgPSB0cnVlO1xuICB9XG5cbiAgLypcbiAgICogVXBkYXRlcyBfZmlyc3QgYW5kIF9sYXN0IGJhc2VkIG9uIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICovXG4gIF9nZXRJdGVtcygpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX25ld1BoeXNpY2FsSXRlbXM7XG4gICAgdGhpcy5fc3RhYmxlID0gdHJ1ZTtcbiAgICBsZXQgbG93ZXIsIHVwcGVyO1xuXG4gICAgLy8gVGhlIGFuY2hvcklkeCBpcyB0aGUgYW5jaG9yIGFyb3VuZCB3aGljaCB3ZSByZWZsb3cuIEl0IGlzIGRlc2lnbmVkIHRvXG4gICAgLy8gYWxsb3cganVtcGluZyB0byBhbnkgcG9pbnQgb2YgdGhlIHNjcm9sbCBzaXplLiBXZSBjaG9vc2UgaXQgb25jZSBhbmRcbiAgICAvLyBzdGljayB3aXRoIGl0IHVudGlsIHN0YWJsZS4gZmlyc3QgYW5kIGxhc3QgYXJlIGRlZHVjZWQgYXJvdW5kIGl0LlxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHNjcm9sbFRvSW5kZXgsIHdlIGFuY2hvciBvbiB0aGUgZ2l2ZW5cbiAgICAvLyBpbmRleCBhbmQgc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gYWNjb3JkaW5nbHlcbiAgICBpZiAodGhpcy5fc2Nyb2xsVG9JbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLl9hbmNob3JJZHggPSBNYXRoLm1pbih0aGlzLl9zY3JvbGxUb0luZGV4LCB0aGlzLl90b3RhbEl0ZW1zIC0gMSk7XG4gICAgICB0aGlzLl9hbmNob3JQb3MgPSB0aGlzLl9nZXRQb3NpdGlvbih0aGlzLl9hbmNob3JJZHgpO1xuICAgICAgdGhpcy5fc2Nyb2xsSWZOZWVkZWQoKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZHMgb2YgdGhlIHJlZ2lvbiB0byBiZVxuICAgIC8vIHJlbmRlcmVkLCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcbiAgICBsb3dlciA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uIC0gdGhpcy5fb3Zlcmhhbmc7Ly9sZWFkaW5nT3Zlcmhhbmc7XG4gICAgdXBwZXIgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xICsgdGhpcy5fb3Zlcmhhbmc7Ly8gdHJhaWxpbmdPdmVyaGFuZztcblxuICAgIGlmICh1cHBlciA8IDAgfHwgbG93ZXIgPiB0aGlzLl9zY3JvbGxTaXplKSB7XG4gICAgICB0aGlzLl9jbGVhckl0ZW1zKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIHNjcm9sbGluZyB0byBhIHNwZWNpZmljIGluZGV4IG9yIGlmIHdlIGFyZSBkb2luZyBhbm90aGVyXG4gICAgLy8gcGFzcyB0byBzdGFiaWxpemUgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgcmVmbG93LCB3ZSB3aWxsIGFscmVhZHlcbiAgICAvLyBoYXZlIGFuIGFuY2hvci4gSWYgbm90LCBlc3RhYmxpc2ggYW4gYW5jaG9yIG5vdy5cbiAgICBpZiAodGhpcy5fYW5jaG9ySWR4ID09PSBudWxsIHx8IHRoaXMuX2FuY2hvclBvcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYW5jaG9ySWR4ID0gdGhpcy5fZ2V0QW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgICB0aGlzLl9hbmNob3JQb3MgPSB0aGlzLl9nZXRQb3NpdGlvbih0aGlzLl9hbmNob3JJZHgpO1xuICAgIH1cblxuICAgIGxldCBhbmNob3JTaXplID0gdGhpcy5fZ2V0U2l6ZSh0aGlzLl9hbmNob3JJZHgpO1xuICAgIGlmIChhbmNob3JTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YWJsZSA9IGZhbHNlO1xuICAgICAgYW5jaG9yU2l6ZSA9IHRoaXMuX2dldEF2ZXJhZ2VTaXplKCk7XG4gICAgfVxuXG4gICAgbGV0IGFuY2hvckxlYWRpbmdNYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9hbmNob3JJZHgpID8/IHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlTWFyZ2luU2l6ZTtcbiAgICBsZXQgYW5jaG9yVHJhaWxpbmdNYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9hbmNob3JJZHggKyAxKSA/PyB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemU7XG5cbiAgICBpZiAodGhpcy5fYW5jaG9ySWR4ID09PSAwKSB7XG4gICAgICB0aGlzLl9hbmNob3JQb3MgPSBhbmNob3JMZWFkaW5nTWFyZ2luO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbmNob3JJZHggPT09IHRoaXMuX3RvdGFsSXRlbXMgLSAxKSB7XG4gICAgICB0aGlzLl9hbmNob3JQb3MgPSB0aGlzLl9zY3JvbGxTaXplIC0gYW5jaG9yVHJhaWxpbmdNYXJnaW4gLSBhbmNob3JTaXplO1xuICAgIH1cblxuICAgIC8vIEFuY2hvciBtaWdodCBiZSBvdXRzaWRlIGJvdW5kcywgc28gcHJlZmVyIGNvcnJlY3RpbmcgdGhlIGVycm9yIGFuZCBrZWVwXG4gICAgLy8gdGhhdCBhbmNob3JJZHguXG4gICAgbGV0IGFuY2hvckVyciA9IDA7XG5cbiAgICBpZiAodGhpcy5fYW5jaG9yUG9zICsgYW5jaG9yU2l6ZSArIGFuY2hvclRyYWlsaW5nTWFyZ2luIDwgbG93ZXIpIHtcbiAgICAgIGFuY2hvckVyciA9IGxvd2VyIC0gKHRoaXMuX2FuY2hvclBvcyArIGFuY2hvclNpemUgKyBhbmNob3JUcmFpbGluZ01hcmdpbik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FuY2hvclBvcyAtIGFuY2hvckxlYWRpbmdNYXJnaW4gPiB1cHBlcikge1xuICAgICAgYW5jaG9yRXJyID0gdXBwZXIgLSAodGhpcy5fYW5jaG9yUG9zIC0gYW5jaG9yTGVhZGluZ01hcmdpbik7XG4gICAgfVxuXG4gICAgaWYgKGFuY2hvckVycikge1xuICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gLT0gYW5jaG9yRXJyO1xuICAgICAgbG93ZXIgLT0gYW5jaG9yRXJyO1xuICAgICAgdXBwZXIgLT0gYW5jaG9yRXJyO1xuICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgKz0gYW5jaG9yRXJyO1xuICAgIH1cblxuICAgIGl0ZW1zLnNldCh0aGlzLl9hbmNob3JJZHgsIHtwb3M6IHRoaXMuX2FuY2hvclBvcywgc2l6ZTogYW5jaG9yU2l6ZX0pO1xuXG4gICAgdGhpcy5fZmlyc3QgPSAodGhpcy5fbGFzdCA9IHRoaXMuX2FuY2hvcklkeCk7XG4gICAgdGhpcy5fcGh5c2ljYWxNaW4gPSB0aGlzLl9hbmNob3JQb3M7XG4gICAgdGhpcy5fcGh5c2ljYWxNYXggPSB0aGlzLl9hbmNob3JQb3MgKyBhbmNob3JTaXplO1xuXG4gICAgd2hpbGUgKHRoaXMuX3BoeXNpY2FsTWluID4gbG93ZXIgJiYgdGhpcy5fZmlyc3QgPiAwKSB7XG4gICAgICBsZXQgc2l6ZSA9IHRoaXMuX2dldFNpemUoLS10aGlzLl9maXJzdCk7XG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IGZhbHNlO1xuICAgICAgICBzaXplID0gdGhpcy5fZ2V0QXZlcmFnZVNpemUoKTtcbiAgICAgIH1cbiAgICAgIGxldCBtYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl9maXJzdCArIDEpO1xuICAgICAgaWYgKG1hcmdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IGZhbHNlO1xuICAgICAgICBtYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLl9waHlzaWNhbE1pbiAtPSBzaXplICsgbWFyZ2luO1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5fcGh5c2ljYWxNaW47XG4gICAgICBpdGVtcy5zZXQodGhpcy5fZmlyc3QsIHtwb3MsIHNpemV9KTtcbiAgICAgIGlmICh0aGlzLl9zdGFibGUgPT09IGZhbHNlICYmIHRoaXMuX2VzdGltYXRlID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5fcGh5c2ljYWxNYXggPCB1cHBlciAmJiB0aGlzLl9sYXN0IDwgdGhpcy5fdG90YWxJdGVtcyAtIDEpIHtcbiAgICAgIGxldCBtYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSgrK3RoaXMuX2xhc3QpO1xuICAgICAgaWYgKG1hcmdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IGZhbHNlO1xuICAgICAgICBtYXJnaW4gPSB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemU7XG4gICAgICB9XG4gICAgICBsZXQgc2l6ZSA9IHRoaXMuX2dldFNpemUodGhpcy5fbGFzdCk7XG4gICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3N0YWJsZSA9IGZhbHNlO1xuICAgICAgICBzaXplID0gdGhpcy5fZ2V0QXZlcmFnZVNpemUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3BoeXNpY2FsTWF4ICsgbWFyZ2luO1xuICAgICAgaXRlbXMuc2V0KHRoaXMuX2xhc3QsIHtwb3MsIHNpemV9KTtcbiAgICAgIHRoaXMuX3BoeXNpY2FsTWF4ICs9IG1hcmdpbiArIHNpemU7XG4gICAgICBpZiAodGhpcy5fc3RhYmxlID09PSBmYWxzZSAmJiB0aGlzLl9lc3RpbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlcyB3aGVyZSB3ZSB3ZXJlIHJlbHlpbmcgb24gZXN0aW1hdGVkIHNpemVzLlxuICAgIGNvbnN0IGV4dGVudEVyciA9IHRoaXMuX2NhbGN1bGF0ZUVycm9yKCk7XG4gICAgaWYgKGV4dGVudEVycikge1xuICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gLT0gZXh0ZW50RXJyO1xuICAgICAgdGhpcy5fcGh5c2ljYWxNYXggLT0gZXh0ZW50RXJyO1xuICAgICAgdGhpcy5fYW5jaG9yUG9zIC09IGV4dGVudEVycjtcbiAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC09IGV4dGVudEVycjtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IGl0ZW0ucG9zIC09IGV4dGVudEVycik7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciArPSBleHRlbnRFcnI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YWJsZSkge1xuICAgICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcyA9IHRoaXMuX3BoeXNpY2FsSXRlbXM7XG4gICAgICB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zLmNsZWFyKCk7XG4gICAgICB0aGlzLl9waHlzaWNhbEl0ZW1zID0gaXRlbXM7XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZUVycm9yKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBhdmVyYWdlTWFyZ2luU2l6ZSB9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsTWluIC0gKHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKDApID8/IGF2ZXJhZ2VNYXJnaW5TaXplKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BoeXNpY2FsTWluIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1pbiAtICh0aGlzLl9maXJzdCAqIHRoaXMuX2RlbHRhKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3QgPT09IHRoaXMuX3RvdGFsSXRlbXMgLSAxKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX3BoeXNpY2FsTWF4ICsgKHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKHRoaXMuX3RvdGFsSXRlbXMpID8/IGF2ZXJhZ2VNYXJnaW5TaXplKSkgLSB0aGlzLl9zY3JvbGxTaXplO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGh5c2ljYWxNYXggPj0gdGhpcy5fc2Nyb2xsU2l6ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgICAodGhpcy5fcGh5c2ljYWxNYXggLSB0aGlzLl9zY3JvbGxTaXplKSArXG4gICAgICAgICAgKCh0aGlzLl90b3RhbEl0ZW1zIC0gMSAtIHRoaXMuX2xhc3QpICogdGhpcy5fZGVsdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBUT0RPOiBDYW4gdGhpcyBiZSBtYWRlIHRvIGluaGVyaXQgZnJvbSBiYXNlLCB3aXRoIHByb3BlciBob29rcz9cbiAgX3JlZmxvdygpIHtcbiAgICBjb25zdCB7X2ZpcnN0LCBfbGFzdCwgX3Njcm9sbFNpemV9ID0gdGhpcztcblxuICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFNpemUoKTtcbiAgICB0aGlzLl9nZXRBY3RpdmVJdGVtcygpO1xuXG4gICAgaWYgKHRoaXMuX3Njcm9sbFNpemUgIT09IF9zY3JvbGxTaXplKSB7XG4gICAgICB0aGlzLl9lbWl0U2Nyb2xsU2l6ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKCk7XG4gICAgdGhpcy5fZW1pdFJhbmdlKCk7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ID09PSAtMSAmJiB0aGlzLl9sYXN0ID09PSAtMSkge1xuICAgICAgdGhpcy5fcmVzZXRSZWZsb3dTdGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRoaXMuX2ZpcnN0ICE9PSBfZmlyc3QgfHwgdGhpcy5fbGFzdCAhPT0gX2xhc3QgfHxcbiAgICAgICAgdGhpcy5fbmVlZHNSZW1lYXN1cmUpIHtcbiAgICAgIHRoaXMuX2VtaXRDaGlsZFBvc2l0aW9ucygpO1xuICAgICAgdGhpcy5fZW1pdFNjcm9sbEVycm9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXRDaGlsZFBvc2l0aW9ucygpO1xuICAgICAgdGhpcy5fZW1pdFNjcm9sbEVycm9yKCk7XG4gICAgICB0aGlzLl9yZXNldFJlZmxvd1N0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc2V0UmVmbG93U3RhdGUoKSB7XG4gICAgdGhpcy5fYW5jaG9ySWR4ID0gbnVsbDtcbiAgICB0aGlzLl9hbmNob3JQb3MgPSBudWxsO1xuICAgIHRoaXMuX3N0YWJsZSA9IHRydWU7XG4gIH1cblxuICBfdXBkYXRlU2Nyb2xsU2l6ZSgpIHtcbiAgICBjb25zdCB7IGF2ZXJhZ2VNYXJnaW5TaXplIH0gPSB0aGlzLl9tZXRyaWNzQ2FjaGU7XG4gICAgdGhpcy5fc2Nyb2xsU2l6ZSA9IE1hdGgubWF4KDEsIHRoaXMuX3RvdGFsSXRlbXMgKiAoYXZlcmFnZU1hcmdpblNpemUgKyB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpKSArIGF2ZXJhZ2VNYXJnaW5TaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIHNpemUgKHByZWNpc2Ugb3IgZXN0aW1hdGVkKSBvZiBhbiBpdGVtIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLFxuICAgKiBpbmNsdWRpbmcgYW55IHN1cnJvdW5kaW5nIHNwYWNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBfZGVsdGEoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGF2ZXJhZ2VNYXJnaW5TaXplIH0gPSB0aGlzLl9tZXRyaWNzQ2FjaGU7XG4gICAgcmV0dXJuIHRoaXMuX2dldEF2ZXJhZ2VTaXplKCkgKyBhdmVyYWdlTWFyZ2luU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb25pbmcgb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgKi9cbiAgX2dldEl0ZW1Qb3NpdGlvbihpZHg6IG51bWJlcik6IFBvc2l0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IHRoaXMuX2dldFBvc2l0aW9uKGlkeCksXG4gICAgICBbdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW1dOiAwLFxuICAgICAgW29mZnNldCh0aGlzLmRpcmVjdGlvbildOiAtKHRoaXMuX21ldHJpY3NDYWNoZS5nZXRMZWFkaW5nTWFyZ2luVmFsdWUoaWR4LCB0aGlzLmRpcmVjdGlvbikgPz8gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplKVxuICAgIH0gYXMgUG9zaXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgKi9cbiAgX2dldEl0ZW1TaXplKGlkeDogbnVtYmVyKTogU2l6ZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFt0aGlzLl9zaXplRGltXTogKHRoaXMuX2dldFNpemUoaWR4KSB8fCB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpKSArICh0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZShpZHggKyAxKSA/PyB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemUpLFxuICAgICAgW3RoaXMuX3NlY29uZGFyeVNpemVEaW1dOiB0aGlzLl9pdGVtU2l6ZVt0aGlzLl9zZWNvbmRhcnlTaXplRGltXVxuICAgIH0gYXMgU2l6ZTtcbiAgfVxuXG4gIF92aWV3RGltMkNoYW5nZWQoKSB7XG4gICAgdGhpcy5fbmVlZHNSZW1lYXN1cmUgPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gIH1cblxuICBfZW1pdFJhbmdlKCkge1xuICAgIGNvbnN0IHJlbWVhc3VyZSA9IHRoaXMuX25lZWRzUmVtZWFzdXJlO1xuICAgIGNvbnN0IHN0YWJsZSA9IHRoaXMuX3N0YWJsZTtcbiAgICB0aGlzLl9uZWVkc1JlbWVhc3VyZSA9IGZhbHNlO1xuICAgIHN1cGVyLl9lbWl0UmFuZ2Uoe3JlbWVhc3VyZSwgc3RhYmxlfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/flow.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SizeCache\": () => (/* binding */ SizeCache)\n/* harmony export */ });\nclass SizeCache {\n  constructor(config) {\n    this._map = new Map();\n    this._roundAverageSize = true;\n    this.totalSize = 0;\n\n    if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === false) {\n      this._roundAverageSize = false;\n    }\n  }\n\n  set(index, value) {\n    const prev = this._map.get(index) || 0;\n\n    this._map.set(index, value);\n\n    this.totalSize += value - prev;\n  }\n\n  get averageSize() {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n\n    return 0;\n  }\n\n  getSize(index) {\n    return this._map.get(index);\n  }\n\n  clear() {\n    this._map.clear();\n\n    this.totalSize = 0;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBSUE7QUFLQTtBQUpBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBbENBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi8uLi9zcmMvbGF5b3V0cy9zaGFyZWQvU2l6ZUNhY2hlLnRzPzdjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBTaXplQ2FjaGVDb25maWcge1xuICAgIHJvdW5kQXZlcmFnZVNpemU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBTaXplQ2FjaGUge1xuICAgIHByaXZhdGUgX21hcDogTWFwPG51bWJlciB8IHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgICBwcml2YXRlIF9yb3VuZEF2ZXJhZ2VTaXplID0gdHJ1ZTtcbiAgICB0b3RhbFNpemU6IG51bWJlciA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc/OiBTaXplQ2FjaGVDb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZz8ucm91bmRBdmVyYWdlU2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdW5kQXZlcmFnZVNpemUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgXG4gICAgc2V0KGluZGV4OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9tYXAuZ2V0KGluZGV4KSB8fCAwO1xuICAgICAgdGhpcy5fbWFwLnNldChpbmRleCwgdmFsdWUpO1xuICAgICAgdGhpcy50b3RhbFNpemUgKz0gdmFsdWUgLSBwcmV2O1xuICAgIH1cbiAgXG4gICAgZ2V0IGF2ZXJhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSB0aGlzLnRvdGFsU2l6ZSAvIHRoaXMuX21hcC5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdW5kQXZlcmFnZVNpemVcbiAgICAgICAgICAgID8gTWF0aC5yb3VuZChhdmVyYWdlKVxuICAgICAgICAgICAgOiBhdmVyYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgXG4gICAgZ2V0U2l6ZShpbmRleDogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLmdldChpbmRleCk7XG4gICAgfVxuICBcbiAgICBjbGVhcigpIHtcbiAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgdGhpcy50b3RhbFNpemUgPSAwO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\n");

/***/ })

}]);