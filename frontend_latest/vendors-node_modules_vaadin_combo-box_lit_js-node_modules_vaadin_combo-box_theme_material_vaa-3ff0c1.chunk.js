"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_vaadin_combo-box_lit_js-node_modules_vaadin_combo-box_theme_material_vaa-3ff0c1"],{

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/elements/dom-module.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/elements/dom-module.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DomModule\": () => (/* binding */ DomModule)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/settings.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nlet modules = {};\nlet lcModules = {};\n/**\n * Sets a dom-module into the global registry by id.\n *\n * @param {string} id dom-module id\n * @param {DomModule} module dom-module instance\n * @return {void}\n */\nfunction setModule(id, module) {\n  // store id separate from lowercased id so that\n  // in all cases mixedCase id will stored distinctly\n  // and lowercase version is a fallback\n  modules[id] = lcModules[id.toLowerCase()] = module;\n}\n/**\n * Retrieves a dom-module from the global registry by id.\n *\n * @param {string} id dom-module id\n * @return {DomModule!} dom-module instance\n */\nfunction findModule(id) {\n  return modules[id] || lcModules[id.toLowerCase()];\n}\nfunction styleOutsideTemplateCheck(inst) {\n  if (inst.querySelector('style')) {\n    console.warn('dom-module %s has style outside template', inst.id);\n  }\n}\n\n/**\n * The `dom-module` element registers the dom it contains to the name given\n * by the module's id attribute. It provides a unified database of dom\n * accessible via its static `import` API.\n *\n * A key use case of `dom-module` is for providing custom element `<template>`s\n * via HTML imports that are parsed by the native HTML parser, that can be\n * relocated during a bundling pass and still looked up by `id`.\n *\n * Example:\n *\n *     <dom-module id=\"foo\">\n *       <img src=\"stuff.png\">\n *     </dom-module>\n *\n * Then in code in some other location that cannot access the dom-module above\n *\n *     let img = customElements.get('dom-module').import('foo', 'img');\n *\n * @customElement\n * @extends HTMLElement\n * @summary Custom element that provides a registry of relocatable DOM content\n *   by `id` that is agnostic to bundling.\n * @unrestricted\n */\nclass DomModule extends HTMLElement {\n  /** @override */\n  static get observedAttributes() {\n    return ['id'];\n  }\n\n  /**\n   * Retrieves the element specified by the css `selector` in the module\n   * registered by `id`. For example, this.import('foo', 'img');\n   * @param {string} id The id of the dom-module in which to search.\n   * @param {string=} selector The css selector by which to find the element.\n   * @return {Element} Returns the element which matches `selector` in the\n   * module registered at the specified `id`.\n   *\n   * @export\n   * @nocollapse Referred to indirectly in style-gather.js\n   */\n  static import(id, selector) {\n    if (id) {\n      let m = findModule(id);\n      if (m && selector) {\n        return m.querySelector(selector);\n      }\n      return m;\n    }\n    return null;\n  }\n\n  /* eslint-disable no-unused-vars */\n  /**\n   * @param {string} name Name of attribute.\n   * @param {?string} old Old value of attribute.\n   * @param {?string} value Current value of attribute.\n   * @param {?string} namespace Attribute namespace.\n   * @return {void}\n   * @override\n   */\n  attributeChangedCallback(name, old, value, namespace) {\n    if (old !== value) {\n      this.register();\n    }\n  }\n  /* eslint-enable no-unused-args */\n\n  /**\n   * The absolute URL of the original location of this `dom-module`.\n   *\n   * This value will differ from this element's `ownerDocument` in the\n   * following ways:\n   * - Takes into account any `assetpath` attribute added during bundling\n   *   to indicate the original location relative to the bundled location\n   * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n   *   the path is relative to the import document's location since\n   *   `ownerDocument` is not currently polyfilled\n   */\n  get assetpath() {\n    // Don't override existing assetpath.\n    if (!this.__assetpath) {\n      // note: assetpath set via an attribute must be relative to this\n      // element's location; accommodate polyfilled HTMLImports\n      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;\n      const url = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveUrl)(this.getAttribute('assetpath') || '', owner.baseURI);\n      this.__assetpath = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.pathFromUrl)(url);\n    }\n    return this.__assetpath;\n  }\n\n  /**\n   * Registers the dom-module at a given id. This method should only be called\n   * when a dom-module is imperatively created. For\n   * example, `document.createElement('dom-module').register('foo')`.\n   * @param {string=} id The id at which to register the dom-module.\n   * @return {void}\n   */\n  register(id) {\n    id = id || this.id;\n    if (id) {\n      // Under strictTemplatePolicy, reject and null out any re-registered\n      // dom-module since it is ambiguous whether first-in or last-in is trusted\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_2__.strictTemplatePolicy && findModule(id) !== undefined) {\n        setModule(id, null);\n        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);\n      }\n      this.id = id;\n      setModule(id, this);\n      styleOutsideTemplateCheck(this);\n    }\n  }\n}\nDomModule.prototype['modules'] = modules;\ncustomElements.define('dom-module', DomModule);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5qcz84NjRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuXG5pbXBvcnQgeyByZXNvbHZlVXJsLCBwYXRoRnJvbVVybCB9IGZyb20gJy4uL3V0aWxzL3Jlc29sdmUtdXJsLmpzJztcbmltcG9ydCB7IHN0cmljdFRlbXBsYXRlUG9saWN5IH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuXG5sZXQgbW9kdWxlcyA9IHt9O1xubGV0IGxjTW9kdWxlcyA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgZG9tLW1vZHVsZSBpbnRvIHRoZSBnbG9iYWwgcmVnaXN0cnkgYnkgaWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIGRvbS1tb2R1bGUgaWRcbiAqIEBwYXJhbSB7RG9tTW9kdWxlfSBtb2R1bGUgZG9tLW1vZHVsZSBpbnN0YW5jZVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2V0TW9kdWxlKGlkLCBtb2R1bGUpIHtcbiAgLy8gc3RvcmUgaWQgc2VwYXJhdGUgZnJvbSBsb3dlcmNhc2VkIGlkIHNvIHRoYXRcbiAgLy8gaW4gYWxsIGNhc2VzIG1peGVkQ2FzZSBpZCB3aWxsIHN0b3JlZCBkaXN0aW5jdGx5XG4gIC8vIGFuZCBsb3dlcmNhc2UgdmVyc2lvbiBpcyBhIGZhbGxiYWNrXG4gIG1vZHVsZXNbaWRdID0gbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldID0gbW9kdWxlO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBkb20tbW9kdWxlIGZyb20gdGhlIGdsb2JhbCByZWdpc3RyeSBieSBpZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tLW1vZHVsZSBpZFxuICogQHJldHVybiB7RG9tTW9kdWxlIX0gZG9tLW1vZHVsZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBmaW5kTW9kdWxlKGlkKSB7XG4gIHJldHVybiBtb2R1bGVzW2lkXSB8fCBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2soaW5zdCkge1xuICBpZiAoaW5zdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKSB7XG4gICAgY29uc29sZS53YXJuKCdkb20tbW9kdWxlICVzIGhhcyBzdHlsZSBvdXRzaWRlIHRlbXBsYXRlJywgaW5zdC5pZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYGRvbS1tb2R1bGVgIGVsZW1lbnQgcmVnaXN0ZXJzIHRoZSBkb20gaXQgY29udGFpbnMgdG8gdGhlIG5hbWUgZ2l2ZW5cbiAqIGJ5IHRoZSBtb2R1bGUncyBpZCBhdHRyaWJ1dGUuIEl0IHByb3ZpZGVzIGEgdW5pZmllZCBkYXRhYmFzZSBvZiBkb21cbiAqIGFjY2Vzc2libGUgdmlhIGl0cyBzdGF0aWMgYGltcG9ydGAgQVBJLlxuICpcbiAqIEEga2V5IHVzZSBjYXNlIG9mIGBkb20tbW9kdWxlYCBpcyBmb3IgcHJvdmlkaW5nIGN1c3RvbSBlbGVtZW50IGA8dGVtcGxhdGU+YHNcbiAqIHZpYSBIVE1MIGltcG9ydHMgdGhhdCBhcmUgcGFyc2VkIGJ5IHRoZSBuYXRpdmUgSFRNTCBwYXJzZXIsIHRoYXQgY2FuIGJlXG4gKiByZWxvY2F0ZWQgZHVyaW5nIGEgYnVuZGxpbmcgcGFzcyBhbmQgc3RpbGwgbG9va2VkIHVwIGJ5IGBpZGAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgPGRvbS1tb2R1bGUgaWQ9XCJmb29cIj5cbiAqICAgICAgIDxpbWcgc3JjPVwic3R1ZmYucG5nXCI+XG4gKiAgICAgPC9kb20tbW9kdWxlPlxuICpcbiAqIFRoZW4gaW4gY29kZSBpbiBzb21lIG90aGVyIGxvY2F0aW9uIHRoYXQgY2Fubm90IGFjY2VzcyB0aGUgZG9tLW1vZHVsZSBhYm92ZVxuICpcbiAqICAgICBsZXQgaW1nID0gY3VzdG9tRWxlbWVudHMuZ2V0KCdkb20tbW9kdWxlJykuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IHByb3ZpZGVzIGEgcmVnaXN0cnkgb2YgcmVsb2NhdGFibGUgRE9NIGNvbnRlbnRcbiAqICAgYnkgYGlkYCB0aGF0IGlzIGFnbm9zdGljIHRvIGJ1bmRsaW5nLlxuICogQHVucmVzdHJpY3RlZFxuICovXG5leHBvcnQgY2xhc3MgRG9tTW9kdWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ2lkJ107IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgY3NzIGBzZWxlY3RvcmAgaW4gdGhlIG1vZHVsZVxuICAgKiByZWdpc3RlcmVkIGJ5IGBpZGAuIEZvciBleGFtcGxlLCB0aGlzLmltcG9ydCgnZm9vJywgJ2ltZycpO1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBkb20tbW9kdWxlIGluIHdoaWNoIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3RvciBUaGUgY3NzIHNlbGVjdG9yIGJ5IHdoaWNoIHRvIGZpbmQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGVsZW1lbnQgd2hpY2ggbWF0Y2hlcyBgc2VsZWN0b3JgIGluIHRoZVxuICAgKiBtb2R1bGUgcmVnaXN0ZXJlZCBhdCB0aGUgc3BlY2lmaWVkIGBpZGAuXG4gICAqXG4gICAqIEBleHBvcnRcbiAgICogQG5vY29sbGFwc2UgUmVmZXJyZWQgdG8gaW5kaXJlY3RseSBpbiBzdHlsZS1nYXRoZXIuanNcbiAgICovXG4gIHN0YXRpYyBpbXBvcnQoaWQsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBsZXQgbSA9IGZpbmRNb2R1bGUoaWQpO1xuICAgICAgaWYgKG0gJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG0ucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlIEF0dHJpYnV0ZSBuYW1lc3BhY2UuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUsIG5hbWVzcGFjZSkge1xuICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWFyZ3MgKi9cblxuICAvKipcbiAgICogVGhlIGFic29sdXRlIFVSTCBvZiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhpcyBgZG9tLW1vZHVsZWAuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgd2lsbCBkaWZmZXIgZnJvbSB0aGlzIGVsZW1lbnQncyBgb3duZXJEb2N1bWVudGAgaW4gdGhlXG4gICAqIGZvbGxvd2luZyB3YXlzOlxuICAgKiAtIFRha2VzIGludG8gYWNjb3VudCBhbnkgYGFzc2V0cGF0aGAgYXR0cmlidXRlIGFkZGVkIGR1cmluZyBidW5kbGluZ1xuICAgKiAgIHRvIGluZGljYXRlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgYnVuZGxlZCBsb2NhdGlvblxuICAgKiAtIFVzZXMgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsJ3MgYGltcG9ydEZvckVsZW1lbnRgIEFQSSB0byBlbnN1cmVcbiAgICogICB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IGRvY3VtZW50J3MgbG9jYXRpb24gc2luY2VcbiAgICogICBgb3duZXJEb2N1bWVudGAgaXMgbm90IGN1cnJlbnRseSBwb2x5ZmlsbGVkXG4gICAqL1xuICBnZXQgYXNzZXRwYXRoKCkge1xuICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFzc2V0cGF0aC5cbiAgICBpZiAoIXRoaXMuX19hc3NldHBhdGgpIHtcbiAgICAgIC8vIG5vdGU6IGFzc2V0cGF0aCBzZXQgdmlhIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoaXNcbiAgICAgIC8vIGVsZW1lbnQncyBsb2NhdGlvbjsgYWNjb21tb2RhdGUgcG9seWZpbGxlZCBIVE1MSW1wb3J0c1xuICAgICAgY29uc3Qgb3duZXIgPSB3aW5kb3cuSFRNTEltcG9ydHMgJiYgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCA/XG4gICAgICAgIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQodGhpcykgfHwgZG9jdW1lbnQgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG4gICAgICBjb25zdCB1cmwgPSByZXNvbHZlVXJsKFxuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnYXNzZXRwYXRoJykgfHwgJycsIG93bmVyLmJhc2VVUkkpO1xuICAgICAgdGhpcy5fX2Fzc2V0cGF0aCA9IHBhdGhGcm9tVXJsKHVybCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fYXNzZXRwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZG9tLW1vZHVsZSBhdCBhIGdpdmVuIGlkLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAgICogd2hlbiBhIGRvbS1tb2R1bGUgaXMgaW1wZXJhdGl2ZWx5IGNyZWF0ZWQuIEZvclxuICAgKiBleGFtcGxlLCBgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZG9tLW1vZHVsZScpLnJlZ2lzdGVyKCdmb28nKWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgVGhlIGlkIGF0IHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBkb20tbW9kdWxlLlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgcmVnaXN0ZXIoaWQpIHtcbiAgICBpZCA9IGlkIHx8IHRoaXMuaWQ7XG4gICAgaWYgKGlkKSB7XG4gICAgICAvLyBVbmRlciBzdHJpY3RUZW1wbGF0ZVBvbGljeSwgcmVqZWN0IGFuZCBudWxsIG91dCBhbnkgcmUtcmVnaXN0ZXJlZFxuICAgICAgLy8gZG9tLW1vZHVsZSBzaW5jZSBpdCBpcyBhbWJpZ3VvdXMgd2hldGhlciBmaXJzdC1pbiBvciBsYXN0LWluIGlzIHRydXN0ZWRcbiAgICAgIGlmIChzdHJpY3RUZW1wbGF0ZVBvbGljeSAmJiBmaW5kTW9kdWxlKGlkKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldE1vZHVsZShpZCwgbnVsbCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyaWN0VGVtcGxhdGVQb2xpY3k6IGRvbS1tb2R1bGUgJHtpZH0gcmUtcmVnaXN0ZXJlZGApO1xuICAgICAgfVxuICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgc2V0TW9kdWxlKGlkLCB0aGlzKTtcbiAgICAgIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2sodGhpcyk7XG4gICAgfVxuICB9XG59XG5cbkRvbU1vZHVsZS5wcm90b3R5cGVbJ21vZHVsZXMnXSA9IG1vZHVsZXM7XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLW1vZHVsZScsIERvbU1vZHVsZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/elements/dom-module.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/element-mixin.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/element-mixin.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementMixin\": () => (/* binding */ ElementMixin),\n/* harmony export */   \"builtCSS\": () => (/* binding */ builtCSS),\n/* harmony export */   \"updateStyles\": () => (/* binding */ updateStyles),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/settings.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/style-gather.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/style-gather.js\");\n/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../elements/dom-module.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n/* harmony import */ var _property_effects_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./property-effects.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-effects.js\");\n/* harmony import */ var _properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./properties-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\nconst version = '3.5.1';\nconst builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\n\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst ElementMixin = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__.dedupingMixin)(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const polymerElementBase = (0,_properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__.PropertiesMixin)((0,_property_effects_js__WEBPACK_IMPORTED_MODULE_6__.PropertyEffects)(base));\n\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n      for (let p in props) {\n        let info = props[p];\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n    return constructor.__propertyDefaults;\n  }\n\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ? /** @type {PolymerElementConstructor} */constructor.observers : null;\n    }\n    return constructor.__ownObservers;\n  }\n\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    }\n    // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n    if (info.computed) {\n      if (proto._hasReadOnlyEffect(name)) {\n        console.warn(`Cannot redefine computed property '${name}'.`);\n      } else {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n    }\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\n    }\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\n    }\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\n    }\n    // always add observer\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    }\n    // always create the mapping from attribute back to property for deserialization.\n    proto._addPropertyToAttributeMap(name);\n  }\n\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n  function processElementStyles(klass, template, is, baseURI) {\n    if (!builtCSS) {\n      const templateStyles = template.content.querySelectorAll('style');\n      const stylesWithImports = (0,_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__.stylesFromTemplate)(template);\n      // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n      const linkedStyles = (0,_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__.stylesFromModuleImports)(is);\n      const firstTemplateChild = template.content.firstElementChild;\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\n        let s = linkedStyles[idx];\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n        template.content.insertBefore(s, firstTemplateChild);\n      }\n      // keep track of the last \"concrete\" style in the template we have encountered\n      let templateStyleIndex = 0;\n      // ensure all gathered styles are actually in this template.\n      for (let i = 0; i < stylesWithImports.length; i++) {\n        let s = stylesWithImports[i];\n        let templateStyle = templateStyles[templateStyleIndex];\n        // if the style is not in this template, it's been \"included\" and\n        // we put a clone of it in the template before the style that included it\n        if (templateStyle !== s) {\n          s = s.cloneNode(true);\n          templateStyle.parentNode.insertBefore(s, templateStyle);\n        } else {\n          templateStyleIndex++;\n        }\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n      }\n    }\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n    // Support for `adoptedStylesheets` relies on using native Shadow DOM\n    // and built CSS. Built CSS is required because runtime transformation of\n    // `@apply` is not supported. This is because ShadyCSS relies on being able\n    // to update a `style` element in the element template and this is\n    // removed when using `adoptedStyleSheets`.\n    // Note, it would be more efficient to allow style includes to become\n    // separate stylesheets; however, because of `@apply` these are\n    // potentially not shareable and sharing the ones that could be shared\n    // would require some coordination. To keep it simple, all the includes\n    // and styles are collapsed into a single shareable stylesheet.\n    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.useAdoptedStyleSheetsWithBuiltCSS && builtCSS && _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.supportsAdoptingStyleSheets) {\n      // Remove styles in template and make a shareable stylesheet\n      const styles = template.content.querySelectorAll('style');\n      if (styles) {\n        let css = '';\n        Array.from(styles).forEach(s => {\n          css += s.textContent;\n          s.parentNode.removeChild(s);\n        });\n        klass._styleSheet = new CSSStyleSheet();\n        klass._styleSheet.replaceSync(css);\n      }\n    }\n  }\n\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {string} is Element name to look up\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n  function getTemplateFromDomModule(is) {\n    let template = null;\n    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n    if (is && (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.strictTemplatePolicy || _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.allowTemplateFromDomModule)) {\n      template = /** @type {?HTMLTemplateElement} */\n      _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__.DomModule[\"import\"](is, 'template');\n      // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.strictTemplatePolicy && !template) {\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\n      }\n    }\n    return template;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   * @extends {polymerElementBase}\n   */\n  class PolymerElement extends polymerElementBase {\n    /**\n     * Current Polymer version in Semver notation.\n     * @type {string} Semver notation of the current version of Polymer.\n     * @nocollapse\n     */\n    static get polymerElementVersion() {\n      return version;\n    }\n\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _finalizeClass() {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      polymerElementBase._finalizeClass.call(this);\n      const observers = ownObservers(this);\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      }\n      this._prepareTemplate();\n    }\n\n    /** @nocollapse */\n    static _prepareTemplate() {\n      // note: create \"working\" template that is finalized at instance time\n      let template = /** @type {PolymerElementConstructor} */this.template;\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.legacyOptimizations) {\n          template = template.cloneNode(true);\n        }\n      }\n\n      /** @override */\n      this.prototype._template = template;\n    }\n\n    /**\n     * Override of PropertiesChanged createProperties to create accessors\n     * and property effects for all of the properties.\n     * @param {!Object} props .\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig( /** @type {?} */this.prototype, p, props[p], props);\n      }\n    }\n\n    /**\n     * Creates observers for the given `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {Object} observers Array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n      for (let i = 0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Returns the template that will be stamped into this element's shadow root.\n     *\n     * If a `static get is()` getter is defined, the default implementation will\n     * return the first `<template>` in a `dom-module` whose `id` matches this\n     * element's `is` (note that a `_template` property on the class prototype\n     * takes precedence over the `dom-module` template, to maintain legacy\n     * element semantics; a subclass will subsequently fall back to its super\n     * class template if neither a `prototype._template` or a `dom-module` for\n     * the class's `is` was found).\n     *\n     * Users may override this getter to return an arbitrary template\n     * (in which case the `is` getter is unnecessary). The template returned\n     * must be an `HTMLTemplateElement`.\n     *\n     * Note that when subclassing, if the super class overrode the default\n     * implementation and the subclass would like to provide an alternate\n     * template via a `dom-module`, it should override this getter and\n     * return `DomModule.import(this.is, 'template')`.\n     *\n     * If a subclass would like to modify the super class template, it should\n     * clone it rather than modify it in place.  If the getter does expensive\n     * work such as cloning/modifying a template, it should memoize the\n     * template for maximum performance:\n     *\n     *   let memoizedTemplate;\n     *   class MySubClass extends MySuperClass {\n     *     static get template() {\n     *       if (!memoizedTemplate) {\n     *         memoizedTemplate = super.template.cloneNode(true);\n     *         let subContent = document.createElement('div');\n     *         subContent.textContent = 'This came from MySubClass';\n     *         memoizedTemplate.content.appendChild(subContent);\n     *       }\n     *       return memoizedTemplate;\n     *     }\n     *   }\n     *\n     * @return {!HTMLTemplateElement|string} Template to be stamped\n     * @nocollapse\n     */\n    static get template() {\n      // Explanation of template-related properties:\n      // - constructor.template (this getter): the template for the class.\n      //     This can come from the prototype (for legacy elements), from a\n      //     dom-module, or from the super class's template (or can be overridden\n      //     altogether by the user)\n      // - constructor._template: memoized version of constructor.template\n      // - prototype._template: working template for the element, which will be\n      //     parsed and modified in place. It is a cloned version of\n      //     constructor.template, saved in _finalizeClass(). Note that before\n      //     this getter is called, for legacy elements this could be from a\n      //     _template field on the info object passed to Polymer(), a behavior,\n      //     or set in registered(); once the static getter runs, a clone of it\n      //     will overwrite it on the prototype as the working template.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        let protoTemplate = this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template : undefined;\n        // Accept a function for the legacy Polymer({_template:...}) field for\n        // lazy parsing\n        if (typeof protoTemplate === 'function') {\n          protoTemplate = protoTemplate();\n        }\n        this._template =\n        // If user has put template on prototype (e.g. in legacy via registered\n        // callback or info object), prefer that first. Note that `null` is\n        // used as a sentinel to indicate \"no template\" and can be used to\n        // override a super template, whereas `undefined` is used as a\n        // sentinel to mean \"fall-back to default template lookup\" via\n        // dom-module and/or super.template.\n        protoTemplate !== undefined ? protoTemplate :\n        // Look in dom-module associated with this element's is\n        this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && getTemplateFromDomModule( /** @type {PolymerElementConstructor}*/this.is) ||\n        // Next look for superclass template (call the super impl this\n        // way so that `this` points to the superclass)\n        Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.template;\n      }\n      return this._template;\n    }\n\n    /**\n     * Set the template.\n     *\n     * @param {!HTMLTemplateElement|string} value Template to set.\n     * @nocollapse\n     */\n    static set template(value) {\n      this._template = value;\n    }\n\n    /**\n     * Path matching the url from which the element was imported.\n     *\n     * This path is used to resolve url's in template style cssText.\n     * The `importPath` property is also set on element instances and can be\n     * used to create bindings relative to the import path.\n     *\n     * For elements defined in ES modules, users should implement\n     * `static get importMeta() { return import.meta; }`, and the default\n     * implementation of `importPath` will  return `import.meta.url`'s path.\n     * For elements defined in HTML imports, this getter will return the path\n     * to the document containing a `dom-module` element matching this\n     * element's static `is` property.\n     *\n     * Note, this path should contain a trailing `/`.\n     *\n     * @return {string} The import path for this element class\n     * @suppress {missingProperties}\n     * @nocollapse\n     */\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n        if (meta) {\n          this._importPath = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.pathFromUrl)(meta.url);\n        } else {\n          const module = _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__.DomModule[\"import\"]( /** @type {PolymerElementConstructor} */this.is);\n          this._importPath = module && module.assetpath || Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.importPath;\n        }\n      }\n      return this._importPath;\n    }\n    constructor() {\n      super();\n      /** @type {HTMLTemplateElement} */\n      this._template;\n      /** @type {string} */\n      this._importPath;\n      /** @type {string} */\n      this.rootPath;\n      /** @type {string} */\n      this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      this.root;\n      /** @type {!Object<string, !Element>} */\n      this.$;\n    }\n\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\n     */\n    _initializeProperties() {\n      this.constructor.finalize();\n      // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n      this.constructor._finalizeTemplate( /** @type {!HTMLElement} */this.localName);\n      super._initializeProperties();\n      // set path defaults\n      this.rootPath = _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.rootPath;\n      this.importPath = this.constructor.importPath;\n      // apply property defaults...\n      let p$ = propertyDefaults(this.constructor);\n      if (!p$) {\n        return;\n      }\n      for (let p in p$) {\n        let info = p$[p];\n        if (this._canApplyPropertyDefault(p)) {\n          let value = typeof info.value == 'function' ? info.value.call(this) : info.value;\n          // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determines if a property dfeault can be applied. For example, this\n     * prevents a default from being applied when a property that has no\n     * accessor is overridden by its host before upgrade (e.g. via a binding).\n     * @override\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property default can be applied.\n     */\n    _canApplyPropertyDefault(property) {\n      return !this.hasOwnProperty(property);\n    }\n\n    /**\n     * Gather style text for a style element in the template.\n     *\n     * @param {string} cssText Text containing styling to process\n     * @param {string} baseURI Base URI to rebase CSS paths against\n     * @return {string} The processed CSS text\n     * @protected\n     * @nocollapse\n     */\n    static _processStyleText(cssText, baseURI) {\n      return (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveCss)(cssText, baseURI);\n    }\n\n    /**\n    * Configures an element `proto` to function with a given `template`.\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\n    * style scoping.\n    *\n    * @param {string} is Tag name (or type extension name) for this element\n    * @return {void}\n    * @protected\n    * @nocollapse\n    */\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */\n      const template = this.prototype._template;\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(importPath) : '';\n        // e.g. support `include=\"module-name\"`, and ShadyCSS\n        processElementStyles(this, template, is, baseURI);\n        this.prototype._bindTemplate(template);\n      }\n    }\n\n    /**\n     * Provides a default implementation of the standard Custom Elements\n     * `connectedCallback`.\n     *\n     * The default implementation enables the property effects system and\n     * flushes any pending properties, and updates shimmed CSS properties\n     * when using the ShadyCSS scoping/custom properties polyfill.\n     *\n     * @override\n     * @suppress {missingProperties, invalidCasts} Super may or may not\n     *     implement the callback\n     * @return {void}\n     */\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);\n      }\n      super.connectedCallback();\n    }\n\n    /**\n     * Stamps the element template.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n      super.ready();\n    }\n\n    /**\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n     * element dom by calling `_attachDom` with the dom stamped from the\n     * element's template via `_stampTemplate`. Note that this allows\n     * client dom to be attached to the element prior to any observers\n     * running.\n     *\n     * @return {void}\n     * @override\n     */\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom( /** @type {StampedTemplate} */this.root);\n      }\n      // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n      super._readyClients();\n    }\n\n    /**\n     * Attaches an element's stamped dom to itself. By default,\n     * this method creates a `shadowRoot` and adds the dom to it.\n     * However, this method may be overridden to allow an element\n     * to put its dom in another location.\n     *\n     * @override\n     * @throws {Error}\n     * @suppress {missingReturn}\n     * @param {StampedTemplate} dom to attach to the element.\n     * @return {ShadowRoot} node to which the dom has been attached.\n     */\n    _attachDom(dom) {\n      const n = (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__.wrap)(this);\n      if (n.attachShadow) {\n        if (dom) {\n          if (!n.shadowRoot) {\n            n.attachShadow({\n              mode: 'open',\n              shadyUpgradeFragment: dom\n            });\n            n.shadowRoot.appendChild(dom);\n            // When `adoptedStyleSheets` is supported a stylesheet is made\n            // available on the element constructor.\n            if (this.constructor._styleSheet) {\n              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];\n            }\n          }\n          if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.syncInitialRender && window.ShadyDOM) {\n            window.ShadyDOM.flushInitial(n.shadowRoot);\n          }\n          return n.shadowRoot;\n        }\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' +\n        // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    }\n\n    /**\n     * When using the ShadyCSS scoping and custom property shim, causes all\n     * shimmed styles in this element (and its subtree) to be updated\n     * based on current custom property values.\n     *\n     * The optional parameter overrides inline custom property styles with an\n     * object of properties where the keys are CSS properties, and the values\n     * are strings.\n     *\n     * Example: `this.updateStyles({'--color': 'blue'})`\n     *\n     * These properties are retained unless a value of `null` is set.\n     *\n     * Note: This function does not support updating CSS mixins.\n     * You can not dynamically change the value of an `@apply`.\n     *\n     * @override\n     * @param {Object=} properties Bag of custom property key/values to\n     *   apply to this element.\n     * @return {void}\n     * @suppress {invalidCasts}\n     */\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);\n      }\n    }\n\n    /**\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\n     * the original location of the document containing the `dom-module` for\n     * this element. This method will return the same URL before and after\n     * bundling.\n     *\n     * Note that this function performs no resolution for URLs that start\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n     * URL resolution, use `window.URL`.\n     *\n     * @override\n     * @param {string} url URL to resolve.\n     * @param {string=} base Optional base URL to resolve against, defaults\n     * to the element's `importPath`\n     * @return {string} Rewritten URL relative to base\n     */\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(this.importPath);\n      }\n      return (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(url, base);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to add map of dynamic functions on\n     * template info, for consumption by `PropertyEffects` template binding\n     * code. This map determines which method templates should have accessors\n     * created for them.\n     *\n     * @param {!HTMLTemplateElement} template Template\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._parseTemplateContent.call(this, template, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\n     * template.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      // Warn if properties are used in template without being declared.\n      // Properties must be listed in `properties` to be included in\n      // `observedAttributes` since CE V1 reads that at registration time, and\n      // since we want to keep template parsing lazy, we can't automatically\n      // add undeclared properties used in templates to `observedAttributes`.\n      // The warning is only enabled in `legacyOptimizations` mode, since\n      // we don't want to spam existing users who might have adopted the\n      // shorthand when attribute deserialization is not important.\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.legacyWarnings && !(prop in this._properties) &&\n      // Methods used in templates with no dependencies (or only literal\n      // dependencies) become accessors with template effects; ignore these\n      !(effect.info.part.signature && effect.info.part.signature.static) &&\n      // Warnings for bindings added to nested templates are handled by\n      // templatizer so ignore both the host-to-template bindings\n      // (`hostProp`) and TemplateInstance-to-child bindings\n      // (`nestedTemplate`)\n      !effect.info.part.hostProp && !templateInfo.nestedTemplate) {\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` + `attribute will not be observed.`);\n      }\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._addTemplatePropertyEffect.call(this, templateInfo, prop, effect);\n    }\n  }\n  return PolymerElement;\n});\n\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\nconst updateStyles = function (props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzP2ExZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBAc3VwcHJlc3Mge2NoZWNrUHJvdG90eXBhbFR5cGVzfVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmRcbiAqIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXlcbiAqIGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnlcbiAqIEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVBcbiAqIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcblxuaW1wb3J0IHsgcm9vdFBhdGgsIHN0cmljdFRlbXBsYXRlUG9saWN5LCBhbGxvd1RlbXBsYXRlRnJvbURvbU1vZHVsZSwgbGVnYWN5T3B0aW1pemF0aW9ucywgbGVnYWN5V2FybmluZ3MsIHN5bmNJbml0aWFsUmVuZGVyLCBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMsIHVzZUFkb3B0ZWRTdHlsZVNoZWV0c1dpdGhCdWlsdENTUyB9IGZyb20gJy4uL3V0aWxzL3NldHRpbmdzLmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgeyBzdHlsZXNGcm9tVGVtcGxhdGUsIHN0eWxlc0Zyb21Nb2R1bGVJbXBvcnRzIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmpzJztcbmltcG9ydCB7IHBhdGhGcm9tVXJsLCByZXNvbHZlQ3NzLCByZXNvbHZlVXJsIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuaW1wb3J0IHsgRG9tTW9kdWxlIH0gZnJvbSAnLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuaW1wb3J0IHsgUHJvcGVydGllc01peGluIH0gZnJvbSAnLi9wcm9wZXJ0aWVzLW1peGluLmpzJztcbmltcG9ydCB7IHdyYXAgfSBmcm9tICcuLi91dGlscy93cmFwLmpzJztcblxuLyoqXG4gKiBDdXJyZW50IFBvbHltZXIgdmVyc2lvbiBpbiBTZW12ZXIgbm90YXRpb24uXG4gKiBAdHlwZSB7c3RyaW5nfSBTZW12ZXIgbm90YXRpb24gb2YgdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBQb2x5bWVyLlxuICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICczLjUuMSc7XG5cbmV4cG9ydCBjb25zdCBidWlsdENTUyA9IHdpbmRvdy5TaGFkeUNTUyAmJiB3aW5kb3cuU2hhZHlDU1NbJ2Nzc0J1aWxkJ107XG5cbi8qKlxuICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmdcbiAqIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLCBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLFxuICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAqXG4gKiBTdWJjbGFzc2VycyBtYXkgcHJvdmlkZSB0aGUgZm9sbG93aW5nIHN0YXRpYyBnZXR0ZXJzIHRvIHJldHVybiBtZXRhZGF0YVxuICogdXNlZCB0byBjb25maWd1cmUgUG9seW1lcidzIGZlYXR1cmVzIGZvciB0aGUgY2xhc3M6XG4gKlxuICogLSBgc3RhdGljIGdldCBpcygpYDogV2hlbiB0aGUgdGVtcGxhdGUgaXMgcHJvdmlkZWQgdmlhIGEgYGRvbS1tb2R1bGVgLFxuICogICB1c2VycyBzaG91bGQgcmV0dXJuIHRoZSBgZG9tLW1vZHVsZWAgaWQgZnJvbSBhIHN0YXRpYyBgaXNgIGdldHRlci4gIElmXG4gKiAgIG5vIHRlbXBsYXRlIGlzIG5lZWRlZCBvciB0aGUgdGVtcGxhdGUgaXMgcHJvdmlkZWQgZGlyZWN0bHkgdmlhIHRoZVxuICogICBgdGVtcGxhdGVgIGdldHRlciwgdGhlcmUgaXMgbm8gbmVlZCB0byBkZWZpbmUgYGlzYCBmb3IgdGhlIGVsZW1lbnQuXG4gKlxuICogLSBgc3RhdGljIGdldCB0ZW1wbGF0ZSgpYDogVXNlcnMgbWF5IHByb3ZpZGUgdGhlIHRlbXBsYXRlIGRpcmVjdGx5IChhc1xuICogICBvcHBvc2VkIHRvIHZpYSBgZG9tLW1vZHVsZWApIGJ5IGltcGxlbWVudGluZyBhIHN0YXRpYyBgdGVtcGxhdGVgIGdldHRlci5cbiAqICAgVGhlIGdldHRlciBtdXN0IHJldHVybiBhbiBgSFRNTFRlbXBsYXRlRWxlbWVudGAuXG4gKlxuICogLSBgc3RhdGljIGdldCBwcm9wZXJ0aWVzKClgOiBTaG91bGQgcmV0dXJuIGFuIG9iamVjdCBkZXNjcmliaW5nXG4gKiAgIHByb3BlcnR5LXJlbGF0ZWQgbWV0YWRhdGEgdXNlZCBieSBQb2x5bWVyIGZlYXR1cmVzIChrZXk6IHByb3BlcnR5IG5hbWVcbiAqICAgdmFsdWU6IG9iamVjdCBjb250YWluaW5nIHByb3BlcnR5IG1ldGFkYXRhKS4gVmFsaWQga2V5cyBpbiBwZXItcHJvcGVydHlcbiAqICAgbWV0YWRhdGEgaW5jbHVkZTpcbiAqICAgLSBgdHlwZWAgKFN0cmluZ3xOdW1iZXJ8T2JqZWN0fEFycmF5fC4uLik6IFVzZWQgYnlcbiAqICAgICBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0byBkZXRlcm1pbmUgaG93IHN0cmluZy1iYXNlZCBhdHRyaWJ1dGVzXG4gKiAgICAgYXJlIGRlc2VyaWFsaXplZCB0byBKYXZhU2NyaXB0IHByb3BlcnR5IHZhbHVlcy5cbiAqICAgLSBgbm90aWZ5YCAoYm9vbGVhbik6IENhdXNlcyBhIGNoYW5nZSBpbiB0aGUgcHJvcGVydHkgdG8gZmlyZSBhXG4gKiAgICAgbm9uLWJ1YmJsaW5nIGV2ZW50IGNhbGxlZCBgPHByb3BlcnR5Pi1jaGFuZ2VkYC4gRWxlbWVudHMgdGhhdCBoYXZlXG4gKiAgICAgZW5hYmxlZCB0d28td2F5IGJpbmRpbmcgdG8gdGhlIHByb3BlcnR5IHVzZSB0aGlzIGV2ZW50IHRvIG9ic2VydmUgY2hhbmdlcy5cbiAqICAgLSBgcmVhZE9ubHlgIChib29sZWFuKTogQ3JlYXRlcyBhIGdldHRlciBmb3IgdGhlIHByb3BlcnR5LCBidXQgbm8gc2V0dGVyLlxuICogICAgIFRvIHNldCBhIHJlYWQtb25seSBwcm9wZXJ0eSwgdXNlIHRoZSBwcml2YXRlIHNldHRlciBtZXRob2RcbiAqICAgICBgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlgLlxuICogICAtIGBvYnNlcnZlcmAgKHN0cmluZyk6IE9ic2VydmVyIG1ldGhvZCBuYW1lIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxuICogICAgIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlXG4gKiAgICAgYCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSlgLlxuICogICAtIGBjb21wdXRlZGAgKHN0cmluZyk6IFN0cmluZyBkZXNjcmliaW5nIG1ldGhvZCBhbmQgZGVwZW5kZW50IHByb3BlcnRpZXNcbiAqICAgICBmb3IgY29tcHV0aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IChlLmcuIGAnY29tcHV0ZUZvbyhiYXIsIHpvdCknYCkuXG4gKiAgICAgQ29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZC1vbmx5IGJ5IGRlZmF1bHQgYW5kIGNhbiBvbmx5IGJlIGNoYW5nZWRcbiAqICAgICB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY29tcHV0aW5nIG1ldGhvZC5cbiAqXG4gKiAtIGBzdGF0aWMgZ2V0IG9ic2VydmVycygpYDogQXJyYXkgb2Ygc3RyaW5ncyBkZXNjcmliaW5nIG11bHRpLXByb3BlcnR5XG4gKiAgIG9ic2VydmVyIG1ldGhvZHMgYW5kIHRoZWlyIGRlcGVuZGVudCBwcm9wZXJ0aWVzIChlLmcuXG4gKiAgIGAnb2JzZXJ2ZUFCQyhhLCBiLCBjKSdgKS5cbiAqXG4gKiBUaGUgYmFzZSBjbGFzcyBwcm92aWRlcyBkZWZhdWx0IGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBzdGFuZGFyZFxuICogY3VzdG9tIGVsZW1lbnQgbGlmZWN5Y2xlIGNhbGxiYWNrczsgdXNlcnMgbWF5IG92ZXJyaWRlIHRoZXNlLCBidXQgc2hvdWxkXG4gKiBjYWxsIHRoZSBzdXBlciBtZXRob2QgdG8gZW5zdXJlXG4gKiAtIGBjb25zdHJ1Y3RvcmA6IFJ1biB3aGVuIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQgb3IgdXBncmFkZWRcbiAqIC0gYGNvbm5lY3RlZENhbGxiYWNrYDogUnVuIGVhY2ggdGltZSB0aGUgZWxlbWVudCBpcyBjb25uZWN0ZWQgdG8gdGhlXG4gKiAgIGRvY3VtZW50XG4gKiAtIGBkaXNjb25uZWN0ZWRDYWxsYmFja2A6IFJ1biBlYWNoIHRpbWUgdGhlIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIGZyb21cbiAqICAgdGhlIGRvY3VtZW50XG4gKiAtIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgOiBSdW4gZWFjaCB0aW1lIGFuIGF0dHJpYnV0ZSBpblxuICogICBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBpcyBzZXQgb3IgcmVtb3ZlZCAobm90ZTogdGhpcyBlbGVtZW50J3MgZGVmYXVsdFxuICogICBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBpbXBsZW1lbnRhdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgcmV0dXJuIGFuIGFycmF5XG4gKiAgIG9mIGRhc2gtY2FzZWQgYXR0cmlidXRlcyBiYXNlZCBvbiBgcHJvcGVydGllc2ApXG4gKlxuICogQG1peGluRnVuY3Rpb25cbiAqIEBwb2x5bWVyXG4gKiBAYXBwbGllc01peGluIFByb3BlcnR5RWZmZWN0c1xuICogQGFwcGxpZXNNaXhpbiBQcm9wZXJ0aWVzTWl4aW5cbiAqIEBwcm9wZXJ0eSByb290UGF0aCB7c3RyaW5nfSBTZXQgdG8gdGhlIHZhbHVlIG9mIGByb290UGF0aGAsXG4gKiAgIHdoaWNoIGRlZmF1bHRzIHRvIHRoZSBtYWluIGRvY3VtZW50IHBhdGhcbiAqIEBwcm9wZXJ0eSBpbXBvcnRQYXRoIHtzdHJpbmd9IFNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGNsYXNzJ3Mgc3RhdGljXG4gKiAgIGBpbXBvcnRQYXRoYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gdGhlIHBhdGggb2YgdGhpcyBlbGVtZW50J3NcbiAqICAgYGRvbS1tb2R1bGVgICh3aGVuIGBpc2AgaXMgdXNlZCksIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBmb3Igb3RoZXJcbiAqICAgaW1wb3J0IHN0cmF0ZWdpZXMuXG4gKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAqIG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3MgQ2xhc3MgdG8gYXBwbHkgbWl4aW4gdG8uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3Mgd2l0aCBtaXhpbiBhcHBsaWVkLlxuICovXG5leHBvcnQgY29uc3QgRWxlbWVudE1peGluID0gZGVkdXBpbmdNaXhpbihiYXNlID0+IHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnRpZXNNaXhpbn1cbiAgICogQGV4dGVuZHMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3QgcG9seW1lckVsZW1lbnRCYXNlID0gUHJvcGVydGllc01peGluKFByb3BlcnR5RWZmZWN0cyhiYXNlKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHByb3BlcnRpZXMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICogVGhpcyBsaXN0IGlzIGNyZWF0ZWQgYXMgYW4gb3B0aW1pemF0aW9uIHNpbmNlIGl0IGlzIGEgc3Vic2V0IG9mXG4gICAqIHRoZSBsaXN0IHJldHVybmVkIGZyb20gYF9wcm9wZXJ0aWVzYC5cbiAgICogVGhpcyBsaXN0IGlzIHVzZWQgaW4gYF9pbml0aWFsaXplUHJvcGVydGllc2AgdG8gc2V0IHByb3BlcnR5IGRlZmF1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgKiAgIHRoYXQgaGF2ZSBkZWZhdWx0IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvcGVydHlEZWZhdWx0cyhjb25zdHJ1Y3Rvcikge1xuICAgIGlmICghY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX3Byb3BlcnR5RGVmYXVsdHMnLCBjb25zdHJ1Y3RvcikpKSB7XG4gICAgICBjb25zdHJ1Y3Rvci5fX3Byb3BlcnR5RGVmYXVsdHMgPSBudWxsO1xuICAgICAgbGV0IHByb3BzID0gY29uc3RydWN0b3IuX3Byb3BlcnRpZXM7XG4gICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgIGxldCBpbmZvID0gcHJvcHNbcF07XG4gICAgICAgIGlmICgndmFsdWUnIGluIGluZm8pIHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvci5fX3Byb3BlcnR5RGVmYXVsdHMgPSBjb25zdHJ1Y3Rvci5fX3Byb3BlcnR5RGVmYXVsdHMgfHwge307XG4gICAgICAgICAgY29uc3RydWN0b3IuX19wcm9wZXJ0eURlZmF1bHRzW3BdID0gaW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uc3RydWN0b3IuX19wcm9wZXJ0eURlZmF1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBtZW1vaXplZCB2ZXJzaW9uIG9mIHRoZSBgb2JzZXJ2ZXJzYCBhcnJheS5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvciBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIG93biBvYnNlcnZlcnMgZm9yIHRoZSBnaXZlbiBjbGFzc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBmdW5jdGlvbiBvd25PYnNlcnZlcnMoY29uc3RydWN0b3IpIHtcbiAgICBpZiAoIWNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25PYnNlcnZlcnMnLCBjb25zdHJ1Y3RvcikpKSB7XG4gICAgICBjb25zdHJ1Y3Rvci5fX293bk9ic2VydmVycyA9XG4gICAgICAgICAgY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ29ic2VydmVycycsIGNvbnN0cnVjdG9yKSkgP1xuICAgICAgICAgIC8qKiBAdHlwZSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gKi8gKGNvbnN0cnVjdG9yKS5vYnNlcnZlcnMgOlxuICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5fX293bk9ic2VydmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGVmZmVjdHMgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIE5vdGUsIG9uY2UgYSBwcm9wZXJ0eSBoYXMgYmVlbiBzZXQgdG9cbiAgICogYHJlYWRPbmx5YCwgYGNvbXB1dGVkYCwgYHJlZmxlY3RUb0F0dHJpYnV0ZWAsIG9yIGBub3RpZnlgXG4gICAqIHRoZXNlIHZhbHVlcyBtYXkgbm90IGJlIGNoYW5nZWQuIEZvciBleGFtcGxlLCBhIHN1YmNsYXNzIGNhbm5vdFxuICAgKiBhbHRlciB0aGVzZSBzZXR0aW5ncy4gSG93ZXZlciwgYWRkaXRpb25hbCBgb2JzZXJ2ZXJzYCBtYXkgYmUgYWRkZWRcbiAgICogYnkgc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogVGhlIGluZm8gb2JqZWN0IHNob3VsZCBjb250YWluIHByb3BlcnR5IG1ldGFkYXRhIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICogYHR5cGVgOiB7ZnVuY3Rpb259IHR5cGUgdG8gd2hpY2ggYW4gYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBwcm9wZXJ0eVxuICAgKiBpcyBkZXNlcmlhbGl6ZWQuIE5vdGUgdGhlIHByb3BlcnR5IGlzIGNhbWVsLWNhc2VkIGZyb20gYSBkYXNoLWNhc2VkXG4gICAqIGF0dHJpYnV0ZS4gRm9yIGV4YW1wbGUsICdmb28tYmFyJyBhdHRyaWJ1dGUgaXMgZGVzZXJpYWxpemVkIHRvIGFcbiAgICogcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicuXG4gICAqXG4gICAqICogYHJlYWRPbmx5YDoge2Jvb2xlYW59IGNyZWF0ZXMgYSByZWFkT25seSBwcm9wZXJ0eSBhbmRcbiAgICogbWFrZXMgYSBwcml2YXRlIHNldHRlciBmb3IgdGhlIHByaXZhdGUgb2YgdGhlIGZvcm0gJ19zZXRGb28nIGZvciBhXG4gICAqIHByb3BlcnR5ICdmb28nLFxuICAgKlxuICAgKiAqIGBjb21wdXRlZGA6IHtzdHJpbmd9IGNyZWF0ZXMgYSBjb21wdXRlZCBwcm9wZXJ0eS4gQSBjb21wdXRlZCBwcm9wZXJ0eVxuICAgKiBpcyBhbHNvIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGByZWFkT25seTogdHJ1ZWAuIFRoZSB2YWx1ZSBpcyBjYWxjdWxhdGVkXG4gICAqIGJ5IHJ1bm5pbmcgYSBtZXRob2QgYW5kIGFyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLiBGb3JcbiAgICogZXhhbXBsZSAnY29tcHV0ZShmb28pJyB3aWxsIGNvbXB1dGUgYSBnaXZlbiBwcm9wZXJ0eSB3aGVuIHRoZVxuICAgKiAnZm9vJyBwcm9wZXJ0eSBjaGFuZ2VzIGJ5IGV4ZWN1dGluZyB0aGUgJ2NvbXB1dGUnIG1ldGhvZC4gVGhpcyBtZXRob2RcbiAgICogbXVzdCByZXR1cm4gdGhlIGNvbXB1dGVkIHZhbHVlLlxuICAgKlxuICAgKiAqIGByZWZsZWN0VG9BdHRyaWJ1dGVgOiB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlZmxlY3RlZFxuICAgKiB0byBhbiBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS4gTm90ZSwgdGhlIGF0dHJpYnV0ZSBpcyBkYXNoLWNhc2VkXG4gICAqIHNvIGEgcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicgaXMgcmVmbGVjdGVkIGFzICdmb28tYmFyJy5cbiAgICpcbiAgICogKiBgbm90aWZ5YDoge2Jvb2xlYW59IHNlbmRzIGEgbm9uLWJ1YmJsaW5nIG5vdGlmaWNhdGlvbiBldmVudCB3aGVuXG4gICAqIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSBwcm9wZXJ0eSBuYW1lZCAnZm9vJyBzZW5kcyBhblxuICAgKiBldmVudCBuYW1lZCAnZm9vLWNoYW5nZWQnIHdpdGggYGV2ZW50LmRldGFpbGAgc2V0IHRvIHRoZSB2YWx1ZSBvZlxuICAgKiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqICogb2JzZXJ2ZXI6IHtzdHJpbmd9IG5hbWUgb2YgYSBtZXRob2QgdGhhdCBydW5zIHdoZW4gdGhlIHByb3BlcnR5XG4gICAqIGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmUgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKS5cbiAgICpcbiAgICogTm90ZTogVXNlcnMgbWF5IHdhbnQgY29udHJvbCBvdmVyIG1vZGlmeWluZyBwcm9wZXJ0eVxuICAgKiBlZmZlY3RzIHZpYSBzdWJjbGFzc2luZy4gRm9yIGV4YW1wbGUsIGEgdXNlciBtaWdodCB3YW50IHRvIG1ha2UgYVxuICAgKiByZWZsZWN0VG9BdHRyaWJ1dGUgcHJvcGVydHkgbm90IGRvIHNvIGluIGEgc3ViY2xhc3MuIFdlJ3ZlIGNob3NlbiB0b1xuICAgKiBkaXNhYmxlIHRoaXMgYmVjYXVzZSBpdCBsZWFkcyB0byBhZGRpdGlvbmFsIGNvbXBsaWNhdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGEgcmVhZE9ubHkgZWZmZWN0IGdlbmVyYXRlcyBhIHNwZWNpYWwgc2V0dGVyLiBJZiBhIHN1YmNsYXNzXG4gICAqIGRpc2FibGVzIHRoZSBlZmZlY3QsIHRoZSBzZXR0ZXIgd291bGQgZmFpbCB1bmV4cGVjdGVkbHkuXG4gICAqIEJhc2VkIG9uIGZlZWRiYWNrLCB3ZSBtYXkgd2FudCB0byB0cnkgdG8gbWFrZSBlZmZlY3RzIG1vcmUgbWFsbGVhYmxlXG4gICAqIGFuZC9vciBwcm92aWRlIGFuIGFkdmFuY2VkIGFwaSBmb3IgbWFuaXB1bGF0aW5nIHRoZW0uXG4gICAqXG4gICAqIEBwYXJhbSB7IVBvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIEluZm8gb2JqZWN0IGZyb20gd2hpY2ggdG8gY3JlYXRlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqIFN1cHBvcnRlZCBrZXlzOlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWxsUHJvcHMgRmxhdHRlbmVkIG1hcCBvZiBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXNcbiAgICogICBlbGVtZW50IChpbmNsdWRpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMpXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIG5hbWUsIGluZm8sIGFsbFByb3BzKSB7XG4gICAgLy8gY29tcHV0ZWQgZm9yY2VzIHJlYWRPbmx5Li4uXG4gICAgaWYgKGluZm8uY29tcHV0ZWQpIHtcbiAgICAgIGluZm8ucmVhZE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBOb3RlLCBzaW5jZSBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZE9ubHksIHRoaXMgcHJldmVudHNcbiAgICAvLyBhZGRpbmcgYWRkaXRpb25hbCBjb21wdXRlZCBwcm9wZXJ0eSBlZmZlY3RzICh3aGljaCBsZWFkcyB0byBhIGNvbmZ1c2luZ1xuICAgIC8vIHNldHVwIHdoZXJlIG11bHRpcGxlIHRyaWdnZXJzIGZvciBzZXR0aW5nIGEgcHJvcGVydHkpXG4gICAgLy8gV2hpbGUgd2UgZG8gaGF2ZSBgaGFzQ29tcHV0ZWRFZmZlY3RgIHRoaXMgaXMgc2V0IG9uIHRoZSBwcm9wZXJ0eSdzXG4gICAgLy8gZGVwZW5kZW5jaWVzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAgICBpZiAoaW5mby5jb21wdXRlZCkge1xuICAgICAgaWYgKHByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYENhbm5vdCByZWRlZmluZSBjb21wdXRlZCBwcm9wZXJ0eSAnJHtuYW1lfScuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90by5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShuYW1lLCBpbmZvLmNvbXB1dGVkLCBhbGxQcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmZvLnJlYWRPbmx5ICYmICFwcm90by5faGFzUmVhZE9ubHlFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KG5hbWUsICFpbmZvLmNvbXB1dGVkKTtcbiAgICB9IGVsc2UgaWYgKGluZm8ucmVhZE9ubHkgPT09IGZhbHNlICYmIHByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgbWFrZSByZWFkT25seSBwcm9wZXJ0eSAnJHtuYW1lfScgbm9uLXJlYWRPbmx5LmApO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWZsZWN0VG9BdHRyaWJ1dGUgJiYgIXByb3RvLl9oYXNSZWZsZWN0RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkobmFtZSk7XG4gICAgfSBlbHNlIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSA9PT0gZmFsc2UgJiYgcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IG1ha2UgcmVmbGVjdGVkIHByb3BlcnR5ICcke25hbWV9JyBub24tcmVmbGVjdGVkLmApO1xuICAgIH1cbiAgICBpZiAoaW5mby5ub3RpZnkgJiYgIXByb3RvLl9oYXNOb3RpZnlFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGluZm8ubm90aWZ5ID09PSBmYWxzZSAmJiBwcm90by5faGFzTm90aWZ5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBtYWtlIG5vdGlmeSBwcm9wZXJ0eSAnJHtuYW1lfScgbm9uLW5vdGlmeS5gKTtcbiAgICB9XG4gICAgLy8gYWx3YXlzIGFkZCBvYnNlcnZlclxuICAgIGlmIChpbmZvLm9ic2VydmVyKSB7XG4gICAgICBwcm90by5fY3JlYXRlUHJvcGVydHlPYnNlcnZlcihuYW1lLCBpbmZvLm9ic2VydmVyLCBhbGxQcm9wc1tpbmZvLm9ic2VydmVyXSk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBjcmVhdGUgdGhlIG1hcHBpbmcgZnJvbSBhdHRyaWJ1dGUgYmFjayB0byBwcm9wZXJ0eSBmb3IgZGVzZXJpYWxpemF0aW9uLlxuICAgIHByb3RvLl9hZGRQcm9wZXJ0eVRvQXR0cmlidXRlTWFwKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYWxsIHN0eWxlIGVsZW1lbnRzIGluIHRoZSBlbGVtZW50IHRlbXBsYXRlLiBTdHlsZXMgd2l0aCB0aGVcbiAgICogYGluY2x1ZGVgIGF0dHJpYnV0ZSBhcmUgcHJvY2Vzc2VkIHN1Y2ggdGhhdCBhbnkgc3R5bGVzIGluXG4gICAqIHRoZSBhc3NvY2lhdGVkIFwic3R5bGUgbW9kdWxlc1wiIGFyZSBpbmNsdWRlZCBpbiB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByb2Nlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlzIE5hbWUgb2YgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSBmb3IgZWxlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnRTdHlsZXMoa2xhc3MsIHRlbXBsYXRlLCBpcywgYmFzZVVSSSkge1xuICAgIGlmICghYnVpbHRDU1MpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlU3R5bGVzID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpO1xuICAgICAgY29uc3Qgc3R5bGVzV2l0aEltcG9ydHMgPSBzdHlsZXNGcm9tVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgLy8gaW5zZXJ0IHN0eWxlcyBmcm9tIDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj4gYXQgdGhlIHRvcCBvZiB0aGUgdGVtcGxhdGVcbiAgICAgIGNvbnN0IGxpbmtlZFN0eWxlcyA9IHN0eWxlc0Zyb21Nb2R1bGVJbXBvcnRzKGlzKTtcbiAgICAgIGNvbnN0IGZpcnN0VGVtcGxhdGVDaGlsZCA9IHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsaW5rZWRTdHlsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBsZXQgcyA9IGxpbmtlZFN0eWxlc1tpZHhdO1xuICAgICAgICBzLnRleHRDb250ZW50ID0ga2xhc3MuX3Byb2Nlc3NTdHlsZVRleHQocy50ZXh0Q29udGVudCwgYmFzZVVSSSk7XG4gICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHMsIGZpcnN0VGVtcGxhdGVDaGlsZCk7XG4gICAgICB9XG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBsYXN0IFwiY29uY3JldGVcIiBzdHlsZSBpbiB0aGUgdGVtcGxhdGUgd2UgaGF2ZSBlbmNvdW50ZXJlZFxuICAgICAgbGV0IHRlbXBsYXRlU3R5bGVJbmRleCA9IDA7XG4gICAgICAvLyBlbnN1cmUgYWxsIGdhdGhlcmVkIHN0eWxlcyBhcmUgYWN0dWFsbHkgaW4gdGhpcyB0ZW1wbGF0ZS5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVzV2l0aEltcG9ydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHMgPSBzdHlsZXNXaXRoSW1wb3J0c1tpXTtcbiAgICAgICAgbGV0IHRlbXBsYXRlU3R5bGUgPSB0ZW1wbGF0ZVN0eWxlc1t0ZW1wbGF0ZVN0eWxlSW5kZXhdO1xuICAgICAgICAvLyBpZiB0aGUgc3R5bGUgaXMgbm90IGluIHRoaXMgdGVtcGxhdGUsIGl0J3MgYmVlbiBcImluY2x1ZGVkXCIgYW5kXG4gICAgICAgIC8vIHdlIHB1dCBhIGNsb25lIG9mIGl0IGluIHRoZSB0ZW1wbGF0ZSBiZWZvcmUgdGhlIHN0eWxlIHRoYXQgaW5jbHVkZWQgaXRcbiAgICAgICAgaWYgKHRlbXBsYXRlU3R5bGUgIT09IHMpIHtcbiAgICAgICAgICBzID0gcy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgdGVtcGxhdGVTdHlsZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzLCB0ZW1wbGF0ZVN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wbGF0ZVN0eWxlSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBzLnRleHRDb250ZW50ID0ga2xhc3MuX3Byb2Nlc3NTdHlsZVRleHQocy50ZXh0Q29udGVudCwgYmFzZVVSSSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGlzKTtcbiAgICB9XG4gICAgLy8gU3VwcG9ydCBmb3IgYGFkb3B0ZWRTdHlsZXNoZWV0c2AgcmVsaWVzIG9uIHVzaW5nIG5hdGl2ZSBTaGFkb3cgRE9NXG4gICAgLy8gYW5kIGJ1aWx0IENTUy4gQnVpbHQgQ1NTIGlzIHJlcXVpcmVkIGJlY2F1c2UgcnVudGltZSB0cmFuc2Zvcm1hdGlvbiBvZlxuICAgIC8vIGBAYXBwbHlgIGlzIG5vdCBzdXBwb3J0ZWQuIFRoaXMgaXMgYmVjYXVzZSBTaGFkeUNTUyByZWxpZXMgb24gYmVpbmcgYWJsZVxuICAgIC8vIHRvIHVwZGF0ZSBhIGBzdHlsZWAgZWxlbWVudCBpbiB0aGUgZWxlbWVudCB0ZW1wbGF0ZSBhbmQgdGhpcyBpc1xuICAgIC8vIHJlbW92ZWQgd2hlbiB1c2luZyBgYWRvcHRlZFN0eWxlU2hlZXRzYC5cbiAgICAvLyBOb3RlLCBpdCB3b3VsZCBiZSBtb3JlIGVmZmljaWVudCB0byBhbGxvdyBzdHlsZSBpbmNsdWRlcyB0byBiZWNvbWVcbiAgICAvLyBzZXBhcmF0ZSBzdHlsZXNoZWV0czsgaG93ZXZlciwgYmVjYXVzZSBvZiBgQGFwcGx5YCB0aGVzZSBhcmVcbiAgICAvLyBwb3RlbnRpYWxseSBub3Qgc2hhcmVhYmxlIGFuZCBzaGFyaW5nIHRoZSBvbmVzIHRoYXQgY291bGQgYmUgc2hhcmVkXG4gICAgLy8gd291bGQgcmVxdWlyZSBzb21lIGNvb3JkaW5hdGlvbi4gVG8ga2VlcCBpdCBzaW1wbGUsIGFsbCB0aGUgaW5jbHVkZXNcbiAgICAvLyBhbmQgc3R5bGVzIGFyZSBjb2xsYXBzZWQgaW50byBhIHNpbmdsZSBzaGFyZWFibGUgc3R5bGVzaGVldC5cbiAgICBpZiAodXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTICYmIGJ1aWx0Q1NTICYmXG4gICAgICAgIHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cykge1xuICAgICAgLy8gUmVtb3ZlIHN0eWxlcyBpbiB0ZW1wbGF0ZSBhbmQgbWFrZSBhIHNoYXJlYWJsZSBzdHlsZXNoZWV0XG4gICAgICBjb25zdCBzdHlsZXMgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgIGxldCBjc3MgPSAnJztcbiAgICAgICAgQXJyYXkuZnJvbShzdHlsZXMpLmZvckVhY2gocyA9PiB7XG4gICAgICAgICAgY3NzICs9IHMudGV4dENvbnRlbnQ7XG4gICAgICAgICAgcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHMpO1xuICAgICAgICB9KTtcbiAgICAgICAga2xhc3MuX3N0eWxlU2hlZXQgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICBrbGFzcy5fc3R5bGVTaGVldC5yZXBsYWNlU3luYyhjc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIHRlbXBsYXRlIGZyb20gZG9tLW1vZHVsZSBmb3IgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaXMgRWxlbWVudCBuYW1lIHRvIGxvb2sgdXBcbiAgICogQHJldHVybiB7P0hUTUxUZW1wbGF0ZUVsZW1lbnR8dW5kZWZpbmVkfSBUZW1wbGF0ZSBmb3VuZCBpbiBkb20gbW9kdWxlLCBvclxuICAgKiAgIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVGcm9tRG9tTW9kdWxlKGlzKSB7XG4gICAgbGV0IHRlbXBsYXRlID0gbnVsbDtcbiAgICAvLyBVbmRlciBzdHJpY3RUZW1wbGF0ZVBvbGljeSBpbiAzLngrLCBkb20tbW9kdWxlIGxvb2t1cCBpcyBvbmx5IGFsbG93ZWRcbiAgICAvLyB3aGVuIG9wdGVkLWluIHZpYSBhbGxvd1RlbXBsYXRlRnJvbURvbU1vZHVsZVxuICAgIGlmIChpcyAmJiAoIXN0cmljdFRlbXBsYXRlUG9saWN5IHx8IGFsbG93VGVtcGxhdGVGcm9tRG9tTW9kdWxlKSkge1xuICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUgez9IVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAoXG4gICAgICAgICAgRG9tTW9kdWxlLmltcG9ydChpcywgJ3RlbXBsYXRlJykpO1xuICAgICAgLy8gVW5kZXIgc3RyaWN0VGVtcGxhdGVQb2xpY3ksIHJlcXVpcmUgYW55IGVsZW1lbnQgd2l0aCBhbiBgaXNgXG4gICAgICAvLyBzcGVjaWZpZWQgdG8gaGF2ZSBhIGRvbS1tb2R1bGVcbiAgICAgIGlmIChzdHJpY3RUZW1wbGF0ZVBvbGljeSAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpY3RUZW1wbGF0ZVBvbGljeTogZXhwZWN0aW5nIGRvbS1tb2R1bGUgb3IgbnVsbCB0ZW1wbGF0ZSBmb3IgJHtpc31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKiBAZXh0ZW5kcyB7cG9seW1lckVsZW1lbnRCYXNlfVxuICAgKi9cbiAgY2xhc3MgUG9seW1lckVsZW1lbnQgZXh0ZW5kcyBwb2x5bWVyRWxlbWVudEJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBQb2x5bWVyIHZlcnNpb24gaW4gU2VtdmVyIG5vdGF0aW9uLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9IFNlbXZlciBub3RhdGlvbiBvZiB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFBvbHltZXIuXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHBvbHltZXJFbGVtZW50VmVyc2lvbigpIHtcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIG9mIFByb3BlcnRpZXNNaXhpbiBfZmluYWxpemVDbGFzcyB0byBjcmVhdGUgb2JzZXJ2ZXJzIGFuZFxuICAgICAqIGZpbmQgdGhlIHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9maW5hbGl6ZUNsYXNzKCkge1xuICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMyNDApOlxuICAgICAgLy8gICAgIENoYW5nZSBiYWNrIHRvIGp1c3Qgc3VwZXIubWV0aG9kQ2FsbCgpXG4gICAgICBwb2x5bWVyRWxlbWVudEJhc2UuX2ZpbmFsaXplQ2xhc3MuY2FsbCh0aGlzKTtcbiAgICAgIGNvbnN0IG9ic2VydmVycyA9IG93bk9ic2VydmVycyh0aGlzKTtcbiAgICAgIGlmIChvYnNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVPYnNlcnZlcnMob2JzZXJ2ZXJzLCB0aGlzLl9wcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByZXBhcmVUZW1wbGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIHN0YXRpYyBfcHJlcGFyZVRlbXBsYXRlKCkge1xuICAgICAgLy8gbm90ZTogY3JlYXRlIFwid29ya2luZ1wiIHRlbXBsYXRlIHRoYXQgaXMgZmluYWxpemVkIGF0IGluc3RhbmNlIHRpbWVcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gKi8gKHRoaXMpLnRlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigndGVtcGxhdGUgZ2V0dGVyIG11c3QgcmV0dXJuIEhUTUxUZW1wbGF0ZUVsZW1lbnQnKTtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoIWxlZ2FjeU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQG92ZXJyaWRlICovXG4gICAgICB0aGlzLnByb3RvdHlwZS5fdGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBvZiBQcm9wZXJ0aWVzQ2hhbmdlZCBjcmVhdGVQcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhY2Nlc3NvcnNcbiAgICAgKiBhbmQgcHJvcGVydHkgZWZmZWN0cyBmb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcHJvcHMgLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5wcm90b3R5cGUpLCBwLCBwcm9wc1twXSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb2JzZXJ2ZXJzIGZvciB0aGUgZ2l2ZW4gYG9ic2VydmVyc2AgYXJyYXkuXG4gICAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBvYnNlcnZlcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVycyBBcnJheSBvZiBvYnNlcnZlciBkZXNjcmlwdG9ycyBmb3JcbiAgICAgKiAgIHRoaXMgY2xhc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZHluYW1pY0ZucyBPYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBhbnkgcHJvcGVydGllc1xuICAgICAqICAgdGhhdCBhcmUgZnVuY3Rpb25zIGFuZCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0IHdoZW4gdGhlIGZ1bmN0aW9uXG4gICAgICogICByZWZlcmVuY2UgaXMgY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU9ic2VydmVycyhvYnNlcnZlcnMsIGR5bmFtaWNGbnMpIHtcbiAgICAgIGNvbnN0IHByb3RvID0gdGhpcy5wcm90b3R5cGU7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBvYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvdG8uX2NyZWF0ZU1ldGhvZE9ic2VydmVyKG9ic2VydmVyc1tpXSwgZHluYW1pY0Zucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHN0YW1wZWQgaW50byB0aGlzIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKlxuICAgICAqIElmIGEgYHN0YXRpYyBnZXQgaXMoKWAgZ2V0dGVyIGlzIGRlZmluZWQsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGxcbiAgICAgKiByZXR1cm4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCBpbiBhIGBkb20tbW9kdWxlYCB3aG9zZSBgaWRgIG1hdGNoZXMgdGhpc1xuICAgICAqIGVsZW1lbnQncyBgaXNgIChub3RlIHRoYXQgYSBgX3RlbXBsYXRlYCBwcm9wZXJ0eSBvbiB0aGUgY2xhc3MgcHJvdG90eXBlXG4gICAgICogdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBgZG9tLW1vZHVsZWAgdGVtcGxhdGUsIHRvIG1haW50YWluIGxlZ2FjeVxuICAgICAqIGVsZW1lbnQgc2VtYW50aWNzOyBhIHN1YmNsYXNzIHdpbGwgc3Vic2VxdWVudGx5IGZhbGwgYmFjayB0byBpdHMgc3VwZXJcbiAgICAgKiBjbGFzcyB0ZW1wbGF0ZSBpZiBuZWl0aGVyIGEgYHByb3RvdHlwZS5fdGVtcGxhdGVgIG9yIGEgYGRvbS1tb2R1bGVgIGZvclxuICAgICAqIHRoZSBjbGFzcydzIGBpc2Agd2FzIGZvdW5kKS5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIGdldHRlciB0byByZXR1cm4gYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgICogKGluIHdoaWNoIGNhc2UgdGhlIGBpc2AgZ2V0dGVyIGlzIHVubmVjZXNzYXJ5KS4gVGhlIHRlbXBsYXRlIHJldHVybmVkXG4gICAgICogbXVzdCBiZSBhbiBgSFRNTFRlbXBsYXRlRWxlbWVudGAuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2hlbiBzdWJjbGFzc2luZywgaWYgdGhlIHN1cGVyIGNsYXNzIG92ZXJyb2RlIHRoZSBkZWZhdWx0XG4gICAgICogaW1wbGVtZW50YXRpb24gYW5kIHRoZSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIHByb3ZpZGUgYW4gYWx0ZXJuYXRlXG4gICAgICogdGVtcGxhdGUgdmlhIGEgYGRvbS1tb2R1bGVgLCBpdCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgYW5kXG4gICAgICogcmV0dXJuIGBEb21Nb2R1bGUuaW1wb3J0KHRoaXMuaXMsICd0ZW1wbGF0ZScpYC5cbiAgICAgKlxuICAgICAqIElmIGEgc3ViY2xhc3Mgd291bGQgbGlrZSB0byBtb2RpZnkgdGhlIHN1cGVyIGNsYXNzIHRlbXBsYXRlLCBpdCBzaG91bGRcbiAgICAgKiBjbG9uZSBpdCByYXRoZXIgdGhhbiBtb2RpZnkgaXQgaW4gcGxhY2UuICBJZiB0aGUgZ2V0dGVyIGRvZXMgZXhwZW5zaXZlXG4gICAgICogd29yayBzdWNoIGFzIGNsb25pbmcvbW9kaWZ5aW5nIGEgdGVtcGxhdGUsIGl0IHNob3VsZCBtZW1vaXplIHRoZVxuICAgICAqIHRlbXBsYXRlIGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlOlxuICAgICAqXG4gICAgICogICBsZXQgbWVtb2l6ZWRUZW1wbGF0ZTtcbiAgICAgKiAgIGNsYXNzIE15U3ViQ2xhc3MgZXh0ZW5kcyBNeVN1cGVyQ2xhc3Mge1xuICAgICAqICAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAqICAgICAgIGlmICghbWVtb2l6ZWRUZW1wbGF0ZSkge1xuICAgICAqICAgICAgICAgbWVtb2l6ZWRUZW1wbGF0ZSA9IHN1cGVyLnRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgICAgICAgIGxldCBzdWJDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICogICAgICAgICBzdWJDb250ZW50LnRleHRDb250ZW50ID0gJ1RoaXMgY2FtZSBmcm9tIE15U3ViQ2xhc3MnO1xuICAgICAqICAgICAgICAgbWVtb2l6ZWRUZW1wbGF0ZS5jb250ZW50LmFwcGVuZENoaWxkKHN1YkNvbnRlbnQpO1xuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgICByZXR1cm4gbWVtb2l6ZWRUZW1wbGF0ZTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHJldHVybiB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR8c3RyaW5nfSBUZW1wbGF0ZSB0byBiZSBzdGFtcGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgLy8gRXhwbGFuYXRpb24gb2YgdGVtcGxhdGUtcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICAgICAgLy8gLSBjb25zdHJ1Y3Rvci50ZW1wbGF0ZSAodGhpcyBnZXR0ZXIpOiB0aGUgdGVtcGxhdGUgZm9yIHRoZSBjbGFzcy5cbiAgICAgIC8vICAgICBUaGlzIGNhbiBjb21lIGZyb20gdGhlIHByb3RvdHlwZSAoZm9yIGxlZ2FjeSBlbGVtZW50cyksIGZyb20gYVxuICAgICAgLy8gICAgIGRvbS1tb2R1bGUsIG9yIGZyb20gdGhlIHN1cGVyIGNsYXNzJ3MgdGVtcGxhdGUgKG9yIGNhbiBiZSBvdmVycmlkZGVuXG4gICAgICAvLyAgICAgYWx0b2dldGhlciBieSB0aGUgdXNlcilcbiAgICAgIC8vIC0gY29uc3RydWN0b3IuX3RlbXBsYXRlOiBtZW1vaXplZCB2ZXJzaW9uIG9mIGNvbnN0cnVjdG9yLnRlbXBsYXRlXG4gICAgICAvLyAtIHByb3RvdHlwZS5fdGVtcGxhdGU6IHdvcmtpbmcgdGVtcGxhdGUgZm9yIHRoZSBlbGVtZW50LCB3aGljaCB3aWxsIGJlXG4gICAgICAvLyAgICAgcGFyc2VkIGFuZCBtb2RpZmllZCBpbiBwbGFjZS4gSXQgaXMgYSBjbG9uZWQgdmVyc2lvbiBvZlxuICAgICAgLy8gICAgIGNvbnN0cnVjdG9yLnRlbXBsYXRlLCBzYXZlZCBpbiBfZmluYWxpemVDbGFzcygpLiBOb3RlIHRoYXQgYmVmb3JlXG4gICAgICAvLyAgICAgdGhpcyBnZXR0ZXIgaXMgY2FsbGVkLCBmb3IgbGVnYWN5IGVsZW1lbnRzIHRoaXMgY291bGQgYmUgZnJvbSBhXG4gICAgICAvLyAgICAgX3RlbXBsYXRlIGZpZWxkIG9uIHRoZSBpbmZvIG9iamVjdCBwYXNzZWQgdG8gUG9seW1lcigpLCBhIGJlaGF2aW9yLFxuICAgICAgLy8gICAgIG9yIHNldCBpbiByZWdpc3RlcmVkKCk7IG9uY2UgdGhlIHN0YXRpYyBnZXR0ZXIgcnVucywgYSBjbG9uZSBvZiBpdFxuICAgICAgLy8gICAgIHdpbGwgb3ZlcndyaXRlIGl0IG9uIHRoZSBwcm90b3R5cGUgYXMgdGhlIHdvcmtpbmcgdGVtcGxhdGUuXG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX3RlbXBsYXRlJywgdGhpcykpKSB7XG4gICAgICAgIGxldCBwcm90b1RlbXBsYXRlID0gdGhpcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXG4gICAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX3RlbXBsYXRlJywgdGhpcy5wcm90b3R5cGUpKSA/XG4gICAgICAgICAgdGhpcy5wcm90b3R5cGUuX3RlbXBsYXRlIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBBY2NlcHQgYSBmdW5jdGlvbiBmb3IgdGhlIGxlZ2FjeSBQb2x5bWVyKHtfdGVtcGxhdGU6Li4ufSkgZmllbGQgZm9yXG4gICAgICAgIC8vIGxhenkgcGFyc2luZ1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvVGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBwcm90b1RlbXBsYXRlID0gcHJvdG9UZW1wbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID1cbiAgICAgICAgICAvLyBJZiB1c2VyIGhhcyBwdXQgdGVtcGxhdGUgb24gcHJvdG90eXBlIChlLmcuIGluIGxlZ2FjeSB2aWEgcmVnaXN0ZXJlZFxuICAgICAgICAgIC8vIGNhbGxiYWNrIG9yIGluZm8gb2JqZWN0KSwgcHJlZmVyIHRoYXQgZmlyc3QuIE5vdGUgdGhhdCBgbnVsbGAgaXNcbiAgICAgICAgICAvLyB1c2VkIGFzIGEgc2VudGluZWwgdG8gaW5kaWNhdGUgXCJubyB0ZW1wbGF0ZVwiIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAgICAgIC8vIG92ZXJyaWRlIGEgc3VwZXIgdGVtcGxhdGUsIHdoZXJlYXMgYHVuZGVmaW5lZGAgaXMgdXNlZCBhcyBhXG4gICAgICAgICAgLy8gc2VudGluZWwgdG8gbWVhbiBcImZhbGwtYmFjayB0byBkZWZhdWx0IHRlbXBsYXRlIGxvb2t1cFwiIHZpYVxuICAgICAgICAgIC8vIGRvbS1tb2R1bGUgYW5kL29yIHN1cGVyLnRlbXBsYXRlLlxuICAgICAgICAgIHByb3RvVGVtcGxhdGUgIT09IHVuZGVmaW5lZCA/IHByb3RvVGVtcGxhdGUgOlxuICAgICAgICAgIC8vIExvb2sgaW4gZG9tLW1vZHVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlbGVtZW50J3MgaXNcbiAgICAgICAgICAoKHRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnaXMnLCB0aGlzKSkgJiZcbiAgICAgICAgICAoZ2V0VGVtcGxhdGVGcm9tRG9tTW9kdWxlKC8qKiBAdHlwZSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0qLyAodGhpcykuaXMpKSkgfHxcbiAgICAgICAgICAvLyBOZXh0IGxvb2sgZm9yIHN1cGVyY2xhc3MgdGVtcGxhdGUgKGNhbGwgdGhlIHN1cGVyIGltcGwgdGhpc1xuICAgICAgICAgIC8vIHdheSBzbyB0aGF0IGB0aGlzYCBwb2ludHMgdG8gdGhlIHN1cGVyY2xhc3MpXG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0qLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci50ZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR8c3RyaW5nfSB2YWx1ZSBUZW1wbGF0ZSB0byBzZXQuXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0IHRlbXBsYXRlKHZhbHVlKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGggbWF0Y2hpbmcgdGhlIHVybCBmcm9tIHdoaWNoIHRoZSBlbGVtZW50IHdhcyBpbXBvcnRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgcGF0aCBpcyB1c2VkIHRvIHJlc29sdmUgdXJsJ3MgaW4gdGVtcGxhdGUgc3R5bGUgY3NzVGV4dC5cbiAgICAgKiBUaGUgYGltcG9ydFBhdGhgIHByb3BlcnR5IGlzIGFsc28gc2V0IG9uIGVsZW1lbnQgaW5zdGFuY2VzIGFuZCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGNyZWF0ZSBiaW5kaW5ncyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IHBhdGguXG4gICAgICpcbiAgICAgKiBGb3IgZWxlbWVudHMgZGVmaW5lZCBpbiBFUyBtb2R1bGVzLCB1c2VycyBzaG91bGQgaW1wbGVtZW50XG4gICAgICogYHN0YXRpYyBnZXQgaW1wb3J0TWV0YSgpIHsgcmV0dXJuIGltcG9ydC5tZXRhOyB9YCwgYW5kIHRoZSBkZWZhdWx0XG4gICAgICogaW1wbGVtZW50YXRpb24gb2YgYGltcG9ydFBhdGhgIHdpbGwgIHJldHVybiBgaW1wb3J0Lm1ldGEudXJsYCdzIHBhdGguXG4gICAgICogRm9yIGVsZW1lbnRzIGRlZmluZWQgaW4gSFRNTCBpbXBvcnRzLCB0aGlzIGdldHRlciB3aWxsIHJldHVybiB0aGUgcGF0aFxuICAgICAqIHRvIHRoZSBkb2N1bWVudCBjb250YWluaW5nIGEgYGRvbS1tb2R1bGVgIGVsZW1lbnQgbWF0Y2hpbmcgdGhpc1xuICAgICAqIGVsZW1lbnQncyBzdGF0aWMgYGlzYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoaXMgcGF0aCBzaG91bGQgY29udGFpbiBhIHRyYWlsaW5nIGAvYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGltcG9ydCBwYXRoIGZvciB0aGlzIGVsZW1lbnQgY2xhc3NcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfVxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBpbXBvcnRQYXRoKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19pbXBvcnRQYXRoJywgdGhpcykpKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmltcG9ydE1ldGE7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgdGhpcy5faW1wb3J0UGF0aCA9IHBhdGhGcm9tVXJsKG1ldGEudXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGUgPSBEb21Nb2R1bGUuaW1wb3J0KC8qKiBAdHlwZSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gKi8gKHRoaXMpLmlzKTtcbiAgICAgICAgICB0aGlzLl9pbXBvcnRQYXRoID0gKG1vZHVsZSAmJiBtb2R1bGUuYXNzZXRwYXRoKSB8fFxuICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0qLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5faW1wb3J0UGF0aDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovXG4gICAgICB0aGlzLl90ZW1wbGF0ZTtcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgdGhpcy5faW1wb3J0UGF0aDtcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgdGhpcy5yb290UGF0aDtcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgdGhpcy5pbXBvcnRQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtTdGFtcGVkVGVtcGxhdGUgfCBIVE1MRWxlbWVudCB8IFNoYWRvd1Jvb3R9ICovXG4gICAgICB0aGlzLnJvb3Q7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhRWxlbWVudD59ICovXG4gICAgICB0aGlzLiQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQcm9wZXJ0eUFjY2Vzc29yc2AgdG8gZW5zdXJlIGNsYXNzXG4gICAgICogbWV0YXByb2dyYW1taW5nIHJlbGF0ZWQgdG8gcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzIGhhc1xuICAgICAqIGNvbXBsZXRlZCAoY2FsbHMgYGZpbmFsaXplYCkuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGluaXRpYWxpemVzIGFueSBwcm9wZXJ0eSBkZWZhdWx0cyBwcm92aWRlZCB2aWEgYHZhbHVlYCBpblxuICAgICAqIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHMsbWlzc2luZ1Byb3BlcnRpZXN9IGdvL21pc3NpbmdmbnByb3BzXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5maW5hbGl6ZSgpO1xuICAgICAgLy8gbm90ZTogZmluYWxpemUgdGVtcGxhdGUgd2hlbiB3ZSBoYXZlIGFjY2VzcyB0byBgbG9jYWxOYW1lYCB0b1xuICAgICAgLy8gYXZvaWQgZGVwZW5kZW5jZSBvbiBgaXNgIGZvciBwb2x5ZmlsbGluZyBzdHlsaW5nLlxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fZmluYWxpemVUZW1wbGF0ZSgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcykubG9jYWxOYW1lKTtcbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgLy8gc2V0IHBhdGggZGVmYXVsdHNcbiAgICAgIHRoaXMucm9vdFBhdGggPSByb290UGF0aDtcbiAgICAgIHRoaXMuaW1wb3J0UGF0aCA9IHRoaXMuY29uc3RydWN0b3IuaW1wb3J0UGF0aDtcbiAgICAgIC8vIGFwcGx5IHByb3BlcnR5IGRlZmF1bHRzLi4uXG4gICAgICBsZXQgcCQgPSBwcm9wZXJ0eURlZmF1bHRzKHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgaWYgKCFwJCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBwIGluIHAkKSB7XG4gICAgICAgIGxldCBpbmZvID0gcCRbcF07XG4gICAgICAgIGlmICh0aGlzLl9jYW5BcHBseVByb3BlcnR5RGVmYXVsdChwKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHR5cGVvZiBpbmZvLnZhbHVlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgaW5mby52YWx1ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAgIGluZm8udmFsdWU7XG4gICAgICAgICAgLy8gU2V0IHZpYSBgX3NldFByb3BlcnR5YCBpZiB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgdG8gZW5hYmxlXG4gICAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHJlYWRPbmx5IHByb3BlcnR5IGRlZmF1bHRzXG4gICAgICAgICAgaWYgKHRoaXMuX2hhc0FjY2Vzc29yKHApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGRmZWF1bHQgY2FuIGJlIGFwcGxpZWQuIEZvciBleGFtcGxlLCB0aGlzXG4gICAgICogcHJldmVudHMgYSBkZWZhdWx0IGZyb20gYmVpbmcgYXBwbGllZCB3aGVuIGEgcHJvcGVydHkgdGhhdCBoYXMgbm9cbiAgICAgKiBhY2Nlc3NvciBpcyBvdmVycmlkZGVuIGJ5IGl0cyBob3N0IGJlZm9yZSB1cGdyYWRlIChlLmcuIHZpYSBhIGJpbmRpbmcpLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgZGVmYXVsdCBjYW4gYmUgYXBwbGllZC5cbiAgICAgKi9cbiAgICBfY2FuQXBwbHlQcm9wZXJ0eURlZmF1bHQocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2F0aGVyIHN0eWxlIHRleHQgZm9yIGEgc3R5bGUgZWxlbWVudCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dCBUZXh0IGNvbnRhaW5pbmcgc3R5bGluZyB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmViYXNlIENTUyBwYXRocyBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJvY2Vzc2VkIENTUyB0ZXh0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wcm9jZXNzU3R5bGVUZXh0KGNzc1RleHQsIGJhc2VVUkkpIHtcbiAgICAgIHJldHVybiByZXNvbHZlQ3NzKGNzc1RleHQsIGJhc2VVUkkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQ29uZmlndXJlcyBhbiBlbGVtZW50IGBwcm90b2AgdG8gZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGB0ZW1wbGF0ZWAuXG4gICAgKiBUaGUgZWxlbWVudCBuYW1lIGBpc2AgYW5kIGV4dGVuZHMgYGV4dGAgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIFNoYWR5Q1NTXG4gICAgKiBzdHlsZSBzY29waW5nLlxuICAgICpcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBpcyBUYWcgbmFtZSAob3IgdHlwZSBleHRlbnNpb24gbmFtZSkgZm9yIHRoaXMgZWxlbWVudFxuICAgICogQHJldHVybiB7dm9pZH1cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqIEBub2NvbGxhcHNlXG4gICAgKi9cbiAgICBzdGF0aWMgX2ZpbmFsaXplVGVtcGxhdGUoaXMpIHtcbiAgICAgIC8qKiBAY29uc3Qge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkKSB7XG4gICAgICAgIHRlbXBsYXRlLl9fcG9seW1lckZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSB0aGlzLmltcG9ydFBhdGg7XG4gICAgICAgIGNvbnN0IGJhc2VVUkkgPSBpbXBvcnRQYXRoID8gcmVzb2x2ZVVybChpbXBvcnRQYXRoKSA6ICcnO1xuICAgICAgICAvLyBlLmcuIHN1cHBvcnQgYGluY2x1ZGU9XCJtb2R1bGUtbmFtZVwiYCwgYW5kIFNoYWR5Q1NTXG4gICAgICAgIHByb2Nlc3NFbGVtZW50U3R5bGVzKHRoaXMsIHRlbXBsYXRlLCBpcywgYmFzZVVSSSk7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGVuYWJsZXMgdGhlIHByb3BlcnR5IGVmZmVjdHMgc3lzdGVtIGFuZFxuICAgICAqIGZsdXNoZXMgYW55IHBlbmRpbmcgcHJvcGVydGllcywgYW5kIHVwZGF0ZXMgc2hpbW1lZCBDU1MgcHJvcGVydGllc1xuICAgICAqIHdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcvY3VzdG9tIHByb3BlcnRpZXMgcG9seWZpbGwuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzLCBpbnZhbGlkQ2FzdHN9IFN1cGVyIG1heSBvciBtYXkgbm90XG4gICAgICogICAgIGltcGxlbWVudCB0aGUgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YW1wcyB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0aGlzLl90ZW1wbGF0ZSk7XG4gICAgICAgIHRoaXMuJCA9IHRoaXMucm9vdC4kO1xuICAgICAgfVxuICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUVmZmVjdHNgJ3MgYF9yZWFkeUNsaWVudHNgIGNhbGwuIEF0dGFjaGVzXG4gICAgICogZWxlbWVudCBkb20gYnkgY2FsbGluZyBgX2F0dGFjaERvbWAgd2l0aCB0aGUgZG9tIHN0YW1wZWQgZnJvbSB0aGVcbiAgICAgKiBlbGVtZW50J3MgdGVtcGxhdGUgdmlhIGBfc3RhbXBUZW1wbGF0ZWAuIE5vdGUgdGhhdCB0aGlzIGFsbG93c1xuICAgICAqIGNsaWVudCBkb20gdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQgcHJpb3IgdG8gYW55IG9ic2VydmVyc1xuICAgICAqIHJ1bm5pbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fYXR0YWNoRG9tKC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlfSAqLyh0aGlzLnJvb3QpKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBzdXBlci5fcmVhZHlDbGllbnRzIGhlcmUgc2V0cyB0aGUgY2xpZW50cyBpbml0aWFsaXplZCBmbGFnLlxuICAgICAgLy8gV2UgbXVzdCB3YWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBjcmVhdGVkL2F0dGFjaGVkXG4gICAgICAvLyBzbyB0aGF0IHRoaXMgZmxhZyBjYW4gYmUgY2hlY2tlZCB0byBwcmV2ZW50IG5vdGlmaWNhdGlvbnMgZmlyZWRcbiAgICAgIC8vIGR1cmluZyB0aGlzIHByb2Nlc3MgZnJvbSBiZWluZyBoYW5kbGVkIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgIHN1cGVyLl9yZWFkeUNsaWVudHMoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuIGVsZW1lbnQncyBzdGFtcGVkIGRvbSB0byBpdHNlbGYuIEJ5IGRlZmF1bHQsXG4gICAgICogdGhpcyBtZXRob2QgY3JlYXRlcyBhIGBzaGFkb3dSb290YCBhbmQgYWRkcyB0aGUgZG9tIHRvIGl0LlxuICAgICAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFsbG93IGFuIGVsZW1lbnRcbiAgICAgKiB0byBwdXQgaXRzIGRvbSBpbiBhbm90aGVyIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUmV0dXJufVxuICAgICAqIEBwYXJhbSB7U3RhbXBlZFRlbXBsYXRlfSBkb20gdG8gYXR0YWNoIHRvIHRoZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge1NoYWRvd1Jvb3R9IG5vZGUgdG8gd2hpY2ggdGhlIGRvbSBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBfYXR0YWNoRG9tKGRvbSkge1xuICAgICAgY29uc3QgbiA9IHdyYXAodGhpcyk7XG4gICAgICBpZiAobi5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgIGlmICghbi5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBuLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nLCBzaGFkeVVwZ3JhZGVGcmFnbWVudDogZG9tfSk7XG4gICAgICAgICAgICBuLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgIC8vIFdoZW4gYGFkb3B0ZWRTdHlsZVNoZWV0c2AgaXMgc3VwcG9ydGVkIGEgc3R5bGVzaGVldCBpcyBtYWRlXG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgb24gdGhlIGVsZW1lbnQgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICBuLnNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW3RoaXMuY29uc3RydWN0b3IuX3N0eWxlU2hlZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3luY0luaXRpYWxSZW5kZXIgJiYgd2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgICAgICB3aW5kb3cuU2hhZHlET00uZmx1c2hJbml0aWFsKG4uc2hhZG93Um9vdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuLnNoYWRvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRvd0RPTSBub3QgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBtb3ZlIHRvIGNvbXBpbGUtdGltZSBjb25kaXRpb25hbCB3aGVuIHN1cHBvcnRlZFxuICAgICAgICAnUG9seW1lckVsZW1lbnQgY2FuIGNyZWF0ZSBkb20gYXMgY2hpbGRyZW4gaW5zdGVhZCBvZiBpbiAnICtcbiAgICAgICAgJ1NoYWRvd0RPTSBieSBzZXR0aW5nIGB0aGlzLnJvb3QgPSB0aGlzO1xcYCBiZWZvcmUgXFxgcmVhZHlcXGAuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnR5IHNoaW0sIGNhdXNlcyBhbGxcbiAgICAgKiBzaGltbWVkIHN0eWxlcyBpbiB0aGlzIGVsZW1lbnQgKGFuZCBpdHMgc3VidHJlZSkgdG8gYmUgdXBkYXRlZFxuICAgICAqIGJhc2VkIG9uIGN1cnJlbnQgY3VzdG9tIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgb3ZlcnJpZGVzIGlubGluZSBjdXN0b20gcHJvcGVydHkgc3R5bGVzIHdpdGggYW5cbiAgICAgKiBvYmplY3Qgb2YgcHJvcGVydGllcyB3aGVyZSB0aGUga2V5cyBhcmUgQ1NTIHByb3BlcnRpZXMsIGFuZCB0aGUgdmFsdWVzXG4gICAgICogYXJlIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOiBgdGhpcy51cGRhdGVTdHlsZXMoeyctLWNvbG9yJzogJ2JsdWUnfSlgXG4gICAgICpcbiAgICAgKiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCB1bmxlc3MgYSB2YWx1ZSBvZiBgbnVsbGAgaXMgc2V0LlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IHVwZGF0aW5nIENTUyBtaXhpbnMuXG4gICAgICogWW91IGNhbiBub3QgZHluYW1pY2FsbHkgY2hhbmdlIHRoZSB2YWx1ZSBvZiBhbiBgQGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICAgKiAgIGFwcGx5IHRvIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIHVwZGF0ZVN0eWxlcyhwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZVN1YnRyZWUoLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKHRoaXMpLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXdyaXRlcyBhIGdpdmVuIFVSTCByZWxhdGl2ZSB0byBhIGJhc2UgVVJMLiBUaGUgYmFzZSBVUkwgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIGRvY3VtZW50IGNvbnRhaW5pbmcgdGhlIGBkb20tbW9kdWxlYCBmb3JcbiAgICAgKiB0aGlzIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lIFVSTCBiZWZvcmUgYW5kIGFmdGVyXG4gICAgICogYnVuZGxpbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBubyByZXNvbHV0aW9uIGZvciBVUkxzIHRoYXQgc3RhcnRcbiAgICAgKiB3aXRoIGAvYCAoYWJzb2x1dGUgVVJMcykgb3IgYCNgIChoYXNoIGlkZW50aWZpZXJzKS4gIEZvciBnZW5lcmFsIHB1cnBvc2VcbiAgICAgKiBVUkwgcmVzb2x1dGlvbiwgdXNlIGB3aW5kb3cuVVJMYC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlIE9wdGlvbmFsIGJhc2UgVVJMIHRvIHJlc29sdmUgYWdhaW5zdCwgZGVmYXVsdHNcbiAgICAgKiB0byB0aGUgZWxlbWVudCdzIGBpbXBvcnRQYXRoYFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV3cml0dGVuIFVSTCByZWxhdGl2ZSB0byBiYXNlXG4gICAgICovXG4gICAgcmVzb2x2ZVVybCh1cmwsIGJhc2UpIHtcbiAgICAgIGlmICghYmFzZSAmJiB0aGlzLmltcG9ydFBhdGgpIHtcbiAgICAgICAgYmFzZSA9IHJlc29sdmVVcmwodGhpcy5pbXBvcnRQYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlVXJsKHVybCwgYmFzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGFkZCBtYXAgb2YgZHluYW1pYyBmdW5jdGlvbnMgb25cbiAgICAgKiB0ZW1wbGF0ZSBpbmZvLCBmb3IgY29uc3VtcHRpb24gYnkgYFByb3BlcnR5RWZmZWN0c2AgdGVtcGxhdGUgYmluZGluZ1xuICAgICAqIGNvZGUuIFRoaXMgbWFwIGRldGVybWluZXMgd2hpY2ggbWV0aG9kIHRlbXBsYXRlcyBzaG91bGQgaGF2ZSBhY2Nlc3NvcnNcbiAgICAgKiBjcmVhdGVkIGZvciB0aGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC5cbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIHRlbXBsYXRlSW5mby5keW5hbWljRm5zID0gdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgfHwgdGhpcy5fcHJvcGVydGllcztcbiAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMjQwKTpcbiAgICAgIC8vICAgICBDaGFuZ2UgYmFjayB0byBqdXN0IHN1cGVyLm1ldGhvZENhbGwoKVxuICAgICAgcmV0dXJuIHBvbHltZXJFbGVtZW50QmFzZS5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQuY2FsbChcbiAgICAgICAgdGhpcywgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlFZmZlY3RzYCB0byB3YXJuIG9uIHVzZSBvZiB1bmRlY2xhcmVkIHByb3BlcnRpZXMgaW5cbiAgICAgKiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgdG8gYWRkIGVmZmVjdCB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgLy8gV2FybiBpZiBwcm9wZXJ0aWVzIGFyZSB1c2VkIGluIHRlbXBsYXRlIHdpdGhvdXQgYmVpbmcgZGVjbGFyZWQuXG4gICAgICAvLyBQcm9wZXJ0aWVzIG11c3QgYmUgbGlzdGVkIGluIGBwcm9wZXJ0aWVzYCB0byBiZSBpbmNsdWRlZCBpblxuICAgICAgLy8gYG9ic2VydmVkQXR0cmlidXRlc2Agc2luY2UgQ0UgVjEgcmVhZHMgdGhhdCBhdCByZWdpc3RyYXRpb24gdGltZSwgYW5kXG4gICAgICAvLyBzaW5jZSB3ZSB3YW50IHRvIGtlZXAgdGVtcGxhdGUgcGFyc2luZyBsYXp5LCB3ZSBjYW4ndCBhdXRvbWF0aWNhbGx5XG4gICAgICAvLyBhZGQgdW5kZWNsYXJlZCBwcm9wZXJ0aWVzIHVzZWQgaW4gdGVtcGxhdGVzIHRvIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICAgICAgLy8gVGhlIHdhcm5pbmcgaXMgb25seSBlbmFibGVkIGluIGBsZWdhY3lPcHRpbWl6YXRpb25zYCBtb2RlLCBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBzcGFtIGV4aXN0aW5nIHVzZXJzIHdobyBtaWdodCBoYXZlIGFkb3B0ZWQgdGhlXG4gICAgICAvLyBzaG9ydGhhbmQgd2hlbiBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBvcnRhbnQuXG4gICAgICBpZiAobGVnYWN5V2FybmluZ3MgJiYgIShwcm9wIGluIHRoaXMuX3Byb3BlcnRpZXMpICYmXG4gICAgICAgICAgLy8gTWV0aG9kcyB1c2VkIGluIHRlbXBsYXRlcyB3aXRoIG5vIGRlcGVuZGVuY2llcyAob3Igb25seSBsaXRlcmFsXG4gICAgICAgICAgLy8gZGVwZW5kZW5jaWVzKSBiZWNvbWUgYWNjZXNzb3JzIHdpdGggdGVtcGxhdGUgZWZmZWN0czsgaWdub3JlIHRoZXNlXG4gICAgICAgICAgIShlZmZlY3QuaW5mby5wYXJ0LnNpZ25hdHVyZSAmJiBlZmZlY3QuaW5mby5wYXJ0LnNpZ25hdHVyZS5zdGF0aWMpICYmXG4gICAgICAgICAgLy8gV2FybmluZ3MgZm9yIGJpbmRpbmdzIGFkZGVkIHRvIG5lc3RlZCB0ZW1wbGF0ZXMgYXJlIGhhbmRsZWQgYnlcbiAgICAgICAgICAvLyB0ZW1wbGF0aXplciBzbyBpZ25vcmUgYm90aCB0aGUgaG9zdC10by10ZW1wbGF0ZSBiaW5kaW5nc1xuICAgICAgICAgIC8vIChgaG9zdFByb3BgKSBhbmQgVGVtcGxhdGVJbnN0YW5jZS10by1jaGlsZCBiaW5kaW5nc1xuICAgICAgICAgIC8vIChgbmVzdGVkVGVtcGxhdGVgKVxuICAgICAgICAgICFlZmZlY3QuaW5mby5wYXJ0Lmhvc3RQcm9wICYmICF0ZW1wbGF0ZUluZm8ubmVzdGVkVGVtcGxhdGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQcm9wZXJ0eSAnJHtwcm9wfScgdXNlZCBpbiB0ZW1wbGF0ZSBidXQgbm90IGRlY2xhcmVkIGluICdwcm9wZXJ0aWVzJzsgYCArXG4gICAgICAgICAgYGF0dHJpYnV0ZSB3aWxsIG5vdCBiZSBvYnNlcnZlZC5gKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMjQwKTpcbiAgICAgIC8vICAgICBDaGFuZ2UgYmFjayB0byBqdXN0IHN1cGVyLm1ldGhvZENhbGwoKVxuICAgICAgcmV0dXJuIHBvbHltZXJFbGVtZW50QmFzZS5fYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdC5jYWxsKFxuICAgICAgICB0aGlzLCB0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gUG9seW1lckVsZW1lbnQ7XG59KTtcblxuLyoqXG4gKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICogc2hpbW1lZCBgc3R5bGVzYCAodmlhIGBjdXN0b20tc3R5bGVgKSBpbiB0aGUgZG9jdW1lbnQgKGFuZCBpdHMgc3VidHJlZSlcbiAqIHRvIGJlIHVwZGF0ZWQgYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgb3ZlcnJpZGVzIGlubGluZSBjdXN0b20gcHJvcGVydHkgc3R5bGVzIHdpdGggYW5cbiAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAqIGFyZSBzdHJpbmdzLlxuICpcbiAqIEV4YW1wbGU6IGB1cGRhdGVTdHlsZXMoeyctLWNvbG9yJzogJ2JsdWUnfSlgXG4gKlxuICogVGhlc2UgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgdW5sZXNzIGEgdmFsdWUgb2YgYG51bGxgIGlzIHNldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BzIEJhZyBvZiBjdXN0b20gcHJvcGVydHkga2V5L3ZhbHVlcyB0b1xuICogICBhcHBseSB0byB0aGUgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlU3R5bGVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZURvY3VtZW50KHByb3BzKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/element-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-changed.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-changed.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertiesChanged\": () => (/* binding */ PropertiesChanged)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/async.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/async.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/** @const {!AsyncInterface} */\nconst microtask = _utils_async_js__WEBPACK_IMPORTED_MODULE_2__.microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertiesChanged = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      const proto = this.prototype;\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) {} //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     * @override\n     */\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n      // This check is technically not correct; it's an optimization that\n      // assumes that if a _property_ name is already in the map (note this is\n      // an attr->property map), the property mapped directly to the attribute\n      // and it has already been mapped.  This would fail if\n      // `attributeNameForProperty` were overridden such that this was not the\n      // case.\n      let attr = this.__dataAttributes[property];\n      if (!attr) {\n        attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n      return attr;\n    }\n\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n        /** @this {PropertiesChanged} */\n        get() {\n          // Inline for perf instead of using `_getProperty`\n          return this.__data[property];\n        },\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          // Inline for perf instead of using `_setProperty`\n          if (this._setPendingProperty(property, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n        /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      this.__dataCounter = 0;\n      this.__serializing = false;\n      this._initializeProperties();\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n    ready() {\n      this.__dataReady = true;\n      this._flushProperties();\n    }\n\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     * @override\n     */\n    _getProperty(property) {\n      return this.__data[property];\n    }\n\n    /* eslint-disable no-unused-vars */\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     * @override\n     */\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n      let changed = this._shouldPropertyChange(property, value, old);\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property is pending.\n     */\n    _isPropertyPending(property) {\n      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\n    }\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n            this._flushProperties();\n          }\n        });\n      }\n    }\n\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n          this.__dataInstanceProps = null;\n        }\n        this.ready();\n      }\n    }\n\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _flushProperties() {\n      this.__dataCounter++;\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this._propertiesChanged(props, changedProps, old);\n      }\n      this.__dataCounter--;\n    }\n\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     * @override\n     */\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n      // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {// eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n    _shouldPropertyChange(property, value, old) {\n      return (\n        // Strict equality check\n        old !== value && (\n        // This ensures (old==NaN, value==NaN) always returns false\n        old === old || value === value)\n      );\n    }\n\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     * @override\n     */\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n      }\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     * @override\n     */\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = arguments.length < 3 ? this[property] : value;\n      this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));\n      this.__serializing = false;\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     * @override\n     */\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n        node = /** @type {?Element} */(0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(node);\n      }\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(attribute,\n        // Closure's type for `setAttribute`'s second parameter incorrectly\n        // excludes `TrustedScript`.\n        str === '' && window.trustedTypes ? /** @type {?} */window.trustedTypes.emptyScript : str);\n      }\n    }\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     * @override\n     */\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return value !== null;\n        case Number:\n          return Number(value);\n        default:\n          return value;\n      }\n    }\n  }\n  return PropertiesChanged;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0aWVzLWNoYW5nZWQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0aWVzLWNoYW5nZWQuanM/N2Y4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcblxuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcbmltcG9ydCB7IHdyYXAgfSBmcm9tICcuLi91dGlscy93cmFwLmpzJztcblxuLyoqIEBjb25zdCB7IUFzeW5jSW50ZXJmYWNlfSAqL1xuY29uc3QgbWljcm90YXNrID0gbWljcm9UYXNrO1xuXG4vKipcbiAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyBtZXRhLXByb2dyYW1taW5nIGZvciBjcmVhdGluZyBvbmVcbiAqIG9yIG1vcmUgcHJvcGVydHkgYWNjZXNzb3JzIChnZXR0ZXIvc2V0dGVyIHBhaXIpIHRoYXQgZW5xdWV1ZSBhbiBhc3luY1xuICogKGJhdGNoZWQpIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICpcbiAqIEZvciBiYXNpYyB1c2FnZSBvZiB0aGlzIG1peGluLCBjYWxsIGBNeUNsYXNzLmNyZWF0ZVByb3BlcnRpZXMocHJvcHMpYFxuICogb25jZSBhdCBjbGFzcyBkZWZpbml0aW9uIHRpbWUgdG8gY3JlYXRlIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgcHJvcGVydGllc1xuICogbmFtZWQgaW4gcHJvcHMsIGltcGxlbWVudCBgX3Byb3BlcnRpZXNDaGFuZ2VkYCB0byByZWFjdCBhcyBkZXNpcmVkIHRvXG4gKiBwcm9wZXJ0eSBjaGFuZ2VzLCBhbmQgaW1wbGVtZW50IGBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpYCBhbmRcbiAqIGluY2x1ZGUgbG93ZXJjYXNlIHZlcnNpb25zIG9mIGFueSBwcm9wZXJ0eSBuYW1lcyB0aGF0IHNob3VsZCBiZSBzZXQgZnJvbVxuICogYXR0cmlidXRlcy4gTGFzdCwgY2FsbCBgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpYCBpbiB0aGUgZWxlbWVudCdzXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIHRvIGVuYWJsZSB0aGUgYWNjZXNzb3JzLlxuICpcbiAqIEBtaXhpbkZ1bmN0aW9uXG4gKiBAcG9seW1lclxuICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiBmb3IgcmVhY3RpbmcgdG8gcHJvcGVydHkgY2hhbmdlcyBmcm9tXG4gKiAgIGdlbmVyYXRlZCBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3MgQ2xhc3MgdG8gYXBwbHkgbWl4aW4gdG8uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3Mgd2l0aCBtaXhpbiBhcHBsaWVkLlxuICovXG5leHBvcnQgY29uc3QgUHJvcGVydGllc0NoYW5nZWQgPSBkZWR1cGluZ01peGluKFxuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3MgQ2xhc3MgdG8gYXBwbHkgbWl4aW4gdG8uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlQpfSBzdXBlckNsYXNzIHdpdGggbWl4aW4gYXBwbGllZC5cbiAgICAgKi9cbiAgICAoc3VwZXJDbGFzcykgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0aWVzQ2hhbmdlZH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgUHJvcGVydGllc0NoYW5nZWQgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgcHJvcGVydHkgYWNjZXNzb3JzIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBwcm9wcyBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgbmFtZXMgb2YgYWNjZXNzb3JzLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIGNvbnN0IHByb3RvID0gdGhpcy5wcm90b3R5cGU7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIC8vIGRvbid0IHN0b21wIGFuIGV4aXN0aW5nIGFjY2Vzc29yXG4gICAgICAgIGlmICghKHByb3AgaW4gcHJvdG8pKSB7XG4gICAgICAgICAgcHJvdG8uX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSBuYW1lIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIFRoZSBhdHRyaWJ1dGUgbmFtZSBpcyB0aGUgbG93ZXJjYXNlZCBwcm9wZXJ0eSBuYW1lLiBPdmVycmlkZSB0b1xuICAgICAqIGN1c3RvbWl6ZSB0aGlzIG1hcHBpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEF0dHJpYnV0ZSBuYW1lIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGF0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgdG8gcHJvdmlkZSBhIHR5cGUgdG8gd2hpY2ggdG8gZGVzZXJpYWxpemUgYSB2YWx1ZSB0b1xuICAgICAqIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIHR5cGVGb3JQcm9wZXJ0eShuYW1lKSB7IH0gLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0dGVyL2dldHRlciBwYWlyIGZvciB0aGUgbmFtZWQgcHJvcGVydHkgd2l0aCBpdHMgb3duXG4gICAgICogbG9jYWwgc3RvcmFnZS4gIFRoZSBnZXR0ZXIgcmV0dXJucyB0aGUgdmFsdWUgaW4gdGhlIGxvY2FsIHN0b3JhZ2UsXG4gICAgICogYW5kIHRoZSBzZXR0ZXIgY2FsbHMgYF9zZXRQcm9wZXJ0eWAsIHdoaWNoIHVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2VcbiAgICAgKiBmb3IgdGhlIHByb3BlcnR5IGFuZCBlbnF1ZXVlcyBhIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiBhIHByb3RvdHlwZSBvciBhbiBpbnN0YW5jZS4gIENhbGxpbmdcbiAgICAgKiB0aGlzIG1ldGhvZCBtYXkgb3ZlcndyaXRlIGEgcHJvcGVydHkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvblxuICAgICAqIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgYnkgY3JlYXRpbmcgdGhlIGFjY2Vzc29yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVhZE9ubHkgV2hlbiB0cnVlLCBubyBzZXR0ZXIgaXMgY3JlYXRlZDsgdGhlXG4gICAgICogICBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIHNldCB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5VG9BdHRyaWJ1dGVNYXAocHJvcGVydHkpO1xuICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YUhhc0FjY2Vzc29yJywgdGhpcykpKSB7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0pIHtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZWZpbmVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCByZWFkT25seSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gYHByb3BlcnR5YCB0byBhIG1hcCBtYXRjaGluZyBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgKiB0byBwcm9wZXJ0eSBuYW1lcywgdXNpbmcgYGF0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eWAuIFRoaXMgbWFwIGlzXG4gICAgICogdXNlZCB3aGVuIGRlc2VyaWFsaXppbmcgYXR0cmlidXRlIHZhbHVlcyB0byBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZFByb3BlcnR5VG9BdHRyaWJ1dGVNYXAocHJvcGVydHkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2RhdGFBdHRyaWJ1dGVzJywgdGhpcykpKSB7XG4gICAgICAgIHRoaXMuX19kYXRhQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX19kYXRhQXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGNoZWNrIGlzIHRlY2huaWNhbGx5IG5vdCBjb3JyZWN0OyBpdCdzIGFuIG9wdGltaXphdGlvbiB0aGF0XG4gICAgICAvLyBhc3N1bWVzIHRoYXQgaWYgYSBfcHJvcGVydHlfIG5hbWUgaXMgYWxyZWFkeSBpbiB0aGUgbWFwIChub3RlIHRoaXMgaXNcbiAgICAgIC8vIGFuIGF0dHItPnByb3BlcnR5IG1hcCksIHRoZSBwcm9wZXJ0eSBtYXBwZWQgZGlyZWN0bHkgdG8gdGhlIGF0dHJpYnV0ZVxuICAgICAgLy8gYW5kIGl0IGhhcyBhbHJlYWR5IGJlZW4gbWFwcGVkLiAgVGhpcyB3b3VsZCBmYWlsIGlmXG4gICAgICAvLyBgYXR0cmlidXRlTmFtZUZvclByb3BlcnR5YCB3ZXJlIG92ZXJyaWRkZW4gc3VjaCB0aGF0IHRoaXMgd2FzIG5vdCB0aGVcbiAgICAgIC8vIGNhc2UuXG4gICAgICBsZXQgYXR0ciA9IHRoaXMuX19kYXRhQXR0cmlidXRlc1twcm9wZXJ0eV07XG4gICAgICBpZiAoIWF0dHIpIHtcbiAgICAgICAgYXR0ciA9IHRoaXMuY29uc3RydWN0b3IuYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5fX2RhdGFBdHRyaWJ1dGVzW2F0dHJdID0gcHJvcGVydHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgcHJvcGVydHkgYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWFkT25seSBXaGVuIHRydWUsIG5vIHNldHRlciBpcyBjcmVhdGVkXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICAgX2RlZmluZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAgICAgLyoqIEB0aGlzIHtQcm9wZXJ0aWVzQ2hhbmdlZH0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIC8vIElubGluZSBmb3IgcGVyZiBpbnN0ZWFkIG9mIHVzaW5nIGBfZ2V0UHJvcGVydHlgXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEB0aGlzIHtQcm9wZXJ0aWVzQ2hhbmdlZH0gKi9cbiAgICAgICAgc2V0OiByZWFkT25seSA/IGZ1bmN0aW9uICgpIHt9IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgLy8gSW5saW5lIGZvciBwZXJmIGluc3RlYWQgb2YgdXNpbmcgYF9zZXRQcm9wZXJ0eWBcbiAgICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YSA9IHt9O1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhT2xkID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIC8vIE5PVEU6IHVzZWQgdG8gdHJhY2sgcmUtZW50cmFudCBjYWxscyB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgIHRoaXMuX19kYXRhQ291bnRlciA9IDA7XG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIGNhbGxiYWNrIGNhbGxlZCB3aGVuIHByb3BlcnRpZXMgYXJlIGVuYWJsZWQgdmlhXG4gICAgICogYF9lbmFibGVQcm9wZXJ0aWVzYC5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGltcGxlbWVudCBiZWhhdmlvciB0aGF0IGlzXG4gICAgICogZGVwZW5kZW50IG9uIHRoZSBlbGVtZW50IGhhdmluZyBpdHMgcHJvcGVydHkgZGF0YSBpbml0aWFsaXplZCwgZS5nLlxuICAgICAqIGZyb20gZGVmYXVsdHMgKGluaXRpYWxpemVkIGZyb20gYGNvbnN0cnVjdG9yYCwgYF9pbml0aWFsaXplUHJvcGVydGllc2ApLFxuICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvciB2YWx1ZXMgcHJvcGFnYXRlZCBmcm9tIGhvc3QgZS5nLiB2aWFcbiAgICAgKiBiaW5kaW5ncy4gIGBzdXBlci5yZWFkeSgpYCBtdXN0IGJlIGNhbGxlZCB0byBlbnN1cmUgdGhlIGRhdGEgc3lzdGVtXG4gICAgICogYmVjb21lcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHVibGljXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICpcbiAgICAgKiBQcm92aWRlZCBhcyBhbiBvdmVycmlkZSBwb2ludCBmb3IgcGVyZm9ybWluZyBhbnkgc2V0dXAgd29yayBwcmlvclxuICAgICAqIHRvIGluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgYWNjZXNzb3Igc3lzdGVtLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgLy8gQ2FwdHVyZSBpbnN0YW5jZSBwcm9wZXJ0aWVzOyB0aGVzZSB3aWxsIGJlIHNldCBpbnRvIGFjY2Vzc29yc1xuICAgICAgLy8gZHVyaW5nIGZpcnN0IGZsdXNoLiBEb24ndCBzZXQgdGhlbSBoZXJlLCBzaW5jZSB3ZSB3YW50XG4gICAgICAvLyB0aGVzZSB0byBvdmVyd3JpdGUgZGVmYXVsdHMvY29uc3RydWN0b3IgYXNzaWdubWVudHNcbiAgICAgIGZvciAobGV0IHAgaW4gdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHNbcF0gPSB0aGlzW3BdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IHJlYWR5IHRpbWUgd2l0aCBiYWcgb2YgaW5zdGFuY2UgcHJvcGVydGllcyB0aGF0IG92ZXJ3cm90ZVxuICAgICAqIGFjY2Vzc29ycyB3aGVuIHRoZSBlbGVtZW50IHVwZ3JhZGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgKiBzZXR0ZXIgYXQgcmVhZHkgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHkgKHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWApXG4gICAgICogYW5kIGVucXVldWVzIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBmb3IgdGhlIGdpdmVuIHByb3BlcnR5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9nZXRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHksIHJlY29yZHMgdGhlIHByZXZpb3VzIHZhbHVlLFxuICAgICAqIGFuZCBhZGRzIGl0IHRvIHRoZSBzZXQgb2YgXCJwZW5kaW5nIGNoYW5nZXNcIiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLiAgVGhpcyBtZXRob2QgZG9lcyBub3QgZW5xdWV1ZSB0aGVcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZXh0IE5vdCB1c2VkIGhlcmU7IGFmZm9yZGFuY2UgZm9yIGNsb3N1cmVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIGV4dCkge1xuICAgICAgbGV0IG9sZCA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YU9sZCAmJiAhKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgaXMgcGVuZGluZy5cbiAgICAgKi9cbiAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLl9fZGF0YVBlbmRpbmcgJiYgdGhpcy5fX2RhdGFQZW5kaW5nLmhhc093blByb3BlcnR5KHByb3BlcnR5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHByb3BlcnRpZXMgYXMgaW52YWxpZCwgYW5kIGVucXVldWVzIGFuIGFzeW5jXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhSW52YWxpZCAmJiB0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IHRydWU7XG4gICAgICAgIG1pY3JvdGFzay5ydW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUludmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRvIGVuYWJsZSBwcm9wZXJ0eSBhY2Nlc3NvciBwcm9jZXNzaW5nLiBCZWZvcmUgdGhpcyBtZXRob2QgaXNcbiAgICAgKiBjYWxsZWQgYWNjZXNzb3IgdmFsdWVzIHdpbGwgYmUgc2V0IGJ1dCBzaWRlIGVmZmVjdHMgYXJlXG4gICAgICogcXVldWVkLiBXaGVuIGNhbGxlZCwgYW55IHBlbmRpbmcgc2lkZSBlZmZlY3RzIG9jY3VyIGltbWVkaWF0ZWx5LlxuICAgICAqIEZvciBlbGVtZW50cywgZ2VuZXJhbGx5IGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgYSBub3JtYWwgc3BvdCB0byBkbyBzby5cbiAgICAgKiBJdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgYXMgaXQgb25seSB0dXJucyBvblxuICAgICAqIHByb3BlcnR5IGFjY2Vzc29ycyBvbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2VuYWJsZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpO1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHNldCBvZlxuICAgICAqIHBlbmRpbmcgY2hhbmdlcyAoYW5kIG9sZCB2YWx1ZXMgcmVjb3JkZWQgd2hlbiBwZW5kaW5nIGNoYW5nZXMgd2VyZVxuICAgICAqIHNldCksIGFuZCByZXNldHMgdGhlIHBlbmRpbmcgc2V0IG9mIGNoYW5nZXMuIEdlbmVyYWxseSwgdGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgbm90IGJlIGNhbGxlZCBpbiB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfZmx1c2hQcm9wZXJ0aWVzKCkge1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyKys7XG4gICAgICBjb25zdCBwcm9wcyA9IHRoaXMuX19kYXRhO1xuICAgICAgY29uc3QgY2hhbmdlZFByb3BzID0gdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgY29uc3Qgb2xkID0gdGhpcy5fX2RhdGFPbGQ7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkUHJvcGVydGllc0NoYW5nZShwcm9wcywgY2hhbmdlZFByb3BzLCBvbGQpKSB7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhT2xkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0NoYW5nZWQocHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19kYXRhQ291bnRlci0tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBpbiBgX2ZsdXNoUHJvcGVydGllc2AgdG8gZGV0ZXJtaW5lIGlmIGBfcHJvcGVydGllc0NoYW5nZWRgXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlIGlmXG4gICAgICogcHJvcGVydGllcyBhcmUgcGVuZGluZy4gT3ZlcnJpZGUgdG8gY3VzdG9taXplIHdoZW5cbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpcyBjYWxsZWQuXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjdXJyZW50UHJvcHMgQmFnIG9mIGFsbCBjdXJyZW50IGFjY2Vzc29yIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7P09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3RcbiAgICAgKiAgIGNhbGwgdG8gYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgKiAgIGluIGBjaGFuZ2VkUHJvcHNgXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBjaGFuZ2VkUHJvcHMgaXMgdHJ1dGh5XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnRpZXNDaGFuZ2UoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBCb29sZWFuKGNoYW5nZWRQcm9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYW55IHByb3BlcnRpZXMgd2l0aCBhY2Nlc3NvcnMgY3JlYXRlZCB2aWFcbiAgICAgKiBgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3JgIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAqIEBwYXJhbSB7P09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FsbGVkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcHJvcGVydHkgdmFsdWUgc2hvdWxkIGJlXG4gICAgICogY29uc2lkZXJlZCBhcyBhIGNoYW5nZSBhbmQgY2F1c2UgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICogdG8gYmUgZW5xdWV1ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGB0cnVlYCBpZiBhIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGNoZWNrIGZhaWxzLiBUaGUgbWV0aG9kIGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBgTmFOYC5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGUuZy4gcHJvdmlkZSBzdHJpY3RlciBjaGVja2luZyBmb3JcbiAgICAgKiBPYmplY3RzL0FycmF5cyB3aGVuIHVzaW5nIGltbXV0YWJsZSBwYXR0ZXJucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogICBhbmQgZW5xdWV1ZSBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAgICAgIChvbGQgIT09IHZhbHVlICYmXG4gICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIChvbGQ9PU5hTiwgdmFsdWU9PU5hTikgYWx3YXlzIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBuYXRpdmUgQ3VzdG9tIEVsZW1lbnRzIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvXG4gICAgICogc2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSB0byBhIHByb3BlcnR5IHZpYSBgX2F0dHJpYnV0ZVRvUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUgdGhhdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgTmV3IGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlIEF0dHJpYnV0ZSBuYW1lc3BhY2UuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBTdXBlciBtYXkgb3IgbWF5IG5vdCBpbXBsZW1lbnQgdGhlIGNhbGxiYWNrXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUsIG5hbWVzcGFjZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhbiBhdHRyaWJ1dGUgdG8gaXRzIGFzc29jaWF0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgc3RyaW5nIHRvXG4gICAgICogYSB0eXBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgdHlwZSB0byBkZXNlcmlhbGl6ZSB0bywgZGVmYXVsdHMgdG8gdGhlIHZhbHVlXG4gICAgICogcmV0dXJuZWQgZnJvbSBgdHlwZUZvclByb3BlcnR5YFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2F0dHJpYnV0ZVRvUHJvcGVydHkoYXR0cmlidXRlLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgaWYgKCF0aGlzLl9fc2VyaWFsaXppbmcpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5fX2RhdGFBdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IG1hcCAmJiBtYXBbYXR0cmlidXRlXSB8fCBhdHRyaWJ1dGU7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSB8fFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IudHlwZUZvclByb3BlcnR5KHByb3BlcnR5KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfSBDbG9zdXJlIGNhbid0IGZpZ3VyZSBvdXQgYHRoaXNgIGlzIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QgdG8uXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gcmVmZWN0LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyB0aGlzW3Byb3BlcnR5XSA6IHZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKHRoaXMpLCB2YWx1ZSxcbiAgICAgICAgYXR0cmlidXRlIHx8IHRoaXMuY29uc3RydWN0b3IuYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KHByb3BlcnR5KSk7XG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdHlwZWQgdmFsdWUgdG8gYW4gSFRNTCBhdHRyaWJ1dGUgb24gYSBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSB0eXBlZFxuICAgICAqIHZhbHVlIHRvIGEgc3RyaW5nLiAgSWYgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkICh0aGlzIGlzIHRoZSBkZWZhdWx0IGZvciBib29sZWFuXG4gICAgICogdHlwZSBgZmFsc2VgKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHNldCBhdHRyaWJ1dGUgdG8uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfdmFsdWVUb05vZGVBdHRyaWJ1dGUobm9kZSwgdmFsdWUsIGF0dHJpYnV0ZSkge1xuICAgICAgY29uc3Qgc3RyID0gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgaWYgKGF0dHJpYnV0ZSA9PT0gJ2NsYXNzJyB8fCBhdHRyaWJ1dGUgPT09ICduYW1lJyB8fCBhdHRyaWJ1dGUgPT09ICdzbG90Jykge1xuICAgICAgICBub2RlID0gLyoqIEB0eXBlIHs/RWxlbWVudH0gKi8od3JhcChub2RlKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgICAgLy8gQ2xvc3VyZSdzIHR5cGUgZm9yIGBzZXRBdHRyaWJ1dGVgJ3Mgc2Vjb25kIHBhcmFtZXRlciBpbmNvcnJlY3RseVxuICAgICAgICAgICAgLy8gZXhjbHVkZXMgYFRydXN0ZWRTY3JpcHRgLlxuICAgICAgICAgICAgKHN0ciA9PT0gJycgJiYgd2luZG93LnRydXN0ZWRUeXBlcykgP1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi8gKHdpbmRvdy50cnVzdGVkVHlwZXMuZW1wdHlTY3JpcHQpIDpcbiAgICAgICAgICAgICAgICBzdHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHNldHRpbmcgSlMgcHJvcGVydHkgdmFsdWVzIHRvXG4gICAgICogSFRNTCBhdHRyaWJ1dGVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGVcbiAgICAgKiBzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFN0cmluZyBzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkXG4gICAgICogcHJvcGVydHkgIHZhbHVlLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID8gJycgOiB1bmRlZmluZWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS50b1N0cmluZygpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHJlYWRpbmcgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzIHRvXG4gICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlXG4gICAgICogZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gVHlwZXMgZm9yIGBCb29sZWFuYCwgYFN0cmluZ2AsXG4gICAgICogYW5kIGBOdW1iZXJgIGNvbnZlcnQgYXR0cmlidXRlcyB0byB0aGUgZXhwZWN0ZWQgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIFZhbHVlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvLlxuICAgICAqIEByZXR1cm4geyp9IFR5cGVkIHZhbHVlIGRlc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgcmV0dXJuICh2YWx1ZSAhPT0gbnVsbCk7XG4gICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQcm9wZXJ0aWVzQ2hhbmdlZDtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-changed.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertiesMixin\": () => (/* binding */ PropertiesMixin)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/telemetry.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/telemetry.js\");\n/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * Creates a copy of `props` with each property normalized such that\n * upgraded it is an object with at least a type property { type: Type}.\n *\n * @param {!Object} props Properties to normalize\n * @return {!Object} Copy of input `props` with normalized properties that\n * are in the form {type: Type}\n * @private\n */\nfunction normalizeProperties(props) {\n  const output = {};\n  for (let p in props) {\n    const o = props[p];\n    output[p] = typeof o === 'function' ? {\n      type: o\n    } : o;\n  }\n  return output;\n}\n\n/**\n * Mixin that provides a minimal starting point to using the PropertiesChanged\n * mixin by providing a mechanism to declare properties in a static\n * getter (e.g. static get properties() { return { foo: String } }). Changes\n * are reported via the `_propertiesChanged` method.\n *\n * This mixin provides no specific support for rendering. Users are expected\n * to create a ShadowRoot and put content into it and update it in whatever\n * way makes sense. This can be done in reaction to properties changing by\n * implementing `_propertiesChanged`.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Mixin that provides a minimal starting point for using\n * the PropertiesChanged mixin by providing a declarative `properties` object.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertiesMixin = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @private\n   */\n  const base = (0,_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__.PropertiesChanged)(superClass);\n\n  /**\n   * Returns the super class constructor for the given class, if it is an\n   * instance of the PropertiesMixin.\n   *\n   * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor\n   * @return {?PropertiesMixinConstructor} Super class constructor\n   */\n  function superPropertiesClass(constructor) {\n    const superCtor = Object.getPrototypeOf(constructor);\n\n    // Note, the `PropertiesMixin` class below only refers to the class\n    // generated by this call to the mixin; the instanceof test only works\n    // because the mixin is deduped and guaranteed only to apply once, hence\n    // all constructors in a proto chain will see the same `PropertiesMixin`\n    return superCtor.prototype instanceof PropertiesMixin ? /** @type {!PropertiesMixinConstructor} */superCtor : null;\n  }\n\n  /**\n   * Returns a memoized version of the `properties` object for the\n   * given class. Properties not in object format are converted to at\n   * least {type}.\n   *\n   * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor\n   * @return {Object} Memoized properties object\n   */\n  function ownProperties(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {\n      let props = null;\n      if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {\n        const properties = constructor.properties;\n        if (properties) {\n          props = normalizeProperties(properties);\n        }\n      }\n      constructor.__ownProperties = props;\n    }\n    return constructor.__ownProperties;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {base}\n   * @implements {Polymer_PropertiesMixin}\n   * @unrestricted\n   */\n  class PropertiesMixin extends base {\n    /**\n     * Implements standard custom elements getter to observes the attributes\n     * listed in `properties`.\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static get observedAttributes() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n        (0,_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__.register)(this.prototype);\n        const props = this._properties;\n        this.__observedAttributes = props ? Object.keys(props).map(p => this.prototype._addPropertyToAttributeMap(p)) : [];\n      }\n      return this.__observedAttributes;\n    }\n\n    /**\n     * Finalizes an element definition, including ensuring any super classes\n     * are also finalized. This includes ensuring property\n     * accessors exist on the element prototype. This method calls\n     * `_finalizeClass` to finalize each constructor in the prototype chain.\n     * @return {void}\n     * @nocollapse\n     */\n    static finalize() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {\n        const superCtor = superPropertiesClass( /** @type {!PropertiesMixinConstructor} */this);\n        if (superCtor) {\n          superCtor.finalize();\n        }\n        this.__finalized = true;\n        this._finalizeClass();\n      }\n    }\n\n    /**\n     * Finalize an element class. This includes ensuring property\n     * accessors exist on the element prototype. This method is called by\n     * `finalize` and finalizes the class constructor.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static _finalizeClass() {\n      const props = ownProperties( /** @type {!PropertiesMixinConstructor} */this);\n      if (props) {\n        /** @type {?} */this.createProperties(props);\n      }\n    }\n\n    /**\n     * Returns a memoized version of all properties, including those inherited\n     * from super classes. Properties not in object format are converted to\n     * at least {type}.\n     *\n     * @return {Object} Object containing properties for this class\n     * @protected\n     * @nocollapse\n     */\n    static get _properties() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {\n        const superCtor = superPropertiesClass( /** @type {!PropertiesMixinConstructor} */this);\n        this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties( /** @type {PropertiesMixinConstructor} */this));\n      }\n      return this.__properties;\n    }\n\n    /**\n     * Overrides `PropertiesChanged` method to return type specified in the\n     * static `properties` object for the given property.\n     * @param {string} name Name of property\n     * @return {*} Type to which to deserialize attribute\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) {\n      const info = this._properties[name];\n      return info && info.type;\n    }\n\n    /**\n     * Overrides `PropertiesChanged` method and adds a call to\n     * `finalize` which lazily configures the element's property accessors.\n     * @override\n     * @return {void}\n     */\n    _initializeProperties() {\n      (0,_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__.incrementInstanceCount)();\n      this.constructor.finalize();\n      super._initializeProperties();\n    }\n\n    /**\n     * Called when the element is added to a document.\n     * Calls `_enableProperties` to turn on property system from\n     * `PropertiesChanged`.\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @return {void}\n     * @override\n     */\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n      this._enableProperties();\n    }\n\n    /**\n     * Called when the element is removed from a document\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @return {void}\n     * @override\n     */\n    disconnectedCallback() {\n      if (super.disconnectedCallback) {\n        super.disconnectedCallback();\n      }\n    }\n  }\n  return PropertiesMixin;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0aWVzLW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnRpZXMtbWl4aW4uanM/YTMxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcblxuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHJlZ2lzdGVyLCBpbmNyZW1lbnRJbnN0YW5jZUNvdW50IH0gZnJvbSAnLi4vdXRpbHMvdGVsZW1ldHJ5LmpzJztcbmltcG9ydCB7IFByb3BlcnRpZXNDaGFuZ2VkIH0gZnJvbSAnLi9wcm9wZXJ0aWVzLWNoYW5nZWQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIGBwcm9wc2Agd2l0aCBlYWNoIHByb3BlcnR5IG5vcm1hbGl6ZWQgc3VjaCB0aGF0XG4gKiB1cGdyYWRlZCBpdCBpcyBhbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIHR5cGUgcHJvcGVydHkgeyB0eXBlOiBUeXBlfS5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBDb3B5IG9mIGlucHV0IGBwcm9wc2Agd2l0aCBub3JtYWxpemVkIHByb3BlcnRpZXMgdGhhdFxuICogYXJlIGluIHRoZSBmb3JtIHt0eXBlOiBUeXBlfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydGllcyhwcm9wcykge1xuICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgIGNvbnN0IG8gPSBwcm9wc1twXTtcbiAgICBvdXRwdXRbcF0gPSAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicpID8ge3R5cGU6IG99IDogbztcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIE1peGluIHRoYXQgcHJvdmlkZXMgYSBtaW5pbWFsIHN0YXJ0aW5nIHBvaW50IHRvIHVzaW5nIHRoZSBQcm9wZXJ0aWVzQ2hhbmdlZFxuICogbWl4aW4gYnkgcHJvdmlkaW5nIGEgbWVjaGFuaXNtIHRvIGRlY2xhcmUgcHJvcGVydGllcyBpbiBhIHN0YXRpY1xuICogZ2V0dGVyIChlLmcuIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHsgcmV0dXJuIHsgZm9vOiBTdHJpbmcgfSB9KS4gQ2hhbmdlc1xuICogYXJlIHJlcG9ydGVkIHZpYSB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgbWV0aG9kLlxuICpcbiAqIFRoaXMgbWl4aW4gcHJvdmlkZXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgcmVuZGVyaW5nLiBVc2VycyBhcmUgZXhwZWN0ZWRcbiAqIHRvIGNyZWF0ZSBhIFNoYWRvd1Jvb3QgYW5kIHB1dCBjb250ZW50IGludG8gaXQgYW5kIHVwZGF0ZSBpdCBpbiB3aGF0ZXZlclxuICogd2F5IG1ha2VzIHNlbnNlLiBUaGlzIGNhbiBiZSBkb25lIGluIHJlYWN0aW9uIHRvIHByb3BlcnRpZXMgY2hhbmdpbmcgYnlcbiAqIGltcGxlbWVudGluZyBgX3Byb3BlcnRpZXNDaGFuZ2VkYC5cbiAqXG4gKiBAbWl4aW5GdW5jdGlvblxuICogQHBvbHltZXJcbiAqIEBhcHBsaWVzTWl4aW4gUHJvcGVydGllc0NoYW5nZWRcbiAqIEBzdW1tYXJ5IE1peGluIHRoYXQgcHJvdmlkZXMgYSBtaW5pbWFsIHN0YXJ0aW5nIHBvaW50IGZvciB1c2luZ1xuICogdGhlIFByb3BlcnRpZXNDaGFuZ2VkIG1peGluIGJ5IHByb3ZpZGluZyBhIGRlY2xhcmF0aXZlIGBwcm9wZXJ0aWVzYCBvYmplY3QuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3MgQ2xhc3MgdG8gYXBwbHkgbWl4aW4gdG8uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3Mgd2l0aCBtaXhpbiBhcHBsaWVkLlxuICovXG5leHBvcnQgY29uc3QgUHJvcGVydGllc01peGluID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuIC8qKlxuICAqIEBjb25zdHJ1Y3RvclxuICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnRpZXNDaGFuZ2VkfVxuICAqIEBwcml2YXRlXG4gICovXG4gY29uc3QgYmFzZSA9IFByb3BlcnRpZXNDaGFuZ2VkKHN1cGVyQ2xhc3MpO1xuXG4gLyoqXG4gICogUmV0dXJucyB0aGUgc3VwZXIgY2xhc3MgY29uc3RydWN0b3IgZm9yIHRoZSBnaXZlbiBjbGFzcywgaWYgaXQgaXMgYW5cbiAgKiBpbnN0YW5jZSBvZiB0aGUgUHJvcGVydGllc01peGluLlxuICAqXG4gICogQHBhcmFtIHshUHJvcGVydGllc01peGluQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yIFByb3BlcnRpZXNNaXhpbiBjb25zdHJ1Y3RvclxuICAqIEByZXR1cm4gez9Qcm9wZXJ0aWVzTWl4aW5Db25zdHJ1Y3Rvcn0gU3VwZXIgY2xhc3MgY29uc3RydWN0b3JcbiAgKi9cbiBmdW5jdGlvbiBzdXBlclByb3BlcnRpZXNDbGFzcyhjb25zdHJ1Y3Rvcikge1xuICAgY29uc3Qgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yKTtcblxuICAgLy8gTm90ZSwgdGhlIGBQcm9wZXJ0aWVzTWl4aW5gIGNsYXNzIGJlbG93IG9ubHkgcmVmZXJzIHRvIHRoZSBjbGFzc1xuICAgLy8gZ2VuZXJhdGVkIGJ5IHRoaXMgY2FsbCB0byB0aGUgbWl4aW47IHRoZSBpbnN0YW5jZW9mIHRlc3Qgb25seSB3b3Jrc1xuICAgLy8gYmVjYXVzZSB0aGUgbWl4aW4gaXMgZGVkdXBlZCBhbmQgZ3VhcmFudGVlZCBvbmx5IHRvIGFwcGx5IG9uY2UsIGhlbmNlXG4gICAvLyBhbGwgY29uc3RydWN0b3JzIGluIGEgcHJvdG8gY2hhaW4gd2lsbCBzZWUgdGhlIHNhbWUgYFByb3BlcnRpZXNNaXhpbmBcbiAgIHJldHVybiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFByb3BlcnRpZXNNaXhpbikgP1xuICAgICAvKiogQHR5cGUgeyFQcm9wZXJ0aWVzTWl4aW5Db25zdHJ1Y3Rvcn0gKi8gKHN1cGVyQ3RvcikgOiBudWxsO1xuIH1cblxuIC8qKlxuICAqIFJldHVybnMgYSBtZW1vaXplZCB2ZXJzaW9uIG9mIHRoZSBgcHJvcGVydGllc2Agb2JqZWN0IGZvciB0aGVcbiAgKiBnaXZlbiBjbGFzcy4gUHJvcGVydGllcyBub3QgaW4gb2JqZWN0IGZvcm1hdCBhcmUgY29udmVydGVkIHRvIGF0XG4gICogbGVhc3Qge3R5cGV9LlxuICAqXG4gICogQHBhcmFtIHtQcm9wZXJ0aWVzTWl4aW5Db25zdHJ1Y3Rvcn0gY29uc3RydWN0b3IgUHJvcGVydGllc01peGluIGNvbnN0cnVjdG9yXG4gICogQHJldHVybiB7T2JqZWN0fSBNZW1vaXplZCBwcm9wZXJ0aWVzIG9iamVjdFxuICAqL1xuIGZ1bmN0aW9uIG93blByb3BlcnRpZXMoY29uc3RydWN0b3IpIHtcbiAgIGlmICghY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25Qcm9wZXJ0aWVzJywgY29uc3RydWN0b3IpKSkge1xuICAgICBsZXQgcHJvcHMgPSBudWxsO1xuXG4gICAgIGlmIChjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdwcm9wZXJ0aWVzJywgY29uc3RydWN0b3IpKSkge1xuICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBjb25zdHJ1Y3Rvci5wcm9wZXJ0aWVzO1xuXG4gICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcHJvcHMgPSBub3JtYWxpemVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgICAgIH1cbiAgICAgfVxuXG4gICAgIGNvbnN0cnVjdG9yLl9fb3duUHJvcGVydGllcyA9IHByb3BzO1xuICAgfVxuICAgcmV0dXJuIGNvbnN0cnVjdG9yLl9fb3duUHJvcGVydGllcztcbiB9XG5cbiAvKipcbiAgKiBAcG9seW1lclxuICAqIEBtaXhpbkNsYXNzXG4gICogQGV4dGVuZHMge2Jhc2V9XG4gICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydGllc01peGlufVxuICAqIEB1bnJlc3RyaWN0ZWRcbiAgKi9cbiBjbGFzcyBQcm9wZXJ0aWVzTWl4aW4gZXh0ZW5kcyBiYXNlIHtcblxuICAgLyoqXG4gICAgKiBJbXBsZW1lbnRzIHN0YW5kYXJkIGN1c3RvbSBlbGVtZW50cyBnZXR0ZXIgdG8gb2JzZXJ2ZXMgdGhlIGF0dHJpYnV0ZXNcbiAgICAqIGxpc3RlZCBpbiBgcHJvcGVydGllc2AuXG4gICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAqIEBub2NvbGxhcHNlXG4gICAgKi9cbiAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vYnNlcnZlZEF0dHJpYnV0ZXMnLCB0aGlzKSkpIHtcbiAgICAgICByZWdpc3Rlcih0aGlzLnByb3RvdHlwZSk7XG4gICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgICAgIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXMgPSBwcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKS5tYXAocCA9PiB0aGlzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlUb0F0dHJpYnV0ZU1hcChwKSkgOiBbXTtcbiAgICAgfVxuICAgICByZXR1cm4gdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgIH1cblxuICAgLyoqXG4gICAgKiBGaW5hbGl6ZXMgYW4gZWxlbWVudCBkZWZpbml0aW9uLCBpbmNsdWRpbmcgZW5zdXJpbmcgYW55IHN1cGVyIGNsYXNzZXNcbiAgICAqIGFyZSBhbHNvIGZpbmFsaXplZC4gVGhpcyBpbmNsdWRlcyBlbnN1cmluZyBwcm9wZXJ0eVxuICAgICogYWNjZXNzb3JzIGV4aXN0IG9uIHRoZSBlbGVtZW50IHByb3RvdHlwZS4gVGhpcyBtZXRob2QgY2FsbHNcbiAgICAqIGBfZmluYWxpemVDbGFzc2AgdG8gZmluYWxpemUgZWFjaCBjb25zdHJ1Y3RvciBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuICAgICogQHJldHVybiB7dm9pZH1cbiAgICAqIEBub2NvbGxhcHNlXG4gICAgKi9cbiAgIHN0YXRpYyBmaW5hbGl6ZSgpIHtcbiAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZmluYWxpemVkJywgdGhpcykpKSB7XG4gICAgICAgY29uc3Qgc3VwZXJDdG9yID0gc3VwZXJQcm9wZXJ0aWVzQ2xhc3MoLyoqIEB0eXBlIHshUHJvcGVydGllc01peGluQ29uc3RydWN0b3J9ICovKHRoaXMpKTtcbiAgICAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICAgICB9XG4gICAgICAgdGhpcy5fX2ZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgdGhpcy5fZmluYWxpemVDbGFzcygpO1xuICAgICB9XG4gICB9XG5cbiAgIC8qKlxuICAgICogRmluYWxpemUgYW4gZWxlbWVudCBjbGFzcy4gVGhpcyBpbmNsdWRlcyBlbnN1cmluZyBwcm9wZXJ0eVxuICAgICogYWNjZXNzb3JzIGV4aXN0IG9uIHRoZSBlbGVtZW50IHByb3RvdHlwZS4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5XG4gICAgKiBgZmluYWxpemVgIGFuZCBmaW5hbGl6ZXMgdGhlIGNsYXNzIGNvbnN0cnVjdG9yLlxuICAgICpcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqIEBub2NvbGxhcHNlXG4gICAgKi9cbiAgIHN0YXRpYyBfZmluYWxpemVDbGFzcygpIHtcbiAgICAgY29uc3QgcHJvcHMgPSBvd25Qcm9wZXJ0aWVzKC8qKiBAdHlwZSB7IVByb3BlcnRpZXNNaXhpbkNvbnN0cnVjdG9yfSAqLyh0aGlzKSk7XG4gICAgIGlmIChwcm9wcykge1xuICAgICAgIC8qKiBAdHlwZSB7P30gKi8gKHRoaXMpLmNyZWF0ZVByb3BlcnRpZXMocHJvcHMpO1xuICAgICB9XG4gICB9XG5cbiAgIC8qKlxuICAgICogUmV0dXJucyBhIG1lbW9pemVkIHZlcnNpb24gb2YgYWxsIHByb3BlcnRpZXMsIGluY2x1ZGluZyB0aG9zZSBpbmhlcml0ZWRcbiAgICAqIGZyb20gc3VwZXIgY2xhc3Nlcy4gUHJvcGVydGllcyBub3QgaW4gb2JqZWN0IGZvcm1hdCBhcmUgY29udmVydGVkIHRvXG4gICAgKiBhdCBsZWFzdCB7dHlwZX0uXG4gICAgKlxuICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAbm9jb2xsYXBzZVxuICAgICovXG4gICBzdGF0aWMgZ2V0IF9wcm9wZXJ0aWVzKCkge1xuICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoXG4gICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19wcm9wZXJ0aWVzJywgdGhpcykpKSB7XG4gICAgICAgY29uc3Qgc3VwZXJDdG9yID0gc3VwZXJQcm9wZXJ0aWVzQ2xhc3MoLyoqIEB0eXBlIHshUHJvcGVydGllc01peGluQ29uc3RydWN0b3J9ICovKHRoaXMpKTtcbiAgICAgICB0aGlzLl9fcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAgICBzdXBlckN0b3IgJiYgc3VwZXJDdG9yLl9wcm9wZXJ0aWVzLFxuICAgICAgICAgb3duUHJvcGVydGllcygvKiogQHR5cGUge1Byb3BlcnRpZXNNaXhpbkNvbnN0cnVjdG9yfSAqLyh0aGlzKSkpO1xuICAgICB9XG4gICAgIHJldHVybiB0aGlzLl9fcHJvcGVydGllcztcbiAgIH1cblxuICAgLyoqXG4gICAgKiBPdmVycmlkZXMgYFByb3BlcnRpZXNDaGFuZ2VkYCBtZXRob2QgdG8gcmV0dXJuIHR5cGUgc3BlY2lmaWVkIGluIHRoZVxuICAgICogc3RhdGljIGBwcm9wZXJ0aWVzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgcHJvcGVydHlcbiAgICAqIEByZXR1cm4geyp9IFR5cGUgdG8gd2hpY2ggdG8gZGVzZXJpYWxpemUgYXR0cmlidXRlXG4gICAgKlxuICAgICogQHByb3RlY3RlZFxuICAgICogQG5vY29sbGFwc2VcbiAgICAqL1xuICAgc3RhdGljIHR5cGVGb3JQcm9wZXJ0eShuYW1lKSB7XG4gICAgIGNvbnN0IGluZm8gPSB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdO1xuICAgICByZXR1cm4gaW5mbyAmJiBpbmZvLnR5cGU7XG4gICB9XG5cbiAgIC8qKlxuICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0aWVzQ2hhbmdlZGAgbWV0aG9kIGFuZCBhZGRzIGEgY2FsbCB0b1xuICAgICogYGZpbmFsaXplYCB3aGljaCBsYXppbHkgY29uZmlndXJlcyB0aGUgZWxlbWVudCdzIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAqIEBvdmVycmlkZVxuICAgICogQHJldHVybiB7dm9pZH1cbiAgICAqL1xuICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICBpbmNyZW1lbnRJbnN0YW5jZUNvdW50KCk7XG4gICAgIHRoaXMuY29uc3RydWN0b3IuZmluYWxpemUoKTtcbiAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWRkZWQgdG8gYSBkb2N1bWVudC5cbiAgICAqIENhbGxzIGBfZW5hYmxlUHJvcGVydGllc2AgdG8gdHVybiBvbiBwcm9wZXJ0eSBzeXN0ZW0gZnJvbVxuICAgICogYFByb3BlcnRpZXNDaGFuZ2VkYC5cbiAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IFN1cGVyIG1heSBvciBtYXkgbm90IGltcGxlbWVudCB0aGUgY2FsbGJhY2tcbiAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgKiBAb3ZlcnJpZGVcbiAgICAqL1xuICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgIGlmIChzdXBlci5jb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgIH1cbiAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSBhIGRvY3VtZW50XG4gICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBTdXBlciBtYXkgb3IgbWF5IG5vdCBpbXBsZW1lbnQgdGhlIGNhbGxiYWNrXG4gICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICogQG92ZXJyaWRlXG4gICAgKi9cbiAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICBpZiAoc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICB9XG4gICB9XG5cbiB9XG5cbiByZXR1cm4gUHJvcGVydGllc01peGluO1xuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-accessors.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-accessors.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertyAccessors\": () => (/* binding */ PropertyAccessors)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nconst nativeProperties = {};\nlet proto = HTMLElement.prototype;\nwhile (proto) {\n  let props = Object.getOwnPropertyNames(proto);\n  for (let i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\nconst isTrustedType = (() => {\n  if (!window.trustedTypes) {\n    return () => false;\n  }\n  return val => trustedTypes.isHTML(val) || trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);\n})();\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    let value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertyAccessors = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n  const base = (0,_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__.PropertiesChanged)(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n  class PropertyAccessors extends base {\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     * @nocollapse\n     */\n    static createPropertiesForAttributes() {\n      let a$ = /** @type {?} */this.observedAttributes;\n      for (let i = 0; i < a$.length; i++) {\n        this.prototype._createPropertyAccessor((0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__.dashToCamelCase)(a$[i]));\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__.camelToDashCase)(property);\n    }\n\n    /**\n     * Overrides PropertiesChanged implementation to initialize values for\n     * accessors created for values that already existed on the element\n     * prototype.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n        this.__dataProto = null;\n      }\n      super._initializeProperties();\n    }\n\n    /**\n     * Called at instance time with bag of properties that were overwritten\n     * by accessors on the prototype when accessors were created.\n     *\n     * The default implementation sets these properties back into the\n     * setter at instance time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProtoProperties(props) {\n      for (let p in props) {\n        this._setProperty(p, props[p]);\n      }\n    }\n\n    /**\n     * Ensures the element has the given attribute. If it does not,\n     * assigns the given value to the attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n     *     element\n     *\n     * @param {string} attribute Name of attribute to ensure is set.\n     * @param {string} value of the attribute.\n     * @return {void}\n     * @override\n     */\n    _ensureAttribute(attribute, value) {\n      const el = /** @type {!HTMLElement} */this;\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    }\n\n    /**\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided property\n     *     value.\n     * @override\n     */\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            if (isTrustedType(value)) {\n              /**\n               * Here `value` isn't actually a string, but it should be\n               * passed into APIs that normally expect a string, like\n               * elem.setAttribute.\n               */\n              return (/** @type {?} */value\n              );\n            }\n            try {\n              return JSON.stringify(value);\n            } catch (x) {\n              return '';\n            }\n          }\n        default:\n          return super._serializeValue(value);\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called by Polymer when reading HTML attribute values to\n     * JS properties.  Users may override this method on Polymer element\n     * prototypes to provide deserialization for custom `type`s.  Note,\n     * the `type` argument is the value of the `type` field provided in the\n     * `properties` configuration object for a given property, and is\n     * by convention the constructor for the type to deserialize.\n     *\n     *\n     * @param {?string} value Attribute value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */\n      let outValue;\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse( /** @type {string} */value);\n          } catch (x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n          break;\n        case Array:\n          try {\n            outValue = JSON.parse( /** @type {string} */value);\n          } catch (x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n          break;\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n      return outValue;\n    }\n    /* eslint-enable no-fallthrough */\n\n    /**\n     * Overrides PropertiesChanged implementation to save existing prototype\n     * property value so that it can be reset.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     *\n     * When calling on a prototype, any overwritten values are saved in\n     * `__dataProto`, and it is up to the subclasser to decide how/when\n     * to set those properties back into the accessor.  When calling on an\n     * instance, the overwritten value is set via `_setPendingProperty`,\n     * and the user should call `_invalidateProperties` or `_flushProperties`\n     * for the values to take effect.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n      super._definePropertyAccessor(property, readOnly);\n    }\n\n    /**\n     * Returns true if this library created an accessor for the given property.\n     *\n     * @param {string} property Property name\n     * @return {boolean} True if an accessor was created\n     * @override\n     */\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    }\n\n    /**\n     * Returns true if the specified property has a pending change.\n     *\n     * @param {string} prop Property name\n     * @return {boolean} True if property has a pending change\n     * @protected\n     * @override\n     */\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && prop in this.__dataPending);\n    }\n  }\n  return PropertyAccessors;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuanM/NDlkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcblxuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoQ2FzZSwgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgUHJvcGVydGllc0NoYW5nZWQgfSBmcm9tICcuL3Byb3BlcnRpZXMtY2hhbmdlZC5qcyc7XG5cbi8vIFNhdmUgbWFwIG9mIG5hdGl2ZSBwcm9wZXJ0aWVzOyB0aGlzIGZvcm1zIGEgYmxhY2tsaXN0IG9yIHByb3BlcnRpZXNcbi8vIHRoYXQgd29uJ3QgaGF2ZSB0aGVpciB2YWx1ZXMgXCJzYXZlZFwiIGJ5IGBzYXZlQWNjZXNzb3JWYWx1ZWAsIHNpbmNlXG4vLyByZWFkaW5nIGZyb20gYW4gSFRNTEVsZW1lbnQgYWNjZXNzb3IgZnJvbSB0aGUgY29udGV4dCBvZiBhIHByb3RvdHlwZSB0aHJvd3NcbmNvbnN0IG5hdGl2ZVByb3BlcnRpZXMgPSB7fTtcbmxldCBwcm90byA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbndoaWxlIChwcm90bykge1xuICBsZXQgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG4gIGZvciAobGV0IGk9MDsgaTxwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIG5hdGl2ZVByb3BlcnRpZXNbcHJvcHNbaV1dID0gdHJ1ZTtcbiAgfVxuICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG59XG5cbmNvbnN0IGlzVHJ1c3RlZFR5cGUgPSAoKCkgPT4ge1xuICBpZiAoIXdpbmRvdy50cnVzdGVkVHlwZXMpIHtcbiAgICByZXR1cm4gKCkgPT4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICh2YWwpID0+IHRydXN0ZWRUeXBlcy5pc0hUTUwodmFsKSB8fFxuICAgICAgICB0cnVzdGVkVHlwZXMuaXNTY3JpcHQodmFsKSB8fCB0cnVzdGVkVHlwZXMuaXNTY3JpcHRVUkwodmFsKTtcbn0pKCk7XG5cbi8qKlxuICogVXNlZCB0byBzYXZlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBvdmVycmlkZGVuIHdpdGhcbiAqIGFuIGFjY2Vzc29yLiBJZiB0aGUgYG1vZGVsYCBpcyBhIHByb3RvdHlwZSwgdGhlIHZhbHVlcyB3aWxsIGJlIHNhdmVkXG4gKiBpbiBgX19kYXRhUHJvdG9gLCBhbmQgaXQncyB1cCB0byB0aGUgdXNlciAob3IgZG93bnN0cmVhbSBtaXhpbikgdG9cbiAqIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhlc2UgdmFsdWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3JzLlxuICogSWYgYG1vZGVsYCBpcyBhbHJlYWR5IGFuIGluc3RhbmNlIChpdCBoYXMgYSBgX19kYXRhYCBwcm9wZXJ0eSksIHRoZW5cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCBhcyBhIHBlbmRpbmcgcHJvcGVydHksIG1lYW5pbmcgdGhlIHVzZXIgc2hvdWxkXG4gKiBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYCB0byB0YWtlIGVmZmVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZUFjY2Vzc29yVmFsdWUobW9kZWwsIHByb3BlcnR5KSB7XG4gIC8vIERvbid0IHJlYWQvc3RvcmUgdmFsdWUgZm9yIGFueSBuYXRpdmUgcHJvcGVydGllcyBzaW5jZSB0aGV5IGNvdWxkIHRocm93XG4gIGlmICghbmF0aXZlUHJvcGVydGllc1twcm9wZXJ0eV0pIHtcbiAgICBsZXQgdmFsdWUgPSBtb2RlbFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChtb2RlbC5fX2RhdGEpIHtcbiAgICAgICAgLy8gQWRkaW5nIGFjY2Vzc29yIHRvIGluc3RhbmNlOyB1cGRhdGUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIEl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gY2FsbCBfZmx1c2hQcm9wZXJ0aWVzXG4gICAgICAgIG1vZGVsLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBwcm90bzsgc2F2ZSBwcm90bydzIHZhbHVlIGZvciBpbnN0YW5jZS10aW1lIHVzZVxuICAgICAgICBpZiAoIW1vZGVsLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG8gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19kYXRhUHJvdG8nLCBtb2RlbCkpKSB7XG4gICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG8gPSBPYmplY3QuY3JlYXRlKG1vZGVsLl9fZGF0YVByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5fX2RhdGFQcm90b1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgYmFzaWMgbWV0YS1wcm9ncmFtbWluZyBmb3IgY3JlYXRpbmcgb25lXG4gKiBvciBtb3JlIHByb3BlcnR5IGFjY2Vzc29ycyAoZ2V0dGVyL3NldHRlciBwYWlyKSB0aGF0IGVucXVldWUgYW4gYXN5bmNcbiAqIChiYXRjaGVkKSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAqXG4gKiBGb3IgYmFzaWMgdXNhZ2Ugb2YgdGhpcyBtaXhpbjpcbiAqXG4gKiAtICAgRGVjbGFyZSBhdHRyaWJ1dGVzIHRvIG9ic2VydmUgdmlhIHRoZSBzdGFuZGFyZCBgc3RhdGljIGdldFxuICogICAgIG9ic2VydmVkQXR0cmlidXRlcygpYC4gVXNlIGBkYXNoLWNhc2VgIGF0dHJpYnV0ZSBuYW1lcyB0byByZXByZXNlbnRcbiAqICAgICBgY2FtZWxDYXNlYCBwcm9wZXJ0eSBuYW1lcy5cbiAqIC0gICBJbXBsZW1lbnQgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrIG9uIHRoZSBjbGFzcy5cbiAqIC0gICBDYWxsIGBNeUNsYXNzLmNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKClgICoqb25jZSoqIG9uIHRoZSBjbGFzcyB0b1xuICogICAgIGdlbmVyYXRlIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgZWFjaCBvYnNlcnZlZCBhdHRyaWJ1dGUuIFRoaXMgbXVzdCBiZVxuICogICAgIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IGluc3RhbmNlIGlzIGNyZWF0ZWQsIGZvciBleGFtcGxlLCBieSBjYWxsaW5nIGl0XG4gKiAgICAgYmVmb3JlIGNhbGxpbmcgYGN1c3RvbUVsZW1lbnRzLmRlZmluZWAuIEl0IGNhbiBhbHNvIGJlIGNhbGxlZCBsYXppbHkgZnJvbVxuICogICAgIHRoZSBlbGVtZW50J3MgYGNvbnN0cnVjdG9yYCwgYXMgbG9uZyBhcyBpdCdzIGd1YXJkZWQgc28gdGhhdCB0aGUgY2FsbCBpc1xuICogICAgIG9ubHkgbWFkZSBvbmNlLCB3aGVuIHRoZSBmaXJzdCBpbnN0YW5jZSBpcyBjcmVhdGVkLlxuICogLSAgIENhbGwgYHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKWAgaW4gdGhlIGVsZW1lbnQncyBgY29ubmVjdGVkQ2FsbGJhY2tgIHRvXG4gKiAgICAgZW5hYmxlIHRoZSBhY2Nlc3NvcnMuXG4gKlxuICogQW55IGBvYnNlcnZlZEF0dHJpYnV0ZXNgIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICogZGVzZXJpYWxpemVkIHZpYSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCBhbmQgc2V0IHRvIHRoZSBhc3NvY2lhdGVkXG4gKiBwcm9wZXJ0eSB1c2luZyBgZGFzaC1jYXNlYC10by1gY2FtZWxDYXNlYCBjb252ZW50aW9uLlxuICpcbiAqIEBtaXhpbkZ1bmN0aW9uXG4gKiBAcG9seW1lclxuICogQGFwcGxpZXNNaXhpbiBQcm9wZXJ0aWVzQ2hhbmdlZFxuICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiBmb3IgcmVhY3RpbmcgdG8gcHJvcGVydHkgY2hhbmdlcyBmcm9tXG4gKiAgIGdlbmVyYXRlZCBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3MgQ2xhc3MgdG8gYXBwbHkgbWl4aW4gdG8uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3Mgd2l0aCBtaXhpbiBhcHBsaWVkLlxuICovXG5leHBvcnQgY29uc3QgUHJvcGVydHlBY2Nlc3NvcnMgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydGllc0NoYW5nZWR9XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gICBjb25zdCBiYXNlID0gUHJvcGVydGllc0NoYW5nZWQoc3VwZXJDbGFzcyk7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgUHJvcGVydHlBY2Nlc3NvcnMgZXh0ZW5kcyBiYXNlIHtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIGFsbCBhdHRyaWJ1dGVzIGluIHRoZSBzdGFuZGFyZFxuICAgICAqIHN0YXRpYyBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIEF0dHJpYnV0ZSBuYW1lcyBhcmUgbWFwcGVkIHRvIHByb3BlcnR5IG5hbWVzIHVzaW5nIHRoZSBgZGFzaC1jYXNlYCB0b1xuICAgICAqIGBjYW1lbENhc2VgIGNvbnZlbnRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMoKSB7XG4gICAgICBsZXQgYSQgPSAgLyoqIEB0eXBlIHs/fSAqLyAodGhpcykub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgYSQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IoZGFzaFRvQ2FtZWxDYXNlKGEkW2ldKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgbmFtZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBCeSBkZWZhdWx0LCBjb252ZXJ0cyBjYW1lbCB0byBkYXNoIGNhc2UsIGUuZy4gYGZvb0JhcmAgdG8gYGZvby1iYXJgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBjb252ZXJ0XG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBdHRyaWJ1dGUgbmFtZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBhdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBjYW1lbFRvRGFzaENhc2UocHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBQcm9wZXJ0aWVzQ2hhbmdlZCBpbXBsZW1lbnRhdGlvbiB0byBpbml0aWFsaXplIHZhbHVlcyBmb3JcbiAgICAgKiBhY2Nlc3NvcnMgY3JlYXRlZCBmb3IgdmFsdWVzIHRoYXQgYWxyZWFkeSBleGlzdGVkIG9uIHRoZSBlbGVtZW50XG4gICAgICogcHJvdG90eXBlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKHRoaXMuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyh0aGlzLl9fZGF0YVByb3RvKTtcbiAgICAgICAgdGhpcy5fX2RhdGFQcm90byA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgaW5zdGFuY2UgdGltZSB3aXRoIGJhZyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqIGJ5IGFjY2Vzc29ycyBvbiB0aGUgcHJvdG90eXBlIHdoZW4gYWNjZXNzb3JzIHdlcmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICogc2V0dGVyIGF0IGluc3RhbmNlIHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHAsIHByb3BzW3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBJZiBpdCBkb2VzIG5vdCxcbiAgICAgKiBhc3NpZ25zIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9IENsb3N1cmUgY2FuJ3QgZmlndXJlIG91dCBgdGhpc2AgaXMgaW5mYWN0IGFuXG4gICAgICogICAgIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZW5zdXJlIGlzIHNldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9lbnN1cmVBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgY29uc3QgZWwgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcyk7XG4gICAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKGVsLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgUHJvcGVydGllc0NoYW5nZWQgaW1wbGVtZW50aW9uIHRvIHNlcmlhbGl6ZSBvYmplY3RzIGFzIEpTT04uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFN0cmluZyBzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHByb3BlcnR5XG4gICAgICogICAgIHZhbHVlLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzVHJ1c3RlZFR5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBIZXJlIGB2YWx1ZWAgaXNuJ3QgYWN0dWFsbHkgYSBzdHJpbmcsIGJ1dCBpdCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICogcGFzc2VkIGludG8gQVBJcyB0aGF0IG5vcm1hbGx5IGV4cGVjdCBhIHN0cmluZywgbGlrZVxuICAgICAgICAgICAgICAgKiBlbGVtLnNldEF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIHJldHVybiAvKiogQHR5cGUgez99ICovICh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gc3VwZXIuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHJlYWRpbmcgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzIHRvXG4gICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gIE5vdGUsXG4gICAgICogdGhlIGB0eXBlYCBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGB0eXBlYCBmaWVsZCBwcm92aWRlZCBpbiB0aGVcbiAgICAgKiBgcHJvcGVydGllc2AgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIGFuZCBpc1xuICAgICAqIGJ5IGNvbnZlbnRpb24gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUgdG8gZGVzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG8uXG4gICAgICogQHJldHVybiB7Kn0gVHlwZWQgdmFsdWUgZGVzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7Kn1cbiAgICAgICAqL1xuICAgICAgbGV0IG91dFZhbHVlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHtzdHJpbmd9ICovKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBub24tSlNPTiBsaXRlcmFscyBsaWtlIFN0cmluZ3MgYW5kIE51bWJlcnNcbiAgICAgICAgICAgIG91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHtzdHJpbmd9ICovKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFBvbHltZXI6OkF0dHJpYnV0ZXM6IGNvdWxkbid0IGRlY29kZSBBcnJheSBhcyBKU09OOiAke3ZhbHVlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgIG91dFZhbHVlID0gaXNOYU4odmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3V0VmFsdWUgPSBuZXcgRGF0ZShvdXRWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0VmFsdWUgPSBzdXBlci5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0VmFsdWU7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tZmFsbHRocm91Z2ggKi9cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBQcm9wZXJ0aWVzQ2hhbmdlZCBpbXBsZW1lbnRhdGlvbiB0byBzYXZlIGV4aXN0aW5nIHByb3RvdHlwZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIHNvIHRoYXQgaXQgY2FuIGJlIHJlc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYWRPbmx5IFdoZW4gdHJ1ZSwgbm8gc2V0dGVyIGlzIGNyZWF0ZWRcbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGluZyBvbiBhIHByb3RvdHlwZSwgYW55IG92ZXJ3cml0dGVuIHZhbHVlcyBhcmUgc2F2ZWQgaW5cbiAgICAgKiBgX19kYXRhUHJvdG9gLCBhbmQgaXQgaXMgdXAgdG8gdGhlIHN1YmNsYXNzZXIgdG8gZGVjaWRlIGhvdy93aGVuXG4gICAgICogdG8gc2V0IHRob3NlIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvbiBhblxuICAgICAqIGluc3RhbmNlLCB0aGUgb3ZlcndyaXR0ZW4gdmFsdWUgaXMgc2V0IHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAsXG4gICAgICogYW5kIHRoZSB1c2VyIHNob3VsZCBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYFxuICAgICAqIGZvciB0aGUgdmFsdWVzIHRvIHRha2UgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCByZWFkT25seSkge1xuICAgICAgc2F2ZUFjY2Vzc29yVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgc3VwZXIuX2RlZmluZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsaWJyYXJ5IGNyZWF0ZWQgYW4gYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBhY2Nlc3NvciB3YXMgY3JlYXRlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9oYXNBY2Nlc3Nvcihwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgJiYgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fX2RhdGFQZW5kaW5nICYmIChwcm9wIGluIHRoaXMuX19kYXRhUGVuZGluZykpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFByb3BlcnR5QWNjZXNzb3JzO1xuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-accessors.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-effects.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-effects.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertyEffects\": () => (/* binding */ PropertyEffects)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/path.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/path.js\");\n/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _property_accessors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./property-accessors.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-accessors.js\");\n/* harmony import */ var _template_stamp_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./template-stamp.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/template-stamp.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/settings.js\");\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n/* for notify, reflect */\n\n\n/* for annotated effects */\n\n\n\n// Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\nlet dedupeId = 0;\nconst NOOP = [];\n\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\nconst TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\nconst COMPUTE_INFO = '__computeInfo';\n\n/** @const {!RegExp} */\nconst capitalAttributeRegex = /[A-Z]/;\n\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\nlet DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nlet DataEffect; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\n *   extending a superclass map onto this subclass\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\n  let effects = model[type];\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n    if (cloneArrays) {\n      for (let p in effects) {\n        let protoFx = effects[p];\n        // Perf optimization over Array.slice\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i = 0; i < protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n  }\n  return effects;\n}\n\n// -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {?Object} effects Object map of property-to-Array of effects\n * @param {?Object} props Bag of current property changes\n * @param {?Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    const id = dedupeId++;\n    for (let prop in props) {\n      // Inline `runEffectsForProperty` for perf.\n      let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n      let fxs = effects[rootProperty];\n      if (fxs) {\n        for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n          if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n            if (fx.info) {\n              fx.info.lastRun = id;\n            }\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n            ran = true;\n          }\n        }\n      }\n    }\n    return ran;\n  }\n  return false;\n}\n\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {!Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  let ran = false;\n  let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n  let fxs = effects[rootProperty];\n  if (fxs) {\n    for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n  return ran;\n}\n\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {?DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    let triggerPath = /** @type {string} */trigger.name;\n    return triggerPath == path || !!(trigger.structured && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isAncestor)(triggerPath, path)) || !!(trigger.wildcard && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(triggerPath, path));\n  } else {\n    return true;\n  }\n}\n\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  let changedProp = info.property;\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  let fxs = inst[TYPES.NOTIFY];\n  let notified;\n  let id = dedupeId++;\n  // Try normal notify effects; if none, fall back to try path notification\n  for (let prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  }\n  // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n  let host;\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\nfunction notifyPath(inst, path, props) {\n  let rootProperty = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(path);\n  if (rootProperty !== path) {\n    let eventName = (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} eventName The name of the event to send\n *     ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property\n *     changed, the path that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  let detail = {\n    value: value,\n    queueProperty: true\n  };\n  if (path) {\n    detail.path = path;\n  }\n  // As a performance optimization, we could elide the wrap here since notifying\n  // events are non-bubbling and shouldn't need retargeting. However, a very\n  // small number of internal tests failed in obscure ways, which may indicate\n  // user code relied on timing differences resulting from ShadyDOM flushing\n  // as a result of the wrapped `dispatchEvent`.\n  (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)( /** @type {!HTMLElement} */inst).dispatchEvent(new CustomEvent(eventName, {\n    detail\n  }));\n}\n\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(property) : property;\n  let path = rootProperty != property ? property : null;\n  let value = path ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, path) : inst.__data[property];\n  if (path && value === undefined) {\n    value = props[property]; // specifically for .splices\n  }\n\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\n *     notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  let value;\n  let detail = /** @type {Object} */event.detail;\n  let fromPath = detail && detail.path;\n  if (fromPath) {\n    toPath = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n  value = negate ? !value : value;\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  let value = inst.__data[property];\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue) {\n    value = (0,_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue)(value, info.attrName, 'attribute', /** @type {Node} */inst);\n  }\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {?Object} changedProps Bag of changed properties\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  let computeEffects = inst[TYPES.COMPUTE];\n  if (computeEffects) {\n    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.orderedComputed) {\n      // Runs computed effects in efficient order by keeping a topologically-\n      // sorted queue of compute effects to run, and inserting subsequently\n      // invalidated effects as they are run\n      dedupeId++;\n      const order = getComputedOrder(inst);\n      const queue = [];\n      for (let p in changedProps) {\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\n      }\n      let info;\n      while (info = queue.shift()) {\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\n        }\n      }\n      Object.assign( /** @type {!Object} */oldProps, inst.__dataOld);\n      Object.assign( /** @type {!Object} */changedProps, inst.__dataPending);\n      inst.__dataPending = null;\n    } else {\n      // Original Polymer 2.x computed effects order, which continues running\n      // effects until no further computed properties have been invalidated\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign( /** @type {!Object} */oldProps, inst.__dataOld);\n        Object.assign( /** @type {!Object} */changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n}\n\n/**\n * Inserts a computed effect into a queue, given the specified order. Performs\n * the insert using a binary search.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {Object} info Property effects metadata\n * @param {Array<Object>} queue Ordered queue of effects\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n */\nconst insertEffect = (info, queue, order) => {\n  let start = 0;\n  let end = queue.length - 1;\n  let idx = -1;\n  while (start <= end) {\n    const mid = start + end >> 1;\n    // Note `methodInfo` is where the computed property name is stored in\n    // the effect metadata\n    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\n    if (cmp < 0) {\n      start = mid + 1;\n    } else if (cmp > 0) {\n      end = mid - 1;\n    } else {\n      idx = mid;\n      break;\n    }\n  }\n  if (idx < 0) {\n    idx = end + 1;\n  }\n  queue.splice(idx, 0, info);\n};\n\n/**\n * Inserts all downstream computed effects invalidated by the specified property\n * into the topologically-sorted queue of effects to be run.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {string} prop Property name\n * @param {Object} computeEffects Computed effects for this element\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\n *   to be run\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\n */\nconst enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {\n  const rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n  const fxs = computeEffects[rootProperty];\n  if (fxs) {\n    for (let i = 0; i < fxs.length; i++) {\n      const fx = fxs[i];\n      if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        fx.info.lastRun = dedupeId;\n        insertEffect(fx.info, queue, order);\n      }\n    }\n  }\n};\n\n/**\n * Generates and retrieves a memoized map of computed property name to its\n * topologically-sorted order.\n *\n * The map is generated by first assigning a \"dependency count\" to each property\n * (defined as number properties it depends on, including its method for\n * \"dynamic functions\"). Any properties that have no dependencies are added to\n * the `ready` queue, which are properties whose order can be added to the final\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\n * the next property in the order map, and b.) each property that it is a\n * dependency for has its dep count decremented (and if that property's dep\n * count goes to zero, it is added to the `ready` queue), until all properties\n * have been visited and ordered.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\n *   effect order for.\n * @return {Map<string,number>} Map of computed property name->topological sort\n *   order\n */\nfunction getComputedOrder(inst) {\n  let ordered = inst.constructor.__orderedComputedDeps;\n  if (!ordered) {\n    ordered = new Map();\n    const effects = inst[TYPES.COMPUTE];\n    let {\n      counts,\n      ready,\n      total\n    } = dependencyCounts(inst);\n    let curr;\n    while (curr = ready.shift()) {\n      ordered.set(curr, ordered.size);\n      const computedByCurr = effects[curr];\n      if (computedByCurr) {\n        computedByCurr.forEach(fx => {\n          // Note `methodInfo` is where the computed property name is stored\n          const computedProp = fx.info.methodInfo;\n          --total;\n          if (--counts[computedProp] === 0) {\n            ready.push(computedProp);\n          }\n        });\n      }\n    }\n    if (total !== 0) {\n      const el = /** @type {HTMLElement} */inst;\n      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);\n    }\n    inst.constructor.__orderedComputedDeps = ordered;\n  }\n  return ordered;\n}\n\n/**\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\n * count\" is the number of dependencies a given property has assuming it is a\n * computed property, otherwise 0).  It also returns a pre-populated list of\n * `ready` properties that have no dependencies and a `total` count, which is\n * used for error-checking the graph.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\n *   counts for.\n * @return {!Object} Object containing `counts` map (property-to-dependency\n *   count) and pre-populated `ready` array of properties that had zero\n *   dependencies.\n */\nfunction dependencyCounts(inst) {\n  const infoForComputed = inst[COMPUTE_INFO];\n  const counts = {};\n  const computedDeps = inst[TYPES.COMPUTE];\n  const ready = [];\n  let total = 0;\n  // Count dependencies for each computed property\n  for (let p in infoForComputed) {\n    const info = infoForComputed[p];\n    // Be sure to add the method name itself in case of \"dynamic functions\"\n    total += counts[p] = info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);\n  }\n  // Build list of ready properties (that aren't themselves computed)\n  for (let p in computedDeps) {\n    if (!infoForComputed[p]) {\n      ready.push(p);\n    }\n  }\n  return {\n    counts,\n    ready,\n    total\n  };\n}\n\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {?Object} changedProps Bag of current property changes\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {boolean} True when the property being computed changed\n * @private\n */\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\n  // Dirty check dependencies and run if any invalid\n  let result = runMethodEffect(inst, property, changedProps, oldProps, info);\n  // Abort if method returns a no-op result\n  if (result === NOOP) {\n    return false;\n  }\n  let computedProp = info.methodInfo;\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    return inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n    return false;\n  }\n}\n\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\n * @param {string} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\nfunction computeLinkedPaths(inst, path, value) {\n  let links = inst.__dataLinkedPaths;\n  if (links) {\n    let link;\n    for (let a in links) {\n      let b = links[a];\n      if ((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(a, path)) {\n        link = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(a, b, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if ((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(b, path)) {\n        link = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(b, a, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n}\n\n// -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  let /** Binding */binding = {\n    kind,\n    target,\n    parts,\n    literal,\n    isCompound: parts.length !== 1\n  };\n  nodeInfo.bindings.push(binding);\n  // Add listener info to binding metadata\n  if (shouldAddListener(binding)) {\n    let {\n      event,\n      negate\n    } = binding.parts[0];\n    binding.listenerEvent = event || (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(target) + '-changed';\n    binding.listenerNegate = negate;\n  }\n  // Add \"propagate\" property effects to templateInfo\n  let index = templateInfo.nodeInfoList.length;\n  for (let i = 0; i < binding.parts.length; i++) {\n    let part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n    } else {\n      let dependencies = part.dependencies;\n      let info = {\n        index,\n        binding,\n        part,\n        evaluator: constructor\n      };\n      for (let j = 0; j < dependencies.length; j++) {\n        let trigger = dependencies[j];\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info,\n          trigger\n        });\n      }\n    }\n  }\n}\n\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  let node = nodeList[info.index];\n  let binding = info.binding;\n  let part = info.part;\n  // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    let value = props[path];\n    path = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(part.source, binding.target, path);\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n    // Propagate value to child\n    // Abort if value is a no-op result\n    if (value !== NOOP) {\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n}\n\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue) {\n    value = (0,_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue)(value, binding.target, binding.kind, node);\n  }\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);\n  } else {\n    // Property binding\n    let prop = binding.target;\n    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      // In legacy no-batching mode, bindings applied before dataReady are\n      // equivalent to the \"apply config\" phase, which only set managed props\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    let storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {\n      value = value == undefined ? '' : value;\n    }\n  }\n  return value;\n}\n\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n}\n\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\n *     bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  let {\n    nodeList,\n    nodeInfoList\n  } = templateInfo;\n  if (nodeInfoList.length) {\n    for (let i = 0; i < nodeInfoList.length; i++) {\n      let info = nodeInfoList[i];\n      let node = nodeList[i];\n      let bindings = info.bindings;\n      if (bindings) {\n        for (let i = 0; i < bindings.length; i++) {\n          let binding = bindings[i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n      // This ensures all bound elements have a host set, regardless\n      // of whether they upgrade synchronous to creation\n      node.__dataHost = inst;\n    }\n  }\n}\n\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n    let parts = binding.parts;\n    // Copy literals from parts into storage for this binding\n    let literals = new Array(parts.length);\n    for (let j = 0; j < parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n    let target = binding.target;\n    storage[target] = literals;\n    // Configure properties with their literal parts\n    if (binding.literal && binding.kind == 'property') {\n      // Note, className needs style scoping so this needs wrapping.\n      // We may also want to consider doing this for `textContent` and\n      // `innerHTML`.\n      if (target === 'className') {\n        node = (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node);\n      }\n      node[target] = binding.literal;\n    }\n  }\n}\n\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\n *     notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    let part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function (e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n}\n\n// -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {!Object} Effect metadata for this method effect\n * @private\n */\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);\n  let info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo,\n    dynamicFn\n  };\n  for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn,\n        info: info,\n        trigger: arg\n      });\n    }\n  }\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn,\n      info: info\n    });\n  }\n  return info;\n}\n\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  let context = inst._methodHost || inst;\n  let fn = context[info.methodName];\n  if (fn) {\n    let args = inst._marshalArgs(info.args, property, props);\n    return args === NOOP ? NOOP : fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\nconst emptyArray = [];\n\n// Regular expressions used for binding\nconst IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nconst CLOSE_BRACKET = '(?:]]|}})';\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nconst bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\nfunction literalFromParts(parts) {\n  let s = '';\n  for (let i = 0; i < parts.length; i++) {\n    let literal = parts[i].literal;\n    s += literal || '';\n  }\n  return s;\n}\n\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (m) {\n    let methodName = m[1];\n    let sig = {\n      methodName,\n      static: true,\n      args: emptyArray\n    };\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n  return null;\n}\n\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function (rawArg) {\n    let arg = parseArg(rawArg);\n    if (!arg.literal) {\n      sig.static = false;\n    }\n    return arg;\n  }, this);\n  return sig;\n}\n\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  let arg = rawArg.trim()\n  // replace comma entity with comma\n  .replace(/&comma;/g, ',')\n  // repair extra escape sequences; note only commas strictly need\n  // escaping, but we allow any other char to be escaped since its\n  // likely users will do this\n  .replace(/\\\\(.)/g, '$1');\n  // basic argument descriptor\n  let a = {\n    name: arg,\n    value: '',\n    literal: false\n  };\n  // detect literal value (must be String or Number)\n  let fc = arg[0];\n  if (fc === '-') {\n    fc = arg[1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch (fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  }\n  // if not literal, look for structured path\n  if (!a.literal) {\n    a.rootProperty = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(arg);\n    // detect structured path (has dots)\n    a.structured = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(arg);\n    if (a.structured) {\n      a.wildcard = arg.slice(-2) == '.*';\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n  return a;\n}\nfunction getArgValue(data, props, path) {\n  let value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(data, path);\n  // when data is not stored e.g. `splices`, get the value from changedProps\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\n  // info.value could pull a stale value out of changedProps during a reentrant\n  // change that sets the value back to undefined.\n  // https://github.com/Polymer/polymer/issues/5479\n  if (value === undefined) {\n    value = props[path];\n  }\n  return value;\n}\n\n// data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\nfunction notifySplices(inst, array, path, splices) {\n  const splicesData = {\n    indexSplices: splices\n  };\n  // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\n  // To match this behavior, we store splices directly on the array.\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !inst._overrideLegacyUndefined) {\n    array.splices = splicesData;\n  }\n  inst.notifyPath(path + '.splices', splicesData);\n  inst.notifyPath(path + '.length', array.length);\n  // Clear splice data only when it's stored on the array.\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !inst._overrideLegacyUndefined) {\n    splicesData.indexSplices = [];\n  }\n}\n\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\nconst PropertyEffects = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__.dedupingMixin)(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  const propertyEffectsBase = (0,_template_stamp_js__WEBPACK_IMPORTED_MODULE_6__.TemplateStamp)((0,_property_accessors_js__WEBPACK_IMPORTED_MODULE_5__.PropertyAccessors)(superClass));\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n  class PropertyEffects extends propertyEffectsBase {\n    constructor() {\n      super();\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n      this.__isPropertyEffectsClient = true;\n      /** @type {boolean} */\n      this.__dataClientsReady;\n      /** @type {Array} */\n      this.__dataPendingClients;\n      /** @type {Object} */\n      this.__dataToNotify;\n      /** @type {Object} */\n      this.__dataLinkedPaths;\n      /** @type {boolean} */\n      this.__dataHasPaths;\n      /** @type {Object} */\n      this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n      this.__dataHost;\n      /** @type {!Object} */\n      this.__dataTemp;\n      /** @type {boolean} */\n      this.__dataClientsInitialized;\n      /** @type {!Object} */\n      this.__data;\n      /** @type {!Object|null} */\n      this.__dataPending;\n      /** @type {!Object} */\n      this.__dataOld;\n      /** @type {Object} */\n      this.__computeEffects;\n      /** @type {Object} */\n      this.__computeInfo;\n      /** @type {Object} */\n      this.__reflectEffects;\n      /** @type {Object} */\n      this.__notifyEffects;\n      /** @type {Object} */\n      this.__propagateEffects;\n      /** @type {Object} */\n      this.__observeEffects;\n      /** @type {Object} */\n      this.__readOnly;\n      /** @type {!TemplateInfo} */\n      this.__templateInfo;\n      /** @type {boolean} */\n      this._overrideLegacyUndefined;\n    }\n    get PROPERTY_EFFECT_TYPES() {\n      return TYPES;\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n    _initializeProperties() {\n      super._initializeProperties();\n      this._registerHost();\n      this.__dataClientsReady = false;\n      this.__dataPendingClients = null;\n      this.__dataToNotify = null;\n      this.__dataLinkedPaths = null;\n      this.__dataHasPaths = false;\n      // May be set on instance prior to upgrade\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n      this.__dataHost = this.__dataHost || null;\n      this.__dataTemp = {};\n      this.__dataClientsInitialized = false;\n    }\n    _registerHost() {\n      if (hostStack.length) {\n        let host = hostStack[hostStack.length - 1];\n        host._enqueueClient(this);\n        // This ensures even non-bound elements have a host set, as\n        // long as they upgrade synchronously\n        this.__dataHost = host;\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to provide a\n     * more efficient implementation of initializing properties from\n     * the prototype on the instance.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the prototype\n     * @return {void}\n     */\n    _initializeProtoProperties(props) {\n      this.__data = Object.create(props);\n      this.__dataPending = Object.create(props);\n      this.__dataOld = {};\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to avoid setting\n     * `_setProperty`'s `shouldNotify: true`.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the instance\n     * @return {void}\n     */\n    _initializeInstanceProperties(props) {\n      let readOnly = this[TYPES.READ_ONLY];\n      for (let prop in props) {\n        if (!readOnly || !readOnly[prop]) {\n          this.__dataPending = this.__dataPending || {};\n          this.__dataOld = this.__dataOld || {};\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\n        }\n      }\n    }\n\n    // Prototype setup ----------------------------------------\n\n    /**\n     * Equivalent to static `addPropertyEffect` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n    _addPropertyEffect(property, type, effect) {\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n      // effects are accumulated into arrays per property based on type\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      if (!effects) {\n        effects = this[type][property] = [];\n      }\n      effects.push(effect);\n    }\n\n    /**\n     * Removes the given property effect.\n     *\n     * @override\n     * @param {string} property Property the effect was associated with\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object to remove\n     * @return {void}\n     */\n    _removePropertyEffect(property, type, effect) {\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      let idx = effects.indexOf(effect);\n      if (idx >= 0) {\n        effects.splice(idx, 1);\n      }\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a property effect\n     * of a certain type.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasPropertyEffect(property, type) {\n      let effects = this[type];\n      return Boolean(effects && effects[property]);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"read only\"\n     * accessor for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReadOnlyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"notify\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasNotifyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"reflect to\n     * attribute\" property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReflectEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"computed\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasComputedEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\n    }\n\n    // Runtime ----------------------------------------\n\n    /**\n     * Sets a pending property or path.  If the root property of the path in\n     * question had no accessor, the path is set, otherwise it is enqueued\n     * via `_setPendingProperty`.\n     *\n     * This function isolates relatively expensive functionality necessary\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\n     * change listeners via {{...}} bindings), such that it is only done\n     * when paths enter the system, and not at every propagation step.  It\n     * also sets a `__dataHasPaths` flag on the instance which is used to\n     * fast-path slower path-matching code in the property effects host paths.\n     *\n     * `path` can be a path string or array of path parts as accepted by the\n     * public API.\n     *\n     * @override\n     * @param {string | !Array<number|string>} path Path to set\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify Set to true if this change should\n     *  cause a property notification event dispatch\n     * @param {boolean=} isPathNotification If the path being set is a path\n     *   notification of an already changed value, as opposed to a request\n     *   to set and notify the change.  In the latter `false` case, a dirty\n     *   check is performed and then the value is set to the path before\n     *   enqueuing the pending property change.\n     * @return {boolean} Returns true if the property/path was enqueued in\n     *   the pending changes bag.\n     * @protected\n     */\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n      if (isPathNotification || (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(Array.isArray(path) ? path[0] : path) !== path) {\n        // Dirty check changes being set to a path against the actual object,\n        // since this is the entry point for paths into the system; from here\n        // the only dirty checks are against the `__dataTemp` cache to prevent\n        // duplicate work in the same turn only. Note, if this was a notification\n        // of a change already set to a path (isPathNotification: true),\n        // we always let the change through and skip the `set` since it was\n        // already dirty checked at the point of entry and the underlying\n        // object has already been updated\n        if (!isPathNotification) {\n          let old = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path);\n          path = /** @type {string} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.set)(this, path, value);\n          // Use property-accessor's simpler dirty check\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\n            return false;\n          }\n        }\n        this.__dataHasPaths = true;\n        if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {\n          computeLinkedPaths(this, /**@type{string}*/path, value);\n          return true;\n        }\n      } else {\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n          return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);\n        } else {\n          this[path] = value;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Applies a value to a non-Polymer element/node's property.\n     *\n     * The implementation makes a best-effort at binding interop:\n     * Some native element properties have side-effects when\n     * re-setting the same value (e.g. setting `<input>.value` resets the\n     * cursor position), so we do a dirty-check before setting the value.\n     * However, for better interop with non-Polymer custom elements that\n     * accept objects, we explicitly re-set object changes coming from the\n     * Polymer world (which may include deep object changes without the\n     * top reference changing), erring on the side of providing more\n     * information.\n     *\n     * Users may override this method to provide alternate approaches.\n     *\n     * @override\n     * @param {!Node} node The node to set a property on\n     * @param {string} prop The property to set\n     * @param {*} value The value to set\n     * @return {void}\n     * @protected\n     */\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      // It is a judgment call that resetting primitives is\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\n      // implement a whitelist of tag & property values that should never\n      // be reset (e.g. <input>.value && <select>.value)\n      if (value !== node[prop] || typeof value == 'object') {\n        // Note, className needs style scoping so this needs wrapping.\n        if (prop === 'className') {\n          node = /** @type {!Node} */(0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node);\n        }\n        node[prop] = value;\n      }\n    }\n\n    /**\n     * Overrides the `PropertiesChanged` implementation to introduce special\n     * dirty check logic depending on the property & value being set:\n     *\n     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n     * 2. Object set to simple property (e.g. 'prop': {...})\n     *    Stored in `__dataTemp` and `__data`, dirty checked against\n     *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n     * 3. Primitive value set to simple property (e.g. 'prop': 42)\n     *    Stored in `__data`, dirty checked against `__data`\n     *\n     * The dirty-check is important to prevent cycles due to two-way\n     * notification, but paths and objects are only dirty checked against any\n     * previous value set during this turn via a \"temporary cache\" that is\n     * cleared when the last `_propertiesChanged` exits. This is so:\n     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n     *    due to array mutations like shift/unshift/splice; this is fine\n     *    since path changes are dirty-checked at user entry points like `set`\n     * b. dirty-checking for objects only lasts one turn to allow the user\n     *    to mutate the object in-place and re-set it with the same identity\n     *    and have all sub-properties re-propagated in a subsequent turn.\n     *\n     * The temp cache is not necessarily sufficient to prevent invalid array\n     * paths, since a splice can happen during the same turn (with pathological\n     * user code); we could introduce a \"fixup\" for temporarily cached array\n     * paths if needed: https://github.com/Polymer/polymer/issues/4227\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify True if property should fire notification\n     *   event (applies only for `notify: true` properties)\n     * @return {boolean} Returns true if the property changed\n     */\n    _setPendingProperty(property, value, shouldNotify) {\n      let propIsPath = this.__dataHasPaths && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(property);\n      let prevProps = propIsPath ? this.__dataTemp : this.__data;\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (!(property in this.__dataOld)) {\n          this.__dataOld[property] = this.__data[property];\n        }\n        // Paths are stored in temporary cache (cleared at end of turn),\n        // which is used for dirty-checking, all others stored in __data\n        if (propIsPath) {\n          this.__dataTemp[property] = value;\n        } else {\n          this.__data[property] = value;\n        }\n        // All changes go into pending property bag, passed to _propertiesChanged\n        this.__dataPending[property] = value;\n        // Track properties that should notify separately\n        if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n          this.__dataToNotify = this.__dataToNotify || {};\n          this.__dataToNotify[property] = shouldNotify;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Overrides base implementation to ensure all accessors set `shouldNotify`\n     * to true, for per-property notification tracking.\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessor`'s default async queuing of\n     * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n     * manually flushed), the function no-ops; otherwise flushes\n     * `_propertiesChanged` synchronously.\n     *\n     * @override\n     * @return {void}\n     */\n    _invalidateProperties() {\n      if (this.__dataReady) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Enqueues the given client on a list of pending clients, whose\n     * pending property changes can later be flushed via a call to\n     * `_flushClients`.\n     *\n     * @override\n     * @param {Object} client PropertyEffects client to enqueue\n     * @return {void}\n     * @protected\n     */\n    _enqueueClient(client) {\n      this.__dataPendingClients = this.__dataPendingClients || [];\n      if (client !== this) {\n        this.__dataPendingClients.push(client);\n      }\n    }\n\n    /**\n     * Flushes any clients previously enqueued via `_enqueueClient`, causing\n     * their `_flushProperties` method to run.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _flushClients() {\n      if (!this.__dataClientsReady) {\n        this.__dataClientsReady = true;\n        this._readyClients();\n        // Override point where accessors are turned on; importantly,\n        // this is after clients have fully readied, providing a guarantee\n        // that any property effects occur only after all clients are ready.\n        this.__dataReady = true;\n      } else {\n        this.__enableOrFlushClients();\n      }\n    }\n\n    // NOTE: We ensure clients either enable or flush as appropriate. This\n    // handles two corner cases:\n    // (1) clients flush properly when connected/enabled before the host\n    // enables; e.g.\n    //   (a) Templatize stamps with no properties and does not flush and\n    //   (b) the instance is inserted into dom and\n    //   (c) then the instance flushes.\n    // (2) clients enable properly when not connected/enabled when the host\n    // flushes; e.g.\n    //   (a) a template is runtime stamped and not yet connected/enabled\n    //   (b) a host sets a property, causing stamped dom to flush\n    //   (c) the stamped dom enables.\n    __enableOrFlushClients() {\n      let clients = this.__dataPendingClients;\n      if (clients) {\n        this.__dataPendingClients = null;\n        for (let i = 0; i < clients.length; i++) {\n          let client = clients[i];\n          if (!client.__dataEnabled) {\n            client._enableProperties();\n          } else if (client.__dataPending) {\n            client._flushProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Perform any initial setup on client dom. Called before the first\n     * `_flushProperties` call on client dom and before any element\n     * observers are called.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _readyClients() {\n      this.__enableOrFlushClients();\n    }\n\n    /**\n     * Sets a bag of property changes to this instance, and\n     * synchronously processes all effects of the properties as a batch.\n     *\n     * Property names must be simple properties, not paths.  Batched\n     * path propagation is not supported.\n     *\n     * @override\n     * @param {Object} props Bag of one or more key-value pairs whose key is\n     *   a property and value is the new value to set for that property.\n     * @param {boolean=} setReadOnly When true, any private values set in\n     *   `props` will be set. By default, `setProperties` will not set\n     *   `readOnly: true` root properties.\n     * @return {void}\n     * @public\n     */\n    setProperties(props, setReadOnly) {\n      for (let path in props) {\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\n          // wildcard observers currently only pass the first changed path\n          // in the `info` object, and you could do some odd things batching\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\n          this._setPendingPropertyOrPath(path, props[path], true);\n        }\n      }\n      this._invalidateProperties();\n    }\n\n    /**\n     * Overrides `PropertyAccessors` so that property accessor\n     * side effects are not enabled until after client dom is fully ready.\n     * Also calls `_flushClients` callback to ensure client dom is enabled\n     * that was not enabled as a result of flushing properties.\n     *\n     * @override\n     * @return {void}\n     */\n    ready() {\n      // It is important that `super.ready()` is not called here as it\n      // immediately turns on accessors. Instead, we wait until `readyClients`\n      // to enable accessors to provide a guarantee that clients are ready\n      // before processing any accessors side effects.\n      this._flushProperties();\n      // If no data was pending, `_flushProperties` will not `flushClients`\n      // so ensure this is done.\n      if (!this.__dataClientsReady) {\n        this._flushClients();\n      }\n      // Before ready, client notifications do not trigger _flushProperties.\n      // Therefore a flush is necessary here if data has been set.\n      if (this.__dataPending) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Implements `PropertyAccessors`'s properties changed callback.\n     *\n     * Runs each class of effects for the batch of changed properties in\n     * a specific order (compute, propagate, reflect, observe, notify).\n     *\n     * @override\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {\n      // ----------------------------\n      // let c = Object.getOwnPropertyNames(changedProps || {});\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n      // if (window.debug) { debugger; }\n      // ----------------------------\n      let hasPaths = this.__dataHasPaths;\n      this.__dataHasPaths = false;\n      let notifyProps;\n      // Compute properties\n      runComputedEffects(this, changedProps, oldProps, hasPaths);\n      // Clear notify properties prior to possible reentry (propagate, observe),\n      // but after computing effects have a chance to add to them\n      notifyProps = this.__dataToNotify;\n      this.__dataToNotify = null;\n      // Propagate properties to clients\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n      // Flush clients\n      this._flushClients();\n      // Reflect properties\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n      // Observe properties\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n      // Notify properties to host\n      if (notifyProps) {\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n      }\n      // Clear temporary cache at end of turn\n      if (this.__dataCounter == 1) {\n        this.__dataTemp = {};\n      }\n      // ----------------------------\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n      // ----------------------------\n    }\n\n    /**\n     * Called to propagate any property changes to stamped template nodes\n     * managed by this element.\n     *\n     * @override\n     * @param {Object} changedProps Bag of changed properties\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {void}\n     * @protected\n     */\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n      if (this[TYPES.PROPAGATE]) {\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n      }\n      if (this.__templateInfo) {\n        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\n      }\n    }\n    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\n      const baseRunEffects = (changedProps, hasPaths) => {\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n        for (let info = templateInfo.firstChild; info; info = info.nextSibling) {\n          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\n        }\n      };\n      if (templateInfo.runEffects) {\n        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\n      } else {\n        baseRunEffects(changedProps, hasPaths);\n      }\n    }\n\n    /**\n     * Aliases one data path as another, such that path notifications from one\n     * are routed to the other.\n     *\n     * @override\n     * @param {string | !Array<string|number>} to Target path to link.\n     * @param {string | !Array<string|number>} from Source path to link.\n     * @return {void}\n     * @public\n     */\n    linkPaths(to, from) {\n      to = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(to);\n      from = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(from);\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n      this.__dataLinkedPaths[to] = from;\n    }\n\n    /**\n     * Removes a data path alias previously established with `_linkPaths`.\n     *\n     * Note, the path to unlink should be the target (`to`) used when\n     * linking the paths.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Target path to unlink.\n     * @return {void}\n     * @public\n     */\n    unlinkPaths(path) {\n      path = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(path);\n      if (this.__dataLinkedPaths) {\n        delete this.__dataLinkedPaths[path];\n      }\n    }\n\n    /**\n     * Notify that an array has changed.\n     *\n     * Example:\n     *\n     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n     *     ...\n     *     this.items.splice(1, 1, {name: 'Sam'});\n     *     this.items.push({name: 'Bob'});\n     *     this.notifySplices('items', [\n     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\n     *         object: this.items, type: 'splice' },\n     *       { index: 3, removed: [], addedCount: 1,\n     *         object: this.items, type: 'splice'}\n     *     ]);\n     *\n     * @param {string} path Path that should be notified.\n     * @param {Array} splices Array of splice records indicating ordered\n     *   changes that occurred to the array. Each record should have the\n     *   following fields:\n     *    * index: index at which the change occurred\n     *    * removed: array of items that were removed from this index\n     *    * addedCount: number of new items added at this index\n     *    * object: a reference to the array in question\n     *    * type: the string literal 'splice'\n     *\n     *   Note that splice records _must_ be normalized such that they are\n     *   reported in index order (raw results from `Object.observe` are not\n     *   ordered and must be normalized/merged before notifying).\n     *\n     * @override\n     * @return {void}\n     * @public\n     */\n    notifySplices(path, splices) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      notifySplices(this, array, info.path, splices);\n    }\n\n    /**\n     * Convenience method for reading a value from a path.\n     *\n     * Note, if any part in the path is undefined, this method returns\n     * `undefined` (this method does not throw when dereferencing undefined\n     * paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n     * @param {Object=} root Root object from which the path is evaluated.\n     * @return {*} Value at the path, or `undefined` if any part of the path\n     *   is undefined.\n     * @public\n     */\n    get(path, root) {\n      return (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(root || this, path);\n    }\n\n    /**\n     * Convenience method for setting a value to a path and notifying any\n     * elements bound to the same path.\n     *\n     * Note, if any part in the path except for the last is undefined,\n     * this method does nothing (this method does not throw when\n     * dereferencing undefined paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n     * @param {*} value Value to set at the specified path.\n     * @param {Object=} root Root object from which the path is evaluated.\n     *   When specified, no notification will occur.\n     * @return {void}\n     * @public\n     */\n    set(path, value, root) {\n      if (root) {\n        (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.set)(root, path, value);\n      } else {\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {\n          if (this._setPendingPropertyOrPath(path, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Adds items onto the end of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to push onto array\n     * @return {number} New length of the array.\n     * @public\n     */\n    push(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array}*/(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let len = array.length;\n      let ret = array.push(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, len, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the end of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    pop(path) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.pop();\n      if (hadLength) {\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Starting from the start index specified, removes 0 or more items\n     * from the array and inserts 0 or more new items in their place.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.splice`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {number} start Index from which to start removing/inserting.\n     * @param {number=} deleteCount Number of items to remove.\n     * @param {...*} items Items to insert into array.\n     * @return {!Array} Array of removed items.\n     * @public\n     */\n    splice(path, start, deleteCount, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      // Normalize fancy native splice handling of crazy start values\n      if (start < 0) {\n        start = array.length - Math.floor(-start);\n      } else if (start) {\n        start = Math.floor(start);\n      }\n      // array.splice does different things based on the number of arguments\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n      // do different things. In the former, the whole array is cleared. In the\n      // latter, no items are removed.\n      // This means that we need to detect whether 1. one of the arguments\n      // is actually passed in and then 2. determine how many arguments\n      // we should pass on to the native array.splice\n      //\n      let ret;\n      // Omit any additional arguments if they were not passed in\n      if (arguments.length === 2) {\n        ret = array.splice(start);\n        // Either start was undefined and the others were defined, but in this\n        // case we can safely pass on all arguments\n        //\n        // Note: this includes the case where none of the arguments were passed in,\n        // e.g. this.splice('array'). However, if both start and deleteCount\n        // are undefined, array.splice will not modify the array (as expected)\n      } else {\n        ret = array.splice(start, deleteCount, ...items);\n      }\n      // At the end, check whether any items were passed in (e.g. insertions)\n      // or if the return array contains items (e.g. deletions).\n      // Only notify if items were added or deleted.\n      if (items.length || ret.length) {\n        notifySplice(this, array, info.path, start, items.length, ret);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the beginning of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    shift(path) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.shift();\n      if (hadLength) {\n        notifySplice(this, array, info.path, 0, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Adds items onto the beginning of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to insert info array\n     * @return {number} New length of the array.\n     * @public\n     */\n    unshift(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let ret = array.unshift(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, 0, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Notify that a path has changed.\n     *\n     * Example:\n     *\n     *     this.item.user.name = 'Bob';\n     *     this.notifyPath('item.user.name');\n     *\n     * @override\n     * @param {string} path Path that should be notified.\n     * @param {*=} value Value at the path (optional).\n     * @return {void}\n     * @public\n     */\n    notifyPath(path, value) {\n      /** @type {string} */\n      let propPath;\n      if (arguments.length == 1) {\n        // Get value if not supplied\n        let info = {\n          path: ''\n        };\n        value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n        propPath = info.path;\n      } else if (Array.isArray(path)) {\n        // Normalize path if needed\n        propPath = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(path);\n      } else {\n        propPath = /** @type{string} */path;\n      }\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Equivalent to static `createReadOnlyProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     */\n    _createReadOnlyProperty(property, protectedSetter) {\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\n      if (protectedSetter) {\n        this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {\n          this._setProperty(property, value);\n        };\n      }\n    }\n\n    /**\n     * Equivalent to static `createPropertyObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method\n     *     to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createPropertyObserver(property, method, dynamicFn) {\n      let info = {\n        property,\n        method,\n        dynamicFn: Boolean(dynamicFn)\n      };\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\n        fn: runObserverEffect,\n        info,\n        trigger: {\n          name: property\n        }\n      });\n      if (dynamicFn) {\n        this._addPropertyEffect( /** @type {string} */method, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info,\n          trigger: {\n            name: method\n          }\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createMethodObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createMethodObserver(expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n      }\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n    }\n\n    /**\n     * Equivalent to static `createNotifyingProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     */\n    _createNotifyingProperty(property) {\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\n        fn: runNotifyEffect,\n        info: {\n          eventName: (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(property) + '-changed',\n          property: property\n        }\n      });\n    }\n\n    /**\n     * Equivalent to static `createReflectedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _createReflectedProperty(property) {\n      let attr = this.constructor.attributeNameForProperty(property);\n      if (attr[0] === '-') {\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n      } else {\n        this._addPropertyEffect(property, TYPES.REFLECT, {\n          fn: runReflectEffect,\n          info: {\n            attrName: attr\n          }\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createComputedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createComputedProperty(property, expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n      }\n      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      // Effects are normally stored as map of dependency->effect, but for\n      // ordered computation, we also need tree of computedProp->dependencies\n      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\n    }\n\n    /**\n     * Gather the argument values for a method specified in the provided array\n     * of argument metadata.\n     *\n     * The `path` and `value` arguments are used to fill in wildcard descriptor\n     * when the method is being called as a result of a path notification.\n     *\n     * @param {!Array<!MethodArg>} args Array of argument metadata\n     * @param {string} path Property/path name that triggered the method effect\n     * @param {Object} props Bag of current property changes\n     * @return {!Array<*>} Array of argument values\n     * @private\n     */\n    _marshalArgs(args, path, props) {\n      const data = this.__data;\n      const values = [];\n      for (let i = 0, l = args.length; i < l; i++) {\n        let {\n          name,\n          structured,\n          wildcard,\n          value,\n          literal\n        } = args[i];\n        if (!literal) {\n          if (wildcard) {\n            const matches = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(name, path);\n            const pathValue = getArgValue(data, props, matches ? path : name);\n            value = {\n              path: matches ? path : name,\n              value: pathValue,\n              base: matches ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(data, name) : pathValue\n            };\n          } else {\n            value = structured ? getArgValue(data, props, name) : data[name];\n          }\n        }\n        // When the `legacyUndefined` flag is enabled, pass a no-op value\n        // so that the observer, computed property, or compound binding is aborted.\n        if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\n          return NOOP;\n        }\n        values[i] = value;\n      }\n      return values;\n    }\n\n    // -- static class methods ------------\n\n    /**\n     * Ensures an accessor exists for the specified property, and adds\n     * to a list of \"property effects\" that will run when the accessor for\n     * the specified property is set.  Effects are grouped by \"type\", which\n     * roughly corresponds to a phase in effect processing.  The effect\n     * metadata should be in the following form:\n     *\n     *     {\n     *       fn: effectFunction, // Reference to function to call to perform effect\n     *       info: { ... }       // Effect metadata passed to function\n     *       trigger: {          // Optional triggering metadata; if not provided\n     *         name: string      // the property is treated as a wildcard\n     *         structured: boolean\n     *         wildcard: boolean\n     *       }\n     *     }\n     *\n     * Effects are called from `_propertiesChanged` in the following order by\n     * type:\n     *\n     * 1. COMPUTE\n     * 2. PROPAGATE\n     * 3. REFLECT\n     * 4. OBSERVE\n     * 5. NOTIFY\n     *\n     * Effect functions are called with the following signature:\n     *\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static addPropertyEffect(property, type, effect) {\n      this.prototype._addPropertyEffect(property, type, effect);\n    }\n\n    /**\n     * Creates a single-property observer for the given property.\n     *\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createPropertyObserver(property, method, dynamicFn) {\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\n    }\n\n    /**\n     * Creates a multi-property \"method observer\" based on the provided\n     * expression, which should be a string in the form of a normal JavaScript\n     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n     * should correspond to a property or path in the context of this\n     * prototype (or instance), or may be a literal string or number.\n     *\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     * @return {void}\n     *   whether method names should be included as a dependency to the effect.\n     * @protected\n     * @nocollapse\n     */\n    static createMethodObserver(expression, dynamicFn) {\n      this.prototype._createMethodObserver(expression, dynamicFn);\n    }\n\n    /**\n     * Causes the setter for the given property to dispatch `<property>-changed`\n     * events to notify of changes to the property.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createNotifyingProperty(property) {\n      this.prototype._createNotifyingProperty(property);\n    }\n\n    /**\n     * Creates a read-only accessor for the given property.\n     *\n     * To set the property, use the protected `_setProperty` API.\n     * To create a custom protected setter (e.g. `_setMyProp()` for\n     * property `myProp`), pass `true` for `protectedSetter`.\n     *\n     * Note, if the property will have other property effects, this method\n     * should be called first, before adding other effects.\n     *\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReadOnlyProperty(property, protectedSetter) {\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\n    }\n\n    /**\n     * Causes the setter for the given property to reflect the property value\n     * to a (dash-cased) attribute of the same name.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReflectedProperty(property) {\n      this.prototype._createReflectedProperty(property);\n    }\n\n    /**\n     * Creates a computed property whose value is set to the result of the\n     * method described by the given `expression` each time one or more\n     * arguments to the method changes.  The expression should be a string\n     * in the form of a normal JavaScript function signature:\n     * `'methodName(arg1, [..., argn])'`\n     *\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n     *   method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createComputedProperty(property, expression, dynamicFn) {\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\n    }\n\n    /**\n     * Parses the provided template to ensure binding effects are created\n     * for them, and then ensures property accessors are created for any\n     * dependent properties in the template.  Binding effects for bound\n     * templates are stored in a linked list on the instance so that\n     * templates can be efficiently stamped and unstamped.\n     *\n     * @param {!HTMLTemplateElement} template Template containing binding\n     *   bindings\n     * @return {!TemplateInfo} Template metadata object\n     * @protected\n     * @nocollapse\n     */\n    static bindTemplate(template) {\n      return this.prototype._bindTemplate(template);\n    }\n\n    // -- binding ----------------------------------------------\n\n    /*\n     * Overview of binding flow:\n     *\n     * During finalization (`instanceBinding==false`, `wasPreBound==false`):\n     *  `_bindTemplate(t, false)` called directly during finalization - parses\n     *  the template (for the first time), and then assigns that _prototypical_\n     *  template info to `__preboundTemplateInfo` _on the prototype_; note in\n     *  this case `wasPreBound` is false; this is the first time we're binding\n     *  it, thus we create accessors.\n     *\n     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\n     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\n     *   returned matches the prebound one, and so this is `wasPreBound == true`\n     *   state; thus we _skip_ creating accessors, but _do_ create an instance\n     *   of the template info to serve as the start of our linked list (needs to\n     *   be an instance, not the prototypical one, so that we can add `nodeList`\n     *   to it to contain the `nodeInfo`-ordered list of instance nodes for\n     *   bindings, and so we can chain runtime-stamped template infos off of\n     *   it). At this point, the call to `_stampTemplate` calls\n     *   `applyTemplateInfo` for each nested `<template>` found during parsing\n     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\n     *   `templateInfo` to the `<template>` so that we have the instance-time\n     *   parent to link the `templateInfo` under in the case it was\n     *   runtime-stamped.\n     *\n     * During subsequent runtime stamping (`instanceBinding==true`,\n     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\n     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\n     *   because it was either a different template altogether, or even if it\n     *   was the same template, the step above created a instance of the info;\n     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\n     *   link a instance into the linked list.\n     */\n\n    /**\n     * Equivalent to static `bindTemplate` API but can be called on an instance\n     * to add effects at runtime.  See that method for full API docs.\n     *\n     * This method may be called on the prototype (for prototypical template\n     * binding, to avoid creating accessors every instance) once per prototype,\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n     * create and link an instance of the template metadata associated with a\n     * particular stamping.\n     *\n     * @override\n     * @param {!HTMLTemplateElement} template Template containing binding\n     * bindings\n     * @param {boolean=} instanceBinding When false (default), performs\n     * \"prototypical\" binding of the template and overwrites any previously\n     * bound template for the class. When true (as passed from\n     * `_stampTemplate`), the template info is instanced and linked into the\n     * list of bound templates.\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n     * this is an instance of the prototypical template info\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _bindTemplate(template, instanceBinding) {\n      let templateInfo = this.constructor._parseTemplate(template);\n      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;\n      // Optimization: since this is called twice for proto-bound templates,\n      // don't attempt to recreate accessors if this template was pre-bound\n      if (!wasPreBound) {\n        for (let prop in templateInfo.propertyEffects) {\n          this._createPropertyAccessor(prop);\n        }\n      }\n      if (instanceBinding) {\n        // For instance-time binding, create instance of template metadata\n        // and link into tree of templates if necessary\n        templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);\n        templateInfo.wasPreBound = wasPreBound;\n        if (!this.__templateInfo) {\n          // Set the info to the root of the tree\n          this.__templateInfo = templateInfo;\n        } else {\n          // Append this template info onto the end of its parent template's\n          // list, which will determine the tree structure via which property\n          // effects are run; if this template was not nested in another\n          // template, use the root template (the first stamped one) as the\n          // parent. Note, `parent` is the `templateInfo` instance for this\n          // template's parent (containing) template, which was set up in\n          // `applyTemplateInfo`.  While a given template's `parent` is set\n          // apriori, it is only added to the parent's child list at the point\n          // that it is being bound, since a template may or may not ever be\n          // stamped, and may be stamped more than once (in which case instances\n          // of the template info will be in the tree under its parent more than\n          // once).\n          const parent = template._parentTemplateInfo || this.__templateInfo;\n          const previous = parent.lastChild;\n          templateInfo.parent = parent;\n          parent.lastChild = templateInfo;\n          templateInfo.previousSibling = previous;\n          if (previous) {\n            previous.nextSibling = templateInfo;\n          } else {\n            parent.firstChild = templateInfo;\n          }\n        }\n      } else {\n        this.__preBoundTemplateInfo = templateInfo;\n      }\n      return templateInfo;\n    }\n\n    /**\n     * Adds a property effect to the given template metadata, which is run\n     * at the \"propagate\" stage of `_propertiesChanged` when the template\n     * has been bound to the element via `_bindTemplate`.\n     *\n     * The `effect` object should match the format in `_addPropertyEffect`.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n      hostProps[prop] = true;\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n      let propEffects = effects[prop] = effects[prop] || [];\n      propEffects.push(effect);\n    }\n\n    /**\n     * Stamps the provided template and performs instance-time setup for\n     * Polymer template features, including data bindings, declarative event\n     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n     * is returned containing the stamped DOM, ready for insertion into the\n     * DOM.\n     *\n     * This method may be called more than once; however note that due to\n     * `shadycss` polyfill limitations, only styles from templates prepared\n     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n     * to the shadow root and support CSS custom properties), and note that\n     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n     * any styles required by in runtime-stamped templates must be included\n     * in the main element template.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional bound template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically bound.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     * @protected\n     */\n    _stampTemplate(template, templateInfo) {\n      templateInfo = templateInfo || /** @type {!TemplateInfo} */this._bindTemplate(template, true);\n      // Ensures that created dom is `_enqueueClient`'d to this element so\n      // that it can be flushed on next call to `_flushProperties`\n      hostStack.push(this);\n      let dom = super._stampTemplate(template, templateInfo);\n      hostStack.pop();\n      // Add template-instance-specific data to instanced templateInfo\n      templateInfo.nodeList = dom.nodeList;\n      // Capture child nodes to allow unstamping of non-prototypical templates\n      if (!templateInfo.wasPreBound) {\n        let nodes = templateInfo.childNodes = [];\n        for (let n = dom.firstChild; n; n = n.nextSibling) {\n          nodes.push(n);\n        }\n      }\n      dom.templateInfo = templateInfo;\n      // Setup compound storage, 2-way listeners, and dataHost for bindings\n      setupBindings(this, templateInfo);\n      // Flush properties into template nodes; the check on `__dataClientsReady`\n      // ensures we don't needlessly run effects for an element's initial\n      // prototypical template stamping since they will happen as a part of the\n      // first call to `_propertiesChanged`. This flag is set to true\n      // after running the initial propagate effects, and immediately before\n      // flushing clients. Since downstream clients could cause stamping on\n      // this host (e.g. a fastDomIf `dom-if` being forced to render\n      // synchronously), this flag ensures effects for runtime-stamped templates\n      // are run at this point during the initial element boot-up.\n      if (this.__dataClientsReady) {\n        this._runEffectsForTemplate(templateInfo, this.__data, null, false);\n        this._flushClients();\n      }\n      return dom;\n    }\n\n    /**\n     * Removes and unbinds the nodes previously contained in the provided\n     * DocumentFragment returned from `_stampTemplate`.\n     *\n     * @override\n     * @param {!StampedTemplate} dom DocumentFragment previously returned\n     *   from `_stampTemplate` associated with the nodes to be removed\n     * @return {void}\n     * @protected\n     */\n    _removeBoundDom(dom) {\n      // Unlink template info; Note that while the child is unlinked from its\n      // parent list, a template's `parent` reference is never removed, since\n      // this is is determined by the tree structure and applied at\n      // `applyTemplateInfo` time.\n      const templateInfo = dom.templateInfo;\n      const {\n        previousSibling,\n        nextSibling,\n        parent\n      } = templateInfo;\n      if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n      } else if (parent) {\n        parent.firstChild = nextSibling;\n      }\n      if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n      } else if (parent) {\n        parent.lastChild = previousSibling;\n      }\n      templateInfo.nextSibling = templateInfo.previousSibling = null;\n      // Remove stamped nodes\n      let nodes = templateInfo.childNodes;\n      for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)((0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node).parentNode).removeChild(node);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNode.call(this, node, templateInfo, nodeInfo);\n      if (node.nodeType === Node.TEXT_NODE) {\n        let parts = this._parseBindings(node.textContent, templateInfo);\n        if (parts) {\n          // Initialize the textContent with any literal parts\n          // NOTE: default to a space here so the textNode remains; some browsers\n          // (IE) omit an empty textNode following cloneNode/importNode.\n          node.textContent = literalFromParts(parts) || ' ';\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n          noted = true;\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from attributes.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      let parts = this._parseBindings(value, templateInfo);\n      if (parts) {\n        // Attribute or property\n        let origName = name;\n        let kind = 'property';\n        // The only way we see a capital letter here is if the attr has\n        // a capital letter in it per spec. In this case, to make sure\n        // this binding works, we go ahead and make the binding to the attribute.\n        if (capitalAttributeRegex.test(name)) {\n          kind = 'attribute';\n        } else if (name[name.length - 1] == '$') {\n          name = name.slice(0, -1);\n          kind = 'attribute';\n        }\n        // Initialize attribute bindings with any literal parts\n        let literal = literalFromParts(parts);\n        if (literal && kind == 'attribute') {\n          // Ensure a ShadyCSS template scoped style is not removed\n          // when a class$ binding's initial literal value is set.\n          if (name == 'class' && node.hasAttribute('class')) {\n            literal += ' ' + node.getAttribute(name);\n          }\n          node.setAttribute(name, literal);\n        }\n        // support disable-upgrade\n        if (kind == 'attribute' && origName == 'disable-upgrade$') {\n          node.setAttribute(name, '');\n        }\n        // Clear attribute before removing, since IE won't allow removing\n        // `value` attribute if it previously had a value (can't\n        // unconditionally set '' before removing since attributes with `$`\n        // can't be set using setAttribute)\n        if (node.localName === 'input' && origName === 'value') {\n          node.setAttribute(origName, '');\n        }\n        // Remove annotation\n        node.removeAttribute(origName);\n        // Case hackery: attributes are lower-case, but bind targets\n        // (properties) are case sensitive. Gambit is to map dash-case to\n        // camel-case: `foo-bar` becomes `fooBar`.\n        // Attribute bindings are excepted.\n        if (kind === 'property') {\n          name = (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.dashToCamelCase)(name);\n        }\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n        return true;\n      } else {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        return propertyEffectsBase._parseTemplateNodeAttribute.call(this, node, templateInfo, nodeInfo, name, value);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * binding the properties that a nested template depends on to the template\n     * as `_host_<property>`.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(this, node, templateInfo, nodeInfo);\n      const parent = node.parentNode;\n      const nestedTemplateInfo = nodeInfo.templateInfo;\n      const isDomIf = parent.localName === 'dom-if';\n      const isDomRepeat = parent.localName === 'dom-repeat';\n      // Remove nested template and redirect its host bindings & templateInfo\n      // onto the parent (dom-if/repeat element)'s nodeInfo\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.removeNestedTemplates && (isDomIf || isDomRepeat)) {\n        parent.removeChild(node);\n        // Use the parent's nodeInfo (for the dom-if/repeat) to record the\n        // templateInfo, and use that for any host property bindings below\n        nodeInfo = nodeInfo.parentInfo;\n        nodeInfo.templateInfo = nestedTemplateInfo;\n        // Ensure the parent dom-if/repeat is noted since it now may have host\n        // bindings; it may not have been if it did not have its own bindings\n        nodeInfo.noted = true;\n        noted = false;\n      }\n      // Merge host props into outer template and add bindings\n      let hostProps = nestedTemplateInfo.hostProps;\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.fastDomIf && isDomIf) {\n        // `fastDomIf` mode uses runtime-template stamping to add accessors/\n        // effects to properties used in its template; as such we don't need to\n        // tax the host element with `_host_` bindings for the `dom-if`.\n        // However, in the event it is nested in a `dom-repeat`, it is still\n        // important that its host properties are added to the\n        // TemplateInstance's `hostProps` so that they are forwarded to the\n        // TemplateInstance.\n        if (hostProps) {\n          templateInfo.hostProps = Object.assign(templateInfo.hostProps || {}, hostProps);\n          // Ensure the dom-if is noted so that it has a __dataHost, since\n          // `fastDomIf` uses the host for runtime template stamping; note this\n          // was already ensured above in the `removeNestedTemplates` case\n          if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.removeNestedTemplates) {\n            nodeInfo.parentInfo.noted = true;\n          }\n        }\n      } else {\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{\n            mode,\n            source,\n            dependencies: [source],\n            hostProp: true\n          }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Called to parse text in a template (either attribute values or\n     * textContent) into binding metadata.\n     *\n     * Any overrides of this method should return an array of binding part\n     * metadata  representing one or more bindings found in the provided text\n     * and any \"literal\" text in between.  Any non-literal parts will be passed\n     * to `_evaluateBinding` when any dependencies change.  The only required\n     * fields of each \"part\" in the returned array are as follows:\n     *\n     * - `dependencies` - Array containing trigger metadata for each property\n     *   that should trigger the binding to update\n     * - `literal` - String containing text if the part represents a literal;\n     *   in this case no `dependencies` are needed\n     *\n     * Additional metadata for use by `_evaluateBinding` may be provided in\n     * each part object as needed.\n     *\n     * The default implementation handles the following types of bindings\n     * (one or more may be intermixed with literal strings):\n     * - Property binding: `[[prop]]`\n     * - Path binding: `[[object.prop]]`\n     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n     * - Two-way property or path bindings (supports negation):\n     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n     * - Inline computed method (supports negation):\n     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n     *\n     * The default implementation uses a regular expression for best\n     * performance. However, the regular expression uses a white-list of\n     * allowed characters in a data-binding, which causes problems for\n     * data-bindings that do use characters not in this white-list.\n     *\n     * Instead of updating the white-list with all allowed characters,\n     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n     * that uses a state machine instead. This state machine is able to handle\n     * all characters. However, it is slightly less performant, therefore we\n     * extracted it into a separate optional mixin.\n     *\n     * @param {string} text Text to parse from attribute or textContent\n     * @param {Object} templateInfo Current template metadata\n     * @return {Array<!BindingPart>} Array of binding part metadata\n     * @protected\n     * @nocollapse\n     */\n    static _parseBindings(text, templateInfo) {\n      let parts = [];\n      let lastIndex = 0;\n      let m;\n      // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n      // Regex matches:\n      //        Iteration 1:  Iteration 2:\n      // m[1]: '{{'          '[['\n      // m[2]: ''            '!'\n      // m[3]: 'prop'        'compute(foo,bar)'\n      while ((m = bindingRegex.exec(text)) !== null) {\n        // Add literal part\n        if (m.index > lastIndex) {\n          parts.push({\n            literal: text.slice(lastIndex, m.index)\n          });\n        }\n        // Add binding part\n        let mode = m[1][0];\n        let negate = Boolean(m[2]);\n        let source = m[3].trim();\n        let customEvent = false,\n          notifyEvent = '',\n          colon = -1;\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n          notifyEvent = source.substring(colon + 2);\n          source = source.substring(0, colon);\n          customEvent = true;\n        }\n        let signature = parseMethod(source);\n        let dependencies = [];\n        if (signature) {\n          // Inline computed function\n          let {\n            args,\n            methodName\n          } = signature;\n          for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n            if (!arg.literal) {\n              dependencies.push(arg);\n            }\n          }\n          let dynamicFns = templateInfo.dynamicFns;\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\n            dependencies.push(methodName);\n            signature.dynamicFn = true;\n          }\n        } else {\n          // Property or path\n          dependencies.push(source);\n        }\n        parts.push({\n          source,\n          mode,\n          negate,\n          customEvent,\n          signature,\n          dependencies,\n          event: notifyEvent\n        });\n        lastIndex = bindingRegex.lastIndex;\n      }\n      // Add a final literal part\n      if (lastIndex && lastIndex < text.length) {\n        let literal = text.substring(lastIndex);\n        if (literal) {\n          parts.push({\n            literal: literal\n          });\n        }\n      }\n      if (parts.length) {\n        return parts;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Called to evaluate a previously parsed binding part based on a set of\n     * one or more changed dependencies.\n     *\n     * @param {!Polymer_PropertyEffects} inst Element that should be used as\n     *     scope for binding dependencies\n     * @param {BindingPart} part Binding part metadata\n     * @param {string} path Property/path that triggered this effect\n     * @param {Object} props Bag of current property changes\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {*} Value the binding part evaluated to\n     * @protected\n     * @nocollapse\n     */\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n      let value;\n      if (part.signature) {\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\n      } else if (path != part.source) {\n        value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, part.source);\n      } else {\n        if (hasPaths && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(path)) {\n          value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n      if (part.negate) {\n        value = !value;\n      }\n      return value;\n    }\n  }\n  return PropertyEffects;\n});\n\n/**\n * Stack for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\nconst hostStack = [];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzP2VhOTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBAc3VwcHJlc3Mge2NoZWNrUHJvdG90eXBhbFR5cGVzfVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmRcbiAqIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dCBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXlcbiAqIGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0IENvZGUgZGlzdHJpYnV0ZWQgYnlcbiAqIEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzbyBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVBcbiAqIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG5pbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJy4uL3V0aWxzL3dyYXAuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHJvb3QsIGlzQW5jZXN0b3IsIGlzRGVzY2VuZGFudCwgZ2V0LCB0cmFuc2xhdGUsIGlzUGF0aCwgc2V0LCBub3JtYWxpemUgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcbi8qIGZvciBub3RpZnksIHJlZmxlY3QgKi9cbmltcG9ydCB7IGNhbWVsVG9EYXNoQ2FzZSwgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlBY2Nlc3NvcnMgfSBmcm9tICcuL3Byb3BlcnR5LWFjY2Vzc29ycy5qcyc7XG4vKiBmb3IgYW5ub3RhdGVkIGVmZmVjdHMgKi9cbmltcG9ydCB7IFRlbXBsYXRlU3RhbXAgfSBmcm9tICcuL3RlbXBsYXRlLXN0YW1wLmpzJztcbmltcG9ydCB7IHNhbml0aXplRE9NVmFsdWUsIGxlZ2FjeVVuZGVmaW5lZCwgb3JkZXJlZENvbXB1dGVkLCByZW1vdmVOZXN0ZWRUZW1wbGF0ZXMsIGZhc3REb21JZiB9IGZyb20gJy4uL3V0aWxzL3NldHRpbmdzLmpzJztcblxuLy8gTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHVuaXF1ZSBJRCB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0cyB0cmlnZ2VyZWRcbi8vIGZyb20gbXVsdGlwbGUgcHJvcGVydGllcyBpbiB0aGUgc2FtZSB0dXJuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG5jb25zdCBOT09QID0gW107XG5cbi8qKlxuICogUHJvcGVydHkgZWZmZWN0IHR5cGVzOyBlZmZlY3RzIGFyZSBzdG9yZWQgb24gdGhlIHByb3RvdHlwZSB1c2luZyB0aGVzZSBrZXlzXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBUWVBFUyA9IHtcbiAgQ09NUFVURTogJ19fY29tcHV0ZUVmZmVjdHMnLFxuICBSRUZMRUNUOiAnX19yZWZsZWN0RWZmZWN0cycsXG4gIE5PVElGWTogJ19fbm90aWZ5RWZmZWN0cycsXG4gIFBST1BBR0FURTogJ19fcHJvcGFnYXRlRWZmZWN0cycsXG4gIE9CU0VSVkU6ICdfX29ic2VydmVFZmZlY3RzJyxcbiAgUkVBRF9PTkxZOiAnX19yZWFkT25seSdcbn07XG5cbmNvbnN0IENPTVBVVEVfSU5GTyA9ICdfX2NvbXB1dGVJbmZvJztcblxuLyoqIEBjb25zdCB7IVJlZ0V4cH0gKi9cbmNvbnN0IGNhcGl0YWxBdHRyaWJ1dGVSZWdleCA9IC9bQS1aXS87XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIG5hbWU6IChzdHJpbmcgfCB1bmRlZmluZWQpLFxuICogc3RydWN0dXJlZDogKGJvb2xlYW4gfCB1bmRlZmluZWQpLFxuICogd2lsZGNhcmQ6IChib29sZWFuIHwgdW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IERhdGFUcmlnZ2VyOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogaW5mbzogPyxcbiAqIHRyaWdnZXI6ICghRGF0YVRyaWdnZXIgfCB1bmRlZmluZWQpLFxuICogZm46ICghRnVuY3Rpb24gfCB1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgRGF0YUVmZmVjdDsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBtb2RlbCBoYXMgYW4gb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gKlxuICogUHJvcGVydHkgZWZmZWN0cyBhcmUgc3RvcmVkIGFzIGFycmF5cyBvZiBlZmZlY3RzIGJ5IHByb3BlcnR5IGluIGEgbWFwLFxuICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAqXG4gKiAgIF9fY29tcHV0ZUVmZmVjdHM6IHtcbiAqICAgICBmb286IFsgLi4uIF0sXG4gKiAgICAgYmFyOiBbIC4uLiBdXG4gKiAgIH1cbiAqXG4gKiBJZiB0aGUgbW9kZWwgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IG1hcCBmb3IgdGhlIHR5cGUsIG9uZSBpcyBjcmVhdGVkXG4gKiBhbmQgcmV0dXJuZWQuICBJZiBpdCBkb2VzLCBidXQgaXQgaXMgbm90IGFuIG93biBwcm9wZXJ0eSAoaS5lLiB0aGVcbiAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gKiBzZXQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5lZCwgcmVhZHkgZm9yIG5ldyBlZmZlY3RzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFByb3BlcnR5IGVmZmVjdCB0eXBlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBjbG9uZUFycmF5cyBDbG9uZSBhbnkgYXJyYXlzIGFzc2lnbmVkIHRvIHRoZSBtYXAgd2hlblxuICogICBleHRlbmRpbmcgYSBzdXBlcmNsYXNzIG1hcCBvbnRvIHRoaXMgc3ViY2xhc3NcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG93bi1wcm9wZXJ0eSBtYXAgb2YgZWZmZWN0cyBmb3IgdGhlIGdpdmVuIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZU93bkVmZmVjdE1hcChtb2RlbCwgdHlwZSwgY2xvbmVBcnJheXMpIHtcbiAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgaWYgKCFlZmZlY3RzKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0ge307XG4gIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShtb2RlbFt0eXBlXSk7XG4gICAgaWYgKGNsb25lQXJyYXlzKSB7XG4gICAgICBmb3IgKGxldCBwIGluIGVmZmVjdHMpIHtcbiAgICAgICAgbGV0IHByb3RvRnggPSBlZmZlY3RzW3BdO1xuICAgICAgICAvLyBQZXJmIG9wdGltaXphdGlvbiBvdmVyIEFycmF5LnNsaWNlXG4gICAgICAgIGxldCBpbnN0RnggPSBlZmZlY3RzW3BdID0gQXJyYXkocHJvdG9GeC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cHJvdG9GeC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVmZmVjdHM7XG59XG5cbi8vIC0tIGVmZmVjdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFJ1bnMgYWxsIGVmZmVjdHMgb2YgYSBnaXZlbiB0eXBlIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIHByb3BlcnR5IGNoYW5nZXNcbiAqIG9uIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0gez9PYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gKiBAcGFyYW0gez9PYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7P09iamVjdD19IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHMoaW5zdCwgZWZmZWN0cywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGlmIChlZmZlY3RzKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gZGVkdXBlSWQrKztcbiAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAvLyBJbmxpbmUgYHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eWAgZm9yIHBlcmYuXG4gICAgICBsZXQgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyByb290KHByb3ApIDogcHJvcDtcbiAgICAgIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gICAgICBpZiAoZnhzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MCwgbD1meHMubGVuZ3RoLCBmeDsgKGk8bCkgJiYgKGZ4PWZ4c1tpXSk7IGkrKykge1xuICAgICAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBpZCkgJiZcbiAgICAgICAgICAgICAgKCFoYXNQYXRocyB8fCBwYXRoTWF0Y2hlc1RyaWdnZXIocHJvcCwgZngudHJpZ2dlcikpKSB7XG4gICAgICAgICAgICBpZiAoZnguaW5mbykge1xuICAgICAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ4LmZuKGluc3QsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgZnguaW5mbywgaGFzUGF0aHMsIGV4dHJhQXJncyk7XG4gICAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgbGlzdCBvZiBlZmZlY3RzIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0geyFPYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gKiBAcGFyYW0ge251bWJlcn0gZGVkdXBlSWQgQ291bnRlciB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0c1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgTmFtZSBvZiBjaGFuZ2VkIHByb3BlcnR5XG4gKiBAcGFyYW0geyp9IHByb3BzIENoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHsqfSBvbGRQcm9wcyBPbGQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBkZWR1cGVJZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGxldCByYW4gPSBmYWxzZTtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdChwcm9wKSA6IHByb3A7XG4gIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gIGlmIChmeHMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ZnhzLmxlbmd0aCwgZng7IChpPGwpICYmIChmeD1meHNbaV0pOyBpKyspIHtcbiAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgaWYgKGZ4LmluZm8pIHtcbiAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgfVxuICAgICAgICBmeC5mbihpbnN0LCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGZ4LmluZm8sIGhhc1BhdGhzLCBleHRyYUFyZ3MpO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmFuO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHByb3BlcnR5L3BhdGggdGhhdCBoYXMgY2hhbmdlZCBtYXRjaGVzIHRoZSB0cmlnZ2VyXG4gKiBjcml0ZXJpYSBmb3IgYW4gZWZmZWN0LiAgQSB0cmlnZ2VyIGlzIGEgZGVzY3JpcHRvciB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICogZS5nLiBmb3IgYGZvby5iYXIuKmA6XG4gKiBgYGBcbiAqIHRyaWdnZXI6IHtcbiAqICAgbmFtZTogJ2EuYicsXG4gKiAgIHN0cnVjdHVyZWQ6IHRydWUsXG4gKiAgIHdpbGRjYXJkOiB0cnVlXG4gKiB9XG4gKiBgYGBcbiAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIG9yIHByb3BlcnR5IHRoYXQgY2hhbmdlZFxuICogQHBhcmFtIHs/RGF0YVRyaWdnZXJ9IHRyaWdnZXIgRGVzY3JpcHRvclxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcGF0aCBtYXRjaGVkIHRoZSB0cmlnZ2VyXG4gKi9cbmZ1bmN0aW9uIHBhdGhNYXRjaGVzVHJpZ2dlcihwYXRoLCB0cmlnZ2VyKSB7XG4gIGlmICh0cmlnZ2VyKSB7XG4gICAgbGV0IHRyaWdnZXJQYXRoID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0cmlnZ2VyLm5hbWUpO1xuICAgIHJldHVybiAodHJpZ2dlclBhdGggPT0gcGF0aCkgfHxcbiAgICAgICAgISEodHJpZ2dlci5zdHJ1Y3R1cmVkICYmIGlzQW5jZXN0b3IodHJpZ2dlclBhdGgsIHBhdGgpKSB8fFxuICAgICAgICAhISh0cmlnZ2VyLndpbGRjYXJkICYmIGlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAqXG4gKiBDYWxscyB0aGUgbWV0aG9kIHdpdGggYGluZm8ubWV0aG9kTmFtZWAgb24gdGhlIGluc3RhbmNlLCBwYXNzaW5nIHRoZVxuICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5PYnNlcnZlckVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCBmbiA9IHR5cGVvZiBpbmZvLm1ldGhvZCA9PT0gXCJzdHJpbmdcIiA/IGluc3RbaW5mby5tZXRob2RdIDogaW5mby5tZXRob2Q7XG4gIGxldCBjaGFuZ2VkUHJvcCA9IGluZm8ucHJvcGVydHk7XG4gIGlmIChmbikge1xuICAgIGZuLmNhbGwoaW5zdCwgaW5zdC5fX2RhdGFbY2hhbmdlZFByb3BdLCBvbGRQcm9wc1tjaGFuZ2VkUHJvcF0pO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2QgKyAnYCBub3QgZGVmaW5lZCcpO1xuICB9XG59XG5cbi8qKlxuICogUnVucyBcIm5vdGlmeVwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gdGhlIGdlbmVyaWMgYHJ1bkVmZmVjdHNgIG1ldGhvZCBpbiB0aGF0IGl0XG4gKiB3aWxsIGRpc3BhdGNoIHBhdGggbm90aWZpY2F0aW9uIGV2ZW50cyBpbiB0aGUgY2FzZSB0aGF0IHRoZSBwcm9wZXJ0eVxuICogY2hhbmdlZCB3YXMgYSBwYXRoIGFuZCB0aGUgcm9vdCBwcm9wZXJ0eSBmb3IgdGhhdCBwYXRoIGRpZG4ndCBoYXZlIGFcbiAqIFwibm90aWZ5XCIgZWZmZWN0LiAgVGhpcyBpcyB0byBtYWludGFpbiAxLjAgYmVoYXZpb3IgdGhhdCBkaWQgbm90IHJlcXVpcmVcbiAqIGBub3RpZnk6IHRydWVgIHRvIGVuc3VyZSBvYmplY3Qgc3ViLXByb3BlcnR5IG5vdGlmaWNhdGlvbnMgd2VyZVxuICogc2VudC5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IG5vdGlmeVByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIG5vdGlmeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3RzKGluc3QsIG5vdGlmeVByb3BzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gIC8vIE5vdGlmeVxuICBsZXQgZnhzID0gaW5zdFtUWVBFUy5OT1RJRlldO1xuICBsZXQgbm90aWZpZWQ7XG4gIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gIC8vIFRyeSBub3JtYWwgbm90aWZ5IGVmZmVjdHM7IGlmIG5vbmUsIGZhbGwgYmFjayB0byB0cnkgcGF0aCBub3RpZmljYXRpb25cbiAgZm9yIChsZXQgcHJvcCBpbiBub3RpZnlQcm9wcykge1xuICAgIGlmIChub3RpZnlQcm9wc1twcm9wXSkge1xuICAgICAgaWYgKGZ4cyAmJiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZnhzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykpIHtcbiAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChoYXNQYXRocyAmJiBub3RpZnlQYXRoKGluc3QsIHByb3AsIHByb3BzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEZsdXNoIGhvc3QgaWYgd2UgYWN0dWFsbHkgbm90aWZpZWQgYW5kIGhvc3Qgd2FzIGJhdGNoaW5nXG4gIC8vIEFuZCB0aGUgaG9zdCBoYXMgYWxyZWFkeSBpbml0aWFsaXplZCBjbGllbnRzOyB0aGlzIHByZXZlbnRzXG4gIC8vIGFuIGlzc3VlIHdpdGggYSBob3N0IG9ic2VydmluZyBkYXRhIGNoYW5nZXMgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICBsZXQgaG9zdDtcbiAgaWYgKG5vdGlmaWVkICYmIChob3N0ID0gaW5zdC5fX2RhdGFIb3N0KSAmJiBob3N0Ll9pbnZhbGlkYXRlUHJvcGVydGllcykge1xuICAgIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgd2l0aCBwYXRoIGluZm9ybWF0aW9uIGluIHRoZSBkZXRhaWxcbiAqIG9iamVjdCB0byBpbmRpY2F0ZSBhIHN1Yi1wYXRoIG9mIHRoZSBwcm9wZXJ0eSB3YXMgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlXG4gKiAgICAgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRoYXQgd2FzIGNoYW5nZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdGggd2FzIG5vdGlmaWVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlQYXRoKGluc3QsIHBhdGgsIHByb3BzKSB7XG4gIGxldCByb290UHJvcGVydHkgPSByb290KHBhdGgpO1xuICBpZiAocm9vdFByb3BlcnR5ICE9PSBwYXRoKSB7XG4gICAgbGV0IGV2ZW50TmFtZSA9IGNhbWVsVG9EYXNoQ2FzZShyb290UHJvcGVydHkpICsgJy1jaGFuZ2VkJztcbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgcHJvcHNbcGF0aF0sIHBhdGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgdG8gaW5kaWNhdGUgYSBwcm9wZXJ0eSAob3IgcGF0aClcbiAqIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZVxuICogICAgIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kXG4gKiAgICAgKCd7cHJvcGVydHl9LWNoYW5nZWQnKVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGNoYW5nZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGF0aCBJZiBhIHN1Yi1wYXRoIG9mIHRoaXMgcHJvcGVydHlcbiAqICAgICBjaGFuZ2VkLCB0aGUgcGF0aCB0aGF0IGNoYW5nZWQgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCkge1xuICBsZXQgZGV0YWlsID0ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBxdWV1ZVByb3BlcnR5OiB0cnVlXG4gIH07XG4gIGlmIChwYXRoKSB7XG4gICAgZGV0YWlsLnBhdGggPSBwYXRoO1xuICB9XG4gIC8vIEFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCB3ZSBjb3VsZCBlbGlkZSB0aGUgd3JhcCBoZXJlIHNpbmNlIG5vdGlmeWluZ1xuICAvLyBldmVudHMgYXJlIG5vbi1idWJibGluZyBhbmQgc2hvdWxkbid0IG5lZWQgcmV0YXJnZXRpbmcuIEhvd2V2ZXIsIGEgdmVyeVxuICAvLyBzbWFsbCBudW1iZXIgb2YgaW50ZXJuYWwgdGVzdHMgZmFpbGVkIGluIG9ic2N1cmUgd2F5cywgd2hpY2ggbWF5IGluZGljYXRlXG4gIC8vIHVzZXIgY29kZSByZWxpZWQgb24gdGltaW5nIGRpZmZlcmVuY2VzIHJlc3VsdGluZyBmcm9tIFNoYWR5RE9NIGZsdXNoaW5nXG4gIC8vIGFzIGEgcmVzdWx0IG9mIHRoZSB3cmFwcGVkIGBkaXNwYXRjaEV2ZW50YC5cbiAgd3JhcCgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkpLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwgfSkpO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFwibm90aWZ5XCIgZWZmZWN0LlxuICpcbiAqIERpc3BhdGNoZXMgYSBub24tYnViYmxpbmcgZXZlbnQgbmFtZWQgYGluZm8uZXZlbnROYW1lYCBvbiB0aGUgaW5zdGFuY2VcbiAqIHdpdGggYSBkZXRhaWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5ldyBgdmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdChwcm9wZXJ0eSkgOiBwcm9wZXJ0eTtcbiAgbGV0IHBhdGggPSByb290UHJvcGVydHkgIT0gcHJvcGVydHkgPyBwcm9wZXJ0eSA6IG51bGw7XG4gIGxldCB2YWx1ZSA9IHBhdGggPyBnZXQoaW5zdCwgcGF0aCkgOiBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gIGlmIChwYXRoICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IHByb3BzW3Byb3BlcnR5XTsgIC8vIHNwZWNpZmljYWxseSBmb3IgLnNwbGljZXNcbiAgfVxuICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGluZm8uZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmdW5jdGlvbiBmb3IgMi13YXkgbm90aWZpY2F0aW9uIGV2ZW50cy4gUmVjZWl2ZXMgY29udGV4dFxuICogaW5mb3JtYXRpb24gY2FwdHVyZWQgaW4gdGhlIGBhZGROb3RpZnlMaXN0ZW5lcmAgY2xvc3VyZSBmcm9tIHRoZVxuICogYF9fbm90aWZ5TGlzdGVuZXJzYCBtZXRhZGF0YS5cbiAqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbm90aWZpZWQgcHJvcGVydHkgdG8gdGhlIGhvc3QgcHJvcGVydHkgb3IgcGF0aC4gIElmXG4gKiB0aGUgZXZlbnQgY29udGFpbmVkIHBhdGggaW5mb3JtYXRpb24sIHRyYW5zbGF0ZSB0aGF0IHBhdGggdG8gdGhlIGhvc3RcbiAqIHNjb3BlJ3MgbmFtZSBmb3IgdGhhdCBwYXRoIGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGV2ZW50IE5vdGlmaWNhdGlvbiBldmVudCAoZS5nLiAnPHByb3BlcnR5Pi1jaGFuZ2VkJylcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSBoYW5kbGluZyB0aGVcbiAqICAgICBub3RpZmljYXRpb24gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tUHJvcCBDaGlsZCBlbGVtZW50IHByb3BlcnR5IHRoYXQgd2FzIGJvdW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9QYXRoIEhvc3QgcHJvcGVydHkvcGF0aCB0aGF0IHdhcyBib3VuZFxuICogQHBhcmFtIHtib29sZWFufSBuZWdhdGUgV2hldGhlciB0aGUgYmluZGluZyB3YXMgbmVnYXRlZFxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihldmVudCwgaW5zdCwgZnJvbVByb3AsIHRvUGF0aCwgbmVnYXRlKSB7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICBsZXQgZnJvbVBhdGggPSBkZXRhaWwgJiYgZGV0YWlsLnBhdGg7XG4gIGlmIChmcm9tUGF0aCkge1xuICAgIHRvUGF0aCA9IHRyYW5zbGF0ZShmcm9tUHJvcCwgdG9QYXRoLCBmcm9tUGF0aCk7XG4gICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZXZlbnQuY3VycmVudFRhcmdldFtmcm9tUHJvcF07XG4gIH1cbiAgdmFsdWUgPSBuZWdhdGUgPyAhdmFsdWUgOiB2YWx1ZTtcbiAgaWYgKCFpbnN0W1RZUEVTLlJFQURfT05MWV0gfHwgIWluc3RbVFlQRVMuUkVBRF9PTkxZXVt0b1BhdGhdKSB7XG4gICAgaWYgKGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCh0b1BhdGgsIHZhbHVlLCB0cnVlLCBCb29sZWFuKGZyb21QYXRoKSlcbiAgICAgICYmICghZGV0YWlsIHx8ICFkZXRhaWwucXVldWVQcm9wZXJ0eSkpIHtcbiAgICAgIGluc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJyZWZsZWN0XCIgZWZmZWN0LlxuICpcbiAqIFNldHMgdGhlIGF0dHJpYnV0ZSBuYW1lZCBgaW5mby5hdHRyTmFtZWAgdG8gdGhlIGdpdmVuIHByb3BlcnR5IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IHZhbHVlID0gaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgaW5mby5hdHRyTmFtZSwgJ2F0dHJpYnV0ZScsIC8qKiBAdHlwZSB7Tm9kZX0gKi8oaW5zdCkpO1xuICB9XG4gIGluc3QuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGluZm8uYXR0ck5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSdW5zIFwiY29tcHV0ZWRcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogY29udGludWVzIHRvIHJ1biBjb21wdXRlZCBlZmZlY3RzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgZWFjaCBwYXNzIHVudGlsXG4gKiB0aGVyZSBhcmUgbm8gbW9yZSBuZXdseSBjb21wdXRlZCBwcm9wZXJ0aWVzLiAgVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAqIGNvbXB1dGVkIGJlZm9yZSBvdGhlciBlZmZlY3RzIChiaW5kaW5nIHByb3BhZ2F0aW9uLCBvYnNlcnZlcnMsIGFuZCBub3RpZnkpXG4gKiBydW4uXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7P09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQ29tcHV0ZWRFZmZlY3RzKGluc3QsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gIGxldCBjb21wdXRlRWZmZWN0cyA9IGluc3RbVFlQRVMuQ09NUFVURV07XG4gIGlmIChjb21wdXRlRWZmZWN0cykge1xuICAgIGlmIChvcmRlcmVkQ29tcHV0ZWQpIHtcbiAgICAgIC8vIFJ1bnMgY29tcHV0ZWQgZWZmZWN0cyBpbiBlZmZpY2llbnQgb3JkZXIgYnkga2VlcGluZyBhIHRvcG9sb2dpY2FsbHktXG4gICAgICAvLyBzb3J0ZWQgcXVldWUgb2YgY29tcHV0ZSBlZmZlY3RzIHRvIHJ1biwgYW5kIGluc2VydGluZyBzdWJzZXF1ZW50bHlcbiAgICAgIC8vIGludmFsaWRhdGVkIGVmZmVjdHMgYXMgdGhleSBhcmUgcnVuXG4gICAgICBkZWR1cGVJZCsrO1xuICAgICAgY29uc3Qgb3JkZXIgPSBnZXRDb21wdXRlZE9yZGVyKGluc3QpO1xuICAgICAgY29uc3QgcXVldWUgPSBbXTtcbiAgICAgIGZvciAobGV0IHAgaW4gY2hhbmdlZFByb3BzKSB7XG4gICAgICAgIGVucXVldWVFZmZlY3RzRm9yKHAsIGNvbXB1dGVFZmZlY3RzLCBxdWV1ZSwgb3JkZXIsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIGxldCBpbmZvO1xuICAgICAgd2hpbGUgKChpbmZvID0gcXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgaWYgKHJ1bkNvbXB1dGVkRWZmZWN0KGluc3QsICcnLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBpbmZvKSkge1xuICAgICAgICAgIGVucXVldWVFZmZlY3RzRm9yKGluZm8ubWV0aG9kSW5mbywgY29tcHV0ZUVmZmVjdHMsIHF1ZXVlLCBvcmRlciwgaGFzUGF0aHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKG9sZFByb3BzKSwgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgT2JqZWN0LmFzc2lnbigvKiogQHR5cGUgeyFPYmplY3R9ICovIChjaGFuZ2VkUHJvcHMpLCBpbnN0Ll9fZGF0YVBlbmRpbmcpO1xuICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3JpZ2luYWwgUG9seW1lciAyLnggY29tcHV0ZWQgZWZmZWN0cyBvcmRlciwgd2hpY2ggY29udGludWVzIHJ1bm5pbmdcbiAgICAgIC8vIGVmZmVjdHMgdW50aWwgbm8gZnVydGhlciBjb21wdXRlZCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBpbnZhbGlkYXRlZFxuICAgICAgbGV0IGlucHV0UHJvcHMgPSBjaGFuZ2VkUHJvcHM7XG4gICAgICB3aGlsZSAocnVuRWZmZWN0cyhpbnN0LCBjb21wdXRlRWZmZWN0cywgaW5wdXRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKG9sZFByb3BzKSwgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGNoYW5nZWRQcm9wcyksIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICAgIGlucHV0UHJvcHMgPSBpbnN0Ll9fZGF0YVBlbmRpbmc7XG4gICAgICAgIGluc3QuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5zZXJ0cyBhIGNvbXB1dGVkIGVmZmVjdCBpbnRvIGEgcXVldWUsIGdpdmVuIHRoZSBzcGVjaWZpZWQgb3JkZXIuIFBlcmZvcm1zXG4gKiB0aGUgaW5zZXJ0IHVzaW5nIGEgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBVc2VkIGJ5IGBvcmRlcmVkQ29tcHV0ZWQ6IHRydWVgIGNvbXB1dGVkIHByb3BlcnR5IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mbyBQcm9wZXJ0eSBlZmZlY3RzIG1ldGFkYXRhXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHF1ZXVlIE9yZGVyZWQgcXVldWUgb2YgZWZmZWN0c1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLG51bWJlcj59IG9yZGVyIE1hcCBvZiBjb21wdXRlZCBwcm9wZXJ0eSBuYW1lLT50b3BvbG9naWNhbFxuICogICBzb3J0IG9yZGVyXG4gKi9cbmNvbnN0IGluc2VydEVmZmVjdCA9IChpbmZvLCBxdWV1ZSwgb3JkZXIpID0+IHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gIGxldCBpZHggPSAtMTtcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIGNvbnN0IG1pZCA9IChzdGFydCArIGVuZCkgPj4gMTtcbiAgICAvLyBOb3RlIGBtZXRob2RJbmZvYCBpcyB3aGVyZSB0aGUgY29tcHV0ZWQgcHJvcGVydHkgbmFtZSBpcyBzdG9yZWQgaW5cbiAgICAvLyB0aGUgZWZmZWN0IG1ldGFkYXRhXG4gICAgY29uc3QgY21wID0gb3JkZXIuZ2V0KHF1ZXVlW21pZF0ubWV0aG9kSW5mbykgLSBvcmRlci5nZXQoaW5mby5tZXRob2RJbmZvKTtcbiAgICBpZiAoY21wIDwgMCkge1xuICAgICAgc3RhcnQgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWR4ID0gbWlkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpZHggPCAwKSB7XG4gICAgaWR4ID0gZW5kICsgMTtcbiAgfVxuICBxdWV1ZS5zcGxpY2UoaWR4LCAwLCBpbmZvKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhbGwgZG93bnN0cmVhbSBjb21wdXRlZCBlZmZlY3RzIGludmFsaWRhdGVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqIGludG8gdGhlIHRvcG9sb2dpY2FsbHktc29ydGVkIHF1ZXVlIG9mIGVmZmVjdHMgdG8gYmUgcnVuLlxuICpcbiAqIFVzZWQgYnkgYG9yZGVyZWRDb21wdXRlZDogdHJ1ZWAgY29tcHV0ZWQgcHJvcGVydHkgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wdXRlRWZmZWN0cyBDb21wdXRlZCBlZmZlY3RzIGZvciB0aGlzIGVsZW1lbnRcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcXVldWUgVG9wb2xvZ2ljYWxseS1zb3J0ZWQgcXVldWUgb2YgY29tcHV0ZWQgZWZmZWN0c1xuICogICB0byBiZSBydW5cbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxudW1iZXI+fSBvcmRlciBNYXAgb2YgY29tcHV0ZWQgcHJvcGVydHkgbmFtZS0+dG9wb2xvZ2ljYWxcbiAqICAgc29ydCBvcmRlclxuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYGNoYW5nZWRQcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqL1xuY29uc3QgZW5xdWV1ZUVmZmVjdHNGb3IgPSAocHJvcCwgY29tcHV0ZUVmZmVjdHMsIHF1ZXVlLCBvcmRlciwgaGFzUGF0aHMpID0+IHtcbiAgY29uc3Qgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyByb290KHByb3ApIDogcHJvcDtcbiAgY29uc3QgZnhzID0gY29tcHV0ZUVmZmVjdHNbcm9vdFByb3BlcnR5XTtcbiAgaWYgKGZ4cykge1xuICAgIGZvciAobGV0IGk9MDsgaTxmeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGZ4ID0gZnhzW2ldO1xuICAgICAgaWYgKChmeC5pbmZvLmxhc3RSdW4gIT09IGRlZHVwZUlkKSAmJlxuICAgICAgICAgICghaGFzUGF0aHMgfHwgcGF0aE1hdGNoZXNUcmlnZ2VyKHByb3AsIGZ4LnRyaWdnZXIpKSkge1xuICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgaW5zZXJ0RWZmZWN0KGZ4LmluZm8sIHF1ZXVlLCBvcmRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0cmlldmVzIGEgbWVtb2l6ZWQgbWFwIG9mIGNvbXB1dGVkIHByb3BlcnR5IG5hbWUgdG8gaXRzXG4gKiB0b3BvbG9naWNhbGx5LXNvcnRlZCBvcmRlci5cbiAqXG4gKiBUaGUgbWFwIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBhc3NpZ25pbmcgYSBcImRlcGVuZGVuY3kgY291bnRcIiB0byBlYWNoIHByb3BlcnR5XG4gKiAoZGVmaW5lZCBhcyBudW1iZXIgcHJvcGVydGllcyBpdCBkZXBlbmRzIG9uLCBpbmNsdWRpbmcgaXRzIG1ldGhvZCBmb3JcbiAqIFwiZHluYW1pYyBmdW5jdGlvbnNcIikuIEFueSBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBubyBkZXBlbmRlbmNpZXMgYXJlIGFkZGVkIHRvXG4gKiB0aGUgYHJlYWR5YCBxdWV1ZSwgd2hpY2ggYXJlIHByb3BlcnRpZXMgd2hvc2Ugb3JkZXIgY2FuIGJlIGFkZGVkIHRvIHRoZSBmaW5hbFxuICogb3JkZXIgbWFwLiBQcm9wZXJ0aWVzIGFyZSBwb3BwZWQgb2ZmIHRoZSBgcmVhZHlgIHF1ZXVlIG9uZSBieSBvbmUgYW5kIGEuKSBhZGRlZCBhc1xuICogdGhlIG5leHQgcHJvcGVydHkgaW4gdGhlIG9yZGVyIG1hcCwgYW5kIGIuKSBlYWNoIHByb3BlcnR5IHRoYXQgaXQgaXMgYVxuICogZGVwZW5kZW5jeSBmb3IgaGFzIGl0cyBkZXAgY291bnQgZGVjcmVtZW50ZWQgKGFuZCBpZiB0aGF0IHByb3BlcnR5J3MgZGVwXG4gKiBjb3VudCBnb2VzIHRvIHplcm8sIGl0IGlzIGFkZGVkIHRvIHRoZSBgcmVhZHlgIHF1ZXVlKSwgdW50aWwgYWxsIHByb3BlcnRpZXNcbiAqIGhhdmUgYmVlbiB2aXNpdGVkIGFuZCBvcmRlcmVkLlxuICpcbiAqIFVzZWQgYnkgYG9yZGVyZWRDb21wdXRlZDogdHJ1ZWAgY29tcHV0ZWQgcHJvcGVydHkgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB0byByZXRyaWV2ZSB0aGUgY29tcHV0ZWRcbiAqICAgZWZmZWN0IG9yZGVyIGZvci5cbiAqIEByZXR1cm4ge01hcDxzdHJpbmcsbnVtYmVyPn0gTWFwIG9mIGNvbXB1dGVkIHByb3BlcnR5IG5hbWUtPnRvcG9sb2dpY2FsIHNvcnRcbiAqICAgb3JkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRPcmRlcihpbnN0KSB7XG4gIGxldCBvcmRlcmVkID0gaW5zdC5jb25zdHJ1Y3Rvci5fX29yZGVyZWRDb21wdXRlZERlcHM7XG4gIGlmICghb3JkZXJlZCkge1xuICAgIG9yZGVyZWQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZWZmZWN0cyA9IGluc3RbVFlQRVMuQ09NUFVURV07XG4gICAgbGV0IHtjb3VudHMsIHJlYWR5LCB0b3RhbH0gPSBkZXBlbmRlbmN5Q291bnRzKGluc3QpO1xuICAgIGxldCBjdXJyO1xuICAgIHdoaWxlICgoY3VyciA9IHJlYWR5LnNoaWZ0KCkpKSB7XG4gICAgICBvcmRlcmVkLnNldChjdXJyLCBvcmRlcmVkLnNpemUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRCeUN1cnIgPSBlZmZlY3RzW2N1cnJdO1xuICAgICAgaWYgKGNvbXB1dGVkQnlDdXJyKSB7XG4gICAgICAgIGNvbXB1dGVkQnlDdXJyLmZvckVhY2goZnggPT4ge1xuICAgICAgICAgIC8vIE5vdGUgYG1ldGhvZEluZm9gIGlzIHdoZXJlIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBuYW1lIGlzIHN0b3JlZFxuICAgICAgICAgIGNvbnN0IGNvbXB1dGVkUHJvcCA9IGZ4LmluZm8ubWV0aG9kSW5mbztcbiAgICAgICAgICAtLXRvdGFsO1xuICAgICAgICAgIGlmICgtLWNvdW50c1tjb21wdXRlZFByb3BdID09PSAwKSB7XG4gICAgICAgICAgICByZWFkeS5wdXNoKGNvbXB1dGVkUHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRvdGFsICE9PSAwKSB7XG4gICAgICBjb25zdCBlbCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChpbnN0KTtcbiAgICAgIGNvbnNvbGUud2FybihgQ29tcHV0ZWQgZ3JhcGggZm9yICR7ZWwubG9jYWxOYW1lfSBpbmNvbXBsZXRlOyBjaXJjdWxhcj9gKTtcbiAgICB9XG4gICAgaW5zdC5jb25zdHJ1Y3Rvci5fX29yZGVyZWRDb21wdXRlZERlcHMgPSBvcmRlcmVkO1xuICB9XG4gIHJldHVybiBvcmRlcmVkO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG1hcCBvZiBwcm9wZXJ0eS10by1kZXBlbmRlbmN5IGNvdW50IChgY291bnRzYCwgd2hlcmUgXCJkZXBlbmRlbmN5XG4gKiBjb3VudFwiIGlzIHRoZSBudW1iZXIgb2YgZGVwZW5kZW5jaWVzIGEgZ2l2ZW4gcHJvcGVydHkgaGFzIGFzc3VtaW5nIGl0IGlzIGFcbiAqIGNvbXB1dGVkIHByb3BlcnR5LCBvdGhlcndpc2UgMCkuICBJdCBhbHNvIHJldHVybnMgYSBwcmUtcG9wdWxhdGVkIGxpc3Qgb2ZcbiAqIGByZWFkeWAgcHJvcGVydGllcyB0aGF0IGhhdmUgbm8gZGVwZW5kZW5jaWVzIGFuZCBhIGB0b3RhbGAgY291bnQsIHdoaWNoIGlzXG4gKiB1c2VkIGZvciBlcnJvci1jaGVja2luZyB0aGUgZ3JhcGguXG4gKlxuICogVXNlZCBieSBgb3JkZXJlZENvbXB1dGVkOiB0cnVlYCBjb21wdXRlZCBwcm9wZXJ0eSBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRvIGdlbmVyYXRlIGRlcGVuZGVuY3lcbiAqICAgY291bnRzIGZvci5cbiAqIEByZXR1cm4geyFPYmplY3R9IE9iamVjdCBjb250YWluaW5nIGBjb3VudHNgIG1hcCAocHJvcGVydHktdG8tZGVwZW5kZW5jeVxuICogICBjb3VudCkgYW5kIHByZS1wb3B1bGF0ZWQgYHJlYWR5YCBhcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgaGFkIHplcm9cbiAqICAgZGVwZW5kZW5jaWVzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRlbmN5Q291bnRzKGluc3QpIHtcbiAgY29uc3QgaW5mb0ZvckNvbXB1dGVkID0gaW5zdFtDT01QVVRFX0lORk9dO1xuICBjb25zdCBjb3VudHMgPSB7fTtcbiAgY29uc3QgY29tcHV0ZWREZXBzID0gaW5zdFtUWVBFUy5DT01QVVRFXTtcbiAgY29uc3QgcmVhZHkgPSBbXTtcbiAgbGV0IHRvdGFsID0gMDtcbiAgLy8gQ291bnQgZGVwZW5kZW5jaWVzIGZvciBlYWNoIGNvbXB1dGVkIHByb3BlcnR5XG4gIGZvciAobGV0IHAgaW4gaW5mb0ZvckNvbXB1dGVkKSB7XG4gICAgY29uc3QgaW5mbyA9IGluZm9Gb3JDb21wdXRlZFtwXTtcbiAgICAvLyBCZSBzdXJlIHRvIGFkZCB0aGUgbWV0aG9kIG5hbWUgaXRzZWxmIGluIGNhc2Ugb2YgXCJkeW5hbWljIGZ1bmN0aW9uc1wiXG4gICAgdG90YWwgKz0gY291bnRzW3BdID1cbiAgICAgIGluZm8uYXJncy5maWx0ZXIoYSA9PiAhYS5saXRlcmFsKS5sZW5ndGggKyAoaW5mby5keW5hbWljRm4gPyAxIDogMCk7XG4gIH1cbiAgLy8gQnVpbGQgbGlzdCBvZiByZWFkeSBwcm9wZXJ0aWVzICh0aGF0IGFyZW4ndCB0aGVtc2VsdmVzIGNvbXB1dGVkKVxuICBmb3IgKGxldCBwIGluIGNvbXB1dGVkRGVwcykge1xuICAgIGlmICghaW5mb0ZvckNvbXB1dGVkW3BdKSB7XG4gICAgICByZWFkeS5wdXNoKHApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2NvdW50cywgcmVhZHksIHRvdGFsfTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImNvbXB1dGVkIHByb3BlcnR5XCIgZWZmZWN0IGJ5IHJ1bm5pbmcgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICogcmV0dXJuIHZhbHVlIHRvIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0gez9PYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0gez9PYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHRoZSBwcm9wZXJ0eSBiZWluZyBjb21wdXRlZCBjaGFuZ2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAvLyBEaXJ0eSBjaGVjayBkZXBlbmRlbmNpZXMgYW5kIHJ1biBpZiBhbnkgaW52YWxpZFxuICBsZXQgcmVzdWx0ID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBpbmZvKTtcbiAgLy8gQWJvcnQgaWYgbWV0aG9kIHJldHVybnMgYSBuby1vcCByZXN1bHRcbiAgaWYgKHJlc3VsdCA9PT0gTk9PUCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY29tcHV0ZWRQcm9wID0gaW5mby5tZXRob2RJbmZvO1xuICBpZiAoaW5zdC5fX2RhdGFIYXNBY2Nlc3NvciAmJiBpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yW2NvbXB1dGVkUHJvcF0pIHtcbiAgICByZXR1cm4gaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KGNvbXB1dGVkUHJvcCwgcmVzdWx0LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0W2NvbXB1dGVkUHJvcF0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgcGF0aCBjaGFuZ2VzIGJhc2VkIG9uIHBhdGggbGlua3Mgc2V0IHVwIHVzaW5nIHRoZSBgbGlua1BhdGhzYFxuICogQVBJLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB3aG9zZSBwcm9wcyBhcmUgY2hhbmdpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBoYXMgY2hhbmdlZFxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiBjaGFuZ2VkIHBhdGhcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTGlua2VkUGF0aHMoaW5zdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IGxpbmtzID0gaW5zdC5fX2RhdGFMaW5rZWRQYXRocztcbiAgaWYgKGxpbmtzKSB7XG4gICAgbGV0IGxpbms7XG4gICAgZm9yIChsZXQgYSBpbiBsaW5rcykge1xuICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgIGlmIChpc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZXNjZW5kYW50KGIsIHBhdGgpKSB7XG4gICAgICAgIGxpbmsgPSB0cmFuc2xhdGUoYiwgYSwgcGF0aCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIC0tIGJpbmRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICogZm9yIGFsbCBwYXJ0IGRlcGVuZGVuY2llcyB0byBgdGVtcGxhdGVJbmZvYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgQmluZGluZyBraW5kLCBlaXRoZXIgJ3Byb3BlcnR5JywgJ2F0dHJpYnV0ZScsIG9yICd0ZXh0J1xuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUYXJnZXQgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGxpdGVyYWwgTGl0ZXJhbCB0ZXh0IHN1cnJvdW5kaW5nIGJpbmRpbmcgcGFydHMgKHNwZWNpZmllZFxuICogICBvbmx5IGZvciAncHJvcGVydHknIGJpbmRpbmdzLCBzaW5jZSB0aGVzZSBtdXN0IGJlIGluaXRpYWxpemVkIGFzIHBhcnRcbiAqICAgb2YgYm9vdC11cClcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRCaW5kaW5nKGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBraW5kLCB0YXJnZXQsIHBhcnRzLCBsaXRlcmFsKSB7XG4gIC8vIENyZWF0ZSBiaW5kaW5nIG1ldGFkYXRhIGFuZCBhZGQgdG8gbm9kZUluZm9cbiAgbm9kZUluZm8uYmluZGluZ3MgPSBub2RlSW5mby5iaW5kaW5ncyB8fCBbXTtcbiAgbGV0IC8qKiBCaW5kaW5nICovIGJpbmRpbmcgPSB7IGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwsIGlzQ29tcG91bmQ6IChwYXJ0cy5sZW5ndGggIT09IDEpIH07XG4gIG5vZGVJbmZvLmJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gIC8vIEFkZCBsaXN0ZW5lciBpbmZvIHRvIGJpbmRpbmcgbWV0YWRhdGFcbiAgaWYgKHNob3VsZEFkZExpc3RlbmVyKGJpbmRpbmcpKSB7XG4gICAgbGV0IHtldmVudCwgbmVnYXRlfSA9IGJpbmRpbmcucGFydHNbMF07XG4gICAgYmluZGluZy5saXN0ZW5lckV2ZW50ID0gZXZlbnQgfHwgKGNhbWVsVG9EYXNoQ2FzZSh0YXJnZXQpICsgJy1jaGFuZ2VkJyk7XG4gICAgYmluZGluZy5saXN0ZW5lck5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgfVxuICAvLyBBZGQgXCJwcm9wYWdhdGVcIiBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRlbXBsYXRlSW5mb1xuICBsZXQgaW5kZXggPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaT0wOyBpPGJpbmRpbmcucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcGFydCA9IGJpbmRpbmcucGFydHNbaV07XG4gICAgcGFydC5jb21wb3VuZEluZGV4ID0gaTtcbiAgICBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgdG8gdGhlIGdpdmVuIGB0ZW1wbGF0ZUluZm9gIGZvciB0aGUgZ2l2ZW4gYmluZGluZ1xuICogcGFydC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggaW50byBgbm9kZUluZm9MaXN0YCBmb3IgdGhpcyBub2RlXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5mdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICBpZiAoIXBhcnQubGl0ZXJhbCkge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09ICdhdHRyaWJ1dGUnICYmIGJpbmRpbmcudGFyZ2V0WzBdID09PSAnLScpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBzdGFydGluZyBjaGFyYWN0ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgbGV0IGluZm8gPSB7IGluZGV4LCBiaW5kaW5nLCBwYXJ0LCBldmFsdWF0b3I6IGNvbnN0cnVjdG9yIH07XG4gICAgICBmb3IgKGxldCBqPTA7IGo8ZGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gcGFyc2VBcmcodHJpZ2dlcik7XG4gICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IuX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCB0cmlnZ2VyLnJvb3RQcm9wZXJ0eSwge1xuICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgIGluZm8sIHRyaWdnZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJiaW5kaW5nXCIgKHByb3BlcnR5L3BhdGggYmluZGluZykgZWZmZWN0LlxuICpcbiAqIE5vdGUgdGhhdCBiaW5kaW5nIHN5bnRheCBpcyBvdmVycmlkYWJsZSB2aWEgYF9wYXJzZUJpbmRpbmdzYCBhbmRcbiAqIGBfZXZhbHVhdGVCaW5kaW5nYC4gIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgX2V2YWx1YXRlQmluZGluZ2AgZm9yIGFueVxuICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAqIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIF9wYXRoXyBiaW5kaW5ncyB2aWEgY3VzdG9tIGJpbmRpbmcgcGFydHMsXG4gKiBhcyB0aGlzIGlzIHNwZWNpZmljIHRvIFBvbHltZXIncyBwYXRoIGJpbmRpbmcgc3ludGF4LlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHBhcmFtIHtBcnJheX0gbm9kZUxpc3QgTGlzdCBvZiBub2RlcyBhc3NvY2lhdGVkIHdpdGggYG5vZGVJbmZvTGlzdGAgdGVtcGxhdGVcbiAqICAgbWV0YWRhdGFcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5CaW5kaW5nRWZmZWN0KGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMsIG5vZGVMaXN0KSB7XG4gIGxldCBub2RlID0gbm9kZUxpc3RbaW5mby5pbmRleF07XG4gIGxldCBiaW5kaW5nID0gaW5mby5iaW5kaW5nO1xuICBsZXQgcGFydCA9IGluZm8ucGFydDtcbiAgLy8gU3VicGF0aCBub3RpZmljYXRpb246IHRyYW5zZm9ybSBwYXRoIGFuZCBzZXQgdG8gY2xpZW50XG4gIC8vIGUuZy46IGZvbz1cInt7b2JqLnN1Yn19XCIsIHBhdGg6ICdvYmouc3ViLnByb3AnLCBzZXQgJ2Zvby5wcm9wJz1vYmouc3ViLnByb3BcbiAgaWYgKGhhc1BhdGhzICYmIHBhcnQuc291cmNlICYmIChwYXRoLmxlbmd0aCA+IHBhcnQuc291cmNlLmxlbmd0aCkgJiZcbiAgICAgIChiaW5kaW5nLmtpbmQgPT0gJ3Byb3BlcnR5JykgJiYgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgbm9kZS5fX2lzUHJvcGVydHlFZmZlY3RzQ2xpZW50ICYmXG4gICAgICBub2RlLl9fZGF0YUhhc0FjY2Vzc29yICYmIG5vZGUuX19kYXRhSGFzQWNjZXNzb3JbYmluZGluZy50YXJnZXRdKSB7XG4gICAgbGV0IHZhbHVlID0gcHJvcHNbcGF0aF07XG4gICAgcGF0aCA9IHRyYW5zbGF0ZShwYXJ0LnNvdXJjZSwgYmluZGluZy50YXJnZXQsIHBhdGgpO1xuICAgIGlmIChub2RlLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgaW5zdC5fZW5xdWV1ZUNsaWVudChub2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHZhbHVlID0gaW5mby5ldmFsdWF0b3IuX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAvLyBQcm9wYWdhdGUgdmFsdWUgdG8gY2hpbGRcbiAgICAvLyBBYm9ydCBpZiB2YWx1ZSBpcyBhIG5vLW9wIHJlc3VsdFxuICAgIGlmICh2YWx1ZSAhPT0gTk9PUCkge1xuICAgICAgYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhbiBcImJpbmRpbmdcIiAoYmluZGluZykgZWZmZWN0IHRvIGEgbm9kZSxcbiAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgaW5zdGFuY2Ugb3duaW5nIHRoZSBiaW5kaW5nIGVmZmVjdFxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRhcmdldCBub2RlIGZvciBiaW5kaW5nXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcHBseUJpbmRpbmdWYWx1ZShpbnN0LCBub2RlLCBiaW5kaW5nLCBwYXJ0LCB2YWx1ZSkge1xuICB2YWx1ZSA9IGNvbXB1dGVCaW5kaW5nVmFsdWUobm9kZSwgdmFsdWUsIGJpbmRpbmcsIHBhcnQpO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgYmluZGluZy50YXJnZXQsIGJpbmRpbmcua2luZCwgbm9kZSk7XG4gIH1cbiAgaWYgKGJpbmRpbmcua2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgaW5zdC5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyhub2RlKSwgdmFsdWUsIGJpbmRpbmcudGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9wZXJ0eSBiaW5kaW5nXG4gICAgbGV0IHByb3AgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBpZiAobm9kZS5fX2lzUHJvcGVydHlFZmZlY3RzQ2xpZW50ICYmXG4gICAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgaWYgKCFub2RlW1RZUEVTLlJFQURfT05MWV0gfHwgIW5vZGVbVFlQRVMuUkVBRF9PTkxZXVtwcm9wXSkge1xuICAgICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gbGVnYWN5IG5vLWJhdGNoaW5nIG1vZGUsIGJpbmRpbmdzIGFwcGxpZWQgYmVmb3JlIGRhdGFSZWFkeSBhcmVcbiAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhlIFwiYXBwbHkgY29uZmlnXCIgcGhhc2UsIHdoaWNoIG9ubHkgc2V0IG1hbmFnZWQgcHJvcHNcbiAgICAgIGluc3QuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gKiBlZmZlY3QgbWV0YWRhdGEsIGFzIHdlbGwgYXMgaGFuZGxpbmcgZm9yIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEByZXR1cm4geyp9IFRyYW5zZm9ybWVkIHZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCkge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgc3RvcmFnZVtwYXJ0LmNvbXBvdW5kSW5kZXhdID0gdmFsdWU7XG4gICAgdmFsdWUgPSBzdG9yYWdlLmpvaW4oJycpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgIT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZXJpYWxpemUgYHVuZGVmaW5lZGAgdG8gYFwidW5kZWZpbmVkXCJgXG4gICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgIChiaW5kaW5nLnRhcmdldCA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgIChub2RlLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyB8fCBub2RlLmxvY2FsTmFtZSA9PT0gJ3RleHRhcmVhJykpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBiaW5kaW5nJ3MgbWV0YWRhdGEgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgdG8gYWxsb3dcbiAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAqIGFkZGVkOlxuICogLSB1c2VkIGN1cmx5IGJyYWNlc1xuICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gKiAtIGlzIG5vdCBhIHRleHRDb250ZW50IGJpbmRpbmdcbiAqIC0gaXMgbm90IGNvbXBvdW5kXG4gKlxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIDItd2F5IGxpc3RlbmVyIHNob3VsZCBiZSBhZGRlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykge1xuICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgIGJpbmRpbmcua2luZCAhPSAnYXR0cmlidXRlJyAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICd0ZXh0JyAmJlxuICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgYmluZGluZy5wYXJ0c1swXS5tb2RlID09PSAneyc7XG59XG5cbi8qKlxuICogU2V0dXAgY29tcG91bmQgYmluZGluZyBzdG9yYWdlIHN0cnVjdHVyZXMsIG5vdGlmeSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdFxuICogcmVmZXJlbmNlcyBvbnRvIHRoZSBib3VuZCBub2RlTGlzdC5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBJbnN0YW5jZSB0aGF0IGJhcyBiZWVuIHByZXZpb3VzbHlcbiAqICAgICBib3VuZFxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwQmluZGluZ3MoaW5zdCwgdGVtcGxhdGVJbmZvKSB7XG4gIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIGRhdGFIb3N0LCBhbmQgbm90aWZ5IGxpc3RlbmVyc1xuICBsZXQge25vZGVMaXN0LCBub2RlSW5mb0xpc3R9ID0gdGVtcGxhdGVJbmZvO1xuICBpZiAobm9kZUluZm9MaXN0Lmxlbmd0aCkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVJbmZvTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGluZm8gPSBub2RlSW5mb0xpc3RbaV07XG4gICAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgICAgbGV0IGJpbmRpbmdzID0gaW5mby5iaW5kaW5ncztcbiAgICAgIGlmIChiaW5kaW5ncykge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgIHNldHVwQ29tcG91bmRTdG9yYWdlKG5vZGUsIGJpbmRpbmcpO1xuICAgICAgICAgIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGVuc3VyZXMgYWxsIGJvdW5kIGVsZW1lbnRzIGhhdmUgYSBob3N0IHNldCwgcmVnYXJkbGVzc1xuICAgICAgLy8gb2Ygd2hldGhlciB0aGV5IHVwZ3JhZGUgc3luY2hyb25vdXMgdG8gY3JlYXRpb25cbiAgICAgIG5vZGUuX19kYXRhSG9zdCA9IGluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYF9fZGF0YUNvbXBvdW5kU3RvcmFnZWAgbG9jYWwgc3RvcmFnZSBvbiBhIGJvdW5kIG5vZGUgd2l0aFxuICogaW5pdGlhbCBsaXRlcmFsIGRhdGEgZm9yIGNvbXBvdW5kIGJpbmRpbmdzLCBhbmQgc2V0cyB0aGUgam9pbmVkXG4gKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAqXG4gKiBXaGVuIGNoYW5nZXMgdG8gY29tcG91bmQgcGFydHMgb2NjdXIsIHRoZXkgYXJlIGZpcnN0IHNldCBpbnRvIHRoZSBjb21wb3VuZFxuICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAqIHRoZSBmaW5hbCB2YWx1ZSBzZXQgdG8gdGhlIHByb3BlcnR5L2F0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwQ29tcG91bmRTdG9yYWdlKG5vZGUsIGJpbmRpbmcpIHtcbiAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgIC8vIENyZWF0ZSBjb21wb3VuZCBzdG9yYWdlIG1hcFxuICAgIGxldCBzdG9yYWdlID0gbm9kZS5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgfHxcbiAgICAgIChub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHt9KTtcbiAgICBsZXQgcGFydHMgPSBiaW5kaW5nLnBhcnRzO1xuICAgIC8vIENvcHkgbGl0ZXJhbHMgZnJvbSBwYXJ0cyBpbnRvIHN0b3JhZ2UgZm9yIHRoaXMgYmluZGluZ1xuICAgIGxldCBsaXRlcmFscyA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGo9MDsgajxwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgbGl0ZXJhbHNbal0gPSBwYXJ0c1tqXS5saXRlcmFsO1xuICAgIH1cbiAgICBsZXQgdGFyZ2V0ID0gYmluZGluZy50YXJnZXQ7XG4gICAgc3RvcmFnZVt0YXJnZXRdID0gbGl0ZXJhbHM7XG4gICAgLy8gQ29uZmlndXJlIHByb3BlcnRpZXMgd2l0aCB0aGVpciBsaXRlcmFsIHBhcnRzXG4gICAgaWYgKGJpbmRpbmcubGl0ZXJhbCAmJiBiaW5kaW5nLmtpbmQgPT0gJ3Byb3BlcnR5Jykge1xuICAgICAgLy8gTm90ZSwgY2xhc3NOYW1lIG5lZWRzIHN0eWxlIHNjb3Bpbmcgc28gdGhpcyBuZWVkcyB3cmFwcGluZy5cbiAgICAgIC8vIFdlIG1heSBhbHNvIHdhbnQgdG8gY29uc2lkZXIgZG9pbmcgdGhpcyBmb3IgYHRleHRDb250ZW50YCBhbmRcbiAgICAgIC8vIGBpbm5lckhUTUxgLlxuICAgICAgaWYgKHRhcmdldCA9PT0gJ2NsYXNzTmFtZScpIHtcbiAgICAgICAgbm9kZSA9IHdyYXAobm9kZSk7XG4gICAgICB9XG4gICAgICBub2RlW3RhcmdldF0gPSBiaW5kaW5nLmxpdGVyYWw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIENoaWxkIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBIb3N0IGVsZW1lbnQgaW5zdGFuY2UgdG8gaGFuZGxlXG4gKiAgICAgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpIHtcbiAgaWYgKGJpbmRpbmcubGlzdGVuZXJFdmVudCkge1xuICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5saXN0ZW5lckV2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICBoYW5kbGVOb3RpZmljYXRpb24oZSwgaW5zdCwgYmluZGluZy50YXJnZXQsIHBhcnQuc291cmNlLCBwYXJ0Lm5lZ2F0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gLS0gZm9yIG1ldGhvZC1iYXNlZCBlZmZlY3RzIChjb21wbGV4T2JzZXJ2ZXIgJiBjb21wdXRlZCkgLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGVhY2ggYXJndW1lbnQgaW4gdGhlIG1ldGhvZCBzaWduYXR1cmUgKGFuZFxuICogb3B0aW9uYWxseSwgZm9yIHRoZSBtZXRob2QgbmFtZSBpZiBgZHluYW1pY2AgaXMgdHJ1ZSkgdGhhdCBjYWxscyB0aGVcbiAqIHByb3ZpZGVkIGVmZmVjdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHshTWV0aG9kU2lnbmF0dXJlfSBzaWcgTWV0aG9kIHNpZ25hdHVyZSBtZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBvZiBwcm9wZXJ0eSBlZmZlY3QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlZmZlY3RGbiBGdW5jdGlvbiB0byBydW4gd2hlbiBhcmd1bWVudHMgY2hhbmdlXG4gKiBAcGFyYW0geyo9fSBtZXRob2RJbmZvIEVmZmVjdC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBiZSBpbmNsdWRlZCBpblxuICogICBtZXRob2QgZWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nIHdoZXRoZXJcbiAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC4gTm90ZSxcbiAqICAgZGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIHN0YXRpYyAoc2lnLnN0YXRpYyBpcyB0cnVlKS5cbiAqIEByZXR1cm4geyFPYmplY3R9IEVmZmVjdCBtZXRhZGF0YSBmb3IgdGhpcyBtZXRob2QgZWZmZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXRob2RFZmZlY3QobW9kZWwsIHNpZywgdHlwZSwgZWZmZWN0Rm4sIG1ldGhvZEluZm8sIGR5bmFtaWNGbikge1xuICBkeW5hbWljRm4gPSBzaWcuc3RhdGljIHx8IChkeW5hbWljRm4gJiZcbiAgICAodHlwZW9mIGR5bmFtaWNGbiAhPT0gJ29iamVjdCcgfHwgZHluYW1pY0ZuW3NpZy5tZXRob2ROYW1lXSkpO1xuICBsZXQgaW5mbyA9IHtcbiAgICBtZXRob2ROYW1lOiBzaWcubWV0aG9kTmFtZSxcbiAgICBhcmdzOiBzaWcuYXJncyxcbiAgICBtZXRob2RJbmZvLFxuICAgIGR5bmFtaWNGblxuICB9O1xuICBmb3IgKGxldCBpPTAsIGFyZzsgKGk8c2lnLmFyZ3MubGVuZ3RoKSAmJiAoYXJnPXNpZy5hcmdzW2ldKTsgaSsrKSB7XG4gICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KGFyZy5yb290UHJvcGVydHksIHR5cGUsIHtcbiAgICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvLCB0cmlnZ2VyOiBhcmdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KHNpZy5tZXRob2ROYW1lLCB0eXBlLCB7XG4gICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm9cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyBtYXJzaGFsZWQgZnJvbSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZVxuICogYmFzZWQgb24gdGhlIG1ldGhvZCBzaWduYXR1cmUgY29udGFpbmVkIGluIHRoZSBlZmZlY3QgbWV0YWRhdGEuXG4gKlxuICogTXVsdGktcHJvcGVydHkgb2JzZXJ2ZXJzLCBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICogZnVuY3Rpb25zIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBpbnZva2UgdGhlIG1ldGhvZCwgdGhlbiB1c2UgdGhlIHJldHVyblxuICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIG1ldGhvZCBpbnZvY2F0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAvLyB0byBmaW5kIG1ldGhvZHMuIEN1cnJlbnRseSB1c2VkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgbGV0IGNvbnRleHQgPSBpbnN0Ll9tZXRob2RIb3N0IHx8IGluc3Q7XG4gIGxldCBmbiA9IGNvbnRleHRbaW5mby5tZXRob2ROYW1lXTtcbiAgaWYgKGZuKSB7XG4gICAgbGV0IGFyZ3MgPSBpbnN0Ll9tYXJzaGFsQXJncyhpbmZvLmFyZ3MsIHByb3BlcnR5LCBwcm9wcyk7XG4gICAgcmV0dXJuIGFyZ3MgPT09IE5PT1AgPyBOT09QIDogZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSBpZiAoIWluZm8uZHluYW1pY0ZuKSB7XG4gICAgY29uc29sZS53YXJuKCdtZXRob2QgYCcgKyBpbmZvLm1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICB9XG59XG5cbmNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuLy8gUmVndWxhciBleHByZXNzaW9ucyB1c2VkIGZvciBiaW5kaW5nXG5jb25zdCBJREVOVCAgPSAnKD86JyArICdbYS16QS1aXyRdW1xcXFx3LjokXFxcXC0qXSonICsgJyknO1xuY29uc3QgTlVNQkVSID0gJyg/OicgKyAnWy0rXT9bMC05XSpcXFxcLj9bMC05XSsoPzpbZUVdWy0rXT9bMC05XSspPycgKyAnKSc7XG5jb25zdCBTUVVPVEVfU1RSSU5HID0gJyg/OicgKyAnXFwnKD86W15cXCdcXFxcXFxcXF18XFxcXFxcXFwuKSpcXCcnICsgJyknO1xuY29uc3QgRFFVT1RFX1NUUklORyA9ICcoPzonICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXC4pKlwiJyArICcpJztcbmNvbnN0IFNUUklORyA9ICcoPzonICsgU1FVT1RFX1NUUklORyArICd8JyArIERRVU9URV9TVFJJTkcgKyAnKSc7XG5jb25zdCBBUkdVTUVOVCA9ICcoPzooJyArIElERU5UICsgJ3wnICsgTlVNQkVSICsgJ3wnICsgIFNUUklORyArICcpXFxcXHMqJyArICcpJztcbmNvbnN0IEFSR1VNRU5UUyA9ICcoPzonICsgQVJHVU1FTlQgKyAnKD86LFxcXFxzKicgKyBBUkdVTUVOVCArICcpKicgKyAnKSc7XG5jb25zdCBBUkdVTUVOVF9MSVNUID0gJyg/OicgKyAnXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgQVJHVU1FTlRTICsgJz8nICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxcXClcXFxccyonICsgJyknO1xuY29uc3QgQklORElORyA9ICcoJyArIElERU5UICsgJ1xcXFxzKicgKyBBUkdVTUVOVF9MSVNUICsgJz8nICsgJyknOyAvLyBHcm91cCAzXG5jb25zdCBPUEVOX0JSQUNLRVQgPSAnKFxcXFxbXFxcXFt8e3spJyArICdcXFxccyonO1xuY29uc3QgQ0xPU0VfQlJBQ0tFVCA9ICcoPzpdXXx9fSknO1xuY29uc3QgTkVHQVRFID0gJyg/OighKVxcXFxzKik/JzsgLy8gR3JvdXAgMlxuY29uc3QgRVhQUkVTU0lPTiA9IE9QRU5fQlJBQ0tFVCArIE5FR0FURSArIEJJTkRJTkcgKyBDTE9TRV9CUkFDS0VUO1xuY29uc3QgYmluZGluZ1JlZ2V4ID0gbmV3IFJlZ0V4cChFWFBSRVNTSU9OLCBcImdcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RyaW5nIGZyb20gYmluZGluZyBwYXJ0cyBvZiBhbGwgdGhlIGxpdGVyYWwgcGFydHNcbiAqXG4gKiBAcGFyYW0geyFBcnJheTxCaW5kaW5nUGFydD59IHBhcnRzIEFsbCBwYXJ0cyB0byBzdHJpbmdpZnlcbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIG1hZGUgZnJvbSB0aGUgbGl0ZXJhbCBwYXJ0c1xuICovXG5mdW5jdGlvbiBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB7XG4gIGxldCBzID0gJyc7XG4gIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBsaXRlcmFsID0gcGFydHNbaV0ubGl0ZXJhbDtcbiAgICBzICs9IGxpdGVyYWwgfHwgJyc7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGV4cHJlc3Npb24gc3RyaW5nIGZvciBhIG1ldGhvZCBzaWduYXR1cmUsIGFuZCByZXR1cm5zIGEgbWV0YWRhdGFcbiAqIGRlc2NyaWJpbmcgdGhlIG1ldGhvZCBpbiB0ZXJtcyBvZiBgbWV0aG9kTmFtZWAsIGBzdGF0aWNgICh3aGV0aGVyIGFsbCB0aGVcbiAqIGFyZ3VtZW50cyBhcmUgbGl0ZXJhbHMpLCBhbmQgYW4gYXJyYXkgb2YgYGFyZ3NgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gdG8gcGFyc2VcbiAqIEByZXR1cm4gez9NZXRob2RTaWduYXR1cmV9IFRoZSBtZXRob2QgbWV0YWRhdGEgb2JqZWN0IGlmIGEgbWV0aG9kIGV4cHJlc3Npb24gd2FzXG4gKiAgIGZvdW5kLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pIHtcbiAgLy8gdHJpZXMgdG8gbWF0Y2ggdmFsaWQgamF2YXNjcmlwdCBwcm9wZXJ0eSBuYW1lc1xuICBsZXQgbSA9IGV4cHJlc3Npb24ubWF0Y2goLyhbXlxcc10rPylcXCgoW1xcc1xcU10qKVxcKS8pO1xuICBpZiAobSkge1xuICAgIGxldCBtZXRob2ROYW1lID0gbVsxXTtcbiAgICBsZXQgc2lnID0geyBtZXRob2ROYW1lLCBzdGF0aWM6IHRydWUsIGFyZ3M6IGVtcHR5QXJyYXkgfTtcbiAgICBpZiAobVsyXS50cmltKCkpIHtcbiAgICAgIC8vIHJlcGxhY2UgZXNjYXBlZCBjb21tYXMgd2l0aCBjb21tYSBlbnRpdHksIHNwbGl0IG9uIHVuLWVzY2FwZWQgY29tbWFzXG4gICAgICBsZXQgYXJncyA9IG1bMl0ucmVwbGFjZSgvXFxcXCwvZywgJyZjb21tYTsnKS5zcGxpdCgnLCcpO1xuICAgICAgcmV0dXJuIHBhcnNlQXJncyhhcmdzLCBzaWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGFuZCBzZXRzIHRoZSBgYXJnc2AgcHJvcGVydHkgb2YgdGhlIHN1cHBsaWVkXG4gKiBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0LiBTZXRzIHRoZSBgc3RhdGljYCBwcm9wZXJ0eSB0byBmYWxzZSBpZiBhbnlcbiAqIGFyZ3VtZW50IGlzIGEgbm9uLWxpdGVyYWwuXG4gKlxuICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXJnTGlzdCBBcnJheSBvZiBhcmd1bWVudCBuYW1lc1xuICogQHBhcmFtIHshTWV0aG9kU2lnbmF0dXJlfSBzaWcgTWV0aG9kIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3RcbiAqIEByZXR1cm4geyFNZXRob2RTaWduYXR1cmV9IFRoZSB1cGRhdGVkIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJncyhhcmdMaXN0LCBzaWcpIHtcbiAgc2lnLmFyZ3MgPSBhcmdMaXN0Lm1hcChmdW5jdGlvbihyYXdBcmcpIHtcbiAgICBsZXQgYXJnID0gcGFyc2VBcmcocmF3QXJnKTtcbiAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICBzaWcuc3RhdGljID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG4gIH0sIHRoaXMpO1xuICByZXR1cm4gc2lnO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBpbmRpdmlkdWFsIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhbiBhcmd1bWVudCBtZXRhZGF0YSBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gKlxuICogICB7XG4gKiAgICAgdmFsdWU6ICdwcm9wJywgICAgICAgIC8vIHByb3BlcnR5L3BhdGggb3IgbGl0ZXJhbCB2YWx1ZVxuICogICAgIGxpdGVyYWw6IGZhbHNlLCAgICAgICAvLyB3aGV0aGVyIGFyZ3VtZW50IGlzIGEgbGl0ZXJhbFxuICogICAgIHN0cnVjdHVyZWQ6IGZhbHNlLCAgICAvLyB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBpcyBhIHBhdGhcbiAqICAgICByb290UHJvcGVydHk6ICdwcm9wJywgLy8gdGhlIHJvb3QgcHJvcGVydHkgb2YgdGhlIHBhdGhcbiAqICAgICB3aWxkY2FyZDogZmFsc2UgICAgICAgLy8gd2hldGhlciB0aGUgYXJndW1lbnQgd2FzIGEgd2lsZGNhcmQgJy4qJyBwYXRoXG4gKiAgIH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3QXJnIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcmV0dXJuIHshTWV0aG9kQXJnfSBBcmd1bWVudCBtZXRhZGF0YSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJnKHJhd0FyZykge1xuICAvLyBjbGVhbiB1cCB3aGl0ZXNwYWNlXG4gIGxldCBhcmcgPSByYXdBcmcudHJpbSgpXG4gICAgLy8gcmVwbGFjZSBjb21tYSBlbnRpdHkgd2l0aCBjb21tYVxuICAgIC5yZXBsYWNlKC8mY29tbWE7L2csICcsJylcbiAgICAvLyByZXBhaXIgZXh0cmEgZXNjYXBlIHNlcXVlbmNlczsgbm90ZSBvbmx5IGNvbW1hcyBzdHJpY3RseSBuZWVkXG4gICAgLy8gZXNjYXBpbmcsIGJ1dCB3ZSBhbGxvdyBhbnkgb3RoZXIgY2hhciB0byBiZSBlc2NhcGVkIHNpbmNlIGl0c1xuICAgIC8vIGxpa2VseSB1c2VycyB3aWxsIGRvIHRoaXNcbiAgICAucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKVxuICAgIDtcbiAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICBsZXQgYSA9IHtcbiAgICBuYW1lOiBhcmcsXG4gICAgdmFsdWU6ICcnLFxuICAgIGxpdGVyYWw6IGZhbHNlXG4gIH07XG4gIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gIGxldCBmYyA9IGFyZ1swXTtcbiAgaWYgKGZjID09PSAnLScpIHtcbiAgICBmYyA9IGFyZ1sxXTtcbiAgfVxuICBpZiAoZmMgPj0gJzAnICYmIGZjIDw9ICc5Jykge1xuICAgIGZjID0gJyMnO1xuICB9XG4gIHN3aXRjaChmYykge1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOlxuICAgICAgYS52YWx1ZSA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gaWYgbm90IGxpdGVyYWwsIGxvb2sgZm9yIHN0cnVjdHVyZWQgcGF0aFxuICBpZiAoIWEubGl0ZXJhbCkge1xuICAgIGEucm9vdFByb3BlcnR5ID0gcm9vdChhcmcpO1xuICAgIC8vIGRldGVjdCBzdHJ1Y3R1cmVkIHBhdGggKGhhcyBkb3RzKVxuICAgIGEuc3RydWN0dXJlZCA9IGlzUGF0aChhcmcpO1xuICAgIGlmIChhLnN0cnVjdHVyZWQpIHtcbiAgICAgIGEud2lsZGNhcmQgPSAoYXJnLnNsaWNlKC0yKSA9PSAnLionKTtcbiAgICAgIGlmIChhLndpbGRjYXJkKSB7XG4gICAgICAgIGEubmFtZSA9IGFyZy5zbGljZSgwLCAtMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBnZXRBcmdWYWx1ZShkYXRhLCBwcm9wcywgcGF0aCkge1xuICBsZXQgdmFsdWUgPSBnZXQoZGF0YSwgcGF0aCk7XG4gIC8vIHdoZW4gZGF0YSBpcyBub3Qgc3RvcmVkIGUuZy4gYHNwbGljZXNgLCBnZXQgdGhlIHZhbHVlIGZyb20gY2hhbmdlZFByb3BzXG4gIC8vIFRPRE8oa3NjaGFhZik6IE5vdGUsIHRoaXMgY2FuIGNhdXNlIGEgcmFyZSBpc3N1ZSB3aGVyZSB0aGUgd2lsZGNhcmRcbiAgLy8gaW5mby52YWx1ZSBjb3VsZCBwdWxsIGEgc3RhbGUgdmFsdWUgb3V0IG9mIGNoYW5nZWRQcm9wcyBkdXJpbmcgYSByZWVudHJhbnRcbiAgLy8gY2hhbmdlIHRoYXQgc2V0cyB0aGUgdmFsdWUgYmFjayB0byB1bmRlZmluZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvaXNzdWVzLzU0NzlcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IHByb3BzW3BhdGhdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gZGF0YSBhcGlcblxuLyoqXG4gKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICpcbiAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3Jkc1xuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIHNwbGljZXMpIHtcbiAgY29uc3Qgc3BsaWNlc0RhdGEgPSB7IGluZGV4U3BsaWNlczogc3BsaWNlcyB9O1xuICAvLyBMZWdhY3kgYmVoYXZpb3Igc3RvcmVkIHNwbGljZXMgaW4gYF9fZGF0YV9fYCBzbyBpdCB3YXMgKm5vdCogZXBoZW1lcmFsLlxuICAvLyBUbyBtYXRjaCB0aGlzIGJlaGF2aW9yLCB3ZSBzdG9yZSBzcGxpY2VzIGRpcmVjdGx5IG9uIHRoZSBhcnJheS5cbiAgaWYgKGxlZ2FjeVVuZGVmaW5lZCAmJiAhaW5zdC5fb3ZlcnJpZGVMZWdhY3lVbmRlZmluZWQpIHtcbiAgICBhcnJheS5zcGxpY2VzID0gc3BsaWNlc0RhdGE7XG4gIH1cbiAgaW5zdC5ub3RpZnlQYXRoKHBhdGggKyAnLnNwbGljZXMnLCBzcGxpY2VzRGF0YSk7XG4gIGluc3Qubm90aWZ5UGF0aChwYXRoICsgJy5sZW5ndGgnLCBhcnJheS5sZW5ndGgpO1xuICAvLyBDbGVhciBzcGxpY2UgZGF0YSBvbmx5IHdoZW4gaXQncyBzdG9yZWQgb24gdGhlIGFycmF5LlxuICBpZiAobGVnYWN5VW5kZWZpbmVkICYmICFpbnN0Ll9vdmVycmlkZUxlZ2FjeVVuZGVmaW5lZCkge1xuICAgIHNwbGljZXNEYXRhLmluZGV4U3BsaWNlcyA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNwbGljZSByZWNvcmQgYW5kIHNlbmRzIGFuIGFycmF5IHNwbGljZSBub3RpZmljYXRpb24gZm9yXG4gKiB0aGUgZGVzY3JpYmVkIG11dGF0aW9uXG4gKlxuICogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgbm9ybWFsaXplZCBwYXRoc1xuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdGhlIGFycmF5IG11dGF0aW9uIG9jY3VycmVkXG4gKiBAcGFyYW0ge251bWJlcn0gYWRkZWRDb3VudCBOdW1iZXIgb2YgYWRkZWQgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZWQgQXJyYXkgb2YgcmVtb3ZlZCBpdGVtc1xuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZShpbnN0LCBhcnJheSwgcGF0aCwgaW5kZXgsIGFkZGVkQ291bnQsIHJlbW92ZWQpIHtcbiAgbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgW3tcbiAgICBpbmRleDogaW5kZXgsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIG9iamVjdDogYXJyYXksXG4gICAgdHlwZTogJ3NwbGljZSdcbiAgfV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXItY2FzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN0cmluZyB0byB1cHBlcmNhc2VcbiAqIEByZXR1cm4ge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwcGVyKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBtZXRhLXByb2dyYW1taW5nIGZvciBQb2x5bWVyJ3MgdGVtcGxhdGVcbiAqIGJpbmRpbmcgYW5kIGRhdGEgb2JzZXJ2YXRpb24gKGNvbGxlY3RpdmVseSwgXCJwcm9wZXJ0eSBlZmZlY3RzXCIpIHN5c3RlbS5cbiAqXG4gKiBUaGlzIG1peGluIHVzZXMgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBrZXkgc3RhdGljIG1ldGhvZHMgZm9yIGFkZGluZ1xuICogcHJvcGVydHkgZWZmZWN0cyB0byBhbiBlbGVtZW50IGNsYXNzOlxuICogLSBgYWRkUHJvcGVydHlFZmZlY3RgXG4gKiAtIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYFxuICogLSBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgXG4gKiAtIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWBcbiAqIC0gYGNyZWF0ZVJlYWRPbmx5UHJvcGVydHlgXG4gKiAtIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWBcbiAqIC0gYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgXG4gKiAtIGBiaW5kVGVtcGxhdGVgXG4gKlxuICogRWFjaCBtZXRob2QgY3JlYXRlcyBvbmUgb3IgbW9yZSBwcm9wZXJ0eSBhY2Nlc3NvcnMsIGFsb25nIHdpdGggbWV0YWRhdGFcbiAqIHVzZWQgYnkgdGhpcyBtaXhpbidzIGltcGxlbWVudGF0aW9uIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHRvIHBlcmZvcm1cbiAqIHRoZSBwcm9wZXJ0eSBlZmZlY3RzLlxuICpcbiAqIFVuZGVyc2NvcmVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSBtZXRob2RzIGFsc28gZXhpc3Qgb24gdGhlIGVsZW1lbnRcbiAqIHByb3RvdHlwZSBmb3IgYWRkaW5nIHByb3BlcnR5IGVmZmVjdHMgb24gaW5zdGFuY2VzIGF0IHJ1bnRpbWUuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbWl4aW4gb3ZlcnJpZGVzIHNldmVyYWwgYFByb3BlcnR5QWNjZXNzb3JzYCBtZXRob2RzLCBpblxuICogbWFueSBjYXNlcyB0byBtYWludGFpbiBndWFyYW50ZWVzIHByb3ZpZGVkIGJ5IHRoZSBQb2x5bWVyIDEueCBmZWF0dXJlcztcbiAqIG5vdGFibHkgaXQgY2hhbmdlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgdG8gYmUgc3luY2hyb25vdXMgYnkgZGVmYXVsdFxuICogd2hlcmVhcyB0aGUgZGVmYXVsdCB3aGVuIHVzaW5nIGBQcm9wZXJ0eUFjY2Vzc29yc2Agc3RhbmRhbG9uZSBpcyB0byBiZVxuICogYXN5bmMgYnkgZGVmYXVsdC5cbiAqXG4gKiBAbWl4aW5GdW5jdGlvblxuICogQHBvbHltZXJcbiAqIEBhcHBsaWVzTWl4aW4gVGVtcGxhdGVTdGFtcFxuICogQGFwcGxpZXNNaXhpbiBQcm9wZXJ0eUFjY2Vzc29yc1xuICogQHN1bW1hcnkgRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIFBvbHltZXInc1xuICogdGVtcGxhdGUgYmluZGluZyBhbmQgZGF0YSBvYnNlcnZhdGlvbiBzeXN0ZW0uXG4gKi9cbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUVmZmVjdHMgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0IHByb3BlcnR5RWZmZWN0c0Jhc2UgPSBUZW1wbGF0ZVN0YW1wKFByb3BlcnR5QWNjZXNzb3JzKHN1cGVyQ2xhc3MpKTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgKiBAZXh0ZW5kcyB7cHJvcGVydHlFZmZlY3RzQmFzZX1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgUHJvcGVydHlFZmZlY3RzIGV4dGVuZHMgcHJvcGVydHlFZmZlY3RzQmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAvLyBVc2VkIHRvIGlkZW50aWZ5IHVzZXJzIG9mIHRoaXMgbWl4aW4sIGFsYSBpbnN0YW5jZW9mXG4gICAgICB0aGlzLl9faXNQcm9wZXJ0eUVmZmVjdHNDbGllbnQgPSB0cnVlO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHk7XG4gICAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeTtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocztcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlO1xuICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cbiAgICAgIHRoaXMuX19kYXRhSG9zdDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhVGVtcDtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGE7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R8bnVsbH0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fY29tcHV0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19jb21wdXRlSW5mbztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlZmxlY3RFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3Byb3BhZ2F0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19vYnNlcnZlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqL1xuICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyaWRlTGVnYWN5VW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICByZXR1cm4gVFlQRVM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdCgpO1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgIC8vIE1heSBiZSBzZXQgb24gaW5zdGFuY2UgcHJpb3IgdG8gdXBncmFkZVxuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gdGhpcy5fX2RhdGFIb3N0IHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVySG9zdCgpIHtcbiAgICAgIGlmIChob3N0U3RhY2subGVuZ3RoKSB7XG4gICAgICAgIGxldCBob3N0ID0gaG9zdFN0YWNrW2hvc3RTdGFjay5sZW5ndGgtMV07XG4gICAgICAgIGhvc3QuX2VucXVldWVDbGllbnQodGhpcyk7XG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBldmVuIG5vbi1ib3VuZCBlbGVtZW50cyBoYXZlIGEgaG9zdCBzZXQsIGFzXG4gICAgICAgIC8vIGxvbmcgYXMgdGhleSB1cGdyYWRlIHN5bmNocm9ub3VzbHlcbiAgICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gaG9zdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgKiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBpbml0aWFsaXppbmcgcHJvcGVydGllcyBmcm9tXG4gICAgICogdGhlIHByb3RvdHlwZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICB0aGlzLl9fZGF0YSA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIHNldHRpbmdcbiAgICAgKiBgX3NldFByb3BlcnR5YCdzIGBzaG91bGROb3RpZnk6IHRydWVgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBsZXQgcmVhZE9ubHkgPSB0aGlzW1RZUEVTLlJFQURfT05MWV07XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIGlmICghcmVhZE9ubHkgfHwgIXJlYWRPbmx5W3Byb3BdKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gdGhpcy5fX2RhdGFQZW5kaW5nIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0gdGhpcy5fX2RhdGFPbGQgfHwge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcF0gPSB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3RvdHlwZSBzZXR1cCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYWRkUHJvcGVydHlFZmZlY3RgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgdHlwZSA9PSBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgLy8gZWZmZWN0cyBhcmUgYWNjdW11bGF0ZWQgaW50byBhcnJheXMgcGVyIHByb3BlcnR5IGJhc2VkIG9uIHR5cGVcbiAgICAgIGxldCBlZmZlY3RzID0gZW5zdXJlT3duRWZmZWN0TWFwKHRoaXMsIHR5cGUsIHRydWUpW3Byb3BlcnR5XTtcbiAgICAgIGlmICghZWZmZWN0cykge1xuICAgICAgICBlZmZlY3RzID0gdGhpc1t0eXBlXVtwcm9wZXJ0eV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIHByb3BlcnR5IGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGUgZWZmZWN0IHdhcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3QgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfcmVtb3ZlUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSwgdHJ1ZSlbcHJvcGVydHldO1xuICAgICAgbGV0IGlkeCA9IGVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBwcm9wZXJ0eSBlZmZlY3RcbiAgICAgKiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpc1xuICAgICAqICAgICB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3R5cGVdO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0cyAmJiBlZmZlY3RzW3Byb3BlcnR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlYWQgb25seVwiXG4gICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpc1xuICAgICAqICAgICB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJub3RpZnlcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzXG4gICAgICogICAgIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc05vdGlmeUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvXG4gICAgICogYXR0cmlidXRlXCIgcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXNcbiAgICAgKiAgICAgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUmVmbGVjdEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwiY29tcHV0ZWRcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzXG4gICAgICogICAgIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLkNPTVBVVEUpO1xuICAgIH1cblxuICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHBlbmRpbmcgcHJvcGVydHkgb3IgcGF0aC4gIElmIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoIGluXG4gICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAqIHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICogZm9yIHRoZSBwdWJsaWMgQVBJIChgc2V0YCwgYHNldFByb3BlcnRpZXNgLCBgbm90aWZ5UGF0aGAsIGFuZCBwcm9wZXJ0eVxuICAgICAqIGNoYW5nZSBsaXN0ZW5lcnMgdmlhIHt7Li4ufX0gYmluZGluZ3MpLCBzdWNoIHRoYXQgaXQgaXMgb25seSBkb25lXG4gICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAqIGFsc28gc2V0cyBhIGBfX2RhdGFIYXNQYXRoc2AgZmxhZyBvbiB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCB0b1xuICAgICAqIGZhc3QtcGF0aCBzbG93ZXIgcGF0aC1tYXRjaGluZyBjb2RlIGluIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIGhvc3QgcGF0aHMuXG4gICAgICpcbiAgICAgKiBgcGF0aGAgY2FuIGJlIGEgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2YgcGF0aCBwYXJ0cyBhcyBhY2NlcHRlZCBieSB0aGVcbiAgICAgKiBwdWJsaWMgQVBJLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgKiAgY2F1c2UgYSBwcm9wZXJ0eSBub3RpZmljYXRpb24gZXZlbnQgZGlzcGF0Y2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1BhdGhOb3RpZmljYXRpb24gSWYgdGhlIHBhdGggYmVpbmcgc2V0IGlzIGEgcGF0aFxuICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgKiAgIHRvIHNldCBhbmQgbm90aWZ5IHRoZSBjaGFuZ2UuICBJbiB0aGUgbGF0dGVyIGBmYWxzZWAgY2FzZSwgYSBkaXJ0eVxuICAgICAqICAgY2hlY2sgaXMgcGVyZm9ybWVkIGFuZCB0aGVuIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHBhdGggYmVmb3JlXG4gICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkvcGF0aCB3YXMgZW5xdWV1ZWQgaW5cbiAgICAgKiAgIHRoZSBwZW5kaW5nIGNoYW5nZXMgYmFnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBzaG91bGROb3RpZnksIGlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgIHJvb3QoQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGhbMF0gOiBwYXRoKSAhPT0gcGF0aCkge1xuICAgICAgICAvLyBEaXJ0eSBjaGVjayBjaGFuZ2VzIGJlaW5nIHNldCB0byBhIHBhdGggYWdhaW5zdCB0aGUgYWN0dWFsIG9iamVjdCxcbiAgICAgICAgLy8gc2luY2UgdGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHBhdGhzIGludG8gdGhlIHN5c3RlbTsgZnJvbSBoZXJlXG4gICAgICAgIC8vIHRoZSBvbmx5IGRpcnR5IGNoZWNrcyBhcmUgYWdhaW5zdCB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gZHVwbGljYXRlIHdvcmsgaW4gdGhlIHNhbWUgdHVybiBvbmx5LiBOb3RlLCBpZiB0aGlzIHdhcyBhIG5vdGlmaWNhdGlvblxuICAgICAgICAvLyBvZiBhIGNoYW5nZSBhbHJlYWR5IHNldCB0byBhIHBhdGggKGlzUGF0aE5vdGlmaWNhdGlvbjogdHJ1ZSksXG4gICAgICAgIC8vIHdlIGFsd2F5cyBsZXQgdGhlIGNoYW5nZSB0aHJvdWdoIGFuZCBza2lwIHRoZSBgc2V0YCBzaW5jZSBpdCB3YXNcbiAgICAgICAgLy8gYWxyZWFkeSBkaXJ0eSBjaGVja2VkIGF0IHRoZSBwb2ludCBvZiBlbnRyeSBhbmQgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gb2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICBpZiAoIWlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgICAgIGxldCBvbGQgPSBnZXQodGhpcywgcGF0aCk7XG4gICAgICAgICAgcGF0aCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc2V0KHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgLy8gVXNlIHByb3BlcnR5LWFjY2Vzc29yJ3Mgc2ltcGxlciBkaXJ0eSBjaGVja1xuICAgICAgICAgIGlmICghcGF0aCB8fCAhc3VwZXIuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHBhdGgsIHZhbHVlLCBvbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSkpIHtcbiAgICAgICAgICBjb21wdXRlTGlua2VkUGF0aHModGhpcywgLyoqQHR5cGV7c3RyaW5nfSovIChwYXRoKSwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG1ha2VzIGEgYmVzdC1lZmZvcnQgYXQgYmluZGluZyBpbnRlcm9wOlxuICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICogcmUtc2V0dGluZyB0aGUgc2FtZSB2YWx1ZSAoZS5nLiBzZXR0aW5nIGA8aW5wdXQ+LnZhbHVlYCByZXNldHMgdGhlXG4gICAgICogY3Vyc29yIHBvc2l0aW9uKSwgc28gd2UgZG8gYSBkaXJ0eS1jaGVjayBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUuXG4gICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgKiBhY2NlcHQgb2JqZWN0cywgd2UgZXhwbGljaXRseSByZS1zZXQgb2JqZWN0IGNoYW5nZXMgY29taW5nIGZyb20gdGhlXG4gICAgICogUG9seW1lciB3b3JsZCAod2hpY2ggbWF5IGluY2x1ZGUgZGVlcCBvYmplY3QgY2hhbmdlcyB3aXRob3V0IHRoZVxuICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBzZXQgYSBwcm9wZXJ0eSBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIC8vIEl0IGlzIGEganVkZ21lbnQgY2FsbCB0aGF0IHJlc2V0dGluZyBwcmltaXRpdmVzIGlzXG4gICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgLy8gaW1wbGVtZW50IGEgd2hpdGVsaXN0IG9mIHRhZyAmIHByb3BlcnR5IHZhbHVlcyB0aGF0IHNob3VsZCBuZXZlclxuICAgICAgLy8gYmUgcmVzZXQgKGUuZy4gPGlucHV0Pi52YWx1ZSAmJiA8c2VsZWN0Pi52YWx1ZSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm90ZSwgY2xhc3NOYW1lIG5lZWRzIHN0eWxlIHNjb3Bpbmcgc28gdGhpcyBuZWVkcyB3cmFwcGluZy5cbiAgICAgICAgaWYgKHByb3AgPT09ICdjbGFzc05hbWUnKSB7XG4gICAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7IU5vZGV9ICovKHdyYXAobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBQcm9wZXJ0aWVzQ2hhbmdlZGAgaW1wbGVtZW50YXRpb24gdG8gaW50cm9kdWNlIHNwZWNpYWxcbiAgICAgKiBkaXJ0eSBjaGVjayBsb2dpYyBkZXBlbmRpbmcgb24gdGhlIHByb3BlcnR5ICYgdmFsdWUgYmVpbmcgc2V0OlxuICAgICAqXG4gICAgICogMS4gQW55IHZhbHVlIHNldCB0byBhIHBhdGggKGUuZy4gJ29iai5wcm9wJzogNDIgb3IgJ29iai5wcm9wJzogey4uLn0pXG4gICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFUZW1wYFxuICAgICAqIDIuIE9iamVjdCBzZXQgdG8gc2ltcGxlIHByb3BlcnR5IChlLmcuICdwcm9wJzogey4uLn0pXG4gICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCBhbmQgYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdFxuICAgICAqICAgIGBfX2RhdGFUZW1wYCBieSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBfc2hvdWxkUHJvcGVydHlDaGFuZ2VgXG4gICAgICogMy4gUHJpbWl0aXZlIHZhbHVlIHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiA0MilcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBgX19kYXRhYFxuICAgICAqXG4gICAgICogVGhlIGRpcnR5LWNoZWNrIGlzIGltcG9ydGFudCB0byBwcmV2ZW50IGN5Y2xlcyBkdWUgdG8gdHdvLXdheVxuICAgICAqIG5vdGlmaWNhdGlvbiwgYnV0IHBhdGhzIGFuZCBvYmplY3RzIGFyZSBvbmx5IGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBhbnlcbiAgICAgKiBwcmV2aW91cyB2YWx1ZSBzZXQgZHVyaW5nIHRoaXMgdHVybiB2aWEgYSBcInRlbXBvcmFyeSBjYWNoZVwiIHRoYXQgaXNcbiAgICAgKiBjbGVhcmVkIHdoZW4gdGhlIGxhc3QgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgZXhpdHMuIFRoaXMgaXMgc286XG4gICAgICogYS4gYW55IGNhY2hlZCBhcnJheSBwYXRocyAoZS5nLiAnYXJyYXkuMy5wcm9wJykgbWF5IGJlIGludmFsaWRhdGVkXG4gICAgICogICAgZHVlIHRvIGFycmF5IG11dGF0aW9ucyBsaWtlIHNoaWZ0L3Vuc2hpZnQvc3BsaWNlOyB0aGlzIGlzIGZpbmVcbiAgICAgKiAgICBzaW5jZSBwYXRoIGNoYW5nZXMgYXJlIGRpcnR5LWNoZWNrZWQgYXQgdXNlciBlbnRyeSBwb2ludHMgbGlrZSBgc2V0YFxuICAgICAqIGIuIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIG9ubHkgbGFzdHMgb25lIHR1cm4gdG8gYWxsb3cgdGhlIHVzZXJcbiAgICAgKiAgICB0byBtdXRhdGUgdGhlIG9iamVjdCBpbi1wbGFjZSBhbmQgcmUtc2V0IGl0IHdpdGggdGhlIHNhbWUgaWRlbnRpdHlcbiAgICAgKiAgICBhbmQgaGF2ZSBhbGwgc3ViLXByb3BlcnRpZXMgcmUtcHJvcGFnYXRlZCBpbiBhIHN1YnNlcXVlbnQgdHVybi5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wIGNhY2hlIGlzIG5vdCBuZWNlc3NhcmlseSBzdWZmaWNpZW50IHRvIHByZXZlbnQgaW52YWxpZCBhcnJheVxuICAgICAqIHBhdGhzLCBzaW5jZSBhIHNwbGljZSBjYW4gaGFwcGVuIGR1cmluZyB0aGUgc2FtZSB0dXJuICh3aXRoIHBhdGhvbG9naWNhbFxuICAgICAqIHVzZXIgY29kZSk7IHdlIGNvdWxkIGludHJvZHVjZSBhIFwiZml4dXBcIiBmb3IgdGVtcG9yYXJpbHkgY2FjaGVkIGFycmF5XG4gICAgICogcGF0aHMgaWYgbmVlZGVkOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyL2lzc3Vlcy80MjI3XG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBUcnVlIGlmIHByb3BlcnR5IHNob3VsZCBmaXJlIG5vdGlmaWNhdGlvblxuICAgICAqICAgZXZlbnQgKGFwcGxpZXMgb25seSBmb3IgYG5vdGlmeTogdHJ1ZWAgcHJvcGVydGllcylcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSB7XG4gICAgICBsZXQgcHJvcElzUGF0aCA9IHRoaXMuX19kYXRhSGFzUGF0aHMgJiYgaXNQYXRoKHByb3BlcnR5KTtcbiAgICAgIGxldCBwcmV2UHJvcHMgPSBwcm9wSXNQYXRoID8gdGhpcy5fX2RhdGFUZW1wIDogdGhpcy5fX2RhdGE7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBwcmV2UHJvcHNbcHJvcGVydHldKSkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIG9sZCBpcyBjYXB0dXJlZCBmcm9tIHRoZSBsYXN0IHR1cm5cbiAgICAgICAgaWYgKCEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGRbcHJvcGVydHldID0gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhdGhzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZiB0dXJuKSxcbiAgICAgICAgLy8gd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmcsIGFsbCBvdGhlcnMgc3RvcmVkIGluIF9fZGF0YVxuICAgICAgICBpZiAocHJvcElzUGF0aCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgY2hhbmdlcyBnbyBpbnRvIHBlbmRpbmcgcHJvcGVydHkgYmFnLCBwYXNzZWQgdG8gX3Byb3BlcnRpZXNDaGFuZ2VkXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgLy8gVHJhY2sgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3RpZnkgc2VwYXJhdGVseVxuICAgICAgICBpZiAocHJvcElzUGF0aCB8fCAodGhpc1tUWVBFUy5OT1RJRlldICYmIHRoaXNbVFlQRVMuTk9USUZZXVtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IHRoaXMuX19kYXRhVG9Ob3RpZnkgfHwge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeVtwcm9wZXJ0eV0gPSBzaG91bGROb3RpZnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIGFsbCBhY2Nlc3NvcnMgc2V0IGBzaG91bGROb3RpZnlgXG4gICAgICogdG8gdHJ1ZSwgZm9yIHBlci1wcm9wZXJ0eSBub3RpZmljYXRpb24gdHJhY2tpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yYCdzIGRlZmF1bHQgYXN5bmMgcXVldWluZyBvZlxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgOiBpZiBgX19kYXRhUmVhZHlgIGlzIGZhbHNlIChoYXMgbm90IHlldCBiZWVuXG4gICAgICogbWFudWFsbHkgZmx1c2hlZCksIHRoZSBmdW5jdGlvbiBuby1vcHM7IG90aGVyd2lzZSBmbHVzaGVzXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgc3luY2hyb25vdXNseS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZXMgdGhlIGdpdmVuIGNsaWVudCBvbiBhIGxpc3Qgb2YgcGVuZGluZyBjbGllbnRzLCB3aG9zZVxuICAgICAqIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlcyBjYW4gbGF0ZXIgYmUgZmx1c2hlZCB2aWEgYSBjYWxsIHRvXG4gICAgICogYF9mbHVzaENsaWVudHNgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsaWVudCBQcm9wZXJ0eUVmZmVjdHMgY2xpZW50IHRvIGVucXVldWVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzIHx8IFtdO1xuICAgICAgaWYgKGNsaWVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFueSBjbGllbnRzIHByZXZpb3VzbHkgZW5xdWV1ZWQgdmlhIGBfZW5xdWV1ZUNsaWVudGAsIGNhdXNpbmdcbiAgICAgKiB0aGVpciBgX2ZsdXNoUHJvcGVydGllc2AgbWV0aG9kIHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9mbHVzaENsaWVudHMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVhZHlDbGllbnRzKCk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IHdoZXJlIGFjY2Vzc29ycyBhcmUgdHVybmVkIG9uOyBpbXBvcnRhbnRseSxcbiAgICAgICAgLy8gdGhpcyBpcyBhZnRlciBjbGllbnRzIGhhdmUgZnVsbHkgcmVhZGllZCwgcHJvdmlkaW5nIGEgZ3VhcmFudGVlXG4gICAgICAgIC8vIHRoYXQgYW55IHByb3BlcnR5IGVmZmVjdHMgb2NjdXIgb25seSBhZnRlciBhbGwgY2xpZW50cyBhcmUgcmVhZHkuXG4gICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogV2UgZW5zdXJlIGNsaWVudHMgZWl0aGVyIGVuYWJsZSBvciBmbHVzaCBhcyBhcHByb3ByaWF0ZS4gVGhpc1xuICAgIC8vIGhhbmRsZXMgdHdvIGNvcm5lciBjYXNlczpcbiAgICAvLyAoMSkgY2xpZW50cyBmbHVzaCBwcm9wZXJseSB3aGVuIGNvbm5lY3RlZC9lbmFibGVkIGJlZm9yZSB0aGUgaG9zdFxuICAgIC8vIGVuYWJsZXM7IGUuZy5cbiAgICAvLyAgIChhKSBUZW1wbGF0aXplIHN0YW1wcyB3aXRoIG5vIHByb3BlcnRpZXMgYW5kIGRvZXMgbm90IGZsdXNoIGFuZFxuICAgIC8vICAgKGIpIHRoZSBpbnN0YW5jZSBpcyBpbnNlcnRlZCBpbnRvIGRvbSBhbmRcbiAgICAvLyAgIChjKSB0aGVuIHRoZSBpbnN0YW5jZSBmbHVzaGVzLlxuICAgIC8vICgyKSBjbGllbnRzIGVuYWJsZSBwcm9wZXJseSB3aGVuIG5vdCBjb25uZWN0ZWQvZW5hYmxlZCB3aGVuIHRoZSBob3N0XG4gICAgLy8gZmx1c2hlczsgZS5nLlxuICAgIC8vICAgKGEpIGEgdGVtcGxhdGUgaXMgcnVudGltZSBzdGFtcGVkIGFuZCBub3QgeWV0IGNvbm5lY3RlZC9lbmFibGVkXG4gICAgLy8gICAoYikgYSBob3N0IHNldHMgYSBwcm9wZXJ0eSwgY2F1c2luZyBzdGFtcGVkIGRvbSB0byBmbHVzaFxuICAgIC8vICAgKGMpIHRoZSBzdGFtcGVkIGRvbSBlbmFibGVzLlxuICAgIF9fZW5hYmxlT3JGbHVzaENsaWVudHMoKSB7XG4gICAgICBsZXQgY2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICBpZiAoY2xpZW50cykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBjbGllbnQgPSBjbGllbnRzW2ldO1xuICAgICAgICAgIGlmICghY2xpZW50Ll9fZGF0YUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNsaWVudC5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpZW50Ll9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNsaWVudC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbnkgaW5pdGlhbCBzZXR1cCBvbiBjbGllbnQgZG9tLiBDYWxsZWQgYmVmb3JlIHRoZSBmaXJzdFxuICAgICAqIGBfZmx1c2hQcm9wZXJ0aWVzYCBjYWxsIG9uIGNsaWVudCBkb20gYW5kIGJlZm9yZSBhbnkgZWxlbWVudFxuICAgICAqIG9ic2VydmVycyBhcmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBiYWcgb2YgcHJvcGVydHkgY2hhbmdlcyB0byB0aGlzIGluc3RhbmNlLCBhbmRcbiAgICAgKiBzeW5jaHJvbm91c2x5IHByb2Nlc3NlcyBhbGwgZWZmZWN0cyBvZiB0aGUgcHJvcGVydGllcyBhcyBhIGJhdGNoLlxuICAgICAqXG4gICAgICogUHJvcGVydHkgbmFtZXMgbXVzdCBiZSBzaW1wbGUgcHJvcGVydGllcywgbm90IHBhdGhzLiAgQmF0Y2hlZFxuICAgICAqIHBhdGggcHJvcGFnYXRpb24gaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2Ygb25lIG9yIG1vcmUga2V5LXZhbHVlIHBhaXJzIHdob3NlIGtleSBpc1xuICAgICAqICAgYSBwcm9wZXJ0eSBhbmQgdmFsdWUgaXMgdGhlIG5ldyB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gc2V0UmVhZE9ubHkgV2hlbiB0cnVlLCBhbnkgcHJpdmF0ZSB2YWx1ZXMgc2V0IGluXG4gICAgICogICBgcHJvcHNgIHdpbGwgYmUgc2V0LiBCeSBkZWZhdWx0LCBgc2V0UHJvcGVydGllc2Agd2lsbCBub3Qgc2V0XG4gICAgICogICBgcmVhZE9ubHk6IHRydWVgIHJvb3QgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKHByb3BzLCBzZXRSZWFkT25seSkge1xuICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2V0UmVhZE9ubHkgfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldW3BhdGhdKSB7XG4gICAgICAgICAgLy9UT0RPKGtzY2hhYWYpOiBleHBsaWNpdGx5IGRpc2FsbG93IHBhdGhzIGluIHNldFByb3BlcnR5P1xuICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAvLyBpbiB0aGUgYGluZm9gIG9iamVjdCwgYW5kIHlvdSBjb3VsZCBkbyBzb21lIG9kZCB0aGluZ3MgYmF0Y2hpbmdcbiAgICAgICAgICAvLyBwYXRocywgZS5nLiB7J2Zvby5iYXInOiB7Li4ufSwgJ2Zvbyc6IG51bGx9XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICogc2lkZSBlZmZlY3RzIGFyZSBub3QgZW5hYmxlZCB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGZ1bGx5IHJlYWR5LlxuICAgICAqIEFsc28gY2FsbHMgYF9mbHVzaENsaWVudHNgIGNhbGxiYWNrIHRvIGVuc3VyZSBjbGllbnQgZG9tIGlzIGVuYWJsZWRcbiAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0aGF0IGBzdXBlci5yZWFkeSgpYCBpcyBub3QgY2FsbGVkIGhlcmUgYXMgaXRcbiAgICAgIC8vIGltbWVkaWF0ZWx5IHR1cm5zIG9uIGFjY2Vzc29ycy4gSW5zdGVhZCwgd2Ugd2FpdCB1bnRpbCBgcmVhZHlDbGllbnRzYFxuICAgICAgLy8gdG8gZW5hYmxlIGFjY2Vzc29ycyB0byBwcm92aWRlIGEgZ3VhcmFudGVlIHRoYXQgY2xpZW50cyBhcmUgcmVhZHlcbiAgICAgIC8vIGJlZm9yZSBwcm9jZXNzaW5nIGFueSBhY2Nlc3NvcnMgc2lkZSBlZmZlY3RzLlxuICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAvLyBJZiBubyBkYXRhIHdhcyBwZW5kaW5nLCBgX2ZsdXNoUHJvcGVydGllc2Agd2lsbCBub3QgYGZsdXNoQ2xpZW50c2BcbiAgICAgIC8vIHNvIGVuc3VyZSB0aGlzIGlzIGRvbmUuXG4gICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgICAgLy8gQmVmb3JlIHJlYWR5LCBjbGllbnQgbm90aWZpY2F0aW9ucyBkbyBub3QgdHJpZ2dlciBfZmx1c2hQcm9wZXJ0aWVzLlxuICAgICAgLy8gVGhlcmVmb3JlIGEgZmx1c2ggaXMgbmVjZXNzYXJ5IGhlcmUgaWYgZGF0YSBoYXMgYmVlbiBzZXQuXG4gICAgICBpZiAodGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5QWNjZXNzb3JzYCdzIHByb3BlcnRpZXMgY2hhbmdlZCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFJ1bnMgZWFjaCBjbGFzcyBvZiBlZmZlY3RzIGZvciB0aGUgYmF0Y2ggb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIGluXG4gICAgICogYSBzcGVjaWZpYyBvcmRlciAoY29tcHV0ZSwgcHJvcGFnYXRlLCByZWZsZWN0LCBvYnNlcnZlLCBub3RpZnkpLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjdXJyZW50UHJvcHMgQmFnIG9mIGFsbCBjdXJyZW50IGFjY2Vzc29yIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7P09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3RcbiAgICAgKiAgIGNhbGwgdG8gYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgKiAgIGluIGBjaGFuZ2VkUHJvcHNgXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBsZXQgYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoYW5nZWRQcm9wcyB8fCB7fSk7XG4gICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAvLyBpZiAod2luZG93LmRlYnVnKSB7IGRlYnVnZ2VyOyB9XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBsZXQgaGFzUGF0aHMgPSB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgbGV0IG5vdGlmeVByb3BzO1xuICAgICAgLy8gQ29tcHV0ZSBwcm9wZXJ0aWVzXG4gICAgICBydW5Db21wdXRlZEVmZmVjdHModGhpcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gQ2xlYXIgbm90aWZ5IHByb3BlcnRpZXMgcHJpb3IgdG8gcG9zc2libGUgcmVlbnRyeSAocHJvcGFnYXRlLCBvYnNlcnZlKSxcbiAgICAgIC8vIGJ1dCBhZnRlciBjb21wdXRpbmcgZWZmZWN0cyBoYXZlIGEgY2hhbmNlIHRvIGFkZCB0byB0aGVtXG4gICAgICBub3RpZnlQcm9wcyA9IHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIC8vIFByb3BhZ2F0ZSBwcm9wZXJ0aWVzIHRvIGNsaWVudHNcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIC8vIFJlZmxlY3QgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBPYnNlcnZlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5PQlNFUlZFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgaWYgKG5vdGlmeVByb3BzKSB7XG4gICAgICAgIHJ1bk5vdGlmeUVmZmVjdHModGhpcywgbm90aWZ5UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIHRlbXBvcmFyeSBjYWNoZSBhdCBlbmQgb2YgdHVyblxuICAgICAgaWYgKHRoaXMuX19kYXRhQ291bnRlciA9PSAxKSB7XG4gICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwcm9wYWdhdGUgYW55IHByb3BlcnR5IGNoYW5nZXMgdG8gc3RhbXBlZCB0ZW1wbGF0ZSBub2Rlc1xuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzKGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBpZiAodGhpc1tUWVBFUy5QUk9QQUdBVEVdKSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5QUk9QQUdBVEVdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX3RlbXBsYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9ydW5FZmZlY3RzRm9yVGVtcGxhdGUodGhpcy5fX3RlbXBsYXRlSW5mbywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9ydW5FZmZlY3RzRm9yVGVtcGxhdGUodGVtcGxhdGVJbmZvLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgY29uc3QgYmFzZVJ1bkVmZmVjdHMgPSAoY2hhbmdlZFByb3BzLCBoYXNQYXRocykgPT4ge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsXG4gICAgICAgICAgaGFzUGF0aHMsIHRlbXBsYXRlSW5mby5ub2RlTGlzdCk7XG4gICAgICAgIGZvciAobGV0IGluZm89dGVtcGxhdGVJbmZvLmZpcnN0Q2hpbGQ7IGluZm87IGluZm89aW5mby5uZXh0U2libGluZykge1xuICAgICAgICAgIHRoaXMuX3J1bkVmZmVjdHNGb3JUZW1wbGF0ZShpbmZvLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodGVtcGxhdGVJbmZvLnJ1bkVmZmVjdHMpIHtcbiAgICAgICAgdGVtcGxhdGVJbmZvLnJ1bkVmZmVjdHMoYmFzZVJ1bkVmZmVjdHMsIGNoYW5nZWRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZVJ1bkVmZmVjdHMoY2hhbmdlZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgKiBhcmUgcm91dGVkIHRvIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBmcm9tIFNvdXJjZSBwYXRoIHRvIGxpbmsuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbGlua1BhdGhzKHRvLCBmcm9tKSB7XG4gICAgICB0byA9IG5vcm1hbGl6ZSh0byk7XG4gICAgICBmcm9tID0gbm9ybWFsaXplKGZyb20pO1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHRoaXMuX19kYXRhTGlua2VkUGF0aHMgfHwge307XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzW3RvXSA9IGZyb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGRhdGEgcGF0aCBhbGlhcyBwcmV2aW91c2x5IGVzdGFibGlzaGVkIHdpdGggYF9saW5rUGF0aHNgLlxuICAgICAqXG4gICAgICogTm90ZSwgdGhlIHBhdGggdG8gdW5saW5rIHNob3VsZCBiZSB0aGUgdGFyZ2V0IChgdG9gKSB1c2VkIHdoZW5cbiAgICAgKiBsaW5raW5nIHRoZSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFRhcmdldCBwYXRoIHRvIHVubGluay5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bmxpbmtQYXRocyhwYXRoKSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplKHBhdGgpO1xuICAgICAgaWYgKHRoaXMuX19kYXRhTGlua2VkUGF0aHMpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX19kYXRhTGlua2VkUGF0aHNbcGF0aF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYW4gYXJyYXkgaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIHRoaXMuaXRlbXMgPSBbIHtuYW1lOiAnSmltJ30sIHtuYW1lOiAnVG9kZCd9LCB7bmFtZTogJ0JpbGwnfSBdO1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgICAgdGhpcy5pdGVtcy5zcGxpY2UoMSwgMSwge25hbWU6ICdTYW0nfSk7XG4gICAgICogICAgIHRoaXMuaXRlbXMucHVzaCh7bmFtZTogJ0JvYid9KTtcbiAgICAgKiAgICAgdGhpcy5ub3RpZnlTcGxpY2VzKCdpdGVtcycsIFtcbiAgICAgKiAgICAgICB7IGluZGV4OiAxLCByZW1vdmVkOiBbe25hbWU6ICdUb2RkJ31dLCBhZGRlZENvdW50OiAxLFxuICAgICAqICAgICAgICAgb2JqZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJyB9LFxuICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLFxuICAgICAqICAgICAgICAgb2JqZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJ31cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNwbGljZXMgQXJyYXkgb2Ygc3BsaWNlIHJlY29yZHMgaW5kaWNhdGluZyBvcmRlcmVkXG4gICAgICogICBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgdG8gdGhlIGFycmF5LiBFYWNoIHJlY29yZCBzaG91bGQgaGF2ZSB0aGVcbiAgICAgKiAgIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICogICAgKiBpbmRleDogaW5kZXggYXQgd2hpY2ggdGhlIGNoYW5nZSBvY2N1cnJlZFxuICAgICAqICAgICogcmVtb3ZlZDogYXJyYXkgb2YgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGlzIGluZGV4XG4gICAgICogICAgKiBhZGRlZENvdW50OiBudW1iZXIgb2YgbmV3IGl0ZW1zIGFkZGVkIGF0IHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIG9iamVjdDogYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5IGluIHF1ZXN0aW9uXG4gICAgICogICAgKiB0eXBlOiB0aGUgc3RyaW5nIGxpdGVyYWwgJ3NwbGljZSdcbiAgICAgKlxuICAgICAqICAgTm90ZSB0aGF0IHNwbGljZSByZWNvcmRzIF9tdXN0XyBiZSBub3JtYWxpemVkIHN1Y2ggdGhhdCB0aGV5IGFyZVxuICAgICAqICAgcmVwb3J0ZWQgaW4gaW5kZXggb3JkZXIgKHJhdyByZXN1bHRzIGZyb20gYE9iamVjdC5vYnNlcnZlYCBhcmUgbm90XG4gICAgICogICBvcmRlcmVkIGFuZCBtdXN0IGJlIG5vcm1hbGl6ZWQvbWVyZ2VkIGJlZm9yZSBub3RpZnlpbmcpLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbm90aWZ5U3BsaWNlcyh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzcGxpY2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHJlYWRpbmcgYSB2YWx1ZSBmcm9tIGEgcGF0aC5cbiAgICAgKlxuICAgICAqIE5vdGUsIGlmIGFueSBwYXJ0IGluIHRoZSBwYXRoIGlzIHVuZGVmaW5lZCwgdGhpcyBtZXRob2QgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgICh0aGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyB3aGVuIGRlcmVmZXJlbmNpbmcgdW5kZWZpbmVkXG4gICAgICogcGF0aHMpLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfCFBcnJheTwoc3RyaW5nfG51bWJlcik+KX0gcGF0aCBQYXRoIHRvIHRoZSB2YWx1ZVxuICAgICAqICAgdG8gcmVhZC4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYGZvby5iYXIuYmF6YClcbiAgICAgKiAgIG9yIGFuIGFycmF5IG9mIHBhdGggcGFydHMgKGUuZy4gYFsnZm9vLmJhcicsICdiYXonXWApLiAgTm90ZSB0aGF0XG4gICAgICogICBicmFja2V0ZWQgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQ7IHN0cmluZy1iYXNlZCBwYXRoIHBhcnRzXG4gICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICogICBpbmRpY2VzLCB0aGUgaW5kZXggbWF5IGJlIHVzZWQgYXMgYSBkb3R0ZWQgcGFydCBkaXJlY3RseVxuICAgICAqICAgKGUuZy4gYHVzZXJzLjEyLm5hbWVgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICogQHJldHVybiB7Kn0gVmFsdWUgYXQgdGhlIHBhdGgsIG9yIGB1bmRlZmluZWRgIGlmIGFueSBwYXJ0IG9mIHRoZSBwYXRoXG4gICAgICogICBpcyB1bmRlZmluZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldChwYXRoLCByb290KSB7XG4gICAgICByZXR1cm4gZ2V0KHJvb3QgfHwgdGhpcywgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBzZXR0aW5nIGEgdmFsdWUgdG8gYSBwYXRoIGFuZCBub3RpZnlpbmcgYW55XG4gICAgICogZWxlbWVudHMgYm91bmQgdG8gdGhlIHNhbWUgcGF0aC5cbiAgICAgKlxuICAgICAqIE5vdGUsIGlmIGFueSBwYXJ0IGluIHRoZSBwYXRoIGV4Y2VwdCBmb3IgdGhlIGxhc3QgaXMgdW5kZWZpbmVkLFxuICAgICAqIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlblxuICAgICAqIGRlcmVmZXJlbmNpbmcgdW5kZWZpbmVkIHBhdGhzKS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgKiAgIHRvIHdyaXRlLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgJ2Zvby5iYXIuYmF6J2ApXG4gICAgICogICBvciBhbiBhcnJheSBvZiBwYXRoIHBhcnRzIChlLmcuIGBbJ2Zvby5iYXInLCAnYmF6J11gKS4gIE5vdGUgdGhhdFxuICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAqICAgKm11c3QqIGJlIHNlcGFyYXRlZCBieSBkb3RzLiAgTm90ZSB0aGF0IHdoZW4gZGVyZWZlcmVuY2luZyBhcnJheVxuICAgICAqICAgaW5kaWNlcywgdGhlIGluZGV4IG1heSBiZSB1c2VkIGFzIGEgZG90dGVkIHBhcnQgZGlyZWN0bHlcbiAgICAgKiAgIChlLmcuIGAndXNlcnMuMTIubmFtZSdgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSByb290IFJvb3Qgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHBhdGggaXMgZXZhbHVhdGVkLlxuICAgICAqICAgV2hlbiBzcGVjaWZpZWQsIG5vIG5vdGlmaWNhdGlvbiB3aWxsIG9jY3VyLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldChwYXRoLCB2YWx1ZSwgcm9vdCkge1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgc2V0KHJvb3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgZW5kIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBwdXNoIG9udG8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSovKGdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnB1c2goLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgbGVuLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGVuZCBvZiBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnBvcGAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHBvcChwYXRoKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5wb3AoKTtcbiAgICAgIGlmIChoYWRMZW5ndGgpIHtcbiAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGFycmF5Lmxlbmd0aCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydGluZyBmcm9tIHRoZSBzdGFydCBpbmRleCBzcGVjaWZpZWQsIHJlbW92ZXMgMCBvciBtb3JlIGl0ZW1zXG4gICAgICogZnJvbSB0aGUgYXJyYXkgYW5kIGluc2VydHMgMCBvciBtb3JlIG5ldyBpdGVtcyBpbiB0aGVpciBwbGFjZS5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBJbmRleCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nL2luc2VydGluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGV0ZUNvdW50IE51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXl9IEFycmF5IG9mIHJlbW92ZWQgaXRlbXMuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNwbGljZShwYXRoLCBzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoIDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIC8vIE5vcm1hbGl6ZSBmYW5jeSBuYXRpdmUgc3BsaWNlIGhhbmRsaW5nIG9mIGNyYXp5IHN0YXJ0IHZhbHVlc1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IGFycmF5Lmxlbmd0aCAtIE1hdGguZmxvb3IoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIGFycmF5LnNwbGljZSBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIG51bWJlciBvZiBhcmd1bWVudHNcbiAgICAgIC8vIHlvdSBwYXNzIGluLiBUaGVyZWZvcmUsIGFycmF5LnNwbGljZSgwKSBhbmQgYXJyYXkuc3BsaWNlKDAsIHVuZGVmaW5lZClcbiAgICAgIC8vIGRvIGRpZmZlcmVudCB0aGluZ3MuIEluIHRoZSBmb3JtZXIsIHRoZSB3aG9sZSBhcnJheSBpcyBjbGVhcmVkLiBJbiB0aGVcbiAgICAgIC8vIGxhdHRlciwgbm8gaXRlbXMgYXJlIHJlbW92ZWQuXG4gICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgd2UgbmVlZCB0byBkZXRlY3Qgd2hldGhlciAxLiBvbmUgb2YgdGhlIGFyZ3VtZW50c1xuICAgICAgLy8gaXMgYWN0dWFsbHkgcGFzc2VkIGluIGFuZCB0aGVuIDIuIGRldGVybWluZSBob3cgbWFueSBhcmd1bWVudHNcbiAgICAgIC8vIHdlIHNob3VsZCBwYXNzIG9uIHRvIHRoZSBuYXRpdmUgYXJyYXkuc3BsaWNlXG4gICAgICAvL1xuICAgICAgbGV0IHJldDtcbiAgICAgIC8vIE9taXQgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGlmIHRoZXkgd2VyZSBub3QgcGFzc2VkIGluXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXQgPSBhcnJheS5zcGxpY2Uoc3RhcnQpO1xuICAgICAgLy8gRWl0aGVyIHN0YXJ0IHdhcyB1bmRlZmluZWQgYW5kIHRoZSBvdGhlcnMgd2VyZSBkZWZpbmVkLCBidXQgaW4gdGhpc1xuICAgICAgLy8gY2FzZSB3ZSBjYW4gc2FmZWx5IHBhc3Mgb24gYWxsIGFyZ3VtZW50c1xuICAgICAgLy9cbiAgICAgIC8vIE5vdGU6IHRoaXMgaW5jbHVkZXMgdGhlIGNhc2Ugd2hlcmUgbm9uZSBvZiB0aGUgYXJndW1lbnRzIHdlcmUgcGFzc2VkIGluLFxuICAgICAgLy8gZS5nLiB0aGlzLnNwbGljZSgnYXJyYXknKS4gSG93ZXZlciwgaWYgYm90aCBzdGFydCBhbmQgZGVsZXRlQ291bnRcbiAgICAgIC8vIGFyZSB1bmRlZmluZWQsIGFycmF5LnNwbGljZSB3aWxsIG5vdCBtb2RpZnkgdGhlIGFycmF5IChhcyBleHBlY3RlZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKTtcbiAgICAgIH1cbiAgICAgIC8vIEF0IHRoZSBlbmQsIGNoZWNrIHdoZXRoZXIgYW55IGl0ZW1zIHdlcmUgcGFzc2VkIGluIChlLmcuIGluc2VydGlvbnMpXG4gICAgICAvLyBvciBpZiB0aGUgcmV0dXJuIGFycmF5IGNvbnRhaW5zIGl0ZW1zIChlLmcuIGRlbGV0aW9ucykuXG4gICAgICAvLyBPbmx5IG5vdGlmeSBpZiBpdGVtcyB3ZXJlIGFkZGVkIG9yIGRlbGV0ZWQuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoIHx8IHJldC5sZW5ndGgpIHtcbiAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHN0YXJ0LCBpdGVtcy5sZW5ndGgsIHJldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wb3BgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHJldHVybiB7Kn0gSXRlbSB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzaGlmdChwYXRoKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5zaGlmdCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bnNoaWZ0KHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnVuc2hpZnQoLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgaXRlbXMubGVuZ3RoLCBbXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGF0IGEgcGF0aCBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtLnVzZXIubmFtZSA9ICdCb2InO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW0udXNlci5uYW1lJyk7XG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFZhbHVlIGF0IHRoZSBwYXRoIChvcHRpb25hbCkuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbm90aWZ5UGF0aChwYXRoLCB2YWx1ZSkge1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICBsZXQgcHJvcFBhdGg7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIEdldCB2YWx1ZSBpZiBub3Qgc3VwcGxpZWRcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICB2YWx1ZSA9IGdldCh0aGlzLCBwYXRoLCBpbmZvKTtcbiAgICAgICAgcHJvcFBhdGggPSBpbmZvLnBhdGg7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHBhdGggaWYgbmVlZGVkXG4gICAgICAgIHByb3BQYXRoID0gbm9ybWFsaXplKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcFBhdGggPSAvKiogQHR5cGV7c3RyaW5nfSAqLyhwYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcFBhdGgsIHZhbHVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWFkT25seVByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgKiAgIHdoZW4gYHRydWVgLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgaWYgKHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICB0aGlzWydfc2V0JyArIHVwcGVyKHByb3BlcnR5KV0gPSAvKiogQHRoaXMge1Byb3BlcnR5RWZmZWN0c30gKi9mdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb24oKiwqKX0gbWV0aG9kIEZ1bmN0aW9uIG9yIG5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kXG4gICAgICogICAgIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kLCBkeW5hbWljRm46IEJvb2xlYW4oZHluYW1pY0ZuKSB9O1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgZm46IHJ1bk9ic2VydmVyRWZmZWN0LCBpbmZvLCB0cmlnZ2VyOiB7bmFtZTogcHJvcGVydHl9XG4gICAgICB9KTtcbiAgICAgIGlmIChkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QoLyoqIEB0eXBlIHtzdHJpbmd9ICovKG1ldGhvZCksIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2R9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVNZXRob2RPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgbGV0IHNpZyA9IHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pO1xuICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIG9ic2VydmVyIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZU1ldGhvZEVmZmVjdCh0aGlzLCBzaWcsIFRZUEVTLk9CU0VSVkUsIHJ1bk1ldGhvZEVmZmVjdCwgbnVsbCwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgIGZuOiBydW5Ob3RpZnlFZmZlY3QsXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBldmVudE5hbWU6IGNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkgKyAnLWNoYW5nZWQnLFxuICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVmbGVjdGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gZ28vbWlzc2luZ2ZucHJvcHNcbiAgICAgKi9cbiAgICBfY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIGxldCBhdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgaWYgKGF0dHJbMF0gPT09ICctJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5ICcgKyBwcm9wZXJ0eSArICcgY2Fubm90IGJlIHJlZmxlY3RlZCB0byBhdHRyaWJ1dGUgJyArXG4gICAgICAgICAgYXR0ciArICcgYmVjYXVzZSBcIi1cIiBpcyBub3QgYSB2YWxpZCBzdGFydGluZyBhdHRyaWJ1dGUgbmFtZS4gVXNlIGEgbG93ZXJjYXNlIGZpcnN0IGxldHRlciBmb3IgdGhlIHByb3BlcnR5IGluc3RlYWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCwge1xuICAgICAgICAgIGZuOiBydW5SZWZsZWN0RWZmZWN0LFxuICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgIGF0dHJOYW1lOiBhdHRyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgY29tcHV0ZWQgcHJvcGVydHkgdG8gc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgbGV0IHNpZyA9IHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pO1xuICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGNvbXB1dGVkIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZm8gPSBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5DT01QVVRFLCBydW5Db21wdXRlZEVmZmVjdCwgcHJvcGVydHksIGR5bmFtaWNGbik7XG4gICAgICAvLyBFZmZlY3RzIGFyZSBub3JtYWxseSBzdG9yZWQgYXMgbWFwIG9mIGRlcGVuZGVuY3ktPmVmZmVjdCwgYnV0IGZvclxuICAgICAgLy8gb3JkZXJlZCBjb21wdXRhdGlvbiwgd2UgYWxzbyBuZWVkIHRyZWUgb2YgY29tcHV0ZWRQcm9wLT5kZXBlbmRlbmNpZXNcbiAgICAgIGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCBDT01QVVRFX0lORk8pW3Byb3BlcnR5XSA9IGluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2F0aGVyIHRoZSBhcmd1bWVudCB2YWx1ZXMgZm9yIGEgbWV0aG9kIHNwZWNpZmllZCBpbiB0aGUgcHJvdmlkZWQgYXJyYXlcbiAgICAgKiBvZiBhcmd1bWVudCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIFRoZSBgcGF0aGAgYW5kIGB2YWx1ZWAgYXJndW1lbnRzIGFyZSB1c2VkIHRvIGZpbGwgaW4gd2lsZGNhcmQgZGVzY3JpcHRvclxuICAgICAqIHdoZW4gdGhlIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgYXMgYSByZXN1bHQgb2YgYSBwYXRoIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUFycmF5PCFNZXRob2RBcmc+fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCBuYW1lIHRoYXQgdHJpZ2dlcmVkIHRoZSBtZXRob2QgZWZmZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHshQXJyYXk8Kj59IEFycmF5IG9mIGFyZ3VtZW50IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21hcnNoYWxBcmdzKGFyZ3MsIHBhdGgsIHByb3BzKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGE7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGk9MCwgbD1hcmdzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgbGV0IHtuYW1lLCBzdHJ1Y3R1cmVkLCB3aWxkY2FyZCwgdmFsdWUsIGxpdGVyYWx9ID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKCFsaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gaXNEZXNjZW5kYW50KG5hbWUsIHBhdGgpO1xuICAgICAgICAgICAgY29uc3QgcGF0aFZhbHVlID0gZ2V0QXJnVmFsdWUoZGF0YSwgcHJvcHMsIG1hdGNoZXMgPyBwYXRoIDogbmFtZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlLFxuICAgICAgICAgICAgICBiYXNlOiBtYXRjaGVzID8gZ2V0KGRhdGEsIG5hbWUpIDogcGF0aFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cnVjdHVyZWQgPyBnZXRBcmdWYWx1ZShkYXRhLCBwcm9wcywgbmFtZSkgOiBkYXRhW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBgbGVnYWN5VW5kZWZpbmVkYCBmbGFnIGlzIGVuYWJsZWQsIHBhc3MgYSBuby1vcCB2YWx1ZVxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBvYnNlcnZlciwgY29tcHV0ZWQgcHJvcGVydHksIG9yIGNvbXBvdW5kIGJpbmRpbmcgaXMgYWJvcnRlZC5cbiAgICAgICAgaWYgKGxlZ2FjeVVuZGVmaW5lZCAmJiAhdGhpcy5fb3ZlcnJpZGVMZWdhY3lVbmRlZmluZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gTk9PUDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLy8gLS0gc3RhdGljIGNsYXNzIG1ldGhvZHMgLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGFuIGFjY2Vzc29yIGV4aXN0cyBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSwgYW5kIGFkZHNcbiAgICAgKiB0byBhIGxpc3Qgb2YgXCJwcm9wZXJ0eSBlZmZlY3RzXCIgdGhhdCB3aWxsIHJ1biB3aGVuIHRoZSBhY2Nlc3NvciBmb3JcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzIHNldC4gIEVmZmVjdHMgYXJlIGdyb3VwZWQgYnkgXCJ0eXBlXCIsIHdoaWNoXG4gICAgICogcm91Z2hseSBjb3JyZXNwb25kcyB0byBhIHBoYXNlIGluIGVmZmVjdCBwcm9jZXNzaW5nLiAgVGhlIGVmZmVjdFxuICAgICAqIG1ldGFkYXRhIHNob3VsZCBiZSBpbiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICpcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIGZuOiBlZmZlY3RGdW5jdGlvbiwgLy8gUmVmZXJlbmNlIHRvIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcGVyZm9ybSBlZmZlY3RcbiAgICAgKiAgICAgICBpbmZvOiB7IC4uLiB9ICAgICAgIC8vIEVmZmVjdCBtZXRhZGF0YSBwYXNzZWQgdG8gZnVuY3Rpb25cbiAgICAgKiAgICAgICB0cmlnZ2VyOiB7ICAgICAgICAgIC8vIE9wdGlvbmFsIHRyaWdnZXJpbmcgbWV0YWRhdGE7IGlmIG5vdCBwcm92aWRlZFxuICAgICAqICAgICAgICAgbmFtZTogc3RyaW5nICAgICAgLy8gdGhlIHByb3BlcnR5IGlzIHRyZWF0ZWQgYXMgYSB3aWxkY2FyZFxuICAgICAqICAgICAgICAgc3RydWN0dXJlZDogYm9vbGVhblxuICAgICAqICAgICAgICAgd2lsZGNhcmQ6IGJvb2xlYW5cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEVmZmVjdHMgYXJlIGNhbGxlZCBmcm9tIGBfcHJvcGVydGllc0NoYW5nZWRgIGluIHRoZSBmb2xsb3dpbmcgb3JkZXIgYnlcbiAgICAgKiB0eXBlOlxuICAgICAqXG4gICAgICogMS4gQ09NUFVURVxuICAgICAqIDIuIFBST1BBR0FURVxuICAgICAqIDMuIFJFRkxFQ1RcbiAgICAgKiA0LiBPQlNFUlZFXG4gICAgICogNS4gTk9USUZZXG4gICAgICpcbiAgICAgKiBFZmZlY3QgZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAgICAgKlxuICAgICAqICAgICBlZmZlY3RGdW5jdGlvbihpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9uKCosKil9IG1ldGhvZCBGdW5jdGlvbiBvciBuYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kLCBkeW5hbWljRm4pIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2QsIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICogZXhwcmVzc2lvbiwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFTY3JpcHRcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmU6IGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYC4gIEVhY2ggYXJndW1lbnRcbiAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAqIHByb3RvdHlwZSAob3IgaW5zdGFuY2UpLCBvciBtYXkgYmUgYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gZGlzcGF0Y2ggYDxwcm9wZXJ0eT4tY2hhbmdlZGBcbiAgICAgKiBldmVudHMgdG8gbm90aWZ5IG9mIGNoYW5nZXMgdG8gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVhZC1vbmx5IGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUbyBzZXQgdGhlIHByb3BlcnR5LCB1c2UgdGhlIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBBUEkuXG4gICAgICogVG8gY3JlYXRlIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXIgKGUuZy4gYF9zZXRNeVByb3AoKWAgZm9yXG4gICAgICogcHJvcGVydHkgYG15UHJvcGApLCBwYXNzIGB0cnVlYCBmb3IgYHByb3RlY3RlZFNldHRlcmAuXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiB0aGUgcHJvcGVydHkgd2lsbCBoYXZlIG90aGVyIHByb3BlcnR5IGVmZmVjdHMsIHRoaXMgbWV0aG9kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBmaXJzdCwgYmVmb3JlIGFkZGluZyBvdGhlciBlZmZlY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiB0byBhIChkYXNoLWNhc2VkKSBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAqIG1ldGhvZCBkZXNjcmliZWQgYnkgdGhlIGdpdmVuIGBleHByZXNzaW9uYCBlYWNoIHRpbWUgb25lIG9yIG1vcmVcbiAgICAgKiBhcmd1bWVudHMgdG8gdGhlIG1ldGhvZCBjaGFuZ2VzLiAgVGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIGEgc3RyaW5nXG4gICAgICogaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YVNjcmlwdCBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICogYCdtZXRob2ROYW1lKGFyZzEsIFsuLi4sIGFyZ25dKSdgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICAgICAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgdG8gZW5zdXJlIGJpbmRpbmcgZWZmZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGZvciB0aGVtLCBhbmQgdGhlbiBlbnN1cmVzIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgY3JlYXRlZCBmb3IgYW55XG4gICAgICogZGVwZW5kZW50IHByb3BlcnRpZXMgaW4gdGhlIHRlbXBsYXRlLiAgQmluZGluZyBlZmZlY3RzIGZvciBib3VuZFxuICAgICAqIHRlbXBsYXRlcyBhcmUgc3RvcmVkIGluIGEgbGlua2VkIGxpc3Qgb24gdGhlIGluc3RhbmNlIHNvIHRoYXRcbiAgICAgKiB0ZW1wbGF0ZXMgY2FuIGJlIGVmZmljaWVudGx5IHN0YW1wZWQgYW5kIHVuc3RhbXBlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAqICAgYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gYmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKlxuICAgICAqIE92ZXJ2aWV3IG9mIGJpbmRpbmcgZmxvdzpcbiAgICAgKlxuICAgICAqIER1cmluZyBmaW5hbGl6YXRpb24gKGBpbnN0YW5jZUJpbmRpbmc9PWZhbHNlYCwgYHdhc1ByZUJvdW5kPT1mYWxzZWApOlxuICAgICAqICBgX2JpbmRUZW1wbGF0ZSh0LCBmYWxzZSlgIGNhbGxlZCBkaXJlY3RseSBkdXJpbmcgZmluYWxpemF0aW9uIC0gcGFyc2VzXG4gICAgICogIHRoZSB0ZW1wbGF0ZSAoZm9yIHRoZSBmaXJzdCB0aW1lKSwgYW5kIHRoZW4gYXNzaWducyB0aGF0IF9wcm90b3R5cGljYWxfXG4gICAgICogIHRlbXBsYXRlIGluZm8gdG8gYF9fcHJlYm91bmRUZW1wbGF0ZUluZm9gIF9vbiB0aGUgcHJvdG90eXBlXzsgbm90ZSBpblxuICAgICAqICB0aGlzIGNhc2UgYHdhc1ByZUJvdW5kYCBpcyBmYWxzZTsgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBiaW5kaW5nXG4gICAgICogIGl0LCB0aHVzIHdlIGNyZWF0ZSBhY2Nlc3NvcnMuXG4gICAgICpcbiAgICAgKiBEdXJpbmcgZmlyc3Qgc3RhbXBpbmcgKGBpbnN0YW5jZUJpbmRpbmc9PXRydWVgLCBgd2FzUHJlQm91bmQ9PXRydWVgKTpcbiAgICAgKiAgIGBfc3RhbXBUZW1wbGF0ZWAgY2FsbHMgYF9iaW5kVGVtcGxhdGUodCwgdHJ1ZSlgOiB0aGUgYHRlbXBsYXRlSW5mb2BcbiAgICAgKiAgIHJldHVybmVkIG1hdGNoZXMgdGhlIHByZWJvdW5kIG9uZSwgYW5kIHNvIHRoaXMgaXMgYHdhc1ByZUJvdW5kID09IHRydWVgXG4gICAgICogICBzdGF0ZTsgdGh1cyB3ZSBfc2tpcF8gY3JlYXRpbmcgYWNjZXNzb3JzLCBidXQgX2RvXyBjcmVhdGUgYW4gaW5zdGFuY2VcbiAgICAgKiAgIG9mIHRoZSB0ZW1wbGF0ZSBpbmZvIHRvIHNlcnZlIGFzIHRoZSBzdGFydCBvZiBvdXIgbGlua2VkIGxpc3QgKG5lZWRzIHRvXG4gICAgICogICBiZSBhbiBpbnN0YW5jZSwgbm90IHRoZSBwcm90b3R5cGljYWwgb25lLCBzbyB0aGF0IHdlIGNhbiBhZGQgYG5vZGVMaXN0YFxuICAgICAqICAgdG8gaXQgdG8gY29udGFpbiB0aGUgYG5vZGVJbmZvYC1vcmRlcmVkIGxpc3Qgb2YgaW5zdGFuY2Ugbm9kZXMgZm9yXG4gICAgICogICBiaW5kaW5ncywgYW5kIHNvIHdlIGNhbiBjaGFpbiBydW50aW1lLXN0YW1wZWQgdGVtcGxhdGUgaW5mb3Mgb2ZmIG9mXG4gICAgICogICBpdCkuIEF0IHRoaXMgcG9pbnQsIHRoZSBjYWxsIHRvIGBfc3RhbXBUZW1wbGF0ZWAgY2FsbHNcbiAgICAgKiAgIGBhcHBseVRlbXBsYXRlSW5mb2AgZm9yIGVhY2ggbmVzdGVkIGA8dGVtcGxhdGU+YCBmb3VuZCBkdXJpbmcgcGFyc2luZ1xuICAgICAqICAgdG8gaGFuZCBwcm90b3R5cGljYWwgYF90ZW1wbGF0ZUluZm9gIHRvIHRoZW07IHdlIGFsc28gcGFzcyB0aGUgX3BhcmVudF9cbiAgICAgKiAgIGB0ZW1wbGF0ZUluZm9gIHRvIHRoZSBgPHRlbXBsYXRlPmAgc28gdGhhdCB3ZSBoYXZlIHRoZSBpbnN0YW5jZS10aW1lXG4gICAgICogICBwYXJlbnQgdG8gbGluayB0aGUgYHRlbXBsYXRlSW5mb2AgdW5kZXIgaW4gdGhlIGNhc2UgaXQgd2FzXG4gICAgICogICBydW50aW1lLXN0YW1wZWQuXG4gICAgICpcbiAgICAgKiBEdXJpbmcgc3Vic2VxdWVudCBydW50aW1lIHN0YW1waW5nIChgaW5zdGFuY2VCaW5kaW5nPT10cnVlYCxcbiAgICAgKiAgIGB3YXNQcmVCb3VuZD09ZmFsc2VgKTogYF9zdGFtcFRlbXBsYXRlYCBjYWxscyBgX2JpbmRUZW1wbGF0ZSh0LCB0cnVlKWBcbiAgICAgKiAgIC0gaGVyZSBgdGVtcGxhdGVJbmZvYCBpcyBndWFyYW50ZWVkIHRvIF9ub3RfIG1hdGNoIHRoZSBwcmVib3VuZCBvbmUsXG4gICAgICogICBiZWNhdXNlIGl0IHdhcyBlaXRoZXIgYSBkaWZmZXJlbnQgdGVtcGxhdGUgYWx0b2dldGhlciwgb3IgZXZlbiBpZiBpdFxuICAgICAqICAgd2FzIHRoZSBzYW1lIHRlbXBsYXRlLCB0aGUgc3RlcCBhYm92ZSBjcmVhdGVkIGEgaW5zdGFuY2Ugb2YgdGhlIGluZm87XG4gICAgICogICBpbiB0aGlzIGNhc2UgYHdhc1ByZUJvdW5kID09IGZhbHNlYCwgc28gd2UgX2RvXyBjcmVhdGUgYWNjZXNzb3JzLCBfYW5kX1xuICAgICAqICAgbGluayBhIGluc3RhbmNlIGludG8gdGhlIGxpbmtlZCBsaXN0LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGJpbmRUZW1wbGF0ZWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uIGFuIGluc3RhbmNlXG4gICAgICogdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3IgZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gdGhlIHByb3RvdHlwZSAoZm9yIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZVxuICAgICAqIGJpbmRpbmcsIHRvIGF2b2lkIGNyZWF0aW5nIGFjY2Vzc29ycyBldmVyeSBpbnN0YW5jZSkgb25jZSBwZXIgcHJvdG90eXBlLFxuICAgICAqIGFuZCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBydW50aW1lQmluZGluZzogdHJ1ZWAgYnkgYF9zdGFtcFRlbXBsYXRlYCB0b1xuICAgICAqIGNyZWF0ZSBhbmQgbGluayBhbiBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGFcbiAgICAgKiBwYXJ0aWN1bGFyIHN0YW1waW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogYmluZGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnN0YW5jZUJpbmRpbmcgV2hlbiBmYWxzZSAoZGVmYXVsdCksIHBlcmZvcm1zXG4gICAgICogXCJwcm90b3R5cGljYWxcIiBiaW5kaW5nIG9mIHRoZSB0ZW1wbGF0ZSBhbmQgb3ZlcndyaXRlcyBhbnkgcHJldmlvdXNseVxuICAgICAqIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgKiBgX3N0YW1wVGVtcGxhdGVgKSwgdGhlIHRlbXBsYXRlIGluZm8gaXMgaW5zdGFuY2VkIGFuZCBsaW5rZWQgaW50byB0aGVcbiAgICAgKiBsaXN0IG9mIGJvdW5kIHRlbXBsYXRlcy5cbiAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3Q7IGZvciBgcnVudGltZUJpbmRpbmdgLFxuICAgICAqIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBpbmZvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGdvL21pc3NpbmdmbnByb3BzXG4gICAgICovXG4gICAgX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgaW5zdGFuY2VCaW5kaW5nKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBsZXQgd2FzUHJlQm91bmQgPSB0aGlzLl9fcHJlQm91bmRUZW1wbGF0ZUluZm8gPT0gdGVtcGxhdGVJbmZvO1xuICAgICAgLy8gT3B0aW1pemF0aW9uOiBzaW5jZSB0aGlzIGlzIGNhbGxlZCB0d2ljZSBmb3IgcHJvdG8tYm91bmQgdGVtcGxhdGVzLFxuICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byByZWNyZWF0ZSBhY2Nlc3NvcnMgaWYgdGhpcyB0ZW1wbGF0ZSB3YXMgcHJlLWJvdW5kXG4gICAgICBpZiAoIXdhc1ByZUJvdW5kKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cykge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgICAgLy8gRm9yIGluc3RhbmNlLXRpbWUgYmluZGluZywgY3JlYXRlIGluc3RhbmNlIG9mIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgIC8vIGFuZCBsaW5rIGludG8gdHJlZSBvZiB0ZW1wbGF0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8oT2JqZWN0LmNyZWF0ZSh0ZW1wbGF0ZUluZm8pKTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLndhc1ByZUJvdW5kID0gd2FzUHJlQm91bmQ7XG4gICAgICAgIGlmICghdGhpcy5fX3RlbXBsYXRlSW5mbykge1xuICAgICAgICAgIC8vIFNldCB0aGUgaW5mbyB0byB0aGUgcm9vdCBvZiB0aGUgdHJlZVxuICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoaXMgdGVtcGxhdGUgaW5mbyBvbnRvIHRoZSBlbmQgb2YgaXRzIHBhcmVudCB0ZW1wbGF0ZSdzXG4gICAgICAgICAgLy8gbGlzdCwgd2hpY2ggd2lsbCBkZXRlcm1pbmUgdGhlIHRyZWUgc3RydWN0dXJlIHZpYSB3aGljaCBwcm9wZXJ0eVxuICAgICAgICAgIC8vIGVmZmVjdHMgYXJlIHJ1bjsgaWYgdGhpcyB0ZW1wbGF0ZSB3YXMgbm90IG5lc3RlZCBpbiBhbm90aGVyXG4gICAgICAgICAgLy8gdGVtcGxhdGUsIHVzZSB0aGUgcm9vdCB0ZW1wbGF0ZSAodGhlIGZpcnN0IHN0YW1wZWQgb25lKSBhcyB0aGVcbiAgICAgICAgICAvLyBwYXJlbnQuIE5vdGUsIGBwYXJlbnRgIGlzIHRoZSBgdGVtcGxhdGVJbmZvYCBpbnN0YW5jZSBmb3IgdGhpc1xuICAgICAgICAgIC8vIHRlbXBsYXRlJ3MgcGFyZW50IChjb250YWluaW5nKSB0ZW1wbGF0ZSwgd2hpY2ggd2FzIHNldCB1cCBpblxuICAgICAgICAgIC8vIGBhcHBseVRlbXBsYXRlSW5mb2AuICBXaGlsZSBhIGdpdmVuIHRlbXBsYXRlJ3MgYHBhcmVudGAgaXMgc2V0XG4gICAgICAgICAgLy8gYXByaW9yaSwgaXQgaXMgb25seSBhZGRlZCB0byB0aGUgcGFyZW50J3MgY2hpbGQgbGlzdCBhdCB0aGUgcG9pbnRcbiAgICAgICAgICAvLyB0aGF0IGl0IGlzIGJlaW5nIGJvdW5kLCBzaW5jZSBhIHRlbXBsYXRlIG1heSBvciBtYXkgbm90IGV2ZXIgYmVcbiAgICAgICAgICAvLyBzdGFtcGVkLCBhbmQgbWF5IGJlIHN0YW1wZWQgbW9yZSB0aGFuIG9uY2UgKGluIHdoaWNoIGNhc2UgaW5zdGFuY2VzXG4gICAgICAgICAgLy8gb2YgdGhlIHRlbXBsYXRlIGluZm8gd2lsbCBiZSBpbiB0aGUgdHJlZSB1bmRlciBpdHMgcGFyZW50IG1vcmUgdGhhblxuICAgICAgICAgIC8vIG9uY2UpLlxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRlbXBsYXRlLl9wYXJlbnRUZW1wbGF0ZUluZm8gfHwgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHBhcmVudC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICBwYXJlbnQubGFzdENoaWxkID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91cztcbiAgICAgICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHRTaWJsaW5nID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuZmlyc3RDaGlsZCA9IHRlbXBsYXRlSW5mbztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19wcmVCb3VuZFRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3BlcnR5IGVmZmVjdCB0byB0aGUgZ2l2ZW4gdGVtcGxhdGUgbWV0YWRhdGEsIHdoaWNoIGlzIHJ1blxuICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICogaGFzIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQgdmlhIGBfYmluZFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIHRvIGFkZCBlZmZlY3QgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCBwcm9wLCBlZmZlY3QpIHtcbiAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgIGhvc3RQcm9wc1twcm9wXSA9IHRydWU7XG4gICAgICBsZXQgZWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgPSB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzIHx8IHt9O1xuICAgICAgbGV0IHByb3BFZmZlY3RzID0gZWZmZWN0c1twcm9wXSA9IGVmZmVjdHNbcHJvcF0gfHwgW107XG4gICAgICBwcm9wRWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhbXBzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSBhbmQgcGVyZm9ybXMgaW5zdGFuY2UtdGltZSBzZXR1cCBmb3JcbiAgICAgKiBQb2x5bWVyIHRlbXBsYXRlIGZlYXR1cmVzLCBpbmNsdWRpbmcgZGF0YSBiaW5kaW5ncywgZGVjbGFyYXRpdmUgZXZlbnRcbiAgICAgKiBsaXN0ZW5lcnMsIGFuZCB0aGUgYHRoaXMuJGAgbWFwIG9mIGBpZGAncyB0byBub2Rlcy4gIEEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgKiBpcyByZXR1cm5lZCBjb250YWluaW5nIHRoZSBzdGFtcGVkIERPTSwgcmVhZHkgZm9yIGluc2VydGlvbiBpbnRvIHRoZVxuICAgICAqIERPTS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2U7IGhvd2V2ZXIgbm90ZSB0aGF0IGR1ZSB0b1xuICAgICAqIGBzaGFkeWNzc2AgcG9seWZpbGwgbGltaXRhdGlvbnMsIG9ubHkgc3R5bGVzIGZyb20gdGVtcGxhdGVzIHByZXBhcmVkXG4gICAgICogdXNpbmcgYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgd2lsbCBiZSBjb3JyZWN0bHkgcG9seWZpbGxlZCAoc2NvcGVkXG4gICAgICogdG8gdGhlIHNoYWRvdyByb290IGFuZCBzdXBwb3J0IENTUyBjdXN0b20gcHJvcGVydGllcyksIGFuZCBub3RlIHRoYXRcbiAgICAgKiBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCBtYXkgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgZWxlbWVudC4gQXMgc3VjaCxcbiAgICAgKiBhbnkgc3R5bGVzIHJlcXVpcmVkIGJ5IGluIHJ1bnRpbWUtc3RhbXBlZCB0ZW1wbGF0ZXMgbXVzdCBiZSBpbmNsdWRlZFxuICAgICAqIGluIHRoZSBtYWluIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBzdGFtcFxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvPX0gdGVtcGxhdGVJbmZvIE9wdGlvbmFsIGJvdW5kIHRlbXBsYXRlIGluZm8gYXNzb2NpYXRlZFxuICAgICAqICAgd2l0aCB0aGUgdGVtcGxhdGUgdG8gYmUgc3RhbXBlZDsgaWYgb21pdHRlZCB0aGUgdGVtcGxhdGUgd2lsbCBiZVxuICAgICAqICAgYXV0b21hdGljYWxseSBib3VuZC5cbiAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvKSB7XG4gICAgICB0ZW1wbGF0ZUluZm8gPSAgdGVtcGxhdGVJbmZvIHx8IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8odGhpcy5fYmluZFRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKSk7XG4gICAgICAvLyBFbnN1cmVzIHRoYXQgY3JlYXRlZCBkb20gaXMgYF9lbnF1ZXVlQ2xpZW50YCdkIHRvIHRoaXMgZWxlbWVudCBzb1xuICAgICAgLy8gdGhhdCBpdCBjYW4gYmUgZmx1c2hlZCBvbiBuZXh0IGNhbGwgdG8gYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICBob3N0U3RhY2sucHVzaCh0aGlzKTtcbiAgICAgIGxldCBkb20gPSBzdXBlci5fc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvKTtcbiAgICAgIGhvc3RTdGFjay5wb3AoKTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZS1pbnN0YW5jZS1zcGVjaWZpYyBkYXRhIHRvIGluc3RhbmNlZCB0ZW1wbGF0ZUluZm9cbiAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgIC8vIENhcHR1cmUgY2hpbGQgbm9kZXMgdG8gYWxsb3cgdW5zdGFtcGluZyBvZiBub24tcHJvdG90eXBpY2FsIHRlbXBsYXRlc1xuICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbj1kb20uZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgc2V0dXBCaW5kaW5ncyh0aGlzLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgLy8gRmx1c2ggcHJvcGVydGllcyBpbnRvIHRlbXBsYXRlIG5vZGVzOyB0aGUgY2hlY2sgb24gYF9fZGF0YUNsaWVudHNSZWFkeWBcbiAgICAgIC8vIGVuc3VyZXMgd2UgZG9uJ3QgbmVlZGxlc3NseSBydW4gZWZmZWN0cyBmb3IgYW4gZWxlbWVudCdzIGluaXRpYWxcbiAgICAgIC8vIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBzdGFtcGluZyBzaW5jZSB0aGV5IHdpbGwgaGFwcGVuIGFzIGEgcGFydCBvZiB0aGVcbiAgICAgIC8vIGZpcnN0IGNhbGwgdG8gYF9wcm9wZXJ0aWVzQ2hhbmdlZGAuIFRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgLy8gYWZ0ZXIgcnVubmluZyB0aGUgaW5pdGlhbCBwcm9wYWdhdGUgZWZmZWN0cywgYW5kIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgICAgLy8gZmx1c2hpbmcgY2xpZW50cy4gU2luY2UgZG93bnN0cmVhbSBjbGllbnRzIGNvdWxkIGNhdXNlIHN0YW1waW5nIG9uXG4gICAgICAvLyB0aGlzIGhvc3QgKGUuZy4gYSBmYXN0RG9tSWYgYGRvbS1pZmAgYmVpbmcgZm9yY2VkIHRvIHJlbmRlclxuICAgICAgLy8gc3luY2hyb25vdXNseSksIHRoaXMgZmxhZyBlbnN1cmVzIGVmZmVjdHMgZm9yIHJ1bnRpbWUtc3RhbXBlZCB0ZW1wbGF0ZXNcbiAgICAgIC8vIGFyZSBydW4gYXQgdGhpcyBwb2ludCBkdXJpbmcgdGhlIGluaXRpYWwgZWxlbWVudCBib290LXVwLlxuICAgICAgaWYgKHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3J1bkVmZmVjdHNGb3JUZW1wbGF0ZSh0ZW1wbGF0ZUluZm8sIHRoaXMuX19kYXRhLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCB1bmJpbmRzIHRoZSBub2RlcyBwcmV2aW91c2x5IGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBEb2N1bWVudEZyYWdtZW50IHJldHVybmVkIGZyb20gYF9zdGFtcFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7IVN0YW1wZWRUZW1wbGF0ZX0gZG9tIERvY3VtZW50RnJhZ21lbnQgcHJldmlvdXNseSByZXR1cm5lZFxuICAgICAqICAgZnJvbSBgX3N0YW1wVGVtcGxhdGVgIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZXMgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVCb3VuZERvbShkb20pIHtcbiAgICAgIC8vIFVubGluayB0ZW1wbGF0ZSBpbmZvOyBOb3RlIHRoYXQgd2hpbGUgdGhlIGNoaWxkIGlzIHVubGlua2VkIGZyb20gaXRzXG4gICAgICAvLyBwYXJlbnQgbGlzdCwgYSB0ZW1wbGF0ZSdzIGBwYXJlbnRgIHJlZmVyZW5jZSBpcyBuZXZlciByZW1vdmVkLCBzaW5jZVxuICAgICAgLy8gdGhpcyBpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0cmVlIHN0cnVjdHVyZSBhbmQgYXBwbGllZCBhdFxuICAgICAgLy8gYGFwcGx5VGVtcGxhdGVJbmZvYCB0aW1lLlxuICAgICAgY29uc3QgdGVtcGxhdGVJbmZvID0gZG9tLnRlbXBsYXRlSW5mbztcbiAgICAgIGNvbnN0IHtwcmV2aW91c1NpYmxpbmcsIG5leHRTaWJsaW5nLCBwYXJlbnR9ID0gdGVtcGxhdGVJbmZvO1xuICAgICAgaWYgKHByZXZpb3VzU2libGluZykge1xuICAgICAgICBwcmV2aW91c1NpYmxpbmcubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5maXJzdENoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50Lmxhc3RDaGlsZCA9IHByZXZpb3VzU2libGluZztcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlSW5mby5uZXh0U2libGluZyA9IHRlbXBsYXRlSW5mby5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIHN0YW1wZWQgbm9kZXNcbiAgICAgIGxldCBub2RlcyA9IHRlbXBsYXRlSW5mby5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHdyYXAod3JhcChub2RlKS5wYXJlbnROb2RlKS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGBUZXh0Tm9kZWAncycgYHRleHRDb250ZW50YC4gIEEgYGJpbmRpbmdzYFxuICAgICAqIGFycmF5IGlzIGFkZGVkIHRvIGBub2RlSW5mb2AgYW5kIHBvcHVsYXRlZCB3aXRoIGJpbmRpbmcgbWV0YWRhdGFcbiAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICogYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMjQwKTpcbiAgICAgIC8vICAgICBDaGFuZ2UgYmFjayB0byBqdXN0IHN1cGVyLm1ldGhvZENhbGwoKVxuICAgICAgbGV0IG5vdGVkID0gcHJvcGVydHlFZmZlY3RzQmFzZS5fcGFyc2VUZW1wbGF0ZU5vZGUuY2FsbChcbiAgICAgICAgdGhpcywgbm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5fcGFyc2VCaW5kaW5ncyhub2RlLnRleHRDb250ZW50LCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0ZXh0Q29udGVudCB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgICAgLy8gTk9URTogZGVmYXVsdCB0byBhIHNwYWNlIGhlcmUgc28gdGhlIHRleHROb2RlIHJlbWFpbnM7IHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAvLyAoSUUpIG9taXQgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB8fCAnICc7XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAndGV4dCcsICd0ZXh0Q29udGVudCcsIHBhcnRzKTtcbiAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGF0dHJpYnV0ZXMuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgbGV0IHBhcnRzID0gdGhpcy5fcGFyc2VCaW5kaW5ncyh2YWx1ZSwgdGVtcGxhdGVJbmZvKTtcbiAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAvLyBBdHRyaWJ1dGUgb3IgcHJvcGVydHlcbiAgICAgICAgbGV0IG9yaWdOYW1lID0gbmFtZTtcbiAgICAgICAgbGV0IGtpbmQgPSAncHJvcGVydHknO1xuICAgICAgICAvLyBUaGUgb25seSB3YXkgd2Ugc2VlIGEgY2FwaXRhbCBsZXR0ZXIgaGVyZSBpcyBpZiB0aGUgYXR0ciBoYXNcbiAgICAgICAgLy8gYSBjYXBpdGFsIGxldHRlciBpbiBpdCBwZXIgc3BlYy4gSW4gdGhpcyBjYXNlLCB0byBtYWtlIHN1cmVcbiAgICAgICAgLy8gdGhpcyBiaW5kaW5nIHdvcmtzLCB3ZSBnbyBhaGVhZCBhbmQgbWFrZSB0aGUgYmluZGluZyB0byB0aGUgYXR0cmlidXRlLlxuICAgICAgICBpZiAoY2FwaXRhbEF0dHJpYnV0ZVJlZ2V4LnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBraW5kID0gJ2F0dHJpYnV0ZSc7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZVtuYW1lLmxlbmd0aC0xXSA9PSAnJCcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAga2luZCA9ICdhdHRyaWJ1dGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgYXR0cmlidXRlIGJpbmRpbmdzIHdpdGggYW55IGxpdGVyYWwgcGFydHNcbiAgICAgICAgbGV0IGxpdGVyYWwgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKTtcbiAgICAgICAgaWYgKGxpdGVyYWwgJiYga2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgICAgICAgIC8vIEVuc3VyZSBhIFNoYWR5Q1NTIHRlbXBsYXRlIHNjb3BlZCBzdHlsZSBpcyBub3QgcmVtb3ZlZFxuICAgICAgICAgIC8vIHdoZW4gYSBjbGFzcyQgYmluZGluZydzIGluaXRpYWwgbGl0ZXJhbCB2YWx1ZSBpcyBzZXQuXG4gICAgICAgICAgaWYgKG5hbWUgPT0gJ2NsYXNzJyAmJiBub2RlLmhhc0F0dHJpYnV0ZSgnY2xhc3MnKSkge1xuICAgICAgICAgICAgbGl0ZXJhbCArPSAnICcgKyBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgbGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3VwcG9ydCBkaXNhYmxlLXVwZ3JhZGVcbiAgICAgICAgaWYgKGtpbmQgPT0gJ2F0dHJpYnV0ZScgJiYgb3JpZ05hbWUgPT0gJ2Rpc2FibGUtdXBncmFkZSQnKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGF0dHJpYnV0ZSBiZWZvcmUgcmVtb3ZpbmcsIHNpbmNlIElFIHdvbid0IGFsbG93IHJlbW92aW5nXG4gICAgICAgIC8vIGB2YWx1ZWAgYXR0cmlidXRlIGlmIGl0IHByZXZpb3VzbHkgaGFkIGEgdmFsdWUgKGNhbid0XG4gICAgICAgIC8vIHVuY29uZGl0aW9uYWxseSBzZXQgJycgYmVmb3JlIHJlbW92aW5nIHNpbmNlIGF0dHJpYnV0ZXMgd2l0aCBgJGBcbiAgICAgICAgLy8gY2FuJ3QgYmUgc2V0IHVzaW5nIHNldEF0dHJpYnV0ZSlcbiAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIG9yaWdOYW1lID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUob3JpZ05hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYW5ub3RhdGlvblxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShvcmlnTmFtZSk7XG4gICAgICAgIC8vIENhc2UgaGFja2VyeTogYXR0cmlidXRlcyBhcmUgbG93ZXItY2FzZSwgYnV0IGJpbmQgdGFyZ2V0c1xuICAgICAgICAvLyAocHJvcGVydGllcykgYXJlIGNhc2Ugc2Vuc2l0aXZlLiBHYW1iaXQgaXMgdG8gbWFwIGRhc2gtY2FzZSB0b1xuICAgICAgICAvLyBjYW1lbC1jYXNlOiBgZm9vLWJhcmAgYmVjb21lcyBgZm9vQmFyYC5cbiAgICAgICAgLy8gQXR0cmlidXRlIGJpbmRpbmdzIGFyZSBleGNlcHRlZC5cbiAgICAgICAgaWYgKGtpbmQgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICBuYW1lID0gZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywga2luZCwgbmFtZSwgcGFydHMsIGxpdGVyYWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMjQwKTpcbiAgICAgICAgLy8gICAgIENoYW5nZSBiYWNrIHRvIGp1c3Qgc3VwZXIubWV0aG9kQ2FsbCgpXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUVmZmVjdHNCYXNlLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZS5jYWxsKFxuICAgICAgICAgIHRoaXMsIG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICogYXMgYF9ob3N0Xzxwcm9wZXJ0eT5gLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMjQwKTpcbiAgICAgIC8vICAgICBDaGFuZ2UgYmFjayB0byBqdXN0IHN1cGVyLm1ldGhvZENhbGwoKVxuICAgICAgbGV0IG5vdGVkID0gcHJvcGVydHlFZmZlY3RzQmFzZS5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlLmNhbGwoXG4gICAgICAgIHRoaXMsIG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgbmVzdGVkVGVtcGxhdGVJbmZvID0gbm9kZUluZm8udGVtcGxhdGVJbmZvO1xuICAgICAgY29uc3QgaXNEb21JZiA9IHBhcmVudC5sb2NhbE5hbWUgPT09ICdkb20taWYnO1xuICAgICAgY29uc3QgaXNEb21SZXBlYXQgPSBwYXJlbnQubG9jYWxOYW1lID09PSAnZG9tLXJlcGVhdCc7XG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIHRlbXBsYXRlIGFuZCByZWRpcmVjdCBpdHMgaG9zdCBiaW5kaW5ncyAmIHRlbXBsYXRlSW5mb1xuICAgICAgLy8gb250byB0aGUgcGFyZW50IChkb20taWYvcmVwZWF0IGVsZW1lbnQpJ3Mgbm9kZUluZm9cbiAgICAgIGlmIChyZW1vdmVOZXN0ZWRUZW1wbGF0ZXMgJiYgKGlzRG9tSWYgfHwgaXNEb21SZXBlYXQpKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgLy8gVXNlIHRoZSBwYXJlbnQncyBub2RlSW5mbyAoZm9yIHRoZSBkb20taWYvcmVwZWF0KSB0byByZWNvcmQgdGhlXG4gICAgICAgIC8vIHRlbXBsYXRlSW5mbywgYW5kIHVzZSB0aGF0IGZvciBhbnkgaG9zdCBwcm9wZXJ0eSBiaW5kaW5ncyBiZWxvd1xuICAgICAgICBub2RlSW5mbyA9IG5vZGVJbmZvLnBhcmVudEluZm87XG4gICAgICAgIG5vZGVJbmZvLnRlbXBsYXRlSW5mbyA9IG5lc3RlZFRlbXBsYXRlSW5mbztcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBwYXJlbnQgZG9tLWlmL3JlcGVhdCBpcyBub3RlZCBzaW5jZSBpdCBub3cgbWF5IGhhdmUgaG9zdFxuICAgICAgICAvLyBiaW5kaW5nczsgaXQgbWF5IG5vdCBoYXZlIGJlZW4gaWYgaXQgZGlkIG5vdCBoYXZlIGl0cyBvd24gYmluZGluZ3NcbiAgICAgICAgbm9kZUluZm8ubm90ZWQgPSB0cnVlO1xuICAgICAgICBub3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgaG9zdCBwcm9wcyBpbnRvIG91dGVyIHRlbXBsYXRlIGFuZCBhZGQgYmluZGluZ3NcbiAgICAgIGxldCBob3N0UHJvcHMgPSBuZXN0ZWRUZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgaWYgKGZhc3REb21JZiAmJiBpc0RvbUlmKSB7XG4gICAgICAgIC8vIGBmYXN0RG9tSWZgIG1vZGUgdXNlcyBydW50aW1lLXRlbXBsYXRlIHN0YW1waW5nIHRvIGFkZCBhY2Nlc3NvcnMvXG4gICAgICAgIC8vIGVmZmVjdHMgdG8gcHJvcGVydGllcyB1c2VkIGluIGl0cyB0ZW1wbGF0ZTsgYXMgc3VjaCB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgIC8vIHRheCB0aGUgaG9zdCBlbGVtZW50IHdpdGggYF9ob3N0X2AgYmluZGluZ3MgZm9yIHRoZSBgZG9tLWlmYC5cbiAgICAgICAgLy8gSG93ZXZlciwgaW4gdGhlIGV2ZW50IGl0IGlzIG5lc3RlZCBpbiBhIGBkb20tcmVwZWF0YCwgaXQgaXMgc3RpbGxcbiAgICAgICAgLy8gaW1wb3J0YW50IHRoYXQgaXRzIGhvc3QgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gdGhlXG4gICAgICAgIC8vIFRlbXBsYXRlSW5zdGFuY2UncyBgaG9zdFByb3BzYCBzbyB0aGF0IHRoZXkgYXJlIGZvcndhcmRlZCB0byB0aGVcbiAgICAgICAgLy8gVGVtcGxhdGVJbnN0YW5jZS5cbiAgICAgICAgaWYgKGhvc3RQcm9wcykge1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9LCBob3N0UHJvcHMpO1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZG9tLWlmIGlzIG5vdGVkIHNvIHRoYXQgaXQgaGFzIGEgX19kYXRhSG9zdCwgc2luY2VcbiAgICAgICAgICAvLyBgZmFzdERvbUlmYCB1c2VzIHRoZSBob3N0IGZvciBydW50aW1lIHRlbXBsYXRlIHN0YW1waW5nOyBub3RlIHRoaXNcbiAgICAgICAgICAvLyB3YXMgYWxyZWFkeSBlbnN1cmVkIGFib3ZlIGluIHRoZSBgcmVtb3ZlTmVzdGVkVGVtcGxhdGVzYCBjYXNlXG4gICAgICAgICAgaWYgKCFyZW1vdmVOZXN0ZWRUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgIG5vZGVJbmZvLnBhcmVudEluZm8ubm90ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG1vZGUgPSAneyc7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSBbeyBtb2RlLCBzb3VyY2UsIGRlcGVuZGVuY2llczogW3NvdXJjZV0sIGhvc3RQcm9wOiB0cnVlIH1dO1xuICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgJ3Byb3BlcnR5JywgJ19ob3N0XycgKyBzb3VyY2UsIHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICogdGV4dENvbnRlbnQpIGludG8gYmluZGluZyBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgKiBtZXRhZGF0YSAgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0ZXh0XG4gICAgICogYW5kIGFueSBcImxpdGVyYWxcIiB0ZXh0IGluIGJldHdlZW4uICBBbnkgbm9uLWxpdGVyYWwgcGFydHMgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICogZmllbGRzIG9mIGVhY2ggXCJwYXJ0XCIgaW4gdGhlIHJldHVybmVkIGFycmF5IGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgYmluZGluZyB0byB1cGRhdGVcbiAgICAgKiAtIGBsaXRlcmFsYCAtIFN0cmluZyBjb250YWluaW5nIHRleHQgaWYgdGhlIHBhcnQgcmVwcmVzZW50cyBhIGxpdGVyYWw7XG4gICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAqXG4gICAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBmb3IgdXNlIGJ5IGBfZXZhbHVhdGVCaW5kaW5nYCBtYXkgYmUgcHJvdmlkZWQgaW5cbiAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhhbmRsZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBiaW5kaW5nc1xuICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICogLSBQcm9wZXJ0eSBiaW5kaW5nOiBgW1twcm9wXV1gXG4gICAgICogLSBQYXRoIGJpbmRpbmc6IGBbW29iamVjdC5wcm9wXV1gXG4gICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAqIC0gVHdvLXdheSBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBge3twcm9wfX1gLCBge3tvYmplY3QucHJvcH19YCwgYHt7IXByb3B9fWAgb3IgYHt7IW9iamVjdC5wcm9wfX1gXG4gICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBgW1tjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWAsIGBbWyFjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWBcbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHVzZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJlc3RcbiAgICAgKiBwZXJmb3JtYW5jZS4gSG93ZXZlciwgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VzIGEgd2hpdGUtbGlzdCBvZlxuICAgICAqIGFsbG93ZWQgY2hhcmFjdGVycyBpbiBhIGRhdGEtYmluZGluZywgd2hpY2ggY2F1c2VzIHByb2JsZW1zIGZvclxuICAgICAqIGRhdGEtYmluZGluZ3MgdGhhdCBkbyB1c2UgY2hhcmFjdGVycyBub3QgaW4gdGhpcyB3aGl0ZS1saXN0LlxuICAgICAqXG4gICAgICogSW5zdGVhZCBvZiB1cGRhdGluZyB0aGUgd2hpdGUtbGlzdCB3aXRoIGFsbCBhbGxvd2VkIGNoYXJhY3RlcnMsXG4gICAgICogdGhlcmUgaXMgYSBTdHJpY3RCaW5kaW5nUGFyc2VyIChzZWUgbGliL21peGlucy9zdHJpY3QtYmluZGluZy1wYXJzZXIpXG4gICAgICogdGhhdCB1c2VzIGEgc3RhdGUgbWFjaGluZSBpbnN0ZWFkLiBUaGlzIHN0YXRlIG1hY2hpbmUgaXMgYWJsZSB0byBoYW5kbGVcbiAgICAgKiBhbGwgY2hhcmFjdGVycy4gSG93ZXZlciwgaXQgaXMgc2xpZ2h0bHkgbGVzcyBwZXJmb3JtYW50LCB0aGVyZWZvcmUgd2VcbiAgICAgKiBleHRyYWN0ZWQgaXQgaW50byBhIHNlcGFyYXRlIG9wdGlvbmFsIG1peGluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dCB0byBwYXJzZSBmcm9tIGF0dHJpYnV0ZSBvciB0ZXh0Q29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gQ3VycmVudCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4ge0FycmF5PCFCaW5kaW5nUGFydD59IEFycmF5IG9mIGJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VCaW5kaW5ncyh0ZXh0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICBsZXQgbTtcbiAgICAgIC8vIEV4YW1wbGU6IFwibGl0ZXJhbDF7e3Byb3B9fWxpdGVyYWwyW1shY29tcHV0ZShmb28sYmFyKV1dZmluYWxcIlxuICAgICAgLy8gUmVnZXggbWF0Y2hlczpcbiAgICAgIC8vICAgICAgICBJdGVyYXRpb24gMTogIEl0ZXJhdGlvbiAyOlxuICAgICAgLy8gbVsxXTogJ3t7JyAgICAgICAgICAnW1snXG4gICAgICAvLyBtWzJdOiAnJyAgICAgICAgICAgICchJ1xuICAgICAgLy8gbVszXTogJ3Byb3AnICAgICAgICAnY29tcHV0ZShmb28sYmFyKSdcbiAgICAgIHdoaWxlICgobSA9IGJpbmRpbmdSZWdleC5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgbGl0ZXJhbCBwYXJ0XG4gICAgICAgIGlmIChtLmluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7bGl0ZXJhbDogdGV4dC5zbGljZShsYXN0SW5kZXgsIG0uaW5kZXgpfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGJpbmRpbmcgcGFydFxuICAgICAgICBsZXQgbW9kZSA9IG1bMV1bMF07XG4gICAgICAgIGxldCBuZWdhdGUgPSBCb29sZWFuKG1bMl0pO1xuICAgICAgICBsZXQgc291cmNlID0gbVszXS50cmltKCk7XG4gICAgICAgIGxldCBjdXN0b21FdmVudCA9IGZhbHNlLCBub3RpZnlFdmVudCA9ICcnLCBjb2xvbiA9IC0xO1xuICAgICAgICBpZiAobW9kZSA9PSAneycgJiYgKGNvbG9uID0gc291cmNlLmluZGV4T2YoJzo6JykpID4gMCkge1xuICAgICAgICAgIG5vdGlmeUV2ZW50ID0gc291cmNlLnN1YnN0cmluZyhjb2xvbiArIDIpO1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgY29sb24pO1xuICAgICAgICAgIGN1c3RvbUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmF0dXJlID0gcGFyc2VNZXRob2Qoc291cmNlKTtcbiAgICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgLy8gSW5saW5lIGNvbXB1dGVkIGZ1bmN0aW9uXG4gICAgICAgICAgbGV0IHthcmdzLCBtZXRob2ROYW1lfSA9IHNpZ25hdHVyZTtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBkeW5hbWljRm5zID0gdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnM7XG4gICAgICAgICAgaWYgKGR5bmFtaWNGbnMgJiYgZHluYW1pY0Zuc1ttZXRob2ROYW1lXSB8fCBzaWduYXR1cmUuc3RhdGljKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIHNpZ25hdHVyZS5keW5hbWljRm4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQcm9wZXJ0eSBvciBwYXRoXG4gICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2UsIG1vZGUsIG5lZ2F0ZSwgY3VzdG9tRXZlbnQsIHNpZ25hdHVyZSwgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgIGV2ZW50OiBub3RpZnlFdmVudFxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdEluZGV4ID0gYmluZGluZ1JlZ2V4Lmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBhIGZpbmFsIGxpdGVyYWwgcGFydFxuICAgICAgaWYgKGxhc3RJbmRleCAmJiBsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBsZXQgbGl0ZXJhbCA9IHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCk7XG4gICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBsaXRlcmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHRvIGV2YWx1YXRlIGEgcHJldmlvdXNseSBwYXJzZWQgYmluZGluZyBwYXJ0IGJhc2VkIG9uIGEgc2V0IG9mXG4gICAgICogb25lIG9yIG1vcmUgY2hhbmdlZCBkZXBlbmRlbmNpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXNcbiAgICAgKiAgICAgc2NvcGUgZm9yIGJpbmRpbmcgZGVwZW5kZW5jaWVzXG4gICAgICogQHBhcmFtIHtCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZWZmZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHRoZSBiaW5kaW5nIHBhcnQgZXZhbHVhdGVkIHRvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9ldmFsdWF0ZUJpbmRpbmcoaW5zdCwgcGFydCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgaWYgKHBhcnQuc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhbHVlID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgcGFydC5zaWduYXR1cmUpO1xuICAgICAgfSBlbHNlIGlmIChwYXRoICE9IHBhcnQuc291cmNlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0KGluc3QsIHBhcnQuc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNQYXRocyAmJiBpc1BhdGgocGF0aCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldChpbnN0LCBwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGluc3QuX19kYXRhW3BhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFydC5uZWdhdGUpIHtcbiAgICAgICAgdmFsdWUgPSAhdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gUHJvcGVydHlFZmZlY3RzO1xufSk7XG5cbi8qKlxuICogU3RhY2sgZm9yIGVucXVldWluZyBjbGllbnQgZG9tIGNyZWF0ZWQgYnkgYSBob3N0IGVsZW1lbnQuXG4gKlxuICogQnkgZGVmYXVsdCBlbGVtZW50cyBhcmUgZmx1c2hlZCB2aWEgYF9mbHVzaFByb3BlcnRpZXNgIHdoZW5cbiAqIGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgY2FsbGVkLiBFbGVtZW50cyBhdHRhY2ggdGhlaXIgY2xpZW50IGRvbSB0b1xuICogdGhlbXNlbHZlcyBhdCBgcmVhZHlgIHRpbWUgd2hpY2ggcmVzdWx0cyBmcm9tIHRoaXMgZmlyc3QgZmx1c2guXG4gKiBUaGlzIHByb3ZpZGVzIGFuIG9yZGVyaW5nIGd1YXJhbnRlZSB0aGF0IHRoZSBjbGllbnQgZG9tIGFuIGVsZW1lbnRcbiAqIGNyZWF0ZXMgaXMgZmx1c2hlZCBiZWZvcmUgdGhlIGVsZW1lbnQgaXRzZWxmIChpLmUuIGNsaWVudCBgcmVhZHlgXG4gKiBmaXJlcyBiZWZvcmUgaG9zdCBgcmVhZHlgKS5cbiAqXG4gKiBIb3dldmVyLCBpZiBgX2ZsdXNoUHJvcGVydGllc2AgaXMgY2FsbGVkICpiZWZvcmUqIGFuIGVsZW1lbnQgaXMgY29ubmVjdGVkLFxuICogYXMgZm9yIGV4YW1wbGUgYFRlbXBsYXRpemVgIGRvZXMsIHRoaXMgb3JkZXJpbmcgZ3VhcmFudGVlIGNhbm5vdCBiZVxuICogc2F0aXNmaWVkIGJlY2F1c2Ugbm8gZWxlbWVudHMgYXJlIGNvbm5lY3RlZC4gKE5vdGU6IEJvdW5kIGVsZW1lbnRzIHRoYXRcbiAqIHJlY2VpdmUgZGF0YSBkbyBiZWNvbWUgZW5xdWV1ZWQgY2xpZW50cyBhbmQgYXJlIHByb3Blcmx5IG9yZGVyZWQgYnV0XG4gKiB1bmJvdW5kIGVsZW1lbnRzIGFyZSBub3QuKVxuICpcbiAqIFRvIG1haW50YWluIHRoZSBkZXNpcmVkIFwiY2xpZW50IGJlZm9yZSBob3N0XCIgb3JkZXJpbmcgZ3VhcmFudGVlIGZvciB0aGlzXG4gKiBjYXNlIHdlIHJlbHkgb24gdGhlIFwiaG9zdCBzdGFjay4gQ2xpZW50IG5vZGVzIHJlZ2lzdGVycyB0aGVtc2VsdmVzIHdpdGhcbiAqIHRoZSBjcmVhdGluZyBob3N0IGVsZW1lbnQgd2hlbiBjcmVhdGVkLiBUaGlzIGVuc3VyZXMgdGhhdCBhbGwgY2xpZW50IGRvbVxuICogaXMgcmVhZGllZCBpbiB0aGUgcHJvcGVyIG9yZGVyLCBtYWludGFpbmluZyB0aGUgZGVzaXJlZCBndWFyYW50ZWUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaG9zdFN0YWNrID0gW107XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/property-effects.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/template-stamp.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/template-stamp.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TemplateStamp\": () => (/* binding */ TemplateStamp)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\n/**\n * Copies an attribute from one element to another, converting the value to a\n * `TrustedScript` if it is named like a Polymer template event listener.\n *\n * @param {!Element} dest The element to set the attribute on\n * @param {!Element} src The element to read the attribute from\n * @param {string} name The name of the attribute\n */\nconst copyAttributeWithTemplateEventPolicy = (() => {\n  /**\n   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted\n   * Types API where any attribute that starts with `on` may only be set to a\n   * `TrustedScript` value, even if that attribute would not cause an event\n   * listener to be created. (See https://crbug.com/993268 for details.)\n   *\n   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be\n   * written using the `<template is=\"...\">` syntax, even if there is no UA\n   * support for custom element extensions of built-in elements. In doing so, it\n   * copies attributes from the original `<template>` to a newly created\n   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if\n   * any of those attributes uses Polymer's `on-` syntax for event listeners.\n   * (Note, the value of these `on-` listeners is not evaluated as script: it is\n   * the name of a member function of a component that will be used as the event\n   * listener.)\n   *\n   * @type {!TrustedTypePolicy|undefined}\n   */\n  const polymerTemplateEventAttributePolicy = window.trustedTypes && window.trustedTypes.createPolicy('polymer-template-event-attribute-policy', {\n    createScript: x => x\n  });\n  return (dest, src, name) => {\n    const value = src.getAttribute(name);\n    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {\n      dest.setAttribute(name, polymerTemplateEventAttributePolicy.createScript(value, name));\n      return;\n    }\n    dest.setAttribute(name, value);\n  };\n})();\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while (t.attributes.length) {\n      const {\n        name\n      } = t.attributes[0];\n      copyAttributeWithTemplateEventPolicy(node, t, name);\n      t.removeAttribute(name);\n    }\n  }\n  return node;\n}\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function (e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nconst TemplateStamp = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let /** ? */templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute && template.hasAttribute('strip-whitespace');\n        // TODO(rictic): fix typing\n        this._parseTemplateContent(template, templateInfo, /** @type {?} */{\n          parent: null\n        });\n      }\n      return template._templateInfo;\n    }\n\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element = /** @type {!HTMLTemplateElement} */node;\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      fixPlaceholder(element);\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n      return noted || nodeInfo.noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */n = next;\n          while (n && n.nodeType === Node.TEXT_NODE) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo = /** @type {!NodeInfo} */{\n          parentIndex,\n          parentInfo: nodeInfo\n        };\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        }\n        // Increment if not removed\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element = /** @type {!HTMLTemplateElement} */node;\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n      let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n      return templateInfo && templateInfo.content || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */document.importNode(content, true);\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n  }\n  return TemplateStamp;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmpzPzEyZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5cbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIDEueCBiYWNrd2FyZHMtY29tcGF0aWJsZSBhdXRvLXdyYXBwZXIgZm9yIHRlbXBsYXRlIHR5cGUgZXh0ZW5zaW9uc1xuLy8gVGhpcyBpcyBhIGNsZWFyIGxheWVyaW5nIHZpb2xhdGlvbiBhbmQgZ2l2ZXMgZmF2b3JlZC1uYXRpb24gc3RhdHVzIHRvXG4vLyBkb20taWYgYW5kIGRvbS1yZXBlYXQgdGVtcGxhdGVzLiAgVGhpcyBpcyBhIGNvbmNlaXQgd2UncmUgY2hvb3NpbmcgdG8ga2VlcFxuLy8gYS4pIHRvIGVhc2UgMS54IGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGR1ZSB0byBsb3NzIG9mIGBpc2AsIGFuZFxuLy8gYi4pIHRvIG1haW50YWluIGlmL3JlcGVhdCBjYXBhYmlsaXR5IGluIHBhcnNlci1jb25zdHJhaW5lZCBlbGVtZW50c1xuLy8gICAgIChlLmcuIHRhYmxlLCBzZWxlY3QpIGluIGxpZXUgb2YgbmF0aXZlIENFIHR5cGUgZXh0ZW5zaW9ucyB3aXRob3V0XG4vLyAgICAgbWFzc2l2ZSBuZXcgaW52ZW50aW9uIGluIHRoaXMgc3BhY2UgKGUuZy4gZGlyZWN0aXZlIHN5c3RlbSlcbmNvbnN0IHRlbXBsYXRlRXh0ZW5zaW9ucyA9IHtcbiAgJ2RvbS1pZic6IHRydWUsXG4gICdkb20tcmVwZWF0JzogdHJ1ZVxufTtcblxubGV0IHBsYWNlaG9sZGVyQnVnRGV0ZWN0ID0gZmFsc2U7XG5sZXQgcGxhY2Vob2xkZXJCdWcgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFzUGxhY2Vob2xkZXJCdWcoKSB7XG4gIGlmICghcGxhY2Vob2xkZXJCdWdEZXRlY3QpIHtcbiAgICBwbGFjZWhvbGRlckJ1Z0RldGVjdCA9IHRydWU7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdC5wbGFjZWhvbGRlciA9ICdhJztcbiAgICBwbGFjZWhvbGRlckJ1ZyA9IHQucGxhY2Vob2xkZXIgPT09IHQudGV4dENvbnRlbnQ7XG4gIH1cbiAgcmV0dXJuIHBsYWNlaG9sZGVyQnVnO1xufVxuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB3aXRoIHRleHRhcmVhLCB3aGVyZSBwbGFjZWhvbGRlciB0ZXh0IGlzIGNvcGllZCBhc1xuICogYSB0ZXh0bm9kZSBjaGlsZCBvZiB0aGUgdGV4dGFyZWEuXG4gKlxuICogSWYgdGhlIHBsYWNlaG9sZGVyIGlzIGEgYmluZGluZywgdGhpcyBjYW4gYnJlYWsgdGVtcGxhdGUgc3RhbXBpbmcgaW4gdHdvXG4gKiB3YXlzLlxuICpcbiAqIE9uZSBpc3N1ZSBpcyB0aGF0IHdoZW4gdGhlIGBwbGFjZWhvbGRlcmAgYXR0cmlidXRlIGlzIHJlbW92ZWQgd2hlbiB0aGVcbiAqIGJpbmRpbmcgaXMgcHJvY2Vzc2VkLCB0aGUgdGV4dG5vZGUgY2hpbGQgb2YgdGhlIHRleHRhcmVhIGlzIGRlbGV0ZWQsIGFuZCB0aGVcbiAqIHRlbXBsYXRlIGluZm8gdHJpZXMgdG8gYmluZCBpbnRvIHRoYXQgbm9kZS5cbiAqXG4gKiBXaXRoIGBsZWdhY3lPcHRpbWl6YXRpb25zYCBpbiB1c2UsIHdoZW4gdGhlIHRlbXBsYXRlIGlzIHN0YW1wZWQgYW5kIHRoZVxuICogYHRleHRhcmVhLnRleHRDb250ZW50YCBiaW5kaW5nIGlzIHByb2Nlc3NlZCwgbm8gY29ycmVzcG9uZGluZyBub2RlIGlzIGZvdW5kXG4gKiBiZWNhdXNlIGl0IHdhcyByZW1vdmVkIGR1cmluZyBwYXJzaW5nLiBBbiBleGNlcHRpb24gaXMgZ2VuZXJhdGVkIHdoZW4gdGhpc1xuICogYmluZGluZyBpcyB1cGRhdGVkLlxuICpcbiAqIFdpdGggYGxlZ2FjeU9wdGltaXphdGlvbnNgIG5vdCBpbiB1c2UsIHRoZSB0ZW1wbGF0ZSBpcyBjbG9uZWQgYmVmb3JlXG4gKiBwcm9jZXNzaW5nIGFuZCB0aGlzIGNoYW5nZXMgdGhlIGFib3ZlIGJlaGF2aW9yLiBUaGUgY2xvbmVkIHRlbXBsYXRlIGFsc28gaGFzXG4gKiBhIHZhbHVlIHByb3BlcnR5IHNldCB0byB0aGUgcGxhY2Vob2xkZXIgYW5kIHRleHRDb250ZW50LiBUaGlzIHByZXZlbnRzIHRoZVxuICogcmVtb3ZhbCBvZiB0aGUgdGV4dENvbnRlbnQgd2hlbiB0aGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlIGlzIHJlbW92ZWQuXG4gKiBUaGVyZWZvcmUgdGhlIGV4Y2VwdGlvbiBkb2VzIG5vdCBvY2N1ci4gSG93ZXZlciwgdGhlcmUgaXMgYW4gZXh0cmFcbiAqIHVubmVjZXNzYXJ5IGJpbmRpbmcuXG4gKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZSBDaGVjayBub2RlIGZvciBwbGFjZWhvbGRlciBidWdcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZpeFBsYWNlaG9sZGVyKG5vZGUpIHtcbiAgaWYgKGhhc1BsYWNlaG9sZGVyQnVnKCkgJiYgbm9kZS5sb2NhbE5hbWUgPT09ICd0ZXh0YXJlYScgJiYgbm9kZS5wbGFjZWhvbGRlclxuICAgICAgICAmJiBub2RlLnBsYWNlaG9sZGVyID09PSBub2RlLnRleHRDb250ZW50KSB7XG4gICAgbm9kZS50ZXh0Q29udGVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3BpZXMgYW4gYXR0cmlidXRlIGZyb20gb25lIGVsZW1lbnQgdG8gYW5vdGhlciwgY29udmVydGluZyB0aGUgdmFsdWUgdG8gYVxuICogYFRydXN0ZWRTY3JpcHRgIGlmIGl0IGlzIG5hbWVkIGxpa2UgYSBQb2x5bWVyIHRlbXBsYXRlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGRlc3QgVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgb25cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IHNyYyBUaGUgZWxlbWVudCB0byByZWFkIHRoZSBhdHRyaWJ1dGUgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG5jb25zdCBjb3B5QXR0cmlidXRlV2l0aFRlbXBsYXRlRXZlbnRQb2xpY3kgPSAoKCkgPT4ge1xuICAvKipcbiAgICogVGhpcyBgVHJ1c3RlZFR5cGVQb2xpY3lgIGlzIHVzZWQgdG8gd29yayBhcm91bmQgYSBDaHJvbWUgYnVnIGluIHRoZSBUcnVzdGVkXG4gICAqIFR5cGVzIEFQSSB3aGVyZSBhbnkgYXR0cmlidXRlIHRoYXQgc3RhcnRzIHdpdGggYG9uYCBtYXkgb25seSBiZSBzZXQgdG8gYVxuICAgKiBgVHJ1c3RlZFNjcmlwdGAgdmFsdWUsIGV2ZW4gaWYgdGhhdCBhdHRyaWJ1dGUgd291bGQgbm90IGNhdXNlIGFuIGV2ZW50XG4gICAqIGxpc3RlbmVyIHRvIGJlIGNyZWF0ZWQuIChTZWUgaHR0cHM6Ly9jcmJ1Zy5jb20vOTkzMjY4IGZvciBkZXRhaWxzLilcbiAgICpcbiAgICogUG9seW1lcidzIHRlbXBsYXRlIHN5c3RlbSBhbGxvd3MgYDxkb20taWY+YCBhbmQgYDxkb20tcmVwZWF0PmAgdG8gYmVcbiAgICogd3JpdHRlbiB1c2luZyB0aGUgYDx0ZW1wbGF0ZSBpcz1cIi4uLlwiPmAgc3ludGF4LCBldmVuIGlmIHRoZXJlIGlzIG5vIFVBXG4gICAqIHN1cHBvcnQgZm9yIGN1c3RvbSBlbGVtZW50IGV4dGVuc2lvbnMgb2YgYnVpbHQtaW4gZWxlbWVudHMuIEluIGRvaW5nIHNvLCBpdFxuICAgKiBjb3BpZXMgYXR0cmlidXRlcyBmcm9tIHRoZSBvcmlnaW5hbCBgPHRlbXBsYXRlPmAgdG8gYSBuZXdseSBjcmVhdGVkXG4gICAqIGA8ZG9tLWlmPmAgb3IgYDxkb20tcmVwZWF0PmAsIHdoaWNoIGNhbiB0cmlnZ2VyIHRoZSBidWcgbWVudGlvbmVkIGFib3ZlIGlmXG4gICAqIGFueSBvZiB0aG9zZSBhdHRyaWJ1dGVzIHVzZXMgUG9seW1lcidzIGBvbi1gIHN5bnRheCBmb3IgZXZlbnQgbGlzdGVuZXJzLlxuICAgKiAoTm90ZSwgdGhlIHZhbHVlIG9mIHRoZXNlIGBvbi1gIGxpc3RlbmVycyBpcyBub3QgZXZhbHVhdGVkIGFzIHNjcmlwdDogaXQgaXNcbiAgICogdGhlIG5hbWUgb2YgYSBtZW1iZXIgZnVuY3Rpb24gb2YgYSBjb21wb25lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGV2ZW50XG4gICAqIGxpc3RlbmVyLilcbiAgICpcbiAgICogQHR5cGUgeyFUcnVzdGVkVHlwZVBvbGljeXx1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBwb2x5bWVyVGVtcGxhdGVFdmVudEF0dHJpYnV0ZVBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMgJiZcbiAgICAgIHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KFxuICAgICAgICAgICdwb2x5bWVyLXRlbXBsYXRlLWV2ZW50LWF0dHJpYnV0ZS1wb2xpY3knLCB7XG4gICAgICAgICAgICBjcmVhdGVTY3JpcHQ6IHggPT4geCxcbiAgICAgICAgICB9KTtcblxuICByZXR1cm4gKGRlc3QsIHNyYywgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc3JjLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGlmIChwb2x5bWVyVGVtcGxhdGVFdmVudEF0dHJpYnV0ZVBvbGljeSAmJiBuYW1lLnN0YXJ0c1dpdGgoJ29uLScpKSB7XG4gICAgICBkZXN0LnNldEF0dHJpYnV0ZShcbiAgICAgICAgICBuYW1lLCBwb2x5bWVyVGVtcGxhdGVFdmVudEF0dHJpYnV0ZVBvbGljeS5jcmVhdGVTY3JpcHQodmFsdWUsIG5hbWUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZXN0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSkge1xuICBsZXQgaXMgPSBub2RlLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgaWYgKGlzICYmIHRlbXBsYXRlRXh0ZW5zaW9uc1tpc10pIHtcbiAgICBsZXQgdCA9IG5vZGU7XG4gICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgbm9kZSA9IHQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzKTtcbiAgICB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIHQpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQodCk7XG4gICAgd2hpbGUodC5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qge25hbWV9ID0gdC5hdHRyaWJ1dGVzWzBdO1xuICAgICAgY29weUF0dHJpYnV0ZVdpdGhUZW1wbGF0ZUV2ZW50UG9saWN5KG5vZGUsIHQsIG5hbWUpO1xuICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvKSB7XG4gIC8vIHJlY3Vyc2l2ZWx5IGFzY2VuZCB0cmVlIHVudGlsIHdlIGhpdCByb290XG4gIGxldCBwYXJlbnQgPSBub2RlSW5mby5wYXJlbnRJbmZvICYmIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8ucGFyZW50SW5mbyk7XG4gIC8vIHVud2luZCB0aGUgc3RhY2ssIHJldHVybmluZyB0aGUgaW5kZXhlZCBub2RlIGF0IGVhY2ggbGV2ZWxcbiAgaWYgKHBhcmVudCkge1xuICAgIC8vIG5vdGU6IG1hcmdpbmFsbHkgZmFzdGVyIHRoYW4gaW5kZXhpbmcgdmlhIGNoaWxkTm9kZXNcbiAgICAvLyAoaHR0cDovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1sb29rdXApXG4gICAgZm9yIChsZXQgbj1wYXJlbnQuZmlyc3RDaGlsZCwgaT0wOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChub2RlSW5mby5wYXJlbnRJbmRleCA9PT0gaSsrKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxufVxuXG4vLyBjb25zdHJ1Y3QgYCRgIG1hcCAoZnJvbSBpZCBhbm5vdGF0aW9ucylcbmZ1bmN0aW9uIGFwcGx5SWRUb01hcChpbnN0LCBtYXAsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5pZCkge1xuICAgIG1hcFtub2RlSW5mby5pZF0gPSBub2RlO1xuICB9XG59XG5cbi8vIGluc3RhbGwgZXZlbnQgbGlzdGVuZXJzIChmcm9tIGV2ZW50IGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlFdmVudExpc3RlbmVyKGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5ldmVudHMgJiYgbm9kZUluZm8uZXZlbnRzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGo9MCwgZSQ9bm9kZUluZm8uZXZlbnRzLCBlOyAoajxlJC5sZW5ndGgpICYmIChlPWUkW2pdKTsgaisrKSB7XG4gICAgICBpbnN0Ll9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGUubmFtZSwgZS52YWx1ZSwgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHB1c2ggY29uZmlndXJhdGlvbiByZWZlcmVuY2VzIGF0IGNvbmZpZ3VyZSB0aW1lXG5mdW5jdGlvbiBhcHBseVRlbXBsYXRlSW5mbyhpbnN0LCBub2RlLCBub2RlSW5mbywgcGFyZW50VGVtcGxhdGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby50ZW1wbGF0ZUluZm8pIHtcbiAgICAvLyBHaXZlIHRoZSBub2RlIGFuIGluc3RhbmNlIG9mIHRoaXMgdGVtcGxhdGVJbmZvIGFuZCBzZXQgaXRzIHBhcmVudFxuICAgIG5vZGUuX3RlbXBsYXRlSW5mbyA9IG5vZGVJbmZvLnRlbXBsYXRlSW5mbztcbiAgICBub2RlLl9wYXJlbnRUZW1wbGF0ZUluZm8gPSBwYXJlbnRUZW1wbGF0ZUluZm87XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gIGNvbnRleHQgPSBjb250ZXh0Ll9tZXRob2RIb3N0IHx8IGNvbnRleHQ7XG4gIGxldCBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChjb250ZXh0W21ldGhvZE5hbWVdKSB7XG4gICAgICBjb250ZXh0W21ldGhvZE5hbWVdKGUsIGUuZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lciBtZXRob2QgYCcgKyBtZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW5kbGVyO1xufVxuXG4vKipcbiAqIEVsZW1lbnQgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyB0ZW1wbGF0ZSBwYXJzaW5nIGFuZCBzdGFtcGluZywgaW5jbHVkaW5nXG4gKiB0aGUgZm9sbG93aW5nIHRlbXBsYXRlLXJlbGF0ZWQgZmVhdHVyZXMgZm9yIHN0YW1wZWQgdGVtcGxhdGVzOlxuICpcbiAqIC0gRGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIChgb24tZXZlbnRuYW1lPVwibGlzdGVuZXJcImApXG4gKiAtIE1hcCBvZiBub2RlIGlkJ3MgdG8gc3RhbXBlZCBub2RlIGluc3RhbmNlcyAoYHRoaXMuJC5pZGApXG4gKiAtIE5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGNhY2hpbmcvcmVtb3ZhbCBhbmQgcmUtaW5zdGFsbGF0aW9uIChwZXJmb3JtYW5jZVxuICogICBvcHRpbWl6YXRpb24pXG4gKlxuICogQG1peGluRnVuY3Rpb25cbiAqIEBwb2x5bWVyXG4gKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgYmFzaWMgdGVtcGxhdGUgcGFyc2luZyBhbmQgc3RhbXBpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFRlbXBsYXRlU3RhbXAgPSBkZWR1cGluZ01peGluKFxuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3MgQ2xhc3MgdG8gYXBwbHkgbWl4aW4gdG8uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlQpfSBzdXBlckNsYXNzIHdpdGggbWl4aW4gYXBwbGllZC5cbiAgICAgKi9cbiAgICAoc3VwZXJDbGFzcykgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9UZW1wbGF0ZVN0YW1wfVxuICAgKi9cbiAgY2xhc3MgVGVtcGxhdGVTdGFtcCBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogU2NhbnMgYSB0ZW1wbGF0ZSB0byBwcm9kdWNlIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogVGVtcGxhdGUtc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiB0aGUgb2JqZWN0IHJldHVybmVkLCBhbmQgbm9kZS1cbiAgICAgKiBzcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIG9iamVjdHMgaW4gaXRzIGZsYXR0ZW5lZCBgbm9kZUluZm9MaXN0YFxuICAgICAqIGFycmF5LiAgT25seSBub2RlcyBpbiB0aGUgdGVtcGxhdGUgdGhhdCB3ZXJlIHBhcnNlZCBhcyBub2RlcyBvZlxuICAgICAqIGludGVyZXN0IGNvbnRhaW4gYW4gb2JqZWN0IGluIGBub2RlSW5mb0xpc3RgLiAgRWFjaCBgbm9kZUluZm9gIG9iamVjdFxuICAgICAqIGNvbnRhaW5zIGFuIGBpbmRleGAgKGBjaGlsZE5vZGVzYCBpbmRleCBpbiBwYXJlbnQpIGFuZCBvcHRpb25hbGx5XG4gICAgICogYHBhcmVudGAsIHdoaWNoIHBvaW50cyB0byBub2RlIGluZm8gb2YgaXRzIHBhcmVudCAoaW5jbHVkaW5nIGl0cyBpbmRleCkuXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0IHJldHVybmVkIGZyb20gdGhpcyBtZXRob2QgaGFzIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBzdHJ1Y3R1cmUgKG1hbnkgZmllbGRzIG9wdGlvbmFsKTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogICB7XG4gICAgICogICAgIC8vIEZsYXR0ZW5lZCBsaXN0IG9mIG5vZGUgbWV0YWRhdGEgKGZvciBub2RlcyB0aGF0IGdlbmVyYXRlZCBtZXRhZGF0YSlcbiAgICAgKiAgICAgbm9kZUluZm9MaXN0OiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgLy8gYGlkYCBhdHRyaWJ1dGUgZm9yIGFueSBub2RlcyB3aXRoIGlkJ3MgZm9yIGdlbmVyYXRpbmcgYCRgIG1hcFxuICAgICAqICAgICAgICAgaWQ6IHtzdHJpbmd9LFxuICAgICAqICAgICAgICAgLy8gYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBtZXRhZGF0YVxuICAgICAqICAgICAgICAgZXZlbnRzOiBbXG4gICAgICogICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICBuYW1lOiB7c3RyaW5nfSwgICAvLyBldmVudCBuYW1lXG4gICAgICogICAgICAgICAgICAgdmFsdWU6IHtzdHJpbmd9LCAgLy8gaGFuZGxlciBtZXRob2QgbmFtZVxuICAgICAqICAgICAgICAgICB9LCAuLi5cbiAgICAgKiAgICAgICAgIF0sXG4gICAgICogICAgICAgICAvLyBOb3RlcyB3aGVuIHRoZSB0ZW1wbGF0ZSBjb250YWluZWQgYSBgPHNsb3Q+YCBmb3Igc2hhZHkgRE9NXG4gICAgICogICAgICAgICAvLyBvcHRpbWl6YXRpb24gcHVycG9zZXNcbiAgICAgKiAgICAgICAgIGhhc0luc2VydGlvblBvaW50OiB7Ym9vbGVhbn0sXG4gICAgICogICAgICAgICAvLyBGb3IgbmVzdGVkIGA8dGVtcGxhdGU+YGAgbm9kZXMsIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqICAgICAgICAgdGVtcGxhdGVJbmZvOiB7b2JqZWN0fSwgLy8gbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICAvLyBNZXRhZGF0YSB0byBhbGxvdyBlZmZpY2llbnQgcmV0cmlldmFsIG9mIGluc3RhbmNlZCBub2RlXG4gICAgICogICAgICAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIHBhcmVudEluZm86IHtudW1iZXJ9LCAgIC8vIHJlZmVyZW5jZSB0byBwYXJlbnQgbm9kZUluZm8+XG4gICAgICogICAgICAgICBwYXJlbnRJbmRleDoge251bWJlcn0sICAvLyBpbmRleCBpbiBwYXJlbnQncyBgY2hpbGROb2Rlc2AgY29sbGVjdGlvblxuICAgICAqICAgICAgICAgaW5mb0luZGV4OiB7bnVtYmVyfSwgICAgLy8gaW5kZXggb2YgdGhpcyBgbm9kZUluZm9gIGluIGB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0YFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAgLi4uXG4gICAgICogICAgIF0sXG4gICAgICogICAgIC8vIFdoZW4gdHJ1ZSwgdGhlIHRlbXBsYXRlIGhhZCB0aGUgYHN0cmlwLXdoaXRlc3BhY2VgIGF0dHJpYnV0ZVxuICAgICAqICAgICAvLyBvciB3YXMgbmVzdGVkIGluIGEgdGVtcGxhdGUgd2l0aCB0aGF0IHNldHRpbmdcbiAgICAgKiAgICAgc3RyaXBXaGl0ZXNwYWNlOiB7Ym9vbGVhbn0sXG4gICAgICogICAgIC8vIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCBpcyBtb3ZlZCBpbnRvXG4gICAgICogICAgIC8vIGEgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGhlcmU7IHRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvXG4gICAgICogICAgIC8vIGF2b2lkIHRoZSBjb3N0IG9mIG5lc3RlZCB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgICogICAgIGNvbnRlbnQ6IHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAqICAgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qga2lja3Mgb2ZmIGEgcmVjdXJzaXZlIHRyZWV3YWxrIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgICBfcGFyc2VUZW1wbGF0ZSA8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAgX3BhcnNlVGVtcGxhdGVDb250ZW50ICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZSAgPC0tLS0tLS0tLS0tLXwtLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlIC0tKyAgfFxuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyAtLS0tLS0tLS0rXG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlc1xuICAgICAqICAgICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBtZXRhZGF0YSBhYm91dCB0ZW1wbGF0ZXNcbiAgICAgKiB0byBlaXRoZXIgYHRlbXBsYXRlSW5mb2Agb3IgYG5vZGVJbmZvYC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgYmUgZGVzdHJ1Y3RpdmUgdG8gdGhlIHRlbXBsYXRlLCBpbiB0aGF0XG4gICAgICogZS5nLiBldmVudCBhbm5vdGF0aW9ucyBtYXkgYmUgcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmcm9tIHRoZSBvdXRlclxuICAgICAqICAgdGVtcGxhdGUsIGZvciBwYXJzaW5nIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBQYXJzZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgb3V0ZXJUZW1wbGF0ZUluZm8pIHtcbiAgICAgIC8vIHNpbmNlIGEgdGVtcGxhdGUgbWF5IGJlIHJlLXVzZWQsIG1lbW8taXplIG1ldGFkYXRhXG4gICAgICBpZiAoIXRlbXBsYXRlLl90ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgLy8gVE9ETyhyaWN0aWMpOiBmaXggdHlwaW5nXG4gICAgICAgIGxldCAvKiogPyAqLyB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvID0ge307XG4gICAgICAgIHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QgPSBbXTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLm5lc3RlZFRlbXBsYXRlID0gQm9vbGVhbihvdXRlclRlbXBsYXRlSW5mbyk7XG4gICAgICAgIHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgPVxuICAgICAgICAgIChvdXRlclRlbXBsYXRlSW5mbyAmJiBvdXRlclRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UpIHx8XG4gICAgICAgICAgKHRlbXBsYXRlLmhhc0F0dHJpYnV0ZSAmJiB0ZW1wbGF0ZS5oYXNBdHRyaWJ1dGUoJ3N0cmlwLXdoaXRlc3BhY2UnKSk7XG4gICAgICAgICAvLyBUT0RPKHJpY3RpYyk6IGZpeCB0eXBpbmdcbiAgICAgICAgIHRoaXMuX3BhcnNlVGVtcGxhdGVDb250ZW50KFxuICAgICAgICAgICAgIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIC8qKiBAdHlwZSB7P30gKi8gKHtwYXJlbnQ6IG51bGx9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgZG9jcyBmb3IgX3BhcnNlVGVtcGxhdGVOb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgLlxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIC5cbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhbmQgYWRkcyB0ZW1wbGF0ZSBhbmQgbm9kZSBtZXRhZGF0YSBiYXNlZCBvblxuICAgICAqIHRoZSBjdXJyZW50IG5vZGUsIGFuZCBpdHMgYGNoaWxkTm9kZXNgIGFuZCBgYXR0cmlidXRlc2AuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG5vZGUgb3IgdGVtcGxhdGUgc3BlY2lmaWNcbiAgICAgKiBtZXRhZGF0YSBiYXNlZCBvbiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKG5vZGUpO1xuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdwcmVzZXJ2ZS1jb250ZW50JykpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgLy8gRm9yIFNoYWR5RG9tIG9wdGltaXphdGlvbiwgaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZpeFBsYWNlaG9sZGVyKGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZXMgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICAvLyBDaGVja2luZyBgbm9kZUluZm8ubm90ZWRgIGFsbG93cyBhIGNoaWxkIG5vZGUgb2YgdGhpcyBub2RlICh3aG8gZ2V0c1xuICAgICAgLy8gYWNjZXNzIHRvIGBwYXJlbnRJbmZvYCkgdG8gY2F1c2UgdGhlIHBhcmVudCB0byBiZSBub3RlZCwgd2hpY2hcbiAgICAgIC8vIG90aGVyd2lzZSBoYXMgbm8gcmV0dXJuIHBhdGggdmlhIGBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXNgICh1c2VkIGJ5XG4gICAgICAvLyBzb21lIG9wdGltaXphdGlvbnMpXG4gICAgICByZXR1cm4gbm90ZWQgfHwgbm9kZUluZm8ubm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIGNoaWxkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyB3cmFwcyB3aGl0ZWxpc3RlZCBsZWdhY3kgdGVtcGxhdGUgZXh0ZW5zaW9uc1xuICAgICAqIChgaXM9XCJkb20taWZcImAgYW5kIGBpcz1cImRvbS1yZXBlYXRcImApIHdpdGggdGhlaXIgZXF1aXZhbGVudCBlbGVtZW50XG4gICAgICogd3JhcHBlcnMsIGNvbGxhcHNlcyB0ZXh0IG5vZGVzLCBhbmQgc3RyaXBzIHdoaXRlc3BhY2UgZnJvbSB0aGUgdGVtcGxhdGVcbiAgICAgKiBpZiB0aGUgYHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlc3BhY2VgIHNldHRpbmcgd2FzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSByb290IFJvb3Qgbm9kZSB3aG9zZSBgY2hpbGROb2Rlc2Agd2lsbCBiZSBwYXJzZWRcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2Rlcyhyb290LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBpZiAocm9vdC5sb2NhbE5hbWUgPT09ICdzY3JpcHQnIHx8IHJvb3QubG9jYWxOYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IG5vZGU9cm9vdC5maXJzdENoaWxkLCBwYXJlbnRJbmRleD0wLCBuZXh0OyBub2RlOyBub2RlPW5leHQpIHtcbiAgICAgICAgLy8gV3JhcCB0ZW1wbGF0ZXNcbiAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICBub2RlID0gd3JhcFRlbXBsYXRlRXh0ZW5zaW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbGxhcHNlIGFkamFjZW50IHRleHROb2RlczogZml4ZXMgYW4gSUUgaXNzdWUgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgLy8gdGV4dCBub2RlcyB0byBiZSBpbmV4cGxpY2FibHkgc3BsaXQgPShcbiAgICAgICAgLy8gbm90ZSB0aGF0IHJvb3Qubm9ybWFsaXplKCkgc2hvdWxkIHdvcmsgYnV0IGRvZXMgbm90IHNvIHdlIGRvIHRoaXNcbiAgICAgICAgLy8gbWFudWFsbHkuXG4gICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBsZXQgLyoqIE5vZGUgKi8gbiA9IG5leHQ7XG4gICAgICAgICAgd2hpbGUgKG4gJiYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSkge1xuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCArPSBuLnRleHRDb250ZW50O1xuICAgICAgICAgICAgbmV4dCA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICAgICAgbiA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG9wdGlvbmFsbHkgc3RyaXAgd2hpdGVzcGFjZVxuICAgICAgICAgIGlmICh0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlICYmICFub2RlLnRleHRDb250ZW50LnRyaW0oKSkge1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRJbmZvID1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGVJbmZvfSAqLyAoe3BhcmVudEluZGV4LCBwYXJlbnRJbmZvOiBub2RlSW5mb30pO1xuICAgICAgICBpZiAodGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBjaGlsZEluZm8pKSB7XG4gICAgICAgICAgY2hpbGRJbmZvLmluZm9JbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QucHVzaChjaGlsZEluZm8pIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbmNyZW1lbnQgaWYgbm90IHJlbW92ZWRcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHBhcmVudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY29udGVudCBmb3IgdGhlIGdpdmVuIG5lc3RlZCBgPHRlbXBsYXRlPmAuXG4gICAgICpcbiAgICAgKiBOZXN0ZWQgdGVtcGxhdGUgaW5mbyBpcyBzdG9yZWQgYXMgYHRlbXBsYXRlSW5mb2AgaW4gdGhlIGN1cnJlbnQgbm9kZSdzXG4gICAgICogYG5vZGVJbmZvYC4gYHRlbXBsYXRlLmNvbnRlbnRgIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBgdGVtcGxhdGVJbmZvYC5cbiAgICAgKiBJdCB3aWxsIHRoZW4gYmUgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBob3N0IHRvIHNldCBpdCBiYWNrIHRvIHRoZVxuICAgICAqIHRlbXBsYXRlIGFuZCBmb3IgdXNlcnMgc3RhbXBpbmcgbmVzdGVkIHRlbXBsYXRlcyB0byB1c2UgdGhlXG4gICAgICogYF9jb250ZW50Rm9yVGVtcGxhdGVgIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgY29udGVudCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICAgICAqIChhbiBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZSAoYSA8dGVtcGxhdGU+KVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqICAgdGhhdCBpbmNsdWRlcyB0aGUgdGVtcGxhdGUgYG5vZGVgXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAvLyBUT0RPKHJpY3RpYyk6IHRoZSB0eXBlIG9mIG5vZGUgc2hvdWxkIGJlIG5vbi1udWxsXG4gICAgICBsZXQgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9ICovIChub2RlKTtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9wYXJzZVRlbXBsYXRlKGVsZW1lbnQsIG91dGVyVGVtcGxhdGVJbmZvKTtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgPVxuICAgICAgICAgIGVsZW1lbnQuY29udGVudC5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5jb250ZW50KTtcbiAgICAgIG5vZGVJbmZvLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZXMgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogZm9yIG5vZGVzIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudFxuICAgICAqICAgICB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIC8vIE1ha2UgY29weSBvZiBvcmlnaW5hbCBhdHRyaWJ1dGUgbGlzdCwgc2luY2UgdGhlIG9yZGVyIG1heSBjaGFuZ2VcbiAgICAgIC8vIGFzIGF0dHJpYnV0ZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkXG4gICAgICBsZXQgbm90ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBhdHRycyA9IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgIGZvciAobGV0IGk9YXR0cnMubGVuZ3RoLTEsIGE7IChhPWF0dHJzW2ldKTsgaS0tKSB7XG4gICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgYS5uYW1lLCBhLnZhbHVlKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzaW5nbGUgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGUgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0b1xuICAgICAqIGBub2RlSW5mb2AgZm9yIGF0dHJpYnV0ZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGFkZHMgbWV0YWRhdGEgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqIGFuZCBgaWRgIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgLy8gZXZlbnRzIChvbi0qKVxuICAgICAgaWYgKG5hbWUuc2xpY2UoMCwgMykgPT09ICdvbi0nKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBub2RlSW5mby5ldmVudHMgPSBub2RlSW5mby5ldmVudHMgfHwgW107XG4gICAgICAgIG5vZGVJbmZvLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lLnNsaWNlKDMpLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHN0YXRpYyBpZFxuICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICBub2RlSW5mby5pZCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgY29udGVudGAgZG9jdW1lbnQgZnJhZ21lbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBGb3IgbmVzdGVkIHRlbXBsYXRlcywgUG9seW1lciBwZXJmb3JtcyBhbiBvcHRpbWl6YXRpb24gdG8gY2FjaGUgbmVzdGVkXG4gICAgICogdGVtcGxhdGUgY29udGVudCB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIGRlZXBseSBuZXN0ZWQgdGVtcGxhdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHJpZXZlcyB0aGUgY2FjaGVkIGNvbnRlbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHJldHJpZXZlIGBjb250ZW50YCBmb3JcbiAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBDb250ZW50IGZyYWdtZW50XG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudFdpdGhJbmZvfSAqLyAodGVtcGxhdGUpLl90ZW1wbGF0ZUluZm87XG4gICAgICByZXR1cm4gKHRlbXBsYXRlSW5mbyAmJiB0ZW1wbGF0ZUluZm8uY29udGVudCkgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGNvbnRlbnQgYW5kIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGNsb25lZCBkb20uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgaXMgcGFyc2VkIChvbmNlIGFuZCBtZW1vaXplZCkgdXNpbmcgdGhpcyBsaWJyYXJ5J3NcbiAgICAgKiB0ZW1wbGF0ZSBwYXJzaW5nIGZlYXR1cmVzLCBhbmQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyB2YWx1ZS1hZGRlZFxuICAgICAqIGZlYXR1cmVzOlxuICAgICAqICogQWRkcyBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqICogR2VuZXJhdGVzIGFuIFwiaWQgbWFwXCIgZm9yIGFsbCBub2RlcyB3aXRoIGlkJ3MgdW5kZXIgYCRgIG9uIHJldHVybmVkXG4gICAgICogICBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqICogUGFzc2VzIHRlbXBsYXRlIGluZm8gaW5jbHVkaW5nIGBjb250ZW50YCBiYWNrIHRvIHRlbXBsYXRlcyBhc1xuICAgICAqICAgYF90ZW1wbGF0ZUluZm9gIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0byBhdm9pZCBkZWVwIHRlbXBsYXRlXG4gICAgICogICBjbG9uaW5nKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBtZW1vaXplZCB0ZW1wbGF0ZSBwYXJzaW5nIHByb2Nlc3MgaXMgZGVzdHJ1Y3RpdmUgdG8gdGhlXG4gICAgICogdGVtcGxhdGU6IGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmdzIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgYXJlXG4gICAgICogcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiBub3RlcywgYW5kIGFueSBuZXN0ZWQgYDx0ZW1wbGF0ZT4uY29udGVudGBcbiAgICAgKiBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gbm90ZXMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSB0ZW1wbGF0ZUluZm8gT3B0aW9uYWwgdGVtcGxhdGUgaW5mbyBhc3NvY2lhdGVkXG4gICAgICogICB3aXRoIHRoZSB0ZW1wbGF0ZSB0byBiZSBzdGFtcGVkOyBpZiBvbWl0dGVkIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlXG4gICAgICogICBhdXRvbWF0aWNhbGx5IHBhcnNlZC5cbiAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgIC8vIFBvbHlmaWxsIHN1cHBvcnQ6IGJvb3RzdHJhcCB0aGUgdGVtcGxhdGUgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW5cbiAgICAgIGlmICh0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29udGVudCAmJlxuICAgICAgICAgIHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50ICYmIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUpIHtcbiAgICAgICAgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyBBY2NlcHRpbmcgdGhlIGB0ZW1wbGF0ZUluZm9gIHZpYSBhbiBhcmd1bWVudCBhbGxvd3MgZm9yIGNyZWF0aW5nXG4gICAgICAvLyBpbnN0YW5jZXMgb2YgdGhlIGB0ZW1wbGF0ZUluZm9gIGJ5IHRoZSBjYWxsZXIsIHVzZWZ1bCBmb3IgYWRkaW5nXG4gICAgICAvLyBpbnN0YW5jZS10aW1lIGluZm9ybWF0aW9uIHRvIHRoZSBwcm90b3R5cGljYWwgZGF0YVxuICAgICAgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvIHx8IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IG5vZGVJbmZvID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdDtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICAgIGxldCBkb20gPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpKTtcbiAgICAgIC8vIE5PVEU6IFNoYWR5RG9tIG9wdGltaXphdGlvbiBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgZG9tLl9fbm9JbnNlcnRpb25Qb2ludCA9ICF0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQ7XG4gICAgICBsZXQgbm9kZXMgPSBkb20ubm9kZUxpc3QgPSBuZXcgQXJyYXkobm9kZUluZm8ubGVuZ3RoKTtcbiAgICAgIGRvbS4kID0ge307XG4gICAgICBmb3IgKGxldCBpPTAsIGw9bm9kZUluZm8ubGVuZ3RoLCBpbmZvOyAoaTxsKSAmJiAoaW5mbz1ub2RlSW5mb1tpXSk7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldID0gZmluZFRlbXBsYXRlTm9kZShkb20sIGluZm8pO1xuICAgICAgICBhcHBseUlkVG9NYXAodGhpcywgZG9tLiQsIG5vZGUsIGluZm8pO1xuICAgICAgICBhcHBseVRlbXBsYXRlSW5mbyh0aGlzLCBub2RlLCBpbmZvLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICBhcHBseUV2ZW50TGlzdGVuZXIodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICB9XG4gICAgICBkb20gPSAvKiogQHR5cGUgeyFTdGFtcGVkVGVtcGxhdGV9ICovKGRvbSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBieSBtZXRob2QgbmFtZSBmb3IgdGhlIGV2ZW50IHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgaGFuZGxlciBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIHRoZSBtZXRob2RcbiAgICAgKiBuYW1lIGF0IGhhbmRsaW5nIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFFdmVudFRhcmdldH0gbm9kZSBOb2RlIHRvIGFkZCBsaXN0ZW5lciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgbWV0aG9kXG4gICAgICogQHBhcmFtIHsqPX0gY29udGV4dCBDb250ZXh0IHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gKGRlZmF1bHRzXG4gICAgICogICB0byBgbm9kZWApXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEdlbmVyYXRlZCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBub2RlO1xuICAgICAgbGV0IGhhbmRsZXIgPSBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFFdmVudFRhcmdldH0gbm9kZSBOb2RlIHRvIGFkZCBldmVudCBsaXN0ZW5lciB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTp2b2lkfSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIGFkZFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFFdmVudFRhcmdldH0gbm9kZSBOb2RlIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOnZvaWR9IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gVGVtcGxhdGVTdGFtcDtcblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/template-stamp.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/async.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/async.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"animationFrame\": () => (/* binding */ animationFrame),\n/* harmony export */   \"idlePeriod\": () => (/* binding */ idlePeriod),\n/* harmony export */   \"microTask\": () => (/* binding */ microTask),\n/* harmony export */   \"timeOut\": () => (/* binding */ timeOut)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\n\n\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n};\n\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nconst microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXN5bmMuanM/OTIwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmcgYXN5bmNocm9ub3VzXG4gKiB0YXNrcy4gRWFjaCBzdWItbW9kdWxlIHByb3ZpZGVzIGEgc3RhbmRhcmQgYHJ1bihmbilgIGludGVyZmFjZSB0aGF0IHJldHVybnMgYVxuICogaGFuZGxlLCBhbmQgYSBgY2FuY2VsKGhhbmRsZSlgIGludGVyZmFjZSBmb3IgY2FuY2VsaW5nIGFzeW5jIHRhc2tzIGJlZm9yZVxuICogdGhleSBydW4uXG4gKlxuICogQHN1bW1hcnkgTW9kdWxlIHRoYXQgcHJvdmlkZXMgYSBudW1iZXIgb2Ygc3RyYXRlZ2llcyBmb3IgZW5xdWV1aW5nXG4gKiBhc3luY2hyb25vdXMgdGFza3MuXG4gKi9cblxuaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyBNaWNyb3Rhc2sgaW1wbGVtZW50ZWQgdXNpbmcgTXV0YXRpb24gT2JzZXJ2ZXJcbmxldCBtaWNyb3Rhc2tDdXJySGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tMYXN0SGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbmxldCBtaWNyb3Rhc2tOb2RlQ29udGVudCA9IDA7XG5sZXQgbWljcm90YXNrU2NoZWR1bGVkID0gZmFsc2U7XG5sZXQgbWljcm90YXNrTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbm5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtaWNyb3Rhc2tGbHVzaCkub2JzZXJ2ZShtaWNyb3Rhc2tOb2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tGbHVzaCgpIHtcbiAgbWljcm90YXNrU2NoZWR1bGVkID0gZmFsc2U7XG4gIGNvbnN0IGxlbiA9IG1pY3JvdGFza0NhbGxiYWNrcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgY2IgPSBtaWNyb3Rhc2tDYWxsYmFja3NbaV07XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZTsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG1pY3JvdGFza0NhbGxiYWNrcy5zcGxpY2UoMCwgbGVuKTtcbiAgbWljcm90YXNrTGFzdEhhbmRsZSArPSBsZW47XG59XG5cbi8qKlxuICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGBzZXRUaW1lb3V0YC5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHNldFRpbWVvdXRgLlxuICovXG5jb25zdCB0aW1lT3V0ID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIHN1Yi1tb2R1bGUgd2l0aCB0aGUgYXN5bmMgaW50ZXJmYWNlIHByb3ZpZGluZyB0aGUgcHJvdmlkZWRcbiAgICogZGVsYXkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiB0aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gZGVsYXkgVGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIGNhbGxiYWNrcyBpbiBtc1xuICAgKiBAcmV0dXJuIHshQXN5bmNJbnRlcmZhY2V9IEFuIGFzeW5jIHRpbWVvdXQgaW50ZXJmYWNlXG4gICAqL1xuICBhZnRlcihkZWxheSkge1xuICAgIHJldHVybiB7XG4gICAgICBydW4oZm4pIHsgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCBkZWxheSk7IH0sXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgaW4gdGhlIG5leHQgdGFzay5cbiAgICpcbiAgICogQG1lbWJlcm9mIHRpbWVPdXRcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IERlbGF5IGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGZuLCBkZWxheSkge1xuICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICB9LFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYHRpbWVPdXRgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgdGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgfVxufTtcbmV4cG9ydCB7dGltZU91dH07XG5cbi8qKlxuICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAqL1xuY29uc3QgYW5pbWF0aW9uRnJhbWUgPSB7XG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBhbmltYXRpb25GcmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oZm4pIHtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gIH0sXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgYW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgYW5pbWF0aW9uRnJhbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgfVxufTtcbmV4cG9ydCB7YW5pbWF0aW9uRnJhbWV9O1xuXG4vKipcbiAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AuICBGYWxscyBiYWNrIHRvXG4gKiBgc2V0VGltZW91dGAgb24gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBgcmVxdWVzdElkbGVDYWxsYmFja2AuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0SWRsZUNhbGxiYWNrYC5cbiAqL1xuY29uc3QgaWRsZVBlcmlvZCA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBpZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUlkbGVEZWFkbGluZSk6dm9pZH0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oZm4pIHtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgP1xuICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soZm4pIDpcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxNik7XG4gIH0sXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgaWRsZVBlcmlvZGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBpZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA/XG4gICAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGhhbmRsZSkgOlxuICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICB9XG59O1xuZXhwb3J0IHtpZGxlUGVyaW9kfTtcblxuLyoqXG4gKiBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWluZyBjYWxsYmFja3MgdGhhdCBydW4gYXQgbWljcm90YXNrIHRpbWluZy5cbiAqXG4gKiBOb3RlIHRoYXQgbWljcm90YXNrIHRpbWluZyBpcyBhY2hpZXZlZCB2aWEgYSBzaW5nbGUgYE11dGF0aW9uT2JzZXJ2ZXJgLFxuICogYW5kIHRodXMgY2FsbGJhY2tzIGVucXVldWVkIHdpdGggdGhpcyBBUEkgd2lsbCBhbGwgcnVuIGluIGEgc2luZ2xlXG4gKiBiYXRjaCwgYW5kIG5vdCBpbnRlcmxlYXZlZCB3aXRoIG90aGVyIG1pY3JvdGFza3Mgc3VjaCBhcyBwcm9taXNlcy5cbiAqIFByb21pc2VzIGFyZSBhdm9pZGVkIGFzIGFuIGltcGxlbWVudGF0aW9uIGNob2ljZSBmb3IgdGhlIHRpbWUgYmVpbmdcbiAqIGR1ZSB0byBTYWZhcmkgYnVncyB0aGF0IGNhdXNlIFByb21pc2VzIHRvIGxhY2sgbWljcm90YXNrIGd1YXJhbnRlZXMuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIGZvciBlbnF1ZXVpbmcgY2FsbGJhY2tzIHRoYXQgcnVuIGF0IG1pY3JvdGFza1xuICogICB0aW1pbmcuXG4gKi9cbmNvbnN0IG1pY3JvVGFzayA9IHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgbWljcm90YXNrIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1pY3JvVGFza1xuICAgKiBAcGFyYW0geyFGdW5jdGlvbj19IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFtaWNyb3Rhc2tTY2hlZHVsZWQpIHtcbiAgICAgIG1pY3JvdGFza1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBtaWNyb3Rhc2tOb2RlLnRleHRDb250ZW50ID0gbWljcm90YXNrTm9kZUNvbnRlbnQrKztcbiAgICB9XG4gICAgbWljcm90YXNrQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBtaWNyb3Rhc2tDdXJySGFuZGxlKys7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBtaWNyb1Rhc2tgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbWljcm9UYXNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgY29uc3QgaWR4ID0gaGFuZGxlIC0gbWljcm90YXNrTGFzdEhhbmRsZTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFzeW5jIGhhbmRsZTogJyArIGhhbmRsZSk7XG4gICAgICB9XG4gICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgfVxuICB9XG5cbn07XG5leHBvcnQge21pY3JvVGFza307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/async.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable no-unused-vars */\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n *\n * @param {?} prop Property name\n * @param {*} obj Reference object\n * @return {string} Potentially renamed property name\n */\nwindow.JSCompiler_renameProperty = function (prop, obj) {\n  return prop;\n};\n/* eslint-enable */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuanM/NDQ3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyoqXG4gKiBXaGVuIHVzaW5nIENsb3N1cmUgQ29tcGlsZXIsIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkocHJvcGVydHksIG9iamVjdCkgaXMgcmVwbGFjZWQgYnkgdGhlIG11bmdlZCBuYW1lIGZvciBvYmplY3RbcHJvcGVydHldXG4gKiBXZSBjYW5ub3QgYWxpYXMgdGhpcyBmdW5jdGlvbiwgc28gd2UgaGF2ZSB0byB1c2UgYSBzbWFsbCBzaGltIHRoYXQgaGFzIHRoZSBzYW1lIGJlaGF2aW9yIHdoZW4gbm90IGNvbXBpbGluZy5cbiAqXG4gKiBAcGFyYW0gez99IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHsqfSBvYmogUmVmZXJlbmNlIG9iamVjdFxuICogQHJldHVybiB7c3RyaW5nfSBQb3RlbnRpYWxseSByZW5hbWVkIHByb3BlcnR5IG5hbWVcbiAqL1xud2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCBvYmopIHtcbiAgcmV0dXJuIHByb3A7XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5leHBvcnQge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/case-map.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/case-map.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"camelToDashCase\": () => (/* binding */ camelToDashCase),\n/* harmony export */   \"dashToCamelCase\": () => (/* binding */ dashToCamelCase)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nconst caseMap = {};\nconst DASH_TO_CAMEL = /-[a-z]/g;\nconst CAMEL_TO_DASH = /([A-Z])/g;\n\n/**\n * @fileoverview Module with utilities for converting between \"dash-case\" and\n * \"camelCase\" identifiers.\n */\n\n/**\n * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n * (e.g. `fooBarBaz`).\n *\n * @param {string} dash Dash-case identifier\n * @return {string} Camel-case representation of the identifier\n */\nfunction dashToCamelCase(dash) {\n  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));\n}\n\n/**\n * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n * (e.g. `foo-bar-baz`).\n *\n * @param {string} camel Camel-case identifier\n * @return {string} Dash-case representation of the identifier\n */\nfunction camelToDashCase(camel) {\n  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanM/YzA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5jb25zdCBjYXNlTWFwID0ge307XG5jb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuY29uc3QgQ0FNRUxfVE9fREFTSCA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBcImRhc2gtY2FzZVwiIGFuZFxuICogXCJjYW1lbENhc2VcIiBpZGVudGlmaWVycy5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIFwiZGFzaC1jYXNlXCIgaWRlbnRpZmllciAoZS5nLiBgZm9vLWJhci1iYXpgKSB0byBcImNhbWVsQ2FzZVwiXG4gKiAoZS5nLiBgZm9vQmFyQmF6YCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhc2ggRGFzaC1jYXNlIGlkZW50aWZpZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gQ2FtZWwtY2FzZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaWRlbnRpZmllclxuICovXG5leHBvcnQgZnVuY3Rpb24gZGFzaFRvQ2FtZWxDYXNlKGRhc2gpIHtcbiAgcmV0dXJuIGNhc2VNYXBbZGFzaF0gfHwgKFxuICAgIGNhc2VNYXBbZGFzaF0gPSBkYXNoLmluZGV4T2YoJy0nKSA8IDAgPyBkYXNoIDogZGFzaC5yZXBsYWNlKERBU0hfVE9fQ0FNRUwsXG4gICAgICAobSkgPT4gbVsxXS50b1VwcGVyQ2FzZSgpXG4gICAgKVxuICApO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIFwiY2FtZWxDYXNlXCIgaWRlbnRpZmllciAoZS5nLiBgZm9vQmFyQmF6YCkgdG8gXCJkYXNoLWNhc2VcIlxuICogKGUuZy4gYGZvby1iYXItYmF6YCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNhbWVsIENhbWVsLWNhc2UgaWRlbnRpZmllclxuICogQHJldHVybiB7c3RyaW5nfSBEYXNoLWNhc2UgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlkZW50aWZpZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbWVsVG9EYXNoQ2FzZShjYW1lbCkge1xuICByZXR1cm4gY2FzZU1hcFtjYW1lbF0gfHwgKFxuICAgIGNhc2VNYXBbY2FtZWxdID0gY2FtZWwucmVwbGFjZShDQU1FTF9UT19EQVNILCAnLSQxJykudG9Mb3dlckNhc2UoKVxuICApO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/case-map.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/html-tag.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/html-tag.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"html\": () => (/* binding */ html),\n/* harmony export */   \"htmlLiteral\": () => (/* binding */ htmlLiteral)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the Polymer html\n * template tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n *\n * @type {!TrustedTypePolicy|undefined}\n */\nconst policy = window.trustedTypes && trustedTypes.createPolicy('polymer-html-literal', {\n  createHTML: s => s\n});\n\n/**\n * Class representing a static string value which can be used to filter\n * strings by asseting that they have been created via this class. The\n * `value` property returns the string passed to the constructor.\n */\nclass LiteralString {\n  /**\n   * @param {!ITemplateArray} strings Constant parts of tagged template literal\n   * @param {!Array<*>} values Variable parts of tagged template literal\n   */\n  constructor(strings, values) {\n    assertValidTemplateStringParameters(strings, values);\n    const string = values.reduce((acc, v, idx) => acc + literalValue(v) + strings[idx + 1], strings[0]);\n    /** @type {string} */\n    this.value = string.toString();\n  }\n  /**\n   * @return {string} LiteralString string value\n   * @override\n   */\n  toString() {\n    return this.value;\n  }\n}\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\nfunction literalValue(value) {\n  if (value instanceof LiteralString) {\n    return (/** @type {!LiteralString} */value.value\n    );\n  } else {\n    throw new Error(`non-literal value passed to Polymer's htmlLiteral function: ${value}`);\n  }\n}\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\nfunction htmlValue(value) {\n  if (value instanceof HTMLTemplateElement) {\n    // This might be an mXSS risk  mainly in the case where this template\n    // contains untrusted content that was believed to be sanitized.\n    // However we can't just use the XMLSerializer here because it misencodes\n    // `>` characters inside style tags.\n    // For an example of an actual case that hit this encoding issue,\n    // see b/198592167\n    return (/** @type {!HTMLTemplateElement } */value.innerHTML\n    );\n  } else if (value instanceof LiteralString) {\n    return literalValue(value);\n  } else {\n    throw new Error(`non-template value passed to Polymer's html function: ${value}`);\n  }\n}\n\n/**\n * A template literal tag that creates an HTML <template> element from the\n * contents of the string.\n *\n * This allows you to write a Polymer Template in JavaScript.\n *\n * Templates can be composed by interpolating `HTMLTemplateElement`s in\n * expressions in the JavaScript template literal. The nested template's\n * `innerHTML` is included in the containing template.  The only other\n * values allowed in expressions are those returned from `htmlLiteral`\n * which ensures only literal values from JS source ever reach the HTML, to\n * guard against XSS risks.\n *\n * All other values are disallowed in expressions to help prevent XSS\n * attacks; however, `htmlLiteral` can be used to compose static\n * string values into templates. This is useful to compose strings into\n * places that do not accept html, like the css text of a `style`\n * element.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>:host{ content:\"...\" }</style>\n *         <div class=\"shadowed\">${this.partialTemplate}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get partialTemplate() { return html`<span>Partial!</span>`; }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement\n */\nconst html = function html(strings, ...values) {\n  assertValidTemplateStringParameters(strings, values);\n  const template = /** @type {!HTMLTemplateElement} */document.createElement('template');\n  let value = values.reduce((acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);\n  if (policy) {\n    value = policy.createHTML(value);\n  }\n  template.innerHTML = value;\n  return template;\n};\n\n/**\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {!Array<*>} values Array of values from quasis\n */\nconst assertValidTemplateStringParameters = (strings, values) => {\n  // Note: if/when https://github.com/tc39/proposal-array-is-template-object\n  // is standardized, use that instead when available, as it can perform an\n  // unforgable check (though of course, the function itself can be forged).\n  if (!Array.isArray(strings) || !Array.isArray(strings.raw) || values.length !== strings.length - 1) {\n    // This is either caused by a browser bug, a compiler bug, or someone\n    // calling the html template tag function as a regular function.\n    //\n    throw new TypeError('Invalid call to the html template tag');\n  }\n};\n\n/**\n * An html literal tag that can be used with `html` to compose.\n * a literal string.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>\n *           :host { display: block; }\n *           ${this.styleTemplate()}\n *         </style>\n *         <div class=\"shadowed\">${staticValue}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get styleTemplate() {\n *        return htmlLiteral`.shadowed { background: gray; }`;\n *     }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!LiteralString} Constructed literal string\n */\nconst htmlLiteral = function (strings, ...values) {\n  return new LiteralString(strings, values);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2h0bWwtdGFnLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZy5qcz9iODc1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8qKlxuICogT3VyIFRydXN0ZWRUeXBlUG9saWN5IGZvciBIVE1MIHdoaWNoIGlzIGRlY2xhcmVkIHVzaW5nIHRoZSBQb2x5bWVyIGh0bWxcbiAqIHRlbXBsYXRlIHRhZyBmdW5jdGlvbi5cbiAqXG4gKiBUaGF0IEhUTUwgaXMgYSBkZXZlbG9wZXItYXV0aG9yZWQgY29uc3RhbnQsIGFuZCBpcyBwYXJzZWQgd2l0aCBpbm5lckhUTUxcbiAqIGJlZm9yZSBhbnkgdW50cnVzdGVkIGV4cHJlc3Npb25zIGhhdmUgYmVlbiBtaXhlZCBpbi4gVGhlcmVmb3IgaXQgaXNcbiAqIGNvbnNpZGVyZWQgc2FmZSBieSBjb25zdHJ1Y3Rpb24uXG4gKlxuICogQHR5cGUgeyFUcnVzdGVkVHlwZVBvbGljeXx1bmRlZmluZWR9XG4gKi9cbmNvbnN0IHBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMgJiZcbiAgICB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KCdwb2x5bWVyLWh0bWwtbGl0ZXJhbCcsIHtjcmVhdGVIVE1MOiAocykgPT4gc30pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHN0YXRpYyBzdHJpbmcgdmFsdWUgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZmlsdGVyXG4gKiBzdHJpbmdzIGJ5IGFzc2V0aW5nIHRoYXQgdGhleSBoYXZlIGJlZW4gY3JlYXRlZCB2aWEgdGhpcyBjbGFzcy4gVGhlXG4gKiBgdmFsdWVgIHByb3BlcnR5IHJldHVybnMgdGhlIHN0cmluZyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICovXG5jbGFzcyBMaXRlcmFsU3RyaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUlUZW1wbGF0ZUFycmF5fSBzdHJpbmdzIENvbnN0YW50IHBhcnRzIG9mIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSB2YWx1ZXMgVmFyaWFibGUgcGFydHMgb2YgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHZhbHVlcykge1xuICAgIGFzc2VydFZhbGlkVGVtcGxhdGVTdHJpbmdQYXJhbWV0ZXJzKHN0cmluZ3MsIHZhbHVlcyk7XG4gICAgY29uc3Qgc3RyaW5nID0gdmFsdWVzLnJlZHVjZShcbiAgICAgICAgKGFjYywgdiwgaWR4KSA9PiBhY2MgKyBsaXRlcmFsVmFsdWUodikgKyBzdHJpbmdzW2lkeCArIDFdLCBzdHJpbmdzWzBdKTtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnZhbHVlID0gc3RyaW5nLnRvU3RyaW5nKCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTGl0ZXJhbFN0cmluZyBzdHJpbmcgdmFsdWVcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT2JqZWN0IHRvIHN0cmluZ2lmeSBpbnRvIEhUTUxcbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCBzdHJpbmdpZmllZCBmb3JtIG9mIGBvYmpgXG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWxWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXRlcmFsU3RyaW5nKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUxpdGVyYWxTdHJpbmd9ICovKHZhbHVlKS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBub24tbGl0ZXJhbCB2YWx1ZSBwYXNzZWQgdG8gUG9seW1lcidzIGh0bWxMaXRlcmFsIGZ1bmN0aW9uOiAke3ZhbHVlfWBcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBPYmplY3QgdG8gc3RyaW5naWZ5IGludG8gSFRNTFxuICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHN0cmluZ2lmaWVkIGZvcm0gb2YgYG9iamBcbiAqL1xuZnVuY3Rpb24gaHRtbFZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAvLyBUaGlzIG1pZ2h0IGJlIGFuIG1YU1MgcmlzayDigJMgbWFpbmx5IGluIHRoZSBjYXNlIHdoZXJlIHRoaXMgdGVtcGxhdGVcbiAgICAvLyBjb250YWlucyB1bnRydXN0ZWQgY29udGVudCB0aGF0IHdhcyBiZWxpZXZlZCB0byBiZSBzYW5pdGl6ZWQuXG4gICAgLy8gSG93ZXZlciB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgWE1MU2VyaWFsaXplciBoZXJlIGJlY2F1c2UgaXQgbWlzZW5jb2Rlc1xuICAgIC8vIGA+YCBjaGFyYWN0ZXJzIGluc2lkZSBzdHlsZSB0YWdzLlxuICAgIC8vIEZvciBhbiBleGFtcGxlIG9mIGFuIGFjdHVhbCBjYXNlIHRoYXQgaGl0IHRoaXMgZW5jb2RpbmcgaXNzdWUsXG4gICAgLy8gc2VlIGIvMTk4NTkyMTY3XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnQgfSAqLyh2YWx1ZSkuaW5uZXJIVE1MO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl0ZXJhbFN0cmluZykge1xuICAgIHJldHVybiBsaXRlcmFsVmFsdWUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYG5vbi10ZW1wbGF0ZSB2YWx1ZSBwYXNzZWQgdG8gUG9seW1lcidzIGh0bWwgZnVuY3Rpb246ICR7dmFsdWV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHRlbXBsYXRlIGxpdGVyYWwgdGFnIHRoYXQgY3JlYXRlcyBhbiBIVE1MIDx0ZW1wbGF0ZT4gZWxlbWVudCBmcm9tIHRoZVxuICogY29udGVudHMgb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gd3JpdGUgYSBQb2x5bWVyIFRlbXBsYXRlIGluIEphdmFTY3JpcHQuXG4gKlxuICogVGVtcGxhdGVzIGNhbiBiZSBjb21wb3NlZCBieSBpbnRlcnBvbGF0aW5nIGBIVE1MVGVtcGxhdGVFbGVtZW50YHMgaW5cbiAqIGV4cHJlc3Npb25zIGluIHRoZSBKYXZhU2NyaXB0IHRlbXBsYXRlIGxpdGVyYWwuIFRoZSBuZXN0ZWQgdGVtcGxhdGUnc1xuICogYGlubmVySFRNTGAgaXMgaW5jbHVkZWQgaW4gdGhlIGNvbnRhaW5pbmcgdGVtcGxhdGUuICBUaGUgb25seSBvdGhlclxuICogdmFsdWVzIGFsbG93ZWQgaW4gZXhwcmVzc2lvbnMgYXJlIHRob3NlIHJldHVybmVkIGZyb20gYGh0bWxMaXRlcmFsYFxuICogd2hpY2ggZW5zdXJlcyBvbmx5IGxpdGVyYWwgdmFsdWVzIGZyb20gSlMgc291cmNlIGV2ZXIgcmVhY2ggdGhlIEhUTUwsIHRvXG4gKiBndWFyZCBhZ2FpbnN0IFhTUyByaXNrcy5cbiAqXG4gKiBBbGwgb3RoZXIgdmFsdWVzIGFyZSBkaXNhbGxvd2VkIGluIGV4cHJlc3Npb25zIHRvIGhlbHAgcHJldmVudCBYU1NcbiAqIGF0dGFja3M7IGhvd2V2ZXIsIGBodG1sTGl0ZXJhbGAgY2FuIGJlIHVzZWQgdG8gY29tcG9zZSBzdGF0aWNcbiAqIHN0cmluZyB2YWx1ZXMgaW50byB0ZW1wbGF0ZXMuIFRoaXMgaXMgdXNlZnVsIHRvIGNvbXBvc2Ugc3RyaW5ncyBpbnRvXG4gKiBwbGFjZXMgdGhhdCBkbyBub3QgYWNjZXB0IGh0bWwsIGxpa2UgdGhlIGNzcyB0ZXh0IG9mIGEgYHN0eWxlYFxuICogZWxlbWVudC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICogICAgICAgcmV0dXJuIGh0bWxgXG4gKiAgICAgICAgIDxzdHlsZT46aG9zdHsgY29udGVudDpcIi4uLlwiIH08L3N0eWxlPlxuICogICAgICAgICA8ZGl2IGNsYXNzPVwic2hhZG93ZWRcIj4ke3RoaXMucGFydGlhbFRlbXBsYXRlfTwvZGl2PlxuICogICAgICAgICAke3N1cGVyLnRlbXBsYXRlfVxuICogICAgICAgYDtcbiAqICAgICB9XG4gKiAgICAgc3RhdGljIGdldCBwYXJ0aWFsVGVtcGxhdGUoKSB7IHJldHVybiBodG1sYDxzcGFuPlBhcnRpYWwhPC9zcGFuPmA7IH1cbiAqXG4gKiBAcGFyYW0geyFJVGVtcGxhdGVBcnJheX0gc3RyaW5ncyBDb25zdGFudCBwYXJ0cyBvZiB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFxuICogQHBhcmFtIHsuLi4qfSB2YWx1ZXMgVmFyaWFibGUgcGFydHMgb2YgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcbiAqIEByZXR1cm4geyFIVE1MVGVtcGxhdGVFbGVtZW50fSBDb25zdHJ1Y3RlZCBIVE1MVGVtcGxhdGVFbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBodG1sID0gZnVuY3Rpb24gaHRtbChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgYXNzZXJ0VmFsaWRUZW1wbGF0ZVN0cmluZ1BhcmFtZXRlcnMoc3RyaW5ncywgdmFsdWVzKTtcbiAgY29uc3QgdGVtcGxhdGUgPVxuICAgICAgLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJykpO1xuICBsZXQgdmFsdWUgPSB2YWx1ZXMucmVkdWNlKFxuICAgICAgKGFjYywgdiwgaWR4KSA9PiBhY2MgKyBodG1sVmFsdWUodikgKyBzdHJpbmdzW2lkeCArIDFdLCBzdHJpbmdzWzBdKTtcbiAgaWYgKHBvbGljeSkge1xuICAgIHZhbHVlID0gcG9saWN5LmNyZWF0ZUhUTUwodmFsdWUpO1xuICB9XG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IHZhbHVlO1xuICByZXR1cm4gdGVtcGxhdGU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IUlUZW1wbGF0ZUFycmF5fSBzdHJpbmdzIENvbnN0YW50IHBhcnRzIG9mIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXG4gKiBAcGFyYW0geyFBcnJheTwqPn0gdmFsdWVzIEFycmF5IG9mIHZhbHVlcyBmcm9tIHF1YXNpc1xuICovXG5jb25zdCBhc3NlcnRWYWxpZFRlbXBsYXRlU3RyaW5nUGFyYW1ldGVycyA9IChzdHJpbmdzLCB2YWx1ZXMpID0+IHtcbiAgLy8gTm90ZTogaWYvd2hlbiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1pcy10ZW1wbGF0ZS1vYmplY3RcbiAgLy8gaXMgc3RhbmRhcmRpemVkLCB1c2UgdGhhdCBpbnN0ZWFkIHdoZW4gYXZhaWxhYmxlLCBhcyBpdCBjYW4gcGVyZm9ybSBhblxuICAvLyB1bmZvcmdhYmxlIGNoZWNrICh0aG91Z2ggb2YgY291cnNlLCB0aGUgZnVuY3Rpb24gaXRzZWxmIGNhbiBiZSBmb3JnZWQpLlxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RyaW5ncykgfHwgIUFycmF5LmlzQXJyYXkoc3RyaW5ncy5yYXcpIHx8XG4gICAgICAodmFsdWVzLmxlbmd0aCAhPT0gc3RyaW5ncy5sZW5ndGggLSAxKSkge1xuICAgIC8vIFRoaXMgaXMgZWl0aGVyIGNhdXNlZCBieSBhIGJyb3dzZXIgYnVnLCBhIGNvbXBpbGVyIGJ1Zywgb3Igc29tZW9uZVxuICAgIC8vIGNhbGxpbmcgdGhlIGh0bWwgdGVtcGxhdGUgdGFnIGZ1bmN0aW9uIGFzIGEgcmVndWxhciBmdW5jdGlvbi5cbiAgICAvL1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2FsbCB0byB0aGUgaHRtbCB0ZW1wbGF0ZSB0YWcnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBbiBodG1sIGxpdGVyYWwgdGFnIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgaHRtbGAgdG8gY29tcG9zZS5cbiAqIGEgbGl0ZXJhbCBzdHJpbmcuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAqICAgICAgIHJldHVybiBodG1sYFxuICogICAgICAgICA8c3R5bGU+XG4gKiAgICAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfVxuICogICAgICAgICAgICR7dGhpcy5zdHlsZVRlbXBsYXRlKCl9XG4gKiAgICAgICAgIDwvc3R5bGU+XG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJzaGFkb3dlZFwiPiR7c3RhdGljVmFsdWV9PC9kaXY+XG4gKiAgICAgICAgICR7c3VwZXIudGVtcGxhdGV9XG4gKiAgICAgICBgO1xuICogICAgIH1cbiAqICAgICBzdGF0aWMgZ2V0IHN0eWxlVGVtcGxhdGUoKSB7XG4gKiAgICAgICAgcmV0dXJuIGh0bWxMaXRlcmFsYC5zaGFkb3dlZCB7IGJhY2tncm91bmQ6IGdyYXk7IH1gO1xuICogICAgIH1cbiAqXG4gKiBAcGFyYW0geyFJVGVtcGxhdGVBcnJheX0gc3RyaW5ncyBDb25zdGFudCBwYXJ0cyBvZiB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFxuICogQHBhcmFtIHsuLi4qfSB2YWx1ZXMgVmFyaWFibGUgcGFydHMgb2YgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcbiAqIEByZXR1cm4geyFMaXRlcmFsU3RyaW5nfSBDb25zdHJ1Y3RlZCBsaXRlcmFsIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgaHRtbExpdGVyYWwgPSBmdW5jdGlvbihzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBMaXRlcmFsU3RyaW5nKHN0cmluZ3MsIHZhbHVlcyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/html-tag.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dedupingMixin\": () => (/* binding */ dedupingMixin)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n// unique global id for deduping mixins.\nlet dedupeId = 0;\n\n/**\n * @constructor\n * @extends {Function}\n * @private\n */\nfunction MixinFunction() {}\n/** @type {(WeakMap | undefined)} */\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet;\n\n/* eslint-disable valid-jsdoc */\n/**\n * Wraps an ES6 class expression mixin such that the mixin is only applied\n * if it has not already been applied its base argument. Also memoizes mixin\n * applications.\n *\n * @template T\n * @param {T} mixin ES6 class expression mixin to wrap\n * @return {T}\n * @suppress {invalidCasts}\n */\nconst dedupingMixin = function (mixin) {\n  let mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */\n    mixin.__mixinApplications = mixinApplications;\n  }\n  // maintain a unique id for each mixin\n  let mixinDedupeId = dedupeId++;\n  function dedupingMixin(base) {\n    let baseSet = /** @type {!MixinFunction} */base.__mixinSet;\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n    let map = mixinApplications;\n    let extended = map.get(base);\n    if (!extended) {\n      extended = /** @type {!Function} */mixin(base);\n      map.set(base, extended);\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      let mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n      /** @type {!MixinFunction} */\n      extended.__mixinSet = mixinSet;\n    }\n    return extended;\n  }\n  return dedupingMixin;\n};\n/* eslint-enable valid-jsdoc *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzPzhmZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnLi9ib290LmpzJztcblxuLy8gdW5pcXVlIGdsb2JhbCBpZCBmb3IgZGVkdXBpbmcgbWl4aW5zLlxubGV0IGRlZHVwZUlkID0gMDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtGdW5jdGlvbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIE1peGluRnVuY3Rpb24oKXt9XG4vKiogQHR5cGUgeyhXZWFrTWFwIHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4vKiogQHR5cGUgeyhPYmplY3QgfCB1bmRlZmluZWQpfSAqL1xuTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpblNldDtcblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbi8qKlxuICogV3JhcHMgYW4gRVM2IGNsYXNzIGV4cHJlc3Npb24gbWl4aW4gc3VjaCB0aGF0IHRoZSBtaXhpbiBpcyBvbmx5IGFwcGxpZWRcbiAqIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGFwcGxpZWQgaXRzIGJhc2UgYXJndW1lbnQuIEFsc28gbWVtb2l6ZXMgbWl4aW5cbiAqIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBtaXhpbiBFUzYgY2xhc3MgZXhwcmVzc2lvbiBtaXhpbiB0byB3cmFwXG4gKiBAcmV0dXJuIHtUfVxuICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgbGV0IG1peGluQXBwbGljYXRpb25zID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIGlmICghbWl4aW5BcHBsaWNhdGlvbnMpIHtcbiAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnMgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgfVxuICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICBsZXQgbWl4aW5EZWR1cGVJZCA9IGRlZHVwZUlkKys7XG4gIGZ1bmN0aW9uIGRlZHVwaW5nTWl4aW4oYmFzZSkge1xuICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICBpZiAoYmFzZVNldCAmJiBiYXNlU2V0W21peGluRGVkdXBlSWRdKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgbGV0IG1hcCA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIGxldCBleHRlbmRlZCA9IG1hcC5nZXQoYmFzZSk7XG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgZXh0ZW5kZWQgPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8obWl4aW4pKGJhc2UpO1xuICAgICAgbWFwLnNldChiYXNlLCBleHRlbmRlZCk7XG4gICAgICAvLyBjb3B5IGluaGVyaXRlZCBtaXhpbiBzZXQgZnJvbSB0aGUgZXh0ZW5kZWQgY2xhc3MsIG9yIHRoZSBiYXNlIGNsYXNzXG4gICAgICAvLyBOT1RFOiB3ZSBhdm9pZCB1c2Ugb2YgU2V0IGhlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXIgKElFMTEpXG4gICAgICAvLyBjYW5ub3QgZXh0ZW5kIGEgYmFzZSBTZXQgdmlhIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIGxldCBtaXhpblNldCA9IE9iamVjdC5jcmVhdGUoLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oZXh0ZW5kZWQpLl9fbWl4aW5TZXQgfHwgYmFzZVNldCB8fCBudWxsKTtcbiAgICAgIG1peGluU2V0W21peGluRGVkdXBlSWRdID0gdHJ1ZTtcbiAgICAgIC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0ID0gbWl4aW5TZXQ7XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfVxuXG4gIHJldHVybiBkZWR1cGluZ01peGluO1xufTtcbi8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/path.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/path.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"get\": () => (/* binding */ get),\n/* harmony export */   \"isAncestor\": () => (/* binding */ isAncestor),\n/* harmony export */   \"isDeep\": () => (/* binding */ isDeep),\n/* harmony export */   \"isDescendant\": () => (/* binding */ isDescendant),\n/* harmony export */   \"isPath\": () => (/* binding */ isPath),\n/* harmony export */   \"matches\": () => (/* binding */ matches),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"root\": () => (/* binding */ root),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"split\": () => (/* binding */ split),\n/* harmony export */   \"translate\": () => (/* binding */ translate)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * Module with utilities for manipulating structured data path strings.\n *\n * @summary Module with utilities for manipulating structured data path strings.\n */\n\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * Example:\n *\n * ```\n * isPath('foo.bar.baz') // true\n * isPath('foo')         // false\n * ```\n *\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\nfunction isPath(path) {\n  return path.indexOf('.') >= 0;\n}\n\n/**\n * Returns the root property name for the given path.\n *\n * Example:\n *\n * ```\n * root('foo.bar.baz') // 'foo'\n * root('foo')         // 'foo'\n * ```\n *\n * @param {string} path Path string\n * @return {string} Root property name\n */\nfunction root(path) {\n  let dotIndex = path.indexOf('.');\n  if (dotIndex === -1) {\n    return path;\n  }\n  return path.slice(0, dotIndex);\n}\n\n/**\n * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n * Returns true if the given path is an ancestor of the base path.\n *\n * Example:\n *\n * ```\n * isAncestor('foo.bar', 'foo')         // true\n * isAncestor('foo.bar', 'foo.bar')     // false\n * isAncestor('foo.bar', 'foo.bar.baz') // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is an ancestor of `base`.\n */\nfunction isAncestor(base, path) {\n  //     base.startsWith(path + '.');\n  return base.indexOf(path + '.') === 0;\n}\n\n/**\n * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n *\n * Example:\n *\n * ```\n * isDescendant('foo.bar', 'foo.bar.baz') // true\n * isDescendant('foo.bar', 'foo.bar')     // false\n * isDescendant('foo.bar', 'foo')         // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is a descendant of `base`.\n */\nfunction isDescendant(base, path) {\n  //     path.startsWith(base + '.');\n  return path.indexOf(base + '.') === 0;\n}\n\n/**\n * Replaces a previous base path with a new base path, preserving the\n * remainder of the path.\n *\n * User must ensure `path` has a prefix of `base`.\n *\n * Example:\n *\n * ```\n * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'\n * ```\n *\n * @param {string} base Current base string to remove\n * @param {string} newBase New base string to replace with\n * @param {string} path Path to translate\n * @return {string} Translated string\n */\nfunction translate(base, newBase, path) {\n  return newBase + path.slice(base.length);\n}\n\n/**\n * @param {string} base Path string to test against\n * @param {string} path Path string to test\n * @return {boolean} True if `path` is equal to `base`\n */\nfunction matches(base, path) {\n  return base === path || isAncestor(base, path) || isDescendant(base, path);\n}\n\n/**\n * Converts array-based paths to flattened path.  String-based paths\n * are returned as-is.\n *\n * Example:\n *\n * ```\n * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {string} Flattened path\n */\nfunction normalize(path) {\n  if (Array.isArray(path)) {\n    let parts = [];\n    for (let i = 0; i < path.length; i++) {\n      let args = path[i].toString().split('.');\n      for (let j = 0; j < args.length; j++) {\n        parts.push(args[j]);\n      }\n    }\n    return parts.join('.');\n  } else {\n    return path;\n  }\n}\n\n/**\n * Splits a path into an array of property names. Accepts either arrays\n * of path parts or strings.\n *\n * Example:\n *\n * ```\n * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {!Array<string>} Array of path parts\n * @suppress {checkTypes}\n */\nfunction split(path) {\n  if (Array.isArray(path)) {\n    return normalize(path).split('.');\n  }\n  return path.toString().split('.');\n}\n\n/**\n * Reads a value from a path.  If any sub-property in the path is `undefined`,\n * this method returns `undefined` (will never throw.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to read\n * @param {Object=} info If an object is provided to `info`, the normalized\n *  (flattened) path will be set to `info.path`.\n * @return {*} Value at path, or `undefined` if the path could not be\n *  fully dereferenced.\n */\nfunction get(root, path, info) {\n  let prop = root;\n  let parts = split(path);\n  // Loop over path parts[0..n-1] and dereference\n  for (let i = 0; i < parts.length; i++) {\n    if (!prop) {\n      return;\n    }\n    let part = parts[i];\n    prop = prop[part];\n  }\n  if (info) {\n    info.path = parts.join('.');\n  }\n  return prop;\n}\n\n/**\n * Sets a value to a path.  If any sub-property in the path is `undefined`,\n * this method will no-op.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to set\n * @param {*} value Value to set to path\n * @return {string | undefined} The normalized version of the input path\n */\nfunction set(root, path, value) {\n  let prop = root;\n  let parts = split(path);\n  let last = parts[parts.length - 1];\n  if (parts.length > 1) {\n    // Loop over path parts[0..n-2] and dereference\n    for (let i = 0; i < parts.length - 1; i++) {\n      let part = parts[i];\n      prop = prop[part];\n      if (!prop) {\n        return;\n      }\n    }\n    // Set value to object at end of path\n    prop[last] = value;\n  } else {\n    // Simple property set\n    prop[path] = value;\n  }\n  return parts.join('.');\n}\n\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * This function is deprecated.  Use `isPath` instead.\n *\n * Example:\n *\n * ```\n * isDeep('foo.bar.baz') // true\n * isDeep('foo')         // false\n * ```\n *\n * @deprecated\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\nconst isDeep = isPath;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmpzP2NkY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnLi9ib290LmpzJztcblxuLyoqXG4gKiBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIG1hbmlwdWxhdGluZyBzdHJ1Y3R1cmVkIGRhdGEgcGF0aCBzdHJpbmdzLlxuICpcbiAqIEBzdW1tYXJ5IE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIHN0cnVjdHVyZWQgZGF0YSBwYXRoIHN0cmluZ3MuXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHN0cnVjdHVyZWQgZGF0YSBwYXRoIChoYXMgZG90cykuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGlzUGF0aCgnZm9vLmJhci5iYXonKSAvLyB0cnVlXG4gKiBpc1BhdGgoJ2ZvbycpICAgICAgICAgLy8gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgY29udGFpbmVkIG9uZSBvciBtb3JlIGRvdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmluZGV4T2YoJy4nKSA+PSAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3QgcHJvcGVydHkgbmFtZSBmb3IgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIHJvb3QoJ2Zvby5iYXIuYmF6JykgLy8gJ2ZvbydcbiAqIHJvb3QoJ2ZvbycpICAgICAgICAgLy8gJ2ZvbydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJvb3QgcHJvcGVydHkgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcm9vdChwYXRoKSB7XG4gIGxldCBkb3RJbmRleCA9IHBhdGguaW5kZXhPZignLicpO1xuICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZG90SW5kZXgpO1xufVxuXG4vKipcbiAqIEdpdmVuIGBiYXNlYCBpcyBgZm9vLmJhcmAsIGBmb29gIGlzIGFuIGFuY2VzdG9yLCBgZm9vLmJhcmAgaXMgbm90XG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGggaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGJhc2UgcGF0aC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28nKSAgICAgICAgIC8vIHRydWVcbiAqIGlzQW5jZXN0b3IoJ2Zvby5iYXInLCAnZm9vLmJhcicpICAgICAvLyBmYWxzZVxuICogaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28uYmFyLmJheicpIC8vIGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgYW4gYW5jZXN0b3Igb2YgYGJhc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB7XG4gIC8vICAgICBiYXNlLnN0YXJ0c1dpdGgocGF0aCArICcuJyk7XG4gIHJldHVybiBiYXNlLmluZGV4T2YocGF0aCArICcuJykgPT09IDA7XG59XG5cbi8qKlxuICogR2l2ZW4gYGJhc2VgIGlzIGBmb28uYmFyYCwgYGZvby5iYXIuYmF6YCBpcyBhbiBkZXNjZW5kYW50XG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGlzRGVzY2VuZGFudCgnZm9vLmJhcicsICdmb28uYmFyLmJheicpIC8vIHRydWVcbiAqIGlzRGVzY2VuZGFudCgnZm9vLmJhcicsICdmb28uYmFyJykgICAgIC8vIGZhbHNlXG4gKiBpc0Rlc2NlbmRhbnQoJ2Zvby5iYXInLCAnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgUGF0aCBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0LlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmcgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGEgZGVzY2VuZGFudCBvZiBgYmFzZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgcGF0aC5zdGFydHNXaXRoKGJhc2UgKyAnLicpO1xuICByZXR1cm4gcGF0aC5pbmRleE9mKGJhc2UgKyAnLicpID09PSAwO1xufVxuXG4vKipcbiAqIFJlcGxhY2VzIGEgcHJldmlvdXMgYmFzZSBwYXRoIHdpdGggYSBuZXcgYmFzZSBwYXRoLCBwcmVzZXJ2aW5nIHRoZVxuICogcmVtYWluZGVyIG9mIHRoZSBwYXRoLlxuICpcbiAqIFVzZXIgbXVzdCBlbnN1cmUgYHBhdGhgIGhhcyBhIHByZWZpeCBvZiBgYmFzZWAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIHRyYW5zbGF0ZSgnZm9vLmJhcicsICd6b3QnLCAnZm9vLmJhci5iYXonKSAvLyAnem90LmJheidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIEN1cnJlbnQgYmFzZSBzdHJpbmcgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3QmFzZSBOZXcgYmFzZSBzdHJpbmcgdG8gcmVwbGFjZSB3aXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIHRyYW5zbGF0ZVxuICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2xhdGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKGJhc2UsIG5ld0Jhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIG5ld0Jhc2UgKyBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHBhdGhgIGlzIGVxdWFsIHRvIGBiYXNlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlcyhiYXNlLCBwYXRoKSB7XG4gIHJldHVybiAoYmFzZSA9PT0gcGF0aCkgfHxcbiAgICAgICAgIGlzQW5jZXN0b3IoYmFzZSwgcGF0aCkgfHxcbiAgICAgICAgIGlzRGVzY2VuZGFudChiYXNlLCBwYXRoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhcnJheS1iYXNlZCBwYXRocyB0byBmbGF0dGVuZWQgcGF0aC4gIFN0cmluZy1iYXNlZCBwYXRoc1xuICogYXJlIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiBub3JtYWxpemUoWydmb28uYmFyJywgMCwgJ2JheiddKSAgLy8gJ2Zvby5iYXIuMC5iYXonXG4gKiBub3JtYWxpemUoJ2Zvby5iYXIuMC5iYXonKSAgICAgICAgLy8gJ2Zvby5iYXIuMC5iYXonXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBJbnB1dCBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZsYXR0ZW5lZCBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXJncyA9IHBhdGhbaV0udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaj0wOyBqPGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhcmdzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuXG4vKipcbiAqIFNwbGl0cyBhIHBhdGggaW50byBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4gQWNjZXB0cyBlaXRoZXIgYXJyYXlzXG4gKiBvZiBwYXRoIHBhcnRzIG9yIHN0cmluZ3MuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIHNwbGl0KFsnZm9vLmJhcicsIDAsICdiYXonXSkgIC8vIFsnZm9vJywgJ2JhcicsICcwJywgJ2JheiddXG4gKiBzcGxpdCgnZm9vLmJhci4wLmJheicpICAgICAgICAvLyBbJ2ZvbycsICdiYXInLCAnMCcsICdiYXonXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggSW5wdXQgcGF0aFxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59IEFycmF5IG9mIHBhdGggcGFydHNcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHBhdGgpLnNwbGl0KCcuJyk7XG4gIH1cbiAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xufVxuXG4vKipcbiAqIFJlYWRzIGEgdmFsdWUgZnJvbSBhIHBhdGguICBJZiBhbnkgc3ViLXByb3BlcnR5IGluIHRoZSBwYXRoIGlzIGB1bmRlZmluZWRgLFxuICogdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCAod2lsbCBuZXZlciB0aHJvdy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcm9vdCBPYmplY3QgZnJvbSB3aGljaCB0byBkZXJlZmVyZW5jZSBwYXRoIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gcmVhZFxuICogQHBhcmFtIHtPYmplY3Q9fSBpbmZvIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCB0byBgaW5mb2AsIHRoZSBub3JtYWxpemVkXG4gKiAgKGZsYXR0ZW5lZCkgcGF0aCB3aWxsIGJlIHNldCB0byBgaW5mby5wYXRoYC5cbiAqIEByZXR1cm4geyp9IFZhbHVlIGF0IHBhdGgsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBwYXRoIGNvdWxkIG5vdCBiZVxuICogIGZ1bGx5IGRlcmVmZXJlbmNlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChyb290LCBwYXRoLCBpbmZvKSB7XG4gIGxldCBwcm9wID0gcm9vdDtcbiAgbGV0IHBhcnRzID0gc3BsaXQocGF0aCk7XG4gIC8vIExvb3Agb3ZlciBwYXRoIHBhcnRzWzAuLm4tMV0gYW5kIGRlcmVmZXJlbmNlXG4gIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghcHJvcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICB9XG4gIGlmIChpbmZvKSB7XG4gICAgaW5mby5wYXRoID0gcGFydHMuam9pbignLicpO1xuICB9XG4gIHJldHVybiBwcm9wO1xufVxuXG4vKipcbiAqIFNldHMgYSB2YWx1ZSB0byBhIHBhdGguICBJZiBhbnkgc3ViLXByb3BlcnR5IGluIHRoZSBwYXRoIGlzIGB1bmRlZmluZWRgLFxuICogdGhpcyBtZXRob2Qgd2lsbCBuby1vcC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcm9vdCBPYmplY3QgZnJvbSB3aGljaCB0byBkZXJlZmVyZW5jZSBwYXRoIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCB0byBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGlucHV0IHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChyb290LCBwYXRoLCB2YWx1ZSkge1xuICBsZXQgcHJvcCA9IHJvb3Q7XG4gIGxldCBwYXJ0cyA9IHNwbGl0KHBhdGgpO1xuICBsZXQgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTJdIGFuZCBkZXJlZmVyZW5jZVxuICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgcHJvcCA9IHByb3BbcGFydF07XG4gICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgdmFsdWUgdG8gb2JqZWN0IGF0IGVuZCBvZiBwYXRoXG4gICAgcHJvcFtsYXN0XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFNpbXBsZSBwcm9wZXJ0eSBzZXRcbiAgICBwcm9wW3BhdGhdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHN0cnVjdHVyZWQgZGF0YSBwYXRoIChoYXMgZG90cykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiAgVXNlIGBpc1BhdGhgIGluc3RlYWQuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGlzRGVlcCgnZm9vLmJhci5iYXonKSAvLyB0cnVlXG4gKiBpc0RlZXAoJ2ZvbycpICAgICAgICAgLy8gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGNvbnRhaW5lZCBvbmUgb3IgbW9yZSBkb3RzXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RlZXAgPSBpc1BhdGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/path.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/render-status.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/render-status.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"afterNextRender\": () => (/* binding */ afterNextRender),\n/* harmony export */   \"beforeNextRender\": () => (/* binding */ beforeNextRender),\n/* harmony export */   \"flush\": () => (/* binding */ flush)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module for scheduling flushable pre-render and post-render tasks.\n *\n * @summary Module for scheduling flushable pre-render and post-render tasks.\n */\n\n\nlet scheduled = false;\nlet beforeRenderQueue = [];\nlet afterRenderQueue = [];\nfunction schedule() {\n  scheduled = true;\n  // before next render\n  requestAnimationFrame(function () {\n    scheduled = false;\n    flushQueue(beforeRenderQueue);\n    // after the render\n    setTimeout(function () {\n      runQueue(afterRenderQueue);\n    });\n  });\n}\nfunction flushQueue(queue) {\n  while (queue.length) {\n    callMethod(queue.shift());\n  }\n}\nfunction runQueue(queue) {\n  for (let i = 0, l = queue.length; i < l; i++) {\n    callMethod(queue.shift());\n  }\n}\nfunction callMethod(info) {\n  const context = info[0];\n  const callback = info[1];\n  const args = info[2];\n  try {\n    callback.apply(context, args);\n  } catch (e) {\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\n/**\n * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`\n * tasks.\n *\n * @return {void}\n */\nfunction flush() {\n  while (beforeRenderQueue.length || afterRenderQueue.length) {\n    flushQueue(beforeRenderQueue);\n    flushQueue(afterRenderQueue);\n  }\n  scheduled = false;\n}\n\n/**\n * Enqueues a callback which will be run before the next render, at\n * `requestAnimationFrame` timing.\n *\n * This method is useful for enqueuing work that requires DOM measurement,\n * since measurement may not be reliable in custom element callbacks before\n * the first render, as well as for batching measurement tasks in general.\n *\n * Tasks in this queue may be flushed by calling `flush()`.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\nfunction beforeNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n  beforeRenderQueue.push([context, callback, args]);\n}\n\n/**\n * Enqueues a callback which will be run after the next render, equivalent\n * to one task (`setTimeout`) after the next `requestAnimationFrame`.\n *\n * This method is useful for tuning the first-render performance of an\n * element or application by deferring non-critical work until after the\n * first paint.  Typical non-render-critical work may include adding UI\n * event listeners and aria attributes.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\nfunction afterNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n  afterRenderQueue.push([context, callback, args]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzPzg1NzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyoqXG4gKiBNb2R1bGUgZm9yIHNjaGVkdWxpbmcgZmx1c2hhYmxlIHByZS1yZW5kZXIgYW5kIHBvc3QtcmVuZGVyIHRhc2tzLlxuICpcbiAqIEBzdW1tYXJ5IE1vZHVsZSBmb3Igc2NoZWR1bGluZyBmbHVzaGFibGUgcHJlLXJlbmRlciBhbmQgcG9zdC1yZW5kZXIgdGFza3MuXG4gKi9cblxuaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5sZXQgc2NoZWR1bGVkID0gZmFsc2U7XG5sZXQgYmVmb3JlUmVuZGVyUXVldWUgPSBbXTtcbmxldCBhZnRlclJlbmRlclF1ZXVlID0gW107XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICBzY2hlZHVsZWQgPSB0cnVlO1xuICAvLyBiZWZvcmUgbmV4dCByZW5kZXJcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGZsdXNoUXVldWUoYmVmb3JlUmVuZGVyUXVldWUpO1xuICAgIC8vIGFmdGVyIHRoZSByZW5kZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcnVuUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmbHVzaFF1ZXVlKHF1ZXVlKSB7XG4gIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICBjYWxsTWV0aG9kKHF1ZXVlLnNoaWZ0KCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG4gIGZvciAobGV0IGk9MCwgbD1xdWV1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjYWxsTWV0aG9kKHF1ZXVlLnNoaWZ0KCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxNZXRob2QoaW5mbykge1xuICBjb25zdCBjb250ZXh0ID0gaW5mb1swXTtcbiAgY29uc3QgY2FsbGJhY2sgPSBpbmZvWzFdO1xuICBjb25zdCBhcmdzID0gaW5mb1syXTtcbiAgdHJ5IHtcbiAgICBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRmx1c2hlcyBhbGwgYGJlZm9yZU5leHRSZW5kZXJgIHRhc2tzLCBmb2xsb3dlZCBieSBhbGwgYGFmdGVyTmV4dFJlbmRlcmBcbiAqIHRhc2tzLlxuICpcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgd2hpbGUgKGJlZm9yZVJlbmRlclF1ZXVlLmxlbmd0aCB8fCBhZnRlclJlbmRlclF1ZXVlLmxlbmd0aCkge1xuICAgIGZsdXNoUXVldWUoYmVmb3JlUmVuZGVyUXVldWUpO1xuICAgIGZsdXNoUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gIH1cbiAgc2NoZWR1bGVkID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgcnVuIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIsIGF0XG4gKiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBlbnF1ZXVpbmcgd29yayB0aGF0IHJlcXVpcmVzIERPTSBtZWFzdXJlbWVudCxcbiAqIHNpbmNlIG1lYXN1cmVtZW50IG1heSBub3QgYmUgcmVsaWFibGUgaW4gY3VzdG9tIGVsZW1lbnQgY2FsbGJhY2tzIGJlZm9yZVxuICogdGhlIGZpcnN0IHJlbmRlciwgYXMgd2VsbCBhcyBmb3IgYmF0Y2hpbmcgbWVhc3VyZW1lbnQgdGFza3MgaW4gZ2VuZXJhbC5cbiAqXG4gKiBUYXNrcyBpbiB0aGlzIHF1ZXVlIG1heSBiZSBmbHVzaGVkIGJ5IGNhbGxpbmcgYGZsdXNoKClgLlxuICpcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IG9iamVjdCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBib3VuZCB0b1xuICogQHBhcmFtIHtmdW5jdGlvbiguLi4qKTp2b2lkfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHshQXJyYXk9fSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYmVmb3JlUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgcnVuIGFmdGVyIHRoZSBuZXh0IHJlbmRlciwgZXF1aXZhbGVudFxuICogdG8gb25lIHRhc2sgKGBzZXRUaW1lb3V0YCkgYWZ0ZXIgdGhlIG5leHQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciB0dW5pbmcgdGhlIGZpcnN0LXJlbmRlciBwZXJmb3JtYW5jZSBvZiBhblxuICogZWxlbWVudCBvciBhcHBsaWNhdGlvbiBieSBkZWZlcnJpbmcgbm9uLWNyaXRpY2FsIHdvcmsgdW50aWwgYWZ0ZXIgdGhlXG4gKiBmaXJzdCBwYWludC4gIFR5cGljYWwgbm9uLXJlbmRlci1jcml0aWNhbCB3b3JrIG1heSBpbmNsdWRlIGFkZGluZyBVSVxuICogZXZlbnQgbGlzdGVuZXJzIGFuZCBhcmlhIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgb2JqZWN0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGJvdW5kIHRvXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopOnZvaWR9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFBcnJheT19IGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlck5leHRSZW5kZXIoY29udGV4dCwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICBzY2hlZHVsZSgpO1xuICB9XG4gIGFmdGVyUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/render-status.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/resolve-url.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/resolve-url.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pathFromUrl\": () => (/* binding */ pathFromUrl),\n/* harmony export */   \"resolveCss\": () => (/* binding */ resolveCss),\n/* harmony export */   \"resolveUrl\": () => (/* binding */ resolveUrl)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nlet CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nlet ABS_URL = /(^\\/[^\\/])|(^#)|(^[\\w-\\d]*:)/;\nlet workingURL;\nlet resolveDoc;\n/**\n * Resolves the given URL against the provided `baseUri'.\n *\n * Note that this function performs no resolution for URLs that start\n * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n * URL resolution, use `window.URL`.\n *\n * @param {string} url Input URL to resolve\n * @param {?string=} baseURI Base URI to resolve the URL against\n * @return {string} resolved URL\n */\nfunction resolveUrl(url, baseURI) {\n  if (url && ABS_URL.test(url)) {\n    return url;\n  }\n  if (url === '//') {\n    return url;\n  }\n  // Lazy feature detection.\n  if (workingURL === undefined) {\n    workingURL = false;\n    try {\n      const u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = u.href === 'http://a/c%20d';\n    } catch (e) {\n      // silently fail\n    }\n  }\n  if (!baseURI) {\n    baseURI = document.baseURI || window.location.href;\n  }\n  if (workingURL) {\n    try {\n      return new URL(url, baseURI).href;\n    } catch (e) {\n      // Bad url or baseURI structure. Do not attempt to resolve.\n      return url;\n    }\n  }\n  // Fallback to creating an anchor into a disconnected document.\n  if (!resolveDoc) {\n    resolveDoc = document.implementation.createHTMLDocument('temp');\n    resolveDoc.base = resolveDoc.createElement('base');\n    resolveDoc.head.appendChild(resolveDoc.base);\n    resolveDoc.anchor = resolveDoc.createElement('a');\n    resolveDoc.body.appendChild(resolveDoc.anchor);\n  }\n  resolveDoc.base.href = baseURI;\n  resolveDoc.anchor.href = url;\n  return resolveDoc.anchor.href || url;\n}\n\n/**\n * Resolves any relative URL's in the given CSS text against the provided\n * `ownerDocument`'s `baseURI`.\n *\n * @param {string} cssText CSS text to process\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Processed CSS text with resolved URL's\n */\nfunction resolveCss(cssText, baseURI) {\n  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\n    return pre + '\\'' + resolveUrl(url.replace(/[\"']/g, ''), baseURI) + '\\'' + post;\n  });\n}\n\n/**\n * Returns a path from a given `url`. The path includes the trailing\n * `/` from the url.\n *\n * @param {string} url Input URL to transform\n * @return {string} resolved path\n */\nfunction pathFromUrl(url) {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3Jlc29sdmUtdXJsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5qcz9lZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG5sZXQgQUJTX1VSTCA9IC8oXlxcL1teXFwvXSl8KF4jKXwoXltcXHctXFxkXSo6KS87XG5sZXQgd29ya2luZ1VSTDtcbmxldCByZXNvbHZlRG9jO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gVVJMIGFnYWluc3QgdGhlIHByb3ZpZGVkIGBiYXNlVXJpJy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBubyByZXNvbHV0aW9uIGZvciBVUkxzIHRoYXQgc3RhcnRcbiAqIHdpdGggYC9gIChhYnNvbHV0ZSBVUkxzKSBvciBgI2AgKGhhc2ggaWRlbnRpZmllcnMpLiAgRm9yIGdlbmVyYWwgcHVycG9zZVxuICogVVJMIHJlc29sdXRpb24sIHVzZSBgd2luZG93LlVSTGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBJbnB1dCBVUkwgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHs/c3RyaW5nPX0gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBVUkxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVVcmwodXJsLCBiYXNlVVJJKSB7XG4gIGlmICh1cmwgJiYgQUJTX1VSTC50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGlmICh1cmwgPT09ICcvLycpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIExhenkgZmVhdHVyZSBkZXRlY3Rpb24uXG4gIGlmICh3b3JraW5nVVJMID09PSB1bmRlZmluZWQpIHtcbiAgICB3b3JraW5nVVJMID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICB1LnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgICAgIHdvcmtpbmdVUkwgPSAodS5ocmVmID09PSAnaHR0cDovL2EvYyUyMGQnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBmYWlsXG4gICAgfVxuICB9XG4gIGlmICghYmFzZVVSSSkge1xuICAgIGJhc2VVUkkgPSBkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG4gIGlmICh3b3JraW5nVVJMKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAobmV3IFVSTCh1cmwsIGJhc2VVUkkpKS5ocmVmO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEJhZCB1cmwgb3IgYmFzZVVSSSBzdHJ1Y3R1cmUuIERvIG5vdCBhdHRlbXB0IHRvIHJlc29sdmUuXG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgfVxuICAvLyBGYWxsYmFjayB0byBjcmVhdGluZyBhbiBhbmNob3IgaW50byBhIGRpc2Nvbm5lY3RlZCBkb2N1bWVudC5cbiAgaWYgKCFyZXNvbHZlRG9jKSB7XG4gICAgcmVzb2x2ZURvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgndGVtcCcpO1xuICAgIHJlc29sdmVEb2MuYmFzZSA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYmFzZScpO1xuICAgIHJlc29sdmVEb2MuaGVhZC5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmJhc2UpO1xuICAgIHJlc29sdmVEb2MuYW5jaG9yID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgcmVzb2x2ZURvYy5ib2R5LmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYW5jaG9yKTtcbiAgfVxuICByZXNvbHZlRG9jLmJhc2UuaHJlZiA9IGJhc2VVUkk7XG4gIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgPSB1cmw7XG4gIHJldHVybiByZXNvbHZlRG9jLmFuY2hvci5ocmVmIHx8IHVybDtcblxufVxuXG4vKipcbiAqIFJlc29sdmVzIGFueSByZWxhdGl2ZSBVUkwncyBpbiB0aGUgZ2l2ZW4gQ1NTIHRleHQgYWdhaW5zdCB0aGUgcHJvdmlkZWRcbiAqIGBvd25lckRvY3VtZW50YCdzIGBiYXNlVVJJYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dCBDU1MgdGV4dCB0byBwcm9jZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICogQHJldHVybiB7c3RyaW5nfSBQcm9jZXNzZWQgQ1NTIHRleHQgd2l0aCByZXNvbHZlZCBVUkwnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNzcyhjc3NUZXh0LCBiYXNlVVJJKSB7XG4gIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoQ1NTX1VSTF9SWCwgZnVuY3Rpb24obSwgcHJlLCB1cmwsIHBvc3QpIHtcbiAgICByZXR1cm4gcHJlICsgJ1xcJycgK1xuICAgICAgcmVzb2x2ZVVybCh1cmwucmVwbGFjZSgvW1wiJ10vZywgJycpLCBiYXNlVVJJKSArXG4gICAgICAnXFwnJyArIHBvc3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIGZyb20gYSBnaXZlbiBgdXJsYC4gVGhlIHBhdGggaW5jbHVkZXMgdGhlIHRyYWlsaW5nXG4gKiBgL2AgZnJvbSB0aGUgdXJsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHRyYW5zZm9ybVxuICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/resolve-url.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/settings.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/settings.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"allowTemplateFromDomModule\": () => (/* binding */ allowTemplateFromDomModule),\n/* harmony export */   \"cancelSyntheticClickEvents\": () => (/* binding */ cancelSyntheticClickEvents),\n/* harmony export */   \"fastDomIf\": () => (/* binding */ fastDomIf),\n/* harmony export */   \"getSanitizeDOMValue\": () => (/* binding */ getSanitizeDOMValue),\n/* harmony export */   \"legacyNoObservedAttributes\": () => (/* binding */ legacyNoObservedAttributes),\n/* harmony export */   \"legacyOptimizations\": () => (/* binding */ legacyOptimizations),\n/* harmony export */   \"legacyUndefined\": () => (/* binding */ legacyUndefined),\n/* harmony export */   \"legacyWarnings\": () => (/* binding */ legacyWarnings),\n/* harmony export */   \"orderedComputed\": () => (/* binding */ orderedComputed),\n/* harmony export */   \"passiveTouchGestures\": () => (/* binding */ passiveTouchGestures),\n/* harmony export */   \"removeNestedTemplates\": () => (/* binding */ removeNestedTemplates),\n/* harmony export */   \"rootPath\": () => (/* binding */ rootPath),\n/* harmony export */   \"sanitizeDOMValue\": () => (/* binding */ sanitizeDOMValue),\n/* harmony export */   \"setAllowTemplateFromDomModule\": () => (/* binding */ setAllowTemplateFromDomModule),\n/* harmony export */   \"setCancelSyntheticClickEvents\": () => (/* binding */ setCancelSyntheticClickEvents),\n/* harmony export */   \"setFastDomIf\": () => (/* binding */ setFastDomIf),\n/* harmony export */   \"setLegacyNoObservedAttributes\": () => (/* binding */ setLegacyNoObservedAttributes),\n/* harmony export */   \"setLegacyOptimizations\": () => (/* binding */ setLegacyOptimizations),\n/* harmony export */   \"setLegacyUndefined\": () => (/* binding */ setLegacyUndefined),\n/* harmony export */   \"setLegacyWarnings\": () => (/* binding */ setLegacyWarnings),\n/* harmony export */   \"setOrderedComputed\": () => (/* binding */ setOrderedComputed),\n/* harmony export */   \"setPassiveTouchGestures\": () => (/* binding */ setPassiveTouchGestures),\n/* harmony export */   \"setRemoveNestedTemplates\": () => (/* binding */ setRemoveNestedTemplates),\n/* harmony export */   \"setRootPath\": () => (/* binding */ setRootPath),\n/* harmony export */   \"setSanitizeDOMValue\": () => (/* binding */ setSanitizeDOMValue),\n/* harmony export */   \"setStrictTemplatePolicy\": () => (/* binding */ setStrictTemplatePolicy),\n/* harmony export */   \"setSuppressTemplateNotifications\": () => (/* binding */ setSuppressTemplateNotifications),\n/* harmony export */   \"setSyncInitialRender\": () => (/* binding */ setSyncInitialRender),\n/* harmony export */   \"setUseAdoptedStyleSheetsWithBuiltCSS\": () => (/* binding */ setUseAdoptedStyleSheetsWithBuiltCSS),\n/* harmony export */   \"strictTemplatePolicy\": () => (/* binding */ strictTemplatePolicy),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* binding */ supportsAdoptingStyleSheets),\n/* harmony export */   \"suppressTemplateNotifications\": () => (/* binding */ suppressTemplateNotifications),\n/* harmony export */   \"syncInitialRender\": () => (/* binding */ syncInitialRender),\n/* harmony export */   \"useAdoptedStyleSheetsWithBuiltCSS\": () => (/* binding */ useAdoptedStyleSheetsWithBuiltCSS),\n/* harmony export */   \"useNativeCSSProperties\": () => (/* binding */ useNativeCSSProperties),\n/* harmony export */   \"useNativeCustomElements\": () => (/* binding */ useNativeCustomElements),\n/* harmony export */   \"useShadow\": () => (/* binding */ useShadow)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nconst useShadow = !window.ShadyDOM || !window.ShadyDOM.inUse;\nconst useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\nconst useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;\nconst supportsAdoptingStyleSheets = useShadow && 'adoptedStyleSheets' in Document.prototype && 'replaceSync' in CSSStyleSheet.prototype &&\n// Since spec may change, feature detect exact API we need\n(() => {\n  try {\n    const sheet = new CSSStyleSheet();\n    sheet.replaceSync('');\n    const host = document.createElement('div');\n    host.attachShadow({\n      mode: 'open'\n    });\n    host.shadowRoot.adoptedStyleSheets = [sheet];\n    return host.shadowRoot.adoptedStyleSheets[0] === sheet;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * Globally settable property that is automatically assigned to\n * `ElementMixin` instances, useful for binding in templates to\n * make URL's relative to an application's root.  Defaults to the main\n * document URL, but can be overridden by users.  It may be useful to set\n * `rootPath` to provide a stable application mount path when\n * using client side routing.\n */\nlet rootPath = window.Polymer && window.Polymer.rootPath || (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.pathFromUrl)(document.baseURI || window.location.href);\n\n/**\n * Sets the global rootPath property used by `ElementMixin` and\n * available via `rootPath`.\n *\n * @param {string} path The new root path\n * @return {void}\n */\nconst setRootPath = function (path) {\n  rootPath = path;\n};\n\n/**\n * A global callback used to sanitize any value before inserting it into the DOM.\n * The callback signature is:\n *\n *  function sanitizeDOMValue(value, name, type, node) { ... }\n *\n * Where:\n *\n * `value` is the value to sanitize.\n * `name` is the name of an attribute or property (for example, href).\n * `type` indicates where the value is being inserted: one of property, attribute, or text.\n * `node` is the node where the value is being inserted.\n *\n * @type {(function(*,string,string,?Node):*)|undefined}\n */\nlet sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || undefined;\n\n/**\n * Sets the global sanitizeDOMValue available via this module's exported\n * `sanitizeDOMValue` variable.\n *\n * @param {(function(*,string,string,?Node):*)|undefined} newSanitizeDOMValue the global sanitizeDOMValue callback\n * @return {void}\n */\nconst setSanitizeDOMValue = function (newSanitizeDOMValue) {\n  sanitizeDOMValue = newSanitizeDOMValue;\n};\n\n/**\n * Gets sanitizeDOMValue, for environments that don't well support `export let`.\n *\n * @return {(function(*,string,string,?Node):*)|undefined} sanitizeDOMValue\n */\nconst getSanitizeDOMValue = function () {\n  return sanitizeDOMValue;\n};\n\n/**\n * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.\n * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother\n * scrolling performance.\n * Defaults to `false` for backwards compatibility.\n */\nlet passiveTouchGestures = window.Polymer && window.Polymer.setPassiveTouchGestures || false;\n\n/**\n * Sets `passiveTouchGestures` globally for all elements using Polymer Gestures.\n *\n * @param {boolean} usePassive enable or disable passive touch gestures globally\n * @return {void}\n */\nconst setPassiveTouchGestures = function (usePassive) {\n  passiveTouchGestures = usePassive;\n};\n\n/**\n * Setting to ensure Polymer template evaluation only occurs based on tempates\n * defined in trusted script.  When true, `<dom-module>` re-registration is\n * disallowed, `<dom-bind>` is disabled, and `<dom-if>`/`<dom-repeat>`\n * templates will only evaluate in the context of a trusted element template.\n */\nlet strictTemplatePolicy = window.Polymer && window.Polymer.strictTemplatePolicy || false;\n\n/**\n * Sets `strictTemplatePolicy` globally for all elements\n *\n * @param {boolean} useStrictPolicy enable or disable strict template policy\n *   globally\n * @return {void}\n */\nconst setStrictTemplatePolicy = function (useStrictPolicy) {\n  strictTemplatePolicy = useStrictPolicy;\n};\n\n/**\n * Setting to enable dom-module lookup from Polymer.Element.  By default,\n * templates must be defined in script using the `static get template()`\n * getter and the `html` tag function.  To enable legacy loading of templates\n * via dom-module, set this flag to true.\n */\nlet allowTemplateFromDomModule = window.Polymer && window.Polymer.allowTemplateFromDomModule || false;\n\n/**\n * Sets `lookupTemplateFromDomModule` globally for all elements\n *\n * @param {boolean} allowDomModule enable or disable template lookup\n *   globally\n * @return {void}\n */\nconst setAllowTemplateFromDomModule = function (allowDomModule) {\n  allowTemplateFromDomModule = allowDomModule;\n};\n\n/**\n * Setting to skip processing style includes and re-writing urls in css styles.\n * Normally \"included\" styles are pulled into the element and all urls in styles\n * are re-written to be relative to the containing script url.\n * If no includes or relative urls are used in styles, these steps can be\n * skipped as an optimization.\n */\nlet legacyOptimizations = window.Polymer && window.Polymer.legacyOptimizations || false;\n\n/**\n * Sets `legacyOptimizations` globally for all elements to enable optimizations\n * when only legacy based elements are used.\n *\n * @param {boolean} useLegacyOptimizations enable or disable legacy optimizations\n * includes and url rewriting\n * @return {void}\n */\nconst setLegacyOptimizations = function (useLegacyOptimizations) {\n  legacyOptimizations = useLegacyOptimizations;\n};\n\n/**\n * Setting to add warnings useful when migrating from Polymer 1.x to 2.x.\n */\nlet legacyWarnings = window.Polymer && window.Polymer.legacyWarnings || false;\n\n/**\n * Sets `legacyWarnings` globally for all elements to migration warnings.\n *\n * @param {boolean} useLegacyWarnings enable or disable warnings\n * @return {void}\n */\nconst setLegacyWarnings = function (useLegacyWarnings) {\n  legacyWarnings = useLegacyWarnings;\n};\n\n/**\n * Setting to perform initial rendering synchronously when running under ShadyDOM.\n * This matches the behavior of Polymer 1.\n */\nlet syncInitialRender = window.Polymer && window.Polymer.syncInitialRender || false;\n\n/**\n * Sets `syncInitialRender` globally for all elements to enable synchronous\n * initial rendering.\n *\n * @param {boolean} useSyncInitialRender enable or disable synchronous initial\n * rendering globally.\n * @return {void}\n */\nconst setSyncInitialRender = function (useSyncInitialRender) {\n  syncInitialRender = useSyncInitialRender;\n};\n\n/**\n * Setting to retain the legacy Polymer 1 behavior for multi-property\n * observers around undefined values. Observers and computed property methods\n * are not called until no argument is undefined.\n */\nlet legacyUndefined = window.Polymer && window.Polymer.legacyUndefined || false;\n\n/**\n * Sets `legacyUndefined` globally for all elements to enable legacy\n * multi-property behavior for undefined values.\n *\n * @param {boolean} useLegacyUndefined enable or disable legacy\n * multi-property behavior for undefined.\n * @return {void}\n */\nconst setLegacyUndefined = function (useLegacyUndefined) {\n  legacyUndefined = useLegacyUndefined;\n};\n\n/**\n * Setting to ensure computed properties are computed in order to ensure\n * re-computation never occurs in a given turn.\n */\nlet orderedComputed = window.Polymer && window.Polymer.orderedComputed || false;\n\n/**\n * Sets `orderedComputed` globally for all elements to enable ordered computed\n * property computation.\n *\n * @param {boolean} useOrderedComputed enable or disable ordered computed effects\n * @return {void}\n */\nconst setOrderedComputed = function (useOrderedComputed) {\n  orderedComputed = useOrderedComputed;\n};\n\n/**\n * Setting to cancel synthetic click events fired by older mobile browsers. Modern browsers\n * no longer fire synthetic click events, and the cancellation behavior can interfere\n * when programmatically clicking on elements.\n */\nlet cancelSyntheticClickEvents = true;\n\n/**\n * Sets `setCancelSyntheticEvents` globally for all elements to cancel synthetic click events.\n *\n * @param {boolean} useCancelSyntheticClickEvents enable or disable cancelling synthetic\n * events\n * @return {void}\n */\nconst setCancelSyntheticClickEvents = function (useCancelSyntheticClickEvents) {\n  cancelSyntheticClickEvents = useCancelSyntheticClickEvents;\n};\n\n/**\n * Setting to remove nested templates inside `dom-if` and `dom-repeat` as\n * part of element template parsing.  This is a performance optimization that\n * eliminates most of the tax of needing two elements due to the loss of\n * type-extended templates as a result of the V1 specification changes.\n */\nlet removeNestedTemplates = window.Polymer && window.Polymer.removeNestedTemplates || false;\n\n/**\n * Sets `removeNestedTemplates` globally, to eliminate nested templates\n * inside `dom-if` and `dom-repeat` as part of template parsing.\n *\n * @param {boolean} useRemoveNestedTemplates enable or disable removing nested\n *   templates during parsing\n * @return {void}\n */\nconst setRemoveNestedTemplates = function (useRemoveNestedTemplates) {\n  removeNestedTemplates = useRemoveNestedTemplates;\n};\n\n/**\n * Setting to place `dom-if` elements in a performance-optimized mode that takes\n * advantage of lighter-weight host runtime template stamping to eliminate the\n * need for an intermediate Templatizer `TemplateInstance` to mange the nodes\n * stamped by `dom-if`.  Under this setting, any Templatizer-provided API's\n * such as `modelForElement` will not be available for nodes stamped by\n * `dom-if`.\n */\nlet fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;\n\n/**\n * Sets `fastDomIf` globally, to put `dom-if` in a performance-optimized mode.\n *\n * @param {boolean} useFastDomIf enable or disable `dom-if` fast-mode\n * @return {void}\n */\nconst setFastDomIf = function (useFastDomIf) {\n  fastDomIf = useFastDomIf;\n};\n\n/**\n * Setting to disable `dom-change` and `rendered-item-count` events from\n * `dom-if` and `dom-repeat`. Users can opt back into `dom-change` events by\n * setting the `notify-dom-change` attribute (`notifyDomChange: true` property)\n * to `dom-if`/`don-repeat` instances.\n */\nlet suppressTemplateNotifications = window.Polymer && window.Polymer.suppressTemplateNotifications || false;\n\n/**\n * Sets `suppressTemplateNotifications` globally, to disable `dom-change` and\n * `rendered-item-count` events from `dom-if` and `dom-repeat`.\n *\n * @param {boolean} suppress enable or disable `suppressTemplateNotifications`\n * @return {void}\n */\nconst setSuppressTemplateNotifications = function (suppress) {\n  suppressTemplateNotifications = suppress;\n};\n\n/**\n * Setting to disable use of dynamic attributes. This is an optimization\n * to avoid setting `observedAttributes`. Instead attributes are read\n * once at create time and set/removeAttribute are patched.\n */\nlet legacyNoObservedAttributes = window.Polymer && window.Polymer.legacyNoObservedAttributes || false;\n\n/**\n * Sets `legacyNoObservedAttributes` globally, to disable `observedAttributes`.\n *\n * @param {boolean} noObservedAttributes enable or disable `legacyNoObservedAttributes`\n * @return {void}\n */\nconst setLegacyNoObservedAttributes = function (noObservedAttributes) {\n  legacyNoObservedAttributes = noObservedAttributes;\n};\n\n/**\n * Setting to enable use of `adoptedStyleSheets` for sharing style sheets\n * between component instances' shadow roots, if the app uses built Shady CSS\n * styles.\n */\nlet useAdoptedStyleSheetsWithBuiltCSS = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;\n\n/**\n * Sets `useAdoptedStyleSheetsWithBuiltCSS` globally.\n *\n * @param {boolean} value enable or disable `useAdoptedStyleSheetsWithBuiltCSS`\n * @return {void}\n */\nconst setUseAdoptedStyleSheetsWithBuiltCSS = function (value) {\n  useAdoptedStyleSheetsWithBuiltCSS = value;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzPzkwODMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IHBhdGhGcm9tVXJsIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5leHBvcnQgY29uc3QgdXNlU2hhZG93ID0gISh3aW5kb3cuU2hhZHlET00pIHx8ICEod2luZG93LlNoYWR5RE9NLmluVXNlKTtcbmV4cG9ydCBjb25zdCB1c2VOYXRpdmVDU1NQcm9wZXJ0aWVzID0gQm9vbGVhbighd2luZG93LlNoYWR5Q1NTIHx8IHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MpO1xuZXhwb3J0IGNvbnN0IHVzZU5hdGl2ZUN1c3RvbUVsZW1lbnRzID0gISh3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayk7XG5leHBvcnQgY29uc3Qgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzID0gdXNlU2hhZG93ICYmXG4gICAgKCdhZG9wdGVkU3R5bGVTaGVldHMnIGluIERvY3VtZW50LnByb3RvdHlwZSkgJiZcbiAgICAoJ3JlcGxhY2VTeW5jJyBpbiBDU1NTdHlsZVNoZWV0LnByb3RvdHlwZSkgJiZcbiAgICAvLyBTaW5jZSBzcGVjIG1heSBjaGFuZ2UsIGZlYXR1cmUgZGV0ZWN0IGV4YWN0IEFQSSB3ZSBuZWVkXG4gICAgKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICAgICAgc2hlZXQucmVwbGFjZVN5bmMoJycpO1xuICAgICAgICBjb25zdCBob3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGhvc3QuYXR0YWNoU2hhZG93KHttb2RlOiAnb3Blbid9KTtcbiAgICAgICAgaG9zdC5zaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFtzaGVldF07XG4gICAgICAgIHJldHVybiAoaG9zdC5zaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0c1swXSA9PT0gc2hlZXQpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4vKipcbiAqIEdsb2JhbGx5IHNldHRhYmxlIHByb3BlcnR5IHRoYXQgaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0b1xuICogYEVsZW1lbnRNaXhpbmAgaW5zdGFuY2VzLCB1c2VmdWwgZm9yIGJpbmRpbmcgaW4gdGVtcGxhdGVzIHRvXG4gKiBtYWtlIFVSTCdzIHJlbGF0aXZlIHRvIGFuIGFwcGxpY2F0aW9uJ3Mgcm9vdC4gIERlZmF1bHRzIHRvIHRoZSBtYWluXG4gKiBkb2N1bWVudCBVUkwsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB1c2Vycy4gIEl0IG1heSBiZSB1c2VmdWwgdG8gc2V0XG4gKiBgcm9vdFBhdGhgIHRvIHByb3ZpZGUgYSBzdGFibGUgYXBwbGljYXRpb24gbW91bnQgcGF0aCB3aGVuXG4gKiB1c2luZyBjbGllbnQgc2lkZSByb3V0aW5nLlxuICovXG5leHBvcnQgbGV0IHJvb3RQYXRoID0gd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIucm9vdFBhdGggfHxcbiAgcGF0aEZyb21VcmwoZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbi8qKlxuICogU2V0cyB0aGUgZ2xvYmFsIHJvb3RQYXRoIHByb3BlcnR5IHVzZWQgYnkgYEVsZW1lbnRNaXhpbmAgYW5kXG4gKiBhdmFpbGFibGUgdmlhIGByb290UGF0aGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIG5ldyByb290IHBhdGhcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRSb290UGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcm9vdFBhdGggPSBwYXRoO1xufTtcblxuLyoqXG4gKiBBIGdsb2JhbCBjYWxsYmFjayB1c2VkIHRvIHNhbml0aXplIGFueSB2YWx1ZSBiZWZvcmUgaW5zZXJ0aW5nIGl0IGludG8gdGhlIERPTS5cbiAqIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4gKlxuICogIGZ1bmN0aW9uIHNhbml0aXplRE9NVmFsdWUodmFsdWUsIG5hbWUsIHR5cGUsIG5vZGUpIHsgLi4uIH1cbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiBgdmFsdWVgIGlzIHRoZSB2YWx1ZSB0byBzYW5pdGl6ZS5cbiAqIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiBhbiBhdHRyaWJ1dGUgb3IgcHJvcGVydHkgKGZvciBleGFtcGxlLCBocmVmKS5cbiAqIGB0eXBlYCBpbmRpY2F0ZXMgd2hlcmUgdGhlIHZhbHVlIGlzIGJlaW5nIGluc2VydGVkOiBvbmUgb2YgcHJvcGVydHksIGF0dHJpYnV0ZSwgb3IgdGV4dC5cbiAqIGBub2RlYCBpcyB0aGUgbm9kZSB3aGVyZSB0aGUgdmFsdWUgaXMgYmVpbmcgaW5zZXJ0ZWQuXG4gKlxuICogQHR5cGUgeyhmdW5jdGlvbigqLHN0cmluZyxzdHJpbmcsP05vZGUpOiopfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGxldCBzYW5pdGl6ZURPTVZhbHVlID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIuc2FuaXRpemVET01WYWx1ZSB8fCB1bmRlZmluZWQ7XG5cbi8qKlxuICogU2V0cyB0aGUgZ2xvYmFsIHNhbml0aXplRE9NVmFsdWUgYXZhaWxhYmxlIHZpYSB0aGlzIG1vZHVsZSdzIGV4cG9ydGVkXG4gKiBgc2FuaXRpemVET01WYWx1ZWAgdmFyaWFibGUuXG4gKlxuICogQHBhcmFtIHsoZnVuY3Rpb24oKixzdHJpbmcsc3RyaW5nLD9Ob2RlKToqKXx1bmRlZmluZWR9IG5ld1Nhbml0aXplRE9NVmFsdWUgdGhlIGdsb2JhbCBzYW5pdGl6ZURPTVZhbHVlIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0U2FuaXRpemVET01WYWx1ZSA9IGZ1bmN0aW9uKG5ld1Nhbml0aXplRE9NVmFsdWUpIHtcbiAgc2FuaXRpemVET01WYWx1ZSA9IG5ld1Nhbml0aXplRE9NVmFsdWU7XG59O1xuXG4vKipcbiAqIEdldHMgc2FuaXRpemVET01WYWx1ZSwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHdlbGwgc3VwcG9ydCBgZXhwb3J0IGxldGAuXG4gKlxuICogQHJldHVybiB7KGZ1bmN0aW9uKCosc3RyaW5nLHN0cmluZyw/Tm9kZSk6Kil8dW5kZWZpbmVkfSBzYW5pdGl6ZURPTVZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTYW5pdGl6ZURPTVZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBzYW5pdGl6ZURPTVZhbHVlO1xufTtcblxuLyoqXG4gKiBHbG9iYWxseSBzZXR0YWJsZSBwcm9wZXJ0eSB0byBtYWtlIFBvbHltZXIgR2VzdHVyZXMgdXNlIHBhc3NpdmUgVG91Y2hFdmVudCBsaXN0ZW5lcnMgd2hlbiByZWNvZ25pemluZyBnZXN0dXJlcy5cbiAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgZ2VzdHVyZXMgbWFkZSBmcm9tIHRvdWNoIHdpbGwgbm90IGJlIGFibGUgdG8gcHJldmVudCBzY3JvbGxpbmcsIGFsbG93aW5nIGZvciBzbW9vdGhlclxuICogc2Nyb2xsaW5nIHBlcmZvcm1hbmNlLlxuICogRGVmYXVsdHMgdG8gYGZhbHNlYCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cbmV4cG9ydCBsZXQgcGFzc2l2ZVRvdWNoR2VzdHVyZXMgPVxuICB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci5zZXRQYXNzaXZlVG91Y2hHZXN0dXJlcyB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGBwYXNzaXZlVG91Y2hHZXN0dXJlc2AgZ2xvYmFsbHkgZm9yIGFsbCBlbGVtZW50cyB1c2luZyBQb2x5bWVyIEdlc3R1cmVzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlUGFzc2l2ZSBlbmFibGUgb3IgZGlzYWJsZSBwYXNzaXZlIHRvdWNoIGdlc3R1cmVzIGdsb2JhbGx5XG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0UGFzc2l2ZVRvdWNoR2VzdHVyZXMgPSBmdW5jdGlvbih1c2VQYXNzaXZlKSB7XG4gIHBhc3NpdmVUb3VjaEdlc3R1cmVzID0gdXNlUGFzc2l2ZTtcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byBlbnN1cmUgUG9seW1lciB0ZW1wbGF0ZSBldmFsdWF0aW9uIG9ubHkgb2NjdXJzIGJhc2VkIG9uIHRlbXBhdGVzXG4gKiBkZWZpbmVkIGluIHRydXN0ZWQgc2NyaXB0LiAgV2hlbiB0cnVlLCBgPGRvbS1tb2R1bGU+YCByZS1yZWdpc3RyYXRpb24gaXNcbiAqIGRpc2FsbG93ZWQsIGA8ZG9tLWJpbmQ+YCBpcyBkaXNhYmxlZCwgYW5kIGA8ZG9tLWlmPmAvYDxkb20tcmVwZWF0PmBcbiAqIHRlbXBsYXRlcyB3aWxsIG9ubHkgZXZhbHVhdGUgaW4gdGhlIGNvbnRleHQgb2YgYSB0cnVzdGVkIGVsZW1lbnQgdGVtcGxhdGUuXG4gKi9cbmV4cG9ydCBsZXQgc3RyaWN0VGVtcGxhdGVQb2xpY3kgPVxuICB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci5zdHJpY3RUZW1wbGF0ZVBvbGljeSB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGBzdHJpY3RUZW1wbGF0ZVBvbGljeWAgZ2xvYmFsbHkgZm9yIGFsbCBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlU3RyaWN0UG9saWN5IGVuYWJsZSBvciBkaXNhYmxlIHN0cmljdCB0ZW1wbGF0ZSBwb2xpY3lcbiAqICAgZ2xvYmFsbHlcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRTdHJpY3RUZW1wbGF0ZVBvbGljeSA9IGZ1bmN0aW9uKHVzZVN0cmljdFBvbGljeSkge1xuICBzdHJpY3RUZW1wbGF0ZVBvbGljeSA9IHVzZVN0cmljdFBvbGljeTtcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byBlbmFibGUgZG9tLW1vZHVsZSBsb29rdXAgZnJvbSBQb2x5bWVyLkVsZW1lbnQuICBCeSBkZWZhdWx0LFxuICogdGVtcGxhdGVzIG11c3QgYmUgZGVmaW5lZCBpbiBzY3JpcHQgdXNpbmcgdGhlIGBzdGF0aWMgZ2V0IHRlbXBsYXRlKClgXG4gKiBnZXR0ZXIgYW5kIHRoZSBgaHRtbGAgdGFnIGZ1bmN0aW9uLiAgVG8gZW5hYmxlIGxlZ2FjeSBsb2FkaW5nIG9mIHRlbXBsYXRlc1xuICogdmlhIGRvbS1tb2R1bGUsIHNldCB0aGlzIGZsYWcgdG8gdHJ1ZS5cbiAqL1xuZXhwb3J0IGxldCBhbGxvd1RlbXBsYXRlRnJvbURvbU1vZHVsZSA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLmFsbG93VGVtcGxhdGVGcm9tRG9tTW9kdWxlIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYGxvb2t1cFRlbXBsYXRlRnJvbURvbU1vZHVsZWAgZ2xvYmFsbHkgZm9yIGFsbCBlbGVtZW50c1xuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dEb21Nb2R1bGUgZW5hYmxlIG9yIGRpc2FibGUgdGVtcGxhdGUgbG9va3VwXG4gKiAgIGdsb2JhbGx5XG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0QWxsb3dUZW1wbGF0ZUZyb21Eb21Nb2R1bGUgPSBmdW5jdGlvbihhbGxvd0RvbU1vZHVsZSkge1xuICBhbGxvd1RlbXBsYXRlRnJvbURvbU1vZHVsZSA9IGFsbG93RG9tTW9kdWxlO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIHNraXAgcHJvY2Vzc2luZyBzdHlsZSBpbmNsdWRlcyBhbmQgcmUtd3JpdGluZyB1cmxzIGluIGNzcyBzdHlsZXMuXG4gKiBOb3JtYWxseSBcImluY2x1ZGVkXCIgc3R5bGVzIGFyZSBwdWxsZWQgaW50byB0aGUgZWxlbWVudCBhbmQgYWxsIHVybHMgaW4gc3R5bGVzXG4gKiBhcmUgcmUtd3JpdHRlbiB0byBiZSByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyBzY3JpcHQgdXJsLlxuICogSWYgbm8gaW5jbHVkZXMgb3IgcmVsYXRpdmUgdXJscyBhcmUgdXNlZCBpbiBzdHlsZXMsIHRoZXNlIHN0ZXBzIGNhbiBiZVxuICogc2tpcHBlZCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gKi9cbmV4cG9ydCBsZXQgbGVnYWN5T3B0aW1pemF0aW9ucyA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLmxlZ2FjeU9wdGltaXphdGlvbnMgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgbGVnYWN5T3B0aW1pemF0aW9uc2AgZ2xvYmFsbHkgZm9yIGFsbCBlbGVtZW50cyB0byBlbmFibGUgb3B0aW1pemF0aW9uc1xuICogd2hlbiBvbmx5IGxlZ2FjeSBiYXNlZCBlbGVtZW50cyBhcmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUxlZ2FjeU9wdGltaXphdGlvbnMgZW5hYmxlIG9yIGRpc2FibGUgbGVnYWN5IG9wdGltaXphdGlvbnNcbiAqIGluY2x1ZGVzIGFuZCB1cmwgcmV3cml0aW5nXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0TGVnYWN5T3B0aW1pemF0aW9ucyA9IGZ1bmN0aW9uKHVzZUxlZ2FjeU9wdGltaXphdGlvbnMpIHtcbiAgbGVnYWN5T3B0aW1pemF0aW9ucyA9IHVzZUxlZ2FjeU9wdGltaXphdGlvbnM7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gYWRkIHdhcm5pbmdzIHVzZWZ1bCB3aGVuIG1pZ3JhdGluZyBmcm9tIFBvbHltZXIgMS54IHRvIDIueC5cbiAqL1xuZXhwb3J0IGxldCBsZWdhY3lXYXJuaW5ncyA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLmxlZ2FjeVdhcm5pbmdzIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYGxlZ2FjeVdhcm5pbmdzYCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzIHRvIG1pZ3JhdGlvbiB3YXJuaW5ncy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUxlZ2FjeVdhcm5pbmdzIGVuYWJsZSBvciBkaXNhYmxlIHdhcm5pbmdzXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0TGVnYWN5V2FybmluZ3MgPSBmdW5jdGlvbih1c2VMZWdhY3lXYXJuaW5ncykge1xuICBsZWdhY3lXYXJuaW5ncyA9IHVzZUxlZ2FjeVdhcm5pbmdzO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIHBlcmZvcm0gaW5pdGlhbCByZW5kZXJpbmcgc3luY2hyb25vdXNseSB3aGVuIHJ1bm5pbmcgdW5kZXIgU2hhZHlET00uXG4gKiBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW9yIG9mIFBvbHltZXIgMS5cbiAqL1xuZXhwb3J0IGxldCBzeW5jSW5pdGlhbFJlbmRlciA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLnN5bmNJbml0aWFsUmVuZGVyIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYHN5bmNJbml0aWFsUmVuZGVyYCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzIHRvIGVuYWJsZSBzeW5jaHJvbm91c1xuICogaW5pdGlhbCByZW5kZXJpbmcuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB1c2VTeW5jSW5pdGlhbFJlbmRlciBlbmFibGUgb3IgZGlzYWJsZSBzeW5jaHJvbm91cyBpbml0aWFsXG4gKiByZW5kZXJpbmcgZ2xvYmFsbHkuXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0U3luY0luaXRpYWxSZW5kZXIgPSBmdW5jdGlvbih1c2VTeW5jSW5pdGlhbFJlbmRlcikge1xuICBzeW5jSW5pdGlhbFJlbmRlciA9IHVzZVN5bmNJbml0aWFsUmVuZGVyO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIHJldGFpbiB0aGUgbGVnYWN5IFBvbHltZXIgMSBiZWhhdmlvciBmb3IgbXVsdGktcHJvcGVydHlcbiAqIG9ic2VydmVycyBhcm91bmQgdW5kZWZpbmVkIHZhbHVlcy4gT2JzZXJ2ZXJzIGFuZCBjb21wdXRlZCBwcm9wZXJ0eSBtZXRob2RzXG4gKiBhcmUgbm90IGNhbGxlZCB1bnRpbCBubyBhcmd1bWVudCBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBsZXQgbGVnYWN5VW5kZWZpbmVkID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIubGVnYWN5VW5kZWZpbmVkIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYGxlZ2FjeVVuZGVmaW5lZGAgZ2xvYmFsbHkgZm9yIGFsbCBlbGVtZW50cyB0byBlbmFibGUgbGVnYWN5XG4gKiBtdWx0aS1wcm9wZXJ0eSBiZWhhdmlvciBmb3IgdW5kZWZpbmVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUxlZ2FjeVVuZGVmaW5lZCBlbmFibGUgb3IgZGlzYWJsZSBsZWdhY3lcbiAqIG11bHRpLXByb3BlcnR5IGJlaGF2aW9yIGZvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0TGVnYWN5VW5kZWZpbmVkID0gZnVuY3Rpb24odXNlTGVnYWN5VW5kZWZpbmVkKSB7XG4gIGxlZ2FjeVVuZGVmaW5lZCA9IHVzZUxlZ2FjeVVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byBlbnN1cmUgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgY29tcHV0ZWQgaW4gb3JkZXIgdG8gZW5zdXJlXG4gKiByZS1jb21wdXRhdGlvbiBuZXZlciBvY2N1cnMgaW4gYSBnaXZlbiB0dXJuLlxuICovXG5leHBvcnQgbGV0IG9yZGVyZWRDb21wdXRlZCA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLm9yZGVyZWRDb21wdXRlZCB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGBvcmRlcmVkQ29tcHV0ZWRgIGdsb2JhbGx5IGZvciBhbGwgZWxlbWVudHMgdG8gZW5hYmxlIG9yZGVyZWQgY29tcHV0ZWRcbiAqIHByb3BlcnR5IGNvbXB1dGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlT3JkZXJlZENvbXB1dGVkIGVuYWJsZSBvciBkaXNhYmxlIG9yZGVyZWQgY29tcHV0ZWQgZWZmZWN0c1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldE9yZGVyZWRDb21wdXRlZCA9IGZ1bmN0aW9uKHVzZU9yZGVyZWRDb21wdXRlZCkge1xuICBvcmRlcmVkQ29tcHV0ZWQgPSB1c2VPcmRlcmVkQ29tcHV0ZWQ7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gY2FuY2VsIHN5bnRoZXRpYyBjbGljayBldmVudHMgZmlyZWQgYnkgb2xkZXIgbW9iaWxlIGJyb3dzZXJzLiBNb2Rlcm4gYnJvd3NlcnNcbiAqIG5vIGxvbmdlciBmaXJlIHN5bnRoZXRpYyBjbGljayBldmVudHMsIGFuZCB0aGUgY2FuY2VsbGF0aW9uIGJlaGF2aW9yIGNhbiBpbnRlcmZlcmVcbiAqIHdoZW4gcHJvZ3JhbW1hdGljYWxseSBjbGlja2luZyBvbiBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGxldCBjYW5jZWxTeW50aGV0aWNDbGlja0V2ZW50cyA9IHRydWU7XG5cbi8qKlxuICogU2V0cyBgc2V0Q2FuY2VsU3ludGhldGljRXZlbnRzYCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzIHRvIGNhbmNlbCBzeW50aGV0aWMgY2xpY2sgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FuY2VsU3ludGhldGljQ2xpY2tFdmVudHMgZW5hYmxlIG9yIGRpc2FibGUgY2FuY2VsbGluZyBzeW50aGV0aWNcbiAqIGV2ZW50c1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldENhbmNlbFN5bnRoZXRpY0NsaWNrRXZlbnRzID0gZnVuY3Rpb24odXNlQ2FuY2VsU3ludGhldGljQ2xpY2tFdmVudHMpIHtcbiAgY2FuY2VsU3ludGhldGljQ2xpY2tFdmVudHMgPSB1c2VDYW5jZWxTeW50aGV0aWNDbGlja0V2ZW50cztcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byByZW1vdmUgbmVzdGVkIHRlbXBsYXRlcyBpbnNpZGUgYGRvbS1pZmAgYW5kIGBkb20tcmVwZWF0YCBhc1xuICogcGFydCBvZiBlbGVtZW50IHRlbXBsYXRlIHBhcnNpbmcuICBUaGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRoYXRcbiAqIGVsaW1pbmF0ZXMgbW9zdCBvZiB0aGUgdGF4IG9mIG5lZWRpbmcgdHdvIGVsZW1lbnRzIGR1ZSB0byB0aGUgbG9zcyBvZlxuICogdHlwZS1leHRlbmRlZCB0ZW1wbGF0ZXMgYXMgYSByZXN1bHQgb2YgdGhlIFYxIHNwZWNpZmljYXRpb24gY2hhbmdlcy5cbiAqL1xuZXhwb3J0IGxldCByZW1vdmVOZXN0ZWRUZW1wbGF0ZXMgPVxuICB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci5yZW1vdmVOZXN0ZWRUZW1wbGF0ZXMgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgcmVtb3ZlTmVzdGVkVGVtcGxhdGVzYCBnbG9iYWxseSwgdG8gZWxpbWluYXRlIG5lc3RlZCB0ZW1wbGF0ZXNcbiAqIGluc2lkZSBgZG9tLWlmYCBhbmQgYGRvbS1yZXBlYXRgIGFzIHBhcnQgb2YgdGVtcGxhdGUgcGFyc2luZy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZVJlbW92ZU5lc3RlZFRlbXBsYXRlcyBlbmFibGUgb3IgZGlzYWJsZSByZW1vdmluZyBuZXN0ZWRcbiAqICAgdGVtcGxhdGVzIGR1cmluZyBwYXJzaW5nXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0UmVtb3ZlTmVzdGVkVGVtcGxhdGVzID0gZnVuY3Rpb24odXNlUmVtb3ZlTmVzdGVkVGVtcGxhdGVzKSB7XG4gIHJlbW92ZU5lc3RlZFRlbXBsYXRlcyA9IHVzZVJlbW92ZU5lc3RlZFRlbXBsYXRlcztcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byBwbGFjZSBgZG9tLWlmYCBlbGVtZW50cyBpbiBhIHBlcmZvcm1hbmNlLW9wdGltaXplZCBtb2RlIHRoYXQgdGFrZXNcbiAqIGFkdmFudGFnZSBvZiBsaWdodGVyLXdlaWdodCBob3N0IHJ1bnRpbWUgdGVtcGxhdGUgc3RhbXBpbmcgdG8gZWxpbWluYXRlIHRoZVxuICogbmVlZCBmb3IgYW4gaW50ZXJtZWRpYXRlIFRlbXBsYXRpemVyIGBUZW1wbGF0ZUluc3RhbmNlYCB0byBtYW5nZSB0aGUgbm9kZXNcbiAqIHN0YW1wZWQgYnkgYGRvbS1pZmAuICBVbmRlciB0aGlzIHNldHRpbmcsIGFueSBUZW1wbGF0aXplci1wcm92aWRlZCBBUEknc1xuICogc3VjaCBhcyBgbW9kZWxGb3JFbGVtZW50YCB3aWxsIG5vdCBiZSBhdmFpbGFibGUgZm9yIG5vZGVzIHN0YW1wZWQgYnlcbiAqIGBkb20taWZgLlxuICovXG5leHBvcnQgbGV0IGZhc3REb21JZiA9IHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLmZhc3REb21JZiB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGBmYXN0RG9tSWZgIGdsb2JhbGx5LCB0byBwdXQgYGRvbS1pZmAgaW4gYSBwZXJmb3JtYW5jZS1vcHRpbWl6ZWQgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUZhc3REb21JZiBlbmFibGUgb3IgZGlzYWJsZSBgZG9tLWlmYCBmYXN0LW1vZGVcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRGYXN0RG9tSWYgPSBmdW5jdGlvbih1c2VGYXN0RG9tSWYpIHtcbiAgZmFzdERvbUlmID0gdXNlRmFzdERvbUlmO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIGRpc2FibGUgYGRvbS1jaGFuZ2VgIGFuZCBgcmVuZGVyZWQtaXRlbS1jb3VudGAgZXZlbnRzIGZyb21cbiAqIGBkb20taWZgIGFuZCBgZG9tLXJlcGVhdGAuIFVzZXJzIGNhbiBvcHQgYmFjayBpbnRvIGBkb20tY2hhbmdlYCBldmVudHMgYnlcbiAqIHNldHRpbmcgdGhlIGBub3RpZnktZG9tLWNoYW5nZWAgYXR0cmlidXRlIChgbm90aWZ5RG9tQ2hhbmdlOiB0cnVlYCBwcm9wZXJ0eSlcbiAqIHRvIGBkb20taWZgL2Bkb24tcmVwZWF0YCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBsZXQgc3VwcHJlc3NUZW1wbGF0ZU5vdGlmaWNhdGlvbnMgPVxuICB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci5zdXBwcmVzc1RlbXBsYXRlTm90aWZpY2F0aW9ucyB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGBzdXBwcmVzc1RlbXBsYXRlTm90aWZpY2F0aW9uc2AgZ2xvYmFsbHksIHRvIGRpc2FibGUgYGRvbS1jaGFuZ2VgIGFuZFxuICogYHJlbmRlcmVkLWl0ZW0tY291bnRgIGV2ZW50cyBmcm9tIGBkb20taWZgIGFuZCBgZG9tLXJlcGVhdGAuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzdXBwcmVzcyBlbmFibGUgb3IgZGlzYWJsZSBgc3VwcHJlc3NUZW1wbGF0ZU5vdGlmaWNhdGlvbnNgXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0U3VwcHJlc3NUZW1wbGF0ZU5vdGlmaWNhdGlvbnMgPSBmdW5jdGlvbihzdXBwcmVzcykge1xuICBzdXBwcmVzc1RlbXBsYXRlTm90aWZpY2F0aW9ucyA9IHN1cHByZXNzO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIGRpc2FibGUgdXNlIG9mIGR5bmFtaWMgYXR0cmlidXRlcy4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb25cbiAqIHRvIGF2b2lkIHNldHRpbmcgYG9ic2VydmVkQXR0cmlidXRlc2AuIEluc3RlYWQgYXR0cmlidXRlcyBhcmUgcmVhZFxuICogb25jZSBhdCBjcmVhdGUgdGltZSBhbmQgc2V0L3JlbW92ZUF0dHJpYnV0ZSBhcmUgcGF0Y2hlZC5cbiAqL1xuZXhwb3J0IGxldCBsZWdhY3lOb09ic2VydmVkQXR0cmlidXRlcyA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLmxlZ2FjeU5vT2JzZXJ2ZWRBdHRyaWJ1dGVzIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYGxlZ2FjeU5vT2JzZXJ2ZWRBdHRyaWJ1dGVzYCBnbG9iYWxseSwgdG8gZGlzYWJsZSBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG5vT2JzZXJ2ZWRBdHRyaWJ1dGVzIGVuYWJsZSBvciBkaXNhYmxlIGBsZWdhY3lOb09ic2VydmVkQXR0cmlidXRlc2BcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRMZWdhY3lOb09ic2VydmVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uKG5vT2JzZXJ2ZWRBdHRyaWJ1dGVzKSB7XG4gIGxlZ2FjeU5vT2JzZXJ2ZWRBdHRyaWJ1dGVzID0gbm9PYnNlcnZlZEF0dHJpYnV0ZXM7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gZW5hYmxlIHVzZSBvZiBgYWRvcHRlZFN0eWxlU2hlZXRzYCBmb3Igc2hhcmluZyBzdHlsZSBzaGVldHNcbiAqIGJldHdlZW4gY29tcG9uZW50IGluc3RhbmNlcycgc2hhZG93IHJvb3RzLCBpZiB0aGUgYXBwIHVzZXMgYnVpbHQgU2hhZHkgQ1NTXG4gKiBzdHlsZXMuXG4gKi9cbmV4cG9ydCBsZXQgdXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIudXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYHVzZUFkb3B0ZWRTdHlsZVNoZWV0c1dpdGhCdWlsdENTU2AgZ2xvYmFsbHkuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBlbmFibGUgb3IgZGlzYWJsZSBgdXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTYFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFVzZUFkb3B0ZWRTdHlsZVNoZWV0c1dpdGhCdWlsdENTUyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHVzZUFkb3B0ZWRTdHlsZVNoZWV0c1dpdGhCdWlsdENTUyA9IHZhbHVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/settings.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/style-gather.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/style-gather.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cssFromModule\": () => (/* binding */ cssFromModule),\n/* harmony export */   \"cssFromModuleImports\": () => (/* binding */ cssFromModuleImports),\n/* harmony export */   \"cssFromModules\": () => (/* binding */ cssFromModules),\n/* harmony export */   \"cssFromTemplate\": () => (/* binding */ cssFromTemplate),\n/* harmony export */   \"stylesFromModule\": () => (/* binding */ stylesFromModule),\n/* harmony export */   \"stylesFromModuleImports\": () => (/* binding */ stylesFromModuleImports),\n/* harmony export */   \"stylesFromModules\": () => (/* binding */ stylesFromModules),\n/* harmony export */   \"stylesFromTemplate\": () => (/* binding */ stylesFromTemplate)\n/* harmony export */ });\n/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../elements/dom-module.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module with utilities for collection CSS text from `<templates>`, external\n * stylesheets, and `dom-module`s.\n *\n * @summary Module with utilities for collection CSS text from various sources.\n */\n\n\n\nconst MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\nconst INCLUDE_ATTR = 'include';\nconst SHADY_UNSCOPED_ATTR = 'shady-unscoped';\n\n/**\n * @param {string} moduleId .\n * @return {?DomModule} .\n */\nfunction importModule(moduleId) {\n  return (/** @type {?DomModule} */_elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__.DomModule[\"import\"](moduleId)\n  );\n}\nfunction styleForImport(importDoc) {\n  // NOTE: polyfill affordance.\n  // under the HTMLImports polyfill, there will be no 'body',\n  // but the import pseudo-doc can be used directly.\n  let container = importDoc.body ? importDoc.body : importDoc;\n  const importCss = (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveCss)(container.textContent, importDoc.baseURI);\n  const style = document.createElement('style');\n  style.textContent = importCss;\n  return style;\n}\n\n/** @typedef {{assetpath: string}} */\nlet templateWithAssetPath; // eslint-disable-line no-unused-vars\n\n/**\n * Returns a list of <style> elements in a space-separated list of `dom-module`s.\n *\n * @function\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements\n */\nfunction stylesFromModules(moduleIds) {\n  const modules = moduleIds.trim().split(/\\s+/);\n  const styles = [];\n  for (let i = 0; i < modules.length; i++) {\n    styles.push(...stylesFromModule(modules[i]));\n  }\n  return styles;\n}\n\n/**\n * Returns a list of <style> elements in a given `dom-module`.\n * Styles in a `dom-module` can come either from `<style>`s within the\n * first `<template>`, or else from one or more\n * `<link rel=\"import\" type=\"css\">` links outside the template.\n *\n * @param {string} moduleId dom-module id to gather styles from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\nfunction stylesFromModule(moduleId) {\n  const m = importModule(moduleId);\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n    return [];\n  }\n  if (m._styles === undefined) {\n    const styles = [];\n    // module imports: <link rel=\"import\" type=\"css\">\n    styles.push(..._stylesFromModuleImports(m));\n    // include css from the first template in the module\n    const template = /** @type {?HTMLTemplateElement} */\n    m.querySelector('template');\n    if (template) {\n      styles.push(...stylesFromTemplate(template, /** @type {templateWithAssetPath} */m.assetpath));\n    }\n    m._styles = styles;\n  }\n  return m._styles;\n}\n\n/**\n * Returns the `<style>` elements within a given template.\n *\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string=} baseURI baseURI for style content\n * @return {!Array<!HTMLStyleElement>} Array of styles\n */\nfunction stylesFromTemplate(template, baseURI) {\n  if (!template._styles) {\n    const styles = [];\n    // if element is a template, get content from its .content\n    const e$ = template.content.querySelectorAll('style');\n    for (let i = 0; i < e$.length; i++) {\n      let e = e$[i];\n      // support style sharing by allowing styles to \"include\"\n      // other dom-modules that contain styling\n      let include = e.getAttribute(INCLUDE_ATTR);\n      if (include) {\n        styles.push(...stylesFromModules(include).filter(function (item, index, self) {\n          return self.indexOf(item) === index;\n        }));\n      }\n      if (baseURI) {\n        e.textContent = (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveCss)(e.textContent, /** @type {string} */baseURI);\n      }\n      styles.push(e);\n    }\n    template._styles = styles;\n  }\n  return template._styles;\n}\n\n/**\n * Returns a list of <style> elements  from stylesheets loaded via `<link rel=\"import\" type=\"css\">` links within the specified `dom-module`.\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\nfunction stylesFromModuleImports(moduleId) {\n  let m = importModule(moduleId);\n  return m ? _stylesFromModuleImports(m) : [];\n}\n\n/**\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {!Array<!HTMLStyleElement>} Array of contained styles\n */\nfunction _stylesFromModuleImports(module) {\n  const styles = [];\n  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n  for (let i = 0; i < p$.length; i++) {\n    let p = p$[i];\n    if (p.import) {\n      const importDoc = p.import;\n      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);\n      if (unscoped && !importDoc._unscopedStyle) {\n        const style = styleForImport(importDoc);\n        style.setAttribute(SHADY_UNSCOPED_ATTR, '');\n        importDoc._unscopedStyle = style;\n      } else if (!importDoc._style) {\n        importDoc._style = styleForImport(importDoc);\n      }\n      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);\n    }\n  }\n  return styles;\n}\n\n/**\n *\n * Returns CSS text of styles in a space-separated list of `dom-module`s.\n * Note: This method is deprecated, use `stylesFromModules` instead.\n *\n * @deprecated\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {string} Concatenated CSS content from specified `dom-module`s\n */\nfunction cssFromModules(moduleIds) {\n  let modules = moduleIds.trim().split(/\\s+/);\n  let cssText = '';\n  for (let i = 0; i < modules.length; i++) {\n    cssText += cssFromModule(modules[i]);\n  }\n  return cssText;\n}\n\n/**\n * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n * can come either from `<style>`s within the first `<template>`, or else\n * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n * template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromModule` instead.\n *\n * @deprecated\n * @param {string} moduleId dom-module id to gather styles from\n * @return {string} Concatenated CSS content from specified `dom-module`\n */\nfunction cssFromModule(moduleId) {\n  let m = importModule(moduleId);\n  if (m && m._cssText === undefined) {\n    // module imports: <link rel=\"import\" type=\"css\">\n    let cssText = _cssFromModuleImports(m);\n    // include css from the first template in the module\n    let t = /** @type {?HTMLTemplateElement} */m.querySelector('template');\n    if (t) {\n      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */m.assetpath);\n    }\n    m._cssText = cssText || null;\n  }\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n  }\n  return m && m._cssText || '';\n}\n\n/**\n * Returns CSS text of `<styles>` within a given template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromTemplate` instead.\n *\n * @deprecated\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Concatenated CSS content from specified template\n */\nfunction cssFromTemplate(template, baseURI) {\n  let cssText = '';\n  const e$ = stylesFromTemplate(template, baseURI);\n  // if element is a template, get content from its .content\n  for (let i = 0; i < e$.length; i++) {\n    let e = e$[i];\n    if (e.parentNode) {\n      e.parentNode.removeChild(e);\n    }\n    cssText += e.textContent;\n  }\n  return cssText;\n}\n\n/**\n * Returns CSS text from stylesheets loaded via `<link rel=\"import\" type=\"css\">`\n * links within the specified `dom-module`.\n *\n * Note: This method is deprecated, use `stylesFromModuleImports` instead.\n *\n * @deprecated\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {string} Concatenated CSS content from links in specified `dom-module`\n */\nfunction cssFromModuleImports(moduleId) {\n  let m = importModule(moduleId);\n  return m ? _cssFromModuleImports(m) : '';\n}\n\n/**\n * @deprecated\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {string} Concatenated CSS content from links in the dom-module\n */\nfunction _cssFromModuleImports(module) {\n  let cssText = '';\n  let styles = _stylesFromModuleImports(module);\n  for (let i = 0; i < styles.length; i++) {\n    cssText += styles[i].textContent;\n  }\n  return cssText;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3N0eWxlLWdhdGhlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3N0eWxlLWdhdGhlci5qcz8zNzMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qKlxuICogTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBjb2xsZWN0aW9uIENTUyB0ZXh0IGZyb20gYDx0ZW1wbGF0ZXM+YCwgZXh0ZXJuYWxcbiAqIHN0eWxlc2hlZXRzLCBhbmQgYGRvbS1tb2R1bGVgcy5cbiAqXG4gKiBAc3VtbWFyeSBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIGNvbGxlY3Rpb24gQ1NTIHRleHQgZnJvbSB2YXJpb3VzIHNvdXJjZXMuXG4gKi9cblxuaW1wb3J0IHsgRG9tTW9kdWxlIH0gZnJvbSAnLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQ3NzIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5cbmNvbnN0IE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SID0gJ2xpbmtbcmVsPWltcG9ydF1bdHlwZX49Y3NzXSc7XG5jb25zdCBJTkNMVURFX0FUVFIgPSAnaW5jbHVkZSc7XG5jb25zdCBTSEFEWV9VTlNDT1BFRF9BVFRSID0gJ3NoYWR5LXVuc2NvcGVkJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgLlxuICogQHJldHVybiB7P0RvbU1vZHVsZX0gLlxuICovXG5mdW5jdGlvbiBpbXBvcnRNb2R1bGUobW9kdWxlSWQpIHtcbiAgcmV0dXJuIC8qKiBAdHlwZSB7P0RvbU1vZHVsZX0gKi8oRG9tTW9kdWxlLmltcG9ydChtb2R1bGVJZCkpO1xufVxuXG5mdW5jdGlvbiBzdHlsZUZvckltcG9ydChpbXBvcnREb2MpIHtcbiAgLy8gTk9URTogcG9seWZpbGwgYWZmb3JkYW5jZS5cbiAgLy8gdW5kZXIgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsLCB0aGVyZSB3aWxsIGJlIG5vICdib2R5JyxcbiAgLy8gYnV0IHRoZSBpbXBvcnQgcHNldWRvLWRvYyBjYW4gYmUgdXNlZCBkaXJlY3RseS5cbiAgbGV0IGNvbnRhaW5lciA9IGltcG9ydERvYy5ib2R5ID8gaW1wb3J0RG9jLmJvZHkgOiBpbXBvcnREb2M7XG4gIGNvbnN0IGltcG9ydENzcyA9IHJlc29sdmVDc3MoY29udGFpbmVyLnRleHRDb250ZW50LFxuICAgIGltcG9ydERvYy5iYXNlVVJJKTtcbiAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IGltcG9ydENzcztcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKiogQHR5cGVkZWYge3thc3NldHBhdGg6IHN0cmluZ319ICovXG5sZXQgdGVtcGxhdGVXaXRoQXNzZXRQYXRoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiA8c3R5bGU+IGVsZW1lbnRzIGluIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgYGRvbS1tb2R1bGVgcy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZHMgTGlzdCBvZiBkb20tbW9kdWxlIGlkJ3Mgd2l0aGluIHdoaWNoIHRvXG4gKiBzZWFyY2ggZm9yIGNzcy5cbiAqIEByZXR1cm4geyFBcnJheTwhSFRNTFN0eWxlRWxlbWVudD59IEFycmF5IG9mIGNvbnRhaW5lZCA8c3R5bGU+IGVsZW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZXNGcm9tTW9kdWxlcyhtb2R1bGVJZHMpIHtcbiBjb25zdCBtb2R1bGVzID0gbW9kdWxlSWRzLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuIGNvbnN0IHN0eWxlcyA9IFtdO1xuIGZvciAobGV0IGk9MDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgIHN0eWxlcy5wdXNoKC4uLnN0eWxlc0Zyb21Nb2R1bGUobW9kdWxlc1tpXSkpO1xuIH1cbiByZXR1cm4gc3R5bGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIDxzdHlsZT4gZWxlbWVudHMgaW4gYSBnaXZlbiBgZG9tLW1vZHVsZWAuXG4gKiBTdHlsZXMgaW4gYSBgZG9tLW1vZHVsZWAgY2FuIGNvbWUgZWl0aGVyIGZyb20gYDxzdHlsZT5gcyB3aXRoaW4gdGhlXG4gKiBmaXJzdCBgPHRlbXBsYXRlPmAsIG9yIGVsc2UgZnJvbSBvbmUgb3IgbW9yZVxuICogYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gIGxpbmtzIG91dHNpZGUgdGhlIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCBkb20tbW9kdWxlIGlkIHRvIGdhdGhlciBzdHlsZXMgZnJvbVxuICogQHJldHVybiB7IUFycmF5PCFIVE1MU3R5bGVFbGVtZW50Pn0gQXJyYXkgb2YgY29udGFpbmVkIHN0eWxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0eWxlc0Zyb21Nb2R1bGUobW9kdWxlSWQpIHtcbiAgY29uc3QgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBzdHlsZSBkYXRhIGluIG1vZHVsZSBuYW1lZCcsIG1vZHVsZUlkKTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAobS5fc3R5bGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICAvLyBtb2R1bGUgaW1wb3J0czogPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPlxuICAgIHN0eWxlcy5wdXNoKC4uLl9zdHlsZXNGcm9tTW9kdWxlSW1wb3J0cyhtKSk7XG4gICAgLy8gaW5jbHVkZSBjc3MgZnJvbSB0aGUgZmlyc3QgdGVtcGxhdGUgaW4gdGhlIG1vZHVsZVxuICAgIGNvbnN0IHRlbXBsYXRlID0gLyoqIEB0eXBlIHs/SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8oXG4gICAgICAgIG0ucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBzdHlsZXMucHVzaCguLi5zdHlsZXNGcm9tVGVtcGxhdGUodGVtcGxhdGUsXG4gICAgICAgIC8qKiBAdHlwZSB7dGVtcGxhdGVXaXRoQXNzZXRQYXRofSAqLyhtKS5hc3NldHBhdGgpKTtcbiAgICB9XG5cbiAgICBtLl9zdHlsZXMgPSBzdHlsZXM7XG4gIH1cblxuICByZXR1cm4gbS5fc3R5bGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGA8c3R5bGU+YCBlbGVtZW50cyB3aXRoaW4gYSBnaXZlbiB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBnYXRoZXIgc3R5bGVzIGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nPX0gYmFzZVVSSSBiYXNlVVJJIGZvciBzdHlsZSBjb250ZW50XG4gKiBAcmV0dXJuIHshQXJyYXk8IUhUTUxTdHlsZUVsZW1lbnQ+fSBBcnJheSBvZiBzdHlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0eWxlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkge1xuICBpZiAoIXRlbXBsYXRlLl9zdHlsZXMpIHtcbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICAvLyBpZiBlbGVtZW50IGlzIGEgdGVtcGxhdGUsIGdldCBjb250ZW50IGZyb20gaXRzIC5jb250ZW50XG4gICAgY29uc3QgZSQgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgZSQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBlID0gZSRbaV07XG4gICAgICAvLyBzdXBwb3J0IHN0eWxlIHNoYXJpbmcgYnkgYWxsb3dpbmcgc3R5bGVzIHRvIFwiaW5jbHVkZVwiXG4gICAgICAvLyBvdGhlciBkb20tbW9kdWxlcyB0aGF0IGNvbnRhaW4gc3R5bGluZ1xuICAgICAgbGV0IGluY2x1ZGUgPSBlLmdldEF0dHJpYnV0ZShJTkNMVURFX0FUVFIpO1xuICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgc3R5bGVzLnB1c2goLi4uc3R5bGVzRnJvbU1vZHVsZXMoaW5jbHVkZSkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0sIGluZGV4LCBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlVVJJKSB7XG4gICAgICAgIGUudGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgcmVzb2x2ZUNzcyhlLnRleHRDb250ZW50LCAvKiogQHR5cGUge3N0cmluZ30gKi8gKGJhc2VVUkkpKTtcbiAgICAgIH1cbiAgICAgIHN0eWxlcy5wdXNoKGUpO1xuICAgIH1cbiAgICB0ZW1wbGF0ZS5fc3R5bGVzID0gc3R5bGVzO1xuICB9XG4gIHJldHVybiB0ZW1wbGF0ZS5fc3R5bGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIDxzdHlsZT4gZWxlbWVudHMgIGZyb20gc3R5bGVzaGVldHMgbG9hZGVkIHZpYSBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmAgbGlua3Mgd2l0aGluIHRoZSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCBJZCBvZiBgZG9tLW1vZHVsZWAgdG8gZ2F0aGVyIENTUyBmcm9tXG4gKiBAcmV0dXJuIHshQXJyYXk8IUhUTUxTdHlsZUVsZW1lbnQ+fSBBcnJheSBvZiBjb250YWluZWQgc3R5bGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpIHtcbiBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gcmV0dXJuIG0gPyBfc3R5bGVzRnJvbU1vZHVsZUltcG9ydHMobSkgOiBbXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbW9kdWxlIGRvbS1tb2R1bGUgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gIHN0eWxlc1xuICogQHJldHVybiB7IUFycmF5PCFIVE1MU3R5bGVFbGVtZW50Pn0gQXJyYXkgb2YgY29udGFpbmVkIHN0eWxlc1xuICovXG5mdW5jdGlvbiBfc3R5bGVzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IFtdO1xuICBjb25zdCBwJCA9IG1vZHVsZS5xdWVyeVNlbGVjdG9yQWxsKE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SKTtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcCQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcCA9IHAkW2ldO1xuICAgIGlmIChwLmltcG9ydCkge1xuICAgICAgY29uc3QgaW1wb3J0RG9jID0gcC5pbXBvcnQ7XG4gICAgICBjb25zdCB1bnNjb3BlZCA9IHAuaGFzQXR0cmlidXRlKFNIQURZX1VOU0NPUEVEX0FUVFIpO1xuICAgICAgaWYgKHVuc2NvcGVkICYmICFpbXBvcnREb2MuX3Vuc2NvcGVkU3R5bGUpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZUZvckltcG9ydChpbXBvcnREb2MpO1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoU0hBRFlfVU5TQ09QRURfQVRUUiwgJycpO1xuICAgICAgICBpbXBvcnREb2MuX3Vuc2NvcGVkU3R5bGUgPSBzdHlsZTtcbiAgICAgIH0gZWxzZSBpZiAoIWltcG9ydERvYy5fc3R5bGUpIHtcbiAgICAgICAgaW1wb3J0RG9jLl9zdHlsZSA9IHN0eWxlRm9ySW1wb3J0KGltcG9ydERvYyk7XG4gICAgICB9XG4gICAgICBzdHlsZXMucHVzaCh1bnNjb3BlZCA/IGltcG9ydERvYy5fdW5zY29wZWRTdHlsZSA6IGltcG9ydERvYy5fc3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufVxuXG4vKipcbiAqXG4gKiBSZXR1cm5zIENTUyB0ZXh0IG9mIHN0eWxlcyBpbiBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGBkb20tbW9kdWxlYHMuXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLCB1c2UgYHN0eWxlc0Zyb21Nb2R1bGVzYCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWRzIExpc3Qgb2YgZG9tLW1vZHVsZSBpZCdzIHdpdGhpbiB3aGljaCB0b1xuICogc2VhcmNoIGZvciBjc3MuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIHNwZWNpZmllZCBgZG9tLW1vZHVsZWBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlcyhtb2R1bGVJZHMpIHtcbiBsZXQgbW9kdWxlcyA9IG1vZHVsZUlkcy50cmltKCkuc3BsaXQoL1xccysvKTtcbiBsZXQgY3NzVGV4dCA9ICcnO1xuIGZvciAobGV0IGk9MDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgIGNzc1RleHQgKz0gY3NzRnJvbU1vZHVsZShtb2R1bGVzW2ldKTtcbiB9XG4gcmV0dXJuIGNzc1RleHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBDU1MgdGV4dCBvZiBzdHlsZXMgaW4gYSBnaXZlbiBgZG9tLW1vZHVsZWAuICBDU1MgaW4gYSBgZG9tLW1vZHVsZWBcbiAqIGNhbiBjb21lIGVpdGhlciBmcm9tIGA8c3R5bGU+YHMgd2l0aGluIHRoZSBmaXJzdCBgPHRlbXBsYXRlPmAsIG9yIGVsc2VcbiAqIGZyb20gb25lIG9yIG1vcmUgYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gIGxpbmtzIG91dHNpZGUgdGhlXG4gKiB0ZW1wbGF0ZS5cbiAqXG4gKiBBbnkgYDxzdHlsZXM+YCBwcm9jZXNzZWQgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbi5cbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHVzZSBgc3R5bGVGcm9tTW9kdWxlYCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgZG9tLW1vZHVsZSBpZCB0byBnYXRoZXIgc3R5bGVzIGZyb21cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIGBkb20tbW9kdWxlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZShtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIGlmIChtICYmIG0uX2Nzc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIG1vZHVsZSBpbXBvcnRzOiA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+XG4gICAgbGV0IGNzc1RleHQgPSBfY3NzRnJvbU1vZHVsZUltcG9ydHMobSk7XG4gICAgLy8gaW5jbHVkZSBjc3MgZnJvbSB0aGUgZmlyc3QgdGVtcGxhdGUgaW4gdGhlIG1vZHVsZVxuICAgIGxldCB0ID0gLyoqIEB0eXBlIHs/SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8obS5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICBpZiAodCkge1xuICAgICAgY3NzVGV4dCArPSBjc3NGcm9tVGVtcGxhdGUodCxcbiAgICAgICAgLyoqIEB0eXBlIHt0ZW1wbGF0ZVdpdGhBc3NldFBhdGh9ICovKG0pLmFzc2V0cGF0aCk7XG4gICAgfVxuICAgIG0uX2Nzc1RleHQgPSBjc3NUZXh0IHx8IG51bGw7XG4gIH1cbiAgaWYgKCFtKSB7XG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBzdHlsZSBkYXRhIGluIG1vZHVsZSBuYW1lZCcsIG1vZHVsZUlkKTtcbiAgfVxuICByZXR1cm4gbSAmJiBtLl9jc3NUZXh0IHx8ICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgQ1NTIHRleHQgb2YgYDxzdHlsZXM+YCB3aXRoaW4gYSBnaXZlbiB0ZW1wbGF0ZS5cbiAqXG4gKiBBbnkgYDxzdHlsZXM+YCBwcm9jZXNzZWQgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBvcmlnaW5hbCBsb2NhdGlvbi5cbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHVzZSBgc3R5bGVGcm9tVGVtcGxhdGVgIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIGdhdGhlciBzdHlsZXMgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpIHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgY29uc3QgZSQgPSBzdHlsZXNGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpO1xuICAvLyBpZiBlbGVtZW50IGlzIGEgdGVtcGxhdGUsIGdldCBjb250ZW50IGZyb20gaXRzIC5jb250ZW50XG4gIGZvciAobGV0IGk9MDsgaSA8IGUkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGUgPSBlJFtpXTtcbiAgICBpZiAoZS5wYXJlbnROb2RlKSB7XG4gICAgICBlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSk7XG4gICAgfVxuICAgIGNzc1RleHQgKz0gZS50ZXh0Q29udGVudDtcbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIENTUyB0ZXh0IGZyb20gc3R5bGVzaGVldHMgbG9hZGVkIHZpYSBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmBcbiAqIGxpbmtzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGBkb20tbW9kdWxlYC5cbiAqXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLCB1c2UgYHN0eWxlc0Zyb21Nb2R1bGVJbXBvcnRzYCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIElkIG9mIGBkb20tbW9kdWxlYCB0byBnYXRoZXIgQ1NTIGZyb21cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gbGlua3MgaW4gc3BlY2lmaWVkIGBkb20tbW9kdWxlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpIHtcbiAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICByZXR1cm4gbSA/IF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtKSA6ICcnO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbW9kdWxlIGRvbS1tb2R1bGUgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5gIHN0eWxlc1xuICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBsaW5rcyBpbiB0aGUgZG9tLW1vZHVsZVxuICovXG5mdW5jdGlvbiBfY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlKSB7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIGxldCBzdHlsZXMgPSBfc3R5bGVzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlKTtcbiAgZm9yIChsZXQgaT0wOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3NzVGV4dCArPSBzdHlsZXNbaV0udGV4dENvbnRlbnQ7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/style-gather.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/telemetry.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/telemetry.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dumpRegistrations\": () => (/* binding */ dumpRegistrations),\n/* harmony export */   \"incrementInstanceCount\": () => (/* binding */ incrementInstanceCount),\n/* harmony export */   \"instanceCount\": () => (/* binding */ instanceCount),\n/* harmony export */   \"register\": () => (/* binding */ register),\n/* harmony export */   \"registrations\": () => (/* binding */ registrations)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Total number of Polymer element instances created.\n * @type {number}\n */\nlet instanceCount = 0;\nfunction incrementInstanceCount() {\n  instanceCount++;\n}\n\n/**\n * Array of Polymer element classes that have been finalized.\n * @type {!Array<!PolymerElementConstructor>}\n */\nconst registrations = [];\n\n/**\n * @param {!PolymerElementConstructor} prototype Element prototype to log\n * @private\n */\nfunction _regLog(prototype) {\n  console.log('[' + /** @type {?} */prototype.is + ']: registered');\n}\n\n/**\n * Registers a class prototype for telemetry purposes.\n * @param {!PolymerElementConstructor} prototype Element prototype to register\n * @protected\n */\nfunction register(prototype) {\n  registrations.push(prototype);\n}\n\n/**\n * Logs all elements registered with an `is` to the console.\n * @public\n */\nfunction dumpRegistrations() {\n  registrations.forEach(_regLog);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3RlbGVtZXRyeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3RlbGVtZXRyeS5qcz9kYTBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qKlxuICogVG90YWwgbnVtYmVyIG9mIFBvbHltZXIgZWxlbWVudCBpbnN0YW5jZXMgY3JlYXRlZC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBsZXQgaW5zdGFuY2VDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnRJbnN0YW5jZUNvdW50KCkge1xuICBpbnN0YW5jZUNvdW50Kys7XG59XG5cbi8qKlxuICogQXJyYXkgb2YgUG9seW1lciBlbGVtZW50IGNsYXNzZXMgdGhhdCBoYXZlIGJlZW4gZmluYWxpemVkLlxuICogQHR5cGUgeyFBcnJheTwhUG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcj59XG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RyYXRpb25zID0gW107XG5cbi8qKlxuICogQHBhcmFtIHshUG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gcHJvdG90eXBlIEVsZW1lbnQgcHJvdG90eXBlIHRvIGxvZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlZ0xvZyhwcm90b3R5cGUpIHtcbiAgY29uc29sZS5sb2coJ1snICsgLyoqIEB0eXBlIHs/fSAqLyhwcm90b3R5cGUpLmlzICsgJ106IHJlZ2lzdGVyZWQnKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjbGFzcyBwcm90b3R5cGUgZm9yIHRlbGVtZXRyeSBwdXJwb3Nlcy5cbiAqIEBwYXJhbSB7IVBvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IHByb3RvdHlwZSBFbGVtZW50IHByb3RvdHlwZSB0byByZWdpc3RlclxuICogQHByb3RlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIocHJvdG90eXBlKSB7XG4gIHJlZ2lzdHJhdGlvbnMucHVzaChwcm90b3R5cGUpO1xufVxuXG4vKipcbiAqIExvZ3MgYWxsIGVsZW1lbnRzIHJlZ2lzdGVyZWQgd2l0aCBhbiBgaXNgIHRvIHRoZSBjb25zb2xlLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZHVtcFJlZ2lzdHJhdGlvbnMoKSB7XG4gIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChfcmVnTG9nKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/telemetry.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/wrap.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/wrap.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrap\": () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable valid-jsdoc */\n/**\n * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill\n * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,\n * a node wrapper must be used to access ShadowDOM API.\n * This is similar to using `Polymer.dom` but relies exclusively\n * on the presence of the ShadyDOM polyfill rather than requiring the loading\n * of legacy (Polymer.dom) API.\n * @type {function(Node):Node}\n */\nconst wrap = window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap'] ? window['ShadyDOM']['wrap'] : window['ShadyDOM'] ? n => ShadyDOM['patch'](n) : n => n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3dyYXAuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvd3JhcC5qcz80YjM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4vKipcbiAqIE5vZGUgd3JhcHBlciB0byBlbnN1cmUgU2hhZG93RE9NIHNhZmUgb3BlcmF0aW9uIHJlZ2FyZGxlc3Mgb2YgcG9seWZpbGxcbiAqIHByZXNlbmNlIG9yIG1vZGUuIE5vdGUgdGhhdCB3aXRoIHRoZSBpbnRyb2R1Y3Rpb24gb2YgYFNoYWR5RE9NLm5vUGF0Y2hgLFxuICogYSBub2RlIHdyYXBwZXIgbXVzdCBiZSB1c2VkIHRvIGFjY2VzcyBTaGFkb3dET00gQVBJLlxuICogVGhpcyBpcyBzaW1pbGFyIHRvIHVzaW5nIGBQb2x5bWVyLmRvbWAgYnV0IHJlbGllcyBleGNsdXNpdmVseVxuICogb24gdGhlIHByZXNlbmNlIG9mIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCByYXRoZXIgdGhhbiByZXF1aXJpbmcgdGhlIGxvYWRpbmdcbiAqIG9mIGxlZ2FjeSAoUG9seW1lci5kb20pIEFQSS5cbiAqIEB0eXBlIHtmdW5jdGlvbihOb2RlKTpOb2RlfVxuICovXG5leHBvcnQgY29uc3Qgd3JhcCA9ICh3aW5kb3dbJ1NoYWR5RE9NJ10gJiYgd2luZG93WydTaGFkeURPTSddWydub1BhdGNoJ10gJiYgd2luZG93WydTaGFkeURPTSddWyd3cmFwJ10pID9cbiAgd2luZG93WydTaGFkeURPTSddWyd3cmFwJ10gOlxuICAod2luZG93WydTaGFkeURPTSddID8gKG4pID0+IFNoYWR5RE9NWydwYXRjaCddKG4pIDogKG4pID0+IG4pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/wrap.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/polymer-element.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/polymer-element.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PolymerElement\": () => (/* binding */ PolymerElement),\n/* harmony export */   \"html\": () => (/* reexport safe */ _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__.html),\n/* harmony export */   \"version\": () => (/* reexport safe */ _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/mixins/element-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/mixins/element-mixin.js\");\n/* harmony import */ var _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/utils/html-tag.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * Base class that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * @customElement\n * @polymer\n * @constructor\n * @implements {Polymer_ElementMixin}\n * @extends HTMLElement\n * @appliesMixin ElementMixin\n * @summary Custom element base class that provides the core API for Polymer's\n *   key meta-programming features including template stamping, data-binding,\n *   attribute deserialization, and property change observation\n */\nconst PolymerElement = (0,_lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__.ElementMixin)(HTMLElement);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzPzNjOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0IHsgRWxlbWVudE1peGluLCB2ZXJzaW9uIH0gZnJvbSAnLi9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuZXhwb3J0IHsgaHRtbCB9IGZyb20gJy4vbGliL3V0aWxzL2h0bWwtdGFnLmpzJztcblxuZXhwb3J0IHsgdmVyc2lvbiB9O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXIncyBtZXRhLXByb2dyYW1taW5nXG4gKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAqIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb24uXG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBwb2x5bWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAYXBwbGllc01peGluIEVsZW1lbnRNaXhpblxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzXG4gKiAgIGtleSBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLFxuICogICBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLCBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBQb2x5bWVyRWxlbWVudCA9IEVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/polymer-element.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/boot.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/boot.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable no-unused-vars */\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n *\n * @param {?} prop Property name\n * @param {*} obj Reference object\n * @return {string} Potentially renamed property name\n */\nwindow.JSCompiler_renameProperty = function (prop, obj) {\n  return prop;\n};\n/* eslint-enable */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9ib290LmpzPzcwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogV2hlbiB1c2luZyBDbG9zdXJlIENvbXBpbGVyLCBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KHByb3BlcnR5LCBvYmplY3QpIGlzIHJlcGxhY2VkIGJ5IHRoZSBtdW5nZWQgbmFtZSBmb3Igb2JqZWN0W3Byb3BlcnR5XVxuICogV2UgY2Fubm90IGFsaWFzIHRoaXMgZnVuY3Rpb24sIHNvIHdlIGhhdmUgdG8gdXNlIGEgc21hbGwgc2hpbSB0aGF0IGhhcyB0aGUgc2FtZSBiZWhhdmlvciB3aGVuIG5vdCBjb21waWxpbmcuXG4gKlxuICogQHBhcmFtIHs/fSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7Kn0gb2JqIFJlZmVyZW5jZSBvYmplY3RcbiAqIEByZXR1cm4ge3N0cmluZ30gUG90ZW50aWFsbHkgcmVuYW1lZCBwcm9wZXJ0eSBuYW1lXG4gKi9cbndpbmRvdy5KU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCwgb2JqKSB7XG4gIHJldHVybiBwcm9wO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuZXhwb3J0IHt9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/boot.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/mixin.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/mixin.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dedupingMixin\": () => (/* binding */ dedupingMixin)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n// unique global id for deduping mixins.\nlet dedupeId = 0;\n\n/**\n * @constructor\n * @extends {Function}\n * @private\n */\nfunction MixinFunction() {}\n/** @type {(WeakMap | undefined)} */\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet;\n\n/* eslint-disable valid-jsdoc */\n/**\n * Wraps an ES6 class expression mixin such that the mixin is only applied\n * if it has not already been applied its base argument. Also memoizes mixin\n * applications.\n *\n * @template T\n * @param {T} mixin ES6 class expression mixin to wrap\n * @return {T}\n * @suppress {invalidCasts}\n */\nconst dedupingMixin = function (mixin) {\n  let mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */\n    mixin.__mixinApplications = mixinApplications;\n  }\n  // maintain a unique id for each mixin\n  let mixinDedupeId = dedupeId++;\n  function dedupingMixin(base) {\n    let baseSet = /** @type {!MixinFunction} */base.__mixinSet;\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n    let map = mixinApplications;\n    let extended = map.get(base);\n    if (!extended) {\n      extended = /** @type {!Function} */mixin(base);\n      map.set(base, extended);\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      let mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n      /** @type {!MixinFunction} */\n      extended.__mixinSet = mixinSet;\n    }\n    return extended;\n  }\n  return dedupingMixin;\n};\n/* eslint-enable valid-jsdoc *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcz8wMDlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIHVuaXF1ZSBnbG9iYWwgaWQgZm9yIGRlZHVwaW5nIG1peGlucy5cbmxldCBkZWR1cGVJZCA9IDA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBNaXhpbkZ1bmN0aW9uKCl7fVxuLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG5NaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluQXBwbGljYXRpb25zO1xuLyoqIEB0eXBlIHsoT2JqZWN0IHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4vKipcbiAqIFdyYXBzIGFuIEVTNiBjbGFzcyBleHByZXNzaW9uIG1peGluIHN1Y2ggdGhhdCB0aGUgbWl4aW4gaXMgb25seSBhcHBsaWVkXG4gKiBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBhcHBsaWVkIGl0cyBiYXNlIGFyZ3VtZW50LiBBbHNvIG1lbW9pemVzIG1peGluXG4gKiBhcHBsaWNhdGlvbnMuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gbWl4aW4gRVM2IGNsYXNzIGV4cHJlc3Npb24gbWl4aW4gdG8gd3JhcFxuICogQHJldHVybiB7VH1cbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICovXG5leHBvcnQgY29uc3QgZGVkdXBpbmdNaXhpbiA9IGZ1bmN0aW9uKG1peGluKSB7XG4gIGxldCBtaXhpbkFwcGxpY2F0aW9ucyA9IC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKG1peGluKS5fX21peGluQXBwbGljYXRpb25zO1xuICBpZiAoIW1peGluQXBwbGljYXRpb25zKSB7XG4gICAgbWl4aW5BcHBsaWNhdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKG1peGluKS5fX21peGluQXBwbGljYXRpb25zID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gIH1cbiAgLy8gbWFpbnRhaW4gYSB1bmlxdWUgaWQgZm9yIGVhY2ggbWl4aW5cbiAgbGV0IG1peGluRGVkdXBlSWQgPSBkZWR1cGVJZCsrO1xuICBmdW5jdGlvbiBkZWR1cGluZ01peGluKGJhc2UpIHtcbiAgICBsZXQgYmFzZVNldCA9IC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGJhc2UpLl9fbWl4aW5TZXQ7XG4gICAgaWYgKGJhc2VTZXQgJiYgYmFzZVNldFttaXhpbkRlZHVwZUlkXSkge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGxldCBtYXAgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgICBsZXQgZXh0ZW5kZWQgPSBtYXAuZ2V0KGJhc2UpO1xuICAgIGlmICghZXh0ZW5kZWQpIHtcbiAgICAgIGV4dGVuZGVkID0gLyoqIEB0eXBlIHshRnVuY3Rpb259ICovKG1peGluKShiYXNlKTtcbiAgICAgIG1hcC5zZXQoYmFzZSwgZXh0ZW5kZWQpO1xuICAgICAgLy8gY29weSBpbmhlcml0ZWQgbWl4aW4gc2V0IGZyb20gdGhlIGV4dGVuZGVkIGNsYXNzLCBvciB0aGUgYmFzZSBjbGFzc1xuICAgICAgLy8gTk9URTogd2UgYXZvaWQgdXNlIG9mIFNldCBoZXJlIGJlY2F1c2Ugc29tZSBicm93c2VyIChJRTExKVxuICAgICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgICBsZXQgbWl4aW5TZXQgPSBPYmplY3QuY3JlYXRlKC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0IHx8IGJhc2VTZXQgfHwgbnVsbCk7XG4gICAgICBtaXhpblNldFttaXhpbkRlZHVwZUlkXSA9IHRydWU7XG4gICAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gIH1cblxuICByZXR1cm4gZGVkdXBpbmdNaXhpbjtcbn07XG4vKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/boot.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/boot.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable no-unused-vars */\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n *\n * @param {?} prop Property name\n * @param {*} obj Reference object\n * @return {string} Potentially renamed property name\n */\nwindow.JSCompiler_renameProperty = function (prop, obj) {\n  return prop;\n};\n/* eslint-enable */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9ib290LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vZmllbGQtYmFzZS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qcz8wNjFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIFdoZW4gdXNpbmcgQ2xvc3VyZSBDb21waWxlciwgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eShwcm9wZXJ0eSwgb2JqZWN0KSBpcyByZXBsYWNlZCBieSB0aGUgbXVuZ2VkIG5hbWUgZm9yIG9iamVjdFtwcm9wZXJ0eV1cbiAqIFdlIGNhbm5vdCBhbGlhcyB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBoYXZlIHRvIHVzZSBhIHNtYWxsIHNoaW0gdGhhdCBoYXMgdGhlIHNhbWUgYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICpcbiAqIEBwYXJhbSB7P30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0geyp9IG9iaiBSZWZlcmVuY2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFBvdGVudGlhbGx5IHJlbmFtZWQgcHJvcGVydHkgbmFtZVxuICovXG53aW5kb3cuSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIG9iaikge1xuICByZXR1cm4gcHJvcDtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmV4cG9ydCB7fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/boot.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/mixin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/mixin.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dedupingMixin\": () => (/* binding */ dedupingMixin)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n// unique global id for deduping mixins.\nlet dedupeId = 0;\n\n/**\n * @constructor\n * @extends {Function}\n * @private\n */\nfunction MixinFunction() {}\n/** @type {(WeakMap | undefined)} */\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet;\n\n/* eslint-disable valid-jsdoc */\n/**\n * Wraps an ES6 class expression mixin such that the mixin is only applied\n * if it has not already been applied its base argument. Also memoizes mixin\n * applications.\n *\n * @template T\n * @param {T} mixin ES6 class expression mixin to wrap\n * @return {T}\n * @suppress {invalidCasts}\n */\nconst dedupingMixin = function (mixin) {\n  let mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */\n    mixin.__mixinApplications = mixinApplications;\n  }\n  // maintain a unique id for each mixin\n  let mixinDedupeId = dedupeId++;\n  function dedupingMixin(base) {\n    let baseSet = /** @type {!MixinFunction} */base.__mixinSet;\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n    let map = mixinApplications;\n    let extended = map.get(base);\n    if (!extended) {\n      extended = /** @type {!Function} */mixin(base);\n      map.set(base, extended);\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      let mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n      /** @type {!MixinFunction} */\n      extended.__mixinSet = mixinSet;\n    }\n    return extended;\n  }\n  return dedupingMixin;\n};\n/* eslint-enable valid-jsdoc *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vZmllbGQtYmFzZS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanM/MzZiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyB1bmlxdWUgZ2xvYmFsIGlkIGZvciBkZWR1cGluZyBtaXhpbnMuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTWl4aW5GdW5jdGlvbigpe31cbi8qKiBAdHlwZSB7KFdlYWtNYXAgfCB1bmRlZmluZWQpfSAqL1xuTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpbkFwcGxpY2F0aW9ucztcbi8qKiBAdHlwZSB7KE9iamVjdCB8IHVuZGVmaW5lZCl9ICovXG5NaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluU2V0O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuLyoqXG4gKiBXcmFwcyBhbiBFUzYgY2xhc3MgZXhwcmVzc2lvbiBtaXhpbiBzdWNoIHRoYXQgdGhlIG1peGluIGlzIG9ubHkgYXBwbGllZFxuICogaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gYXBwbGllZCBpdHMgYmFzZSBhcmd1bWVudC4gQWxzbyBtZW1vaXplcyBtaXhpblxuICogYXBwbGljYXRpb25zLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IG1peGluIEVTNiBjbGFzcyBleHByZXNzaW9uIG1peGluIHRvIHdyYXBcbiAqIEByZXR1cm4ge1R9XG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZHVwaW5nTWl4aW4gPSBmdW5jdGlvbihtaXhpbikge1xuICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgaWYgKCFtaXhpbkFwcGxpY2F0aW9ucykge1xuICAgIG1peGluQXBwbGljYXRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICB9XG4gIC8vIG1haW50YWluIGEgdW5pcXVlIGlkIGZvciBlYWNoIG1peGluXG4gIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgZnVuY3Rpb24gZGVkdXBpbmdNaXhpbihiYXNlKSB7XG4gICAgbGV0IGJhc2VTZXQgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhiYXNlKS5fX21peGluU2V0O1xuICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgbGV0IGV4dGVuZGVkID0gbWFwLmdldChiYXNlKTtcbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICBtYXAuc2V0KGJhc2UsIGV4dGVuZGVkKTtcbiAgICAgIC8vIGNvcHkgaW5oZXJpdGVkIG1peGluIHNldCBmcm9tIHRoZSBleHRlbmRlZCBjbGFzcywgb3IgdGhlIGJhc2UgY2xhc3NcbiAgICAgIC8vIE5PVEU6IHdlIGF2b2lkIHVzZSBvZiBTZXQgaGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlciAoSUUxMSlcbiAgICAgIC8vIGNhbm5vdCBleHRlbmQgYSBiYXNlIFNldCB2aWEgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgbGV0IG1peGluU2V0ID0gT2JqZWN0LmNyZWF0ZSgvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCB8fCBiYXNlU2V0IHx8IG51bGwpO1xuICAgICAgbWl4aW5TZXRbbWl4aW5EZWR1cGVJZF0gPSB0cnVlO1xuICAgICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oZXh0ZW5kZWQpLl9fbWl4aW5TZXQgPSBtaXhpblNldDtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xuICB9XG5cbiAgcmV0dXJuIGRlZHVwaW5nTWl4aW47XG59O1xuLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/elements/dom-module.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/elements/dom-module.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DomModule\": () => (/* binding */ DomModule)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/settings.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nlet modules = {};\nlet lcModules = {};\n/**\n * Sets a dom-module into the global registry by id.\n *\n * @param {string} id dom-module id\n * @param {DomModule} module dom-module instance\n * @return {void}\n */\nfunction setModule(id, module) {\n  // store id separate from lowercased id so that\n  // in all cases mixedCase id will stored distinctly\n  // and lowercase version is a fallback\n  modules[id] = lcModules[id.toLowerCase()] = module;\n}\n/**\n * Retrieves a dom-module from the global registry by id.\n *\n * @param {string} id dom-module id\n * @return {DomModule!} dom-module instance\n */\nfunction findModule(id) {\n  return modules[id] || lcModules[id.toLowerCase()];\n}\nfunction styleOutsideTemplateCheck(inst) {\n  if (inst.querySelector('style')) {\n    console.warn('dom-module %s has style outside template', inst.id);\n  }\n}\n\n/**\n * The `dom-module` element registers the dom it contains to the name given\n * by the module's id attribute. It provides a unified database of dom\n * accessible via its static `import` API.\n *\n * A key use case of `dom-module` is for providing custom element `<template>`s\n * via HTML imports that are parsed by the native HTML parser, that can be\n * relocated during a bundling pass and still looked up by `id`.\n *\n * Example:\n *\n *     <dom-module id=\"foo\">\n *       <img src=\"stuff.png\">\n *     </dom-module>\n *\n * Then in code in some other location that cannot access the dom-module above\n *\n *     let img = customElements.get('dom-module').import('foo', 'img');\n *\n * @customElement\n * @extends HTMLElement\n * @summary Custom element that provides a registry of relocatable DOM content\n *   by `id` that is agnostic to bundling.\n * @unrestricted\n */\nclass DomModule extends HTMLElement {\n  /** @override */\n  static get observedAttributes() {\n    return ['id'];\n  }\n\n  /**\n   * Retrieves the element specified by the css `selector` in the module\n   * registered by `id`. For example, this.import('foo', 'img');\n   * @param {string} id The id of the dom-module in which to search.\n   * @param {string=} selector The css selector by which to find the element.\n   * @return {Element} Returns the element which matches `selector` in the\n   * module registered at the specified `id`.\n   *\n   * @export\n   * @nocollapse Referred to indirectly in style-gather.js\n   */\n  static import(id, selector) {\n    if (id) {\n      let m = findModule(id);\n      if (m && selector) {\n        return m.querySelector(selector);\n      }\n      return m;\n    }\n    return null;\n  }\n\n  /* eslint-disable no-unused-vars */\n  /**\n   * @param {string} name Name of attribute.\n   * @param {?string} old Old value of attribute.\n   * @param {?string} value Current value of attribute.\n   * @param {?string} namespace Attribute namespace.\n   * @return {void}\n   * @override\n   */\n  attributeChangedCallback(name, old, value, namespace) {\n    if (old !== value) {\n      this.register();\n    }\n  }\n  /* eslint-enable no-unused-args */\n\n  /**\n   * The absolute URL of the original location of this `dom-module`.\n   *\n   * This value will differ from this element's `ownerDocument` in the\n   * following ways:\n   * - Takes into account any `assetpath` attribute added during bundling\n   *   to indicate the original location relative to the bundled location\n   * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n   *   the path is relative to the import document's location since\n   *   `ownerDocument` is not currently polyfilled\n   */\n  get assetpath() {\n    // Don't override existing assetpath.\n    if (!this.__assetpath) {\n      // note: assetpath set via an attribute must be relative to this\n      // element's location; accommodate polyfilled HTMLImports\n      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;\n      const url = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveUrl)(this.getAttribute('assetpath') || '', owner.baseURI);\n      this.__assetpath = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.pathFromUrl)(url);\n    }\n    return this.__assetpath;\n  }\n\n  /**\n   * Registers the dom-module at a given id. This method should only be called\n   * when a dom-module is imperatively created. For\n   * example, `document.createElement('dom-module').register('foo')`.\n   * @param {string=} id The id at which to register the dom-module.\n   * @return {void}\n   */\n  register(id) {\n    id = id || this.id;\n    if (id) {\n      // Under strictTemplatePolicy, reject and null out any re-registered\n      // dom-module since it is ambiguous whether first-in or last-in is trusted\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_2__.strictTemplatePolicy && findModule(id) !== undefined) {\n        setModule(id, null);\n        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);\n      }\n      this.id = id;\n      setModule(id, this);\n      styleOutsideTemplateCheck(this);\n    }\n  }\n}\nDomModule.prototype['modules'] = modules;\ncustomElements.define('dom-module', DomModule);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmpzPzk4MTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5cbmltcG9ydCB7IHJlc29sdmVVcmwsIHBhdGhGcm9tVXJsIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuaW1wb3J0IHsgc3RyaWN0VGVtcGxhdGVQb2xpY3kgfSBmcm9tICcuLi91dGlscy9zZXR0aW5ncy5qcyc7XG5cbmxldCBtb2R1bGVzID0ge307XG5sZXQgbGNNb2R1bGVzID0ge307XG4vKipcbiAqIFNldHMgYSBkb20tbW9kdWxlIGludG8gdGhlIGdsb2JhbCByZWdpc3RyeSBieSBpZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgZG9tLW1vZHVsZSBpZFxuICogQHBhcmFtIHtEb21Nb2R1bGV9IG1vZHVsZSBkb20tbW9kdWxlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzZXRNb2R1bGUoaWQsIG1vZHVsZSkge1xuICAvLyBzdG9yZSBpZCBzZXBhcmF0ZSBmcm9tIGxvd2VyY2FzZWQgaWQgc28gdGhhdFxuICAvLyBpbiBhbGwgY2FzZXMgbWl4ZWRDYXNlIGlkIHdpbGwgc3RvcmVkIGRpc3RpbmN0bHlcbiAgLy8gYW5kIGxvd2VyY2FzZSB2ZXJzaW9uIGlzIGEgZmFsbGJhY2tcbiAgbW9kdWxlc1tpZF0gPSBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV0gPSBtb2R1bGU7XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIGRvbS1tb2R1bGUgZnJvbSB0aGUgZ2xvYmFsIHJlZ2lzdHJ5IGJ5IGlkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20tbW9kdWxlIGlkXG4gKiBAcmV0dXJuIHtEb21Nb2R1bGUhfSBkb20tbW9kdWxlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGZpbmRNb2R1bGUoaWQpIHtcbiAgcmV0dXJuIG1vZHVsZXNbaWRdIHx8IGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXTtcbn1cblxuZnVuY3Rpb24gc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayhpbnN0KSB7XG4gIGlmIChpbnN0LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpIHtcbiAgICBjb25zb2xlLndhcm4oJ2RvbS1tb2R1bGUgJXMgaGFzIHN0eWxlIG91dHNpZGUgdGVtcGxhdGUnLCBpbnN0LmlkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgZG9tLW1vZHVsZWAgZWxlbWVudCByZWdpc3RlcnMgdGhlIGRvbSBpdCBjb250YWlucyB0byB0aGUgbmFtZSBnaXZlblxuICogYnkgdGhlIG1vZHVsZSdzIGlkIGF0dHJpYnV0ZS4gSXQgcHJvdmlkZXMgYSB1bmlmaWVkIGRhdGFiYXNlIG9mIGRvbVxuICogYWNjZXNzaWJsZSB2aWEgaXRzIHN0YXRpYyBgaW1wb3J0YCBBUEkuXG4gKlxuICogQSBrZXkgdXNlIGNhc2Ugb2YgYGRvbS1tb2R1bGVgIGlzIGZvciBwcm92aWRpbmcgY3VzdG9tIGVsZW1lbnQgYDx0ZW1wbGF0ZT5gc1xuICogdmlhIEhUTUwgaW1wb3J0cyB0aGF0IGFyZSBwYXJzZWQgYnkgdGhlIG5hdGl2ZSBIVE1MIHBhcnNlciwgdGhhdCBjYW4gYmVcbiAqIHJlbG9jYXRlZCBkdXJpbmcgYSBidW5kbGluZyBwYXNzIGFuZCBzdGlsbCBsb29rZWQgdXAgYnkgYGlkYC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA8ZG9tLW1vZHVsZSBpZD1cImZvb1wiPlxuICogICAgICAgPGltZyBzcmM9XCJzdHVmZi5wbmdcIj5cbiAqICAgICA8L2RvbS1tb2R1bGU+XG4gKlxuICogVGhlbiBpbiBjb2RlIGluIHNvbWUgb3RoZXIgbG9jYXRpb24gdGhhdCBjYW5ub3QgYWNjZXNzIHRoZSBkb20tbW9kdWxlIGFib3ZlXG4gKlxuICogICAgIGxldCBpbWcgPSBjdXN0b21FbGVtZW50cy5nZXQoJ2RvbS1tb2R1bGUnKS5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgcHJvdmlkZXMgYSByZWdpc3RyeSBvZiByZWxvY2F0YWJsZSBET00gY29udGVudFxuICogICBieSBgaWRgIHRoYXQgaXMgYWdub3N0aWMgdG8gYnVuZGxpbmcuXG4gKiBAdW5yZXN0cmljdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBEb21Nb2R1bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnaWQnXTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBjc3MgYHNlbGVjdG9yYCBpbiB0aGUgbW9kdWxlXG4gICAqIHJlZ2lzdGVyZWQgYnkgYGlkYC4gRm9yIGV4YW1wbGUsIHRoaXMuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGRvbS1tb2R1bGUgaW4gd2hpY2ggdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdG9yIFRoZSBjc3Mgc2VsZWN0b3IgYnkgd2hpY2ggdG8gZmluZCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgZWxlbWVudCB3aGljaCBtYXRjaGVzIGBzZWxlY3RvcmAgaW4gdGhlXG4gICAqIG1vZHVsZSByZWdpc3RlcmVkIGF0IHRoZSBzcGVjaWZpZWQgYGlkYC5cbiAgICpcbiAgICogQGV4cG9ydFxuICAgKiBAbm9jb2xsYXBzZSBSZWZlcnJlZCB0byBpbmRpcmVjdGx5IGluIHN0eWxlLWdhdGhlci5qc1xuICAgKi9cbiAgc3RhdGljIGltcG9ydChpZCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGxldCBtID0gZmluZE1vZHVsZShpZCk7XG4gICAgICBpZiAobSAmJiBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2UgQXR0cmlidXRlIG5hbWVzcGFjZS5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtYXJncyAqL1xuXG4gIC8qKlxuICAgKiBUaGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGlzIGBkb20tbW9kdWxlYC5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSB3aWxsIGRpZmZlciBmcm9tIHRoaXMgZWxlbWVudCdzIGBvd25lckRvY3VtZW50YCBpbiB0aGVcbiAgICogZm9sbG93aW5nIHdheXM6XG4gICAqIC0gVGFrZXMgaW50byBhY2NvdW50IGFueSBgYXNzZXRwYXRoYCBhdHRyaWJ1dGUgYWRkZWQgZHVyaW5nIGJ1bmRsaW5nXG4gICAqICAgdG8gaW5kaWNhdGUgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBidW5kbGVkIGxvY2F0aW9uXG4gICAqIC0gVXNlcyB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwncyBgaW1wb3J0Rm9yRWxlbWVudGAgQVBJIHRvIGVuc3VyZVxuICAgKiAgIHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgZG9jdW1lbnQncyBsb2NhdGlvbiBzaW5jZVxuICAgKiAgIGBvd25lckRvY3VtZW50YCBpcyBub3QgY3VycmVudGx5IHBvbHlmaWxsZWRcbiAgICovXG4gIGdldCBhc3NldHBhdGgoKSB7XG4gICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYXNzZXRwYXRoLlxuICAgIGlmICghdGhpcy5fX2Fzc2V0cGF0aCkge1xuICAgICAgLy8gbm90ZTogYXNzZXRwYXRoIHNldCB2aWEgYW4gYXR0cmlidXRlIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhpc1xuICAgICAgLy8gZWxlbWVudCdzIGxvY2F0aW9uOyBhY2NvbW1vZGF0ZSBwb2x5ZmlsbGVkIEhUTUxJbXBvcnRzXG4gICAgICBjb25zdCBvd25lciA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50ID9cbiAgICAgICAgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCh0aGlzKSB8fCBkb2N1bWVudCA6IHRoaXMub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IHVybCA9IHJlc29sdmVVcmwoXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdhc3NldHBhdGgnKSB8fCAnJywgb3duZXIuYmFzZVVSSSk7XG4gICAgICB0aGlzLl9fYXNzZXRwYXRoID0gcGF0aEZyb21VcmwodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19hc3NldHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBkb20tbW9kdWxlIGF0IGEgZ2l2ZW4gaWQuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZFxuICAgKiB3aGVuIGEgZG9tLW1vZHVsZSBpcyBpbXBlcmF0aXZlbHkgY3JlYXRlZC4gRm9yXG4gICAqIGV4YW1wbGUsIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykucmVnaXN0ZXIoJ2ZvbycpYC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCBUaGUgaWQgYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGRvbS1tb2R1bGUuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICByZWdpc3RlcihpZCkge1xuICAgIGlkID0gaWQgfHwgdGhpcy5pZDtcbiAgICBpZiAoaWQpIHtcbiAgICAgIC8vIFVuZGVyIHN0cmljdFRlbXBsYXRlUG9saWN5LCByZWplY3QgYW5kIG51bGwgb3V0IGFueSByZS1yZWdpc3RlcmVkXG4gICAgICAvLyBkb20tbW9kdWxlIHNpbmNlIGl0IGlzIGFtYmlndW91cyB3aGV0aGVyIGZpcnN0LWluIG9yIGxhc3QtaW4gaXMgdHJ1c3RlZFxuICAgICAgaWYgKHN0cmljdFRlbXBsYXRlUG9saWN5ICYmIGZpbmRNb2R1bGUoaWQpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0TW9kdWxlKGlkLCBudWxsKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpY3RUZW1wbGF0ZVBvbGljeTogZG9tLW1vZHVsZSAke2lkfSByZS1yZWdpc3RlcmVkYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICBzZXRNb2R1bGUoaWQsIHRoaXMpO1xuICAgICAgc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuRG9tTW9kdWxlLnByb3RvdHlwZVsnbW9kdWxlcyddID0gbW9kdWxlcztcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tbW9kdWxlJywgRG9tTW9kdWxlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/elements/dom-module.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/element-mixin.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/element-mixin.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ElementMixin\": () => (/* binding */ ElementMixin),\n/* harmony export */   \"builtCSS\": () => (/* binding */ builtCSS),\n/* harmony export */   \"updateStyles\": () => (/* binding */ updateStyles),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/settings.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/style-gather.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/style-gather.js\");\n/* harmony import */ var _utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/resolve-url.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../elements/dom-module.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n/* harmony import */ var _property_effects_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./property-effects.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-effects.js\");\n/* harmony import */ var _properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./properties-mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * Current Polymer version in Semver notation.\n * @type {string} Semver notation of the current version of Polymer.\n */\nconst version = '3.5.1';\nconst builtCSS = window.ShadyCSS && window.ShadyCSS['cssBuild'];\n\n/**\n * Element class mixin that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * Subclassers may provide the following static getters to return metadata\n * used to configure Polymer's features for the class:\n *\n * - `static get is()`: When the template is provided via a `dom-module`,\n *   users should return the `dom-module` id from a static `is` getter.  If\n *   no template is needed or the template is provided directly via the\n *   `template` getter, there is no need to define `is` for the element.\n *\n * - `static get template()`: Users may provide the template directly (as\n *   opposed to via `dom-module`) by implementing a static `template` getter.\n *   The getter must return an `HTMLTemplateElement`.\n *\n * - `static get properties()`: Should return an object describing\n *   property-related metadata used by Polymer features (key: property name\n *   value: object containing property metadata). Valid keys in per-property\n *   metadata include:\n *   - `type` (String|Number|Object|Array|...): Used by\n *     `attributeChangedCallback` to determine how string-based attributes\n *     are deserialized to JavaScript property values.\n *   - `notify` (boolean): Causes a change in the property to fire a\n *     non-bubbling event called `<property>-changed`. Elements that have\n *     enabled two-way binding to the property use this event to observe changes.\n *   - `readOnly` (boolean): Creates a getter for the property, but no setter.\n *     To set a read-only property, use the private setter method\n *     `_setProperty(property, value)`.\n *   - `observer` (string): Observer method name that will be called when\n *     the property changes. The arguments of the method are\n *     `(value, previousValue)`.\n *   - `computed` (string): String describing method and dependent properties\n *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).\n *     Computed properties are read-only by default and can only be changed\n *     via the return value of the computing method.\n *\n * - `static get observers()`: Array of strings describing multi-property\n *   observer methods and their dependent properties (e.g.\n *   `'observeABC(a, b, c)'`).\n *\n * The base class provides default implementations for the following standard\n * custom element lifecycle callbacks; users may override these, but should\n * call the super method to ensure\n * - `constructor`: Run when the element is created or upgraded\n * - `connectedCallback`: Run each time the element is connected to the\n *   document\n * - `disconnectedCallback`: Run each time the element is disconnected from\n *   the document\n * - `attributeChangedCallback`: Run each time an attribute in\n *   `observedAttributes` is set or removed (note: this element's default\n *   `observedAttributes` implementation will automatically return an array\n *   of dash-cased attributes based on `properties`)\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyEffects\n * @appliesMixin PropertiesMixin\n * @property rootPath {string} Set to the value of `rootPath`,\n *   which defaults to the main document path\n * @property importPath {string} Set to the value of the class's static\n *   `importPath` property, which defaults to the path of this element's\n *   `dom-module` (when `is` is used), but can be overridden for other\n *   import strategies.\n * @summary Element class mixin that provides the core API for Polymer's\n * meta-programming features.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst ElementMixin = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__.dedupingMixin)(base => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const polymerElementBase = (0,_properties_mixin_js__WEBPACK_IMPORTED_MODULE_7__.PropertiesMixin)((0,_property_effects_js__WEBPACK_IMPORTED_MODULE_6__.PropertyEffects)(base));\n\n  /**\n   * Returns a list of properties with default values.\n   * This list is created as an optimization since it is a subset of\n   * the list returned from `_properties`.\n   * This list is used in `_initializeProperties` to set property defaults.\n   *\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {PolymerElementProperties} Flattened properties for this class\n   *   that have default values\n   * @private\n   */\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n      for (let p in props) {\n        let info = props[p];\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n    return constructor.__propertyDefaults;\n  }\n\n  /**\n   * Returns a memoized version of the `observers` array.\n   * @param {PolymerElementConstructor} constructor Element class\n   * @return {Array} Array containing own observers for the given class\n   * @protected\n   */\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ? /** @type {PolymerElementConstructor} */constructor.observers : null;\n    }\n    return constructor.__ownObservers;\n  }\n\n  /**\n   * Creates effects for a property.\n   *\n   * Note, once a property has been set to\n   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n   * these values may not be changed. For example, a subclass cannot\n   * alter these settings. However, additional `observers` may be added\n   * by subclasses.\n   *\n   * The info object should contain property metadata as follows:\n   *\n   * * `type`: {function} type to which an attribute matching the property\n   * is deserialized. Note the property is camel-cased from a dash-cased\n   * attribute. For example, 'foo-bar' attribute is deserialized to a\n   * property named 'fooBar'.\n   *\n   * * `readOnly`: {boolean} creates a readOnly property and\n   * makes a private setter for the private of the form '_setFoo' for a\n   * property 'foo',\n   *\n   * * `computed`: {string} creates a computed property. A computed property\n   * is also automatically set to `readOnly: true`. The value is calculated\n   * by running a method and arguments parsed from the given string. For\n   * example 'compute(foo)' will compute a given property when the\n   * 'foo' property changes by executing the 'compute' method. This method\n   * must return the computed value.\n   *\n   * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n   * to an attribute of the same name. Note, the attribute is dash-cased\n   * so a property named 'fooBar' is reflected as 'foo-bar'.\n   *\n   * * `notify`: {boolean} sends a non-bubbling notification event when\n   * the property changes. For example, a property named 'foo' sends an\n   * event named 'foo-changed' with `event.detail` set to the value of\n   * the property.\n   *\n   * * observer: {string} name of a method that runs when the property\n   * changes. The arguments of the method are (value, previousValue).\n   *\n   * Note: Users may want control over modifying property\n   * effects via subclassing. For example, a user might want to make a\n   * reflectToAttribute property not do so in a subclass. We've chosen to\n   * disable this because it leads to additional complication.\n   * For example, a readOnly effect generates a special setter. If a subclass\n   * disables the effect, the setter would fail unexpectedly.\n   * Based on feedback, we may want to try to make effects more malleable\n   * and/or provide an advanced api for manipulating them.\n   *\n   * @param {!PolymerElement} proto Element class prototype to add accessors\n   *   and effects to\n   * @param {string} name Name of the property.\n   * @param {Object} info Info object from which to create property effects.\n   * Supported keys:\n   * @param {Object} allProps Flattened map of all properties defined in this\n   *   element (including inherited properties)\n   * @return {void}\n   * @private\n   */\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    }\n    // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n    if (info.computed) {\n      if (proto._hasReadOnlyEffect(name)) {\n        console.warn(`Cannot redefine computed property '${name}'.`);\n      } else {\n        proto._createComputedProperty(name, info.computed, allProps);\n      }\n    }\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    } else if (info.readOnly === false && proto._hasReadOnlyEffect(name)) {\n      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);\n    }\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    } else if (info.reflectToAttribute === false && proto._hasReflectEffect(name)) {\n      console.warn(`Cannot make reflected property '${name}' non-reflected.`);\n    }\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } else if (info.notify === false && proto._hasNotifyEffect(name)) {\n      console.warn(`Cannot make notify property '${name}' non-notify.`);\n    }\n    // always add observer\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    }\n    // always create the mapping from attribute back to property for deserialization.\n    proto._addPropertyToAttributeMap(name);\n  }\n\n  /**\n   * Process all style elements in the element template. Styles with the\n   * `include` attribute are processed such that any styles in\n   * the associated \"style modules\" are included in the element template.\n   * @param {PolymerElementConstructor} klass Element class\n   * @param {!HTMLTemplateElement} template Template to process\n   * @param {string} is Name of element\n   * @param {string} baseURI Base URI for element\n   * @private\n   */\n  function processElementStyles(klass, template, is, baseURI) {\n    if (!builtCSS) {\n      const templateStyles = template.content.querySelectorAll('style');\n      const stylesWithImports = (0,_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__.stylesFromTemplate)(template);\n      // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n      const linkedStyles = (0,_utils_style_gather_js__WEBPACK_IMPORTED_MODULE_3__.stylesFromModuleImports)(is);\n      const firstTemplateChild = template.content.firstElementChild;\n      for (let idx = 0; idx < linkedStyles.length; idx++) {\n        let s = linkedStyles[idx];\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n        template.content.insertBefore(s, firstTemplateChild);\n      }\n      // keep track of the last \"concrete\" style in the template we have encountered\n      let templateStyleIndex = 0;\n      // ensure all gathered styles are actually in this template.\n      for (let i = 0; i < stylesWithImports.length; i++) {\n        let s = stylesWithImports[i];\n        let templateStyle = templateStyles[templateStyleIndex];\n        // if the style is not in this template, it's been \"included\" and\n        // we put a clone of it in the template before the style that included it\n        if (templateStyle !== s) {\n          s = s.cloneNode(true);\n          templateStyle.parentNode.insertBefore(s, templateStyle);\n        } else {\n          templateStyleIndex++;\n        }\n        s.textContent = klass._processStyleText(s.textContent, baseURI);\n      }\n    }\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n    // Support for `adoptedStylesheets` relies on using native Shadow DOM\n    // and built CSS. Built CSS is required because runtime transformation of\n    // `@apply` is not supported. This is because ShadyCSS relies on being able\n    // to update a `style` element in the element template and this is\n    // removed when using `adoptedStyleSheets`.\n    // Note, it would be more efficient to allow style includes to become\n    // separate stylesheets; however, because of `@apply` these are\n    // potentially not shareable and sharing the ones that could be shared\n    // would require some coordination. To keep it simple, all the includes\n    // and styles are collapsed into a single shareable stylesheet.\n    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.useAdoptedStyleSheetsWithBuiltCSS && builtCSS && _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.supportsAdoptingStyleSheets) {\n      // Remove styles in template and make a shareable stylesheet\n      const styles = template.content.querySelectorAll('style');\n      if (styles) {\n        let css = '';\n        Array.from(styles).forEach(s => {\n          css += s.textContent;\n          s.parentNode.removeChild(s);\n        });\n        klass._styleSheet = new CSSStyleSheet();\n        klass._styleSheet.replaceSync(css);\n      }\n    }\n  }\n\n  /**\n   * Look up template from dom-module for element\n   *\n   * @param {string} is Element name to look up\n   * @return {?HTMLTemplateElement|undefined} Template found in dom module, or\n   *   undefined if not found\n   * @protected\n   */\n  function getTemplateFromDomModule(is) {\n    let template = null;\n    // Under strictTemplatePolicy in 3.x+, dom-module lookup is only allowed\n    // when opted-in via allowTemplateFromDomModule\n    if (is && (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.strictTemplatePolicy || _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.allowTemplateFromDomModule)) {\n      template = /** @type {?HTMLTemplateElement} */\n      _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__.DomModule[\"import\"](is, 'template');\n      // Under strictTemplatePolicy, require any element with an `is`\n      // specified to have a dom-module\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.strictTemplatePolicy && !template) {\n        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);\n      }\n    }\n    return template;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @unrestricted\n   * @implements {Polymer_ElementMixin}\n   * @extends {polymerElementBase}\n   */\n  class PolymerElement extends polymerElementBase {\n    /**\n     * Current Polymer version in Semver notation.\n     * @type {string} Semver notation of the current version of Polymer.\n     * @nocollapse\n     */\n    static get polymerElementVersion() {\n      return version;\n    }\n\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _finalizeClass() {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      polymerElementBase._finalizeClass.call(this);\n      const observers = ownObservers(this);\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      }\n      this._prepareTemplate();\n    }\n\n    /** @nocollapse */\n    static _prepareTemplate() {\n      // note: create \"working\" template that is finalized at instance time\n      let template = /** @type {PolymerElementConstructor} */this.template;\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.legacyOptimizations) {\n          template = template.cloneNode(true);\n        }\n      }\n\n      /** @override */\n      this.prototype._template = template;\n    }\n\n    /**\n     * Override of PropertiesChanged createProperties to create accessors\n     * and property effects for all of the properties.\n     * @param {!Object} props .\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig( /** @type {?} */this.prototype, p, props[p], props);\n      }\n    }\n\n    /**\n     * Creates observers for the given `observers` array.\n     * Leverages `PropertyEffects` to create observers.\n     * @param {Object} observers Array of observer descriptors for\n     *   this class\n     * @param {Object} dynamicFns Object containing keys for any properties\n     *   that are functions and should trigger the effect when the function\n     *   reference is changed\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n      for (let i = 0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    }\n\n    /**\n     * Returns the template that will be stamped into this element's shadow root.\n     *\n     * If a `static get is()` getter is defined, the default implementation will\n     * return the first `<template>` in a `dom-module` whose `id` matches this\n     * element's `is` (note that a `_template` property on the class prototype\n     * takes precedence over the `dom-module` template, to maintain legacy\n     * element semantics; a subclass will subsequently fall back to its super\n     * class template if neither a `prototype._template` or a `dom-module` for\n     * the class's `is` was found).\n     *\n     * Users may override this getter to return an arbitrary template\n     * (in which case the `is` getter is unnecessary). The template returned\n     * must be an `HTMLTemplateElement`.\n     *\n     * Note that when subclassing, if the super class overrode the default\n     * implementation and the subclass would like to provide an alternate\n     * template via a `dom-module`, it should override this getter and\n     * return `DomModule.import(this.is, 'template')`.\n     *\n     * If a subclass would like to modify the super class template, it should\n     * clone it rather than modify it in place.  If the getter does expensive\n     * work such as cloning/modifying a template, it should memoize the\n     * template for maximum performance:\n     *\n     *   let memoizedTemplate;\n     *   class MySubClass extends MySuperClass {\n     *     static get template() {\n     *       if (!memoizedTemplate) {\n     *         memoizedTemplate = super.template.cloneNode(true);\n     *         let subContent = document.createElement('div');\n     *         subContent.textContent = 'This came from MySubClass';\n     *         memoizedTemplate.content.appendChild(subContent);\n     *       }\n     *       return memoizedTemplate;\n     *     }\n     *   }\n     *\n     * @return {!HTMLTemplateElement|string} Template to be stamped\n     * @nocollapse\n     */\n    static get template() {\n      // Explanation of template-related properties:\n      // - constructor.template (this getter): the template for the class.\n      //     This can come from the prototype (for legacy elements), from a\n      //     dom-module, or from the super class's template (or can be overridden\n      //     altogether by the user)\n      // - constructor._template: memoized version of constructor.template\n      // - prototype._template: working template for the element, which will be\n      //     parsed and modified in place. It is a cloned version of\n      //     constructor.template, saved in _finalizeClass(). Note that before\n      //     this getter is called, for legacy elements this could be from a\n      //     _template field on the info object passed to Polymer(), a behavior,\n      //     or set in registered(); once the static getter runs, a clone of it\n      //     will overwrite it on the prototype as the working template.\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        let protoTemplate = this.prototype.hasOwnProperty(JSCompiler_renameProperty('_template', this.prototype)) ? this.prototype._template : undefined;\n        // Accept a function for the legacy Polymer({_template:...}) field for\n        // lazy parsing\n        if (typeof protoTemplate === 'function') {\n          protoTemplate = protoTemplate();\n        }\n        this._template =\n        // If user has put template on prototype (e.g. in legacy via registered\n        // callback or info object), prefer that first. Note that `null` is\n        // used as a sentinel to indicate \"no template\" and can be used to\n        // override a super template, whereas `undefined` is used as a\n        // sentinel to mean \"fall-back to default template lookup\" via\n        // dom-module and/or super.template.\n        protoTemplate !== undefined ? protoTemplate :\n        // Look in dom-module associated with this element's is\n        this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && getTemplateFromDomModule( /** @type {PolymerElementConstructor}*/this.is) ||\n        // Next look for superclass template (call the super impl this\n        // way so that `this` points to the superclass)\n        Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.template;\n      }\n      return this._template;\n    }\n\n    /**\n     * Set the template.\n     *\n     * @param {!HTMLTemplateElement|string} value Template to set.\n     * @nocollapse\n     */\n    static set template(value) {\n      this._template = value;\n    }\n\n    /**\n     * Path matching the url from which the element was imported.\n     *\n     * This path is used to resolve url's in template style cssText.\n     * The `importPath` property is also set on element instances and can be\n     * used to create bindings relative to the import path.\n     *\n     * For elements defined in ES modules, users should implement\n     * `static get importMeta() { return import.meta; }`, and the default\n     * implementation of `importPath` will  return `import.meta.url`'s path.\n     * For elements defined in HTML imports, this getter will return the path\n     * to the document containing a `dom-module` element matching this\n     * element's static `is` property.\n     *\n     * Note, this path should contain a trailing `/`.\n     *\n     * @return {string} The import path for this element class\n     * @suppress {missingProperties}\n     * @nocollapse\n     */\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n        if (meta) {\n          this._importPath = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.pathFromUrl)(meta.url);\n        } else {\n          const module = _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_5__.DomModule[\"import\"]( /** @type {PolymerElementConstructor} */this.is);\n          this._importPath = module && module.assetpath || Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.importPath;\n        }\n      }\n      return this._importPath;\n    }\n    constructor() {\n      super();\n      /** @type {HTMLTemplateElement} */\n      this._template;\n      /** @type {string} */\n      this._importPath;\n      /** @type {string} */\n      this.rootPath;\n      /** @type {string} */\n      this.importPath;\n      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      this.root;\n      /** @type {!Object<string, !Element>} */\n      this.$;\n    }\n\n    /**\n     * Overrides the default `PropertyAccessors` to ensure class\n     * metaprogramming related to property accessors and effects has\n     * completed (calls `finalize`).\n     *\n     * It also initializes any property defaults provided via `value` in\n     * `properties` metadata.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts,missingProperties} go/missingfnprops\n     */\n    _initializeProperties() {\n      this.constructor.finalize();\n      // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n      this.constructor._finalizeTemplate( /** @type {!HTMLElement} */this.localName);\n      super._initializeProperties();\n      // set path defaults\n      this.rootPath = _utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.rootPath;\n      this.importPath = this.constructor.importPath;\n      // apply property defaults...\n      let p$ = propertyDefaults(this.constructor);\n      if (!p$) {\n        return;\n      }\n      for (let p in p$) {\n        let info = p$[p];\n        if (this._canApplyPropertyDefault(p)) {\n          let value = typeof info.value == 'function' ? info.value.call(this) : info.value;\n          // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determines if a property dfeault can be applied. For example, this\n     * prevents a default from being applied when a property that has no\n     * accessor is overridden by its host before upgrade (e.g. via a binding).\n     * @override\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property default can be applied.\n     */\n    _canApplyPropertyDefault(property) {\n      return !this.hasOwnProperty(property);\n    }\n\n    /**\n     * Gather style text for a style element in the template.\n     *\n     * @param {string} cssText Text containing styling to process\n     * @param {string} baseURI Base URI to rebase CSS paths against\n     * @return {string} The processed CSS text\n     * @protected\n     * @nocollapse\n     */\n    static _processStyleText(cssText, baseURI) {\n      return (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveCss)(cssText, baseURI);\n    }\n\n    /**\n    * Configures an element `proto` to function with a given `template`.\n    * The element name `is` and extends `ext` must be specified for ShadyCSS\n    * style scoping.\n    *\n    * @param {string} is Tag name (or type extension name) for this element\n    * @return {void}\n    * @protected\n    * @nocollapse\n    */\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */\n      const template = this.prototype._template;\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(importPath) : '';\n        // e.g. support `include=\"module-name\"`, and ShadyCSS\n        processElementStyles(this, template, is, baseURI);\n        this.prototype._bindTemplate(template);\n      }\n    }\n\n    /**\n     * Provides a default implementation of the standard Custom Elements\n     * `connectedCallback`.\n     *\n     * The default implementation enables the property effects system and\n     * flushes any pending properties, and updates shimmed CSS properties\n     * when using the ShadyCSS scoping/custom properties polyfill.\n     *\n     * @override\n     * @suppress {missingProperties, invalidCasts} Super may or may not\n     *     implement the callback\n     * @return {void}\n     */\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);\n      }\n      super.connectedCallback();\n    }\n\n    /**\n     * Stamps the element template.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n      super.ready();\n    }\n\n    /**\n     * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n     * element dom by calling `_attachDom` with the dom stamped from the\n     * element's template via `_stampTemplate`. Note that this allows\n     * client dom to be attached to the element prior to any observers\n     * running.\n     *\n     * @return {void}\n     * @override\n     */\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom( /** @type {StampedTemplate} */this.root);\n      }\n      // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n      super._readyClients();\n    }\n\n    /**\n     * Attaches an element's stamped dom to itself. By default,\n     * this method creates a `shadowRoot` and adds the dom to it.\n     * However, this method may be overridden to allow an element\n     * to put its dom in another location.\n     *\n     * @override\n     * @throws {Error}\n     * @suppress {missingReturn}\n     * @param {StampedTemplate} dom to attach to the element.\n     * @return {ShadowRoot} node to which the dom has been attached.\n     */\n    _attachDom(dom) {\n      const n = (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_8__.wrap)(this);\n      if (n.attachShadow) {\n        if (dom) {\n          if (!n.shadowRoot) {\n            n.attachShadow({\n              mode: 'open',\n              shadyUpgradeFragment: dom\n            });\n            n.shadowRoot.appendChild(dom);\n            // When `adoptedStyleSheets` is supported a stylesheet is made\n            // available on the element constructor.\n            if (this.constructor._styleSheet) {\n              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];\n            }\n          }\n          if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.syncInitialRender && window.ShadyDOM) {\n            window.ShadyDOM.flushInitial(n.shadowRoot);\n          }\n          return n.shadowRoot;\n        }\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' +\n        // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    }\n\n    /**\n     * When using the ShadyCSS scoping and custom property shim, causes all\n     * shimmed styles in this element (and its subtree) to be updated\n     * based on current custom property values.\n     *\n     * The optional parameter overrides inline custom property styles with an\n     * object of properties where the keys are CSS properties, and the values\n     * are strings.\n     *\n     * Example: `this.updateStyles({'--color': 'blue'})`\n     *\n     * These properties are retained unless a value of `null` is set.\n     *\n     * Note: This function does not support updating CSS mixins.\n     * You can not dynamically change the value of an `@apply`.\n     *\n     * @override\n     * @param {Object=} properties Bag of custom property key/values to\n     *   apply to this element.\n     * @return {void}\n     * @suppress {invalidCasts}\n     */\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);\n      }\n    }\n\n    /**\n     * Rewrites a given URL relative to a base URL. The base URL defaults to\n     * the original location of the document containing the `dom-module` for\n     * this element. This method will return the same URL before and after\n     * bundling.\n     *\n     * Note that this function performs no resolution for URLs that start\n     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n     * URL resolution, use `window.URL`.\n     *\n     * @override\n     * @param {string} url URL to resolve.\n     * @param {string=} base Optional base URL to resolve against, defaults\n     * to the element's `importPath`\n     * @return {string} Rewritten URL relative to base\n     */\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(this.importPath);\n      }\n      return (0,_utils_resolve_url_js__WEBPACK_IMPORTED_MODULE_4__.resolveUrl)(url, base);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to add map of dynamic functions on\n     * template info, for consumption by `PropertyEffects` template binding\n     * code. This map determines which method templates should have accessors\n     * created for them.\n     *\n     * @param {!HTMLTemplateElement} template Template\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._parseTemplateContent.call(this, template, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Overrides `PropertyEffects` to warn on use of undeclared properties in\n     * template.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      // Warn if properties are used in template without being declared.\n      // Properties must be listed in `properties` to be included in\n      // `observedAttributes` since CE V1 reads that at registration time, and\n      // since we want to keep template parsing lazy, we can't automatically\n      // add undeclared properties used in templates to `observedAttributes`.\n      // The warning is only enabled in `legacyOptimizations` mode, since\n      // we don't want to spam existing users who might have adopted the\n      // shorthand when attribute deserialization is not important.\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_1__.legacyWarnings && !(prop in this._properties) &&\n      // Methods used in templates with no dependencies (or only literal\n      // dependencies) become accessors with template effects; ignore these\n      !(effect.info.part.signature && effect.info.part.signature.static) &&\n      // Warnings for bindings added to nested templates are handled by\n      // templatizer so ignore both the host-to-template bindings\n      // (`hostProp`) and TemplateInstance-to-child bindings\n      // (`nestedTemplate`)\n      !effect.info.part.hostProp && !templateInfo.nestedTemplate) {\n        console.warn(`Property '${prop}' used in template but not declared in 'properties'; ` + `attribute will not be observed.`);\n      }\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      return polymerElementBase._addTemplatePropertyEffect.call(this, templateInfo, prop, effect);\n    }\n  }\n  return PolymerElement;\n});\n\n/**\n * When using the ShadyCSS scoping and custom property shim, causes all\n * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n * to be updated based on current custom property values.\n *\n * The optional parameter overrides inline custom property styles with an\n * object of properties where the keys are CSS properties, and the values\n * are strings.\n *\n * Example: `updateStyles({'--color': 'blue'})`\n *\n * These properties are retained unless a value of `null` is set.\n *\n * @param {Object=} props Bag of custom property key/values to\n *   apply to the document.\n * @return {void}\n */\nconst updateStyles = function (props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uanM/YzAyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIEBzdXBwcmVzcyB7Y2hlY2tQcm90b3R5cGFsVHlwZXN9XG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZFxuICogYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heVxuICogYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieVxuICogR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUFxuICogcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuXG5pbXBvcnQgeyByb290UGF0aCwgc3RyaWN0VGVtcGxhdGVQb2xpY3ksIGFsbG93VGVtcGxhdGVGcm9tRG9tTW9kdWxlLCBsZWdhY3lPcHRpbWl6YXRpb25zLCBsZWdhY3lXYXJuaW5ncywgc3luY0luaXRpYWxSZW5kZXIsIHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cywgdXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHN0eWxlc0Zyb21UZW1wbGF0ZSwgc3R5bGVzRnJvbU1vZHVsZUltcG9ydHMgfSBmcm9tICcuLi91dGlscy9zdHlsZS1nYXRoZXIuanMnO1xuaW1wb3J0IHsgcGF0aEZyb21VcmwsIHJlc29sdmVDc3MsIHJlc29sdmVVcmwgfSBmcm9tICcuLi91dGlscy9yZXNvbHZlLXVybC5qcyc7XG5pbXBvcnQgeyBEb21Nb2R1bGUgfSBmcm9tICcuLi9lbGVtZW50cy9kb20tbW9kdWxlLmpzJztcbmltcG9ydCB7IFByb3BlcnR5RWZmZWN0cyB9IGZyb20gJy4vcHJvcGVydHktZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0aWVzTWl4aW4gfSBmcm9tICcuL3Byb3BlcnRpZXMtbWl4aW4uanMnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJy4uL3V0aWxzL3dyYXAuanMnO1xuXG4vKipcbiAqIEN1cnJlbnQgUG9seW1lciB2ZXJzaW9uIGluIFNlbXZlciBub3RhdGlvbi5cbiAqIEB0eXBlIHtzdHJpbmd9IFNlbXZlciBub3RhdGlvbiBvZiB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFBvbHltZXIuXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzMuNS4xJztcblxuZXhwb3J0IGNvbnN0IGJ1aWx0Q1NTID0gd2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTU1snY3NzQnVpbGQnXTtcblxuLyoqXG4gKiBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICogZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sXG4gKiBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uLlxuICpcbiAqIFN1YmNsYXNzZXJzIG1heSBwcm92aWRlIHRoZSBmb2xsb3dpbmcgc3RhdGljIGdldHRlcnMgdG8gcmV0dXJuIG1ldGFkYXRhXG4gKiB1c2VkIHRvIGNvbmZpZ3VyZSBQb2x5bWVyJ3MgZmVhdHVyZXMgZm9yIHRoZSBjbGFzczpcbiAqXG4gKiAtIGBzdGF0aWMgZ2V0IGlzKClgOiBXaGVuIHRoZSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCB2aWEgYSBgZG9tLW1vZHVsZWAsXG4gKiAgIHVzZXJzIHNob3VsZCByZXR1cm4gdGhlIGBkb20tbW9kdWxlYCBpZCBmcm9tIGEgc3RhdGljIGBpc2AgZ2V0dGVyLiAgSWZcbiAqICAgbm8gdGVtcGxhdGUgaXMgbmVlZGVkIG9yIHRoZSB0ZW1wbGF0ZSBpcyBwcm92aWRlZCBkaXJlY3RseSB2aWEgdGhlXG4gKiAgIGB0ZW1wbGF0ZWAgZ2V0dGVyLCB0aGVyZSBpcyBubyBuZWVkIHRvIGRlZmluZSBgaXNgIGZvciB0aGUgZWxlbWVudC5cbiAqXG4gKiAtIGBzdGF0aWMgZ2V0IHRlbXBsYXRlKClgOiBVc2VycyBtYXkgcHJvdmlkZSB0aGUgdGVtcGxhdGUgZGlyZWN0bHkgKGFzXG4gKiAgIG9wcG9zZWQgdG8gdmlhIGBkb20tbW9kdWxlYCkgYnkgaW1wbGVtZW50aW5nIGEgc3RhdGljIGB0ZW1wbGF0ZWAgZ2V0dGVyLlxuICogICBUaGUgZ2V0dGVyIG11c3QgcmV0dXJuIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YC5cbiAqXG4gKiAtIGBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKWA6IFNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGRlc2NyaWJpbmdcbiAqICAgcHJvcGVydHktcmVsYXRlZCBtZXRhZGF0YSB1c2VkIGJ5IFBvbHltZXIgZmVhdHVyZXMgKGtleTogcHJvcGVydHkgbmFtZVxuICogICB2YWx1ZTogb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydHkgbWV0YWRhdGEpLiBWYWxpZCBrZXlzIGluIHBlci1wcm9wZXJ0eVxuICogICBtZXRhZGF0YSBpbmNsdWRlOlxuICogICAtIGB0eXBlYCAoU3RyaW5nfE51bWJlcnxPYmplY3R8QXJyYXl8Li4uKTogVXNlZCBieVxuICogICAgIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvIGRldGVybWluZSBob3cgc3RyaW5nLWJhc2VkIGF0dHJpYnV0ZXNcbiAqICAgICBhcmUgZGVzZXJpYWxpemVkIHRvIEphdmFTY3JpcHQgcHJvcGVydHkgdmFsdWVzLlxuICogICAtIGBub3RpZnlgIChib29sZWFuKTogQ2F1c2VzIGEgY2hhbmdlIGluIHRoZSBwcm9wZXJ0eSB0byBmaXJlIGFcbiAqICAgICBub24tYnViYmxpbmcgZXZlbnQgY2FsbGVkIGA8cHJvcGVydHk+LWNoYW5nZWRgLiBFbGVtZW50cyB0aGF0IGhhdmVcbiAqICAgICBlbmFibGVkIHR3by13YXkgYmluZGluZyB0byB0aGUgcHJvcGVydHkgdXNlIHRoaXMgZXZlbnQgdG8gb2JzZXJ2ZSBjaGFuZ2VzLlxuICogICAtIGByZWFkT25seWAgKGJvb2xlYW4pOiBDcmVhdGVzIGEgZ2V0dGVyIGZvciB0aGUgcHJvcGVydHksIGJ1dCBubyBzZXR0ZXIuXG4gKiAgICAgVG8gc2V0IGEgcmVhZC1vbmx5IHByb3BlcnR5LCB1c2UgdGhlIHByaXZhdGUgc2V0dGVyIG1ldGhvZFxuICogICAgIGBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKWAuXG4gKiAgIC0gYG9ic2VydmVyYCAoc3RyaW5nKTogT2JzZXJ2ZXIgbWV0aG9kIG5hbWUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gKiAgICAgdGhlIHByb3BlcnR5IGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmVcbiAqICAgICBgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKWAuXG4gKiAgIC0gYGNvbXB1dGVkYCAoc3RyaW5nKTogU3RyaW5nIGRlc2NyaWJpbmcgbWV0aG9kIGFuZCBkZXBlbmRlbnQgcHJvcGVydGllc1xuICogICAgIGZvciBjb21wdXRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgKGUuZy4gYCdjb21wdXRlRm9vKGJhciwgem90KSdgKS5cbiAqICAgICBDb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSByZWFkLW9ubHkgYnkgZGVmYXVsdCBhbmQgY2FuIG9ubHkgYmUgY2hhbmdlZFxuICogICAgIHZpYSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjb21wdXRpbmcgbWV0aG9kLlxuICpcbiAqIC0gYHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKClgOiBBcnJheSBvZiBzdHJpbmdzIGRlc2NyaWJpbmcgbXVsdGktcHJvcGVydHlcbiAqICAgb2JzZXJ2ZXIgbWV0aG9kcyBhbmQgdGhlaXIgZGVwZW5kZW50IHByb3BlcnRpZXMgKGUuZy5cbiAqICAgYCdvYnNlcnZlQUJDKGEsIGIsIGMpJ2ApLlxuICpcbiAqIFRoZSBiYXNlIGNsYXNzIHByb3ZpZGVzIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgZm9sbG93aW5nIHN0YW5kYXJkXG4gKiBjdXN0b20gZWxlbWVudCBsaWZlY3ljbGUgY2FsbGJhY2tzOyB1c2VycyBtYXkgb3ZlcnJpZGUgdGhlc2UsIGJ1dCBzaG91bGRcbiAqIGNhbGwgdGhlIHN1cGVyIG1ldGhvZCB0byBlbnN1cmVcbiAqIC0gYGNvbnN0cnVjdG9yYDogUnVuIHdoZW4gdGhlIGVsZW1lbnQgaXMgY3JlYXRlZCBvciB1cGdyYWRlZFxuICogLSBgY29ubmVjdGVkQ2FsbGJhY2tgOiBSdW4gZWFjaCB0aW1lIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byB0aGVcbiAqICAgZG9jdW1lbnRcbiAqIC0gYGRpc2Nvbm5lY3RlZENhbGxiYWNrYDogUnVuIGVhY2ggdGltZSB0aGUgZWxlbWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbVxuICogICB0aGUgZG9jdW1lbnRcbiAqIC0gYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2A6IFJ1biBlYWNoIHRpbWUgYW4gYXR0cmlidXRlIGluXG4gKiAgIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGlzIHNldCBvciByZW1vdmVkIChub3RlOiB0aGlzIGVsZW1lbnQncyBkZWZhdWx0XG4gKiAgIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGltcGxlbWVudGF0aW9uIHdpbGwgYXV0b21hdGljYWxseSByZXR1cm4gYW4gYXJyYXlcbiAqICAgb2YgZGFzaC1jYXNlZCBhdHRyaWJ1dGVzIGJhc2VkIG9uIGBwcm9wZXJ0aWVzYClcbiAqXG4gKiBAbWl4aW5GdW5jdGlvblxuICogQHBvbHltZXJcbiAqIEBhcHBsaWVzTWl4aW4gUHJvcGVydHlFZmZlY3RzXG4gKiBAYXBwbGllc01peGluIFByb3BlcnRpZXNNaXhpblxuICogQHByb3BlcnR5IHJvb3RQYXRoIHtzdHJpbmd9IFNldCB0byB0aGUgdmFsdWUgb2YgYHJvb3RQYXRoYCxcbiAqICAgd2hpY2ggZGVmYXVsdHMgdG8gdGhlIG1haW4gZG9jdW1lbnQgcGF0aFxuICogQHByb3BlcnR5IGltcG9ydFBhdGgge3N0cmluZ30gU2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY2xhc3MncyBzdGF0aWNcbiAqICAgYGltcG9ydFBhdGhgIHByb3BlcnR5LCB3aGljaCBkZWZhdWx0cyB0byB0aGUgcGF0aCBvZiB0aGlzIGVsZW1lbnQnc1xuICogICBgZG9tLW1vZHVsZWAgKHdoZW4gYGlzYCBpcyB1c2VkKSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGZvciBvdGhlclxuICogICBpbXBvcnQgc3RyYXRlZ2llcy5cbiAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXInc1xuICogbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcy5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyBDbGFzcyB0byBhcHBseSBtaXhpbiB0by5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyB3aXRoIG1peGluIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBFbGVtZW50TWl4aW4gPSBkZWR1cGluZ01peGluKGJhc2UgPT4ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydGllc01peGlufVxuICAgKiBAZXh0ZW5kcyB7SFRNTEVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdCBwb2x5bWVyRWxlbWVudEJhc2UgPSBQcm9wZXJ0aWVzTWl4aW4oUHJvcGVydHlFZmZlY3RzKGJhc2UpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgcHJvcGVydGllcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBUaGlzIGxpc3QgaXMgY3JlYXRlZCBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgaXQgaXMgYSBzdWJzZXQgb2ZcbiAgICogdGhlIGxpc3QgcmV0dXJuZWQgZnJvbSBgX3Byb3BlcnRpZXNgLlxuICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBpbiBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCB0byBzZXQgcHJvcGVydHkgZGVmYXVsdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3IgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqICAgdGhhdCBoYXZlIGRlZmF1bHQgdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0eURlZmF1bHRzKGNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCFjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fcHJvcGVydHlEZWZhdWx0cycsIGNvbnN0cnVjdG9yKSkpIHtcbiAgICAgIGNvbnN0cnVjdG9yLl9fcHJvcGVydHlEZWZhdWx0cyA9IG51bGw7XG4gICAgICBsZXQgcHJvcHMgPSBjb25zdHJ1Y3Rvci5fcHJvcGVydGllcztcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwcm9wc1twXTtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gaW5mbykge1xuICAgICAgICAgIGNvbnN0cnVjdG9yLl9fcHJvcGVydHlEZWZhdWx0cyA9IGNvbnN0cnVjdG9yLl9fcHJvcGVydHlEZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgICBjb25zdHJ1Y3Rvci5fX3Byb3BlcnR5RGVmYXVsdHNbcF0gPSBpbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5fX3Byb3BlcnR5RGVmYXVsdHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG1lbW9pemVkIHZlcnNpb24gb2YgdGhlIGBvYnNlcnZlcnNgIGFycmF5LlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgb3duIG9ic2VydmVycyBmb3IgdGhlIGdpdmVuIGNsYXNzXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIG93bk9ic2VydmVycyhjb25zdHJ1Y3Rvcikge1xuICAgIGlmICghY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293bk9ic2VydmVycycsIGNvbnN0cnVjdG9yKSkpIHtcbiAgICAgIGNvbnN0cnVjdG9yLl9fb3duT2JzZXJ2ZXJzID1cbiAgICAgICAgICBjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnb2JzZXJ2ZXJzJywgY29uc3RydWN0b3IpKSA/XG4gICAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSAqLyAoY29uc3RydWN0b3IpLm9ic2VydmVycyA6XG4gICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLl9fb3duT2JzZXJ2ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZWZmZWN0cyBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogTm90ZSwgb25jZSBhIHByb3BlcnR5IGhhcyBiZWVuIHNldCB0b1xuICAgKiBgcmVhZE9ubHlgLCBgY29tcHV0ZWRgLCBgcmVmbGVjdFRvQXR0cmlidXRlYCwgb3IgYG5vdGlmeWBcbiAgICogdGhlc2UgdmFsdWVzIG1heSBub3QgYmUgY2hhbmdlZC4gRm9yIGV4YW1wbGUsIGEgc3ViY2xhc3MgY2Fubm90XG4gICAqIGFsdGVyIHRoZXNlIHNldHRpbmdzLiBIb3dldmVyLCBhZGRpdGlvbmFsIGBvYnNlcnZlcnNgIG1heSBiZSBhZGRlZFxuICAgKiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBUaGUgaW5mbyBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gcHJvcGVydHkgbWV0YWRhdGEgYXMgZm9sbG93czpcbiAgICpcbiAgICogKiBgdHlwZWA6IHtmdW5jdGlvbn0gdHlwZSB0byB3aGljaCBhbiBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIHByb3BlcnR5XG4gICAqIGlzIGRlc2VyaWFsaXplZC4gTm90ZSB0aGUgcHJvcGVydHkgaXMgY2FtZWwtY2FzZWQgZnJvbSBhIGRhc2gtY2FzZWRcbiAgICogYXR0cmlidXRlLiBGb3IgZXhhbXBsZSwgJ2Zvby1iYXInIGF0dHJpYnV0ZSBpcyBkZXNlcmlhbGl6ZWQgdG8gYVxuICAgKiBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJy5cbiAgICpcbiAgICogKiBgcmVhZE9ubHlgOiB7Ym9vbGVhbn0gY3JlYXRlcyBhIHJlYWRPbmx5IHByb3BlcnR5IGFuZFxuICAgKiBtYWtlcyBhIHByaXZhdGUgc2V0dGVyIGZvciB0aGUgcHJpdmF0ZSBvZiB0aGUgZm9ybSAnX3NldEZvbycgZm9yIGFcbiAgICogcHJvcGVydHkgJ2ZvbycsXG4gICAqXG4gICAqICogYGNvbXB1dGVkYDoge3N0cmluZ30gY3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBBIGNvbXB1dGVkIHByb3BlcnR5XG4gICAqIGlzIGFsc28gYXV0b21hdGljYWxseSBzZXQgdG8gYHJlYWRPbmx5OiB0cnVlYC4gVGhlIHZhbHVlIGlzIGNhbGN1bGF0ZWRcbiAgICogYnkgcnVubmluZyBhIG1ldGhvZCBhbmQgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuIEZvclxuICAgKiBleGFtcGxlICdjb21wdXRlKGZvbyknIHdpbGwgY29tcHV0ZSBhIGdpdmVuIHByb3BlcnR5IHdoZW4gdGhlXG4gICAqICdmb28nIHByb3BlcnR5IGNoYW5nZXMgYnkgZXhlY3V0aW5nIHRoZSAnY29tcHV0ZScgbWV0aG9kLiBUaGlzIG1ldGhvZFxuICAgKiBtdXN0IHJldHVybiB0aGUgY29tcHV0ZWQgdmFsdWUuXG4gICAqXG4gICAqICogYHJlZmxlY3RUb0F0dHJpYnV0ZWA6IHtib29sZWFufSBJZiB0cnVlLCB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmVmbGVjdGVkXG4gICAqIHRvIGFuIGF0dHJpYnV0ZSBvZiB0aGUgc2FtZSBuYW1lLiBOb3RlLCB0aGUgYXR0cmlidXRlIGlzIGRhc2gtY2FzZWRcbiAgICogc28gYSBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJyBpcyByZWZsZWN0ZWQgYXMgJ2Zvby1iYXInLlxuICAgKlxuICAgKiAqIGBub3RpZnlgOiB7Ym9vbGVhbn0gc2VuZHMgYSBub24tYnViYmxpbmcgbm90aWZpY2F0aW9uIGV2ZW50IHdoZW5cbiAgICogdGhlIHByb3BlcnR5IGNoYW5nZXMuIEZvciBleGFtcGxlLCBhIHByb3BlcnR5IG5hbWVkICdmb28nIHNlbmRzIGFuXG4gICAqIGV2ZW50IG5hbWVkICdmb28tY2hhbmdlZCcgd2l0aCBgZXZlbnQuZGV0YWlsYCBzZXQgdG8gdGhlIHZhbHVlIG9mXG4gICAqIHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogKiBvYnNlcnZlcjoge3N0cmluZ30gbmFtZSBvZiBhIG1ldGhvZCB0aGF0IHJ1bnMgd2hlbiB0aGUgcHJvcGVydHlcbiAgICogY2hhbmdlcy4gVGhlIGFyZ3VtZW50cyBvZiB0aGUgbWV0aG9kIGFyZSAodmFsdWUsIHByZXZpb3VzVmFsdWUpLlxuICAgKlxuICAgKiBOb3RlOiBVc2VycyBtYXkgd2FudCBjb250cm9sIG92ZXIgbW9kaWZ5aW5nIHByb3BlcnR5XG4gICAqIGVmZmVjdHMgdmlhIHN1YmNsYXNzaW5nLiBGb3IgZXhhbXBsZSwgYSB1c2VyIG1pZ2h0IHdhbnQgdG8gbWFrZSBhXG4gICAqIHJlZmxlY3RUb0F0dHJpYnV0ZSBwcm9wZXJ0eSBub3QgZG8gc28gaW4gYSBzdWJjbGFzcy4gV2UndmUgY2hvc2VuIHRvXG4gICAqIGRpc2FibGUgdGhpcyBiZWNhdXNlIGl0IGxlYWRzIHRvIGFkZGl0aW9uYWwgY29tcGxpY2F0aW9uLlxuICAgKiBGb3IgZXhhbXBsZSwgYSByZWFkT25seSBlZmZlY3QgZ2VuZXJhdGVzIGEgc3BlY2lhbCBzZXR0ZXIuIElmIGEgc3ViY2xhc3NcbiAgICogZGlzYWJsZXMgdGhlIGVmZmVjdCwgdGhlIHNldHRlciB3b3VsZCBmYWlsIHVuZXhwZWN0ZWRseS5cbiAgICogQmFzZWQgb24gZmVlZGJhY2ssIHdlIG1heSB3YW50IHRvIHRyeSB0byBtYWtlIGVmZmVjdHMgbW9yZSBtYWxsZWFibGVcbiAgICogYW5kL29yIHByb3ZpZGUgYW4gYWR2YW5jZWQgYXBpIGZvciBtYW5pcHVsYXRpbmcgdGhlbS5cbiAgICpcbiAgICogQHBhcmFtIHshUG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICogICBhbmQgZWZmZWN0cyB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gSW5mbyBvYmplY3QgZnJvbSB3aGljaCB0byBjcmVhdGUgcHJvcGVydHkgZWZmZWN0cy5cbiAgICogU3VwcG9ydGVkIGtleXM6XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhbGxQcm9wcyBGbGF0dGVuZWQgbWFwIG9mIGFsbCBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhpc1xuICAgKiAgIGVsZW1lbnQgKGluY2x1ZGluZyBpbmhlcml0ZWQgcHJvcGVydGllcylcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgbmFtZSwgaW5mbywgYWxsUHJvcHMpIHtcbiAgICAvLyBjb21wdXRlZCBmb3JjZXMgcmVhZE9ubHkuLi5cbiAgICBpZiAoaW5mby5jb21wdXRlZCkge1xuICAgICAgaW5mby5yZWFkT25seSA9IHRydWU7XG4gICAgfVxuICAgIC8vIE5vdGUsIHNpbmNlIGFsbCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSByZWFkT25seSwgdGhpcyBwcmV2ZW50c1xuICAgIC8vIGFkZGluZyBhZGRpdGlvbmFsIGNvbXB1dGVkIHByb3BlcnR5IGVmZmVjdHMgKHdoaWNoIGxlYWRzIHRvIGEgY29uZnVzaW5nXG4gICAgLy8gc2V0dXAgd2hlcmUgbXVsdGlwbGUgdHJpZ2dlcnMgZm9yIHNldHRpbmcgYSBwcm9wZXJ0eSlcbiAgICAvLyBXaGlsZSB3ZSBkbyBoYXZlIGBoYXNDb21wdXRlZEVmZmVjdGAgdGhpcyBpcyBzZXQgb24gdGhlIHByb3BlcnR5J3NcbiAgICAvLyBkZXBlbmRlbmNpZXMgcmF0aGVyIHRoYW4gaXRzZWxmLlxuICAgIGlmIChpbmZvLmNvbXB1dGVkKSB7XG4gICAgICBpZiAocHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IHJlZGVmaW5lIGNvbXB1dGVkIHByb3BlcnR5ICcke25hbWV9Jy5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3RvLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KG5hbWUsIGluZm8uY29tcHV0ZWQsIGFsbFByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZm8ucmVhZE9ubHkgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkobmFtZSwgIWluZm8uY29tcHV0ZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5mby5yZWFkT25seSA9PT0gZmFsc2UgJiYgcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbm5vdCBtYWtlIHJlYWRPbmx5IHByb3BlcnR5ICcke25hbWV9JyBub24tcmVhZE9ubHkuYCk7XG4gICAgfVxuICAgIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSAmJiAhcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGluZm8ucmVmbGVjdFRvQXR0cmlidXRlID09PSBmYWxzZSAmJiBwcm90by5faGFzUmVmbGVjdEVmZmVjdChuYW1lKSkge1xuICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgbWFrZSByZWZsZWN0ZWQgcHJvcGVydHkgJyR7bmFtZX0nIG5vbi1yZWZsZWN0ZWQuYCk7XG4gICAgfVxuICAgIGlmIChpbmZvLm5vdGlmeSAmJiAhcHJvdG8uX2hhc05vdGlmeUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoaW5mby5ub3RpZnkgPT09IGZhbHNlICYmIHByb3RvLl9oYXNOb3RpZnlFZmZlY3QobmFtZSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IG1ha2Ugbm90aWZ5IHByb3BlcnR5ICcke25hbWV9JyBub24tbm90aWZ5LmApO1xuICAgIH1cbiAgICAvLyBhbHdheXMgYWRkIG9ic2VydmVyXG4gICAgaWYgKGluZm8ub2JzZXJ2ZXIpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKG5hbWUsIGluZm8ub2JzZXJ2ZXIsIGFsbFByb3BzW2luZm8ub2JzZXJ2ZXJdKTtcbiAgICB9XG4gICAgLy8gYWx3YXlzIGNyZWF0ZSB0aGUgbWFwcGluZyBmcm9tIGF0dHJpYnV0ZSBiYWNrIHRvIHByb3BlcnR5IGZvciBkZXNlcmlhbGl6YXRpb24uXG4gICAgcHJvdG8uX2FkZFByb3BlcnR5VG9BdHRyaWJ1dGVNYXAobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhbGwgc3R5bGUgZWxlbWVudHMgaW4gdGhlIGVsZW1lbnQgdGVtcGxhdGUuIFN0eWxlcyB3aXRoIHRoZVxuICAgKiBgaW5jbHVkZWAgYXR0cmlidXRlIGFyZSBwcm9jZXNzZWQgc3VjaCB0aGF0IGFueSBzdHlsZXMgaW5cbiAgICogdGhlIGFzc29jaWF0ZWQgXCJzdHlsZSBtb2R1bGVzXCIgYXJlIGluY2x1ZGVkIGluIHRoZSBlbGVtZW50IHRlbXBsYXRlLlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaXMgTmFtZSBvZiBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIGZvciBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzRWxlbWVudFN0eWxlcyhrbGFzcywgdGVtcGxhdGUsIGlzLCBiYXNlVVJJKSB7XG4gICAgaWYgKCFidWlsdENTUykge1xuICAgICAgY29uc3QgdGVtcGxhdGVTdHlsZXMgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gICAgICBjb25zdCBzdHlsZXNXaXRoSW1wb3J0cyA9IHN0eWxlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAvLyBpbnNlcnQgc3R5bGVzIGZyb20gPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPiBhdCB0aGUgdG9wIG9mIHRoZSB0ZW1wbGF0ZVxuICAgICAgY29uc3QgbGlua2VkU3R5bGVzID0gc3R5bGVzRnJvbU1vZHVsZUltcG9ydHMoaXMpO1xuICAgICAgY29uc3QgZmlyc3RUZW1wbGF0ZUNoaWxkID0gdGVtcGxhdGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGxpbmtlZFN0eWxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGxldCBzID0gbGlua2VkU3R5bGVzW2lkeF07XG4gICAgICAgIHMudGV4dENvbnRlbnQgPSBrbGFzcy5fcHJvY2Vzc1N0eWxlVGV4dChzLnRleHRDb250ZW50LCBiYXNlVVJJKTtcbiAgICAgICAgdGVtcGxhdGUuY29udGVudC5pbnNlcnRCZWZvcmUocywgZmlyc3RUZW1wbGF0ZUNoaWxkKTtcbiAgICAgIH1cbiAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgXCJjb25jcmV0ZVwiIHN0eWxlIGluIHRoZSB0ZW1wbGF0ZSB3ZSBoYXZlIGVuY291bnRlcmVkXG4gICAgICBsZXQgdGVtcGxhdGVTdHlsZUluZGV4ID0gMDtcbiAgICAgIC8vIGVuc3VyZSBhbGwgZ2F0aGVyZWQgc3R5bGVzIGFyZSBhY3R1YWxseSBpbiB0aGlzIHRlbXBsYXRlLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXNXaXRoSW1wb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcyA9IHN0eWxlc1dpdGhJbXBvcnRzW2ldO1xuICAgICAgICBsZXQgdGVtcGxhdGVTdHlsZSA9IHRlbXBsYXRlU3R5bGVzW3RlbXBsYXRlU3R5bGVJbmRleF07XG4gICAgICAgIC8vIGlmIHRoZSBzdHlsZSBpcyBub3QgaW4gdGhpcyB0ZW1wbGF0ZSwgaXQncyBiZWVuIFwiaW5jbHVkZWRcIiBhbmRcbiAgICAgICAgLy8gd2UgcHV0IGEgY2xvbmUgb2YgaXQgaW4gdGhlIHRlbXBsYXRlIGJlZm9yZSB0aGUgc3R5bGUgdGhhdCBpbmNsdWRlZCBpdFxuICAgICAgICBpZiAodGVtcGxhdGVTdHlsZSAhPT0gcykge1xuICAgICAgICAgIHMgPSBzLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICB0ZW1wbGF0ZVN0eWxlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHMsIHRlbXBsYXRlU3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBsYXRlU3R5bGVJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHMudGV4dENvbnRlbnQgPSBrbGFzcy5fcHJvY2Vzc1N0eWxlVGV4dChzLnRleHRDb250ZW50LCBiYXNlVVJJKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMpO1xuICAgIH1cbiAgICAvLyBTdXBwb3J0IGZvciBgYWRvcHRlZFN0eWxlc2hlZXRzYCByZWxpZXMgb24gdXNpbmcgbmF0aXZlIFNoYWRvdyBET01cbiAgICAvLyBhbmQgYnVpbHQgQ1NTLiBCdWlsdCBDU1MgaXMgcmVxdWlyZWQgYmVjYXVzZSBydW50aW1lIHRyYW5zZm9ybWF0aW9uIG9mXG4gICAgLy8gYEBhcHBseWAgaXMgbm90IHN1cHBvcnRlZC4gVGhpcyBpcyBiZWNhdXNlIFNoYWR5Q1NTIHJlbGllcyBvbiBiZWluZyBhYmxlXG4gICAgLy8gdG8gdXBkYXRlIGEgYHN0eWxlYCBlbGVtZW50IGluIHRoZSBlbGVtZW50IHRlbXBsYXRlIGFuZCB0aGlzIGlzXG4gICAgLy8gcmVtb3ZlZCB3aGVuIHVzaW5nIGBhZG9wdGVkU3R5bGVTaGVldHNgLlxuICAgIC8vIE5vdGUsIGl0IHdvdWxkIGJlIG1vcmUgZWZmaWNpZW50IHRvIGFsbG93IHN0eWxlIGluY2x1ZGVzIHRvIGJlY29tZVxuICAgIC8vIHNlcGFyYXRlIHN0eWxlc2hlZXRzOyBob3dldmVyLCBiZWNhdXNlIG9mIGBAYXBwbHlgIHRoZXNlIGFyZVxuICAgIC8vIHBvdGVudGlhbGx5IG5vdCBzaGFyZWFibGUgYW5kIHNoYXJpbmcgdGhlIG9uZXMgdGhhdCBjb3VsZCBiZSBzaGFyZWRcbiAgICAvLyB3b3VsZCByZXF1aXJlIHNvbWUgY29vcmRpbmF0aW9uLiBUbyBrZWVwIGl0IHNpbXBsZSwgYWxsIHRoZSBpbmNsdWRlc1xuICAgIC8vIGFuZCBzdHlsZXMgYXJlIGNvbGxhcHNlZCBpbnRvIGEgc2luZ2xlIHNoYXJlYWJsZSBzdHlsZXNoZWV0LlxuICAgIGlmICh1c2VBZG9wdGVkU3R5bGVTaGVldHNXaXRoQnVpbHRDU1MgJiYgYnVpbHRDU1MgJiZcbiAgICAgICAgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzKSB7XG4gICAgICAvLyBSZW1vdmUgc3R5bGVzIGluIHRlbXBsYXRlIGFuZCBtYWtlIGEgc2hhcmVhYmxlIHN0eWxlc2hlZXRcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKTtcbiAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgbGV0IGNzcyA9ICcnO1xuICAgICAgICBBcnJheS5mcm9tKHN0eWxlcykuZm9yRWFjaChzID0+IHtcbiAgICAgICAgICBjc3MgKz0gcy50ZXh0Q29udGVudDtcbiAgICAgICAgICBzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocyk7XG4gICAgICAgIH0pO1xuICAgICAgICBrbGFzcy5fc3R5bGVTaGVldCA9IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG4gICAgICAgIGtsYXNzLl9zdHlsZVNoZWV0LnJlcGxhY2VTeW5jKGNzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgdGVtcGxhdGUgZnJvbSBkb20tbW9kdWxlIGZvciBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpcyBFbGVtZW50IG5hbWUgdG8gbG9vayB1cFxuICAgKiBAcmV0dXJuIHs/SFRNTFRlbXBsYXRlRWxlbWVudHx1bmRlZmluZWR9IFRlbXBsYXRlIGZvdW5kIGluIGRvbSBtb2R1bGUsIG9yXG4gICAqICAgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUZW1wbGF0ZUZyb21Eb21Nb2R1bGUoaXMpIHtcbiAgICBsZXQgdGVtcGxhdGUgPSBudWxsO1xuICAgIC8vIFVuZGVyIHN0cmljdFRlbXBsYXRlUG9saWN5IGluIDMueCssIGRvbS1tb2R1bGUgbG9va3VwIGlzIG9ubHkgYWxsb3dlZFxuICAgIC8vIHdoZW4gb3B0ZWQtaW4gdmlhIGFsbG93VGVtcGxhdGVGcm9tRG9tTW9kdWxlXG4gICAgaWYgKGlzICYmICghc3RyaWN0VGVtcGxhdGVQb2xpY3kgfHwgYWxsb3dUZW1wbGF0ZUZyb21Eb21Nb2R1bGUpKSB7XG4gICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7P0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovIChcbiAgICAgICAgICBEb21Nb2R1bGUuaW1wb3J0KGlzLCAndGVtcGxhdGUnKSk7XG4gICAgICAvLyBVbmRlciBzdHJpY3RUZW1wbGF0ZVBvbGljeSwgcmVxdWlyZSBhbnkgZWxlbWVudCB3aXRoIGFuIGBpc2BcbiAgICAgIC8vIHNwZWNpZmllZCB0byBoYXZlIGEgZG9tLW1vZHVsZVxuICAgICAgaWYgKHN0cmljdFRlbXBsYXRlUG9saWN5ICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmljdFRlbXBsYXRlUG9saWN5OiBleHBlY3RpbmcgZG9tLW1vZHVsZSBvciBudWxsIHRlbXBsYXRlIGZvciAke2lzfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQHVucmVzdHJpY3RlZFxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqIEBleHRlbmRzIHtwb2x5bWVyRWxlbWVudEJhc2V9XG4gICAqL1xuICBjbGFzcyBQb2x5bWVyRWxlbWVudCBleHRlbmRzIHBvbHltZXJFbGVtZW50QmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IFBvbHltZXIgdmVyc2lvbiBpbiBTZW12ZXIgbm90YXRpb24uXG4gICAgICogQHR5cGUge3N0cmluZ30gU2VtdmVyIG5vdGF0aW9uIG9mIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUG9seW1lci5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcG9seW1lckVsZW1lbnRWZXJzaW9uKCkge1xuICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgb2YgUHJvcGVydGllc01peGluIF9maW5hbGl6ZUNsYXNzIHRvIGNyZWF0ZSBvYnNlcnZlcnMgYW5kXG4gICAgICogZmluZCB0aGUgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX2ZpbmFsaXplQ2xhc3MoKSB7XG4gICAgICAvLyBUT0RPKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMzI0MCk6XG4gICAgICAvLyAgICAgQ2hhbmdlIGJhY2sgdG8ganVzdCBzdXBlci5tZXRob2RDYWxsKClcbiAgICAgIHBvbHltZXJFbGVtZW50QmFzZS5fZmluYWxpemVDbGFzcy5jYWxsKHRoaXMpO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXJzID0gb3duT2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgaWYgKG9ic2VydmVycykge1xuICAgICAgICB0aGlzLmNyZWF0ZU9ic2VydmVycyhvYnNlcnZlcnMsIHRoaXMuX3Byb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHJlcGFyZVRlbXBsYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgc3RhdGljIF9wcmVwYXJlVGVtcGxhdGUoKSB7XG4gICAgICAvLyBub3RlOiBjcmVhdGUgXCJ3b3JraW5nXCIgdGVtcGxhdGUgdGhhdCBpcyBmaW5hbGl6ZWQgYXQgaW5zdGFuY2UgdGltZVxuICAgICAgbGV0IHRlbXBsYXRlID0gLyoqIEB0eXBlIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSAqLyAodGhpcykudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCd0ZW1wbGF0ZSBnZXR0ZXIgbXVzdCByZXR1cm4gSFRNTFRlbXBsYXRlRWxlbWVudCcpO1xuICAgICAgICAgIHRlbXBsYXRlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICghbGVnYWN5T3B0aW1pemF0aW9ucykge1xuICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICAgIHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIG9mIFByb3BlcnRpZXNDaGFuZ2VkIGNyZWF0ZVByb3BlcnRpZXMgdG8gY3JlYXRlIGFjY2Vzc29yc1xuICAgICAqIGFuZCBwcm9wZXJ0eSBlZmZlY3RzIGZvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBwcm9wcyAuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcoXG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovICh0aGlzLnByb3RvdHlwZSksIHAsIHByb3BzW3BdLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvYnNlcnZlcnMgZm9yIHRoZSBnaXZlbiBgb2JzZXJ2ZXJzYCBhcnJheS5cbiAgICAgKiBMZXZlcmFnZXMgYFByb3BlcnR5RWZmZWN0c2AgdG8gY3JlYXRlIG9ic2VydmVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXJzIEFycmF5IG9mIG9ic2VydmVyIGRlc2NyaXB0b3JzIGZvclxuICAgICAqICAgdGhpcyBjbGFzc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkeW5hbWljRm5zIE9iamVjdCBjb250YWluaW5nIGtleXMgZm9yIGFueSBwcm9wZXJ0aWVzXG4gICAgICogICB0aGF0IGFyZSBmdW5jdGlvbnMgYW5kIHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3Qgd2hlbiB0aGUgZnVuY3Rpb25cbiAgICAgKiAgIHJlZmVyZW5jZSBpcyBjaGFuZ2VkXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlT2JzZXJ2ZXJzKG9ic2VydmVycywgZHluYW1pY0Zucykge1xuICAgICAgY29uc3QgcHJvdG8gPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm90by5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIob2JzZXJ2ZXJzW2ldLCBkeW5hbWljRm5zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoaXMgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqXG4gICAgICogSWYgYSBgc3RhdGljIGdldCBpcygpYCBnZXR0ZXIgaXMgZGVmaW5lZCwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbFxuICAgICAqIHJldHVybiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gIGluIGEgYGRvbS1tb2R1bGVgIHdob3NlIGBpZGAgbWF0Y2hlcyB0aGlzXG4gICAgICogZWxlbWVudCdzIGBpc2AgKG5vdGUgdGhhdCBhIGBfdGVtcGxhdGVgIHByb3BlcnR5IG9uIHRoZSBjbGFzcyBwcm90b3R5cGVcbiAgICAgKiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGBkb20tbW9kdWxlYCB0ZW1wbGF0ZSwgdG8gbWFpbnRhaW4gbGVnYWN5XG4gICAgICogZWxlbWVudCBzZW1hbnRpY3M7IGEgc3ViY2xhc3Mgd2lsbCBzdWJzZXF1ZW50bHkgZmFsbCBiYWNrIHRvIGl0cyBzdXBlclxuICAgICAqIGNsYXNzIHRlbXBsYXRlIGlmIG5laXRoZXIgYSBgcHJvdG90eXBlLl90ZW1wbGF0ZWAgb3IgYSBgZG9tLW1vZHVsZWAgZm9yXG4gICAgICogdGhlIGNsYXNzJ3MgYGlzYCB3YXMgZm91bmQpLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZ2V0dGVyIHRvIHJldHVybiBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB0aGUgYGlzYCBnZXR0ZXIgaXMgdW5uZWNlc3NhcnkpLiBUaGUgdGVtcGxhdGUgcmV0dXJuZWRcbiAgICAgKiBtdXN0IGJlIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHN1YmNsYXNzaW5nLCBpZiB0aGUgc3VwZXIgY2xhc3Mgb3ZlcnJvZGUgdGhlIGRlZmF1bHRcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICAgKiB0ZW1wbGF0ZSB2aWEgYSBgZG9tLW1vZHVsZWAsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIGdldHRlciBhbmRcbiAgICAgKiByZXR1cm4gYERvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJylgLlxuICAgICAqXG4gICAgICogSWYgYSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIG1vZGlmeSB0aGUgc3VwZXIgY2xhc3MgdGVtcGxhdGUsIGl0IHNob3VsZFxuICAgICAqIGNsb25lIGl0IHJhdGhlciB0aGFuIG1vZGlmeSBpdCBpbiBwbGFjZS4gIElmIHRoZSBnZXR0ZXIgZG9lcyBleHBlbnNpdmVcbiAgICAgKiB3b3JrIHN1Y2ggYXMgY2xvbmluZy9tb2RpZnlpbmcgYSB0ZW1wbGF0ZSwgaXQgc2hvdWxkIG1lbW9pemUgdGhlXG4gICAgICogdGVtcGxhdGUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2U6XG4gICAgICpcbiAgICAgKiAgIGxldCBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgY2xhc3MgTXlTdWJDbGFzcyBleHRlbmRzIE15U3VwZXJDbGFzcyB7XG4gICAgICogICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICogICAgICAgaWYgKCFtZW1vaXplZFRlbXBsYXRlKSB7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlID0gc3VwZXIudGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgICAgICAgbGV0IHN1YkNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgKiAgICAgICAgIHN1YkNvbnRlbnQudGV4dENvbnRlbnQgPSAnVGhpcyBjYW1lIGZyb20gTXlTdWJDbGFzcyc7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3ViQ29udGVudCk7XG4gICAgICogICAgICAgfVxuICAgICAqICAgICAgIHJldHVybiBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHshSFRNTFRlbXBsYXRlRWxlbWVudHxzdHJpbmd9IFRlbXBsYXRlIHRvIGJlIHN0YW1wZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAvLyBFeHBsYW5hdGlvbiBvZiB0ZW1wbGF0ZS1yZWxhdGVkIHByb3BlcnRpZXM6XG4gICAgICAvLyAtIGNvbnN0cnVjdG9yLnRlbXBsYXRlICh0aGlzIGdldHRlcik6IHRoZSB0ZW1wbGF0ZSBmb3IgdGhlIGNsYXNzLlxuICAgICAgLy8gICAgIFRoaXMgY2FuIGNvbWUgZnJvbSB0aGUgcHJvdG90eXBlIChmb3IgbGVnYWN5IGVsZW1lbnRzKSwgZnJvbSBhXG4gICAgICAvLyAgICAgZG9tLW1vZHVsZSwgb3IgZnJvbSB0aGUgc3VwZXIgY2xhc3MncyB0ZW1wbGF0ZSAob3IgY2FuIGJlIG92ZXJyaWRkZW5cbiAgICAgIC8vICAgICBhbHRvZ2V0aGVyIGJ5IHRoZSB1c2VyKVxuICAgICAgLy8gLSBjb25zdHJ1Y3Rvci5fdGVtcGxhdGU6IG1lbW9pemVkIHZlcnNpb24gb2YgY29uc3RydWN0b3IudGVtcGxhdGVcbiAgICAgIC8vIC0gcHJvdG90eXBlLl90ZW1wbGF0ZTogd29ya2luZyB0ZW1wbGF0ZSBmb3IgdGhlIGVsZW1lbnQsIHdoaWNoIHdpbGwgYmVcbiAgICAgIC8vICAgICBwYXJzZWQgYW5kIG1vZGlmaWVkIGluIHBsYWNlLiBJdCBpcyBhIGNsb25lZCB2ZXJzaW9uIG9mXG4gICAgICAvLyAgICAgY29uc3RydWN0b3IudGVtcGxhdGUsIHNhdmVkIGluIF9maW5hbGl6ZUNsYXNzKCkuIE5vdGUgdGhhdCBiZWZvcmVcbiAgICAgIC8vICAgICB0aGlzIGdldHRlciBpcyBjYWxsZWQsIGZvciBsZWdhY3kgZWxlbWVudHMgdGhpcyBjb3VsZCBiZSBmcm9tIGFcbiAgICAgIC8vICAgICBfdGVtcGxhdGUgZmllbGQgb24gdGhlIGluZm8gb2JqZWN0IHBhc3NlZCB0byBQb2x5bWVyKCksIGEgYmVoYXZpb3IsXG4gICAgICAvLyAgICAgb3Igc2V0IGluIHJlZ2lzdGVyZWQoKTsgb25jZSB0aGUgc3RhdGljIGdldHRlciBydW5zLCBhIGNsb25lIG9mIGl0XG4gICAgICAvLyAgICAgd2lsbCBvdmVyd3JpdGUgaXQgb24gdGhlIHByb3RvdHlwZSBhcyB0aGUgd29ya2luZyB0ZW1wbGF0ZS5cbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfdGVtcGxhdGUnLCB0aGlzKSkpIHtcbiAgICAgICAgbGV0IHByb3RvVGVtcGxhdGUgPSB0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfdGVtcGxhdGUnLCB0aGlzLnByb3RvdHlwZSkpID9cbiAgICAgICAgICB0aGlzLnByb3RvdHlwZS5fdGVtcGxhdGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEFjY2VwdCBhIGZ1bmN0aW9uIGZvciB0aGUgbGVnYWN5IFBvbHltZXIoe190ZW1wbGF0ZTouLi59KSBmaWVsZCBmb3JcbiAgICAgICAgLy8gbGF6eSBwYXJzaW5nXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9UZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHByb3RvVGVtcGxhdGUgPSBwcm90b1RlbXBsYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPVxuICAgICAgICAgIC8vIElmIHVzZXIgaGFzIHB1dCB0ZW1wbGF0ZSBvbiBwcm90b3R5cGUgKGUuZy4gaW4gbGVnYWN5IHZpYSByZWdpc3RlcmVkXG4gICAgICAgICAgLy8gY2FsbGJhY2sgb3IgaW5mbyBvYmplY3QpLCBwcmVmZXIgdGhhdCBmaXJzdC4gTm90ZSB0aGF0IGBudWxsYCBpc1xuICAgICAgICAgIC8vIHVzZWQgYXMgYSBzZW50aW5lbCB0byBpbmRpY2F0ZSBcIm5vIHRlbXBsYXRlXCIgYW5kIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgICAgLy8gb3ZlcnJpZGUgYSBzdXBlciB0ZW1wbGF0ZSwgd2hlcmVhcyBgdW5kZWZpbmVkYCBpcyB1c2VkIGFzIGFcbiAgICAgICAgICAvLyBzZW50aW5lbCB0byBtZWFuIFwiZmFsbC1iYWNrIHRvIGRlZmF1bHQgdGVtcGxhdGUgbG9va3VwXCIgdmlhXG4gICAgICAgICAgLy8gZG9tLW1vZHVsZSBhbmQvb3Igc3VwZXIudGVtcGxhdGUuXG4gICAgICAgICAgcHJvdG9UZW1wbGF0ZSAhPT0gdW5kZWZpbmVkID8gcHJvdG9UZW1wbGF0ZSA6XG4gICAgICAgICAgLy8gTG9vayBpbiBkb20tbW9kdWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVsZW1lbnQncyBpc1xuICAgICAgICAgICgodGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdpcycsIHRoaXMpKSAmJlxuICAgICAgICAgIChnZXRUZW1wbGF0ZUZyb21Eb21Nb2R1bGUoLyoqIEB0eXBlIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSovICh0aGlzKS5pcykpKSB8fFxuICAgICAgICAgIC8vIE5leHQgbG9vayBmb3Igc3VwZXJjbGFzcyB0ZW1wbGF0ZSAoY2FsbCB0aGUgc3VwZXIgaW1wbCB0aGlzXG4gICAgICAgICAgLy8gd2F5IHNvIHRoYXQgYHRoaXNgIHBvaW50cyB0byB0aGUgc3VwZXJjbGFzcylcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSovICh0aGlzKS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yLnRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudHxzdHJpbmd9IHZhbHVlIFRlbXBsYXRlIHRvIHNldC5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXQgdGVtcGxhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0aCBtYXRjaGluZyB0aGUgdXJsIGZyb20gd2hpY2ggdGhlIGVsZW1lbnQgd2FzIGltcG9ydGVkLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIGlzIHVzZWQgdG8gcmVzb2x2ZSB1cmwncyBpbiB0ZW1wbGF0ZSBzdHlsZSBjc3NUZXh0LlxuICAgICAqIFRoZSBgaW1wb3J0UGF0aGAgcHJvcGVydHkgaXMgYWxzbyBzZXQgb24gZWxlbWVudCBpbnN0YW5jZXMgYW5kIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGJpbmRpbmdzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgcGF0aC5cbiAgICAgKlxuICAgICAqIEZvciBlbGVtZW50cyBkZWZpbmVkIGluIEVTIG1vZHVsZXMsIHVzZXJzIHNob3VsZCBpbXBsZW1lbnRcbiAgICAgKiBgc3RhdGljIGdldCBpbXBvcnRNZXRhKCkgeyByZXR1cm4gaW1wb3J0Lm1ldGE7IH1gLCBhbmQgdGhlIGRlZmF1bHRcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBvZiBgaW1wb3J0UGF0aGAgd2lsbCAgcmV0dXJuIGBpbXBvcnQubWV0YS51cmxgJ3MgcGF0aC5cbiAgICAgKiBGb3IgZWxlbWVudHMgZGVmaW5lZCBpbiBIVE1MIGltcG9ydHMsIHRoaXMgZ2V0dGVyIHdpbGwgcmV0dXJuIHRoZSBwYXRoXG4gICAgICogdG8gdGhlIGRvY3VtZW50IGNvbnRhaW5pbmcgYSBgZG9tLW1vZHVsZWAgZWxlbWVudCBtYXRjaGluZyB0aGlzXG4gICAgICogZWxlbWVudCdzIHN0YXRpYyBgaXNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogTm90ZSwgdGhpcyBwYXRoIHNob3VsZCBjb250YWluIGEgdHJhaWxpbmcgYC9gLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaW1wb3J0IHBhdGggZm9yIHRoaXMgZWxlbWVudCBjbGFzc1xuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9XG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGltcG9ydFBhdGgoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX2ltcG9ydFBhdGgnLCB0aGlzKSkpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuaW1wb3J0TWV0YTtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICB0aGlzLl9pbXBvcnRQYXRoID0gcGF0aEZyb21VcmwobWV0YS51cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IERvbU1vZHVsZS5pbXBvcnQoLyoqIEB0eXBlIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSAqLyAodGhpcykuaXMpO1xuICAgICAgICAgIHRoaXMuX2ltcG9ydFBhdGggPSAobW9kdWxlICYmIG1vZHVsZS5hc3NldHBhdGgpIHx8XG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSovICh0aGlzKS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9pbXBvcnRQYXRoO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9cbiAgICAgIHRoaXMuX3RlbXBsYXRlO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLl9pbXBvcnRQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLnJvb3RQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLmltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge1N0YW1wZWRUZW1wbGF0ZSB8IEhUTUxFbGVtZW50IHwgU2hhZG93Um9vdH0gKi9cbiAgICAgIHRoaXMucm9vdDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFFbGVtZW50Pn0gKi9cbiAgICAgIHRoaXMuJDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFByb3BlcnR5QWNjZXNzb3JzYCB0byBlbnN1cmUgY2xhc3NcbiAgICAgKiBtZXRhcHJvZ3JhbW1pbmcgcmVsYXRlZCB0byBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHMgaGFzXG4gICAgICogY29tcGxldGVkIChjYWxscyBgZmluYWxpemVgKS5cbiAgICAgKlxuICAgICAqIEl0IGFsc28gaW5pdGlhbGl6ZXMgYW55IHByb3BlcnR5IGRlZmF1bHRzIHByb3ZpZGVkIHZpYSBgdmFsdWVgIGluXG4gICAgICogYHByb3BlcnRpZXNgIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0cyxtaXNzaW5nUHJvcGVydGllc30gZ28vbWlzc2luZ2ZucHJvcHNcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmZpbmFsaXplKCk7XG4gICAgICAvLyBub3RlOiBmaW5hbGl6ZSB0ZW1wbGF0ZSB3aGVuIHdlIGhhdmUgYWNjZXNzIHRvIGBsb2NhbE5hbWVgIHRvXG4gICAgICAvLyBhdm9pZCBkZXBlbmRlbmNlIG9uIGBpc2AgZm9yIHBvbHlmaWxsaW5nIHN0eWxpbmcuXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLl9maW5hbGl6ZVRlbXBsYXRlKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKS5sb2NhbE5hbWUpO1xuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAvLyBzZXQgcGF0aCBkZWZhdWx0c1xuICAgICAgdGhpcy5yb290UGF0aCA9IHJvb3RQYXRoO1xuICAgICAgdGhpcy5pbXBvcnRQYXRoID0gdGhpcy5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgLy8gYXBwbHkgcHJvcGVydHkgZGVmYXVsdHMuLi5cbiAgICAgIGxldCBwJCA9IHByb3BlcnR5RGVmYXVsdHModGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAoIXAkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHAgaW4gcCQpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwJFtwXTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbkFwcGx5UHJvcGVydHlEZWZhdWx0KHApKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdHlwZW9mIGluZm8udmFsdWUgPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBpbmZvLnZhbHVlLmNhbGwodGhpcykgOlxuICAgICAgICAgICAgaW5mby52YWx1ZTtcbiAgICAgICAgICAvLyBTZXQgdmlhIGBfc2V0UHJvcGVydHlgIGlmIHRoZXJlIGlzIGFuIGFjY2Vzc29yLCB0byBlbmFibGVcbiAgICAgICAgICAvLyBpbml0aWFsaXppbmcgcmVhZE9ubHkgcHJvcGVydHkgZGVmYXVsdHNcbiAgICAgICAgICBpZiAodGhpcy5faGFzQWNjZXNzb3IocCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbcF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgZGZlYXVsdCBjYW4gYmUgYXBwbGllZC4gRm9yIGV4YW1wbGUsIHRoaXNcbiAgICAgKiBwcmV2ZW50cyBhIGRlZmF1bHQgZnJvbSBiZWluZyBhcHBsaWVkIHdoZW4gYSBwcm9wZXJ0eSB0aGF0IGhhcyBub1xuICAgICAqIGFjY2Vzc29yIGlzIG92ZXJyaWRkZW4gYnkgaXRzIGhvc3QgYmVmb3JlIHVwZ3JhZGUgKGUuZy4gdmlhIGEgYmluZGluZykuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBkZWZhdWx0IGNhbiBiZSBhcHBsaWVkLlxuICAgICAqL1xuICAgIF9jYW5BcHBseVByb3BlcnR5RGVmYXVsdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhc093blByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHYXRoZXIgc3R5bGUgdGV4dCBmb3IgYSBzdHlsZSBlbGVtZW50IGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0IFRleHQgY29udGFpbmluZyBzdHlsaW5nIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSB0byByZWJhc2UgQ1NTIHBhdGhzIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcm9jZXNzZWQgQ1NTIHRleHRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3Byb2Nlc3NTdHlsZVRleHQoY3NzVGV4dCwgYmFzZVVSSSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBDb25maWd1cmVzIGFuIGVsZW1lbnQgYHByb3RvYCB0byBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gYHRlbXBsYXRlYC5cbiAgICAqIFRoZSBlbGVtZW50IG5hbWUgYGlzYCBhbmQgZXh0ZW5kcyBgZXh0YCBtdXN0IGJlIHNwZWNpZmllZCBmb3IgU2hhZHlDU1NcbiAgICAqIHN0eWxlIHNjb3BpbmcuXG4gICAgKlxuICAgICogQHBhcmFtIHtzdHJpbmd9IGlzIFRhZyBuYW1lIChvciB0eXBlIGV4dGVuc2lvbiBuYW1lKSBmb3IgdGhpcyBlbGVtZW50XG4gICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICogQHByb3RlY3RlZFxuICAgICogQG5vY29sbGFwc2VcbiAgICAqL1xuICAgIHN0YXRpYyBfZmluYWxpemVUZW1wbGF0ZShpcykge1xuICAgICAgLyoqIEBjb25zdCB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5wcm90b3R5cGUuX3RlbXBsYXRlO1xuICAgICAgaWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQpIHtcbiAgICAgICAgdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaW1wb3J0UGF0aCA9IHRoaXMuaW1wb3J0UGF0aDtcbiAgICAgICAgY29uc3QgYmFzZVVSSSA9IGltcG9ydFBhdGggPyByZXNvbHZlVXJsKGltcG9ydFBhdGgpIDogJyc7XG4gICAgICAgIC8vIGUuZy4gc3VwcG9ydCBgaW5jbHVkZT1cIm1vZHVsZS1uYW1lXCJgLCBhbmQgU2hhZHlDU1NcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnRTdHlsZXModGhpcywgdGVtcGxhdGUsIGlzLCBiYXNlVVJJKTtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZW5hYmxlcyB0aGUgcHJvcGVydHkgZWZmZWN0cyBzeXN0ZW0gYW5kXG4gICAgICogZmx1c2hlcyBhbnkgcGVuZGluZyBwcm9wZXJ0aWVzLCBhbmQgdXBkYXRlcyBzaGltbWVkIENTUyBwcm9wZXJ0aWVzXG4gICAgICogd2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZy9jdXN0b20gcHJvcGVydGllcyBwb2x5ZmlsbC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXMsIGludmFsaWRDYXN0c30gU3VwZXIgbWF5IG9yIG1heSBub3RcbiAgICAgKiAgICAgaW1wbGVtZW50IHRoZSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAod2luZG93LlNoYWR5Q1NTICYmIHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZUVsZW1lbnQoLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhbXBzIHRoZSBlbGVtZW50IHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICB9XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5RWZmZWN0c2AncyBgX3JlYWR5Q2xpZW50c2AgY2FsbC4gQXR0YWNoZXNcbiAgICAgKiBlbGVtZW50IGRvbSBieSBjYWxsaW5nIGBfYXR0YWNoRG9tYCB3aXRoIHRoZSBkb20gc3RhbXBlZCBmcm9tIHRoZVxuICAgICAqIGVsZW1lbnQncyB0ZW1wbGF0ZSB2aWEgYF9zdGFtcFRlbXBsYXRlYC4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzXG4gICAgICogY2xpZW50IGRvbSB0byBiZSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCBwcmlvciB0byBhbnkgb2JzZXJ2ZXJzXG4gICAgICogcnVubmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9hdHRhY2hEb20oLyoqIEB0eXBlIHtTdGFtcGVkVGVtcGxhdGV9ICovKHRoaXMucm9vdCkpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHN1cGVyLl9yZWFkeUNsaWVudHMgaGVyZSBzZXRzIHRoZSBjbGllbnRzIGluaXRpYWxpemVkIGZsYWcuXG4gICAgICAvLyBXZSBtdXN0IHdhaXQgdG8gZG8gdGhpcyB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGNyZWF0ZWQvYXR0YWNoZWRcbiAgICAgIC8vIHNvIHRoYXQgdGhpcyBmbGFnIGNhbiBiZSBjaGVja2VkIHRvIHByZXZlbnQgbm90aWZpY2F0aW9ucyBmaXJlZFxuICAgICAgLy8gZHVyaW5nIHRoaXMgcHJvY2VzcyBmcm9tIGJlaW5nIGhhbmRsZWQgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgc3VwZXIuX3JlYWR5Q2xpZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gZWxlbWVudCdzIHN0YW1wZWQgZG9tIHRvIGl0c2VsZi4gQnkgZGVmYXVsdCxcbiAgICAgKiB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgYHNoYWRvd1Jvb3RgIGFuZCBhZGRzIHRoZSBkb20gdG8gaXQuXG4gICAgICogSG93ZXZlciwgdGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWxsb3cgYW4gZWxlbWVudFxuICAgICAqIHRvIHB1dCBpdHMgZG9tIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdSZXR1cm59XG4gICAgICogQHBhcmFtIHtTdGFtcGVkVGVtcGxhdGV9IGRvbSB0byBhdHRhY2ggdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7U2hhZG93Um9vdH0gbm9kZSB0byB3aGljaCB0aGUgZG9tIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIF9hdHRhY2hEb20oZG9tKSB7XG4gICAgICBjb25zdCBuID0gd3JhcCh0aGlzKTtcbiAgICAgIGlmIChuLmF0dGFjaFNoYWRvdykge1xuICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgaWYgKCFuLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIG4uYXR0YWNoU2hhZG93KHttb2RlOiAnb3BlbicsIHNoYWR5VXBncmFkZUZyYWdtZW50OiBkb219KTtcbiAgICAgICAgICAgIG4uc2hhZG93Um9vdC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgLy8gV2hlbiBgYWRvcHRlZFN0eWxlU2hlZXRzYCBpcyBzdXBwb3J0ZWQgYSBzdHlsZXNoZWV0IGlzIG1hZGVcbiAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBvbiB0aGUgZWxlbWVudCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgIG4uc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbdGhpcy5jb25zdHJ1Y3Rvci5fc3R5bGVTaGVldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzeW5jSW5pdGlhbFJlbmRlciAmJiB3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgICAgIHdpbmRvdy5TaGFkeURPTS5mbHVzaEluaXRpYWwobi5zaGFkb3dSb290KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG4uc2hhZG93Um9vdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZG93RE9NIG5vdCBhdmFpbGFibGUuICcgK1xuICAgICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IG1vdmUgdG8gY29tcGlsZS10aW1lIGNvbmRpdGlvbmFsIHdoZW4gc3VwcG9ydGVkXG4gICAgICAgICdQb2x5bWVyRWxlbWVudCBjYW4gY3JlYXRlIGRvbSBhcyBjaGlsZHJlbiBpbnN0ZWFkIG9mIGluICcgK1xuICAgICAgICAnU2hhZG93RE9NIGJ5IHNldHRpbmcgYHRoaXMucm9vdCA9IHRoaXM7XFxgIGJlZm9yZSBcXGByZWFkeVxcYC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICAgICAqIHNoaW1tZWQgc3R5bGVzIGluIHRoaXMgZWxlbWVudCAoYW5kIGl0cyBzdWJ0cmVlKSB0byBiZSB1cGRhdGVkXG4gICAgICogYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgICAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiBhcmUgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6IGB0aGlzLnVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAgICAgKlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgdXBkYXRpbmcgQ1NTIG1peGlucy5cbiAgICAgKiBZb3UgY2FuIG5vdCBkeW5hbWljYWxseSBjaGFuZ2UgdGhlIHZhbHVlIG9mIGFuIGBAYXBwbHlgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIEJhZyBvZiBjdXN0b20gcHJvcGVydHkga2V5L3ZhbHVlcyB0b1xuICAgICAqICAgYXBwbHkgdG8gdGhpcyBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICovXG4gICAgdXBkYXRlU3R5bGVzKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlU3VidHJlZSgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcyksIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJld3JpdGVzIGEgZ2l2ZW4gVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwuIFRoZSBiYXNlIFVSTCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgZG9jdW1lbnQgY29udGFpbmluZyB0aGUgYGRvbS1tb2R1bGVgIGZvclxuICAgICAqIHRoaXMgZWxlbWVudC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWUgVVJMIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAgKiBidW5kbGluZy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHBlcmZvcm1zIG5vIHJlc29sdXRpb24gZm9yIFVSTHMgdGhhdCBzdGFydFxuICAgICAqIHdpdGggYC9gIChhYnNvbHV0ZSBVUkxzKSBvciBgI2AgKGhhc2ggaWRlbnRpZmllcnMpLiAgRm9yIGdlbmVyYWwgcHVycG9zZVxuICAgICAqIFVSTCByZXNvbHV0aW9uLCB1c2UgYHdpbmRvdy5VUkxgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJhc2UgT3B0aW9uYWwgYmFzZSBVUkwgdG8gcmVzb2x2ZSBhZ2FpbnN0LCBkZWZhdWx0c1xuICAgICAqIHRvIHRoZSBlbGVtZW50J3MgYGltcG9ydFBhdGhgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXdyaXR0ZW4gVVJMIHJlbGF0aXZlIHRvIGJhc2VcbiAgICAgKi9cbiAgICByZXNvbHZlVXJsKHVybCwgYmFzZSkge1xuICAgICAgaWYgKCFiYXNlICYmIHRoaXMuaW1wb3J0UGF0aCkge1xuICAgICAgICBiYXNlID0gcmVzb2x2ZVVybCh0aGlzLmltcG9ydFBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVVcmwodXJsLCBiYXNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5RWZmZWN0c2AgdG8gYWRkIG1hcCBvZiBkeW5hbWljIGZ1bmN0aW9ucyBvblxuICAgICAqIHRlbXBsYXRlIGluZm8sIGZvciBjb25zdW1wdGlvbiBieSBgUHJvcGVydHlFZmZlY3RzYCB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICogY29kZS4gVGhpcyBtYXAgZGV0ZXJtaW5lcyB3aGljaCBtZXRob2QgdGVtcGxhdGVzIHNob3VsZCBoYXZlIGFjY2Vzc29yc1xuICAgICAqIGNyZWF0ZWQgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLlxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyB8fCB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMyNDApOlxuICAgICAgLy8gICAgIENoYW5nZSBiYWNrIHRvIGp1c3Qgc3VwZXIubWV0aG9kQ2FsbCgpXG4gICAgICByZXR1cm4gcG9seW1lckVsZW1lbnRCYXNlLl9wYXJzZVRlbXBsYXRlQ29udGVudC5jYWxsKFxuICAgICAgICB0aGlzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIHdhcm4gb24gdXNlIG9mIHVuZGVjbGFyZWQgcHJvcGVydGllcyBpblxuICAgICAqIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSB0byBhZGQgZWZmZWN0IHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgcHJvcCwgZWZmZWN0KSB7XG4gICAgICAvLyBXYXJuIGlmIHByb3BlcnRpZXMgYXJlIHVzZWQgaW4gdGVtcGxhdGUgd2l0aG91dCBiZWluZyBkZWNsYXJlZC5cbiAgICAgIC8vIFByb3BlcnRpZXMgbXVzdCBiZSBsaXN0ZWQgaW4gYHByb3BlcnRpZXNgIHRvIGJlIGluY2x1ZGVkIGluXG4gICAgICAvLyBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBzaW5jZSBDRSBWMSByZWFkcyB0aGF0IGF0IHJlZ2lzdHJhdGlvbiB0aW1lLCBhbmRcbiAgICAgIC8vIHNpbmNlIHdlIHdhbnQgdG8ga2VlcCB0ZW1wbGF0ZSBwYXJzaW5nIGxhenksIHdlIGNhbid0IGF1dG9tYXRpY2FsbHlcbiAgICAgIC8vIGFkZCB1bmRlY2xhcmVkIHByb3BlcnRpZXMgdXNlZCBpbiB0ZW1wbGF0ZXMgdG8gYG9ic2VydmVkQXR0cmlidXRlc2AuXG4gICAgICAvLyBUaGUgd2FybmluZyBpcyBvbmx5IGVuYWJsZWQgaW4gYGxlZ2FjeU9wdGltaXphdGlvbnNgIG1vZGUsIHNpbmNlXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHNwYW0gZXhpc3RpbmcgdXNlcnMgd2hvIG1pZ2h0IGhhdmUgYWRvcHRlZCB0aGVcbiAgICAgIC8vIHNob3J0aGFuZCB3aGVuIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24gaXMgbm90IGltcG9ydGFudC5cbiAgICAgIGlmIChsZWdhY3lXYXJuaW5ncyAmJiAhKHByb3AgaW4gdGhpcy5fcHJvcGVydGllcykgJiZcbiAgICAgICAgICAvLyBNZXRob2RzIHVzZWQgaW4gdGVtcGxhdGVzIHdpdGggbm8gZGVwZW5kZW5jaWVzIChvciBvbmx5IGxpdGVyYWxcbiAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMpIGJlY29tZSBhY2Nlc3NvcnMgd2l0aCB0ZW1wbGF0ZSBlZmZlY3RzOyBpZ25vcmUgdGhlc2VcbiAgICAgICAgICAhKGVmZmVjdC5pbmZvLnBhcnQuc2lnbmF0dXJlICYmIGVmZmVjdC5pbmZvLnBhcnQuc2lnbmF0dXJlLnN0YXRpYykgJiZcbiAgICAgICAgICAvLyBXYXJuaW5ncyBmb3IgYmluZGluZ3MgYWRkZWQgdG8gbmVzdGVkIHRlbXBsYXRlcyBhcmUgaGFuZGxlZCBieVxuICAgICAgICAgIC8vIHRlbXBsYXRpemVyIHNvIGlnbm9yZSBib3RoIHRoZSBob3N0LXRvLXRlbXBsYXRlIGJpbmRpbmdzXG4gICAgICAgICAgLy8gKGBob3N0UHJvcGApIGFuZCBUZW1wbGF0ZUluc3RhbmNlLXRvLWNoaWxkIGJpbmRpbmdzXG4gICAgICAgICAgLy8gKGBuZXN0ZWRUZW1wbGF0ZWApXG4gICAgICAgICAgIWVmZmVjdC5pbmZvLnBhcnQuaG9zdFByb3AgJiYgIXRlbXBsYXRlSW5mby5uZXN0ZWRUZW1wbGF0ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFByb3BlcnR5ICcke3Byb3B9JyB1c2VkIGluIHRlbXBsYXRlIGJ1dCBub3QgZGVjbGFyZWQgaW4gJ3Byb3BlcnRpZXMnOyBgICtcbiAgICAgICAgICBgYXR0cmlidXRlIHdpbGwgbm90IGJlIG9ic2VydmVkLmApO1xuICAgICAgfVxuICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMyNDApOlxuICAgICAgLy8gICAgIENoYW5nZSBiYWNrIHRvIGp1c3Qgc3VwZXIubWV0aG9kQ2FsbCgpXG4gICAgICByZXR1cm4gcG9seW1lckVsZW1lbnRCYXNlLl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0LmNhbGwoXG4gICAgICAgIHRoaXMsIHRlbXBsYXRlSW5mbywgcHJvcCwgZWZmZWN0KTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQb2x5bWVyRWxlbWVudDtcbn0pO1xuXG4vKipcbiAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gKiBzaGltbWVkIGBzdHlsZXNgICh2aWEgYGN1c3RvbS1zdHlsZWApIGluIHRoZSBkb2N1bWVudCAoYW5kIGl0cyBzdWJ0cmVlKVxuICogdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKlxuICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICogYXJlIHN0cmluZ3MuXG4gKlxuICogRXhhbXBsZTogYHVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCB1bmxlc3MgYSB2YWx1ZSBvZiBgbnVsbGAgaXMgc2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcHMgQmFnIG9mIGN1c3RvbSBwcm9wZXJ0eSBrZXkvdmFsdWVzIHRvXG4gKiAgIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVTdHlsZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRG9jdW1lbnQocHJvcHMpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/element-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/mutable-data.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/mutable-data.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MutableData\": () => (/* binding */ MutableData),\n/* harmony export */   \"OptionalMutableData\": () => (/* binding */ OptionalMutableData)\n/* harmony export */ });\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n// Common implementation for mixin & behavior\nfunction mutablePropertyChange(inst, property, value, old, mutableData) {\n  let isObject;\n  if (mutableData) {\n    isObject = typeof value === 'object' && value !== null;\n    // Pull `old` for Objects from temp cache, but treat `null` as a primitive\n    if (isObject) {\n      old = inst.__dataTemp[property];\n    }\n  }\n  // Strict equality check, but return false for NaN===NaN\n  let shouldChange = old !== value && (old === old || value === value);\n  // Objects are stored in temporary cache (cleared at end of\n  // turn), which is used for dirty-checking\n  if (isObject && shouldChange) {\n    inst.__dataTemp[property] = value;\n  }\n  return shouldChange;\n}\n\n/**\n * Element class mixin to skip strict dirty-checking for objects and arrays\n * (always consider them to be \"dirty\"), for use on elements utilizing\n * `PropertyEffects`\n *\n * By default, `PropertyEffects` performs strict dirty checking on\n * objects, which means that any deep modifications to an object or array will\n * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n * references from the root to the mutation were changed).\n *\n * Polymer also provides a proprietary data mutation and path notification API\n * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n * mutation and notification of deep changes in an object graph to all elements\n * bound to the same object graph.\n *\n * In cases where neither immutable patterns nor the data mutation API can be\n * used, applying this mixin will cause Polymer to skip dirty checking for\n * objects and arrays (always consider them to be \"dirty\").  This allows a\n * user to make a deep modification to a bound object graph, and then either\n * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n * elements that wish to be updated based on deep mutations must apply this\n * mixin or otherwise skip strict dirty checking for objects/arrays.\n * Specifically, any elements in the binding tree between the source of a\n * mutation and the consumption of it must apply this mixin or enable the\n * `OptionalMutableData` mixin.\n *\n * In order to make the dirty check strategy configurable, see\n * `OptionalMutableData`.\n *\n * Note, the performance characteristics of propagating large object graphs\n * will be worse as opposed to using strict dirty checking with immutable\n * patterns or Polymer's path notification API.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin to skip strict dirty-checking for objects\n *   and arrays\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst MutableData = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_MutableData}\n   */\n  class MutableData extends superClass {\n    /**\n     * Overrides `PropertyEffects` to provide option for skipping\n     * strict equality checking for Objects and Arrays.\n     *\n     * This method pulls the value to dirty check against from the `__dataTemp`\n     * cache (rather than the normal `__data` cache) for Objects.  Since the temp\n     * cache is cleared at the end of a turn, this implementation allows\n     * side-effects of deep object changes to be processed by re-setting the\n     * same object (using the temp cache as an in-turn backstop to prevent\n     * cycles due to 2-way notification).\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     * @protected\n     */\n    _shouldPropertyChange(property, value, old) {\n      return mutablePropertyChange(this, property, value, old, true);\n    }\n  }\n  return MutableData;\n});\n\n/**\n * Element class mixin to add the optional ability to skip strict\n * dirty-checking for objects and arrays (always consider them to be\n * \"dirty\") by setting a `mutable-data` attribute on an element instance.\n *\n * By default, `PropertyEffects` performs strict dirty checking on\n * objects, which means that any deep modifications to an object or array will\n * not be propagated unless \"immutable\" data patterns are used (i.e. all object\n * references from the root to the mutation were changed).\n *\n * Polymer also provides a proprietary data mutation and path notification API\n * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient\n * mutation and notification of deep changes in an object graph to all elements\n * bound to the same object graph.\n *\n * In cases where neither immutable patterns nor the data mutation API can be\n * used, applying this mixin will allow Polymer to skip dirty checking for\n * objects and arrays (always consider them to be \"dirty\").  This allows a\n * user to make a deep modification to a bound object graph, and then either\n * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`\n * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all\n * elements that wish to be updated based on deep mutations must apply this\n * mixin or otherwise skip strict dirty checking for objects/arrays.\n * Specifically, any elements in the binding tree between the source of a\n * mutation and the consumption of it must enable this mixin or apply the\n * `MutableData` mixin.\n *\n * While this mixin adds the ability to forgo Object/Array dirty checking,\n * the `mutableData` flag defaults to false and must be set on the instance.\n *\n * Note, the performance characteristics of propagating large object graphs\n * will be worse by relying on `mutableData: true` as opposed to using\n * strict dirty checking with immutable patterns or Polymer's path notification\n * API.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin to optionally skip strict dirty-checking\n *   for objects and arrays\n */\nconst OptionalMutableData = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superClass => {\n  /**\n   * @mixinClass\n   * @polymer\n   * @implements {Polymer_OptionalMutableData}\n   */\n  class OptionalMutableData extends superClass {\n    /** @nocollapse */\n    static get properties() {\n      return {\n        /**\n         * Instance-level flag for configuring the dirty-checking strategy\n         * for this element.  When true, Objects and Arrays will skip dirty\n         * checking, otherwise strict equality checking will be used.\n         */\n        mutableData: Boolean\n      };\n    }\n\n    /**\n     * Overrides `PropertyEffects` to provide option for skipping\n     * strict equality checking for Objects and Arrays.\n     *\n     * When `this.mutableData` is true on this instance, this method\n     * pulls the value to dirty check against from the `__dataTemp` cache\n     * (rather than the normal `__data` cache) for Objects.  Since the temp\n     * cache is cleared at the end of a turn, this implementation allows\n     * side-effects of deep object changes to be processed by re-setting the\n     * same object (using the temp cache as an in-turn backstop to prevent\n     * cycles due to 2-way notification).\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     * @protected\n     */\n    _shouldPropertyChange(property, value, old) {\n      return mutablePropertyChange(this, property, value, old, this.mutableData);\n    }\n  }\n  return OptionalMutableData;\n});\n\n// Export for use by legacy behavior\nMutableData._mutablePropertyChange = mutablePropertyChange;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzPzc3ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbiBmb3IgbWl4aW4gJiBiZWhhdmlvclxuZnVuY3Rpb24gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKGluc3QsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCBtdXRhYmxlRGF0YSkge1xuICBsZXQgaXNPYmplY3Q7XG4gIGlmIChtdXRhYmxlRGF0YSkge1xuICAgIGlzT2JqZWN0ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpO1xuICAgIC8vIFB1bGwgYG9sZGAgZm9yIE9iamVjdHMgZnJvbSB0ZW1wIGNhY2hlLCBidXQgdHJlYXQgYG51bGxgIGFzIGEgcHJpbWl0aXZlXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBvbGQgPSBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2ssIGJ1dCByZXR1cm4gZmFsc2UgZm9yIE5hTj09PU5hTlxuICBsZXQgc2hvdWxkQ2hhbmdlID0gKG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpO1xuICAvLyBPYmplY3RzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZlxuICAvLyB0dXJuKSwgd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmdcbiAgaWYgKGlzT2JqZWN0ICYmIHNob3VsZENoYW5nZSkge1xuICAgIGluc3QuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gc2hvdWxkQ2hhbmdlO1xufVxuXG4vKipcbiAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5c1xuICogKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIiksIGZvciB1c2Ugb24gZWxlbWVudHMgdXRpbGl6aW5nXG4gKiBgUHJvcGVydHlFZmZlY3RzYFxuICpcbiAqIEJ5IGRlZmF1bHQsIGBQcm9wZXJ0eUVmZmVjdHNgIHBlcmZvcm1zIHN0cmljdCBkaXJ0eSBjaGVja2luZyBvblxuICogb2JqZWN0cywgd2hpY2ggbWVhbnMgdGhhdCBhbnkgZGVlcCBtb2RpZmljYXRpb25zIHRvIGFuIG9iamVjdCBvciBhcnJheSB3aWxsXG4gKiBub3QgYmUgcHJvcGFnYXRlZCB1bmxlc3MgXCJpbW11dGFibGVcIiBkYXRhIHBhdHRlcm5zIGFyZSB1c2VkIChpLmUuIGFsbCBvYmplY3RcbiAqIHJlZmVyZW5jZXMgZnJvbSB0aGUgcm9vdCB0byB0aGUgbXV0YXRpb24gd2VyZSBjaGFuZ2VkKS5cbiAqXG4gKiBQb2x5bWVyIGFsc28gcHJvdmlkZXMgYSBwcm9wcmlldGFyeSBkYXRhIG11dGF0aW9uIGFuZCBwYXRoIG5vdGlmaWNhdGlvbiBBUElcbiAqIChlLmcuIGBub3RpZnlQYXRoYCwgYHNldGAsIGFuZCBhcnJheSBtdXRhdGlvbiBBUEkncykgdGhhdCBhbGxvdyBlZmZpY2llbnRcbiAqIG11dGF0aW9uIGFuZCBub3RpZmljYXRpb24gb2YgZGVlcCBjaGFuZ2VzIGluIGFuIG9iamVjdCBncmFwaCB0byBhbGwgZWxlbWVudHNcbiAqIGJvdW5kIHRvIHRoZSBzYW1lIG9iamVjdCBncmFwaC5cbiAqXG4gKiBJbiBjYXNlcyB3aGVyZSBuZWl0aGVyIGltbXV0YWJsZSBwYXR0ZXJucyBub3IgdGhlIGRhdGEgbXV0YXRpb24gQVBJIGNhbiBiZVxuICogdXNlZCwgYXBwbHlpbmcgdGhpcyBtaXhpbiB3aWxsIGNhdXNlIFBvbHltZXIgdG8gc2tpcCBkaXJ0eSBjaGVja2luZyBmb3JcbiAqIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmUgXCJkaXJ0eVwiKS4gIFRoaXMgYWxsb3dzIGFcbiAqIHVzZXIgdG8gbWFrZSBhIGRlZXAgbW9kaWZpY2F0aW9uIHRvIGEgYm91bmQgb2JqZWN0IGdyYXBoLCBhbmQgdGhlbiBlaXRoZXJcbiAqIHNpbXBseSByZS1zZXQgdGhlIG9iamVjdCAoZS5nLiBgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNgKSBvciBjYWxsIGBub3RpZnlQYXRoYFxuICogKGUuZy4gYHRoaXMubm90aWZ5UGF0aCgnaXRlbXMnKWApIHRvIHVwZGF0ZSB0aGUgdHJlZS4gIE5vdGUgdGhhdCBhbGxcbiAqIGVsZW1lbnRzIHRoYXQgd2lzaCB0byBiZSB1cGRhdGVkIGJhc2VkIG9uIGRlZXAgbXV0YXRpb25zIG11c3QgYXBwbHkgdGhpc1xuICogbWl4aW4gb3Igb3RoZXJ3aXNlIHNraXAgc3RyaWN0IGRpcnR5IGNoZWNraW5nIGZvciBvYmplY3RzL2FycmF5cy5cbiAqIFNwZWNpZmljYWxseSwgYW55IGVsZW1lbnRzIGluIHRoZSBiaW5kaW5nIHRyZWUgYmV0d2VlbiB0aGUgc291cmNlIG9mIGFcbiAqIG11dGF0aW9uIGFuZCB0aGUgY29uc3VtcHRpb24gb2YgaXQgbXVzdCBhcHBseSB0aGlzIG1peGluIG9yIGVuYWJsZSB0aGVcbiAqIGBPcHRpb25hbE11dGFibGVEYXRhYCBtaXhpbi5cbiAqXG4gKiBJbiBvcmRlciB0byBtYWtlIHRoZSBkaXJ0eSBjaGVjayBzdHJhdGVneSBjb25maWd1cmFibGUsIHNlZVxuICogYE9wdGlvbmFsTXV0YWJsZURhdGFgLlxuICpcbiAqIE5vdGUsIHRoZSBwZXJmb3JtYW5jZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgcHJvcGFnYXRpbmcgbGFyZ2Ugb2JqZWN0IGdyYXBoc1xuICogd2lsbCBiZSB3b3JzZSBhcyBvcHBvc2VkIHRvIHVzaW5nIHN0cmljdCBkaXJ0eSBjaGVja2luZyB3aXRoIGltbXV0YWJsZVxuICogcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uIEFQSS5cbiAqXG4gKiBAbWl4aW5GdW5jdGlvblxuICogQHBvbHltZXJcbiAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdG8gc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHNcbiAqICAgYW5kIGFycmF5c1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OlQpfSBzdXBlckNsYXNzIENsYXNzIHRvIGFwcGx5IG1peGluIHRvLlxuICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlQpfSBzdXBlckNsYXNzIHdpdGggbWl4aW4gYXBwbGllZC5cbiAqL1xuZXhwb3J0IGNvbnN0IE11dGFibGVEYXRhID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAqL1xuICBjbGFzcyBNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgICAqIGNhY2hlIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0cnVlKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBNdXRhYmxlRGF0YTtcblxufSk7XG5cbi8qKlxuICogRWxlbWVudCBjbGFzcyBtaXhpbiB0byBhZGQgdGhlIG9wdGlvbmFsIGFiaWxpdHkgdG8gc2tpcCBzdHJpY3RcbiAqIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gKiBcImRpcnR5XCIpIGJ5IHNldHRpbmcgYSBgbXV0YWJsZS1kYXRhYCBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCBpbnN0YW5jZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBgUHJvcGVydHlFZmZlY3RzYCBwZXJmb3JtcyBzdHJpY3QgZGlydHkgY2hlY2tpbmcgb25cbiAqIG9iamVjdHMsIHdoaWNoIG1lYW5zIHRoYXQgYW55IGRlZXAgbW9kaWZpY2F0aW9ucyB0byBhbiBvYmplY3Qgb3IgYXJyYXkgd2lsbFxuICogbm90IGJlIHByb3BhZ2F0ZWQgdW5sZXNzIFwiaW1tdXRhYmxlXCIgZGF0YSBwYXR0ZXJucyBhcmUgdXNlZCAoaS5lLiBhbGwgb2JqZWN0XG4gKiByZWZlcmVuY2VzIGZyb20gdGhlIHJvb3QgdG8gdGhlIG11dGF0aW9uIHdlcmUgY2hhbmdlZCkuXG4gKlxuICogUG9seW1lciBhbHNvIHByb3ZpZGVzIGEgcHJvcHJpZXRhcnkgZGF0YSBtdXRhdGlvbiBhbmQgcGF0aCBub3RpZmljYXRpb24gQVBJXG4gKiAoZS5nLiBgbm90aWZ5UGF0aGAsIGBzZXRgLCBhbmQgYXJyYXkgbXV0YXRpb24gQVBJJ3MpIHRoYXQgYWxsb3cgZWZmaWNpZW50XG4gKiBtdXRhdGlvbiBhbmQgbm90aWZpY2F0aW9uIG9mIGRlZXAgY2hhbmdlcyBpbiBhbiBvYmplY3QgZ3JhcGggdG8gYWxsIGVsZW1lbnRzXG4gKiBib3VuZCB0byB0aGUgc2FtZSBvYmplY3QgZ3JhcGguXG4gKlxuICogSW4gY2FzZXMgd2hlcmUgbmVpdGhlciBpbW11dGFibGUgcGF0dGVybnMgbm9yIHRoZSBkYXRhIG11dGF0aW9uIEFQSSBjYW4gYmVcbiAqIHVzZWQsIGFwcGx5aW5nIHRoaXMgbWl4aW4gd2lsbCBhbGxvdyBQb2x5bWVyIHRvIHNraXAgZGlydHkgY2hlY2tpbmcgZm9yXG4gKiBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlIFwiZGlydHlcIikuICBUaGlzIGFsbG93cyBhXG4gKiB1c2VyIHRvIG1ha2UgYSBkZWVwIG1vZGlmaWNhdGlvbiB0byBhIGJvdW5kIG9iamVjdCBncmFwaCwgYW5kIHRoZW4gZWl0aGVyXG4gKiBzaW1wbHkgcmUtc2V0IHRoZSBvYmplY3QgKGUuZy4gYHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zYCkgb3IgY2FsbCBgbm90aWZ5UGF0aGBcbiAqIChlLmcuIGB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW1zJylgKSB0byB1cGRhdGUgdGhlIHRyZWUuICBOb3RlIHRoYXQgYWxsXG4gKiBlbGVtZW50cyB0aGF0IHdpc2ggdG8gYmUgdXBkYXRlZCBiYXNlZCBvbiBkZWVwIG11dGF0aW9ucyBtdXN0IGFwcGx5IHRoaXNcbiAqIG1peGluIG9yIG90aGVyd2lzZSBza2lwIHN0cmljdCBkaXJ0eSBjaGVja2luZyBmb3Igb2JqZWN0cy9hcnJheXMuXG4gKiBTcGVjaWZpY2FsbHksIGFueSBlbGVtZW50cyBpbiB0aGUgYmluZGluZyB0cmVlIGJldHdlZW4gdGhlIHNvdXJjZSBvZiBhXG4gKiBtdXRhdGlvbiBhbmQgdGhlIGNvbnN1bXB0aW9uIG9mIGl0IG11c3QgZW5hYmxlIHRoaXMgbWl4aW4gb3IgYXBwbHkgdGhlXG4gKiBgTXV0YWJsZURhdGFgIG1peGluLlxuICpcbiAqIFdoaWxlIHRoaXMgbWl4aW4gYWRkcyB0aGUgYWJpbGl0eSB0byBmb3JnbyBPYmplY3QvQXJyYXkgZGlydHkgY2hlY2tpbmcsXG4gKiB0aGUgYG11dGFibGVEYXRhYCBmbGFnIGRlZmF1bHRzIHRvIGZhbHNlIGFuZCBtdXN0IGJlIHNldCBvbiB0aGUgaW5zdGFuY2UuXG4gKlxuICogTm90ZSwgdGhlIHBlcmZvcm1hbmNlIGNoYXJhY3RlcmlzdGljcyBvZiBwcm9wYWdhdGluZyBsYXJnZSBvYmplY3QgZ3JhcGhzXG4gKiB3aWxsIGJlIHdvcnNlIGJ5IHJlbHlpbmcgb24gYG11dGFibGVEYXRhOiB0cnVlYCBhcyBvcHBvc2VkIHRvIHVzaW5nXG4gKiBzdHJpY3QgZGlydHkgY2hlY2tpbmcgd2l0aCBpbW11dGFibGUgcGF0dGVybnMgb3IgUG9seW1lcidzIHBhdGggbm90aWZpY2F0aW9uXG4gKiBBUEkuXG4gKlxuICogQG1peGluRnVuY3Rpb25cbiAqIEBwb2x5bWVyXG4gKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRvIG9wdGlvbmFsbHkgc2tpcCBzdHJpY3QgZGlydHktY2hlY2tpbmdcbiAqICAgZm9yIG9iamVjdHMgYW5kIGFycmF5c1xuICovXG5leHBvcnQgY29uc3QgT3B0aW9uYWxNdXRhYmxlRGF0YSA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBwb2x5bWVyXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAqL1xuICBjbGFzcyBPcHRpb25hbE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogV2hlbiBgdGhpcy5tdXRhYmxlRGF0YWAgaXMgdHJ1ZSBvbiB0aGlzIGluc3RhbmNlLCB0aGlzIG1ldGhvZFxuICAgICAqIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgICAqIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0aGlzLm11dGFibGVEYXRhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT3B0aW9uYWxNdXRhYmxlRGF0YTtcblxufSk7XG5cbi8vIEV4cG9ydCBmb3IgdXNlIGJ5IGxlZ2FjeSBiZWhhdmlvclxuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZSA9IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/mutable-data.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-changed.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-changed.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertiesChanged\": () => (/* binding */ PropertiesChanged)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/async.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/async.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/** @const {!AsyncInterface} */\nconst microtask = _utils_async_js__WEBPACK_IMPORTED_MODULE_2__.microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertiesChanged = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      const proto = this.prototype;\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) {} //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     * @override\n     */\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n      // This check is technically not correct; it's an optimization that\n      // assumes that if a _property_ name is already in the map (note this is\n      // an attr->property map), the property mapped directly to the attribute\n      // and it has already been mapped.  This would fail if\n      // `attributeNameForProperty` were overridden such that this was not the\n      // case.\n      let attr = this.__dataAttributes[property];\n      if (!attr) {\n        attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n      return attr;\n    }\n\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n        /** @this {PropertiesChanged} */\n        get() {\n          // Inline for perf instead of using `_getProperty`\n          return this.__data[property];\n        },\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          // Inline for perf instead of using `_setProperty`\n          if (this._setPendingProperty(property, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n        /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      this.__dataCounter = 0;\n      this.__serializing = false;\n      this._initializeProperties();\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n    ready() {\n      this.__dataReady = true;\n      this._flushProperties();\n    }\n\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     * @override\n     */\n    _getProperty(property) {\n      return this.__data[property];\n    }\n\n    /* eslint-disable no-unused-vars */\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     * @override\n     */\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n      let changed = this._shouldPropertyChange(property, value, old);\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property is pending.\n     */\n    _isPropertyPending(property) {\n      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\n    }\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n            this._flushProperties();\n          }\n        });\n      }\n    }\n\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n          this.__dataInstanceProps = null;\n        }\n        this.ready();\n      }\n    }\n\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _flushProperties() {\n      this.__dataCounter++;\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this._propertiesChanged(props, changedProps, old);\n      }\n      this.__dataCounter--;\n    }\n\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     * @override\n     */\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n      // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {// eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n    _shouldPropertyChange(property, value, old) {\n      return (\n        // Strict equality check\n        old !== value && (\n        // This ensures (old==NaN, value==NaN) always returns false\n        old === old || value === value)\n      );\n    }\n\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     * @override\n     */\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n      }\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     * @override\n     */\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = arguments.length < 3 ? this[property] : value;\n      this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));\n      this.__serializing = false;\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     * @override\n     */\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n        node = /** @type {?Element} */(0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(node);\n      }\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(attribute,\n        // Closure's type for `setAttribute`'s second parameter incorrectly\n        // excludes `TrustedScript`.\n        str === '' && window.trustedTypes ? /** @type {?} */window.trustedTypes.emptyScript : str);\n      }\n    }\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     * @override\n     */\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return value !== null;\n        case Number:\n          return Number(value);\n        default:\n          return value;\n      }\n    }\n  }\n  return PropertiesChanged;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydGllcy1jaGFuZ2VkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnRpZXMtY2hhbmdlZC5qcz8zMGFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuXG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJy4uL3V0aWxzL3dyYXAuanMnO1xuXG4vKiogQGNvbnN0IHshQXN5bmNJbnRlcmZhY2V9ICovXG5jb25zdCBtaWNyb3Rhc2sgPSBtaWNyb1Rhc2s7XG5cbi8qKlxuICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIGNyZWF0aW5nIG9uZVxuICogb3IgbW9yZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgKGdldHRlci9zZXR0ZXIgcGFpcikgdGhhdCBlbnF1ZXVlIGFuIGFzeW5jXG4gKiAoYmF0Y2hlZCkgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gKlxuICogRm9yIGJhc2ljIHVzYWdlIG9mIHRoaXMgbWl4aW4sIGNhbGwgYE15Q2xhc3MuY3JlYXRlUHJvcGVydGllcyhwcm9wcylgXG4gKiBvbmNlIGF0IGNsYXNzIGRlZmluaXRpb24gdGltZSB0byBjcmVhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGZvciBwcm9wZXJ0aWVzXG4gKiBuYW1lZCBpbiBwcm9wcywgaW1wbGVtZW50IGBfcHJvcGVydGllc0NoYW5nZWRgIHRvIHJlYWN0IGFzIGRlc2lyZWQgdG9cbiAqIHByb3BlcnR5IGNoYW5nZXMsIGFuZCBpbXBsZW1lbnQgYHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKClgIGFuZFxuICogaW5jbHVkZSBsb3dlcmNhc2UgdmVyc2lvbnMgb2YgYW55IHByb3BlcnR5IG5hbWVzIHRoYXQgc2hvdWxkIGJlIHNldCBmcm9tXG4gKiBhdHRyaWJ1dGVzLiBMYXN0LCBjYWxsIGB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKClgIGluIHRoZSBlbGVtZW50J3NcbiAqIGBjb25uZWN0ZWRDYWxsYmFja2AgdG8gZW5hYmxlIHRoZSBhY2Nlc3NvcnMuXG4gKlxuICogQG1peGluRnVuY3Rpb25cbiAqIEBwb2x5bWVyXG4gKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIGZvciByZWFjdGluZyB0byBwcm9wZXJ0eSBjaGFuZ2VzIGZyb21cbiAqICAgZ2VuZXJhdGVkIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyBDbGFzcyB0byBhcHBseSBtaXhpbiB0by5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyB3aXRoIG1peGluIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBQcm9wZXJ0aWVzQ2hhbmdlZCA9IGRlZHVwaW5nTWl4aW4oXG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyBDbGFzcyB0byBhcHBseSBtaXhpbiB0by5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3Mgd2l0aCBtaXhpbiBhcHBsaWVkLlxuICAgICAqL1xuICAgIChzdXBlckNsYXNzKSA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnRpZXNDaGFuZ2VkfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0aWVzQ2hhbmdlZCBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IHByb3BzIE9iamVjdCB3aG9zZSBrZXlzIGFyZSBuYW1lcyBvZiBhY2Nlc3NvcnMuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgY29uc3QgcHJvdG8gPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgLy8gZG9uJ3Qgc3RvbXAgYW4gZXhpc3RpbmcgYWNjZXNzb3JcbiAgICAgICAgaWYgKCEocHJvcCBpbiBwcm90bykpIHtcbiAgICAgICAgICBwcm90by5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXR0cmlidXRlIG5hbWUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICogVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIHRoZSBsb3dlcmNhc2VkIHByb3BlcnR5IG5hbWUuIE92ZXJyaWRlIHRvXG4gICAgICogY3VzdG9taXplIHRoaXMgbWFwcGluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gY29udmVydFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQXR0cmlidXRlIG5hbWUgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCB0byBwcm92aWRlIGEgdHlwZSB0byB3aGljaCB0byBkZXNlcmlhbGl6ZSBhIHZhbHVlIHRvXG4gICAgICogYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHByb3BlcnR5XG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgdHlwZUZvclByb3BlcnR5KG5hbWUpIHsgfSAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXR0ZXIvZ2V0dGVyIHBhaXIgZm9yIHRoZSBuYW1lZCBwcm9wZXJ0eSB3aXRoIGl0cyBvd25cbiAgICAgKiBsb2NhbCBzdG9yYWdlLiAgVGhlIGdldHRlciByZXR1cm5zIHRoZSB2YWx1ZSBpbiB0aGUgbG9jYWwgc3RvcmFnZSxcbiAgICAgKiBhbmQgdGhlIHNldHRlciBjYWxscyBgX3NldFByb3BlcnR5YCwgd2hpY2ggdXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZVxuICAgICAqIGZvciB0aGUgcHJvcGVydHkgYW5kIGVucXVldWVzIGEgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIGEgcHJvdG90eXBlIG9yIGFuIGluc3RhbmNlLiAgQ2FsbGluZ1xuICAgICAqIHRoaXMgbWV0aG9kIG1heSBvdmVyd3JpdGUgYSBwcm9wZXJ0eSB2YWx1ZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uXG4gICAgICogdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBieSBjcmVhdGluZyB0aGUgYWNjZXNzb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWFkT25seSBXaGVuIHRydWUsIG5vIHNldHRlciBpcyBjcmVhdGVkOyB0aGVcbiAgICAgKiAgIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCByZWFkT25seSkge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlUb0F0dHJpYnV0ZU1hcChwcm9wZXJ0eSk7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19kYXRhSGFzQWNjZXNzb3InLCB0aGlzKSkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSkge1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RlZmluZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBgcHJvcGVydHlgIHRvIGEgbWFwIG1hdGNoaW5nIGF0dHJpYnV0ZSBuYW1lc1xuICAgICAqIHRvIHByb3BlcnR5IG5hbWVzLCB1c2luZyBgYXR0cmlidXRlTmFtZUZvclByb3BlcnR5YC4gVGhpcyBtYXAgaXNcbiAgICAgKiB1c2VkIHdoZW4gZGVzZXJpYWxpemluZyBhdHRyaWJ1dGUgdmFsdWVzIHRvIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYWRkUHJvcGVydHlUb0F0dHJpYnV0ZU1hcChwcm9wZXJ0eSkge1xuICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YUF0dHJpYnV0ZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fX2RhdGFBdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgY2hlY2sgaXMgdGVjaG5pY2FsbHkgbm90IGNvcnJlY3Q7IGl0J3MgYW4gb3B0aW1pemF0aW9uIHRoYXRcbiAgICAgIC8vIGFzc3VtZXMgdGhhdCBpZiBhIF9wcm9wZXJ0eV8gbmFtZSBpcyBhbHJlYWR5IGluIHRoZSBtYXAgKG5vdGUgdGhpcyBpc1xuICAgICAgLy8gYW4gYXR0ci0+cHJvcGVydHkgbWFwKSwgdGhlIHByb3BlcnR5IG1hcHBlZCBkaXJlY3RseSB0byB0aGUgYXR0cmlidXRlXG4gICAgICAvLyBhbmQgaXQgaGFzIGFscmVhZHkgYmVlbiBtYXBwZWQuICBUaGlzIHdvdWxkIGZhaWwgaWZcbiAgICAgIC8vIGBhdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHlgIHdlcmUgb3ZlcnJpZGRlbiBzdWNoIHRoYXQgdGhpcyB3YXMgbm90IHRoZVxuICAgICAgLy8gY2FzZS5cbiAgICAgIGxldCBhdHRyID0gdGhpcy5fX2RhdGFBdHRyaWJ1dGVzW3Byb3BlcnR5XTtcbiAgICAgIGlmICghYXR0cikge1xuICAgICAgICBhdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICB0aGlzLl9fZGF0YUF0dHJpYnV0ZXNbYXR0cl0gPSBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSBwcm9wZXJ0eSBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYWRPbmx5IFdoZW4gdHJ1ZSwgbm8gc2V0dGVyIGlzIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgICBfZGVmaW5lUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAgICAgICAvKiogQHRoaXMge1Byb3BlcnRpZXNDaGFuZ2VkfSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgLy8gSW5saW5lIGZvciBwZXJmIGluc3RlYWQgb2YgdXNpbmcgYF9nZXRQcm9wZXJ0eWBcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQHRoaXMge1Byb3BlcnRpZXNDaGFuZ2VkfSAqL1xuICAgICAgICBzZXQ6IHJlYWRPbmx5ID8gZnVuY3Rpb24gKCkge30gOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgZm9yIHBlcmYgaW5zdGVhZCBvZiB1c2luZyBgX3NldFByb3BlcnR5YFxuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhID0ge307XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gbnVsbDtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgLy8gTk9URTogdXNlZCB0byB0cmFjayByZS1lbnRyYW50IGNhbGxzIHRvIGBfZmx1c2hQcm9wZXJ0aWVzYFxuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgY2FsbGJhY2sgY2FsbGVkIHdoZW4gcHJvcGVydGllcyBhcmUgZW5hYmxlZCB2aWFcbiAgICAgKiBgX2VuYWJsZVByb3BlcnRpZXNgLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gaW1wbGVtZW50IGJlaGF2aW9yIHRoYXQgaXNcbiAgICAgKiBkZXBlbmRlbnQgb24gdGhlIGVsZW1lbnQgaGF2aW5nIGl0cyBwcm9wZXJ0eSBkYXRhIGluaXRpYWxpemVkLCBlLmcuXG4gICAgICogZnJvbSBkZWZhdWx0cyAoaW5pdGlhbGl6ZWQgZnJvbSBgY29uc3RydWN0b3JgLCBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCksXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHZhbHVlcyBwcm9wYWdhdGVkIGZyb20gaG9zdCBlLmcuIHZpYVxuICAgICAqIGJpbmRpbmdzLiAgYHN1cGVyLnJlYWR5KClgIG11c3QgYmUgY2FsbGVkIHRvIGVuc3VyZSB0aGUgZGF0YSBzeXN0ZW1cbiAgICAgKiBiZWNvbWVzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKlxuICAgICAqIFByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwZXJmb3JtaW5nIGFueSBzZXR1cCB3b3JrIHByaW9yXG4gICAgICogdG8gaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSBhY2Nlc3NvciBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICAvLyBDYXB0dXJlIGluc3RhbmNlIHByb3BlcnRpZXM7IHRoZXNlIHdpbGwgYmUgc2V0IGludG8gYWNjZXNzb3JzXG4gICAgICAvLyBkdXJpbmcgZmlyc3QgZmx1c2guIERvbid0IHNldCB0aGVtIGhlcmUsIHNpbmNlIHdlIHdhbnRcbiAgICAgIC8vIHRoZXNlIHRvIG92ZXJ3cml0ZSBkZWZhdWx0cy9jb25zdHJ1Y3RvciBhc3NpZ25tZW50c1xuICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wc1twXSA9IHRoaXNbcF07XG4gICAgICAgICAgZGVsZXRlIHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgcmVhZHkgdGltZSB3aXRoIGJhZyBvZiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHRoYXQgb3Zlcndyb3RlXG4gICAgICogYWNjZXNzb3JzIHdoZW4gdGhlIGVsZW1lbnQgdXBncmFkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzZXRzIHRoZXNlIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZVxuICAgICAqIHNldHRlciBhdCByZWFkeSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSAodmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YClcbiAgICAgKiBhbmQgZW5xdWV1ZXMgYSBgX3Byb2VwcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4geyp9IFZhbHVlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2dldFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSwgcmVjb3JkcyB0aGUgcHJldmlvdXMgdmFsdWUsXG4gICAgICogYW5kIGFkZHMgaXQgdG8gdGhlIHNldCBvZiBcInBlbmRpbmcgY2hhbmdlc1wiIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBlbnF1ZXVlIHRoZVxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleHQgTm90IHVzZWQgaGVyZTsgYWZmb3JkYW5jZSBmb3IgY2xvc3VyZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgZXh0KSB7XG4gICAgICBsZXQgb2xkID0gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCk7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIG9sZCBpcyBjYXB0dXJlZCBmcm9tIHRoZSBsYXN0IHR1cm5cbiAgICAgICAgaWYgKHRoaXMuX19kYXRhT2xkICYmICEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGRbcHJvcGVydHldID0gb2xkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBpcyBwZW5kaW5nLlxuICAgICAqL1xuICAgIF9pc1Byb3BlcnR5UGVuZGluZyhwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuX19kYXRhUGVuZGluZyAmJiB0aGlzLl9fZGF0YVBlbmRpbmcuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgcHJvcGVydGllcyBhcyBpbnZhbGlkLCBhbmQgZW5xdWV1ZXMgYW4gYXN5bmNcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFJbnZhbGlkICYmIHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgbWljcm90YXNrLnJ1bigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdG8gZW5hYmxlIHByb3BlcnR5IGFjY2Vzc29yIHByb2Nlc3NpbmcuIEJlZm9yZSB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCBhY2Nlc3NvciB2YWx1ZXMgd2lsbCBiZSBzZXQgYnV0IHNpZGUgZWZmZWN0cyBhcmVcbiAgICAgKiBxdWV1ZWQuIFdoZW4gY2FsbGVkLCBhbnkgcGVuZGluZyBzaWRlIGVmZmVjdHMgb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgICogRm9yIGVsZW1lbnRzLCBnZW5lcmFsbHkgYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBhIG5vcm1hbCBzcG90IHRvIGRvIHNvLlxuICAgICAqIEl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyBhcyBpdCBvbmx5IHR1cm5zIG9uXG4gICAgICogcHJvcGVydHkgYWNjZXNzb3JzIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfZW5hYmxlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyk7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrIHdpdGggdGhlIGN1cnJlbnQgc2V0IG9mXG4gICAgICogcGVuZGluZyBjaGFuZ2VzIChhbmQgb2xkIHZhbHVlcyByZWNvcmRlZCB3aGVuIHBlbmRpbmcgY2hhbmdlcyB3ZXJlXG4gICAgICogc2V0KSwgYW5kIHJlc2V0cyB0aGUgcGVuZGluZyBzZXQgb2YgY2hhbmdlcy4gR2VuZXJhbGx5LCB0aGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBub3QgYmUgY2FsbGVkIGluIHVzZXIgY29kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9mbHVzaFByb3BlcnRpZXMoKSB7XG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXIrKztcbiAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5fX2RhdGE7XG4gICAgICBjb25zdCBjaGFuZ2VkUHJvcHMgPSB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICBjb25zdCBvbGQgPSB0aGlzLl9fZGF0YU9sZDtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRQcm9wZXJ0aWVzQ2hhbmdlKHByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZCkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzQ2hhbmdlZChwcm9wcywgY2hhbmdlZFByb3BzLCBvbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyLS07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGluIGBfZmx1c2hQcm9wZXJ0aWVzYCB0byBkZXRlcm1pbmUgaWYgYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRydWUgaWZcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBwZW5kaW5nLiBPdmVycmlkZSB0byBjdXN0b21pemUgd2hlblxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGlzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAqIEBwYXJhbSB7P09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGNoYW5nZWRQcm9wcyBpcyB0cnV0aHlcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydGllc0NoYW5nZShjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIEJvb2xlYW4oY2hhbmdlZFByb3BzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiBhbnkgcHJvcGVydGllcyB3aXRoIGFjY2Vzc29ycyBjcmVhdGVkIHZpYVxuICAgICAqIGBfY3JlYXRlUHJvcGVydHlBY2Nlc3NvcmAgaGF2ZSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gY3VycmVudFByb3BzIEJhZyBvZiBhbGwgY3VycmVudCBhY2Nlc3NvciB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgcHJvcGVydGllcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0XG4gICAgICogICBjYWxsIHRvIGBfcHJvcGVydGllc0NoYW5nZWRgXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICogICBpbiBgY2hhbmdlZFByb3BzYFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSB2YWx1ZSBzaG91bGQgYmVcbiAgICAgKiBjb25zaWRlcmVkIGFzIGEgY2hhbmdlIGFuZCBjYXVzZSB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiB0byBiZSBlbnF1ZXVlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgYHRydWVgIGlmIGEgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogY2hlY2sgZmFpbHMuIFRoZSBtZXRob2QgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGBOYU5gLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZS5nLiBwcm92aWRlIHN0cmljdGVyIGNoZWNraW5nIGZvclxuICAgICAqIE9iamVjdHMvQXJyYXlzIHdoZW4gdXNpbmcgaW1tdXRhYmxlIHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiAgIGFuZCBlbnF1ZXVlIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgKG9sZCAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgKG9sZD09TmFOLCB2YWx1ZT09TmFOKSBhbHdheXMgcmV0dXJucyBmYWxzZVxuICAgICAgICAgIChvbGQgPT09IG9sZCB8fCB2YWx1ZSA9PT0gdmFsdWUpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIG5hdGl2ZSBDdXN0b20gRWxlbWVudHMgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG9cbiAgICAgKiBzZXQgYW4gYXR0cmlidXRlIHZhbHVlIHRvIGEgcHJvcGVydHkgdmlhIGBfYXR0cmlidXRlVG9Qcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZSB0aGF0IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBOZXcgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2UgQXR0cmlidXRlIG5hbWVzcGFjZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IFN1cGVyIG1heSBvciBtYXkgbm90IGltcGxlbWVudCB0aGUgY2FsbGJhY2tcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGFuIGF0dHJpYnV0ZSB0byBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG9cbiAgICAgKiBhIHR5cGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSB0eXBlIHRvIGRlc2VyaWFsaXplIHRvLCBkZWZhdWx0cyB0byB0aGUgdmFsdWVcbiAgICAgKiByZXR1cm5lZCBmcm9tIGB0eXBlRm9yUHJvcGVydHlgXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYXR0cmlidXRlVG9Qcm9wZXJ0eShhdHRyaWJ1dGUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICBpZiAoIXRoaXMuX19zZXJpYWxpemluZykge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLl9fZGF0YUF0dHJpYnV0ZXM7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gbWFwICYmIG1hcFthdHRyaWJ1dGVdIHx8IGF0dHJpYnV0ZTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlIHx8XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci50eXBlRm9yUHJvcGVydHkocHJvcGVydHkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgcHJvcGVydHkgdG8gaXRzIGFzc29jaWF0ZWQgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9IENsb3N1cmUgY2FuJ3QgZmlndXJlIG91dCBgdGhpc2AgaXMgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdCB0by5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gdHJ1ZTtcbiAgICAgIHZhbHVlID0gKGFyZ3VtZW50cy5sZW5ndGggPCAzKSA/IHRoaXNbcHJvcGVydHldIDogdmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcyksIHZhbHVlLFxuICAgICAgICBhdHRyaWJ1dGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkocHJvcGVydHkpKTtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHRvIGNvbnZlcnQgdGhlIHR5cGVkXG4gICAgICogdmFsdWUgdG8gYSBzdHJpbmcuICBJZiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQgKHRoaXMgaXMgdGhlIGRlZmF1bHQgZm9yIGJvb2xlYW5cbiAgICAgKiB0eXBlIGBmYWxzZWApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICBjb25zdCBzdHIgPSB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICBpZiAoYXR0cmlidXRlID09PSAnY2xhc3MnIHx8IGF0dHJpYnV0ZSA9PT0gJ25hbWUnIHx8IGF0dHJpYnV0ZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIG5vZGUgPSAvKiogQHR5cGUgez9FbGVtZW50fSAqLyh3cmFwKG5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAvLyBDbG9zdXJlJ3MgdHlwZSBmb3IgYHNldEF0dHJpYnV0ZWAncyBzZWNvbmQgcGFyYW1ldGVyIGluY29ycmVjdGx5XG4gICAgICAgICAgICAvLyBleGNsdWRlcyBgVHJ1c3RlZFNjcmlwdGAuXG4gICAgICAgICAgICAoc3RyID09PSAnJyAmJiB3aW5kb3cudHJ1c3RlZFR5cGVzKSA/XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqLyAod2luZG93LnRydXN0ZWRUeXBlcy5lbXB0eVNjcmlwdCkgOlxuICAgICAgICAgICAgICAgIHN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gc2V0dGluZyBKUyBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICAgKiBIVE1MIGF0dHJpYnV0ZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJvdmlkZVxuICAgICAqIHNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU3RyaW5nIHNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWRcbiAgICAgKiBwcm9wZXJ0eSAgdmFsdWUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gcmVhZGluZyBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMgdG9cbiAgICAgKiBKUyBwcm9wZXJ0aWVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGVcbiAgICAgKiBkZXNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSBgdHlwZWBzLiBUeXBlcyBmb3IgYEJvb2xlYW5gLCBgU3RyaW5nYCxcbiAgICAgKiBhbmQgYE51bWJlcmAgY29udmVydCBhdHRyaWJ1dGVzIHRvIHRoZSBleHBlY3RlZCB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gZGVzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG8uXG4gICAgICogQHJldHVybiB7Kn0gVHlwZWQgdmFsdWUgZGVzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICByZXR1cm4gKHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFByb3BlcnRpZXNDaGFuZ2VkO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-changed.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertiesMixin\": () => (/* binding */ PropertiesMixin)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/telemetry.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/telemetry.js\");\n/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * Creates a copy of `props` with each property normalized such that\n * upgraded it is an object with at least a type property { type: Type}.\n *\n * @param {!Object} props Properties to normalize\n * @return {!Object} Copy of input `props` with normalized properties that\n * are in the form {type: Type}\n * @private\n */\nfunction normalizeProperties(props) {\n  const output = {};\n  for (let p in props) {\n    const o = props[p];\n    output[p] = typeof o === 'function' ? {\n      type: o\n    } : o;\n  }\n  return output;\n}\n\n/**\n * Mixin that provides a minimal starting point to using the PropertiesChanged\n * mixin by providing a mechanism to declare properties in a static\n * getter (e.g. static get properties() { return { foo: String } }). Changes\n * are reported via the `_propertiesChanged` method.\n *\n * This mixin provides no specific support for rendering. Users are expected\n * to create a ShadowRoot and put content into it and update it in whatever\n * way makes sense. This can be done in reaction to properties changing by\n * implementing `_propertiesChanged`.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Mixin that provides a minimal starting point for using\n * the PropertiesChanged mixin by providing a declarative `properties` object.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertiesMixin = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @private\n   */\n  const base = (0,_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__.PropertiesChanged)(superClass);\n\n  /**\n   * Returns the super class constructor for the given class, if it is an\n   * instance of the PropertiesMixin.\n   *\n   * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor\n   * @return {?PropertiesMixinConstructor} Super class constructor\n   */\n  function superPropertiesClass(constructor) {\n    const superCtor = Object.getPrototypeOf(constructor);\n\n    // Note, the `PropertiesMixin` class below only refers to the class\n    // generated by this call to the mixin; the instanceof test only works\n    // because the mixin is deduped and guaranteed only to apply once, hence\n    // all constructors in a proto chain will see the same `PropertiesMixin`\n    return superCtor.prototype instanceof PropertiesMixin ? /** @type {!PropertiesMixinConstructor} */superCtor : null;\n  }\n\n  /**\n   * Returns a memoized version of the `properties` object for the\n   * given class. Properties not in object format are converted to at\n   * least {type}.\n   *\n   * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor\n   * @return {Object} Memoized properties object\n   */\n  function ownProperties(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {\n      let props = null;\n      if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {\n        const properties = constructor.properties;\n        if (properties) {\n          props = normalizeProperties(properties);\n        }\n      }\n      constructor.__ownProperties = props;\n    }\n    return constructor.__ownProperties;\n  }\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {base}\n   * @implements {Polymer_PropertiesMixin}\n   * @unrestricted\n   */\n  class PropertiesMixin extends base {\n    /**\n     * Implements standard custom elements getter to observes the attributes\n     * listed in `properties`.\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static get observedAttributes() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n        (0,_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__.register)(this.prototype);\n        const props = this._properties;\n        this.__observedAttributes = props ? Object.keys(props).map(p => this.prototype._addPropertyToAttributeMap(p)) : [];\n      }\n      return this.__observedAttributes;\n    }\n\n    /**\n     * Finalizes an element definition, including ensuring any super classes\n     * are also finalized. This includes ensuring property\n     * accessors exist on the element prototype. This method calls\n     * `_finalizeClass` to finalize each constructor in the prototype chain.\n     * @return {void}\n     * @nocollapse\n     */\n    static finalize() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {\n        const superCtor = superPropertiesClass( /** @type {!PropertiesMixinConstructor} */this);\n        if (superCtor) {\n          superCtor.finalize();\n        }\n        this.__finalized = true;\n        this._finalizeClass();\n      }\n    }\n\n    /**\n     * Finalize an element class. This includes ensuring property\n     * accessors exist on the element prototype. This method is called by\n     * `finalize` and finalizes the class constructor.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static _finalizeClass() {\n      const props = ownProperties( /** @type {!PropertiesMixinConstructor} */this);\n      if (props) {\n        /** @type {?} */this.createProperties(props);\n      }\n    }\n\n    /**\n     * Returns a memoized version of all properties, including those inherited\n     * from super classes. Properties not in object format are converted to\n     * at least {type}.\n     *\n     * @return {Object} Object containing properties for this class\n     * @protected\n     * @nocollapse\n     */\n    static get _properties() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {\n        const superCtor = superPropertiesClass( /** @type {!PropertiesMixinConstructor} */this);\n        this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties( /** @type {PropertiesMixinConstructor} */this));\n      }\n      return this.__properties;\n    }\n\n    /**\n     * Overrides `PropertiesChanged` method to return type specified in the\n     * static `properties` object for the given property.\n     * @param {string} name Name of property\n     * @return {*} Type to which to deserialize attribute\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) {\n      const info = this._properties[name];\n      return info && info.type;\n    }\n\n    /**\n     * Overrides `PropertiesChanged` method and adds a call to\n     * `finalize` which lazily configures the element's property accessors.\n     * @override\n     * @return {void}\n     */\n    _initializeProperties() {\n      (0,_utils_telemetry_js__WEBPACK_IMPORTED_MODULE_2__.incrementInstanceCount)();\n      this.constructor.finalize();\n      super._initializeProperties();\n    }\n\n    /**\n     * Called when the element is added to a document.\n     * Calls `_enableProperties` to turn on property system from\n     * `PropertiesChanged`.\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @return {void}\n     * @override\n     */\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n      this._enableProperties();\n    }\n\n    /**\n     * Called when the element is removed from a document\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @return {void}\n     * @override\n     */\n    disconnectedCallback() {\n      if (super.disconnectedCallback) {\n        super.disconnectedCallback();\n      }\n    }\n  }\n  return PropertiesMixin;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydGllcy1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydGllcy1taXhpbi5qcz82MTMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuXG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXIsIGluY3JlbWVudEluc3RhbmNlQ291bnQgfSBmcm9tICcuLi91dGlscy90ZWxlbWV0cnkuanMnO1xuaW1wb3J0IHsgUHJvcGVydGllc0NoYW5nZWQgfSBmcm9tICcuL3Byb3BlcnRpZXMtY2hhbmdlZC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgYHByb3BzYCB3aXRoIGVhY2ggcHJvcGVydHkgbm9ybWFsaXplZCBzdWNoIHRoYXRcbiAqIHVwZ3JhZGVkIGl0IGlzIGFuIG9iamVjdCB3aXRoIGF0IGxlYXN0IGEgdHlwZSBwcm9wZXJ0eSB7IHR5cGU6IFR5cGV9LlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBub3JtYWxpemVcbiAqIEByZXR1cm4geyFPYmplY3R9IENvcHkgb2YgaW5wdXQgYHByb3BzYCB3aXRoIG5vcm1hbGl6ZWQgcHJvcGVydGllcyB0aGF0XG4gKiBhcmUgaW4gdGhlIGZvcm0ge3R5cGU6IFR5cGV9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0aWVzKHByb3BzKSB7XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgY29uc3QgbyA9IHByb3BzW3BdO1xuICAgIG91dHB1dFtwXSA9ICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJykgPyB7dHlwZTogb30gOiBvO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogTWl4aW4gdGhhdCBwcm92aWRlcyBhIG1pbmltYWwgc3RhcnRpbmcgcG9pbnQgdG8gdXNpbmcgdGhlIFByb3BlcnRpZXNDaGFuZ2VkXG4gKiBtaXhpbiBieSBwcm92aWRpbmcgYSBtZWNoYW5pc20gdG8gZGVjbGFyZSBwcm9wZXJ0aWVzIGluIGEgc3RhdGljXG4gKiBnZXR0ZXIgKGUuZy4gc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkgeyByZXR1cm4geyBmb286IFN0cmluZyB9IH0pLiBDaGFuZ2VzXG4gKiBhcmUgcmVwb3J0ZWQgdmlhIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBtZXRob2QuXG4gKlxuICogVGhpcyBtaXhpbiBwcm92aWRlcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciByZW5kZXJpbmcuIFVzZXJzIGFyZSBleHBlY3RlZFxuICogdG8gY3JlYXRlIGEgU2hhZG93Um9vdCBhbmQgcHV0IGNvbnRlbnQgaW50byBpdCBhbmQgdXBkYXRlIGl0IGluIHdoYXRldmVyXG4gKiB3YXkgbWFrZXMgc2Vuc2UuIFRoaXMgY2FuIGJlIGRvbmUgaW4gcmVhY3Rpb24gdG8gcHJvcGVydGllcyBjaGFuZ2luZyBieVxuICogaW1wbGVtZW50aW5nIGBfcHJvcGVydGllc0NoYW5nZWRgLlxuICpcbiAqIEBtaXhpbkZ1bmN0aW9uXG4gKiBAcG9seW1lclxuICogQGFwcGxpZXNNaXhpbiBQcm9wZXJ0aWVzQ2hhbmdlZFxuICogQHN1bW1hcnkgTWl4aW4gdGhhdCBwcm92aWRlcyBhIG1pbmltYWwgc3RhcnRpbmcgcG9pbnQgZm9yIHVzaW5nXG4gKiB0aGUgUHJvcGVydGllc0NoYW5nZWQgbWl4aW4gYnkgcHJvdmlkaW5nIGEgZGVjbGFyYXRpdmUgYHByb3BlcnRpZXNgIG9iamVjdC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyBDbGFzcyB0byBhcHBseSBtaXhpbiB0by5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyB3aXRoIG1peGluIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBQcm9wZXJ0aWVzTWl4aW4gPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gLyoqXG4gICogQGNvbnN0cnVjdG9yXG4gICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydGllc0NoYW5nZWR9XG4gICogQHByaXZhdGVcbiAgKi9cbiBjb25zdCBiYXNlID0gUHJvcGVydGllc0NoYW5nZWQoc3VwZXJDbGFzcyk7XG5cbiAvKipcbiAgKiBSZXR1cm5zIHRoZSBzdXBlciBjbGFzcyBjb25zdHJ1Y3RvciBmb3IgdGhlIGdpdmVuIGNsYXNzLCBpZiBpdCBpcyBhblxuICAqIGluc3RhbmNlIG9mIHRoZSBQcm9wZXJ0aWVzTWl4aW4uXG4gICpcbiAgKiBAcGFyYW0geyFQcm9wZXJ0aWVzTWl4aW5Db25zdHJ1Y3Rvcn0gY29uc3RydWN0b3IgUHJvcGVydGllc01peGluIGNvbnN0cnVjdG9yXG4gICogQHJldHVybiB7P1Byb3BlcnRpZXNNaXhpbkNvbnN0cnVjdG9yfSBTdXBlciBjbGFzcyBjb25zdHJ1Y3RvclxuICAqL1xuIGZ1bmN0aW9uIHN1cGVyUHJvcGVydGllc0NsYXNzKGNvbnN0cnVjdG9yKSB7XG4gICBjb25zdCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uc3RydWN0b3IpO1xuXG4gICAvLyBOb3RlLCB0aGUgYFByb3BlcnRpZXNNaXhpbmAgY2xhc3MgYmVsb3cgb25seSByZWZlcnMgdG8gdGhlIGNsYXNzXG4gICAvLyBnZW5lcmF0ZWQgYnkgdGhpcyBjYWxsIHRvIHRoZSBtaXhpbjsgdGhlIGluc3RhbmNlb2YgdGVzdCBvbmx5IHdvcmtzXG4gICAvLyBiZWNhdXNlIHRoZSBtaXhpbiBpcyBkZWR1cGVkIGFuZCBndWFyYW50ZWVkIG9ubHkgdG8gYXBwbHkgb25jZSwgaGVuY2VcbiAgIC8vIGFsbCBjb25zdHJ1Y3RvcnMgaW4gYSBwcm90byBjaGFpbiB3aWxsIHNlZSB0aGUgc2FtZSBgUHJvcGVydGllc01peGluYFxuICAgcmV0dXJuIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUHJvcGVydGllc01peGluKSA/XG4gICAgIC8qKiBAdHlwZSB7IVByb3BlcnRpZXNNaXhpbkNvbnN0cnVjdG9yfSAqLyAoc3VwZXJDdG9yKSA6IG51bGw7XG4gfVxuXG4gLyoqXG4gICogUmV0dXJucyBhIG1lbW9pemVkIHZlcnNpb24gb2YgdGhlIGBwcm9wZXJ0aWVzYCBvYmplY3QgZm9yIHRoZVxuICAqIGdpdmVuIGNsYXNzLiBQcm9wZXJ0aWVzIG5vdCBpbiBvYmplY3QgZm9ybWF0IGFyZSBjb252ZXJ0ZWQgdG8gYXRcbiAgKiBsZWFzdCB7dHlwZX0uXG4gICpcbiAgKiBAcGFyYW0ge1Byb3BlcnRpZXNNaXhpbkNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvciBQcm9wZXJ0aWVzTWl4aW4gY29uc3RydWN0b3JcbiAgKiBAcmV0dXJuIHtPYmplY3R9IE1lbW9pemVkIHByb3BlcnRpZXMgb2JqZWN0XG4gICovXG4gZnVuY3Rpb24gb3duUHJvcGVydGllcyhjb25zdHJ1Y3Rvcikge1xuICAgaWYgKCFjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293blByb3BlcnRpZXMnLCBjb25zdHJ1Y3RvcikpKSB7XG4gICAgIGxldCBwcm9wcyA9IG51bGw7XG5cbiAgICAgaWYgKGNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCBjb25zdHJ1Y3RvcikpKSB7XG4gICAgICAgY29uc3QgcHJvcGVydGllcyA9IGNvbnN0cnVjdG9yLnByb3BlcnRpZXM7XG5cbiAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBwcm9wcyA9IG5vcm1hbGl6ZVByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICAgfVxuICAgICB9XG5cbiAgICAgY29uc3RydWN0b3IuX19vd25Qcm9wZXJ0aWVzID0gcHJvcHM7XG4gICB9XG4gICByZXR1cm4gY29uc3RydWN0b3IuX19vd25Qcm9wZXJ0aWVzO1xuIH1cblxuIC8qKlxuICAqIEBwb2x5bWVyXG4gICogQG1peGluQ2xhc3NcbiAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0aWVzTWl4aW59XG4gICogQHVucmVzdHJpY3RlZFxuICAqL1xuIGNsYXNzIFByb3BlcnRpZXNNaXhpbiBleHRlbmRzIGJhc2Uge1xuXG4gICAvKipcbiAgICAqIEltcGxlbWVudHMgc3RhbmRhcmQgY3VzdG9tIGVsZW1lbnRzIGdldHRlciB0byBvYnNlcnZlcyB0aGUgYXR0cmlidXRlc1xuICAgICogbGlzdGVkIGluIGBwcm9wZXJ0aWVzYC5cbiAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICogQG5vY29sbGFwc2VcbiAgICAqL1xuICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX29ic2VydmVkQXR0cmlidXRlcycsIHRoaXMpKSkge1xuICAgICAgIHJlZ2lzdGVyKHRoaXMucHJvdG90eXBlKTtcbiAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgICAgdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcyA9IHByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpLm1hcChwID0+IHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eVRvQXR0cmlidXRlTWFwKHApKSA6IFtdO1xuICAgICB9XG4gICAgIHJldHVybiB0aGlzLl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgfVxuXG4gICAvKipcbiAgICAqIEZpbmFsaXplcyBhbiBlbGVtZW50IGRlZmluaXRpb24sIGluY2x1ZGluZyBlbnN1cmluZyBhbnkgc3VwZXIgY2xhc3Nlc1xuICAgICogYXJlIGFsc28gZmluYWxpemVkLiBUaGlzIGluY2x1ZGVzIGVuc3VyaW5nIHByb3BlcnR5XG4gICAgKiBhY2Nlc3NvcnMgZXhpc3Qgb24gdGhlIGVsZW1lbnQgcHJvdG90eXBlLiBUaGlzIG1ldGhvZCBjYWxsc1xuICAgICogYF9maW5hbGl6ZUNsYXNzYCB0byBmaW5hbGl6ZSBlYWNoIGNvbnN0cnVjdG9yIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICogQG5vY29sbGFwc2VcbiAgICAqL1xuICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19maW5hbGl6ZWQnLCB0aGlzKSkpIHtcbiAgICAgICBjb25zdCBzdXBlckN0b3IgPSBzdXBlclByb3BlcnRpZXNDbGFzcygvKiogQHR5cGUgeyFQcm9wZXJ0aWVzTWl4aW5Db25zdHJ1Y3Rvcn0gKi8odGhpcykpO1xuICAgICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgICAgIHN1cGVyQ3Rvci5maW5hbGl6ZSgpO1xuICAgICAgIH1cbiAgICAgICB0aGlzLl9fZmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICB0aGlzLl9maW5hbGl6ZUNsYXNzKCk7XG4gICAgIH1cbiAgIH1cblxuICAgLyoqXG4gICAgKiBGaW5hbGl6ZSBhbiBlbGVtZW50IGNsYXNzLiBUaGlzIGluY2x1ZGVzIGVuc3VyaW5nIHByb3BlcnR5XG4gICAgKiBhY2Nlc3NvcnMgZXhpc3Qgb24gdGhlIGVsZW1lbnQgcHJvdG90eXBlLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnlcbiAgICAqIGBmaW5hbGl6ZWAgYW5kIGZpbmFsaXplcyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gICAgKlxuICAgICogQHByb3RlY3RlZFxuICAgICogQG5vY29sbGFwc2VcbiAgICAqL1xuICAgc3RhdGljIF9maW5hbGl6ZUNsYXNzKCkge1xuICAgICBjb25zdCBwcm9wcyA9IG93blByb3BlcnRpZXMoLyoqIEB0eXBlIHshUHJvcGVydGllc01peGluQ29uc3RydWN0b3J9ICovKHRoaXMpKTtcbiAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgLyoqIEB0eXBlIHs/fSAqLyAodGhpcykuY3JlYXRlUHJvcGVydGllcyhwcm9wcyk7XG4gICAgIH1cbiAgIH1cblxuICAgLyoqXG4gICAgKiBSZXR1cm5zIGEgbWVtb2l6ZWQgdmVyc2lvbiBvZiBhbGwgcHJvcGVydGllcywgaW5jbHVkaW5nIHRob3NlIGluaGVyaXRlZFxuICAgICogZnJvbSBzdXBlciBjbGFzc2VzLiBQcm9wZXJ0aWVzIG5vdCBpbiBvYmplY3QgZm9ybWF0IGFyZSBjb252ZXJ0ZWQgdG9cbiAgICAqIGF0IGxlYXN0IHt0eXBlfS5cbiAgICAqXG4gICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqIEBub2NvbGxhcHNlXG4gICAgKi9cbiAgIHN0YXRpYyBnZXQgX3Byb3BlcnRpZXMoKSB7XG4gICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX3Byb3BlcnRpZXMnLCB0aGlzKSkpIHtcbiAgICAgICBjb25zdCBzdXBlckN0b3IgPSBzdXBlclByb3BlcnRpZXNDbGFzcygvKiogQHR5cGUgeyFQcm9wZXJ0aWVzTWl4aW5Db25zdHJ1Y3Rvcn0gKi8odGhpcykpO1xuICAgICAgIHRoaXMuX19wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgICAgIHN1cGVyQ3RvciAmJiBzdXBlckN0b3IuX3Byb3BlcnRpZXMsXG4gICAgICAgICBvd25Qcm9wZXJ0aWVzKC8qKiBAdHlwZSB7UHJvcGVydGllc01peGluQ29uc3RydWN0b3J9ICovKHRoaXMpKSk7XG4gICAgIH1cbiAgICAgcmV0dXJuIHRoaXMuX19wcm9wZXJ0aWVzO1xuICAgfVxuXG4gICAvKipcbiAgICAqIE92ZXJyaWRlcyBgUHJvcGVydGllc0NoYW5nZWRgIG1ldGhvZCB0byByZXR1cm4gdHlwZSBzcGVjaWZpZWQgaW4gdGhlXG4gICAgKiBzdGF0aWMgYHByb3BlcnRpZXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBwcm9wZXJ0eVxuICAgICogQHJldHVybiB7Kn0gVHlwZSB0byB3aGljaCB0byBkZXNlcmlhbGl6ZSBhdHRyaWJ1dGVcbiAgICAqXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAbm9jb2xsYXBzZVxuICAgICovXG4gICBzdGF0aWMgdHlwZUZvclByb3BlcnR5KG5hbWUpIHtcbiAgICAgY29uc3QgaW5mbyA9IHRoaXMuX3Byb3BlcnRpZXNbbmFtZV07XG4gICAgIHJldHVybiBpbmZvICYmIGluZm8udHlwZTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBPdmVycmlkZXMgYFByb3BlcnRpZXNDaGFuZ2VkYCBtZXRob2QgYW5kIGFkZHMgYSBjYWxsIHRvXG4gICAgKiBgZmluYWxpemVgIHdoaWNoIGxhemlseSBjb25maWd1cmVzIHRoZSBlbGVtZW50J3MgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICogQG92ZXJyaWRlXG4gICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICovXG4gICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgIGluY3JlbWVudEluc3RhbmNlQ291bnQoKTtcbiAgICAgdGhpcy5jb25zdHJ1Y3Rvci5maW5hbGl6ZSgpO1xuICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byBhIGRvY3VtZW50LlxuICAgICogQ2FsbHMgYF9lbmFibGVQcm9wZXJ0aWVzYCB0byB0dXJuIG9uIHByb3BlcnR5IHN5c3RlbSBmcm9tXG4gICAgKiBgUHJvcGVydGllc0NoYW5nZWRgLlxuICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gU3VwZXIgbWF5IG9yIG1heSBub3QgaW1wbGVtZW50IHRoZSBjYWxsYmFja1xuICAgICogQHJldHVybiB7dm9pZH1cbiAgICAqIEBvdmVycmlkZVxuICAgICovXG4gICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgaWYgKHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgfVxuICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGEgZG9jdW1lbnRcbiAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IFN1cGVyIG1heSBvciBtYXkgbm90IGltcGxlbWVudCB0aGUgY2FsbGJhY2tcbiAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgKiBAb3ZlcnJpZGVcbiAgICAqL1xuICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgIGlmIChzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgIH1cbiAgIH1cblxuIH1cblxuIHJldHVybiBQcm9wZXJ0aWVzTWl4aW47XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-accessors.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-accessors.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertyAccessors\": () => (/* binding */ PropertyAccessors)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _properties_changed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./properties-changed.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/properties-changed.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nconst nativeProperties = {};\nlet proto = HTMLElement.prototype;\nwhile (proto) {\n  let props = Object.getOwnPropertyNames(proto);\n  for (let i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\nconst isTrustedType = (() => {\n  if (!window.trustedTypes) {\n    return () => false;\n  }\n  return val => trustedTypes.isHTML(val) || trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);\n})();\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    let value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nconst PropertyAccessors = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n  const base = (0,_properties_changed_js__WEBPACK_IMPORTED_MODULE_3__.PropertiesChanged)(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n  class PropertyAccessors extends base {\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     * @nocollapse\n     */\n    static createPropertiesForAttributes() {\n      let a$ = /** @type {?} */this.observedAttributes;\n      for (let i = 0; i < a$.length; i++) {\n        this.prototype._createPropertyAccessor((0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__.dashToCamelCase)(a$[i]));\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_2__.camelToDashCase)(property);\n    }\n\n    /**\n     * Overrides PropertiesChanged implementation to initialize values for\n     * accessors created for values that already existed on the element\n     * prototype.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n        this.__dataProto = null;\n      }\n      super._initializeProperties();\n    }\n\n    /**\n     * Called at instance time with bag of properties that were overwritten\n     * by accessors on the prototype when accessors were created.\n     *\n     * The default implementation sets these properties back into the\n     * setter at instance time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProtoProperties(props) {\n      for (let p in props) {\n        this._setProperty(p, props[p]);\n      }\n    }\n\n    /**\n     * Ensures the element has the given attribute. If it does not,\n     * assigns the given value to the attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n     *     element\n     *\n     * @param {string} attribute Name of attribute to ensure is set.\n     * @param {string} value of the attribute.\n     * @return {void}\n     * @override\n     */\n    _ensureAttribute(attribute, value) {\n      const el = /** @type {!HTMLElement} */this;\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    }\n\n    /**\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided property\n     *     value.\n     * @override\n     */\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            if (isTrustedType(value)) {\n              /**\n               * Here `value` isn't actually a string, but it should be\n               * passed into APIs that normally expect a string, like\n               * elem.setAttribute.\n               */\n              return (/** @type {?} */value\n              );\n            }\n            try {\n              return JSON.stringify(value);\n            } catch (x) {\n              return '';\n            }\n          }\n        default:\n          return super._serializeValue(value);\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called by Polymer when reading HTML attribute values to\n     * JS properties.  Users may override this method on Polymer element\n     * prototypes to provide deserialization for custom `type`s.  Note,\n     * the `type` argument is the value of the `type` field provided in the\n     * `properties` configuration object for a given property, and is\n     * by convention the constructor for the type to deserialize.\n     *\n     *\n     * @param {?string} value Attribute value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */\n      let outValue;\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse( /** @type {string} */value);\n          } catch (x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n          break;\n        case Array:\n          try {\n            outValue = JSON.parse( /** @type {string} */value);\n          } catch (x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n          break;\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n      return outValue;\n    }\n    /* eslint-enable no-fallthrough */\n\n    /**\n     * Overrides PropertiesChanged implementation to save existing prototype\n     * property value so that it can be reset.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     *\n     * When calling on a prototype, any overwritten values are saved in\n     * `__dataProto`, and it is up to the subclasser to decide how/when\n     * to set those properties back into the accessor.  When calling on an\n     * instance, the overwritten value is set via `_setPendingProperty`,\n     * and the user should call `_invalidateProperties` or `_flushProperties`\n     * for the values to take effect.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n      super._definePropertyAccessor(property, readOnly);\n    }\n\n    /**\n     * Returns true if this library created an accessor for the given property.\n     *\n     * @param {string} property Property name\n     * @return {boolean} True if an accessor was created\n     * @override\n     */\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    }\n\n    /**\n     * Returns true if the specified property has a pending change.\n     *\n     * @param {string} prop Property name\n     * @return {boolean} True if property has a pending change\n     * @protected\n     * @override\n     */\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && prop in this.__dataPending);\n    }\n  }\n  return PropertyAccessors;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5qcz9mY2U5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuXG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2hDYXNlLCBkYXNoVG9DYW1lbENhc2UgfSBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0aWVzQ2hhbmdlZCB9IGZyb20gJy4vcHJvcGVydGllcy1jaGFuZ2VkLmpzJztcblxuLy8gU2F2ZSBtYXAgb2YgbmF0aXZlIHByb3BlcnRpZXM7IHRoaXMgZm9ybXMgYSBibGFja2xpc3Qgb3IgcHJvcGVydGllc1xuLy8gdGhhdCB3b24ndCBoYXZlIHRoZWlyIHZhbHVlcyBcInNhdmVkXCIgYnkgYHNhdmVBY2Nlc3NvclZhbHVlYCwgc2luY2Vcbi8vIHJlYWRpbmcgZnJvbSBhbiBIVE1MRWxlbWVudCBhY2Nlc3NvciBmcm9tIHRoZSBjb250ZXh0IG9mIGEgcHJvdG90eXBlIHRocm93c1xuY29uc3QgbmF0aXZlUHJvcGVydGllcyA9IHt9O1xubGV0IHByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xud2hpbGUgKHByb3RvKSB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgZm9yIChsZXQgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmF0aXZlUHJvcGVydGllc1twcm9wc1tpXV0gPSB0cnVlO1xuICB9XG4gIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbn1cblxuY29uc3QgaXNUcnVzdGVkVHlwZSA9ICgoKSA9PiB7XG4gIGlmICghd2luZG93LnRydXN0ZWRUeXBlcykge1xuICAgIHJldHVybiAoKSA9PiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKHZhbCkgPT4gdHJ1c3RlZFR5cGVzLmlzSFRNTCh2YWwpIHx8XG4gICAgICAgIHRydXN0ZWRUeXBlcy5pc1NjcmlwdCh2YWwpIHx8IHRydXN0ZWRUeXBlcy5pc1NjcmlwdFVSTCh2YWwpO1xufSkoKTtcblxuLyoqXG4gKiBVc2VkIHRvIHNhdmUgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aFxuICogYW4gYWNjZXNzb3IuIElmIHRoZSBgbW9kZWxgIGlzIGEgcHJvdG90eXBlLCB0aGUgdmFsdWVzIHdpbGwgYmUgc2F2ZWRcbiAqIGluIGBfX2RhdGFQcm90b2AsIGFuZCBpdCdzIHVwIHRvIHRoZSB1c2VyIChvciBkb3duc3RyZWFtIG1peGluKSB0b1xuICogZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aGVzZSB2YWx1ZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3NvcnMuXG4gKiBJZiBgbW9kZWxgIGlzIGFscmVhZHkgYW4gaW5zdGFuY2UgKGl0IGhhcyBhIGBfX2RhdGFgIHByb3BlcnR5KSwgdGhlblxuICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGFzIGEgcGVuZGluZyBwcm9wZXJ0eSwgbWVhbmluZyB0aGUgdXNlciBzaG91bGRcbiAqIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgIHRvIHRha2UgZWZmZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlQWNjZXNzb3JWYWx1ZShtb2RlbCwgcHJvcGVydHkpIHtcbiAgLy8gRG9uJ3QgcmVhZC9zdG9yZSB2YWx1ZSBmb3IgYW55IG5hdGl2ZSBwcm9wZXJ0aWVzIHNpbmNlIHRoZXkgY291bGQgdGhyb3dcbiAgaWYgKCFuYXRpdmVQcm9wZXJ0aWVzW3Byb3BlcnR5XSkge1xuICAgIGxldCB2YWx1ZSA9IG1vZGVsW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG1vZGVsLl9fZGF0YSkge1xuICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gaW5zdGFuY2U7IHVwZGF0ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gSXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBjYWxsIF9mbHVzaFByb3BlcnRpZXNcbiAgICAgICAgbW9kZWwuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkaW5nIGFjY2Vzc29yIHRvIHByb3RvOyBzYXZlIHByb3RvJ3MgdmFsdWUgZm9yIGluc3RhbmNlLXRpbWUgdXNlXG4gICAgICAgIGlmICghbW9kZWwuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKCFtb2RlbC5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2RhdGFQcm90bycsIG1vZGVsKSkpIHtcbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IE9iamVjdC5jcmVhdGUobW9kZWwuX19kYXRhUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLl9fZGF0YVByb3RvW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyBtZXRhLXByb2dyYW1taW5nIGZvciBjcmVhdGluZyBvbmVcbiAqIG9yIG1vcmUgcHJvcGVydHkgYWNjZXNzb3JzIChnZXR0ZXIvc2V0dGVyIHBhaXIpIHRoYXQgZW5xdWV1ZSBhbiBhc3luY1xuICogKGJhdGNoZWQpIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICpcbiAqIEZvciBiYXNpYyB1c2FnZSBvZiB0aGlzIG1peGluOlxuICpcbiAqIC0gICBEZWNsYXJlIGF0dHJpYnV0ZXMgdG8gb2JzZXJ2ZSB2aWEgdGhlIHN0YW5kYXJkIGBzdGF0aWMgZ2V0XG4gKiAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzKClgLiBVc2UgYGRhc2gtY2FzZWAgYXR0cmlidXRlIG5hbWVzIHRvIHJlcHJlc2VudFxuICogICAgIGBjYW1lbENhc2VgIHByb3BlcnR5IG5hbWVzLlxuICogLSAgIEltcGxlbWVudCB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2sgb24gdGhlIGNsYXNzLlxuICogLSAgIENhbGwgYE15Q2xhc3MuY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMoKWAgKipvbmNlKiogb24gdGhlIGNsYXNzIHRvXG4gKiAgICAgZ2VuZXJhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGZvciBlYWNoIG9ic2VydmVkIGF0dHJpYnV0ZS4gVGhpcyBtdXN0IGJlXG4gKiAgICAgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgaW5zdGFuY2UgaXMgY3JlYXRlZCwgZm9yIGV4YW1wbGUsIGJ5IGNhbGxpbmcgaXRcbiAqICAgICBiZWZvcmUgY2FsbGluZyBgY3VzdG9tRWxlbWVudHMuZGVmaW5lYC4gSXQgY2FuIGFsc28gYmUgY2FsbGVkIGxhemlseSBmcm9tXG4gKiAgICAgdGhlIGVsZW1lbnQncyBgY29uc3RydWN0b3JgLCBhcyBsb25nIGFzIGl0J3MgZ3VhcmRlZCBzbyB0aGF0IHRoZSBjYWxsIGlzXG4gKiAgICAgb25seSBtYWRlIG9uY2UsIHdoZW4gdGhlIGZpcnN0IGluc3RhbmNlIGlzIGNyZWF0ZWQuXG4gKiAtICAgQ2FsbCBgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpYCBpbiB0aGUgZWxlbWVudCdzIGBjb25uZWN0ZWRDYWxsYmFja2AgdG9cbiAqICAgICBlbmFibGUgdGhlIGFjY2Vzc29ycy5cbiAqXG4gKiBBbnkgYG9ic2VydmVkQXR0cmlidXRlc2Agd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gKiBkZXNlcmlhbGl6ZWQgdmlhIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIGFuZCBzZXQgdG8gdGhlIGFzc29jaWF0ZWRcbiAqIHByb3BlcnR5IHVzaW5nIGBkYXNoLWNhc2VgLXRvLWBjYW1lbENhc2VgIGNvbnZlbnRpb24uXG4gKlxuICogQG1peGluRnVuY3Rpb25cbiAqIEBwb2x5bWVyXG4gKiBAYXBwbGllc01peGluIFByb3BlcnRpZXNDaGFuZ2VkXG4gKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIGZvciByZWFjdGluZyB0byBwcm9wZXJ0eSBjaGFuZ2VzIGZyb21cbiAqICAgZ2VuZXJhdGVkIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyBDbGFzcyB0byBhcHBseSBtaXhpbiB0by5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyB3aXRoIG1peGluIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUFjY2Vzc29ycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0aWVzQ2hhbmdlZH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgIGNvbnN0IGJhc2UgPSBQcm9wZXJ0aWVzQ2hhbmdlZChzdXBlckNsYXNzKTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29ycyBleHRlbmRzIGJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHN0YW5kYXJkXG4gICAgICogc3RhdGljIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQXR0cmlidXRlIG5hbWVzIGFyZSBtYXBwZWQgdG8gcHJvcGVydHkgbmFtZXMgdXNpbmcgdGhlIGBkYXNoLWNhc2VgIHRvXG4gICAgICogYGNhbWVsQ2FzZWAgY29udmVudGlvblxuICAgICAqXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0aWVzRm9yQXR0cmlidXRlcygpIHtcbiAgICAgIGxldCBhJCA9ICAvKiogQHR5cGUgez99ICovICh0aGlzKS5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBhJC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlBY2Nlc3NvcihkYXNoVG9DYW1lbENhc2UoYSRbaV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSBuYW1lIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIEJ5IGRlZmF1bHQsIGNvbnZlcnRzIGNhbWVsIHRvIGRhc2ggY2FzZSwgZS5nLiBgZm9vQmFyYCB0byBgZm9vLWJhcmAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEF0dHJpYnV0ZSBuYW1lIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGF0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIFByb3BlcnRpZXNDaGFuZ2VkIGltcGxlbWVudGF0aW9uIHRvIGluaXRpYWxpemUgdmFsdWVzIGZvclxuICAgICAqIGFjY2Vzc29ycyBjcmVhdGVkIGZvciB2YWx1ZXMgdGhhdCBhbHJlYWR5IGV4aXN0ZWQgb24gdGhlIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFQcm90bykge1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHRoaXMuX19kYXRhUHJvdG8pO1xuICAgICAgICB0aGlzLl9fZGF0YVByb3RvID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCBpbnN0YW5jZSB0aW1lIHdpdGggYmFnIG9mIHByb3BlcnRpZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICogYnkgYWNjZXNzb3JzIG9uIHRoZSBwcm90b3R5cGUgd2hlbiBhY2Nlc3NvcnMgd2VyZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgKiBzZXR0ZXIgYXQgaW5zdGFuY2UgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocCwgcHJvcHNbcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIGVsZW1lbnQgaGFzIHRoZSBnaXZlbiBhdHRyaWJ1dGUuIElmIGl0IGRvZXMgbm90LFxuICAgICAqIGFzc2lnbnMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c30gQ2xvc3VyZSBjYW4ndCBmaWd1cmUgb3V0IGB0aGlzYCBpcyBpbmZhY3QgYW5cbiAgICAgKiAgICAgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBlbnN1cmUgaXMgc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICBjb25zdCBlbCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKTtcbiAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoZWwsIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBQcm9wZXJ0aWVzQ2hhbmdlZCBpbXBsZW1lbnRpb24gdG8gc2VyaWFsaXplIG9iamVjdHMgYXMgSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU3RyaW5nIHNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcHJvcGVydHlcbiAgICAgKiAgICAgdmFsdWUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNUcnVzdGVkVHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEhlcmUgYHZhbHVlYCBpc24ndCBhY3R1YWxseSBhIHN0cmluZywgYnV0IGl0IHNob3VsZCBiZVxuICAgICAgICAgICAgICAgKiBwYXNzZWQgaW50byBBUElzIHRoYXQgbm9ybWFsbHkgZXhwZWN0IGEgc3RyaW5nLCBsaWtlXG4gICAgICAgICAgICAgICAqIGVsZW0uc2V0QXR0cmlidXRlLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBzdXBlci5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gcmVhZGluZyBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMgdG9cbiAgICAgKiBKUyBwcm9wZXJ0aWVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIG9uIFBvbHltZXIgZWxlbWVudFxuICAgICAqIHByb3RvdHlwZXMgdG8gcHJvdmlkZSBkZXNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSBgdHlwZWBzLiAgTm90ZSxcbiAgICAgKiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgYHR5cGVgIGZpZWxkIHByb3ZpZGVkIGluIHRoZVxuICAgICAqIGBwcm9wZXJ0aWVzYCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYSBnaXZlbiBwcm9wZXJ0eSwgYW5kIGlzXG4gICAgICogYnkgY29udmVudGlvbiB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0geyo9fSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0by5cbiAgICAgKiBAcmV0dXJuIHsqfSBUeXBlZCB2YWx1ZSBkZXNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICovXG4gICAgICBsZXQgb3V0VmFsdWU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUge3N0cmluZ30gKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IG5vbi1KU09OIGxpdGVyYWxzIGxpa2UgU3RyaW5ncyBhbmQgTnVtYmVyc1xuICAgICAgICAgICAgb3V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUge3N0cmluZ30gKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUG9seW1lcjo6QXR0cmlidXRlczogY291bGRuJ3QgZGVjb2RlIEFycmF5IGFzIEpTT046ICR7dmFsdWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgb3V0VmFsdWUgPSBpc05hTih2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdXRWYWx1ZSA9IG5ldyBEYXRlKG91dFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXRWYWx1ZSA9IHN1cGVyLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRWYWx1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIFByb3BlcnRpZXNDaGFuZ2VkIGltcGxlbWVudGF0aW9uIHRvIHNhdmUgZXhpc3RpbmcgcHJvdG90eXBlXG4gICAgICogcHJvcGVydHkgdmFsdWUgc28gdGhhdCBpdCBjYW4gYmUgcmVzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVhZE9ubHkgV2hlbiB0cnVlLCBubyBzZXR0ZXIgaXMgY3JlYXRlZFxuICAgICAqXG4gICAgICogV2hlbiBjYWxsaW5nIG9uIGEgcHJvdG90eXBlLCBhbnkgb3ZlcndyaXR0ZW4gdmFsdWVzIGFyZSBzYXZlZCBpblxuICAgICAqIGBfX2RhdGFQcm90b2AsIGFuZCBpdCBpcyB1cCB0byB0aGUgc3ViY2xhc3NlciB0byBkZWNpZGUgaG93L3doZW5cbiAgICAgKiB0byBzZXQgdGhvc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uIGFuXG4gICAgICogaW5zdGFuY2UsIHRoZSBvdmVyd3JpdHRlbiB2YWx1ZSBpcyBzZXQgdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YCxcbiAgICAgKiBhbmQgdGhlIHVzZXIgc2hvdWxkIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICogZm9yIHRoZSB2YWx1ZXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KSB7XG4gICAgICBzYXZlQWNjZXNzb3JWYWx1ZSh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICBzdXBlci5fZGVmaW5lUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpYnJhcnkgY3JlYXRlZCBhbiBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGFjY2Vzc29yIHdhcyBjcmVhdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2hhc0FjY2Vzc29yKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHByb3BlcnR5IGhhcyBhIHBlbmRpbmcgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9pc1Byb3BlcnR5UGVuZGluZyhwcm9wKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9fZGF0YVBlbmRpbmcgJiYgKHByb3AgaW4gdGhpcy5fX2RhdGFQZW5kaW5nKSk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvcnM7XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-accessors.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-effects.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-effects.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PropertyEffects\": () => (/* binding */ PropertyEffects)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/wrap.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/* harmony import */ var _utils_path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/path.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/path.js\");\n/* harmony import */ var _utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/case-map.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _property_accessors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./property-accessors.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-accessors.js\");\n/* harmony import */ var _template_stamp_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./template-stamp.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/template-stamp.js\");\n/* harmony import */ var _utils_settings_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/settings.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/settings.js\");\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n/* for notify, reflect */\n\n\n/* for annotated effects */\n\n\n\n// Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\nlet dedupeId = 0;\nconst NOOP = [];\n\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\nconst TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\nconst COMPUTE_INFO = '__computeInfo';\n\n/** @const {!RegExp} */\nconst capitalAttributeRegex = /[A-Z]/;\n\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\nlet DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nlet DataEffect; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\n *   extending a superclass map onto this subclass\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\n  let effects = model[type];\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n    if (cloneArrays) {\n      for (let p in effects) {\n        let protoFx = effects[p];\n        // Perf optimization over Array.slice\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i = 0; i < protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n  }\n  return effects;\n}\n\n// -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {?Object} effects Object map of property-to-Array of effects\n * @param {?Object} props Bag of current property changes\n * @param {?Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    const id = dedupeId++;\n    for (let prop in props) {\n      // Inline `runEffectsForProperty` for perf.\n      let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n      let fxs = effects[rootProperty];\n      if (fxs) {\n        for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n          if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n            if (fx.info) {\n              fx.info.lastRun = id;\n            }\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n            ran = true;\n          }\n        }\n      }\n    }\n    return ran;\n  }\n  return false;\n}\n\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {!Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  let ran = false;\n  let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n  let fxs = effects[rootProperty];\n  if (fxs) {\n    for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n  return ran;\n}\n\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {?DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    let triggerPath = /** @type {string} */trigger.name;\n    return triggerPath == path || !!(trigger.structured && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isAncestor)(triggerPath, path)) || !!(trigger.wildcard && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(triggerPath, path));\n  } else {\n    return true;\n  }\n}\n\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  let changedProp = info.property;\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  let fxs = inst[TYPES.NOTIFY];\n  let notified;\n  let id = dedupeId++;\n  // Try normal notify effects; if none, fall back to try path notification\n  for (let prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  }\n  // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n  let host;\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\nfunction notifyPath(inst, path, props) {\n  let rootProperty = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(path);\n  if (rootProperty !== path) {\n    let eventName = (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} eventName The name of the event to send\n *     ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property\n *     changed, the path that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  let detail = {\n    value: value,\n    queueProperty: true\n  };\n  if (path) {\n    detail.path = path;\n  }\n  // As a performance optimization, we could elide the wrap here since notifying\n  // events are non-bubbling and shouldn't need retargeting. However, a very\n  // small number of internal tests failed in obscure ways, which may indicate\n  // user code relied on timing differences resulting from ShadyDOM flushing\n  // as a result of the wrapped `dispatchEvent`.\n  (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)( /** @type {!HTMLElement} */inst).dispatchEvent(new CustomEvent(eventName, {\n    detail\n  }));\n}\n\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  let rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(property) : property;\n  let path = rootProperty != property ? property : null;\n  let value = path ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, path) : inst.__data[property];\n  if (path && value === undefined) {\n    value = props[property]; // specifically for .splices\n  }\n\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\n *     notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  let value;\n  let detail = /** @type {Object} */event.detail;\n  let fromPath = detail && detail.path;\n  if (fromPath) {\n    toPath = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n  value = negate ? !value : value;\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  let value = inst.__data[property];\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue) {\n    value = (0,_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue)(value, info.attrName, 'attribute', /** @type {Node} */inst);\n  }\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {?Object} changedProps Bag of changed properties\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  let computeEffects = inst[TYPES.COMPUTE];\n  if (computeEffects) {\n    if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.orderedComputed) {\n      // Runs computed effects in efficient order by keeping a topologically-\n      // sorted queue of compute effects to run, and inserting subsequently\n      // invalidated effects as they are run\n      dedupeId++;\n      const order = getComputedOrder(inst);\n      const queue = [];\n      for (let p in changedProps) {\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\n      }\n      let info;\n      while (info = queue.shift()) {\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\n        }\n      }\n      Object.assign( /** @type {!Object} */oldProps, inst.__dataOld);\n      Object.assign( /** @type {!Object} */changedProps, inst.__dataPending);\n      inst.__dataPending = null;\n    } else {\n      // Original Polymer 2.x computed effects order, which continues running\n      // effects until no further computed properties have been invalidated\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign( /** @type {!Object} */oldProps, inst.__dataOld);\n        Object.assign( /** @type {!Object} */changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n}\n\n/**\n * Inserts a computed effect into a queue, given the specified order. Performs\n * the insert using a binary search.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {Object} info Property effects metadata\n * @param {Array<Object>} queue Ordered queue of effects\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n */\nconst insertEffect = (info, queue, order) => {\n  let start = 0;\n  let end = queue.length - 1;\n  let idx = -1;\n  while (start <= end) {\n    const mid = start + end >> 1;\n    // Note `methodInfo` is where the computed property name is stored in\n    // the effect metadata\n    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\n    if (cmp < 0) {\n      start = mid + 1;\n    } else if (cmp > 0) {\n      end = mid - 1;\n    } else {\n      idx = mid;\n      break;\n    }\n  }\n  if (idx < 0) {\n    idx = end + 1;\n  }\n  queue.splice(idx, 0, info);\n};\n\n/**\n * Inserts all downstream computed effects invalidated by the specified property\n * into the topologically-sorted queue of effects to be run.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {string} prop Property name\n * @param {Object} computeEffects Computed effects for this element\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\n *   to be run\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\n */\nconst enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {\n  const rootProperty = hasPaths ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(prop) : prop;\n  const fxs = computeEffects[rootProperty];\n  if (fxs) {\n    for (let i = 0; i < fxs.length; i++) {\n      const fx = fxs[i];\n      if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        fx.info.lastRun = dedupeId;\n        insertEffect(fx.info, queue, order);\n      }\n    }\n  }\n};\n\n/**\n * Generates and retrieves a memoized map of computed property name to its\n * topologically-sorted order.\n *\n * The map is generated by first assigning a \"dependency count\" to each property\n * (defined as number properties it depends on, including its method for\n * \"dynamic functions\"). Any properties that have no dependencies are added to\n * the `ready` queue, which are properties whose order can be added to the final\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\n * the next property in the order map, and b.) each property that it is a\n * dependency for has its dep count decremented (and if that property's dep\n * count goes to zero, it is added to the `ready` queue), until all properties\n * have been visited and ordered.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\n *   effect order for.\n * @return {Map<string,number>} Map of computed property name->topological sort\n *   order\n */\nfunction getComputedOrder(inst) {\n  let ordered = inst.constructor.__orderedComputedDeps;\n  if (!ordered) {\n    ordered = new Map();\n    const effects = inst[TYPES.COMPUTE];\n    let {\n      counts,\n      ready,\n      total\n    } = dependencyCounts(inst);\n    let curr;\n    while (curr = ready.shift()) {\n      ordered.set(curr, ordered.size);\n      const computedByCurr = effects[curr];\n      if (computedByCurr) {\n        computedByCurr.forEach(fx => {\n          // Note `methodInfo` is where the computed property name is stored\n          const computedProp = fx.info.methodInfo;\n          --total;\n          if (--counts[computedProp] === 0) {\n            ready.push(computedProp);\n          }\n        });\n      }\n    }\n    if (total !== 0) {\n      const el = /** @type {HTMLElement} */inst;\n      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);\n    }\n    inst.constructor.__orderedComputedDeps = ordered;\n  }\n  return ordered;\n}\n\n/**\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\n * count\" is the number of dependencies a given property has assuming it is a\n * computed property, otherwise 0).  It also returns a pre-populated list of\n * `ready` properties that have no dependencies and a `total` count, which is\n * used for error-checking the graph.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\n *   counts for.\n * @return {!Object} Object containing `counts` map (property-to-dependency\n *   count) and pre-populated `ready` array of properties that had zero\n *   dependencies.\n */\nfunction dependencyCounts(inst) {\n  const infoForComputed = inst[COMPUTE_INFO];\n  const counts = {};\n  const computedDeps = inst[TYPES.COMPUTE];\n  const ready = [];\n  let total = 0;\n  // Count dependencies for each computed property\n  for (let p in infoForComputed) {\n    const info = infoForComputed[p];\n    // Be sure to add the method name itself in case of \"dynamic functions\"\n    total += counts[p] = info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);\n  }\n  // Build list of ready properties (that aren't themselves computed)\n  for (let p in computedDeps) {\n    if (!infoForComputed[p]) {\n      ready.push(p);\n    }\n  }\n  return {\n    counts,\n    ready,\n    total\n  };\n}\n\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {?Object} changedProps Bag of current property changes\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {boolean} True when the property being computed changed\n * @private\n */\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\n  // Dirty check dependencies and run if any invalid\n  let result = runMethodEffect(inst, property, changedProps, oldProps, info);\n  // Abort if method returns a no-op result\n  if (result === NOOP) {\n    return false;\n  }\n  let computedProp = info.methodInfo;\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    return inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n    return false;\n  }\n}\n\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\n * @param {string} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\nfunction computeLinkedPaths(inst, path, value) {\n  let links = inst.__dataLinkedPaths;\n  if (links) {\n    let link;\n    for (let a in links) {\n      let b = links[a];\n      if ((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(a, path)) {\n        link = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(a, b, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if ((0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(b, path)) {\n        link = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(b, a, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n}\n\n// -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  let /** Binding */binding = {\n    kind,\n    target,\n    parts,\n    literal,\n    isCompound: parts.length !== 1\n  };\n  nodeInfo.bindings.push(binding);\n  // Add listener info to binding metadata\n  if (shouldAddListener(binding)) {\n    let {\n      event,\n      negate\n    } = binding.parts[0];\n    binding.listenerEvent = event || (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(target) + '-changed';\n    binding.listenerNegate = negate;\n  }\n  // Add \"propagate\" property effects to templateInfo\n  let index = templateInfo.nodeInfoList.length;\n  for (let i = 0; i < binding.parts.length; i++) {\n    let part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n    } else {\n      let dependencies = part.dependencies;\n      let info = {\n        index,\n        binding,\n        part,\n        evaluator: constructor\n      };\n      for (let j = 0; j < dependencies.length; j++) {\n        let trigger = dependencies[j];\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info,\n          trigger\n        });\n      }\n    }\n  }\n}\n\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  let node = nodeList[info.index];\n  let binding = info.binding;\n  let part = info.part;\n  // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    let value = props[path];\n    path = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.translate)(part.source, binding.target, path);\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n    // Propagate value to child\n    // Abort if value is a no-op result\n    if (value !== NOOP) {\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n}\n\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue) {\n    value = (0,_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.sanitizeDOMValue)(value, binding.target, binding.kind, node);\n  }\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);\n  } else {\n    // Property binding\n    let prop = binding.target;\n    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      // In legacy no-batching mode, bindings applied before dataReady are\n      // equivalent to the \"apply config\" phase, which only set managed props\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    let storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {\n      value = value == undefined ? '' : value;\n    }\n  }\n  return value;\n}\n\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n}\n\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\n *     bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  let {\n    nodeList,\n    nodeInfoList\n  } = templateInfo;\n  if (nodeInfoList.length) {\n    for (let i = 0; i < nodeInfoList.length; i++) {\n      let info = nodeInfoList[i];\n      let node = nodeList[i];\n      let bindings = info.bindings;\n      if (bindings) {\n        for (let i = 0; i < bindings.length; i++) {\n          let binding = bindings[i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n      // This ensures all bound elements have a host set, regardless\n      // of whether they upgrade synchronous to creation\n      node.__dataHost = inst;\n    }\n  }\n}\n\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n    let parts = binding.parts;\n    // Copy literals from parts into storage for this binding\n    let literals = new Array(parts.length);\n    for (let j = 0; j < parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n    let target = binding.target;\n    storage[target] = literals;\n    // Configure properties with their literal parts\n    if (binding.literal && binding.kind == 'property') {\n      // Note, className needs style scoping so this needs wrapping.\n      // We may also want to consider doing this for `textContent` and\n      // `innerHTML`.\n      if (target === 'className') {\n        node = (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node);\n      }\n      node[target] = binding.literal;\n    }\n  }\n}\n\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\n *     notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    let part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function (e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n}\n\n// -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {!Object} Effect metadata for this method effect\n * @private\n */\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);\n  let info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo,\n    dynamicFn\n  };\n  for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn,\n        info: info,\n        trigger: arg\n      });\n    }\n  }\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn,\n      info: info\n    });\n  }\n  return info;\n}\n\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  let context = inst._methodHost || inst;\n  let fn = context[info.methodName];\n  if (fn) {\n    let args = inst._marshalArgs(info.args, property, props);\n    return args === NOOP ? NOOP : fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\nconst emptyArray = [];\n\n// Regular expressions used for binding\nconst IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nconst CLOSE_BRACKET = '(?:]]|}})';\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nconst bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\nfunction literalFromParts(parts) {\n  let s = '';\n  for (let i = 0; i < parts.length; i++) {\n    let literal = parts[i].literal;\n    s += literal || '';\n  }\n  return s;\n}\n\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (m) {\n    let methodName = m[1];\n    let sig = {\n      methodName,\n      static: true,\n      args: emptyArray\n    };\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n  return null;\n}\n\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function (rawArg) {\n    let arg = parseArg(rawArg);\n    if (!arg.literal) {\n      sig.static = false;\n    }\n    return arg;\n  }, this);\n  return sig;\n}\n\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  let arg = rawArg.trim()\n  // replace comma entity with comma\n  .replace(/&comma;/g, ',')\n  // repair extra escape sequences; note only commas strictly need\n  // escaping, but we allow any other char to be escaped since its\n  // likely users will do this\n  .replace(/\\\\(.)/g, '$1');\n  // basic argument descriptor\n  let a = {\n    name: arg,\n    value: '',\n    literal: false\n  };\n  // detect literal value (must be String or Number)\n  let fc = arg[0];\n  if (fc === '-') {\n    fc = arg[1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch (fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  }\n  // if not literal, look for structured path\n  if (!a.literal) {\n    a.rootProperty = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(arg);\n    // detect structured path (has dots)\n    a.structured = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(arg);\n    if (a.structured) {\n      a.wildcard = arg.slice(-2) == '.*';\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n  return a;\n}\nfunction getArgValue(data, props, path) {\n  let value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(data, path);\n  // when data is not stored e.g. `splices`, get the value from changedProps\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\n  // info.value could pull a stale value out of changedProps during a reentrant\n  // change that sets the value back to undefined.\n  // https://github.com/Polymer/polymer/issues/5479\n  if (value === undefined) {\n    value = props[path];\n  }\n  return value;\n}\n\n// data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\nfunction notifySplices(inst, array, path, splices) {\n  const splicesData = {\n    indexSplices: splices\n  };\n  // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\n  // To match this behavior, we store splices directly on the array.\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !inst._overrideLegacyUndefined) {\n    array.splices = splicesData;\n  }\n  inst.notifyPath(path + '.splices', splicesData);\n  inst.notifyPath(path + '.length', array.length);\n  // Clear splice data only when it's stored on the array.\n  if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !inst._overrideLegacyUndefined) {\n    splicesData.indexSplices = [];\n  }\n}\n\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\nconst PropertyEffects = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_2__.dedupingMixin)(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  const propertyEffectsBase = (0,_template_stamp_js__WEBPACK_IMPORTED_MODULE_6__.TemplateStamp)((0,_property_accessors_js__WEBPACK_IMPORTED_MODULE_5__.PropertyAccessors)(superClass));\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n  class PropertyEffects extends propertyEffectsBase {\n    constructor() {\n      super();\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n      this.__isPropertyEffectsClient = true;\n      /** @type {boolean} */\n      this.__dataClientsReady;\n      /** @type {Array} */\n      this.__dataPendingClients;\n      /** @type {Object} */\n      this.__dataToNotify;\n      /** @type {Object} */\n      this.__dataLinkedPaths;\n      /** @type {boolean} */\n      this.__dataHasPaths;\n      /** @type {Object} */\n      this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n      this.__dataHost;\n      /** @type {!Object} */\n      this.__dataTemp;\n      /** @type {boolean} */\n      this.__dataClientsInitialized;\n      /** @type {!Object} */\n      this.__data;\n      /** @type {!Object|null} */\n      this.__dataPending;\n      /** @type {!Object} */\n      this.__dataOld;\n      /** @type {Object} */\n      this.__computeEffects;\n      /** @type {Object} */\n      this.__computeInfo;\n      /** @type {Object} */\n      this.__reflectEffects;\n      /** @type {Object} */\n      this.__notifyEffects;\n      /** @type {Object} */\n      this.__propagateEffects;\n      /** @type {Object} */\n      this.__observeEffects;\n      /** @type {Object} */\n      this.__readOnly;\n      /** @type {!TemplateInfo} */\n      this.__templateInfo;\n      /** @type {boolean} */\n      this._overrideLegacyUndefined;\n    }\n    get PROPERTY_EFFECT_TYPES() {\n      return TYPES;\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n    _initializeProperties() {\n      super._initializeProperties();\n      this._registerHost();\n      this.__dataClientsReady = false;\n      this.__dataPendingClients = null;\n      this.__dataToNotify = null;\n      this.__dataLinkedPaths = null;\n      this.__dataHasPaths = false;\n      // May be set on instance prior to upgrade\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n      this.__dataHost = this.__dataHost || null;\n      this.__dataTemp = {};\n      this.__dataClientsInitialized = false;\n    }\n    _registerHost() {\n      if (hostStack.length) {\n        let host = hostStack[hostStack.length - 1];\n        host._enqueueClient(this);\n        // This ensures even non-bound elements have a host set, as\n        // long as they upgrade synchronously\n        this.__dataHost = host;\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to provide a\n     * more efficient implementation of initializing properties from\n     * the prototype on the instance.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the prototype\n     * @return {void}\n     */\n    _initializeProtoProperties(props) {\n      this.__data = Object.create(props);\n      this.__dataPending = Object.create(props);\n      this.__dataOld = {};\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to avoid setting\n     * `_setProperty`'s `shouldNotify: true`.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the instance\n     * @return {void}\n     */\n    _initializeInstanceProperties(props) {\n      let readOnly = this[TYPES.READ_ONLY];\n      for (let prop in props) {\n        if (!readOnly || !readOnly[prop]) {\n          this.__dataPending = this.__dataPending || {};\n          this.__dataOld = this.__dataOld || {};\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\n        }\n      }\n    }\n\n    // Prototype setup ----------------------------------------\n\n    /**\n     * Equivalent to static `addPropertyEffect` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n    _addPropertyEffect(property, type, effect) {\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n      // effects are accumulated into arrays per property based on type\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      if (!effects) {\n        effects = this[type][property] = [];\n      }\n      effects.push(effect);\n    }\n\n    /**\n     * Removes the given property effect.\n     *\n     * @override\n     * @param {string} property Property the effect was associated with\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object to remove\n     * @return {void}\n     */\n    _removePropertyEffect(property, type, effect) {\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      let idx = effects.indexOf(effect);\n      if (idx >= 0) {\n        effects.splice(idx, 1);\n      }\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a property effect\n     * of a certain type.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasPropertyEffect(property, type) {\n      let effects = this[type];\n      return Boolean(effects && effects[property]);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"read only\"\n     * accessor for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReadOnlyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"notify\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasNotifyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"reflect to\n     * attribute\" property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReflectEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"computed\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasComputedEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\n    }\n\n    // Runtime ----------------------------------------\n\n    /**\n     * Sets a pending property or path.  If the root property of the path in\n     * question had no accessor, the path is set, otherwise it is enqueued\n     * via `_setPendingProperty`.\n     *\n     * This function isolates relatively expensive functionality necessary\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\n     * change listeners via {{...}} bindings), such that it is only done\n     * when paths enter the system, and not at every propagation step.  It\n     * also sets a `__dataHasPaths` flag on the instance which is used to\n     * fast-path slower path-matching code in the property effects host paths.\n     *\n     * `path` can be a path string or array of path parts as accepted by the\n     * public API.\n     *\n     * @override\n     * @param {string | !Array<number|string>} path Path to set\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify Set to true if this change should\n     *  cause a property notification event dispatch\n     * @param {boolean=} isPathNotification If the path being set is a path\n     *   notification of an already changed value, as opposed to a request\n     *   to set and notify the change.  In the latter `false` case, a dirty\n     *   check is performed and then the value is set to the path before\n     *   enqueuing the pending property change.\n     * @return {boolean} Returns true if the property/path was enqueued in\n     *   the pending changes bag.\n     * @protected\n     */\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n      if (isPathNotification || (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.root)(Array.isArray(path) ? path[0] : path) !== path) {\n        // Dirty check changes being set to a path against the actual object,\n        // since this is the entry point for paths into the system; from here\n        // the only dirty checks are against the `__dataTemp` cache to prevent\n        // duplicate work in the same turn only. Note, if this was a notification\n        // of a change already set to a path (isPathNotification: true),\n        // we always let the change through and skip the `set` since it was\n        // already dirty checked at the point of entry and the underlying\n        // object has already been updated\n        if (!isPathNotification) {\n          let old = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path);\n          path = /** @type {string} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.set)(this, path, value);\n          // Use property-accessor's simpler dirty check\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\n            return false;\n          }\n        }\n        this.__dataHasPaths = true;\n        if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {\n          computeLinkedPaths(this, /**@type{string}*/path, value);\n          return true;\n        }\n      } else {\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n          return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);\n        } else {\n          this[path] = value;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Applies a value to a non-Polymer element/node's property.\n     *\n     * The implementation makes a best-effort at binding interop:\n     * Some native element properties have side-effects when\n     * re-setting the same value (e.g. setting `<input>.value` resets the\n     * cursor position), so we do a dirty-check before setting the value.\n     * However, for better interop with non-Polymer custom elements that\n     * accept objects, we explicitly re-set object changes coming from the\n     * Polymer world (which may include deep object changes without the\n     * top reference changing), erring on the side of providing more\n     * information.\n     *\n     * Users may override this method to provide alternate approaches.\n     *\n     * @override\n     * @param {!Node} node The node to set a property on\n     * @param {string} prop The property to set\n     * @param {*} value The value to set\n     * @return {void}\n     * @protected\n     */\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      // It is a judgment call that resetting primitives is\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\n      // implement a whitelist of tag & property values that should never\n      // be reset (e.g. <input>.value && <select>.value)\n      if (value !== node[prop] || typeof value == 'object') {\n        // Note, className needs style scoping so this needs wrapping.\n        if (prop === 'className') {\n          node = /** @type {!Node} */(0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node);\n        }\n        node[prop] = value;\n      }\n    }\n\n    /**\n     * Overrides the `PropertiesChanged` implementation to introduce special\n     * dirty check logic depending on the property & value being set:\n     *\n     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n     * 2. Object set to simple property (e.g. 'prop': {...})\n     *    Stored in `__dataTemp` and `__data`, dirty checked against\n     *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n     * 3. Primitive value set to simple property (e.g. 'prop': 42)\n     *    Stored in `__data`, dirty checked against `__data`\n     *\n     * The dirty-check is important to prevent cycles due to two-way\n     * notification, but paths and objects are only dirty checked against any\n     * previous value set during this turn via a \"temporary cache\" that is\n     * cleared when the last `_propertiesChanged` exits. This is so:\n     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n     *    due to array mutations like shift/unshift/splice; this is fine\n     *    since path changes are dirty-checked at user entry points like `set`\n     * b. dirty-checking for objects only lasts one turn to allow the user\n     *    to mutate the object in-place and re-set it with the same identity\n     *    and have all sub-properties re-propagated in a subsequent turn.\n     *\n     * The temp cache is not necessarily sufficient to prevent invalid array\n     * paths, since a splice can happen during the same turn (with pathological\n     * user code); we could introduce a \"fixup\" for temporarily cached array\n     * paths if needed: https://github.com/Polymer/polymer/issues/4227\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify True if property should fire notification\n     *   event (applies only for `notify: true` properties)\n     * @return {boolean} Returns true if the property changed\n     */\n    _setPendingProperty(property, value, shouldNotify) {\n      let propIsPath = this.__dataHasPaths && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(property);\n      let prevProps = propIsPath ? this.__dataTemp : this.__data;\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (!(property in this.__dataOld)) {\n          this.__dataOld[property] = this.__data[property];\n        }\n        // Paths are stored in temporary cache (cleared at end of turn),\n        // which is used for dirty-checking, all others stored in __data\n        if (propIsPath) {\n          this.__dataTemp[property] = value;\n        } else {\n          this.__data[property] = value;\n        }\n        // All changes go into pending property bag, passed to _propertiesChanged\n        this.__dataPending[property] = value;\n        // Track properties that should notify separately\n        if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n          this.__dataToNotify = this.__dataToNotify || {};\n          this.__dataToNotify[property] = shouldNotify;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Overrides base implementation to ensure all accessors set `shouldNotify`\n     * to true, for per-property notification tracking.\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessor`'s default async queuing of\n     * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n     * manually flushed), the function no-ops; otherwise flushes\n     * `_propertiesChanged` synchronously.\n     *\n     * @override\n     * @return {void}\n     */\n    _invalidateProperties() {\n      if (this.__dataReady) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Enqueues the given client on a list of pending clients, whose\n     * pending property changes can later be flushed via a call to\n     * `_flushClients`.\n     *\n     * @override\n     * @param {Object} client PropertyEffects client to enqueue\n     * @return {void}\n     * @protected\n     */\n    _enqueueClient(client) {\n      this.__dataPendingClients = this.__dataPendingClients || [];\n      if (client !== this) {\n        this.__dataPendingClients.push(client);\n      }\n    }\n\n    /**\n     * Flushes any clients previously enqueued via `_enqueueClient`, causing\n     * their `_flushProperties` method to run.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _flushClients() {\n      if (!this.__dataClientsReady) {\n        this.__dataClientsReady = true;\n        this._readyClients();\n        // Override point where accessors are turned on; importantly,\n        // this is after clients have fully readied, providing a guarantee\n        // that any property effects occur only after all clients are ready.\n        this.__dataReady = true;\n      } else {\n        this.__enableOrFlushClients();\n      }\n    }\n\n    // NOTE: We ensure clients either enable or flush as appropriate. This\n    // handles two corner cases:\n    // (1) clients flush properly when connected/enabled before the host\n    // enables; e.g.\n    //   (a) Templatize stamps with no properties and does not flush and\n    //   (b) the instance is inserted into dom and\n    //   (c) then the instance flushes.\n    // (2) clients enable properly when not connected/enabled when the host\n    // flushes; e.g.\n    //   (a) a template is runtime stamped and not yet connected/enabled\n    //   (b) a host sets a property, causing stamped dom to flush\n    //   (c) the stamped dom enables.\n    __enableOrFlushClients() {\n      let clients = this.__dataPendingClients;\n      if (clients) {\n        this.__dataPendingClients = null;\n        for (let i = 0; i < clients.length; i++) {\n          let client = clients[i];\n          if (!client.__dataEnabled) {\n            client._enableProperties();\n          } else if (client.__dataPending) {\n            client._flushProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Perform any initial setup on client dom. Called before the first\n     * `_flushProperties` call on client dom and before any element\n     * observers are called.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _readyClients() {\n      this.__enableOrFlushClients();\n    }\n\n    /**\n     * Sets a bag of property changes to this instance, and\n     * synchronously processes all effects of the properties as a batch.\n     *\n     * Property names must be simple properties, not paths.  Batched\n     * path propagation is not supported.\n     *\n     * @override\n     * @param {Object} props Bag of one or more key-value pairs whose key is\n     *   a property and value is the new value to set for that property.\n     * @param {boolean=} setReadOnly When true, any private values set in\n     *   `props` will be set. By default, `setProperties` will not set\n     *   `readOnly: true` root properties.\n     * @return {void}\n     * @public\n     */\n    setProperties(props, setReadOnly) {\n      for (let path in props) {\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\n          // wildcard observers currently only pass the first changed path\n          // in the `info` object, and you could do some odd things batching\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\n          this._setPendingPropertyOrPath(path, props[path], true);\n        }\n      }\n      this._invalidateProperties();\n    }\n\n    /**\n     * Overrides `PropertyAccessors` so that property accessor\n     * side effects are not enabled until after client dom is fully ready.\n     * Also calls `_flushClients` callback to ensure client dom is enabled\n     * that was not enabled as a result of flushing properties.\n     *\n     * @override\n     * @return {void}\n     */\n    ready() {\n      // It is important that `super.ready()` is not called here as it\n      // immediately turns on accessors. Instead, we wait until `readyClients`\n      // to enable accessors to provide a guarantee that clients are ready\n      // before processing any accessors side effects.\n      this._flushProperties();\n      // If no data was pending, `_flushProperties` will not `flushClients`\n      // so ensure this is done.\n      if (!this.__dataClientsReady) {\n        this._flushClients();\n      }\n      // Before ready, client notifications do not trigger _flushProperties.\n      // Therefore a flush is necessary here if data has been set.\n      if (this.__dataPending) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Implements `PropertyAccessors`'s properties changed callback.\n     *\n     * Runs each class of effects for the batch of changed properties in\n     * a specific order (compute, propagate, reflect, observe, notify).\n     *\n     * @override\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {\n      // ----------------------------\n      // let c = Object.getOwnPropertyNames(changedProps || {});\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n      // if (window.debug) { debugger; }\n      // ----------------------------\n      let hasPaths = this.__dataHasPaths;\n      this.__dataHasPaths = false;\n      let notifyProps;\n      // Compute properties\n      runComputedEffects(this, changedProps, oldProps, hasPaths);\n      // Clear notify properties prior to possible reentry (propagate, observe),\n      // but after computing effects have a chance to add to them\n      notifyProps = this.__dataToNotify;\n      this.__dataToNotify = null;\n      // Propagate properties to clients\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n      // Flush clients\n      this._flushClients();\n      // Reflect properties\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n      // Observe properties\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n      // Notify properties to host\n      if (notifyProps) {\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n      }\n      // Clear temporary cache at end of turn\n      if (this.__dataCounter == 1) {\n        this.__dataTemp = {};\n      }\n      // ----------------------------\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n      // ----------------------------\n    }\n\n    /**\n     * Called to propagate any property changes to stamped template nodes\n     * managed by this element.\n     *\n     * @override\n     * @param {Object} changedProps Bag of changed properties\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {void}\n     * @protected\n     */\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n      if (this[TYPES.PROPAGATE]) {\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n      }\n      if (this.__templateInfo) {\n        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\n      }\n    }\n    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\n      const baseRunEffects = (changedProps, hasPaths) => {\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n        for (let info = templateInfo.firstChild; info; info = info.nextSibling) {\n          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\n        }\n      };\n      if (templateInfo.runEffects) {\n        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\n      } else {\n        baseRunEffects(changedProps, hasPaths);\n      }\n    }\n\n    /**\n     * Aliases one data path as another, such that path notifications from one\n     * are routed to the other.\n     *\n     * @override\n     * @param {string | !Array<string|number>} to Target path to link.\n     * @param {string | !Array<string|number>} from Source path to link.\n     * @return {void}\n     * @public\n     */\n    linkPaths(to, from) {\n      to = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(to);\n      from = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(from);\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n      this.__dataLinkedPaths[to] = from;\n    }\n\n    /**\n     * Removes a data path alias previously established with `_linkPaths`.\n     *\n     * Note, the path to unlink should be the target (`to`) used when\n     * linking the paths.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Target path to unlink.\n     * @return {void}\n     * @public\n     */\n    unlinkPaths(path) {\n      path = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(path);\n      if (this.__dataLinkedPaths) {\n        delete this.__dataLinkedPaths[path];\n      }\n    }\n\n    /**\n     * Notify that an array has changed.\n     *\n     * Example:\n     *\n     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n     *     ...\n     *     this.items.splice(1, 1, {name: 'Sam'});\n     *     this.items.push({name: 'Bob'});\n     *     this.notifySplices('items', [\n     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\n     *         object: this.items, type: 'splice' },\n     *       { index: 3, removed: [], addedCount: 1,\n     *         object: this.items, type: 'splice'}\n     *     ]);\n     *\n     * @param {string} path Path that should be notified.\n     * @param {Array} splices Array of splice records indicating ordered\n     *   changes that occurred to the array. Each record should have the\n     *   following fields:\n     *    * index: index at which the change occurred\n     *    * removed: array of items that were removed from this index\n     *    * addedCount: number of new items added at this index\n     *    * object: a reference to the array in question\n     *    * type: the string literal 'splice'\n     *\n     *   Note that splice records _must_ be normalized such that they are\n     *   reported in index order (raw results from `Object.observe` are not\n     *   ordered and must be normalized/merged before notifying).\n     *\n     * @override\n     * @return {void}\n     * @public\n     */\n    notifySplices(path, splices) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      notifySplices(this, array, info.path, splices);\n    }\n\n    /**\n     * Convenience method for reading a value from a path.\n     *\n     * Note, if any part in the path is undefined, this method returns\n     * `undefined` (this method does not throw when dereferencing undefined\n     * paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n     * @param {Object=} root Root object from which the path is evaluated.\n     * @return {*} Value at the path, or `undefined` if any part of the path\n     *   is undefined.\n     * @public\n     */\n    get(path, root) {\n      return (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(root || this, path);\n    }\n\n    /**\n     * Convenience method for setting a value to a path and notifying any\n     * elements bound to the same path.\n     *\n     * Note, if any part in the path except for the last is undefined,\n     * this method does nothing (this method does not throw when\n     * dereferencing undefined paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n     * @param {*} value Value to set at the specified path.\n     * @param {Object=} root Root object from which the path is evaluated.\n     *   When specified, no notification will occur.\n     * @return {void}\n     * @public\n     */\n    set(path, value, root) {\n      if (root) {\n        (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.set)(root, path, value);\n      } else {\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {\n          if (this._setPendingPropertyOrPath(path, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Adds items onto the end of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to push onto array\n     * @return {number} New length of the array.\n     * @public\n     */\n    push(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array}*/(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let len = array.length;\n      let ret = array.push(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, len, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the end of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    pop(path) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.pop();\n      if (hadLength) {\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Starting from the start index specified, removes 0 or more items\n     * from the array and inserts 0 or more new items in their place.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.splice`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {number} start Index from which to start removing/inserting.\n     * @param {number=} deleteCount Number of items to remove.\n     * @param {...*} items Items to insert into array.\n     * @return {!Array} Array of removed items.\n     * @public\n     */\n    splice(path, start, deleteCount, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      // Normalize fancy native splice handling of crazy start values\n      if (start < 0) {\n        start = array.length - Math.floor(-start);\n      } else if (start) {\n        start = Math.floor(start);\n      }\n      // array.splice does different things based on the number of arguments\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n      // do different things. In the former, the whole array is cleared. In the\n      // latter, no items are removed.\n      // This means that we need to detect whether 1. one of the arguments\n      // is actually passed in and then 2. determine how many arguments\n      // we should pass on to the native array.splice\n      //\n      let ret;\n      // Omit any additional arguments if they were not passed in\n      if (arguments.length === 2) {\n        ret = array.splice(start);\n        // Either start was undefined and the others were defined, but in this\n        // case we can safely pass on all arguments\n        //\n        // Note: this includes the case where none of the arguments were passed in,\n        // e.g. this.splice('array'). However, if both start and deleteCount\n        // are undefined, array.splice will not modify the array (as expected)\n      } else {\n        ret = array.splice(start, deleteCount, ...items);\n      }\n      // At the end, check whether any items were passed in (e.g. insertions)\n      // or if the return array contains items (e.g. deletions).\n      // Only notify if items were added or deleted.\n      if (items.length || ret.length) {\n        notifySplice(this, array, info.path, start, items.length, ret);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the beginning of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    shift(path) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.shift();\n      if (hadLength) {\n        notifySplice(this, array, info.path, 0, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Adds items onto the beginning of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to insert info array\n     * @return {number} New length of the array.\n     * @public\n     */\n    unshift(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */(0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n      let ret = array.unshift(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, 0, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Notify that a path has changed.\n     *\n     * Example:\n     *\n     *     this.item.user.name = 'Bob';\n     *     this.notifyPath('item.user.name');\n     *\n     * @override\n     * @param {string} path Path that should be notified.\n     * @param {*=} value Value at the path (optional).\n     * @return {void}\n     * @public\n     */\n    notifyPath(path, value) {\n      /** @type {string} */\n      let propPath;\n      if (arguments.length == 1) {\n        // Get value if not supplied\n        let info = {\n          path: ''\n        };\n        value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(this, path, info);\n        propPath = info.path;\n      } else if (Array.isArray(path)) {\n        // Normalize path if needed\n        propPath = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.normalize)(path);\n      } else {\n        propPath = /** @type{string} */path;\n      }\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Equivalent to static `createReadOnlyProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     */\n    _createReadOnlyProperty(property, protectedSetter) {\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\n      if (protectedSetter) {\n        this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {\n          this._setProperty(property, value);\n        };\n      }\n    }\n\n    /**\n     * Equivalent to static `createPropertyObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method\n     *     to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createPropertyObserver(property, method, dynamicFn) {\n      let info = {\n        property,\n        method,\n        dynamicFn: Boolean(dynamicFn)\n      };\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\n        fn: runObserverEffect,\n        info,\n        trigger: {\n          name: property\n        }\n      });\n      if (dynamicFn) {\n        this._addPropertyEffect( /** @type {string} */method, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info,\n          trigger: {\n            name: method\n          }\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createMethodObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createMethodObserver(expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n      }\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n    }\n\n    /**\n     * Equivalent to static `createNotifyingProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     */\n    _createNotifyingProperty(property) {\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\n        fn: runNotifyEffect,\n        info: {\n          eventName: (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.camelToDashCase)(property) + '-changed',\n          property: property\n        }\n      });\n    }\n\n    /**\n     * Equivalent to static `createReflectedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _createReflectedProperty(property) {\n      let attr = this.constructor.attributeNameForProperty(property);\n      if (attr[0] === '-') {\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n      } else {\n        this._addPropertyEffect(property, TYPES.REFLECT, {\n          fn: runReflectEffect,\n          info: {\n            attrName: attr\n          }\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createComputedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createComputedProperty(property, expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n      }\n      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      // Effects are normally stored as map of dependency->effect, but for\n      // ordered computation, we also need tree of computedProp->dependencies\n      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\n    }\n\n    /**\n     * Gather the argument values for a method specified in the provided array\n     * of argument metadata.\n     *\n     * The `path` and `value` arguments are used to fill in wildcard descriptor\n     * when the method is being called as a result of a path notification.\n     *\n     * @param {!Array<!MethodArg>} args Array of argument metadata\n     * @param {string} path Property/path name that triggered the method effect\n     * @param {Object} props Bag of current property changes\n     * @return {!Array<*>} Array of argument values\n     * @private\n     */\n    _marshalArgs(args, path, props) {\n      const data = this.__data;\n      const values = [];\n      for (let i = 0, l = args.length; i < l; i++) {\n        let {\n          name,\n          structured,\n          wildcard,\n          value,\n          literal\n        } = args[i];\n        if (!literal) {\n          if (wildcard) {\n            const matches = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isDescendant)(name, path);\n            const pathValue = getArgValue(data, props, matches ? path : name);\n            value = {\n              path: matches ? path : name,\n              value: pathValue,\n              base: matches ? (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(data, name) : pathValue\n            };\n          } else {\n            value = structured ? getArgValue(data, props, name) : data[name];\n          }\n        }\n        // When the `legacyUndefined` flag is enabled, pass a no-op value\n        // so that the observer, computed property, or compound binding is aborted.\n        if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\n          return NOOP;\n        }\n        values[i] = value;\n      }\n      return values;\n    }\n\n    // -- static class methods ------------\n\n    /**\n     * Ensures an accessor exists for the specified property, and adds\n     * to a list of \"property effects\" that will run when the accessor for\n     * the specified property is set.  Effects are grouped by \"type\", which\n     * roughly corresponds to a phase in effect processing.  The effect\n     * metadata should be in the following form:\n     *\n     *     {\n     *       fn: effectFunction, // Reference to function to call to perform effect\n     *       info: { ... }       // Effect metadata passed to function\n     *       trigger: {          // Optional triggering metadata; if not provided\n     *         name: string      // the property is treated as a wildcard\n     *         structured: boolean\n     *         wildcard: boolean\n     *       }\n     *     }\n     *\n     * Effects are called from `_propertiesChanged` in the following order by\n     * type:\n     *\n     * 1. COMPUTE\n     * 2. PROPAGATE\n     * 3. REFLECT\n     * 4. OBSERVE\n     * 5. NOTIFY\n     *\n     * Effect functions are called with the following signature:\n     *\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static addPropertyEffect(property, type, effect) {\n      this.prototype._addPropertyEffect(property, type, effect);\n    }\n\n    /**\n     * Creates a single-property observer for the given property.\n     *\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createPropertyObserver(property, method, dynamicFn) {\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\n    }\n\n    /**\n     * Creates a multi-property \"method observer\" based on the provided\n     * expression, which should be a string in the form of a normal JavaScript\n     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n     * should correspond to a property or path in the context of this\n     * prototype (or instance), or may be a literal string or number.\n     *\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     * @return {void}\n     *   whether method names should be included as a dependency to the effect.\n     * @protected\n     * @nocollapse\n     */\n    static createMethodObserver(expression, dynamicFn) {\n      this.prototype._createMethodObserver(expression, dynamicFn);\n    }\n\n    /**\n     * Causes the setter for the given property to dispatch `<property>-changed`\n     * events to notify of changes to the property.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createNotifyingProperty(property) {\n      this.prototype._createNotifyingProperty(property);\n    }\n\n    /**\n     * Creates a read-only accessor for the given property.\n     *\n     * To set the property, use the protected `_setProperty` API.\n     * To create a custom protected setter (e.g. `_setMyProp()` for\n     * property `myProp`), pass `true` for `protectedSetter`.\n     *\n     * Note, if the property will have other property effects, this method\n     * should be called first, before adding other effects.\n     *\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReadOnlyProperty(property, protectedSetter) {\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\n    }\n\n    /**\n     * Causes the setter for the given property to reflect the property value\n     * to a (dash-cased) attribute of the same name.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReflectedProperty(property) {\n      this.prototype._createReflectedProperty(property);\n    }\n\n    /**\n     * Creates a computed property whose value is set to the result of the\n     * method described by the given `expression` each time one or more\n     * arguments to the method changes.  The expression should be a string\n     * in the form of a normal JavaScript function signature:\n     * `'methodName(arg1, [..., argn])'`\n     *\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n     *   method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createComputedProperty(property, expression, dynamicFn) {\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\n    }\n\n    /**\n     * Parses the provided template to ensure binding effects are created\n     * for them, and then ensures property accessors are created for any\n     * dependent properties in the template.  Binding effects for bound\n     * templates are stored in a linked list on the instance so that\n     * templates can be efficiently stamped and unstamped.\n     *\n     * @param {!HTMLTemplateElement} template Template containing binding\n     *   bindings\n     * @return {!TemplateInfo} Template metadata object\n     * @protected\n     * @nocollapse\n     */\n    static bindTemplate(template) {\n      return this.prototype._bindTemplate(template);\n    }\n\n    // -- binding ----------------------------------------------\n\n    /*\n     * Overview of binding flow:\n     *\n     * During finalization (`instanceBinding==false`, `wasPreBound==false`):\n     *  `_bindTemplate(t, false)` called directly during finalization - parses\n     *  the template (for the first time), and then assigns that _prototypical_\n     *  template info to `__preboundTemplateInfo` _on the prototype_; note in\n     *  this case `wasPreBound` is false; this is the first time we're binding\n     *  it, thus we create accessors.\n     *\n     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\n     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\n     *   returned matches the prebound one, and so this is `wasPreBound == true`\n     *   state; thus we _skip_ creating accessors, but _do_ create an instance\n     *   of the template info to serve as the start of our linked list (needs to\n     *   be an instance, not the prototypical one, so that we can add `nodeList`\n     *   to it to contain the `nodeInfo`-ordered list of instance nodes for\n     *   bindings, and so we can chain runtime-stamped template infos off of\n     *   it). At this point, the call to `_stampTemplate` calls\n     *   `applyTemplateInfo` for each nested `<template>` found during parsing\n     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\n     *   `templateInfo` to the `<template>` so that we have the instance-time\n     *   parent to link the `templateInfo` under in the case it was\n     *   runtime-stamped.\n     *\n     * During subsequent runtime stamping (`instanceBinding==true`,\n     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\n     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\n     *   because it was either a different template altogether, or even if it\n     *   was the same template, the step above created a instance of the info;\n     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\n     *   link a instance into the linked list.\n     */\n\n    /**\n     * Equivalent to static `bindTemplate` API but can be called on an instance\n     * to add effects at runtime.  See that method for full API docs.\n     *\n     * This method may be called on the prototype (for prototypical template\n     * binding, to avoid creating accessors every instance) once per prototype,\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n     * create and link an instance of the template metadata associated with a\n     * particular stamping.\n     *\n     * @override\n     * @param {!HTMLTemplateElement} template Template containing binding\n     * bindings\n     * @param {boolean=} instanceBinding When false (default), performs\n     * \"prototypical\" binding of the template and overwrites any previously\n     * bound template for the class. When true (as passed from\n     * `_stampTemplate`), the template info is instanced and linked into the\n     * list of bound templates.\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n     * this is an instance of the prototypical template info\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _bindTemplate(template, instanceBinding) {\n      let templateInfo = this.constructor._parseTemplate(template);\n      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;\n      // Optimization: since this is called twice for proto-bound templates,\n      // don't attempt to recreate accessors if this template was pre-bound\n      if (!wasPreBound) {\n        for (let prop in templateInfo.propertyEffects) {\n          this._createPropertyAccessor(prop);\n        }\n      }\n      if (instanceBinding) {\n        // For instance-time binding, create instance of template metadata\n        // and link into tree of templates if necessary\n        templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);\n        templateInfo.wasPreBound = wasPreBound;\n        if (!this.__templateInfo) {\n          // Set the info to the root of the tree\n          this.__templateInfo = templateInfo;\n        } else {\n          // Append this template info onto the end of its parent template's\n          // list, which will determine the tree structure via which property\n          // effects are run; if this template was not nested in another\n          // template, use the root template (the first stamped one) as the\n          // parent. Note, `parent` is the `templateInfo` instance for this\n          // template's parent (containing) template, which was set up in\n          // `applyTemplateInfo`.  While a given template's `parent` is set\n          // apriori, it is only added to the parent's child list at the point\n          // that it is being bound, since a template may or may not ever be\n          // stamped, and may be stamped more than once (in which case instances\n          // of the template info will be in the tree under its parent more than\n          // once).\n          const parent = template._parentTemplateInfo || this.__templateInfo;\n          const previous = parent.lastChild;\n          templateInfo.parent = parent;\n          parent.lastChild = templateInfo;\n          templateInfo.previousSibling = previous;\n          if (previous) {\n            previous.nextSibling = templateInfo;\n          } else {\n            parent.firstChild = templateInfo;\n          }\n        }\n      } else {\n        this.__preBoundTemplateInfo = templateInfo;\n      }\n      return templateInfo;\n    }\n\n    /**\n     * Adds a property effect to the given template metadata, which is run\n     * at the \"propagate\" stage of `_propertiesChanged` when the template\n     * has been bound to the element via `_bindTemplate`.\n     *\n     * The `effect` object should match the format in `_addPropertyEffect`.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n      hostProps[prop] = true;\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n      let propEffects = effects[prop] = effects[prop] || [];\n      propEffects.push(effect);\n    }\n\n    /**\n     * Stamps the provided template and performs instance-time setup for\n     * Polymer template features, including data bindings, declarative event\n     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n     * is returned containing the stamped DOM, ready for insertion into the\n     * DOM.\n     *\n     * This method may be called more than once; however note that due to\n     * `shadycss` polyfill limitations, only styles from templates prepared\n     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n     * to the shadow root and support CSS custom properties), and note that\n     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n     * any styles required by in runtime-stamped templates must be included\n     * in the main element template.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional bound template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically bound.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     * @protected\n     */\n    _stampTemplate(template, templateInfo) {\n      templateInfo = templateInfo || /** @type {!TemplateInfo} */this._bindTemplate(template, true);\n      // Ensures that created dom is `_enqueueClient`'d to this element so\n      // that it can be flushed on next call to `_flushProperties`\n      hostStack.push(this);\n      let dom = super._stampTemplate(template, templateInfo);\n      hostStack.pop();\n      // Add template-instance-specific data to instanced templateInfo\n      templateInfo.nodeList = dom.nodeList;\n      // Capture child nodes to allow unstamping of non-prototypical templates\n      if (!templateInfo.wasPreBound) {\n        let nodes = templateInfo.childNodes = [];\n        for (let n = dom.firstChild; n; n = n.nextSibling) {\n          nodes.push(n);\n        }\n      }\n      dom.templateInfo = templateInfo;\n      // Setup compound storage, 2-way listeners, and dataHost for bindings\n      setupBindings(this, templateInfo);\n      // Flush properties into template nodes; the check on `__dataClientsReady`\n      // ensures we don't needlessly run effects for an element's initial\n      // prototypical template stamping since they will happen as a part of the\n      // first call to `_propertiesChanged`. This flag is set to true\n      // after running the initial propagate effects, and immediately before\n      // flushing clients. Since downstream clients could cause stamping on\n      // this host (e.g. a fastDomIf `dom-if` being forced to render\n      // synchronously), this flag ensures effects for runtime-stamped templates\n      // are run at this point during the initial element boot-up.\n      if (this.__dataClientsReady) {\n        this._runEffectsForTemplate(templateInfo, this.__data, null, false);\n        this._flushClients();\n      }\n      return dom;\n    }\n\n    /**\n     * Removes and unbinds the nodes previously contained in the provided\n     * DocumentFragment returned from `_stampTemplate`.\n     *\n     * @override\n     * @param {!StampedTemplate} dom DocumentFragment previously returned\n     *   from `_stampTemplate` associated with the nodes to be removed\n     * @return {void}\n     * @protected\n     */\n    _removeBoundDom(dom) {\n      // Unlink template info; Note that while the child is unlinked from its\n      // parent list, a template's `parent` reference is never removed, since\n      // this is is determined by the tree structure and applied at\n      // `applyTemplateInfo` time.\n      const templateInfo = dom.templateInfo;\n      const {\n        previousSibling,\n        nextSibling,\n        parent\n      } = templateInfo;\n      if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n      } else if (parent) {\n        parent.firstChild = nextSibling;\n      }\n      if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n      } else if (parent) {\n        parent.lastChild = previousSibling;\n      }\n      templateInfo.nextSibling = templateInfo.previousSibling = null;\n      // Remove stamped nodes\n      let nodes = templateInfo.childNodes;\n      for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        (0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)((0,_utils_wrap_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(node).parentNode).removeChild(node);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNode.call(this, node, templateInfo, nodeInfo);\n      if (node.nodeType === Node.TEXT_NODE) {\n        let parts = this._parseBindings(node.textContent, templateInfo);\n        if (parts) {\n          // Initialize the textContent with any literal parts\n          // NOTE: default to a space here so the textNode remains; some browsers\n          // (IE) omit an empty textNode following cloneNode/importNode.\n          node.textContent = literalFromParts(parts) || ' ';\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n          noted = true;\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from attributes.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      let parts = this._parseBindings(value, templateInfo);\n      if (parts) {\n        // Attribute or property\n        let origName = name;\n        let kind = 'property';\n        // The only way we see a capital letter here is if the attr has\n        // a capital letter in it per spec. In this case, to make sure\n        // this binding works, we go ahead and make the binding to the attribute.\n        if (capitalAttributeRegex.test(name)) {\n          kind = 'attribute';\n        } else if (name[name.length - 1] == '$') {\n          name = name.slice(0, -1);\n          kind = 'attribute';\n        }\n        // Initialize attribute bindings with any literal parts\n        let literal = literalFromParts(parts);\n        if (literal && kind == 'attribute') {\n          // Ensure a ShadyCSS template scoped style is not removed\n          // when a class$ binding's initial literal value is set.\n          if (name == 'class' && node.hasAttribute('class')) {\n            literal += ' ' + node.getAttribute(name);\n          }\n          node.setAttribute(name, literal);\n        }\n        // support disable-upgrade\n        if (kind == 'attribute' && origName == 'disable-upgrade$') {\n          node.setAttribute(name, '');\n        }\n        // Clear attribute before removing, since IE won't allow removing\n        // `value` attribute if it previously had a value (can't\n        // unconditionally set '' before removing since attributes with `$`\n        // can't be set using setAttribute)\n        if (node.localName === 'input' && origName === 'value') {\n          node.setAttribute(origName, '');\n        }\n        // Remove annotation\n        node.removeAttribute(origName);\n        // Case hackery: attributes are lower-case, but bind targets\n        // (properties) are case sensitive. Gambit is to map dash-case to\n        // camel-case: `foo-bar` becomes `fooBar`.\n        // Attribute bindings are excepted.\n        if (kind === 'property') {\n          name = (0,_utils_case_map_js__WEBPACK_IMPORTED_MODULE_4__.dashToCamelCase)(name);\n        }\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n        return true;\n      } else {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        return propertyEffectsBase._parseTemplateNodeAttribute.call(this, node, templateInfo, nodeInfo, name, value);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * binding the properties that a nested template depends on to the template\n     * as `_host_<property>`.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(this, node, templateInfo, nodeInfo);\n      const parent = node.parentNode;\n      const nestedTemplateInfo = nodeInfo.templateInfo;\n      const isDomIf = parent.localName === 'dom-if';\n      const isDomRepeat = parent.localName === 'dom-repeat';\n      // Remove nested template and redirect its host bindings & templateInfo\n      // onto the parent (dom-if/repeat element)'s nodeInfo\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.removeNestedTemplates && (isDomIf || isDomRepeat)) {\n        parent.removeChild(node);\n        // Use the parent's nodeInfo (for the dom-if/repeat) to record the\n        // templateInfo, and use that for any host property bindings below\n        nodeInfo = nodeInfo.parentInfo;\n        nodeInfo.templateInfo = nestedTemplateInfo;\n        // Ensure the parent dom-if/repeat is noted since it now may have host\n        // bindings; it may not have been if it did not have its own bindings\n        nodeInfo.noted = true;\n        noted = false;\n      }\n      // Merge host props into outer template and add bindings\n      let hostProps = nestedTemplateInfo.hostProps;\n      if (_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.fastDomIf && isDomIf) {\n        // `fastDomIf` mode uses runtime-template stamping to add accessors/\n        // effects to properties used in its template; as such we don't need to\n        // tax the host element with `_host_` bindings for the `dom-if`.\n        // However, in the event it is nested in a `dom-repeat`, it is still\n        // important that its host properties are added to the\n        // TemplateInstance's `hostProps` so that they are forwarded to the\n        // TemplateInstance.\n        if (hostProps) {\n          templateInfo.hostProps = Object.assign(templateInfo.hostProps || {}, hostProps);\n          // Ensure the dom-if is noted so that it has a __dataHost, since\n          // `fastDomIf` uses the host for runtime template stamping; note this\n          // was already ensured above in the `removeNestedTemplates` case\n          if (!_utils_settings_js__WEBPACK_IMPORTED_MODULE_7__.removeNestedTemplates) {\n            nodeInfo.parentInfo.noted = true;\n          }\n        }\n      } else {\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{\n            mode,\n            source,\n            dependencies: [source],\n            hostProp: true\n          }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Called to parse text in a template (either attribute values or\n     * textContent) into binding metadata.\n     *\n     * Any overrides of this method should return an array of binding part\n     * metadata  representing one or more bindings found in the provided text\n     * and any \"literal\" text in between.  Any non-literal parts will be passed\n     * to `_evaluateBinding` when any dependencies change.  The only required\n     * fields of each \"part\" in the returned array are as follows:\n     *\n     * - `dependencies` - Array containing trigger metadata for each property\n     *   that should trigger the binding to update\n     * - `literal` - String containing text if the part represents a literal;\n     *   in this case no `dependencies` are needed\n     *\n     * Additional metadata for use by `_evaluateBinding` may be provided in\n     * each part object as needed.\n     *\n     * The default implementation handles the following types of bindings\n     * (one or more may be intermixed with literal strings):\n     * - Property binding: `[[prop]]`\n     * - Path binding: `[[object.prop]]`\n     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n     * - Two-way property or path bindings (supports negation):\n     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n     * - Inline computed method (supports negation):\n     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n     *\n     * The default implementation uses a regular expression for best\n     * performance. However, the regular expression uses a white-list of\n     * allowed characters in a data-binding, which causes problems for\n     * data-bindings that do use characters not in this white-list.\n     *\n     * Instead of updating the white-list with all allowed characters,\n     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n     * that uses a state machine instead. This state machine is able to handle\n     * all characters. However, it is slightly less performant, therefore we\n     * extracted it into a separate optional mixin.\n     *\n     * @param {string} text Text to parse from attribute or textContent\n     * @param {Object} templateInfo Current template metadata\n     * @return {Array<!BindingPart>} Array of binding part metadata\n     * @protected\n     * @nocollapse\n     */\n    static _parseBindings(text, templateInfo) {\n      let parts = [];\n      let lastIndex = 0;\n      let m;\n      // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n      // Regex matches:\n      //        Iteration 1:  Iteration 2:\n      // m[1]: '{{'          '[['\n      // m[2]: ''            '!'\n      // m[3]: 'prop'        'compute(foo,bar)'\n      while ((m = bindingRegex.exec(text)) !== null) {\n        // Add literal part\n        if (m.index > lastIndex) {\n          parts.push({\n            literal: text.slice(lastIndex, m.index)\n          });\n        }\n        // Add binding part\n        let mode = m[1][0];\n        let negate = Boolean(m[2]);\n        let source = m[3].trim();\n        let customEvent = false,\n          notifyEvent = '',\n          colon = -1;\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n          notifyEvent = source.substring(colon + 2);\n          source = source.substring(0, colon);\n          customEvent = true;\n        }\n        let signature = parseMethod(source);\n        let dependencies = [];\n        if (signature) {\n          // Inline computed function\n          let {\n            args,\n            methodName\n          } = signature;\n          for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n            if (!arg.literal) {\n              dependencies.push(arg);\n            }\n          }\n          let dynamicFns = templateInfo.dynamicFns;\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\n            dependencies.push(methodName);\n            signature.dynamicFn = true;\n          }\n        } else {\n          // Property or path\n          dependencies.push(source);\n        }\n        parts.push({\n          source,\n          mode,\n          negate,\n          customEvent,\n          signature,\n          dependencies,\n          event: notifyEvent\n        });\n        lastIndex = bindingRegex.lastIndex;\n      }\n      // Add a final literal part\n      if (lastIndex && lastIndex < text.length) {\n        let literal = text.substring(lastIndex);\n        if (literal) {\n          parts.push({\n            literal: literal\n          });\n        }\n      }\n      if (parts.length) {\n        return parts;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Called to evaluate a previously parsed binding part based on a set of\n     * one or more changed dependencies.\n     *\n     * @param {!Polymer_PropertyEffects} inst Element that should be used as\n     *     scope for binding dependencies\n     * @param {BindingPart} part Binding part metadata\n     * @param {string} path Property/path that triggered this effect\n     * @param {Object} props Bag of current property changes\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {*} Value the binding part evaluated to\n     * @protected\n     * @nocollapse\n     */\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n      let value;\n      if (part.signature) {\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\n      } else if (path != part.source) {\n        value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, part.source);\n      } else {\n        if (hasPaths && (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.isPath)(path)) {\n          value = (0,_utils_path_js__WEBPACK_IMPORTED_MODULE_3__.get)(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n      if (part.negate) {\n        value = !value;\n      }\n      return value;\n    }\n  }\n  return PropertyEffects;\n});\n\n/**\n * Stack for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\nconst hostStack = [];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanM/Mjk1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIEBzdXBwcmVzcyB7Y2hlY2tQcm90b3R5cGFsVHlwZXN9XG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZFxuICogYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heVxuICogYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieVxuICogR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUFxuICogcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnLi4vdXRpbHMvd3JhcC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgcm9vdCwgaXNBbmNlc3RvciwgaXNEZXNjZW5kYW50LCBnZXQsIHRyYW5zbGF0ZSwgaXNQYXRoLCBzZXQsIG5vcm1hbGl6ZSB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuLyogZm9yIG5vdGlmeSwgcmVmbGVjdCAqL1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2hDYXNlLCBkYXNoVG9DYW1lbENhc2UgfSBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUFjY2Vzc29ycyB9IGZyb20gJy4vcHJvcGVydHktYWNjZXNzb3JzLmpzJztcbi8qIGZvciBhbm5vdGF0ZWQgZWZmZWN0cyAqL1xuaW1wb3J0IHsgVGVtcGxhdGVTdGFtcCB9IGZyb20gJy4vdGVtcGxhdGUtc3RhbXAuanMnO1xuaW1wb3J0IHsgc2FuaXRpemVET01WYWx1ZSwgbGVnYWN5VW5kZWZpbmVkLCBvcmRlcmVkQ29tcHV0ZWQsIHJlbW92ZU5lc3RlZFRlbXBsYXRlcywgZmFzdERvbUlmIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuXG4vLyBNb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdW5pcXVlIElEIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzIHRyaWdnZXJlZFxuLy8gZnJvbSBtdWx0aXBsZSBwcm9wZXJ0aWVzIGluIHRoZSBzYW1lIHR1cm5cbmxldCBkZWR1cGVJZCA9IDA7XG5cbmNvbnN0IE5PT1AgPSBbXTtcblxuLyoqXG4gKiBQcm9wZXJ0eSBlZmZlY3QgdHlwZXM7IGVmZmVjdHMgYXJlIHN0b3JlZCBvbiB0aGUgcHJvdG90eXBlIHVzaW5nIHRoZXNlIGtleXNcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFRZUEVTID0ge1xuICBDT01QVVRFOiAnX19jb21wdXRlRWZmZWN0cycsXG4gIFJFRkxFQ1Q6ICdfX3JlZmxlY3RFZmZlY3RzJyxcbiAgTk9USUZZOiAnX19ub3RpZnlFZmZlY3RzJyxcbiAgUFJPUEFHQVRFOiAnX19wcm9wYWdhdGVFZmZlY3RzJyxcbiAgT0JTRVJWRTogJ19fb2JzZXJ2ZUVmZmVjdHMnLFxuICBSRUFEX09OTFk6ICdfX3JlYWRPbmx5J1xufTtcblxuY29uc3QgQ09NUFVURV9JTkZPID0gJ19fY29tcHV0ZUluZm8nO1xuXG4vKiogQGNvbnN0IHshUmVnRXhwfSAqL1xuY29uc3QgY2FwaXRhbEF0dHJpYnV0ZVJlZ2V4ID0gL1tBLVpdLztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogbmFtZTogKHN0cmluZyB8IHVuZGVmaW5lZCksXG4gKiBzdHJ1Y3R1cmVkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZCksXG4gKiB3aWxkY2FyZDogKGJvb2xlYW4gfCB1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgRGF0YVRyaWdnZXI7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBpbmZvOiA/LFxuICogdHJpZ2dlcjogKCFEYXRhVHJpZ2dlciB8IHVuZGVmaW5lZCksXG4gKiBmbjogKCFGdW5jdGlvbiB8IHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBEYXRhRWZmZWN0OyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgdGhlIG1vZGVsIGhhcyBhbiBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICogVGhlIG1vZGVsIG1heSBiZSBhIHByb3RvdHlwZSBvciBhbiBpbnN0YW5jZS5cbiAqXG4gKiBQcm9wZXJ0eSBlZmZlY3RzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIG9mIGVmZmVjdHMgYnkgcHJvcGVydHkgaW4gYSBtYXAsXG4gKiBieSBuYW1lZCB0eXBlIG9uIHRoZSBtb2RlbC4gZS5nLlxuICpcbiAqICAgX19jb21wdXRlRWZmZWN0czoge1xuICogICAgIGZvbzogWyAuLi4gXSxcbiAqICAgICBiYXI6IFsgLi4uIF1cbiAqICAgfVxuICpcbiAqIElmIHRoZSBtb2RlbCBkb2VzIG5vdCB5ZXQgaGF2ZSBhbiBlZmZlY3QgbWFwIGZvciB0aGUgdHlwZSwgb25lIGlzIGNyZWF0ZWRcbiAqIGFuZCByZXR1cm5lZC4gIElmIGl0IGRvZXMsIGJ1dCBpdCBpcyBub3QgYW4gb3duIHByb3BlcnR5IChpLmUuIHRoZVxuICogcHJvdG90eXBlIGhhZCBlZmZlY3RzKSwgdGhlIHRoZSBtYXAgaXMgZGVlcGx5IGNsb25lZCBhbmQgdGhlIGNvcHkgaXNcbiAqIHNldCBvbiB0aGUgbW9kZWwgYW5kIHJldHVybmVkLCByZWFkeSBmb3IgbmV3IGVmZmVjdHMgdG8gYmUgYWRkZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgUHJvcGVydHkgZWZmZWN0IHR5cGVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGNsb25lQXJyYXlzIENsb25lIGFueSBhcnJheXMgYXNzaWduZWQgdG8gdGhlIG1hcCB3aGVuXG4gKiAgIGV4dGVuZGluZyBhIHN1cGVyY2xhc3MgbWFwIG9udG8gdGhpcyBzdWJjbGFzc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5zdXJlT3duRWZmZWN0TWFwKG1vZGVsLCB0eXBlLCBjbG9uZUFycmF5cykge1xuICBsZXQgZWZmZWN0cyA9IG1vZGVsW3R5cGVdO1xuICBpZiAoIWVmZmVjdHMpIHtcbiAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSB7fTtcbiAgfSBlbHNlIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSBPYmplY3QuY3JlYXRlKG1vZGVsW3R5cGVdKTtcbiAgICBpZiAoY2xvbmVBcnJheXMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gZWZmZWN0cykge1xuICAgICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICAgIC8vIFBlcmYgb3B0aW1pemF0aW9uIG92ZXIgQXJyYXkuc2xpY2VcbiAgICAgICAgbGV0IGluc3RGeCA9IGVmZmVjdHNbcF0gPSBBcnJheShwcm90b0Z4Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwcm90b0Z4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW5zdEZ4W2ldID0gcHJvdG9GeFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWZmZWN0cztcbn1cblxuLy8gLS0gZWZmZWN0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogUnVucyBhbGwgZWZmZWN0cyBvZiBhIGdpdmVuIHR5cGUgZm9yIHRoZSBnaXZlbiBzZXQgb2YgcHJvcGVydHkgY2hhbmdlc1xuICogb24gYW4gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7P09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7P09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHs/T2JqZWN0PX0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuRWZmZWN0cyhpbnN0LCBlZmZlY3RzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgaWYgKGVmZmVjdHMpIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgY29uc3QgaWQgPSBkZWR1cGVJZCsrO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIC8vIElubGluZSBgcnVuRWZmZWN0c0ZvclByb3BlcnR5YCBmb3IgcGVyZi5cbiAgICAgIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QocHJvcCkgOiBwcm9wO1xuICAgICAgbGV0IGZ4cyA9IGVmZmVjdHNbcm9vdFByb3BlcnR5XTtcbiAgICAgIGlmIChmeHMpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wLCBsPWZ4cy5sZW5ndGgsIGZ4OyAoaTxsKSAmJiAoZng9ZnhzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgaWYgKCghZnguaW5mbyB8fCBmeC5pbmZvLmxhc3RSdW4gIT09IGlkKSAmJlxuICAgICAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgICAgIGlmIChmeC5pbmZvKSB7XG4gICAgICAgICAgICAgIGZ4LmluZm8ubGFzdFJ1biA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnguZm4oaW5zdCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBmeC5pbmZvLCBoYXNQYXRocywgZXh0cmFBcmdzKTtcbiAgICAgICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW47XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJ1bnMgYSBsaXN0IG9mIGVmZmVjdHMgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7IU9iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWR1cGVJZCBDb3VudGVyIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBOYW1lIG9mIGNoYW5nZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7Kn0gcHJvcHMgQ2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0geyp9IG9sZFByb3BzIE9sZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGRlZHVwZUlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgbGV0IHJhbiA9IGZhbHNlO1xuICBsZXQgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyByb290KHByb3ApIDogcHJvcDtcbiAgbGV0IGZ4cyA9IGVmZmVjdHNbcm9vdFByb3BlcnR5XTtcbiAgaWYgKGZ4cykge1xuICAgIGZvciAobGV0IGk9MCwgbD1meHMubGVuZ3RoLCBmeDsgKGk8bCkgJiYgKGZ4PWZ4c1tpXSk7IGkrKykge1xuICAgICAgaWYgKCghZnguaW5mbyB8fCBmeC5pbmZvLmxhc3RSdW4gIT09IGRlZHVwZUlkKSAmJlxuICAgICAgICAgICghaGFzUGF0aHMgfHwgcGF0aE1hdGNoZXNUcmlnZ2VyKHByb3AsIGZ4LnRyaWdnZXIpKSkge1xuICAgICAgICBpZiAoZnguaW5mbykge1xuICAgICAgICAgIGZ4LmluZm8ubGFzdFJ1biA9IGRlZHVwZUlkO1xuICAgICAgICB9XG4gICAgICAgIGZ4LmZuKGluc3QsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgZnguaW5mbywgaGFzUGF0aHMsIGV4dHJhQXJncyk7XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByYW47XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcHJvcGVydHkvcGF0aCB0aGF0IGhhcyBjaGFuZ2VkIG1hdGNoZXMgdGhlIHRyaWdnZXJcbiAqIGNyaXRlcmlhIGZvciBhbiBlZmZlY3QuICBBIHRyaWdnZXIgaXMgYSBkZXNjcmlwdG9yIHdpdGggdGhlIGZvbGxvd2luZ1xuICogc3RydWN0dXJlLCB3aGljaCBtYXRjaGVzIHRoZSBkZXNjcmlwdG9ycyByZXR1cm5lZCBmcm9tIGBwYXJzZUFyZ2AuXG4gKiBlLmcuIGZvciBgZm9vLmJhci4qYDpcbiAqIGBgYFxuICogdHJpZ2dlcjoge1xuICogICBuYW1lOiAnYS5iJyxcbiAqICAgc3RydWN0dXJlZDogdHJ1ZSxcbiAqICAgd2lsZGNhcmQ6IHRydWVcbiAqIH1cbiAqIGBgYFxuICogSWYgbm8gdHJpZ2dlciBpcyBnaXZlbiwgdGhlIHBhdGggaXMgZGVlbWVkIHRvIG1hdGNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggb3IgcHJvcGVydHkgdGhhdCBjaGFuZ2VkXG4gKiBAcGFyYW0gez9EYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXRoIG1hdGNoZWQgdGhlIHRyaWdnZXJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgaWYgKHRyaWdnZXIpIHtcbiAgICBsZXQgdHJpZ2dlclBhdGggPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRyaWdnZXIubmFtZSk7XG4gICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgICAhISh0cmlnZ2VyLnN0cnVjdHVyZWQgJiYgaXNBbmNlc3Rvcih0cmlnZ2VyUGF0aCwgcGF0aCkpIHx8XG4gICAgICAgICEhKHRyaWdnZXIud2lsZGNhcmQgJiYgaXNEZXNjZW5kYW50KHRyaWdnZXJQYXRoLCBwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcIm9ic2VydmVyXCIgZWZmZWN0LlxuICpcbiAqIENhbGxzIHRoZSBtZXRob2Qgd2l0aCBgaW5mby5tZXRob2ROYW1lYCBvbiB0aGUgaW5zdGFuY2UsIHBhc3NpbmcgdGhlXG4gKiBuZXcgYW5kIG9sZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk9ic2VydmVyRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IGZuID0gdHlwZW9mIGluZm8ubWV0aG9kID09PSBcInN0cmluZ1wiID8gaW5zdFtpbmZvLm1ldGhvZF0gOiBpbmZvLm1ldGhvZDtcbiAgbGV0IGNoYW5nZWRQcm9wID0gaW5mby5wcm9wZXJ0eTtcbiAgaWYgKGZuKSB7XG4gICAgZm4uY2FsbChpbnN0LCBpbnN0Ll9fZGF0YVtjaGFuZ2VkUHJvcF0sIG9sZFByb3BzW2NoYW5nZWRQcm9wXSk7XG4gIH0gZWxzZSBpZiAoIWluZm8uZHluYW1pY0ZuKSB7XG4gICAgY29uc29sZS53YXJuKCdvYnNlcnZlciBtZXRob2QgYCcgKyBpbmZvLm1ldGhvZCArICdgIG5vdCBkZWZpbmVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSdW5zIFwibm90aWZ5XCIgZWZmZWN0cyBmb3IgYSBzZXQgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSB0aGUgZ2VuZXJpYyBgcnVuRWZmZWN0c2AgbWV0aG9kIGluIHRoYXQgaXRcbiAqIHdpbGwgZGlzcGF0Y2ggcGF0aCBub3RpZmljYXRpb24gZXZlbnRzIGluIHRoZSBjYXNlIHRoYXQgdGhlIHByb3BlcnR5XG4gKiBjaGFuZ2VkIHdhcyBhIHBhdGggYW5kIHRoZSByb290IHByb3BlcnR5IGZvciB0aGF0IHBhdGggZGlkbid0IGhhdmUgYVxuICogXCJub3RpZnlcIiBlZmZlY3QuICBUaGlzIGlzIHRvIG1haW50YWluIDEuMCBiZWhhdmlvciB0aGF0IGRpZCBub3QgcmVxdWlyZVxuICogYG5vdGlmeTogdHJ1ZWAgdG8gZW5zdXJlIG9iamVjdCBzdWItcHJvcGVydHkgbm90aWZpY2F0aW9ucyB3ZXJlXG4gKiBzZW50LlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gbm90aWZ5UHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gbm90aWZ5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdHMoaW5zdCwgbm90aWZ5UHJvcHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgLy8gTm90aWZ5XG4gIGxldCBmeHMgPSBpbnN0W1RZUEVTLk5PVElGWV07XG4gIGxldCBub3RpZmllZDtcbiAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgLy8gVHJ5IG5vcm1hbCBub3RpZnkgZWZmZWN0czsgaWYgbm9uZSwgZmFsbCBiYWNrIHRvIHRyeSBwYXRoIG5vdGlmaWNhdGlvblxuICBmb3IgKGxldCBwcm9wIGluIG5vdGlmeVByb3BzKSB7XG4gICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICBpZiAoZnhzICYmIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBmeHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRmx1c2ggaG9zdCBpZiB3ZSBhY3R1YWxseSBub3RpZmllZCBhbmQgaG9zdCB3YXMgYmF0Y2hpbmdcbiAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgLy8gYW4gaXNzdWUgd2l0aCBhIGhvc3Qgb2JzZXJ2aW5nIGRhdGEgY2hhbmdlcyBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gIGxldCBob3N0O1xuICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB3aXRoIHBhdGggaW5mb3JtYXRpb24gaW4gdGhlIGRldGFpbFxuICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZmlyZSB0aGVcbiAqICAgICBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgbm90aWZpZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVBhdGgoaW5zdCwgcGF0aCwgcHJvcHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IHJvb3QocGF0aCk7XG4gIGlmIChyb290UHJvcGVydHkgIT09IHBhdGgpIHtcbiAgICBsZXQgZXZlbnROYW1lID0gY2FtZWxUb0Rhc2hDYXNlKHJvb3RQcm9wZXJ0eSkgKyAnLWNoYW5nZWQnO1xuICAgIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCBwcm9wc1twYXRoXSwgcGF0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB0byBpbmRpY2F0ZSBhIHByb3BlcnR5IChvciBwYXRoKVxuICogY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlXG4gKiAgICAgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmRcbiAqICAgICAoJ3twcm9wZXJ0eX0tY2hhbmdlZCcpXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgY2hhbmdlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXRoIElmIGEgc3ViLXBhdGggb2YgdGhpcyBwcm9wZXJ0eVxuICogICAgIGNoYW5nZWQsIHRoZSBwYXRoIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBldmVudE5hbWUsIHZhbHVlLCBwYXRoKSB7XG4gIGxldCBkZXRhaWwgPSB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHF1ZXVlUHJvcGVydHk6IHRydWVcbiAgfTtcbiAgaWYgKHBhdGgpIHtcbiAgICBkZXRhaWwucGF0aCA9IHBhdGg7XG4gIH1cbiAgLy8gQXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIHdlIGNvdWxkIGVsaWRlIHRoZSB3cmFwIGhlcmUgc2luY2Ugbm90aWZ5aW5nXG4gIC8vIGV2ZW50cyBhcmUgbm9uLWJ1YmJsaW5nIGFuZCBzaG91bGRuJ3QgbmVlZCByZXRhcmdldGluZy4gSG93ZXZlciwgYSB2ZXJ5XG4gIC8vIHNtYWxsIG51bWJlciBvZiBpbnRlcm5hbCB0ZXN0cyBmYWlsZWQgaW4gb2JzY3VyZSB3YXlzLCB3aGljaCBtYXkgaW5kaWNhdGVcbiAgLy8gdXNlciBjb2RlIHJlbGllZCBvbiB0aW1pbmcgZGlmZmVyZW5jZXMgcmVzdWx0aW5nIGZyb20gU2hhZHlET00gZmx1c2hpbmdcbiAgLy8gYXMgYSByZXN1bHQgb2YgdGhlIHdyYXBwZWQgYGRpc3BhdGNoRXZlbnRgLlxuICB3cmFwKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhpbnN0KSkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gKlxuICogRGlzcGF0Y2hlcyBhIG5vbi1idWJibGluZyBldmVudCBuYW1lZCBgaW5mby5ldmVudE5hbWVgIG9uIHRoZSBpbnN0YW5jZVxuICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocykge1xuICBsZXQgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyByb290KHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICBsZXQgcGF0aCA9IHJvb3RQcm9wZXJ0eSAhPSBwcm9wZXJ0eSA/IHByb3BlcnR5IDogbnVsbDtcbiAgbGV0IHZhbHVlID0gcGF0aCA/IGdldChpbnN0LCBwYXRoKSA6IGluc3QuX19kYXRhW3Byb3BlcnR5XTtcbiAgaWYgKHBhdGggJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gcHJvcHNbcHJvcGVydHldOyAgLy8gc3BlY2lmaWNhbGx5IGZvciAuc3BsaWNlc1xuICB9XG4gIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgaW5mby5ldmVudE5hbWUsIHZhbHVlLCBwYXRoKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZ1bmN0aW9uIGZvciAyLXdheSBub3RpZmljYXRpb24gZXZlbnRzLiBSZWNlaXZlcyBjb250ZXh0XG4gKiBpbmZvcm1hdGlvbiBjYXB0dXJlZCBpbiB0aGUgYGFkZE5vdGlmeUxpc3RlbmVyYCBjbG9zdXJlIGZyb20gdGhlXG4gKiBgX19ub3RpZnlMaXN0ZW5lcnNgIG1ldGFkYXRhLlxuICpcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBub3RpZmllZCBwcm9wZXJ0eSB0byB0aGUgaG9zdCBwcm9wZXJ0eSBvciBwYXRoLiAgSWZcbiAqIHRoZSBldmVudCBjb250YWluZWQgcGF0aCBpbmZvcm1hdGlvbiwgdHJhbnNsYXRlIHRoYXQgcGF0aCB0byB0aGUgaG9zdFxuICogc2NvcGUncyBuYW1lIGZvciB0aGF0IHBhdGggZmlyc3QuXG4gKlxuICogQHBhcmFtIHtDdXN0b21FdmVudH0gZXZlbnQgTm90aWZpY2F0aW9uIGV2ZW50IChlLmcuICc8cHJvcGVydHk+LWNoYW5nZWQnKVxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgSG9zdCBlbGVtZW50IGluc3RhbmNlIGhhbmRsaW5nIHRoZVxuICogICAgIG5vdGlmaWNhdGlvbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGZyb21Qcm9wIENoaWxkIGVsZW1lbnQgcHJvcGVydHkgdGhhdCB3YXMgYm91bmRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b1BhdGggSG9zdCBwcm9wZXJ0eS9wYXRoIHRoYXQgd2FzIGJvdW5kXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG5lZ2F0ZSBXaGV0aGVyIHRoZSBiaW5kaW5nIHdhcyBuZWdhdGVkXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKGV2ZW50LCBpbnN0LCBmcm9tUHJvcCwgdG9QYXRoLCBuZWdhdGUpIHtcbiAgbGV0IHZhbHVlO1xuICBsZXQgZGV0YWlsID0gLyoqIEB0eXBlIHtPYmplY3R9ICovKGV2ZW50LmRldGFpbCk7XG4gIGxldCBmcm9tUGF0aCA9IGRldGFpbCAmJiBkZXRhaWwucGF0aDtcbiAgaWYgKGZyb21QYXRoKSB7XG4gICAgdG9QYXRoID0gdHJhbnNsYXRlKGZyb21Qcm9wLCB0b1BhdGgsIGZyb21QYXRoKTtcbiAgICB2YWx1ZSA9IGRldGFpbCAmJiBkZXRhaWwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBldmVudC5jdXJyZW50VGFyZ2V0W2Zyb21Qcm9wXTtcbiAgfVxuICB2YWx1ZSA9IG5lZ2F0ZSA/ICF2YWx1ZSA6IHZhbHVlO1xuICBpZiAoIWluc3RbVFlQRVMuUkVBRF9PTkxZXSB8fCAhaW5zdFtUWVBFUy5SRUFEX09OTFldW3RvUGF0aF0pIHtcbiAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgJiYgKCFkZXRhaWwgfHwgIWRldGFpbC5xdWV1ZVByb3BlcnR5KSkge1xuICAgICAgaW5zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcInJlZmxlY3RcIiBlZmZlY3QuXG4gKlxuICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1blJlZmxlY3RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgdmFsdWUgPSBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gIGlmIChzYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgdmFsdWUgPSBzYW5pdGl6ZURPTVZhbHVlKHZhbHVlLCBpbmZvLmF0dHJOYW1lLCAnYXR0cmlidXRlJywgLyoqIEB0eXBlIHtOb2RlfSAqLyhpbnN0KSk7XG4gIH1cbiAgaW5zdC5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgaW5mby5hdHRyTmFtZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFJ1bnMgXCJjb21wdXRlZFwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gdGhlIGdlbmVyaWMgYHJ1bkVmZmVjdHNgIG1ldGhvZCBpbiB0aGF0IGl0XG4gKiBjb250aW51ZXMgdG8gcnVuIGNvbXB1dGVkIGVmZmVjdHMgYmFzZWQgb24gdGhlIG91dHB1dCBvZiBlYWNoIHBhc3MgdW50aWxcbiAqIHRoZXJlIGFyZSBubyBtb3JlIG5ld2x5IGNvbXB1dGVkIHByb3BlcnRpZXMuICBUaGlzIGVuc3VyZXMgdGhhdCBhbGxcbiAqIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGNvbXB1dGVkIGJ5IHRoZSBpbml0aWFsIHNldCBvZiBjaGFuZ2VzIGFyZVxuICogY29tcHV0ZWQgYmVmb3JlIG90aGVyIGVmZmVjdHMgKGJpbmRpbmcgcHJvcGFnYXRpb24sIG9ic2VydmVycywgYW5kIG5vdGlmeSlcbiAqIHJ1bi5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHs/T2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdHMoaW5zdCwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgbGV0IGNvbXB1dGVFZmZlY3RzID0gaW5zdFtUWVBFUy5DT01QVVRFXTtcbiAgaWYgKGNvbXB1dGVFZmZlY3RzKSB7XG4gICAgaWYgKG9yZGVyZWRDb21wdXRlZCkge1xuICAgICAgLy8gUnVucyBjb21wdXRlZCBlZmZlY3RzIGluIGVmZmljaWVudCBvcmRlciBieSBrZWVwaW5nIGEgdG9wb2xvZ2ljYWxseS1cbiAgICAgIC8vIHNvcnRlZCBxdWV1ZSBvZiBjb21wdXRlIGVmZmVjdHMgdG8gcnVuLCBhbmQgaW5zZXJ0aW5nIHN1YnNlcXVlbnRseVxuICAgICAgLy8gaW52YWxpZGF0ZWQgZWZmZWN0cyBhcyB0aGV5IGFyZSBydW5cbiAgICAgIGRlZHVwZUlkKys7XG4gICAgICBjb25zdCBvcmRlciA9IGdldENvbXB1dGVkT3JkZXIoaW5zdCk7XG4gICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgICAgZm9yIChsZXQgcCBpbiBjaGFuZ2VkUHJvcHMpIHtcbiAgICAgICAgZW5xdWV1ZUVmZmVjdHNGb3IocCwgY29tcHV0ZUVmZmVjdHMsIHF1ZXVlLCBvcmRlciwgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgbGV0IGluZm87XG4gICAgICB3aGlsZSAoKGluZm8gPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICBpZiAocnVuQ29tcHV0ZWRFZmZlY3QoaW5zdCwgJycsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGluZm8pKSB7XG4gICAgICAgICAgZW5xdWV1ZUVmZmVjdHNGb3IoaW5mby5tZXRob2RJbmZvLCBjb21wdXRlRWZmZWN0cywgcXVldWUsIG9yZGVyLCBoYXNQYXRocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24oLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAob2xkUHJvcHMpLCBpbnN0Ll9fZGF0YU9sZCk7XG4gICAgICBPYmplY3QuYXNzaWduKC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGNoYW5nZWRQcm9wcyksIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICBpbnN0Ll9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcmlnaW5hbCBQb2x5bWVyIDIueCBjb21wdXRlZCBlZmZlY3RzIG9yZGVyLCB3aGljaCBjb250aW51ZXMgcnVubmluZ1xuICAgICAgLy8gZWZmZWN0cyB1bnRpbCBubyBmdXJ0aGVyIGNvbXB1dGVkIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGludmFsaWRhdGVkXG4gICAgICBsZXQgaW5wdXRQcm9wcyA9IGNoYW5nZWRQcm9wcztcbiAgICAgIHdoaWxlIChydW5FZmZlY3RzKGluc3QsIGNvbXB1dGVFZmZlY3RzLCBpbnB1dFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAob2xkUHJvcHMpLCBpbnN0Ll9fZGF0YU9sZCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoY2hhbmdlZFByb3BzKSwgaW5zdC5fX2RhdGFQZW5kaW5nKTtcbiAgICAgICAgaW5wdXRQcm9wcyA9IGluc3QuX19kYXRhUGVuZGluZztcbiAgICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgY29tcHV0ZWQgZWZmZWN0IGludG8gYSBxdWV1ZSwgZ2l2ZW4gdGhlIHNwZWNpZmllZCBvcmRlci4gUGVyZm9ybXNcbiAqIHRoZSBpbnNlcnQgdXNpbmcgYSBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIFVzZWQgYnkgYG9yZGVyZWRDb21wdXRlZDogdHJ1ZWAgY29tcHV0ZWQgcHJvcGVydHkgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIFByb3BlcnR5IGVmZmVjdHMgbWV0YWRhdGFcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcXVldWUgT3JkZXJlZCBxdWV1ZSBvZiBlZmZlY3RzXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsbnVtYmVyPn0gb3JkZXIgTWFwIG9mIGNvbXB1dGVkIHByb3BlcnR5IG5hbWUtPnRvcG9sb2dpY2FsXG4gKiAgIHNvcnQgb3JkZXJcbiAqL1xuY29uc3QgaW5zZXJ0RWZmZWN0ID0gKGluZm8sIHF1ZXVlLCBvcmRlcikgPT4ge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgbGV0IGlkeCA9IC0xO1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgY29uc3QgbWlkID0gKHN0YXJ0ICsgZW5kKSA+PiAxO1xuICAgIC8vIE5vdGUgYG1ldGhvZEluZm9gIGlzIHdoZXJlIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBuYW1lIGlzIHN0b3JlZCBpblxuICAgIC8vIHRoZSBlZmZlY3QgbWV0YWRhdGFcbiAgICBjb25zdCBjbXAgPSBvcmRlci5nZXQocXVldWVbbWlkXS5tZXRob2RJbmZvKSAtIG9yZGVyLmdldChpbmZvLm1ldGhvZEluZm8pO1xuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBzdGFydCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICBlbmQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZHggPSBtaWQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZHggPSBlbmQgKyAxO1xuICB9XG4gIHF1ZXVlLnNwbGljZShpZHgsIDAsIGluZm8pO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGFsbCBkb3duc3RyZWFtIGNvbXB1dGVkIGVmZmVjdHMgaW52YWxpZGF0ZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICogaW50byB0aGUgdG9wb2xvZ2ljYWxseS1zb3J0ZWQgcXVldWUgb2YgZWZmZWN0cyB0byBiZSBydW4uXG4gKlxuICogVXNlZCBieSBgb3JkZXJlZENvbXB1dGVkOiB0cnVlYCBjb21wdXRlZCBwcm9wZXJ0eSBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbXB1dGVFZmZlY3RzIENvbXB1dGVkIGVmZmVjdHMgZm9yIHRoaXMgZWxlbWVudFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBxdWV1ZSBUb3BvbG9naWNhbGx5LXNvcnRlZCBxdWV1ZSBvZiBjb21wdXRlZCBlZmZlY3RzXG4gKiAgIHRvIGJlIHJ1blxuICogQHBhcmFtIHtNYXA8c3RyaW5nLG51bWJlcj59IG9yZGVyIE1hcCBvZiBjb21wdXRlZCBwcm9wZXJ0eSBuYW1lLT50b3BvbG9naWNhbFxuICogICBzb3J0IG9yZGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgY2hhbmdlZFByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICovXG5jb25zdCBlbnF1ZXVlRWZmZWN0c0ZvciA9IChwcm9wLCBjb21wdXRlRWZmZWN0cywgcXVldWUsIG9yZGVyLCBoYXNQYXRocykgPT4ge1xuICBjb25zdCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QocHJvcCkgOiBwcm9wO1xuICBjb25zdCBmeHMgPSBjb21wdXRlRWZmZWN0c1tyb290UHJvcGVydHldO1xuICBpZiAoZnhzKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpPGZ4cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnggPSBmeHNbaV07XG4gICAgICBpZiAoKGZ4LmluZm8ubGFzdFJ1biAhPT0gZGVkdXBlSWQpICYmXG4gICAgICAgICAgKCFoYXNQYXRocyB8fCBwYXRoTWF0Y2hlc1RyaWdnZXIocHJvcCwgZngudHJpZ2dlcikpKSB7XG4gICAgICAgIGZ4LmluZm8ubGFzdFJ1biA9IGRlZHVwZUlkO1xuICAgICAgICBpbnNlcnRFZmZlY3QoZnguaW5mbywgcXVldWUsIG9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXRyaWV2ZXMgYSBtZW1vaXplZCBtYXAgb2YgY29tcHV0ZWQgcHJvcGVydHkgbmFtZSB0byBpdHNcbiAqIHRvcG9sb2dpY2FsbHktc29ydGVkIG9yZGVyLlxuICpcbiAqIFRoZSBtYXAgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IGFzc2lnbmluZyBhIFwiZGVwZW5kZW5jeSBjb3VudFwiIHRvIGVhY2ggcHJvcGVydHlcbiAqIChkZWZpbmVkIGFzIG51bWJlciBwcm9wZXJ0aWVzIGl0IGRlcGVuZHMgb24sIGluY2x1ZGluZyBpdHMgbWV0aG9kIGZvclxuICogXCJkeW5hbWljIGZ1bmN0aW9uc1wiKS4gQW55IHByb3BlcnRpZXMgdGhhdCBoYXZlIG5vIGRlcGVuZGVuY2llcyBhcmUgYWRkZWQgdG9cbiAqIHRoZSBgcmVhZHlgIHF1ZXVlLCB3aGljaCBhcmUgcHJvcGVydGllcyB3aG9zZSBvcmRlciBjYW4gYmUgYWRkZWQgdG8gdGhlIGZpbmFsXG4gKiBvcmRlciBtYXAuIFByb3BlcnRpZXMgYXJlIHBvcHBlZCBvZmYgdGhlIGByZWFkeWAgcXVldWUgb25lIGJ5IG9uZSBhbmQgYS4pIGFkZGVkIGFzXG4gKiB0aGUgbmV4dCBwcm9wZXJ0eSBpbiB0aGUgb3JkZXIgbWFwLCBhbmQgYi4pIGVhY2ggcHJvcGVydHkgdGhhdCBpdCBpcyBhXG4gKiBkZXBlbmRlbmN5IGZvciBoYXMgaXRzIGRlcCBjb3VudCBkZWNyZW1lbnRlZCAoYW5kIGlmIHRoYXQgcHJvcGVydHkncyBkZXBcbiAqIGNvdW50IGdvZXMgdG8gemVybywgaXQgaXMgYWRkZWQgdG8gdGhlIGByZWFkeWAgcXVldWUpLCB1bnRpbCBhbGwgcHJvcGVydGllc1xuICogaGF2ZSBiZWVuIHZpc2l0ZWQgYW5kIG9yZGVyZWQuXG4gKlxuICogVXNlZCBieSBgb3JkZXJlZENvbXB1dGVkOiB0cnVlYCBjb21wdXRlZCBwcm9wZXJ0eSBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRvIHJldHJpZXZlIHRoZSBjb21wdXRlZFxuICogICBlZmZlY3Qgb3JkZXIgZm9yLlxuICogQHJldHVybiB7TWFwPHN0cmluZyxudW1iZXI+fSBNYXAgb2YgY29tcHV0ZWQgcHJvcGVydHkgbmFtZS0+dG9wb2xvZ2ljYWwgc29ydFxuICogICBvcmRlclxuICovXG5mdW5jdGlvbiBnZXRDb21wdXRlZE9yZGVyKGluc3QpIHtcbiAgbGV0IG9yZGVyZWQgPSBpbnN0LmNvbnN0cnVjdG9yLl9fb3JkZXJlZENvbXB1dGVkRGVwcztcbiAgaWYgKCFvcmRlcmVkKSB7XG4gICAgb3JkZXJlZCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlZmZlY3RzID0gaW5zdFtUWVBFUy5DT01QVVRFXTtcbiAgICBsZXQge2NvdW50cywgcmVhZHksIHRvdGFsfSA9IGRlcGVuZGVuY3lDb3VudHMoaW5zdCk7XG4gICAgbGV0IGN1cnI7XG4gICAgd2hpbGUgKChjdXJyID0gcmVhZHkuc2hpZnQoKSkpIHtcbiAgICAgIG9yZGVyZWQuc2V0KGN1cnIsIG9yZGVyZWQuc2l6ZSk7XG4gICAgICBjb25zdCBjb21wdXRlZEJ5Q3VyciA9IGVmZmVjdHNbY3Vycl07XG4gICAgICBpZiAoY29tcHV0ZWRCeUN1cnIpIHtcbiAgICAgICAgY29tcHV0ZWRCeUN1cnIuZm9yRWFjaChmeCA9PiB7XG4gICAgICAgICAgLy8gTm90ZSBgbWV0aG9kSW5mb2AgaXMgd2hlcmUgdGhlIGNvbXB1dGVkIHByb3BlcnR5IG5hbWUgaXMgc3RvcmVkXG4gICAgICAgICAgY29uc3QgY29tcHV0ZWRQcm9wID0gZnguaW5mby5tZXRob2RJbmZvO1xuICAgICAgICAgIC0tdG90YWw7XG4gICAgICAgICAgaWYgKC0tY291bnRzW2NvbXB1dGVkUHJvcF0gPT09IDApIHtcbiAgICAgICAgICAgIHJlYWR5LnB1c2goY29tcHV0ZWRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodG90YWwgIT09IDApIHtcbiAgICAgIGNvbnN0IGVsID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGluc3QpO1xuICAgICAgY29uc29sZS53YXJuKGBDb21wdXRlZCBncmFwaCBmb3IgJHtlbC5sb2NhbE5hbWV9IGluY29tcGxldGU7IGNpcmN1bGFyP2ApO1xuICAgIH1cbiAgICBpbnN0LmNvbnN0cnVjdG9yLl9fb3JkZXJlZENvbXB1dGVkRGVwcyA9IG9yZGVyZWQ7XG4gIH1cbiAgcmV0dXJuIG9yZGVyZWQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWFwIG9mIHByb3BlcnR5LXRvLWRlcGVuZGVuY3kgY291bnQgKGBjb3VudHNgLCB3aGVyZSBcImRlcGVuZGVuY3lcbiAqIGNvdW50XCIgaXMgdGhlIG51bWJlciBvZiBkZXBlbmRlbmNpZXMgYSBnaXZlbiBwcm9wZXJ0eSBoYXMgYXNzdW1pbmcgaXQgaXMgYVxuICogY29tcHV0ZWQgcHJvcGVydHksIG90aGVyd2lzZSAwKS4gIEl0IGFsc28gcmV0dXJucyBhIHByZS1wb3B1bGF0ZWQgbGlzdCBvZlxuICogYHJlYWR5YCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBubyBkZXBlbmRlbmNpZXMgYW5kIGEgYHRvdGFsYCBjb3VudCwgd2hpY2ggaXNcbiAqIHVzZWQgZm9yIGVycm9yLWNoZWNraW5nIHRoZSBncmFwaC5cbiAqXG4gKiBVc2VkIGJ5IGBvcmRlcmVkQ29tcHV0ZWQ6IHRydWVgIGNvbXB1dGVkIHByb3BlcnR5IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgaW5zdGFuY2UgdG8gZ2VuZXJhdGUgZGVwZW5kZW5jeVxuICogICBjb3VudHMgZm9yLlxuICogQHJldHVybiB7IU9iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgYGNvdW50c2AgbWFwIChwcm9wZXJ0eS10by1kZXBlbmRlbmN5XG4gKiAgIGNvdW50KSBhbmQgcHJlLXBvcHVsYXRlZCBgcmVhZHlgIGFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCBoYWQgemVyb1xuICogICBkZXBlbmRlbmNpZXMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZGVuY3lDb3VudHMoaW5zdCkge1xuICBjb25zdCBpbmZvRm9yQ29tcHV0ZWQgPSBpbnN0W0NPTVBVVEVfSU5GT107XG4gIGNvbnN0IGNvdW50cyA9IHt9O1xuICBjb25zdCBjb21wdXRlZERlcHMgPSBpbnN0W1RZUEVTLkNPTVBVVEVdO1xuICBjb25zdCByZWFkeSA9IFtdO1xuICBsZXQgdG90YWwgPSAwO1xuICAvLyBDb3VudCBkZXBlbmRlbmNpZXMgZm9yIGVhY2ggY29tcHV0ZWQgcHJvcGVydHlcbiAgZm9yIChsZXQgcCBpbiBpbmZvRm9yQ29tcHV0ZWQpIHtcbiAgICBjb25zdCBpbmZvID0gaW5mb0ZvckNvbXB1dGVkW3BdO1xuICAgIC8vIEJlIHN1cmUgdG8gYWRkIHRoZSBtZXRob2QgbmFtZSBpdHNlbGYgaW4gY2FzZSBvZiBcImR5bmFtaWMgZnVuY3Rpb25zXCJcbiAgICB0b3RhbCArPSBjb3VudHNbcF0gPVxuICAgICAgaW5mby5hcmdzLmZpbHRlcihhID0+ICFhLmxpdGVyYWwpLmxlbmd0aCArIChpbmZvLmR5bmFtaWNGbiA/IDEgOiAwKTtcbiAgfVxuICAvLyBCdWlsZCBsaXN0IG9mIHJlYWR5IHByb3BlcnRpZXMgKHRoYXQgYXJlbid0IHRoZW1zZWx2ZXMgY29tcHV0ZWQpXG4gIGZvciAobGV0IHAgaW4gY29tcHV0ZWREZXBzKSB7XG4gICAgaWYgKCFpbmZvRm9yQ29tcHV0ZWRbcF0pIHtcbiAgICAgIHJlYWR5LnB1c2gocCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Y291bnRzLCByZWFkeSwgdG90YWx9O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFwiY29tcHV0ZWQgcHJvcGVydHlcIiBlZmZlY3QgYnkgcnVubmluZyB0aGUgbWV0aG9kIHdpdGggdGhlXG4gKiB2YWx1ZXMgb2YgdGhlIGFyZ3VtZW50cyBzcGVjaWZpZWQgaW4gdGhlIGBpbmZvYCBvYmplY3QgYW5kIHNldHRpbmcgdGhlXG4gKiByZXR1cm4gdmFsdWUgdG8gdGhlIGNvbXB1dGVkIHByb3BlcnR5IHNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7P09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7P09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIHdoZW4gdGhlIHByb3BlcnR5IGJlaW5nIGNvbXB1dGVkIGNoYW5nZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0KGluc3QsIHByb3BlcnR5LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIC8vIERpcnR5IGNoZWNrIGRlcGVuZGVuY2llcyBhbmQgcnVuIGlmIGFueSBpbnZhbGlkXG4gIGxldCByZXN1bHQgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGluZm8pO1xuICAvLyBBYm9ydCBpZiBtZXRob2QgcmV0dXJucyBhIG5vLW9wIHJlc3VsdFxuICBpZiAocmVzdWx0ID09PSBOT09QKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gIGlmIChpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yICYmIGluc3QuX19kYXRhSGFzQWNjZXNzb3JbY29tcHV0ZWRQcm9wXSkge1xuICAgIHJldHVybiBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkoY29tcHV0ZWRQcm9wLCByZXN1bHQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGluc3RbY29tcHV0ZWRQcm9wXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyBwYXRoIGNoYW5nZXMgYmFzZWQgb24gcGF0aCBsaW5rcyBzZXQgdXAgdXNpbmcgdGhlIGBsaW5rUGF0aHNgXG4gKiBBUEkuXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHdob3NlIHByb3BzIGFyZSBjaGFuZ2luZ1xuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0aGF0IGhhcyBjaGFuZ2VkXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIGNoYW5nZWQgcGF0aFxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVMaW5rZWRQYXRocyhpbnN0LCBwYXRoLCB2YWx1ZSkge1xuICBsZXQgbGlua3MgPSBpbnN0Ll9fZGF0YUxpbmtlZFBhdGhzO1xuICBpZiAobGlua3MpIHtcbiAgICBsZXQgbGluaztcbiAgICBmb3IgKGxldCBhIGluIGxpbmtzKSB7XG4gICAgICBsZXQgYiA9IGxpbmtzW2FdO1xuICAgICAgaWYgKGlzRGVzY2VuZGFudChhLCBwYXRoKSkge1xuICAgICAgICBsaW5rID0gdHJhbnNsYXRlKGEsIGIsIHBhdGgpO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Rlc2NlbmRhbnQoYiwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShiLCBhLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gLS0gYmluZGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgYmluZGluZyBtZXRhZGF0YSB0byB0aGUgY3VycmVudCBgbm9kZUluZm9gLCBhbmQgYmluZGluZyBlZmZlY3RzXG4gKiBmb3IgYWxsIHBhcnQgZGVwZW5kZW5jaWVzIHRvIGB0ZW1wbGF0ZUluZm9gLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAqICAgcnVubmluZyBvblxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCBCaW5kaW5nIGtpbmQsIGVpdGhlciAncHJvcGVydHknLCAnYXR0cmlidXRlJywgb3IgJ3RleHQnXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFRhcmdldCBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0geyFBcnJheTwhQmluZGluZ1BhcnQ+fSBwYXJ0cyBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbGl0ZXJhbCBMaXRlcmFsIHRleHQgc3Vycm91bmRpbmcgYmluZGluZyBwYXJ0cyAoc3BlY2lmaWVkXG4gKiAgIG9ubHkgZm9yICdwcm9wZXJ0eScgYmluZGluZ3MsIHNpbmNlIHRoZXNlIG11c3QgYmUgaW5pdGlhbGl6ZWQgYXMgcGFydFxuICogICBvZiBib290LXVwKVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgLy8gQ3JlYXRlIGJpbmRpbmcgbWV0YWRhdGEgYW5kIGFkZCB0byBub2RlSW5mb1xuICBub2RlSW5mby5iaW5kaW5ncyA9IG5vZGVJbmZvLmJpbmRpbmdzIHx8IFtdO1xuICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgbm9kZUluZm8uYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgLy8gQWRkIGxpc3RlbmVyIGluZm8gdG8gYmluZGluZyBtZXRhZGF0YVxuICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICBsZXQge2V2ZW50LCBuZWdhdGV9ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyRXZlbnQgPSBldmVudCB8fCAoY2FtZWxUb0Rhc2hDYXNlKHRhcmdldCkgKyAnLWNoYW5nZWQnKTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyTmVnYXRlID0gbmVnYXRlO1xuICB9XG4gIC8vIEFkZCBcInByb3BhZ2F0ZVwiIHByb3BlcnR5IGVmZmVjdHMgdG8gdGVtcGxhdGVJbmZvXG4gIGxldCBpbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QubGVuZ3RoO1xuICBmb3IgKGxldCBpPTA7IGk8YmluZGluZy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1tpXTtcbiAgICBwYXJ0LmNvbXBvdW5kSW5kZXggPSBpO1xuICAgIGFkZEVmZmVjdEZvckJpbmRpbmdQYXJ0KGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIGJpbmRpbmcsIHBhcnQsIGluZGV4KTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyB0byB0aGUgZ2l2ZW4gYHRlbXBsYXRlSW5mb2AgZm9yIHRoZSBnaXZlbiBiaW5kaW5nXG4gKiBwYXJ0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAqICAgcnVubmluZyBvblxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBpbnRvIGBub2RlSW5mb0xpc3RgIGZvciB0aGlzIG5vZGVcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGFkZEVmZmVjdEZvckJpbmRpbmdQYXJ0KGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIGJpbmRpbmcsIHBhcnQsIGluZGV4KSB7XG4gIGlmICghcGFydC5saXRlcmFsKSB7XG4gICAgaWYgKGJpbmRpbmcua2luZCA9PT0gJ2F0dHJpYnV0ZScgJiYgYmluZGluZy50YXJnZXRbMF0gPT09ICctJykge1xuICAgICAgY29uc29sZS53YXJuKCdDYW5ub3Qgc2V0IGF0dHJpYnV0ZSAnICsgYmluZGluZy50YXJnZXQgK1xuICAgICAgICAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIHN0YXJ0aW5nIGNoYXJhY3RlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVwZW5kZW5jaWVzID0gcGFydC5kZXBlbmRlbmNpZXM7XG4gICAgICBsZXQgaW5mbyA9IHsgaW5kZXgsIGJpbmRpbmcsIHBhcnQsIGV2YWx1YXRvcjogY29uc3RydWN0b3IgfTtcbiAgICAgIGZvciAobGV0IGo9MDsgajxkZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IHRyaWdnZXIgPSBkZXBlbmRlbmNpZXNbal07XG4gICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRyaWdnZXIgPSBwYXJzZUFyZyh0cmlnZ2VyKTtcbiAgICAgICAgICB0cmlnZ2VyLndpbGRjYXJkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvci5fYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHRyaWdnZXIucm9vdFByb3BlcnR5LCB7XG4gICAgICAgICAgZm46IHJ1bkJpbmRpbmdFZmZlY3QsXG4gICAgICAgICAgaW5mbywgdHJpZ2dlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImJpbmRpbmdcIiAocHJvcGVydHkvcGF0aCBiaW5kaW5nKSBlZmZlY3QuXG4gKlxuICogTm90ZSB0aGF0IGJpbmRpbmcgc3ludGF4IGlzIG92ZXJyaWRhYmxlIHZpYSBgX3BhcnNlQmluZGluZ3NgIGFuZFxuICogYF9ldmFsdWF0ZUJpbmRpbmdgLiAgVGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBfZXZhbHVhdGVCaW5kaW5nYCBmb3IgYW55XG4gKiBub24tbGl0ZXJhbCBwYXJ0cyByZXR1cm5lZCBmcm9tIGBfcGFyc2VCaW5kaW5nc2AuICBIb3dldmVyLFxuICogdGhlcmUgaXMgbm8gc3VwcG9ydCBmb3IgX3BhdGhfIGJpbmRpbmdzIHZpYSBjdXN0b20gYmluZGluZyBwYXJ0cyxcbiAqIGFzIHRoaXMgaXMgc3BlY2lmaWMgdG8gUG9seW1lcidzIHBhdGggYmluZGluZyBzeW50YXguXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlTGlzdCBMaXN0IG9mIG5vZGVzIGFzc29jaWF0ZWQgd2l0aCBgbm9kZUluZm9MaXN0YCB0ZW1wbGF0ZVxuICogICBtZXRhZGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkJpbmRpbmdFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocywgbm9kZUxpc3QpIHtcbiAgbGV0IG5vZGUgPSBub2RlTGlzdFtpbmZvLmluZGV4XTtcbiAgbGV0IGJpbmRpbmcgPSBpbmZvLmJpbmRpbmc7XG4gIGxldCBwYXJ0ID0gaW5mby5wYXJ0O1xuICAvLyBTdWJwYXRoIG5vdGlmaWNhdGlvbjogdHJhbnNmb3JtIHBhdGggYW5kIHNldCB0byBjbGllbnRcbiAgLy8gZS5nLjogZm9vPVwie3tvYmouc3VifX1cIiwgcGF0aDogJ29iai5zdWIucHJvcCcsIHNldCAnZm9vLnByb3AnPW9iai5zdWIucHJvcFxuICBpZiAoaGFzUGF0aHMgJiYgcGFydC5zb3VyY2UgJiYgKHBhdGgubGVuZ3RoID4gcGFydC5zb3VyY2UubGVuZ3RoKSAmJlxuICAgICAgKGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSAmJiAhYmluZGluZy5pc0NvbXBvdW5kICYmXG4gICAgICBub2RlLl9faXNQcm9wZXJ0eUVmZmVjdHNDbGllbnQgJiZcbiAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvcltiaW5kaW5nLnRhcmdldF0pIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twYXRoXTtcbiAgICBwYXRoID0gdHJhbnNsYXRlKHBhcnQuc291cmNlLCBiaW5kaW5nLnRhcmdldCwgcGF0aCk7XG4gICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgdmFsdWUgPSBpbmZvLmV2YWx1YXRvci5fZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgIC8vIFByb3BhZ2F0ZSB2YWx1ZSB0byBjaGlsZFxuICAgIC8vIEFib3J0IGlmIHZhbHVlIGlzIGEgbm8tb3AgcmVzdWx0XG4gICAgaWYgKHZhbHVlICE9PSBOT09QKSB7XG4gICAgICBhcHBseUJpbmRpbmdWYWx1ZShpbnN0LCBub2RlLCBiaW5kaW5nLCBwYXJ0LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGFuIFwiYmluZGluZ1wiIChiaW5kaW5nKSBlZmZlY3QgdG8gYSBub2RlLFxuICogZWl0aGVyIGFzIGEgcHJvcGVydHkgb3IgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IFRoZSBpbnN0YW5jZSBvd25pbmcgdGhlIGJpbmRpbmcgZWZmZWN0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGFyZ2V0IG5vZGUgZm9yIGJpbmRpbmdcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKSB7XG4gIHZhbHVlID0gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCk7XG4gIGlmIChzYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgdmFsdWUgPSBzYW5pdGl6ZURPTVZhbHVlKHZhbHVlLCBiaW5kaW5nLnRhcmdldCwgYmluZGluZy5raW5kLCBub2RlKTtcbiAgfVxuICBpZiAoYmluZGluZy5raW5kID09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gQXR0cmlidXRlIGJpbmRpbmdcbiAgICBpbnN0Ll92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovKG5vZGUpLCB2YWx1ZSwgYmluZGluZy50YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFByb3BlcnR5IGJpbmRpbmdcbiAgICBsZXQgcHJvcCA9IGJpbmRpbmcudGFyZ2V0O1xuICAgIGlmIChub2RlLl9faXNQcm9wZXJ0eUVmZmVjdHNDbGllbnQgJiZcbiAgICAgICAgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvciAmJiBub2RlLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BdKSB7XG4gICAgICBpZiAoIW5vZGVbVFlQRVMuUkVBRF9PTkxZXSB8fCAhbm9kZVtUWVBFUy5SRUFEX09OTFldW3Byb3BdKSB7XG4gICAgICAgIGlmIChub2RlLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcCwgdmFsdWUpKSB7XG4gICAgICAgICAgaW5zdC5fZW5xdWV1ZUNsaWVudChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBsZWdhY3kgbm8tYmF0Y2hpbmcgbW9kZSwgYmluZGluZ3MgYXBwbGllZCBiZWZvcmUgZGF0YVJlYWR5IGFyZVxuICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGUgXCJhcHBseSBjb25maWdcIiBwaGFzZSwgd2hpY2ggb25seSBzZXQgbWFuYWdlZCBwcm9wc1xuICAgICAgaW5zdC5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gXCJiaW5kaW5nXCIgZWZmZWN0IHZhbHVlIGJhc2VkIG9uIGNvbXBvdW5kICYgbmVnYXRpb25cbiAqIGVmZmVjdCBtZXRhZGF0YSwgYXMgd2VsbCBhcyBoYW5kbGluZyBmb3Igc3BlY2lhbC1jYXNlIHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0aGUgdmFsdWUgd2lsbCBiZSBzZXQgdG9cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHJldHVybiB7Kn0gVHJhbnNmb3JtZWQgdmFsdWUgdG8gc2V0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KSB7XG4gIGlmIChiaW5kaW5nLmlzQ29tcG91bmQpIHtcbiAgICBsZXQgc3RvcmFnZSA9IG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlW2JpbmRpbmcudGFyZ2V0XTtcbiAgICBzdG9yYWdlW3BhcnQuY29tcG91bmRJbmRleF0gPSB2YWx1ZTtcbiAgICB2YWx1ZSA9IHN0b3JhZ2Uuam9pbignJyk7XG4gIH1cbiAgaWYgKGJpbmRpbmcua2luZCAhPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAvLyBTb21lIGJyb3dzZXJzIHNlcmlhbGl6ZSBgdW5kZWZpbmVkYCB0byBgXCJ1bmRlZmluZWRcImBcbiAgICBpZiAoYmluZGluZy50YXJnZXQgPT09ICd0ZXh0Q29udGVudCcgfHxcbiAgICAgICAgKGJpbmRpbmcudGFyZ2V0ID09PSAndmFsdWUnICYmXG4gICAgICAgICAgKG5vZGUubG9jYWxOYW1lID09PSAnaW5wdXQnIHx8IG5vZGUubG9jYWxOYW1lID09PSAndGV4dGFyZWEnKSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGJpbmRpbmcncyBtZXRhZGF0YSBtZWV0cyBhbGwgdGhlIHJlcXVpcmVtZW50cyB0byBhbGxvd1xuICogMi13YXkgYmluZGluZywgYW5kIHRoZXJlZm9yZSBhIGA8cHJvcGVydHk+LWNoYW5nZWRgIGV2ZW50IGxpc3RlbmVyIHNob3VsZCBiZVxuICogYWRkZWQ6XG4gKiAtIHVzZWQgY3VybHkgYnJhY2VzXG4gKiAtIGlzIGEgcHJvcGVydHkgKG5vdCBhdHRyaWJ1dGUpIGJpbmRpbmdcbiAqIC0gaXMgbm90IGEgdGV4dENvbnRlbnQgYmluZGluZ1xuICogLSBpcyBub3QgY29tcG91bmRcbiAqXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgMi13YXkgbGlzdGVuZXIgc2hvdWxkIGJlIGFkZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaG91bGRBZGRMaXN0ZW5lcihiaW5kaW5nKSB7XG4gIHJldHVybiBCb29sZWFuKGJpbmRpbmcudGFyZ2V0KSAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICdhdHRyaWJ1dGUnICYmXG4gICAgICAgICBiaW5kaW5nLmtpbmQgIT0gJ3RleHQnICYmXG4gICAgICAgICAhYmluZGluZy5pc0NvbXBvdW5kICYmXG4gICAgICAgICBiaW5kaW5nLnBhcnRzWzBdLm1vZGUgPT09ICd7Jztcbn1cblxuLyoqXG4gKiBTZXR1cCBjb21wb3VuZCBiaW5kaW5nIHN0b3JhZ2Ugc3RydWN0dXJlcywgbm90aWZ5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0XG4gKiByZWZlcmVuY2VzIG9udG8gdGhlIGJvdW5kIG5vZGVMaXN0LlxuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IEluc3RhbmNlIHRoYXQgYmFzIGJlZW4gcHJldmlvdXNseVxuICogICAgIGJvdW5kXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBCaW5kaW5ncyhpbnN0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gIGxldCB7bm9kZUxpc3QsIG5vZGVJbmZvTGlzdH0gPSB0ZW1wbGF0ZUluZm87XG4gIGlmIChub2RlSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaW5mbyA9IG5vZGVJbmZvTGlzdFtpXTtcbiAgICAgIGxldCBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZyk7XG4gICAgICAgICAgYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgZW5zdXJlcyBhbGwgYm91bmQgZWxlbWVudHMgaGF2ZSBhIGhvc3Qgc2V0LCByZWdhcmRsZXNzXG4gICAgICAvLyBvZiB3aGV0aGVyIHRoZXkgdXBncmFkZSBzeW5jaHJvbm91cyB0byBjcmVhdGlvblxuICAgICAgbm9kZS5fX2RhdGFIb3N0ID0gaW5zdDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBgX19kYXRhQ29tcG91bmRTdG9yYWdlYCBsb2NhbCBzdG9yYWdlIG9uIGEgYm91bmQgbm9kZSB3aXRoXG4gKiBpbml0aWFsIGxpdGVyYWwgZGF0YSBmb3IgY29tcG91bmQgYmluZGluZ3MsIGFuZCBzZXRzIHRoZSBqb2luZWRcbiAqIGxpdGVyYWwgcGFydHMgdG8gdGhlIGJvdW5kIHByb3BlcnR5LlxuICpcbiAqIFdoZW4gY2hhbmdlcyB0byBjb21wb3VuZCBwYXJ0cyBvY2N1ciwgdGhleSBhcmUgZmlyc3Qgc2V0IGludG8gdGhlIGNvbXBvdW5kXG4gKiBzdG9yYWdlIGFycmF5IGZvciB0aGF0IHByb3BlcnR5LCBhbmQgdGhlbiB0aGUgYXJyYXkgaXMgam9pbmVkIHRvIHJlc3VsdCBpblxuICogdGhlIGZpbmFsIHZhbHVlIHNldCB0byB0aGUgcHJvcGVydHkvYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBCb3VuZCBub2RlIHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fFxuICAgICAgKG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlID0ge30pO1xuICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgLy8gQ29weSBsaXRlcmFscyBmcm9tIHBhcnRzIGludG8gc3RvcmFnZSBmb3IgdGhpcyBiaW5kaW5nXG4gICAgbGV0IGxpdGVyYWxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaXRlcmFsc1tqXSA9IHBhcnRzW2pdLmxpdGVyYWw7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBzdG9yYWdlW3RhcmdldF0gPSBsaXRlcmFscztcbiAgICAvLyBDb25maWd1cmUgcHJvcGVydGllcyB3aXRoIHRoZWlyIGxpdGVyYWwgcGFydHNcbiAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICAvLyBOb3RlLCBjbGFzc05hbWUgbmVlZHMgc3R5bGUgc2NvcGluZyBzbyB0aGlzIG5lZWRzIHdyYXBwaW5nLlxuICAgICAgLy8gV2UgbWF5IGFsc28gd2FudCB0byBjb25zaWRlciBkb2luZyB0aGlzIGZvciBgdGV4dENvbnRlbnRgIGFuZFxuICAgICAgLy8gYGlubmVySFRNTGAuXG4gICAgICBpZiAodGFyZ2V0ID09PSAnY2xhc3NOYW1lJykge1xuICAgICAgICBub2RlID0gd3JhcChub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGVbdGFyZ2V0XSA9IGJpbmRpbmcubGl0ZXJhbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGEgMi13YXkgYmluZGluZyBub3RpZmljYXRpb24gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG5vZGUgc3BlY2lmaWVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQ2hpbGQgZWxlbWVudCB0byBhZGQgbGlzdGVuZXIgdG9cbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGVcbiAqICAgICBub3RpZmljYXRpb24gZXZlbnRcbiAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5saXN0ZW5lckV2ZW50KSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmxpc3RlbmVyRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihlLCBpbnN0LCBiaW5kaW5nLnRhcmdldCwgcGFydC5zb3VyY2UsIHBhcnQubmVnYXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyBmb3IgZWFjaCBhcmd1bWVudCBpbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSAoYW5kXG4gKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICogcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHByb3BlcnR5IGVmZmVjdCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAqIEBwYXJhbSB7Kj19IG1ldGhvZEluZm8gRWZmZWN0LXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluXG4gKiAgIG1ldGhvZCBlZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LiBOb3RlLFxuICogICBkZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgc3RhdGljIChzaWcuc3RhdGljIGlzIHRydWUpLlxuICogQHJldHVybiB7IU9iamVjdH0gRWZmZWN0IG1ldGFkYXRhIGZvciB0aGlzIG1ldGhvZCBlZmZlY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZEVmZmVjdChtb2RlbCwgc2lnLCB0eXBlLCBlZmZlY3RGbiwgbWV0aG9kSW5mbywgZHluYW1pY0ZuKSB7XG4gIGR5bmFtaWNGbiA9IHNpZy5zdGF0aWMgfHwgKGR5bmFtaWNGbiAmJlxuICAgICh0eXBlb2YgZHluYW1pY0ZuICE9PSAnb2JqZWN0JyB8fCBkeW5hbWljRm5bc2lnLm1ldGhvZE5hbWVdKSk7XG4gIGxldCBpbmZvID0ge1xuICAgIG1ldGhvZE5hbWU6IHNpZy5tZXRob2ROYW1lLFxuICAgIGFyZ3M6IHNpZy5hcmdzLFxuICAgIG1ldGhvZEluZm8sXG4gICAgZHluYW1pY0ZuXG4gIH07XG4gIGZvciAobGV0IGk9MCwgYXJnOyAoaTxzaWcuYXJncy5sZW5ndGgpICYmIChhcmc9c2lnLmFyZ3NbaV0pOyBpKyspIHtcbiAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICBtb2RlbC5fYWRkUHJvcGVydHlFZmZlY3QoYXJnLnJvb3RQcm9wZXJ0eSwgdHlwZSwge1xuICAgICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm8sIHRyaWdnZXI6IGFyZ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChkeW5hbWljRm4pIHtcbiAgICBtb2RlbC5fYWRkUHJvcGVydHlFZmZlY3Qoc2lnLm1ldGhvZE5hbWUsIHR5cGUsIHtcbiAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mb1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIHdpdGggYXJndW1lbnRzIG1hcnNoYWxlZCBmcm9tIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlXG4gKiBiYXNlZCBvbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSBjb250YWluZWQgaW4gdGhlIGVmZmVjdCBtZXRhZGF0YS5cbiAqXG4gKiBNdWx0aS1wcm9wZXJ0eSBvYnNlcnZlcnMsIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gKiBmdW5jdGlvbnMgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGludm9rZSB0aGUgbWV0aG9kLCB0aGVuIHVzZSB0aGUgcmV0dXJuXG4gKiB2YWx1ZSBhY2NvcmRpbmdseS5cbiAqXG4gKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbWV0aG9kIGludm9jYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBsZXQgY29udGV4dCA9IGluc3QuX21ldGhvZEhvc3QgfHwgaW5zdDtcbiAgbGV0IGZuID0gY29udGV4dFtpbmZvLm1ldGhvZE5hbWVdO1xuICBpZiAoZm4pIHtcbiAgICBsZXQgYXJncyA9IGluc3QuX21hcnNoYWxBcmdzKGluZm8uYXJncywgcHJvcGVydHksIHByb3BzKTtcbiAgICByZXR1cm4gYXJncyA9PT0gTk9PUCA/IE5PT1AgOiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIGlmICghaW5mby5keW5hbWljRm4pIHtcbiAgICBjb25zb2xlLndhcm4oJ21ldGhvZCBgJyArIGluZm8ubWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gIH1cbn1cblxuY29uc3QgZW1wdHlBcnJheSA9IFtdO1xuXG4vLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgZm9yIGJpbmRpbmdcbmNvbnN0IElERU5UICA9ICcoPzonICsgJ1thLXpBLVpfJF1bXFxcXHcuOiRcXFxcLSpdKicgKyAnKSc7XG5jb25zdCBOVU1CRVIgPSAnKD86JyArICdbLStdP1swLTldKlxcXFwuP1swLTldKyg/OltlRV1bLStdP1swLTldKyk/JyArICcpJztcbmNvbnN0IFNRVU9URV9TVFJJTkcgPSAnKD86JyArICdcXCcoPzpbXlxcJ1xcXFxcXFxcXXxcXFxcXFxcXC4pKlxcJycgKyAnKSc7XG5jb25zdCBEUVVPVEVfU1RSSU5HID0gJyg/OicgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcLikqXCInICsgJyknO1xuY29uc3QgU1RSSU5HID0gJyg/OicgKyBTUVVPVEVfU1RSSU5HICsgJ3wnICsgRFFVT1RFX1NUUklORyArICcpJztcbmNvbnN0IEFSR1VNRU5UID0gJyg/OignICsgSURFTlQgKyAnfCcgKyBOVU1CRVIgKyAnfCcgKyAgU1RSSU5HICsgJylcXFxccyonICsgJyknO1xuY29uc3QgQVJHVU1FTlRTID0gJyg/OicgKyBBUkdVTUVOVCArICcoPzosXFxcXHMqJyArIEFSR1VNRU5UICsgJykqJyArICcpJztcbmNvbnN0IEFSR1VNRU5UX0xJU1QgPSAnKD86JyArICdcXFxcKFxcXFxzKicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBBUkdVTUVOVFMgKyAnPycgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcKVxcXFxzKicgKyAnKSc7XG5jb25zdCBCSU5ESU5HID0gJygnICsgSURFTlQgKyAnXFxcXHMqJyArIEFSR1VNRU5UX0xJU1QgKyAnPycgKyAnKSc7IC8vIEdyb3VwIDNcbmNvbnN0IE9QRU5fQlJBQ0tFVCA9ICcoXFxcXFtcXFxcW3x7eyknICsgJ1xcXFxzKic7XG5jb25zdCBDTE9TRV9CUkFDS0VUID0gJyg/Ol1dfH19KSc7XG5jb25zdCBORUdBVEUgPSAnKD86KCEpXFxcXHMqKT8nOyAvLyBHcm91cCAyXG5jb25zdCBFWFBSRVNTSU9OID0gT1BFTl9CUkFDS0VUICsgTkVHQVRFICsgQklORElORyArIENMT1NFX0JSQUNLRVQ7XG5jb25zdCBiaW5kaW5nUmVnZXggPSBuZXcgUmVnRXhwKEVYUFJFU1NJT04sIFwiZ1wiKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzdHJpbmcgZnJvbSBiaW5kaW5nIHBhcnRzIG9mIGFsbCB0aGUgbGl0ZXJhbCBwYXJ0c1xuICpcbiAqIEBwYXJhbSB7IUFycmF5PEJpbmRpbmdQYXJ0Pn0gcGFydHMgQWxsIHBhcnRzIHRvIHN0cmluZ2lmeVxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgbWFkZSBmcm9tIHRoZSBsaXRlcmFsIHBhcnRzXG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHtcbiAgbGV0IHMgPSAnJztcbiAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGxpdGVyYWwgPSBwYXJ0c1tpXS5saXRlcmFsO1xuICAgIHMgKz0gbGl0ZXJhbCB8fCAnJztcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gZXhwcmVzc2lvbiBzdHJpbmcgZm9yIGEgbWV0aG9kIHNpZ25hdHVyZSwgYW5kIHJldHVybnMgYSBtZXRhZGF0YVxuICogZGVzY3JpYmluZyB0aGUgbWV0aG9kIGluIHRlcm1zIG9mIGBtZXRob2ROYW1lYCwgYHN0YXRpY2AgKHdoZXRoZXIgYWxsIHRoZVxuICogYXJndW1lbnRzIGFyZSBsaXRlcmFscyksIGFuZCBhbiBhcnJheSBvZiBgYXJnc2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byBwYXJzZVxuICogQHJldHVybiB7P01ldGhvZFNpZ25hdHVyZX0gVGhlIG1ldGhvZCBtZXRhZGF0YSBvYmplY3QgaWYgYSBtZXRob2QgZXhwcmVzc2lvbiB3YXNcbiAqICAgZm91bmQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXRob2QoZXhwcmVzc2lvbikge1xuICAvLyB0cmllcyB0byBtYXRjaCB2YWxpZCBqYXZhc2NyaXB0IHByb3BlcnR5IG5hbWVzXG4gIGxldCBtID0gZXhwcmVzc2lvbi5tYXRjaCgvKFteXFxzXSs/KVxcKChbXFxzXFxTXSopXFwpLyk7XG4gIGlmIChtKSB7XG4gICAgbGV0IG1ldGhvZE5hbWUgPSBtWzFdO1xuICAgIGxldCBzaWcgPSB7IG1ldGhvZE5hbWUsIHN0YXRpYzogdHJ1ZSwgYXJnczogZW1wdHlBcnJheSB9O1xuICAgIGlmIChtWzJdLnRyaW0oKSkge1xuICAgICAgLy8gcmVwbGFjZSBlc2NhcGVkIGNvbW1hcyB3aXRoIGNvbW1hIGVudGl0eSwgc3BsaXQgb24gdW4tZXNjYXBlZCBjb21tYXNcbiAgICAgIGxldCBhcmdzID0gbVsyXS5yZXBsYWNlKC9cXFxcLC9nLCAnJmNvbW1hOycpLnNwbGl0KCcsJyk7XG4gICAgICByZXR1cm4gcGFyc2VBcmdzKGFyZ3MsIHNpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaWc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgYW5kIHNldHMgdGhlIGBhcmdzYCBwcm9wZXJ0eSBvZiB0aGUgc3VwcGxpZWRcbiAqIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3QuIFNldHMgdGhlIGBzdGF0aWNgIHByb3BlcnR5IHRvIGZhbHNlIGlmIGFueVxuICogYXJndW1lbnQgaXMgYSBub24tbGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBhcmdMaXN0IEFycmF5IG9mIGFyZ3VtZW50IG5hbWVzXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICogQHJldHVybiB7IU1ldGhvZFNpZ25hdHVyZX0gVGhlIHVwZGF0ZWQgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcmdzKGFyZ0xpc3QsIHNpZykge1xuICBzaWcuYXJncyA9IGFyZ0xpc3QubWFwKGZ1bmN0aW9uKHJhd0FyZykge1xuICAgIGxldCBhcmcgPSBwYXJzZUFyZyhyYXdBcmcpO1xuICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgIHNpZy5zdGF0aWMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfSwgdGhpcyk7XG4gIHJldHVybiBzaWc7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGluZGl2aWR1YWwgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFuIGFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqXG4gKiAgIHtcbiAqICAgICB2YWx1ZTogJ3Byb3AnLCAgICAgICAgLy8gcHJvcGVydHkvcGF0aCBvciBsaXRlcmFsIHZhbHVlXG4gKiAgICAgbGl0ZXJhbDogZmFsc2UsICAgICAgIC8vIHdoZXRoZXIgYXJndW1lbnQgaXMgYSBsaXRlcmFsXG4gKiAgICAgc3RydWN0dXJlZDogZmFsc2UsICAgIC8vIHdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIGEgcGF0aFxuICogICAgIHJvb3RQcm9wZXJ0eTogJ3Byb3AnLCAvLyB0aGUgcm9vdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aFxuICogICAgIHdpbGRjYXJkOiBmYWxzZSAgICAgICAvLyB3aGV0aGVyIHRoZSBhcmd1bWVudCB3YXMgYSB3aWxkY2FyZCAnLionIHBhdGhcbiAqICAgfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdBcmcgVGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAqIEByZXR1cm4geyFNZXRob2RBcmd9IEFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcmcocmF3QXJnKSB7XG4gIC8vIGNsZWFuIHVwIHdoaXRlc3BhY2VcbiAgbGV0IGFyZyA9IHJhd0FyZy50cmltKClcbiAgICAvLyByZXBsYWNlIGNvbW1hIGVudGl0eSB3aXRoIGNvbW1hXG4gICAgLnJlcGxhY2UoLyZjb21tYTsvZywgJywnKVxuICAgIC8vIHJlcGFpciBleHRyYSBlc2NhcGUgc2VxdWVuY2VzOyBub3RlIG9ubHkgY29tbWFzIHN0cmljdGx5IG5lZWRcbiAgICAvLyBlc2NhcGluZywgYnV0IHdlIGFsbG93IGFueSBvdGhlciBjaGFyIHRvIGJlIGVzY2FwZWQgc2luY2UgaXRzXG4gICAgLy8gbGlrZWx5IHVzZXJzIHdpbGwgZG8gdGhpc1xuICAgIC5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG4gICAgO1xuICAvLyBiYXNpYyBhcmd1bWVudCBkZXNjcmlwdG9yXG4gIGxldCBhID0ge1xuICAgIG5hbWU6IGFyZyxcbiAgICB2YWx1ZTogJycsXG4gICAgbGl0ZXJhbDogZmFsc2VcbiAgfTtcbiAgLy8gZGV0ZWN0IGxpdGVyYWwgdmFsdWUgKG11c3QgYmUgU3RyaW5nIG9yIE51bWJlcilcbiAgbGV0IGZjID0gYXJnWzBdO1xuICBpZiAoZmMgPT09ICctJykge1xuICAgIGZjID0gYXJnWzFdO1xuICB9XG4gIGlmIChmYyA+PSAnMCcgJiYgZmMgPD0gJzknKSB7XG4gICAgZmMgPSAnIyc7XG4gIH1cbiAgc3dpdGNoKGZjKSB7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6XG4gICAgICBhLnZhbHVlID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGEudmFsdWUgPSBOdW1iZXIoYXJnKTtcbiAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgfVxuICAvLyBpZiBub3QgbGl0ZXJhbCwgbG9vayBmb3Igc3RydWN0dXJlZCBwYXRoXG4gIGlmICghYS5saXRlcmFsKSB7XG4gICAgYS5yb290UHJvcGVydHkgPSByb290KGFyZyk7XG4gICAgLy8gZGV0ZWN0IHN0cnVjdHVyZWQgcGF0aCAoaGFzIGRvdHMpXG4gICAgYS5zdHJ1Y3R1cmVkID0gaXNQYXRoKGFyZyk7XG4gICAgaWYgKGEuc3RydWN0dXJlZCkge1xuICAgICAgYS53aWxkY2FyZCA9IChhcmcuc2xpY2UoLTIpID09ICcuKicpO1xuICAgICAgaWYgKGEud2lsZGNhcmQpIHtcbiAgICAgICAgYS5uYW1lID0gYXJnLnNsaWNlKDAsIC0yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGdldEFyZ1ZhbHVlKGRhdGEsIHByb3BzLCBwYXRoKSB7XG4gIGxldCB2YWx1ZSA9IGdldChkYXRhLCBwYXRoKTtcbiAgLy8gd2hlbiBkYXRhIGlzIG5vdCBzdG9yZWQgZS5nLiBgc3BsaWNlc2AsIGdldCB0aGUgdmFsdWUgZnJvbSBjaGFuZ2VkUHJvcHNcbiAgLy8gVE9ETyhrc2NoYWFmKTogTm90ZSwgdGhpcyBjYW4gY2F1c2UgYSByYXJlIGlzc3VlIHdoZXJlIHRoZSB3aWxkY2FyZFxuICAvLyBpbmZvLnZhbHVlIGNvdWxkIHB1bGwgYSBzdGFsZSB2YWx1ZSBvdXQgb2YgY2hhbmdlZFByb3BzIGR1cmluZyBhIHJlZW50cmFudFxuICAvLyBjaGFuZ2UgdGhhdCBzZXRzIHRoZSB2YWx1ZSBiYWNrIHRvIHVuZGVmaW5lZC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNTQ3OVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gcHJvcHNbcGF0aF07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBkYXRhIGFwaVxuXG4vKipcbiAqIFNlbmRzIGFycmF5IHNwbGljZSBub3RpZmljYXRpb25zIChgLnNwbGljZXNgIGFuZCBgLmxlbmd0aGApXG4gKlxuICogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgbm9ybWFsaXplZCBwYXRoc1xuICpcbiAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgc3BsaWNlcykge1xuICBjb25zdCBzcGxpY2VzRGF0YSA9IHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH07XG4gIC8vIExlZ2FjeSBiZWhhdmlvciBzdG9yZWQgc3BsaWNlcyBpbiBgX19kYXRhX19gIHNvIGl0IHdhcyAqbm90KiBlcGhlbWVyYWwuXG4gIC8vIFRvIG1hdGNoIHRoaXMgYmVoYXZpb3IsIHdlIHN0b3JlIHNwbGljZXMgZGlyZWN0bHkgb24gdGhlIGFycmF5LlxuICBpZiAobGVnYWN5VW5kZWZpbmVkICYmICFpbnN0Ll9vdmVycmlkZUxlZ2FjeVVuZGVmaW5lZCkge1xuICAgIGFycmF5LnNwbGljZXMgPSBzcGxpY2VzRGF0YTtcbiAgfVxuICBpbnN0Lm5vdGlmeVBhdGgocGF0aCArICcuc3BsaWNlcycsIHNwbGljZXNEYXRhKTtcbiAgaW5zdC5ub3RpZnlQYXRoKHBhdGggKyAnLmxlbmd0aCcsIGFycmF5Lmxlbmd0aCk7XG4gIC8vIENsZWFyIHNwbGljZSBkYXRhIG9ubHkgd2hlbiBpdCdzIHN0b3JlZCBvbiB0aGUgYXJyYXkuXG4gIGlmIChsZWdhY3lVbmRlZmluZWQgJiYgIWluc3QuX292ZXJyaWRlTGVnYWN5VW5kZWZpbmVkKSB7XG4gICAgc3BsaWNlc0RhdGEuaW5kZXhTcGxpY2VzID0gW107XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAqIHRoZSBkZXNjcmliZWQgbXV0YXRpb25cbiAqXG4gKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gKlxuICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdGhlIG11dGF0aW9ucyBvY2N1cnJlZCBvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gdGhlIGFycmF5IHRoYXQgd2FzIG11dGF0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0aGUgYXJyYXkgbXV0YXRpb24gb2NjdXJyZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlZENvdW50IE51bWJlciBvZiBhZGRlZCBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gcmVtb3ZlZCBBcnJheSBvZiByZW1vdmVkIGl0ZW1zXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm90aWZ5U3BsaWNlKGluc3QsIGFycmF5LCBwYXRoLCBpbmRleCwgYWRkZWRDb3VudCwgcmVtb3ZlZCkge1xuICBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBbe1xuICAgIGluZGV4OiBpbmRleCxcbiAgICBhZGRlZENvdW50OiBhZGRlZENvdW50LFxuICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgb2JqZWN0OiBhcnJheSxcbiAgICB0eXBlOiAnc3BsaWNlJ1xuICB9XSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiB1cHBlci1jYXNlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3RyaW5nIHRvIHVwcGVyY2FzZVxuICogQHJldHVybiB7c3RyaW5nfSBVcHBlcmNhc2VkIHN0cmluZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBwZXIobmFtZSkge1xuICByZXR1cm4gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogRWxlbWVudCBjbGFzcyBtaXhpbiB0aGF0IHByb3ZpZGVzIG1ldGEtcHJvZ3JhbW1pbmcgZm9yIFBvbHltZXIncyB0ZW1wbGF0ZVxuICogYmluZGluZyBhbmQgZGF0YSBvYnNlcnZhdGlvbiAoY29sbGVjdGl2ZWx5LCBcInByb3BlcnR5IGVmZmVjdHNcIikgc3lzdGVtLlxuICpcbiAqIFRoaXMgbWl4aW4gdXNlcyBwcm92aWRlcyB0aGUgZm9sbG93aW5nIGtleSBzdGF0aWMgbWV0aG9kcyBmb3IgYWRkaW5nXG4gKiBwcm9wZXJ0eSBlZmZlY3RzIHRvIGFuIGVsZW1lbnQgY2xhc3M6XG4gKiAtIGBhZGRQcm9wZXJ0eUVmZmVjdGBcbiAqIC0gYGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXJgXG4gKiAtIGBjcmVhdGVNZXRob2RPYnNlcnZlcmBcbiAqIC0gYGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5YFxuICogLSBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWBcbiAqIC0gYGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5YFxuICogLSBgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eWBcbiAqIC0gYGJpbmRUZW1wbGF0ZWBcbiAqXG4gKiBFYWNoIG1ldGhvZCBjcmVhdGVzIG9uZSBvciBtb3JlIHByb3BlcnR5IGFjY2Vzc29ycywgYWxvbmcgd2l0aCBtZXRhZGF0YVxuICogdXNlZCBieSB0aGlzIG1peGluJ3MgaW1wbGVtZW50YXRpb24gb2YgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgdG8gcGVyZm9ybVxuICogdGhlIHByb3BlcnR5IGVmZmVjdHMuXG4gKlxuICogVW5kZXJzY29yZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlIG1ldGhvZHMgYWxzbyBleGlzdCBvbiB0aGUgZWxlbWVudFxuICogcHJvdG90eXBlIGZvciBhZGRpbmcgcHJvcGVydHkgZWZmZWN0cyBvbiBpbnN0YW5jZXMgYXQgcnVudGltZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtaXhpbiBvdmVycmlkZXMgc2V2ZXJhbCBgUHJvcGVydHlBY2Nlc3NvcnNgIG1ldGhvZHMsIGluXG4gKiBtYW55IGNhc2VzIHRvIG1haW50YWluIGd1YXJhbnRlZXMgcHJvdmlkZWQgYnkgdGhlIFBvbHltZXIgMS54IGZlYXR1cmVzO1xuICogbm90YWJseSBpdCBjaGFuZ2VzIHByb3BlcnR5IGFjY2Vzc29ycyB0byBiZSBzeW5jaHJvbm91cyBieSBkZWZhdWx0XG4gKiB3aGVyZWFzIHRoZSBkZWZhdWx0IHdoZW4gdXNpbmcgYFByb3BlcnR5QWNjZXNzb3JzYCBzdGFuZGFsb25lIGlzIHRvIGJlXG4gKiBhc3luYyBieSBkZWZhdWx0LlxuICpcbiAqIEBtaXhpbkZ1bmN0aW9uXG4gKiBAcG9seW1lclxuICogQGFwcGxpZXNNaXhpbiBUZW1wbGF0ZVN0YW1wXG4gKiBAYXBwbGllc01peGluIFByb3BlcnR5QWNjZXNzb3JzXG4gKiBAc3VtbWFyeSBFbGVtZW50IGNsYXNzIG1peGluIHRoYXQgcHJvdmlkZXMgbWV0YS1wcm9ncmFtbWluZyBmb3IgUG9seW1lcidzXG4gKiB0ZW1wbGF0ZSBiaW5kaW5nIGFuZCBkYXRhIG9ic2VydmF0aW9uIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGNvbnN0IFByb3BlcnR5RWZmZWN0cyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFRlbXBsYXRlU3RhbXAoUHJvcGVydHlBY2Nlc3NvcnMoc3VwZXJDbGFzcykpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqIEBleHRlbmRzIHtwcm9wZXJ0eUVmZmVjdHNCYXNlfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUVmZmVjdHMgZXh0ZW5kcyBwcm9wZXJ0eUVmZmVjdHNCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIC8vIFVzZWQgdG8gaWRlbnRpZnkgdXNlcnMgb2YgdGhpcyBtaXhpbiwgYWxhIGluc3RhbmNlb2ZcbiAgICAgIHRoaXMuX19pc1Byb3BlcnR5RWZmZWN0c0NsaWVudCA9IHRydWU7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeTtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5O1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2U7XG4gICAgICAvKiogQHR5cGUge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfSAqL1xuICAgICAgdGhpcy5fX2RhdGFIb3N0O1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFUZW1wO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzSW5pdGlhbGl6ZWQ7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YTtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdHxudWxsfSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19jb21wdXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2NvbXB1dGVJbmZvO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fcmVmbGVjdEVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19ub3RpZnlFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fcHJvcGFnYXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX29ic2VydmVFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fcmVhZE9ubHk7XG4gICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fb3ZlcnJpZGVMZWdhY3lVbmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0IFBST1BFUlRZX0VGRkVDVF9UWVBFUygpIHtcbiAgICAgIHJldHVybiBUWVBFUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgdGhpcy5fcmVnaXN0ZXJIb3N0KCk7XG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgLy8gTWF5IGJlIHNldCBvbiBpbnN0YW5jZSBwcmlvciB0byB1cGdyYWRlXG4gICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlIHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QgfHwgbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfcmVnaXN0ZXJIb3N0KCkge1xuICAgICAgaWYgKGhvc3RTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGhvc3QgPSBob3N0U3RhY2tbaG9zdFN0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgaG9zdC5fZW5xdWV1ZUNsaWVudCh0aGlzKTtcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGV2ZW4gbm9uLWJvdW5kIGVsZW1lbnRzIGhhdmUgYSBob3N0IHNldCwgYXNcbiAgICAgICAgLy8gbG9uZyBhcyB0aGV5IHVwZ3JhZGUgc3luY2hyb25vdXNseVxuICAgICAgICB0aGlzLl9fZGF0YUhvc3QgPSBob3N0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIHByb3ZpZGUgYVxuICAgICAqIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIGluaXRpYWxpemluZyBwcm9wZXJ0aWVzIGZyb21cbiAgICAgKiB0aGUgcHJvdG90eXBlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb24gdGhlIHByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIHRoaXMuX19kYXRhID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgc2V0dGluZ1xuICAgICAqIGBfc2V0UHJvcGVydHlgJ3MgYHNob3VsZE5vdGlmeTogdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIGxldCByZWFkT25seSA9IHRoaXNbVFlQRVMuUkVBRF9PTkxZXTtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKCFyZWFkT25seSB8fCAhcmVhZE9ubHlbcHJvcF0pIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB0aGlzLl9fZGF0YVBlbmRpbmcgfHwge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB0aGlzLl9fZGF0YU9sZCB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wXSA9IHRoaXMuX19kYXRhUGVuZGluZ1twcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvdG90eXBlIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBhZGRQcm9wZXJ0eUVmZmVjdGAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCB0eXBlID09IFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSwgdHJ1ZSlbcHJvcGVydHldO1xuICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcHJvcGVydHkgZWZmZWN0LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoZSBlZmZlY3Qgd2FzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9yZW1vdmVQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICBsZXQgZWZmZWN0cyA9IGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCB0eXBlLCB0cnVlKVtwcm9wZXJ0eV07XG4gICAgICBsZXQgaWR4ID0gZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgZWZmZWN0cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIHByb3BlcnR5IGVmZmVjdFxuICAgICAqIG9mIGEgY2VydGFpbiB0eXBlLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzXG4gICAgICogICAgIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlKSB7XG4gICAgICBsZXQgZWZmZWN0cyA9IHRoaXNbdHlwZV07XG4gICAgICByZXR1cm4gQm9vbGVhbihlZmZlY3RzICYmIGVmZmVjdHNbcHJvcGVydHldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwicmVhZCBvbmx5XCJcbiAgICAgKiBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzXG4gICAgICogICAgIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc1JlYWRPbmx5RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcIm5vdGlmeVwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXNcbiAgICAgKiAgICAgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzTm90aWZ5RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk5PVElGWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlZmxlY3QgdG9cbiAgICAgKiBhdHRyaWJ1dGVcIiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpc1xuICAgICAqICAgICB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWZsZWN0RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJjb21wdXRlZFwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXNcbiAgICAgKiAgICAgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzQ29tcHV0ZWRFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuQ09NUFVURSk7XG4gICAgfVxuXG4gICAgLy8gUnVudGltZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgcGVuZGluZyBwcm9wZXJ0eSBvciBwYXRoLiAgSWYgdGhlIHJvb3QgcHJvcGVydHkgb2YgdGhlIHBhdGggaW5cbiAgICAgKiBxdWVzdGlvbiBoYWQgbm8gYWNjZXNzb3IsIHRoZSBwYXRoIGlzIHNldCwgb3RoZXJ3aXNlIGl0IGlzIGVucXVldWVkXG4gICAgICogdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXNvbGF0ZXMgcmVsYXRpdmVseSBleHBlbnNpdmUgZnVuY3Rpb25hbGl0eSBuZWNlc3NhcnlcbiAgICAgKiBmb3IgdGhlIHB1YmxpYyBBUEkgKGBzZXRgLCBgc2V0UHJvcGVydGllc2AsIGBub3RpZnlQYXRoYCwgYW5kIHByb3BlcnR5XG4gICAgICogY2hhbmdlIGxpc3RlbmVycyB2aWEge3suLi59fSBiaW5kaW5ncyksIHN1Y2ggdGhhdCBpdCBpcyBvbmx5IGRvbmVcbiAgICAgKiB3aGVuIHBhdGhzIGVudGVyIHRoZSBzeXN0ZW0sIGFuZCBub3QgYXQgZXZlcnkgcHJvcGFnYXRpb24gc3RlcC4gIEl0XG4gICAgICogYWxzbyBzZXRzIGEgYF9fZGF0YUhhc1BhdGhzYCBmbGFnIG9uIHRoZSBpbnN0YW5jZSB3aGljaCBpcyB1c2VkIHRvXG4gICAgICogZmFzdC1wYXRoIHNsb3dlciBwYXRoLW1hdGNoaW5nIGNvZGUgaW4gdGhlIHByb3BlcnR5IGVmZmVjdHMgaG9zdCBwYXRocy5cbiAgICAgKlxuICAgICAqIGBwYXRoYCBjYW4gYmUgYSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBwYXRoIHBhcnRzIGFzIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAqIHB1YmxpYyBBUEkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gcGF0aCBQYXRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkTm90aWZ5IFNldCB0byB0cnVlIGlmIHRoaXMgY2hhbmdlIHNob3VsZFxuICAgICAqICBjYXVzZSBhIHByb3BlcnR5IG5vdGlmaWNhdGlvbiBldmVudCBkaXNwYXRjaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUGF0aE5vdGlmaWNhdGlvbiBJZiB0aGUgcGF0aCBiZWluZyBzZXQgaXMgYSBwYXRoXG4gICAgICogICBub3RpZmljYXRpb24gb2YgYW4gYWxyZWFkeSBjaGFuZ2VkIHZhbHVlLCBhcyBvcHBvc2VkIHRvIGEgcmVxdWVzdFxuICAgICAqICAgdG8gc2V0IGFuZCBub3RpZnkgdGhlIGNoYW5nZS4gIEluIHRoZSBsYXR0ZXIgYGZhbHNlYCBjYXNlLCBhIGRpcnR5XG4gICAgICogICBjaGVjayBpcyBwZXJmb3JtZWQgYW5kIHRoZW4gdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgcGF0aCBiZWZvcmVcbiAgICAgKiAgIGVucXVldWluZyB0aGUgcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2UuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eS9wYXRoIHdhcyBlbnF1ZXVlZCBpblxuICAgICAqICAgdGhlIHBlbmRpbmcgY2hhbmdlcyBiYWcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHNob3VsZE5vdGlmeSwgaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICBpZiAoaXNQYXRoTm90aWZpY2F0aW9uIHx8XG4gICAgICAgICAgcm9vdChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGgpICE9PSBwYXRoKSB7XG4gICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgcGF0aHMgaW50byB0aGUgc3lzdGVtOyBmcm9tIGhlcmVcbiAgICAgICAgLy8gdGhlIG9ubHkgZGlydHkgY2hlY2tzIGFyZSBhZ2FpbnN0IHRoZSBgX19kYXRhVGVtcGAgY2FjaGUgdG8gcHJldmVudFxuICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIC8vIG9mIGEgY2hhbmdlIGFscmVhZHkgc2V0IHRvIGEgcGF0aCAoaXNQYXRoTm90aWZpY2F0aW9uOiB0cnVlKSxcbiAgICAgICAgLy8gd2UgYWx3YXlzIGxldCB0aGUgY2hhbmdlIHRocm91Z2ggYW5kIHNraXAgdGhlIGBzZXRgIHNpbmNlIGl0IHdhc1xuICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmICghaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbGV0IG9sZCA9IGdldCh0aGlzLCBwYXRoKTtcbiAgICAgICAgICBwYXRoID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChzZXQodGhpcywgcGF0aCwgdmFsdWUpKTtcbiAgICAgICAgICAvLyBVc2UgcHJvcGVydHktYWNjZXNzb3IncyBzaW1wbGVyIGRpcnR5IGNoZWNrXG4gICAgICAgICAgaWYgKCFwYXRoIHx8ICFzdXBlci5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocGF0aCwgdmFsdWUsIG9sZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoLyoqQHR5cGV7c3RyaW5nfSovKHBhdGgpLCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSkge1xuICAgICAgICAgIGNvbXB1dGVMaW5rZWRQYXRocyh0aGlzLCAvKipAdHlwZXtzdHJpbmd9Ki8gKHBhdGgpLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcGF0aF0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1twYXRoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHZhbHVlIHRvIGEgbm9uLVBvbHltZXIgZWxlbWVudC9ub2RlJ3MgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gbWFrZXMgYSBiZXN0LWVmZm9ydCBhdCBiaW5kaW5nIGludGVyb3A6XG4gICAgICogU29tZSBuYXRpdmUgZWxlbWVudCBwcm9wZXJ0aWVzIGhhdmUgc2lkZS1lZmZlY3RzIHdoZW5cbiAgICAgKiByZS1zZXR0aW5nIHRoZSBzYW1lIHZhbHVlIChlLmcuIHNldHRpbmcgYDxpbnB1dD4udmFsdWVgIHJlc2V0cyB0aGVcbiAgICAgKiBjdXJzb3IgcG9zaXRpb24pLCBzbyB3ZSBkbyBhIGRpcnR5LWNoZWNrIGJlZm9yZSBzZXR0aW5nIHRoZSB2YWx1ZS5cbiAgICAgKiBIb3dldmVyLCBmb3IgYmV0dGVyIGludGVyb3Agd2l0aCBub24tUG9seW1lciBjdXN0b20gZWxlbWVudHMgdGhhdFxuICAgICAqIGFjY2VwdCBvYmplY3RzLCB3ZSBleHBsaWNpdGx5IHJlLXNldCBvYmplY3QgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGVcbiAgICAgKiBQb2x5bWVyIHdvcmxkICh3aGljaCBtYXkgaW5jbHVkZSBkZWVwIG9iamVjdCBjaGFuZ2VzIHdpdGhvdXQgdGhlXG4gICAgICogdG9wIHJlZmVyZW5jZSBjaGFuZ2luZyksIGVycmluZyBvbiB0aGUgc2lkZSBvZiBwcm92aWRpbmcgbW9yZVxuICAgICAqIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgYWx0ZXJuYXRlIGFwcHJvYWNoZXMuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgLy8gSXQgaXMgYSBqdWRnbWVudCBjYWxsIHRoYXQgcmVzZXR0aW5nIHByaW1pdGl2ZXMgaXNcbiAgICAgIC8vIFwiYmFkXCIgYW5kIHJlc2V0dGluZ3Mgb2JqZWN0cyBpcyBhbHNvIFwiZ29vZFwiOyBhbHRlcm5hdGl2ZWx5IHdlIGNvdWxkXG4gICAgICAvLyBpbXBsZW1lbnQgYSB3aGl0ZWxpc3Qgb2YgdGFnICYgcHJvcGVydHkgdmFsdWVzIHRoYXQgc2hvdWxkIG5ldmVyXG4gICAgICAvLyBiZSByZXNldCAoZS5nLiA8aW5wdXQ+LnZhbHVlICYmIDxzZWxlY3Q+LnZhbHVlKVxuICAgICAgaWYgKHZhbHVlICE9PSBub2RlW3Byb3BdIHx8IHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb3RlLCBjbGFzc05hbWUgbmVlZHMgc3R5bGUgc2NvcGluZyBzbyB0aGlzIG5lZWRzIHdyYXBwaW5nLlxuICAgICAgICBpZiAocHJvcCA9PT0gJ2NsYXNzTmFtZScpIHtcbiAgICAgICAgICBub2RlID0gLyoqIEB0eXBlIHshTm9kZX0gKi8od3JhcChub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFByb3BlcnRpZXNDaGFuZ2VkYCBpbXBsZW1lbnRhdGlvbiB0byBpbnRyb2R1Y2Ugc3BlY2lhbFxuICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICpcbiAgICAgKiAxLiBBbnkgdmFsdWUgc2V0IHRvIGEgcGF0aCAoZS5nLiAnb2JqLnByb3AnOiA0MiBvciAnb2JqLnByb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICogMi4gT2JqZWN0IHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgIGFuZCBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0XG4gICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgKiAzLiBQcmltaXRpdmUgdmFsdWUgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IDQyKVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFgXG4gICAgICpcbiAgICAgKiBUaGUgZGlydHktY2hlY2sgaXMgaW1wb3J0YW50IHRvIHByZXZlbnQgY3ljbGVzIGR1ZSB0byB0d28td2F5XG4gICAgICogbm90aWZpY2F0aW9uLCBidXQgcGF0aHMgYW5kIG9iamVjdHMgYXJlIG9ubHkgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGFueVxuICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAqIGNsZWFyZWQgd2hlbiB0aGUgbGFzdCBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBleGl0cy4gVGhpcyBpcyBzbzpcbiAgICAgKiBhLiBhbnkgY2FjaGVkIGFycmF5IHBhdGhzIChlLmcuICdhcnJheS4zLnByb3AnKSBtYXkgYmUgaW52YWxpZGF0ZWRcbiAgICAgKiAgICBkdWUgdG8gYXJyYXkgbXV0YXRpb25zIGxpa2Ugc2hpZnQvdW5zaGlmdC9zcGxpY2U7IHRoaXMgaXMgZmluZVxuICAgICAqICAgIHNpbmNlIHBhdGggY2hhbmdlcyBhcmUgZGlydHktY2hlY2tlZCBhdCB1c2VyIGVudHJ5IHBvaW50cyBsaWtlIGBzZXRgXG4gICAgICogYi4gZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgb25seSBsYXN0cyBvbmUgdHVybiB0byBhbGxvdyB0aGUgdXNlclxuICAgICAqICAgIHRvIG11dGF0ZSB0aGUgb2JqZWN0IGluLXBsYWNlIGFuZCByZS1zZXQgaXQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eVxuICAgICAqICAgIGFuZCBoYXZlIGFsbCBzdWItcHJvcGVydGllcyByZS1wcm9wYWdhdGVkIGluIGEgc3Vic2VxdWVudCB0dXJuLlxuICAgICAqXG4gICAgICogVGhlIHRlbXAgY2FjaGUgaXMgbm90IG5lY2Vzc2FyaWx5IHN1ZmZpY2llbnQgdG8gcHJldmVudCBpbnZhbGlkIGFycmF5XG4gICAgICogcGF0aHMsIHNpbmNlIGEgc3BsaWNlIGNhbiBoYXBwZW4gZHVyaW5nIHRoZSBzYW1lIHR1cm4gKHdpdGggcGF0aG9sb2dpY2FsXG4gICAgICogdXNlciBjb2RlKTsgd2UgY291bGQgaW50cm9kdWNlIGEgXCJmaXh1cFwiIGZvciB0ZW1wb3JhcmlseSBjYWNoZWQgYXJyYXlcbiAgICAgKiBwYXRocyBpZiBuZWVkZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvaXNzdWVzLzQyMjdcbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkTm90aWZ5IFRydWUgaWYgcHJvcGVydHkgc2hvdWxkIGZpcmUgbm90aWZpY2F0aW9uXG4gICAgICogICBldmVudCAoYXBwbGllcyBvbmx5IGZvciBgbm90aWZ5OiB0cnVlYCBwcm9wZXJ0aWVzKVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAqL1xuICAgIF9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCBzaG91bGROb3RpZnkpIHtcbiAgICAgIGxldCBwcm9wSXNQYXRoID0gdGhpcy5fX2RhdGFIYXNQYXRocyAmJiBpc1BhdGgocHJvcGVydHkpO1xuICAgICAgbGV0IHByZXZQcm9wcyA9IHByb3BJc1BhdGggPyB0aGlzLl9fZGF0YVRlbXAgOiB0aGlzLl9fZGF0YTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIHByZXZQcm9wc1twcm9wZXJ0eV0pKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0ge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgb2xkIGlzIGNhcHR1cmVkIGZyb20gdGhlIGxhc3QgdHVyblxuICAgICAgICBpZiAoIShwcm9wZXJ0eSBpbiB0aGlzLl9fZGF0YU9sZCkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGF0aHMgYXJlIHN0b3JlZCBpbiB0ZW1wb3JhcnkgY2FjaGUgKGNsZWFyZWQgYXQgZW5kIG9mIHR1cm4pLFxuICAgICAgICAvLyB3aGljaCBpcyB1c2VkIGZvciBkaXJ0eS1jaGVja2luZywgYWxsIG90aGVycyBzdG9yZWQgaW4gX19kYXRhXG4gICAgICAgIGlmIChwcm9wSXNQYXRoKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbCBjaGFuZ2VzIGdvIGludG8gcGVuZGluZyBwcm9wZXJ0eSBiYWcsIHBhc3NlZCB0byBfcHJvcGVydGllc0NoYW5nZWRcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAvLyBUcmFjayBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdGlmeSBzZXBhcmF0ZWx5XG4gICAgICAgIGlmIChwcm9wSXNQYXRoIHx8ICh0aGlzW1RZUEVTLk5PVElGWV0gJiYgdGhpc1tUWVBFUy5OT1RJRlldW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5W3Byb3BlcnR5XSA9IHNob3VsZE5vdGlmeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgYWxsIGFjY2Vzc29ycyBzZXQgYHNob3VsZE5vdGlmeWBcbiAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JgJ3MgZGVmYXVsdCBhc3luYyBxdWV1aW5nIG9mXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGA6IGlmIGBfX2RhdGFSZWFkeWAgaXMgZmFsc2UgKGhhcyBub3QgeWV0IGJlZW5cbiAgICAgKiBtYW51YWxseSBmbHVzaGVkKSwgdGhlIGZ1bmN0aW9uIG5vLW9wczsgb3RoZXJ3aXNlIGZsdXNoZXNcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2xpZW50IG9uIGEgbGlzdCBvZiBwZW5kaW5nIGNsaWVudHMsIHdob3NlXG4gICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgKiBgX2ZsdXNoQ2xpZW50c2AuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9lbnF1ZXVlQ2xpZW50KGNsaWVudCkge1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgfHwgW107XG4gICAgICBpZiAoY2xpZW50ICE9PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMucHVzaChjbGllbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYW55IGNsaWVudHMgcHJldmlvdXNseSBlbnF1ZXVlZCB2aWEgYF9lbnF1ZXVlQ2xpZW50YCwgY2F1c2luZ1xuICAgICAqIHRoZWlyIGBfZmx1c2hQcm9wZXJ0aWVzYCBtZXRob2QgdG8gcnVuLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZsdXNoQ2xpZW50cygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWFkeUNsaWVudHMoKTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgcG9pbnQgd2hlcmUgYWNjZXNzb3JzIGFyZSB0dXJuZWQgb247IGltcG9ydGFudGx5LFxuICAgICAgICAvLyB0aGlzIGlzIGFmdGVyIGNsaWVudHMgaGF2ZSBmdWxseSByZWFkaWVkLCBwcm92aWRpbmcgYSBndWFyYW50ZWVcbiAgICAgICAgLy8gdGhhdCBhbnkgcHJvcGVydHkgZWZmZWN0cyBvY2N1ciBvbmx5IGFmdGVyIGFsbCBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZW5hYmxlT3JGbHVzaENsaWVudHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiBXZSBlbnN1cmUgY2xpZW50cyBlaXRoZXIgZW5hYmxlIG9yIGZsdXNoIGFzIGFwcHJvcHJpYXRlLiBUaGlzXG4gICAgLy8gaGFuZGxlcyB0d28gY29ybmVyIGNhc2VzOlxuICAgIC8vICgxKSBjbGllbnRzIGZsdXNoIHByb3Blcmx5IHdoZW4gY29ubmVjdGVkL2VuYWJsZWQgYmVmb3JlIHRoZSBob3N0XG4gICAgLy8gZW5hYmxlczsgZS5nLlxuICAgIC8vICAgKGEpIFRlbXBsYXRpemUgc3RhbXBzIHdpdGggbm8gcHJvcGVydGllcyBhbmQgZG9lcyBub3QgZmx1c2ggYW5kXG4gICAgLy8gICAoYikgdGhlIGluc3RhbmNlIGlzIGluc2VydGVkIGludG8gZG9tIGFuZFxuICAgIC8vICAgKGMpIHRoZW4gdGhlIGluc3RhbmNlIGZsdXNoZXMuXG4gICAgLy8gKDIpIGNsaWVudHMgZW5hYmxlIHByb3Blcmx5IHdoZW4gbm90IGNvbm5lY3RlZC9lbmFibGVkIHdoZW4gdGhlIGhvc3RcbiAgICAvLyBmbHVzaGVzOyBlLmcuXG4gICAgLy8gICAoYSkgYSB0ZW1wbGF0ZSBpcyBydW50aW1lIHN0YW1wZWQgYW5kIG5vdCB5ZXQgY29ubmVjdGVkL2VuYWJsZWRcbiAgICAvLyAgIChiKSBhIGhvc3Qgc2V0cyBhIHByb3BlcnR5LCBjYXVzaW5nIHN0YW1wZWQgZG9tIHRvIGZsdXNoXG4gICAgLy8gICAoYykgdGhlIHN0YW1wZWQgZG9tIGVuYWJsZXMuXG4gICAgX19lbmFibGVPckZsdXNoQ2xpZW50cygpIHtcbiAgICAgIGxldCBjbGllbnRzID0gdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgIGlmIChjbGllbnRzKSB7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgICAgICAgaWYgKCFjbGllbnQuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICAgICAgY2xpZW50Ll9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgY2xpZW50Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFueSBpbml0aWFsIHNldHVwIG9uIGNsaWVudCBkb20uIENhbGxlZCBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICogYF9mbHVzaFByb3BlcnRpZXNgIGNhbGwgb24gY2xpZW50IGRvbSBhbmQgYmVmb3JlIGFueSBlbGVtZW50XG4gICAgICogb2JzZXJ2ZXJzIGFyZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGJhZyBvZiBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHRoaXMgaW5zdGFuY2UsIGFuZFxuICAgICAqIHN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzIGFsbCBlZmZlY3RzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIGEgYmF0Y2guXG4gICAgICpcbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtdXN0IGJlIHNpbXBsZSBwcm9wZXJ0aWVzLCBub3QgcGF0aHMuICBCYXRjaGVkXG4gICAgICogcGF0aCBwcm9wYWdhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBvbmUgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2hvc2Uga2V5IGlzXG4gICAgICogICBhIHByb3BlcnR5IGFuZCB2YWx1ZSBpcyB0aGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgKiAgIGBwcm9wc2Agd2lsbCBiZSBzZXQuIEJ5IGRlZmF1bHQsIGBzZXRQcm9wZXJ0aWVzYCB3aWxsIG5vdCBzZXRcbiAgICAgKiAgIGByZWFkT25seTogdHJ1ZWAgcm9vdCBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldFByb3BlcnRpZXMocHJvcHMsIHNldFJlYWRPbmx5KSB7XG4gICAgICBmb3IgKGxldCBwYXRoIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChzZXRSZWFkT25seSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bcGF0aF0pIHtcbiAgICAgICAgICAvL1RPRE8oa3NjaGFhZik6IGV4cGxpY2l0bHkgZGlzYWxsb3cgcGF0aHMgaW4gc2V0UHJvcGVydHk/XG4gICAgICAgICAgLy8gd2lsZGNhcmQgb2JzZXJ2ZXJzIGN1cnJlbnRseSBvbmx5IHBhc3MgdGhlIGZpcnN0IGNoYW5nZWQgcGF0aFxuICAgICAgICAgIC8vIGluIHRoZSBgaW5mb2Agb2JqZWN0LCBhbmQgeW91IGNvdWxkIGRvIHNvbWUgb2RkIHRoaW5ncyBiYXRjaGluZ1xuICAgICAgICAgIC8vIHBhdGhzLCBlLmcuIHsnZm9vLmJhcic6IHsuLi59LCAnZm9vJzogbnVsbH1cbiAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgcHJvcHNbcGF0aF0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHNvIHRoYXQgcHJvcGVydHkgYWNjZXNzb3JcbiAgICAgKiBzaWRlIGVmZmVjdHMgYXJlIG5vdCBlbmFibGVkIHVudGlsIGFmdGVyIGNsaWVudCBkb20gaXMgZnVsbHkgcmVhZHkuXG4gICAgICogQWxzbyBjYWxscyBgX2ZsdXNoQ2xpZW50c2AgY2FsbGJhY2sgdG8gZW5zdXJlIGNsaWVudCBkb20gaXMgZW5hYmxlZFxuICAgICAqIHRoYXQgd2FzIG5vdCBlbmFibGVkIGFzIGEgcmVzdWx0IG9mIGZsdXNoaW5nIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgYHN1cGVyLnJlYWR5KClgIGlzIG5vdCBjYWxsZWQgaGVyZSBhcyBpdFxuICAgICAgLy8gaW1tZWRpYXRlbHkgdHVybnMgb24gYWNjZXNzb3JzLiBJbnN0ZWFkLCB3ZSB3YWl0IHVudGlsIGByZWFkeUNsaWVudHNgXG4gICAgICAvLyB0byBlbmFibGUgYWNjZXNzb3JzIHRvIHByb3ZpZGUgYSBndWFyYW50ZWUgdGhhdCBjbGllbnRzIGFyZSByZWFkeVxuICAgICAgLy8gYmVmb3JlIHByb2Nlc3NpbmcgYW55IGFjY2Vzc29ycyBzaWRlIGVmZmVjdHMuXG4gICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIC8vIElmIG5vIGRhdGEgd2FzIHBlbmRpbmcsIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aWxsIG5vdCBgZmx1c2hDbGllbnRzYFxuICAgICAgLy8gc28gZW5zdXJlIHRoaXMgaXMgZG9uZS5cbiAgICAgIGlmICghdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hDbGllbnRzKCk7XG4gICAgICB9XG4gICAgICAvLyBCZWZvcmUgcmVhZHksIGNsaWVudCBub3RpZmljYXRpb25zIGRvIG5vdCB0cmlnZ2VyIF9mbHVzaFByb3BlcnRpZXMuXG4gICAgICAvLyBUaGVyZWZvcmUgYSBmbHVzaCBpcyBuZWNlc3NhcnkgaGVyZSBpZiBkYXRhIGhhcyBiZWVuIHNldC5cbiAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlBY2Nlc3NvcnNgJ3MgcHJvcGVydGllcyBjaGFuZ2VkIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogUnVucyBlYWNoIGNsYXNzIG9mIGVmZmVjdHMgZm9yIHRoZSBiYXRjaCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgaW5cbiAgICAgKiBhIHNwZWNpZmljIG9yZGVyIChjb21wdXRlLCBwcm9wYWdhdGUsIHJlZmxlY3QsIG9ic2VydmUsIG5vdGlmeSkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAqIEBwYXJhbSB7P09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGxldCBjID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhbmdlZFByb3BzIHx8IHt9KTtcbiAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGxldCBoYXNQYXRocyA9IHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICBsZXQgbm90aWZ5UHJvcHM7XG4gICAgICAvLyBDb21wdXRlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkNvbXB1dGVkRWZmZWN0cyh0aGlzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgLy8gYnV0IGFmdGVyIGNvbXB1dGluZyBlZmZlY3RzIGhhdmUgYSBjaGFuY2UgdG8gYWRkIHRvIHRoZW1cbiAgICAgIG5vdGlmeVByb3BzID0gdGhpcy5fX2RhdGFUb05vdGlmeTtcbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSBudWxsO1xuICAgICAgLy8gUHJvcGFnYXRlIHByb3BlcnRpZXMgdG8gY2xpZW50c1xuICAgICAgdGhpcy5fcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzKGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIC8vIEZsdXNoIGNsaWVudHNcbiAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgLy8gUmVmbGVjdCBwcm9wZXJ0aWVzXG4gICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUkVGTEVDVF0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIC8vIE9ic2VydmUgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLk9CU0VSVkVdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBOb3RpZnkgcHJvcGVydGllcyB0byBob3N0XG4gICAgICBpZiAobm90aWZ5UHJvcHMpIHtcbiAgICAgICAgcnVuTm90aWZ5RWZmZWN0cyh0aGlzLCBub3RpZnlQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgdGVtcG9yYXJ5IGNhY2hlIGF0IGVuZCBvZiB0dXJuXG4gICAgICBpZiAodGhpcy5fX2RhdGFDb3VudGVyID09IDEpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFUZW1wID0ge307XG4gICAgICB9XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cEVuZCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHRvIHByb3BhZ2F0ZSBhbnkgcHJvcGVydHkgY2hhbmdlcyB0byBzdGFtcGVkIHRlbXBsYXRlIG5vZGVzXG4gICAgICogbWFuYWdlZCBieSB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMoY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAgIGlmICh0aGlzW1RZUEVTLlBST1BBR0FURV0pIHtcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlBST1BBR0FURV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRoaXMuX3J1bkVmZmVjdHNGb3JUZW1wbGF0ZSh0aGlzLl9fdGVtcGxhdGVJbmZvLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3J1bkVmZmVjdHNGb3JUZW1wbGF0ZSh0ZW1wbGF0ZUluZm8sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBjb25zdCBiYXNlUnVuRWZmZWN0cyA9IChjaGFuZ2VkUHJvcHMsIGhhc1BhdGhzKSA9PiB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICBoYXNQYXRocywgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgZm9yIChsZXQgaW5mbz10ZW1wbGF0ZUluZm8uZmlyc3RDaGlsZDsgaW5mbzsgaW5mbz1pbmZvLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgdGhpcy5fcnVuRWZmZWN0c0ZvclRlbXBsYXRlKGluZm8sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0ZW1wbGF0ZUluZm8ucnVuRWZmZWN0cykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8ucnVuRWZmZWN0cyhiYXNlUnVuRWZmZWN0cywgY2hhbmdlZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlUnVuRWZmZWN0cyhjaGFuZ2VkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhc2VzIG9uZSBkYXRhIHBhdGggYXMgYW5vdGhlciwgc3VjaCB0aGF0IHBhdGggbm90aWZpY2F0aW9ucyBmcm9tIG9uZVxuICAgICAqIGFyZSByb3V0ZWQgdG8gdGhlIG90aGVyLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHRvIFRhcmdldCBwYXRoIHRvIGxpbmsuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IGZyb20gU291cmNlIHBhdGggdG8gbGluay5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBsaW5rUGF0aHModG8sIGZyb20pIHtcbiAgICAgIHRvID0gbm9ybWFsaXplKHRvKTtcbiAgICAgIGZyb20gPSBub3JtYWxpemUoZnJvbSk7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRocyB8fCB7fTtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHNbdG9dID0gZnJvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZGF0YSBwYXRoIGFsaWFzIHByZXZpb3VzbHkgZXN0YWJsaXNoZWQgd2l0aCBgX2xpbmtQYXRoc2AuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGUgcGF0aCB0byB1bmxpbmsgc2hvdWxkIGJlIHRoZSB0YXJnZXQgKGB0b2ApIHVzZWQgd2hlblxuICAgICAqIGxpbmtpbmcgdGhlIHBhdGhzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggVGFyZ2V0IHBhdGggdG8gdW5saW5rLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVubGlua1BhdGhzKHBhdGgpIHtcbiAgICAgIHBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1twYXRoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhhdCBhbiBhcnJheSBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICB0aGlzLml0ZW1zLnNwbGljZSgxLCAxLCB7bmFtZTogJ1NhbSd9KTtcbiAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVNwbGljZXMoJ2l0ZW1zJywgW1xuICAgICAqICAgICAgIHsgaW5kZXg6IDEsIHJlbW92ZWQ6IFt7bmFtZTogJ1RvZGQnfV0sIGFkZGVkQ291bnQ6IDEsXG4gICAgICogICAgICAgICBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnIH0sXG4gICAgICogICAgICAgeyBpbmRleDogMywgcmVtb3ZlZDogW10sIGFkZGVkQ291bnQ6IDEsXG4gICAgICogICAgICAgICBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIG9yZGVyZWRcbiAgICAgKiAgIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB0byB0aGUgYXJyYXkuIEVhY2ggcmVjb3JkIHNob3VsZCBoYXZlIHRoZVxuICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAgICAqIGluZGV4OiBpbmRleCBhdCB3aGljaCB0aGUgY2hhbmdlIG9jY3VycmVkXG4gICAgICogICAgKiByZW1vdmVkOiBhcnJheSBvZiBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAqICAgICogb2JqZWN0OiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgaW4gcXVlc3Rpb25cbiAgICAgKiAgICAqIHR5cGU6IHRoZSBzdHJpbmcgbGl0ZXJhbCAnc3BsaWNlJ1xuICAgICAqXG4gICAgICogICBOb3RlIHRoYXQgc3BsaWNlIHJlY29yZHMgX211c3RfIGJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZXkgYXJlXG4gICAgICogICByZXBvcnRlZCBpbiBpbmRleCBvcmRlciAocmF3IHJlc3VsdHMgZnJvbSBgT2JqZWN0Lm9ic2VydmVgIGFyZSBub3RcbiAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBub3RpZnlTcGxpY2VzKHBhdGgsIHNwbGljZXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBub3RpZnlTcGxpY2VzKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHNwbGljZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVhZGluZyBhIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW4gZGVyZWZlcmVuY2luZyB1bmRlZmluZWRcbiAgICAgKiBwYXRocykuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byByZWFkLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgZm9vLmJhci5iYXpgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgdXNlcnMuMTIubmFtZWAgb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgKiAgIGlzIHVuZGVmaW5lZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIHJvb3QpIHtcbiAgICAgIHJldHVybiBnZXQocm9vdCB8fCB0aGlzLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHNldHRpbmcgYSB2YWx1ZSB0byBhIHBhdGggYW5kIG5vdGlmeWluZyBhbnlcbiAgICAgKiBlbGVtZW50cyBib3VuZCB0byB0aGUgc2FtZSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggZXhjZXB0IGZvciB0aGUgbGFzdCBpcyB1bmRlZmluZWQsXG4gICAgICogdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nICh0aGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyB3aGVuXG4gICAgICogZGVyZWZlcmVuY2luZyB1bmRlZmluZWQgcGF0aHMpLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfCFBcnJheTwoc3RyaW5nfG51bWJlcik+KX0gcGF0aCBQYXRoIHRvIHRoZSB2YWx1ZVxuICAgICAqICAgdG8gd3JpdGUuICBUaGUgcGF0aCBtYXkgYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChlLmcuIGAnZm9vLmJhci5iYXonYClcbiAgICAgKiAgIG9yIGFuIGFycmF5IG9mIHBhdGggcGFydHMgKGUuZy4gYFsnZm9vLmJhcicsICdiYXonXWApLiAgTm90ZSB0aGF0XG4gICAgICogICBicmFja2V0ZWQgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQ7IHN0cmluZy1iYXNlZCBwYXRoIHBhcnRzXG4gICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICogICBpbmRpY2VzLCB0aGUgaW5kZXggbWF5IGJlIHVzZWQgYXMgYSBkb3R0ZWQgcGFydCBkaXJlY3RseVxuICAgICAqICAgKGUuZy4gYCd1c2Vycy4xMi5uYW1lJ2Agb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICogICBXaGVuIHNwZWNpZmllZCwgbm8gbm90aWZpY2F0aW9uIHdpbGwgb2NjdXIuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0KHBhdGgsIHZhbHVlLCByb290KSB7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICBzZXQocm9vdCwgcGF0aCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzW1RZUEVTLlJFQURfT05MWV0gfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXVsvKiogQHR5cGUge3N0cmluZ30gKi8ocGF0aCldKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBpdGVtcyBvbnRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucHVzaGAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIHB1c2ggb250byBhcnJheVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1c2gocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9Ki8oZ2V0KHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucHVzaCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBsZW4sIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcG9wKHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnBvcCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgYXJyYXkubGVuZ3RoLCAwLCBbcmV0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdGhlIHN0YXJ0IGluZGV4IHNwZWNpZmllZCwgcmVtb3ZlcyAwIG9yIG1vcmUgaXRlbXNcbiAgICAgKiBmcm9tIHRoZSBhcnJheSBhbmQgaW5zZXJ0cyAwIG9yIG1vcmUgbmV3IGl0ZW1zIGluIHRoZWlyIHBsYWNlLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IEluZGV4IGZyb20gd2hpY2ggdG8gc3RhcnQgcmVtb3ZpbmcvaW5zZXJ0aW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZGVsZXRlQ291bnQgTnVtYmVyIG9mIGl0ZW1zIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIGluc2VydCBpbnRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyFBcnJheX0gQXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3BsaWNlKHBhdGgsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGggOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgLy8gTm9ybWFsaXplIGZhbmN5IG5hdGl2ZSBzcGxpY2UgaGFuZGxpbmcgb2YgY3Jhenkgc3RhcnQgdmFsdWVzXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gYXJyYXkubGVuZ3RoIC0gTWF0aC5mbG9vcigtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgfVxuICAgICAgLy8gYXJyYXkuc3BsaWNlIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgLy8geW91IHBhc3MgaW4uIFRoZXJlZm9yZSwgYXJyYXkuc3BsaWNlKDApIGFuZCBhcnJheS5zcGxpY2UoMCwgdW5kZWZpbmVkKVxuICAgICAgLy8gZG8gZGlmZmVyZW50IHRoaW5ncy4gSW4gdGhlIGZvcm1lciwgdGhlIHdob2xlIGFycmF5IGlzIGNsZWFyZWQuIEluIHRoZVxuICAgICAgLy8gbGF0dGVyLCBubyBpdGVtcyBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIGRldGVjdCB3aGV0aGVyIDEuIG9uZSBvZiB0aGUgYXJndW1lbnRzXG4gICAgICAvLyBpcyBhY3R1YWxseSBwYXNzZWQgaW4gYW5kIHRoZW4gMi4gZGV0ZXJtaW5lIGhvdyBtYW55IGFyZ3VtZW50c1xuICAgICAgLy8gd2Ugc2hvdWxkIHBhc3Mgb24gdG8gdGhlIG5hdGl2ZSBhcnJheS5zcGxpY2VcbiAgICAgIC8vXG4gICAgICBsZXQgcmV0O1xuICAgICAgLy8gT21pdCBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgaWYgdGhleSB3ZXJlIG5vdCBwYXNzZWQgaW5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldCA9IGFycmF5LnNwbGljZShzdGFydCk7XG4gICAgICAvLyBFaXRoZXIgc3RhcnQgd2FzIHVuZGVmaW5lZCBhbmQgdGhlIG90aGVycyB3ZXJlIGRlZmluZWQsIGJ1dCBpbiB0aGlzXG4gICAgICAvLyBjYXNlIHdlIGNhbiBzYWZlbHkgcGFzcyBvbiBhbGwgYXJndW1lbnRzXG4gICAgICAvL1xuICAgICAgLy8gTm90ZTogdGhpcyBpbmNsdWRlcyB0aGUgY2FzZSB3aGVyZSBub25lIG9mIHRoZSBhcmd1bWVudHMgd2VyZSBwYXNzZWQgaW4sXG4gICAgICAvLyBlLmcuIHRoaXMuc3BsaWNlKCdhcnJheScpLiBIb3dldmVyLCBpZiBib3RoIHN0YXJ0IGFuZCBkZWxldGVDb3VudFxuICAgICAgLy8gYXJlIHVuZGVmaW5lZCwgYXJyYXkuc3BsaWNlIHdpbGwgbm90IG1vZGlmeSB0aGUgYXJyYXkgKGFzIGV4cGVjdGVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpO1xuICAgICAgfVxuICAgICAgLy8gQXQgdGhlIGVuZCwgY2hlY2sgd2hldGhlciBhbnkgaXRlbXMgd2VyZSBwYXNzZWQgaW4gKGUuZy4gaW5zZXJ0aW9ucylcbiAgICAgIC8vIG9yIGlmIHRoZSByZXR1cm4gYXJyYXkgY29udGFpbnMgaXRlbXMgKGUuZy4gZGVsZXRpb25zKS5cbiAgICAgIC8vIE9ubHkgbm90aWZ5IGlmIGl0ZW1zIHdlcmUgYWRkZWQgb3IgZGVsZXRlZC5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggfHwgcmV0Lmxlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgc3RhcnQsIGl0ZW1zLmxlbmd0aCwgcmV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnBvcGAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNoaWZ0KHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnNoaWZ0KCk7XG4gICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCAwLCBbcmV0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW5mbyBhcnJheVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVuc2hpZnQocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB0aGlzLml0ZW0udXNlci5uYW1lID0gJ0JvYic7XG4gICAgICogICAgIHRoaXMubm90aWZ5UGF0aCgnaXRlbS51c2VyLm5hbWUnKTtcbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgVmFsdWUgYXQgdGhlIHBhdGggKG9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBub3RpZnlQYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCBwcm9wUGF0aDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIHZhbHVlID0gZ2V0KHRoaXMsIHBhdGgsIGluZm8pO1xuICAgICAgICBwcm9wUGF0aCA9IGluZm8ucGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAvLyBOb3JtYWxpemUgcGF0aCBpZiBuZWVkZWRcbiAgICAgICAgcHJvcFBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wUGF0aCA9IC8qKiBAdHlwZXtzdHJpbmd9ICovKHBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wUGF0aCwgdmFsdWUsIHRydWUsIHRydWUpKSB7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVJlYWRPbmx5UHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICBpZiAocHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbigqLCopfSBtZXRob2QgRnVuY3Rpb24gb3IgbmFtZSBvZiBvYnNlcnZlciBtZXRob2RcbiAgICAgKiAgICAgdG8gY2FsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGR5bmFtaWNGbiBXaGV0aGVyIHRoZSBtZXRob2QgbmFtZSBzaG91bGQgYmUgaW5jbHVkZWQgYXNcbiAgICAgKiAgIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2QsIGR5bmFtaWNGbikge1xuICAgICAgbGV0IGluZm8gPSB7IHByb3BlcnR5LCBtZXRob2QsIGR5bmFtaWNGbjogQm9vbGVhbihkeW5hbWljRm4pIH07XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuT0JTRVJWRSwge1xuICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBwcm9wZXJ0eX1cbiAgICAgIH0pO1xuICAgICAgaWYgKGR5bmFtaWNGbikge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdCgvKiogQHR5cGUge3N0cmluZ30gKi8obWV0aG9kKSwgVFlQRVMuT0JTRVJWRSwge1xuICAgICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IG1ldGhvZH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU1ldGhvZE9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgb2JzZXJ2ZXIgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuT0JTRVJWRSwgcnVuTWV0aG9kRWZmZWN0LCBudWxsLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlksIHtcbiAgICAgICAgZm46IHJ1bk5vdGlmeUVmZmVjdCxcbiAgICAgICAgaW5mbzoge1xuICAgICAgICAgIGV2ZW50TmFtZTogY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBnby9taXNzaW5nZm5wcm9wc1xuICAgICAqL1xuICAgIF9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgbGV0IGF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLmF0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICBpZiAoYXR0clswXSA9PT0gJy0nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgJyArIHByb3BlcnR5ICsgJyBjYW5ub3QgYmUgcmVmbGVjdGVkIHRvIGF0dHJpYnV0ZSAnICtcbiAgICAgICAgICBhdHRyICsgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIHN0YXJ0aW5nIGF0dHJpYnV0ZSBuYW1lLiBVc2UgYSBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIGZvciB0aGUgcHJvcGVydHkgaW5zdGVhZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNULCB7XG4gICAgICAgICAgZm46IHJ1blJlZmxlY3RFZmZlY3QsXG4gICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgYXR0ck5hbWU6IGF0dHJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVDb21wdXRlZFByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgY29tcHV0ZWQgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5mbyA9IGNyZWF0ZU1ldGhvZEVmZmVjdCh0aGlzLCBzaWcsIFRZUEVTLkNPTVBVVEUsIHJ1bkNvbXB1dGVkRWZmZWN0LCBwcm9wZXJ0eSwgZHluYW1pY0ZuKTtcbiAgICAgIC8vIEVmZmVjdHMgYXJlIG5vcm1hbGx5IHN0b3JlZCBhcyBtYXAgb2YgZGVwZW5kZW5jeS0+ZWZmZWN0LCBidXQgZm9yXG4gICAgICAvLyBvcmRlcmVkIGNvbXB1dGF0aW9uLCB3ZSBhbHNvIG5lZWQgdHJlZSBvZiBjb21wdXRlZFByb3AtPmRlcGVuZGVuY2llc1xuICAgICAgZW5zdXJlT3duRWZmZWN0TWFwKHRoaXMsIENPTVBVVEVfSU5GTylbcHJvcGVydHldID0gaW5mbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICAgICAqIG9mIGFyZ3VtZW50IG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gICAgICogd2hlbiB0aGUgbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCBhcyBhIHJlc3VsdCBvZiBhIHBhdGggbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshQXJyYXk8IU1ldGhvZEFyZz59IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnQgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIG5hbWUgdGhhdCB0cmlnZ2VyZWQgdGhlIG1ldGhvZCBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgICAqIEByZXR1cm4geyFBcnJheTwqPn0gQXJyYXkgb2YgYXJndW1lbnQgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFyc2hhbEFyZ3MoYXJncywgcGF0aCwgcHJvcHMpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YTtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgICBsZXQge25hbWUsIHN0cnVjdHVyZWQsIHdpbGRjYXJkLCB2YWx1ZSwgbGl0ZXJhbH0gPSBhcmdzW2ldO1xuICAgICAgICBpZiAoIWxpdGVyYWwpIHtcbiAgICAgICAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBpc0Rlc2NlbmRhbnQobmFtZSwgcGF0aCk7XG4gICAgICAgICAgICBjb25zdCBwYXRoVmFsdWUgPSBnZXRBcmdWYWx1ZShkYXRhLCBwcm9wcywgbWF0Y2hlcyA/IHBhdGggOiBuYW1lKTtcbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICBwYXRoOiBtYXRjaGVzID8gcGF0aCA6IG5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBwYXRoVmFsdWUsXG4gICAgICAgICAgICAgIGJhc2U6IG1hdGNoZXMgPyBnZXQoZGF0YSwgbmFtZSkgOiBwYXRoVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3RydWN0dXJlZCA/IGdldEFyZ1ZhbHVlKGRhdGEsIHByb3BzLCBuYW1lKSA6IGRhdGFbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIGBsZWdhY3lVbmRlZmluZWRgIGZsYWcgaXMgZW5hYmxlZCwgcGFzcyBhIG5vLW9wIHZhbHVlXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIG9ic2VydmVyLCBjb21wdXRlZCBwcm9wZXJ0eSwgb3IgY29tcG91bmQgYmluZGluZyBpcyBhYm9ydGVkLlxuICAgICAgICBpZiAobGVnYWN5VW5kZWZpbmVkICYmICF0aGlzLl9vdmVycmlkZUxlZ2FjeVVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBOT09QO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICAvLyAtLSBzdGF0aWMgY2xhc3MgbWV0aG9kcyAtLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYW4gYWNjZXNzb3IgZXhpc3RzIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBhbmQgYWRkc1xuICAgICAqIHRvIGEgbGlzdCBvZiBcInByb3BlcnR5IGVmZmVjdHNcIiB0aGF0IHdpbGwgcnVuIHdoZW4gdGhlIGFjY2Vzc29yIGZvclxuICAgICAqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaXMgc2V0LiAgRWZmZWN0cyBhcmUgZ3JvdXBlZCBieSBcInR5cGVcIiwgd2hpY2hcbiAgICAgKiByb3VnaGx5IGNvcnJlc3BvbmRzIHRvIGEgcGhhc2UgaW4gZWZmZWN0IHByb2Nlc3NpbmcuICBUaGUgZWZmZWN0XG4gICAgICogbWV0YWRhdGEgc2hvdWxkIGJlIGluIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgKlxuICAgICAqICAgICB7XG4gICAgICogICAgICAgZm46IGVmZmVjdEZ1bmN0aW9uLCAvLyBSZWZlcmVuY2UgdG8gZnVuY3Rpb24gdG8gY2FsbCB0byBwZXJmb3JtIGVmZmVjdFxuICAgICAqICAgICAgIGluZm86IHsgLi4uIH0gICAgICAgLy8gRWZmZWN0IG1ldGFkYXRhIHBhc3NlZCB0byBmdW5jdGlvblxuICAgICAqICAgICAgIHRyaWdnZXI6IHsgICAgICAgICAgLy8gT3B0aW9uYWwgdHJpZ2dlcmluZyBtZXRhZGF0YTsgaWYgbm90IHByb3ZpZGVkXG4gICAgICogICAgICAgICBuYW1lOiBzdHJpbmcgICAgICAvLyB0aGUgcHJvcGVydHkgaXMgdHJlYXRlZCBhcyBhIHdpbGRjYXJkXG4gICAgICogICAgICAgICBzdHJ1Y3R1cmVkOiBib29sZWFuXG4gICAgICogICAgICAgICB3aWxkY2FyZDogYm9vbGVhblxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogRWZmZWN0cyBhcmUgY2FsbGVkIGZyb20gYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgaW4gdGhlIGZvbGxvd2luZyBvcmRlciBieVxuICAgICAqIHR5cGU6XG4gICAgICpcbiAgICAgKiAxLiBDT01QVVRFXG4gICAgICogMi4gUFJPUEFHQVRFXG4gICAgICogMy4gUkVGTEVDVFxuICAgICAqIDQuIE9CU0VSVkVcbiAgICAgKiA1LiBOT1RJRllcbiAgICAgKlxuICAgICAqIEVmZmVjdCBmdW5jdGlvbnMgYXJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICAgICAqXG4gICAgICogICAgIGVmZmVjdEZ1bmN0aW9uKGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaW5nbGUtcHJvcGVydHkgb2JzZXJ2ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb24oKiwqKX0gbWV0aG9kIEZ1bmN0aW9uIG9yIG5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2QsIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZCwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbXVsdGktcHJvcGVydHkgXCJtZXRob2Qgb2JzZXJ2ZXJcIiBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBleHByZXNzaW9uLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YVNjcmlwdFxuICAgICAqIGZ1bmN0aW9uIHNpZ25hdHVyZTogYCdtZXRob2ROYW1lKGFyZzEsIFsuLi4sIGFyZ25dKSdgLiAgRWFjaCBhcmd1bWVudFxuICAgICAqIHNob3VsZCBjb3JyZXNwb25kIHRvIGEgcHJvcGVydHkgb3IgcGF0aCBpbiB0aGUgY29udGV4dCBvZiB0aGlzXG4gICAgICogcHJvdG90eXBlIChvciBpbnN0YW5jZSksIG9yIG1heSBiZSBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAqIGV2ZW50cyB0byBub3RpZnkgb2YgY2hhbmdlcyB0byB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWFkLW9ubHkgYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRvIHNldCB0aGUgcHJvcGVydHksIHVzZSB0aGUgcHJvdGVjdGVkIGBfc2V0UHJvcGVydHlgIEFQSS5cbiAgICAgKiBUbyBjcmVhdGUgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlciAoZS5nLiBgX3NldE15UHJvcCgpYCBmb3JcbiAgICAgKiBwcm9wZXJ0eSBgbXlQcm9wYCksIHBhc3MgYHRydWVgIGZvciBgcHJvdGVjdGVkU2V0dGVyYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIGlmIHRoZSBwcm9wZXJ0eSB3aWxsIGhhdmUgb3RoZXIgcHJvcGVydHkgZWZmZWN0cywgdGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LCBiZWZvcmUgYWRkaW5nIG90aGVyIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgKiAgIHdoZW4gYHRydWVgLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byByZWZsZWN0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIHRvIGEgKGRhc2gtY2FzZWQpIGF0dHJpYnV0ZSBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIGNoYW5nZXMuICBUaGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSB0byBlbnN1cmUgYmluZGluZyBlZmZlY3RzIGFyZSBjcmVhdGVkXG4gICAgICogZm9yIHRoZW0sIGFuZCB0aGVuIGVuc3VyZXMgcHJvcGVydHkgYWNjZXNzb3JzIGFyZSBjcmVhdGVkIGZvciBhbnlcbiAgICAgKiBkZXBlbmRlbnQgcHJvcGVydGllcyBpbiB0aGUgdGVtcGxhdGUuICBCaW5kaW5nIGVmZmVjdHMgZm9yIGJvdW5kXG4gICAgICogdGVtcGxhdGVzIGFyZSBzdG9yZWQgaW4gYSBsaW5rZWQgbGlzdCBvbiB0aGUgaW5zdGFuY2Ugc28gdGhhdFxuICAgICAqIHRlbXBsYXRlcyBjYW4gYmUgZWZmaWNpZW50bHkgc3RhbXBlZCBhbmQgdW5zdGFtcGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogICBiaW5kaW5nc1xuICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBiaW5kVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvLyAtLSBiaW5kaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qXG4gICAgICogT3ZlcnZpZXcgb2YgYmluZGluZyBmbG93OlxuICAgICAqXG4gICAgICogRHVyaW5nIGZpbmFsaXphdGlvbiAoYGluc3RhbmNlQmluZGluZz09ZmFsc2VgLCBgd2FzUHJlQm91bmQ9PWZhbHNlYCk6XG4gICAgICogIGBfYmluZFRlbXBsYXRlKHQsIGZhbHNlKWAgY2FsbGVkIGRpcmVjdGx5IGR1cmluZyBmaW5hbGl6YXRpb24gLSBwYXJzZXNcbiAgICAgKiAgdGhlIHRlbXBsYXRlIChmb3IgdGhlIGZpcnN0IHRpbWUpLCBhbmQgdGhlbiBhc3NpZ25zIHRoYXQgX3Byb3RvdHlwaWNhbF9cbiAgICAgKiAgdGVtcGxhdGUgaW5mbyB0byBgX19wcmVib3VuZFRlbXBsYXRlSW5mb2AgX29uIHRoZSBwcm90b3R5cGVfOyBub3RlIGluXG4gICAgICogIHRoaXMgY2FzZSBgd2FzUHJlQm91bmRgIGlzIGZhbHNlOyB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGJpbmRpbmdcbiAgICAgKiAgaXQsIHRodXMgd2UgY3JlYXRlIGFjY2Vzc29ycy5cbiAgICAgKlxuICAgICAqIER1cmluZyBmaXJzdCBzdGFtcGluZyAoYGluc3RhbmNlQmluZGluZz09dHJ1ZWAsIGB3YXNQcmVCb3VuZD09dHJ1ZWApOlxuICAgICAqICAgYF9zdGFtcFRlbXBsYXRlYCBjYWxscyBgX2JpbmRUZW1wbGF0ZSh0LCB0cnVlKWA6IHRoZSBgdGVtcGxhdGVJbmZvYFxuICAgICAqICAgcmV0dXJuZWQgbWF0Y2hlcyB0aGUgcHJlYm91bmQgb25lLCBhbmQgc28gdGhpcyBpcyBgd2FzUHJlQm91bmQgPT0gdHJ1ZWBcbiAgICAgKiAgIHN0YXRlOyB0aHVzIHdlIF9za2lwXyBjcmVhdGluZyBhY2Nlc3NvcnMsIGJ1dCBfZG9fIGNyZWF0ZSBhbiBpbnN0YW5jZVxuICAgICAqICAgb2YgdGhlIHRlbXBsYXRlIGluZm8gdG8gc2VydmUgYXMgdGhlIHN0YXJ0IG9mIG91ciBsaW5rZWQgbGlzdCAobmVlZHMgdG9cbiAgICAgKiAgIGJlIGFuIGluc3RhbmNlLCBub3QgdGhlIHByb3RvdHlwaWNhbCBvbmUsIHNvIHRoYXQgd2UgY2FuIGFkZCBgbm9kZUxpc3RgXG4gICAgICogICB0byBpdCB0byBjb250YWluIHRoZSBgbm9kZUluZm9gLW9yZGVyZWQgbGlzdCBvZiBpbnN0YW5jZSBub2RlcyBmb3JcbiAgICAgKiAgIGJpbmRpbmdzLCBhbmQgc28gd2UgY2FuIGNoYWluIHJ1bnRpbWUtc3RhbXBlZCB0ZW1wbGF0ZSBpbmZvcyBvZmYgb2ZcbiAgICAgKiAgIGl0KS4gQXQgdGhpcyBwb2ludCwgdGhlIGNhbGwgdG8gYF9zdGFtcFRlbXBsYXRlYCBjYWxsc1xuICAgICAqICAgYGFwcGx5VGVtcGxhdGVJbmZvYCBmb3IgZWFjaCBuZXN0ZWQgYDx0ZW1wbGF0ZT5gIGZvdW5kIGR1cmluZyBwYXJzaW5nXG4gICAgICogICB0byBoYW5kIHByb3RvdHlwaWNhbCBgX3RlbXBsYXRlSW5mb2AgdG8gdGhlbTsgd2UgYWxzbyBwYXNzIHRoZSBfcGFyZW50X1xuICAgICAqICAgYHRlbXBsYXRlSW5mb2AgdG8gdGhlIGA8dGVtcGxhdGU+YCBzbyB0aGF0IHdlIGhhdmUgdGhlIGluc3RhbmNlLXRpbWVcbiAgICAgKiAgIHBhcmVudCB0byBsaW5rIHRoZSBgdGVtcGxhdGVJbmZvYCB1bmRlciBpbiB0aGUgY2FzZSBpdCB3YXNcbiAgICAgKiAgIHJ1bnRpbWUtc3RhbXBlZC5cbiAgICAgKlxuICAgICAqIER1cmluZyBzdWJzZXF1ZW50IHJ1bnRpbWUgc3RhbXBpbmcgKGBpbnN0YW5jZUJpbmRpbmc9PXRydWVgLFxuICAgICAqICAgYHdhc1ByZUJvdW5kPT1mYWxzZWApOiBgX3N0YW1wVGVtcGxhdGVgIGNhbGxzIGBfYmluZFRlbXBsYXRlKHQsIHRydWUpYFxuICAgICAqICAgLSBoZXJlIGB0ZW1wbGF0ZUluZm9gIGlzIGd1YXJhbnRlZWQgdG8gX25vdF8gbWF0Y2ggdGhlIHByZWJvdW5kIG9uZSxcbiAgICAgKiAgIGJlY2F1c2UgaXQgd2FzIGVpdGhlciBhIGRpZmZlcmVudCB0ZW1wbGF0ZSBhbHRvZ2V0aGVyLCBvciBldmVuIGlmIGl0XG4gICAgICogICB3YXMgdGhlIHNhbWUgdGVtcGxhdGUsIHRoZSBzdGVwIGFib3ZlIGNyZWF0ZWQgYSBpbnN0YW5jZSBvZiB0aGUgaW5mbztcbiAgICAgKiAgIGluIHRoaXMgY2FzZSBgd2FzUHJlQm91bmQgPT0gZmFsc2VgLCBzbyB3ZSBfZG9fIGNyZWF0ZSBhY2Nlc3NvcnMsIF9hbmRfXG4gICAgICogICBsaW5rIGEgaW5zdGFuY2UgaW50byB0aGUgbGlua2VkIGxpc3QuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYmluZFRlbXBsYXRlYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb24gYW4gaW5zdGFuY2VcbiAgICAgKiB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvciBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiB0aGUgcHJvdG90eXBlIChmb3IgcHJvdG90eXBpY2FsIHRlbXBsYXRlXG4gICAgICogYmluZGluZywgdG8gYXZvaWQgY3JlYXRpbmcgYWNjZXNzb3JzIGV2ZXJ5IGluc3RhbmNlKSBvbmNlIHBlciBwcm90b3R5cGUsXG4gICAgICogYW5kIHdpbGwgYmUgY2FsbGVkIHdpdGggYHJ1bnRpbWVCaW5kaW5nOiB0cnVlYCBieSBgX3N0YW1wVGVtcGxhdGVgIHRvXG4gICAgICogY3JlYXRlIGFuZCBsaW5rIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggYVxuICAgICAqIHBhcnRpY3VsYXIgc3RhbXBpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSBjb250YWluaW5nIGJpbmRpbmdcbiAgICAgKiBiaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluc3RhbmNlQmluZGluZyBXaGVuIGZhbHNlIChkZWZhdWx0KSwgcGVyZm9ybXNcbiAgICAgKiBcInByb3RvdHlwaWNhbFwiIGJpbmRpbmcgb2YgdGhlIHRlbXBsYXRlIGFuZCBvdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5XG4gICAgICogYm91bmQgdGVtcGxhdGUgZm9yIHRoZSBjbGFzcy4gV2hlbiB0cnVlIChhcyBwYXNzZWQgZnJvbVxuICAgICAqIGBfc3RhbXBUZW1wbGF0ZWApLCB0aGUgdGVtcGxhdGUgaW5mbyBpcyBpbnN0YW5jZWQgYW5kIGxpbmtlZCBpbnRvIHRoZVxuICAgICAqIGxpc3Qgb2YgYm91bmQgdGVtcGxhdGVzLlxuICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdDsgZm9yIGBydW50aW1lQmluZGluZ2AsXG4gICAgICogdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlIGluZm9cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gZ28vbWlzc2luZ2ZucHJvcHNcbiAgICAgKi9cbiAgICBfYmluZFRlbXBsYXRlKHRlbXBsYXRlLCBpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGxldCB3YXNQcmVCb3VuZCA9IHRoaXMuX19wcmVCb3VuZFRlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAvLyBPcHRpbWl6YXRpb246IHNpbmNlIHRoaXMgaXMgY2FsbGVkIHR3aWNlIGZvciBwcm90by1ib3VuZCB0ZW1wbGF0ZXMsXG4gICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHJlY3JlYXRlIGFjY2Vzc29ycyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBwcmUtYm91bmRcbiAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlQmluZGluZykge1xuICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgLy8gYW5kIGxpbmsgaW50byB0cmVlIG9mIHRlbXBsYXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyhPYmplY3QuY3JlYXRlKHRlbXBsYXRlSW5mbykpO1xuICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgaWYgKCF0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSBpbmZvIHRvIHRoZSByb290IG9mIHRoZSB0cmVlXG4gICAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBcHBlbmQgdGhpcyB0ZW1wbGF0ZSBpbmZvIG9udG8gdGhlIGVuZCBvZiBpdHMgcGFyZW50IHRlbXBsYXRlJ3NcbiAgICAgICAgICAvLyBsaXN0LCB3aGljaCB3aWxsIGRldGVybWluZSB0aGUgdHJlZSBzdHJ1Y3R1cmUgdmlhIHdoaWNoIHByb3BlcnR5XG4gICAgICAgICAgLy8gZWZmZWN0cyBhcmUgcnVuOyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBub3QgbmVzdGVkIGluIGFub3RoZXJcbiAgICAgICAgICAvLyB0ZW1wbGF0ZSwgdXNlIHRoZSByb290IHRlbXBsYXRlICh0aGUgZmlyc3Qgc3RhbXBlZCBvbmUpIGFzIHRoZVxuICAgICAgICAgIC8vIHBhcmVudC4gTm90ZSwgYHBhcmVudGAgaXMgdGhlIGB0ZW1wbGF0ZUluZm9gIGluc3RhbmNlIGZvciB0aGlzXG4gICAgICAgICAgLy8gdGVtcGxhdGUncyBwYXJlbnQgKGNvbnRhaW5pbmcpIHRlbXBsYXRlLCB3aGljaCB3YXMgc2V0IHVwIGluXG4gICAgICAgICAgLy8gYGFwcGx5VGVtcGxhdGVJbmZvYC4gIFdoaWxlIGEgZ2l2ZW4gdGVtcGxhdGUncyBgcGFyZW50YCBpcyBzZXRcbiAgICAgICAgICAvLyBhcHJpb3JpLCBpdCBpcyBvbmx5IGFkZGVkIHRvIHRoZSBwYXJlbnQncyBjaGlsZCBsaXN0IGF0IHRoZSBwb2ludFxuICAgICAgICAgIC8vIHRoYXQgaXQgaXMgYmVpbmcgYm91bmQsIHNpbmNlIGEgdGVtcGxhdGUgbWF5IG9yIG1heSBub3QgZXZlciBiZVxuICAgICAgICAgIC8vIHN0YW1wZWQsIGFuZCBtYXkgYmUgc3RhbXBlZCBtb3JlIHRoYW4gb25jZSAoaW4gd2hpY2ggY2FzZSBpbnN0YW5jZXNcbiAgICAgICAgICAvLyBvZiB0aGUgdGVtcGxhdGUgaW5mbyB3aWxsIGJlIGluIHRoZSB0cmVlIHVuZGVyIGl0cyBwYXJlbnQgbW9yZSB0aGFuXG4gICAgICAgICAgLy8gb25jZSkuXG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGVtcGxhdGUuX3BhcmVudFRlbXBsYXRlSW5mbyB8fCB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gcGFyZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIHBhcmVudC5sYXN0Q2hpbGQgPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzU2libGluZyA9IHByZXZpb3VzO1xuICAgICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgICAgcHJldmlvdXMubmV4dFNpYmxpbmcgPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5maXJzdENoaWxkID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX3ByZUJvdW5kVGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcHJvcGVydHkgZWZmZWN0IHRvIHRoZSBnaXZlbiB0ZW1wbGF0ZSBtZXRhZGF0YSwgd2hpY2ggaXMgcnVuXG4gICAgICogYXQgdGhlIFwicHJvcGFnYXRlXCIgc3RhZ2Ugb2YgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgd2hlbiB0aGUgdGVtcGxhdGVcbiAgICAgKiBoYXMgYmVlbiBib3VuZCB0byB0aGUgZWxlbWVudCB2aWEgYF9iaW5kVGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogVGhlIGBlZmZlY3RgIG9iamVjdCBzaG91bGQgbWF0Y2ggdGhlIGZvcm1hdCBpbiBgX2FkZFByb3BlcnR5RWZmZWN0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgdG8gYWRkIGVmZmVjdCB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgIGxldCBlZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgfHwge307XG4gICAgICBsZXQgcHJvcEVmZmVjdHMgPSBlZmZlY3RzW3Byb3BdID0gZWZmZWN0c1twcm9wXSB8fCBbXTtcbiAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAqIFBvbHltZXIgdGVtcGxhdGUgZmVhdHVyZXMsIGluY2x1ZGluZyBkYXRhIGJpbmRpbmdzLCBkZWNsYXJhdGl2ZSBldmVudFxuICAgICAqIGxpc3RlbmVycywgYW5kIHRoZSBgdGhpcy4kYCBtYXAgb2YgYGlkYCdzIHRvIG5vZGVzLiAgQSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICogRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICogYHNoYWR5Y3NzYCBwb2x5ZmlsbCBsaW1pdGF0aW9ucywgb25seSBzdHlsZXMgZnJvbSB0ZW1wbGF0ZXMgcHJlcGFyZWRcbiAgICAgKiB1c2luZyBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCB3aWxsIGJlIGNvcnJlY3RseSBwb2x5ZmlsbGVkIChzY29wZWRcbiAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAqIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBlbGVtZW50LiBBcyBzdWNoLFxuICAgICAqIGFueSBzdHlsZXMgcmVxdWlyZWQgYnkgaW4gcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlcyBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSB0ZW1wbGF0ZUluZm8gT3B0aW9uYWwgYm91bmQgdGVtcGxhdGUgaW5mbyBhc3NvY2lhdGVkXG4gICAgICogICB3aXRoIHRoZSB0ZW1wbGF0ZSB0byBiZSBzdGFtcGVkOyBpZiBvbWl0dGVkIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlXG4gICAgICogICBhdXRvbWF0aWNhbGx5IGJvdW5kLlxuICAgICAqIEByZXR1cm4geyFTdGFtcGVkVGVtcGxhdGV9IENsb25lZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgIHRlbXBsYXRlSW5mbyA9ICB0ZW1wbGF0ZUluZm8gfHwgLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyh0aGlzLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpKTtcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBjcmVhdGVkIGRvbSBpcyBgX2VucXVldWVDbGllbnRgJ2QgdG8gdGhpcyBlbGVtZW50IHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgIGhvc3RTdGFjay5wdXNoKHRoaXMpO1xuICAgICAgbGV0IGRvbSA9IHN1cGVyLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgaG9zdFN0YWNrLnBvcCgpO1xuICAgICAgLy8gQWRkIHRlbXBsYXRlLWluc3RhbmNlLXNwZWNpZmljIGRhdGEgdG8gaW5zdGFuY2VkIHRlbXBsYXRlSW5mb1xuICAgICAgdGVtcGxhdGVJbmZvLm5vZGVMaXN0ID0gZG9tLm5vZGVMaXN0O1xuICAgICAgLy8gQ2FwdHVyZSBjaGlsZCBub2RlcyB0byBhbGxvdyB1bnN0YW1waW5nIG9mIG5vbi1wcm90b3R5cGljYWwgdGVtcGxhdGVzXG4gICAgICBpZiAoIXRlbXBsYXRlSW5mby53YXNQcmVCb3VuZCkge1xuICAgICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuPWRvbS5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb20udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgMi13YXkgbGlzdGVuZXJzLCBhbmQgZGF0YUhvc3QgZm9yIGJpbmRpbmdzXG4gICAgICBzZXR1cEJpbmRpbmdzKHRoaXMsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAvLyBGbHVzaCBwcm9wZXJ0aWVzIGludG8gdGVtcGxhdGUgbm9kZXM7IHRoZSBjaGVjayBvbiBgX19kYXRhQ2xpZW50c1JlYWR5YFxuICAgICAgLy8gZW5zdXJlcyB3ZSBkb24ndCBuZWVkbGVzc2x5IHJ1biBlZmZlY3RzIGZvciBhbiBlbGVtZW50J3MgaW5pdGlhbFxuICAgICAgLy8gcHJvdG90eXBpY2FsIHRlbXBsYXRlIHN0YW1waW5nIHNpbmNlIHRoZXkgd2lsbCBoYXBwZW4gYXMgYSBwYXJ0IG9mIHRoZVxuICAgICAgLy8gZmlyc3QgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYC4gVGhpcyBmbGFnIGlzIHNldCB0byB0cnVlXG4gICAgICAvLyBhZnRlciBydW5uaW5nIHRoZSBpbml0aWFsIHByb3BhZ2F0ZSBlZmZlY3RzLCBhbmQgaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyBmbHVzaGluZyBjbGllbnRzLiBTaW5jZSBkb3duc3RyZWFtIGNsaWVudHMgY291bGQgY2F1c2Ugc3RhbXBpbmcgb25cbiAgICAgIC8vIHRoaXMgaG9zdCAoZS5nLiBhIGZhc3REb21JZiBgZG9tLWlmYCBiZWluZyBmb3JjZWQgdG8gcmVuZGVyXG4gICAgICAvLyBzeW5jaHJvbm91c2x5KSwgdGhpcyBmbGFnIGVuc3VyZXMgZWZmZWN0cyBmb3IgcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlc1xuICAgICAgLy8gYXJlIHJ1biBhdCB0aGlzIHBvaW50IGR1cmluZyB0aGUgaW5pdGlhbCBlbGVtZW50IGJvb3QtdXAuXG4gICAgICBpZiAodGhpcy5fX2RhdGFDbGllbnRzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fcnVuRWZmZWN0c0ZvclRlbXBsYXRlKHRlbXBsYXRlSW5mbywgdGhpcy5fX2RhdGEsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZmx1c2hDbGllbnRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW5kIHVuYmluZHMgdGhlIG5vZGVzIHByZXZpb3VzbHkgY29udGFpbmVkIGluIHRoZSBwcm92aWRlZFxuICAgICAqIERvY3VtZW50RnJhZ21lbnQgcmV0dXJuZWQgZnJvbSBgX3N0YW1wVGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHshU3RhbXBlZFRlbXBsYXRlfSBkb20gRG9jdW1lbnRGcmFnbWVudCBwcmV2aW91c2x5IHJldHVybmVkXG4gICAgICogICBmcm9tIGBfc3RhbXBUZW1wbGF0ZWAgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlcyB0byBiZSByZW1vdmVkXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlbW92ZUJvdW5kRG9tKGRvbSkge1xuICAgICAgLy8gVW5saW5rIHRlbXBsYXRlIGluZm87IE5vdGUgdGhhdCB3aGlsZSB0aGUgY2hpbGQgaXMgdW5saW5rZWQgZnJvbSBpdHNcbiAgICAgIC8vIHBhcmVudCBsaXN0LCBhIHRlbXBsYXRlJ3MgYHBhcmVudGAgcmVmZXJlbmNlIGlzIG5ldmVyIHJlbW92ZWQsIHNpbmNlXG4gICAgICAvLyB0aGlzIGlzIGlzIGRldGVybWluZWQgYnkgdGhlIHRyZWUgc3RydWN0dXJlIGFuZCBhcHBsaWVkIGF0XG4gICAgICAvLyBgYXBwbHlUZW1wbGF0ZUluZm9gIHRpbWUuXG4gICAgICBjb25zdCB0ZW1wbGF0ZUluZm8gPSBkb20udGVtcGxhdGVJbmZvO1xuICAgICAgY29uc3Qge3ByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcsIHBhcmVudH0gPSB0ZW1wbGF0ZUluZm87XG4gICAgICBpZiAocHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIHByZXZpb3VzU2libGluZy5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmZpcnN0Q2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQubGFzdENoaWxkID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGVJbmZvLm5leHRTaWJsaW5nID0gdGVtcGxhdGVJbmZvLnByZXZpb3VzU2libGluZyA9IG51bGw7XG4gICAgICAvLyBSZW1vdmUgc3RhbXBlZCBub2Rlc1xuICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgd3JhcCh3cmFwKG5vZGUpLnBhcmVudE5vZGUpLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYFRleHROb2RlYCdzJyBgdGV4dENvbnRlbnRgLiAgQSBgYmluZGluZ3NgXG4gICAgICogYXJyYXkgaXMgYWRkZWQgdG8gYG5vZGVJbmZvYCBhbmQgcG9wdWxhdGVkIHdpdGggYmluZGluZyBtZXRhZGF0YVxuICAgICAqIHdpdGggaW5mb3JtYXRpb24gY2FwdHVyaW5nIHRoZSBiaW5kaW5nIHRhcmdldCwgYW5kIGEgYHBhcnRzYCBhcnJheVxuICAgICAqIHdpdGggb25lIG9yIG1vcmUgbWV0YWRhdGEgb2JqZWN0cyBjYXB0dXJpbmcgdGhlIHNvdXJjZShzKSBvZiB0aGVcbiAgICAgKiBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMyNDApOlxuICAgICAgLy8gICAgIENoYW5nZSBiYWNrIHRvIGp1c3Qgc3VwZXIubWV0aG9kQ2FsbCgpXG4gICAgICBsZXQgbm90ZWQgPSBwcm9wZXJ0eUVmZmVjdHNCYXNlLl9wYXJzZVRlbXBsYXRlTm9kZS5jYWxsKFxuICAgICAgICB0aGlzLCBub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKG5vZGUudGV4dENvbnRlbnQsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRleHRDb250ZW50IHdpdGggYW55IGxpdGVyYWwgcGFydHNcbiAgICAgICAgICAvLyBOT1RFOiBkZWZhdWx0IHRvIGEgc3BhY2UgaGVyZSBzbyB0aGUgdGV4dE5vZGUgcmVtYWluczsgc29tZSBicm93c2Vyc1xuICAgICAgICAgIC8vIChJRSkgb21pdCBhbiBlbXB0eSB0ZXh0Tm9kZSBmb2xsb3dpbmcgY2xvbmVOb2RlL2ltcG9ydE5vZGUuXG4gICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHx8ICcgJztcbiAgICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sICd0ZXh0JywgJ3RleHRDb250ZW50JywgcGFydHMpO1xuICAgICAgICAgIG5vdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYXR0cmlidXRlcy4gIEEgYGJpbmRpbmdzYFxuICAgICAqIGFycmF5IGlzIGFkZGVkIHRvIGBub2RlSW5mb2AgYW5kIHBvcHVsYXRlZCB3aXRoIGJpbmRpbmcgbWV0YWRhdGFcbiAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICogYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKHZhbHVlLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIC8vIEF0dHJpYnV0ZSBvciBwcm9wZXJ0eVxuICAgICAgICBsZXQgb3JpZ05hbWUgPSBuYW1lO1xuICAgICAgICBsZXQga2luZCA9ICdwcm9wZXJ0eSc7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB3ZSBzZWUgYSBjYXBpdGFsIGxldHRlciBoZXJlIGlzIGlmIHRoZSBhdHRyIGhhc1xuICAgICAgICAvLyBhIGNhcGl0YWwgbGV0dGVyIGluIGl0IHBlciBzcGVjLiBJbiB0aGlzIGNhc2UsIHRvIG1ha2Ugc3VyZVxuICAgICAgICAvLyB0aGlzIGJpbmRpbmcgd29ya3MsIHdlIGdvIGFoZWFkIGFuZCBtYWtlIHRoZSBiaW5kaW5nIHRvIHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgIGlmIChjYXBpdGFsQXR0cmlidXRlUmVnZXgudGVzdChuYW1lKSkge1xuICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lW25hbWUubGVuZ3RoLTFdID09ICckJykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICBraW5kID0gJ2F0dHJpYnV0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdHRyaWJ1dGUgYmluZGluZ3Mgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICBsZXQgbGl0ZXJhbCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpO1xuICAgICAgICBpZiAobGl0ZXJhbCAmJiBraW5kID09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIGEgU2hhZHlDU1MgdGVtcGxhdGUgc2NvcGVkIHN0eWxlIGlzIG5vdCByZW1vdmVkXG4gICAgICAgICAgLy8gd2hlbiBhIGNsYXNzJCBiaW5kaW5nJ3MgaW5pdGlhbCBsaXRlcmFsIHZhbHVlIGlzIHNldC5cbiAgICAgICAgICBpZiAobmFtZSA9PSAnY2xhc3MnICYmIG5vZGUuaGFzQXR0cmlidXRlKCdjbGFzcycpKSB7XG4gICAgICAgICAgICBsaXRlcmFsICs9ICcgJyArIG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdXBwb3J0IGRpc2FibGUtdXBncmFkZVxuICAgICAgICBpZiAoa2luZCA9PSAnYXR0cmlidXRlJyAmJiBvcmlnTmFtZSA9PSAnZGlzYWJsZS11cGdyYWRlJCcpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgYXR0cmlidXRlIGJlZm9yZSByZW1vdmluZywgc2luY2UgSUUgd29uJ3QgYWxsb3cgcmVtb3ZpbmdcbiAgICAgICAgLy8gYHZhbHVlYCBhdHRyaWJ1dGUgaWYgaXQgcHJldmlvdXNseSBoYWQgYSB2YWx1ZSAoY2FuJ3RcbiAgICAgICAgLy8gdW5jb25kaXRpb25hbGx5IHNldCAnJyBiZWZvcmUgcmVtb3Zpbmcgc2luY2UgYXR0cmlidXRlcyB3aXRoIGAkYFxuICAgICAgICAvLyBjYW4ndCBiZSBzZXQgdXNpbmcgc2V0QXR0cmlidXRlKVxuICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgb3JpZ05hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShvcmlnTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbm5vdGF0aW9uXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG9yaWdOYW1lKTtcbiAgICAgICAgLy8gQ2FzZSBoYWNrZXJ5OiBhdHRyaWJ1dGVzIGFyZSBsb3dlci1jYXNlLCBidXQgYmluZCB0YXJnZXRzXG4gICAgICAgIC8vIChwcm9wZXJ0aWVzKSBhcmUgY2FzZSBzZW5zaXRpdmUuIEdhbWJpdCBpcyB0byBtYXAgZGFzaC1jYXNlIHRvXG4gICAgICAgIC8vIGNhbWVsLWNhc2U6IGBmb28tYmFyYCBiZWNvbWVzIGBmb29CYXJgLlxuICAgICAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ3MgYXJlIGV4Y2VwdGVkLlxuICAgICAgICBpZiAoa2luZCA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgIG5hbWUgPSBkYXNoVG9DYW1lbENhc2UobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBraW5kLCBuYW1lLCBwYXJ0cywgbGl0ZXJhbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMyNDApOlxuICAgICAgICAvLyAgICAgQ2hhbmdlIGJhY2sgdG8ganVzdCBzdXBlci5tZXRob2RDYWxsKClcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5RWZmZWN0c0Jhc2UuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlLmNhbGwoXG4gICAgICAgICAgdGhpcywgbm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgKiBiaW5kaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYSBuZXN0ZWQgdGVtcGxhdGUgZGVwZW5kcyBvbiB0byB0aGUgdGVtcGxhdGVcbiAgICAgKiBhcyBgX2hvc3RfPHByb3BlcnR5PmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgLy8gVE9ETyhodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMyNDApOlxuICAgICAgLy8gICAgIENoYW5nZSBiYWNrIHRvIGp1c3Qgc3VwZXIubWV0aG9kQ2FsbCgpXG4gICAgICBsZXQgbm90ZWQgPSBwcm9wZXJ0eUVmZmVjdHNCYXNlLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUuY2FsbChcbiAgICAgICAgdGhpcywgbm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBuZXN0ZWRUZW1wbGF0ZUluZm8gPSBub2RlSW5mby50ZW1wbGF0ZUluZm87XG4gICAgICBjb25zdCBpc0RvbUlmID0gcGFyZW50LmxvY2FsTmFtZSA9PT0gJ2RvbS1pZic7XG4gICAgICBjb25zdCBpc0RvbVJlcGVhdCA9IHBhcmVudC5sb2NhbE5hbWUgPT09ICdkb20tcmVwZWF0JztcbiAgICAgIC8vIFJlbW92ZSBuZXN0ZWQgdGVtcGxhdGUgYW5kIHJlZGlyZWN0IGl0cyBob3N0IGJpbmRpbmdzICYgdGVtcGxhdGVJbmZvXG4gICAgICAvLyBvbnRvIHRoZSBwYXJlbnQgKGRvbS1pZi9yZXBlYXQgZWxlbWVudCkncyBub2RlSW5mb1xuICAgICAgaWYgKHJlbW92ZU5lc3RlZFRlbXBsYXRlcyAmJiAoaXNEb21JZiB8fCBpc0RvbVJlcGVhdCkpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAvLyBVc2UgdGhlIHBhcmVudCdzIG5vZGVJbmZvIChmb3IgdGhlIGRvbS1pZi9yZXBlYXQpIHRvIHJlY29yZCB0aGVcbiAgICAgICAgLy8gdGVtcGxhdGVJbmZvLCBhbmQgdXNlIHRoYXQgZm9yIGFueSBob3N0IHByb3BlcnR5IGJpbmRpbmdzIGJlbG93XG4gICAgICAgIG5vZGVJbmZvID0gbm9kZUluZm8ucGFyZW50SW5mbztcbiAgICAgICAgbm9kZUluZm8udGVtcGxhdGVJbmZvID0gbmVzdGVkVGVtcGxhdGVJbmZvO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIHBhcmVudCBkb20taWYvcmVwZWF0IGlzIG5vdGVkIHNpbmNlIGl0IG5vdyBtYXkgaGF2ZSBob3N0XG4gICAgICAgIC8vIGJpbmRpbmdzOyBpdCBtYXkgbm90IGhhdmUgYmVlbiBpZiBpdCBkaWQgbm90IGhhdmUgaXRzIG93biBiaW5kaW5nc1xuICAgICAgICBub2RlSW5mby5ub3RlZCA9IHRydWU7XG4gICAgICAgIG5vdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSBob3N0IHByb3BzIGludG8gb3V0ZXIgdGVtcGxhdGUgYW5kIGFkZCBiaW5kaW5nc1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IG5lc3RlZFRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICBpZiAoZmFzdERvbUlmICYmIGlzRG9tSWYpIHtcbiAgICAgICAgLy8gYGZhc3REb21JZmAgbW9kZSB1c2VzIHJ1bnRpbWUtdGVtcGxhdGUgc3RhbXBpbmcgdG8gYWRkIGFjY2Vzc29ycy9cbiAgICAgICAgLy8gZWZmZWN0cyB0byBwcm9wZXJ0aWVzIHVzZWQgaW4gaXRzIHRlbXBsYXRlOyBhcyBzdWNoIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgLy8gdGF4IHRoZSBob3N0IGVsZW1lbnQgd2l0aCBgX2hvc3RfYCBiaW5kaW5ncyBmb3IgdGhlIGBkb20taWZgLlxuICAgICAgICAvLyBIb3dldmVyLCBpbiB0aGUgZXZlbnQgaXQgaXMgbmVzdGVkIGluIGEgYGRvbS1yZXBlYXRgLCBpdCBpcyBzdGlsbFxuICAgICAgICAvLyBpbXBvcnRhbnQgdGhhdCBpdHMgaG9zdCBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byB0aGVcbiAgICAgICAgLy8gVGVtcGxhdGVJbnN0YW5jZSdzIGBob3N0UHJvcHNgIHNvIHRoYXQgdGhleSBhcmUgZm9yd2FyZGVkIHRvIHRoZVxuICAgICAgICAvLyBUZW1wbGF0ZUluc3RhbmNlLlxuICAgICAgICBpZiAoaG9zdFByb3BzKSB7XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyA9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgfHwge30sIGhvc3RQcm9wcyk7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoZSBkb20taWYgaXMgbm90ZWQgc28gdGhhdCBpdCBoYXMgYSBfX2RhdGFIb3N0LCBzaW5jZVxuICAgICAgICAgIC8vIGBmYXN0RG9tSWZgIHVzZXMgdGhlIGhvc3QgZm9yIHJ1bnRpbWUgdGVtcGxhdGUgc3RhbXBpbmc7IG5vdGUgdGhpc1xuICAgICAgICAgIC8vIHdhcyBhbHJlYWR5IGVuc3VyZWQgYWJvdmUgaW4gdGhlIGByZW1vdmVOZXN0ZWRUZW1wbGF0ZXNgIGNhc2VcbiAgICAgICAgICBpZiAoIXJlbW92ZU5lc3RlZFRlbXBsYXRlcykge1xuICAgICAgICAgICAgbm9kZUluZm8ucGFyZW50SW5mby5ub3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbW9kZSA9ICd7JztcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIGhvc3RQcm9wcykge1xuICAgICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSwgaG9zdFByb3A6IHRydWUgfV07XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAncHJvcGVydHknLCAnX2hvc3RfJyArIHNvdXJjZSwgcGFydHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHRvIHBhcnNlIHRleHQgaW4gYSB0ZW1wbGF0ZSAoZWl0aGVyIGF0dHJpYnV0ZSB2YWx1ZXMgb3JcbiAgICAgKiB0ZXh0Q29udGVudCkgaW50byBiaW5kaW5nIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQW55IG92ZXJyaWRlcyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIGJpbmRpbmcgcGFydFxuICAgICAqIG1ldGFkYXRhICByZXByZXNlbnRpbmcgb25lIG9yIG1vcmUgYmluZGluZ3MgZm91bmQgaW4gdGhlIHByb3ZpZGVkIHRleHRcbiAgICAgKiBhbmQgYW55IFwibGl0ZXJhbFwiIHRleHQgaW4gYmV0d2Vlbi4gIEFueSBub24tbGl0ZXJhbCBwYXJ0cyB3aWxsIGJlIHBhc3NlZFxuICAgICAqIHRvIGBfZXZhbHVhdGVCaW5kaW5nYCB3aGVuIGFueSBkZXBlbmRlbmNpZXMgY2hhbmdlLiAgVGhlIG9ubHkgcmVxdWlyZWRcbiAgICAgKiBmaWVsZHMgb2YgZWFjaCBcInBhcnRcIiBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgYXJlIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiAtIGBkZXBlbmRlbmNpZXNgIC0gQXJyYXkgY29udGFpbmluZyB0cmlnZ2VyIG1ldGFkYXRhIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICogICB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBiaW5kaW5nIHRvIHVwZGF0ZVxuICAgICAqIC0gYGxpdGVyYWxgIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGV4dCBpZiB0aGUgcGFydCByZXByZXNlbnRzIGEgbGl0ZXJhbDtcbiAgICAgKiAgIGluIHRoaXMgY2FzZSBubyBgZGVwZW5kZW5jaWVzYCBhcmUgbmVlZGVkXG4gICAgICpcbiAgICAgKiBBZGRpdGlvbmFsIG1ldGFkYXRhIGZvciB1c2UgYnkgYF9ldmFsdWF0ZUJpbmRpbmdgIG1heSBiZSBwcm92aWRlZCBpblxuICAgICAqIGVhY2ggcGFydCBvYmplY3QgYXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGFuZGxlcyB0aGUgZm9sbG93aW5nIHR5cGVzIG9mIGJpbmRpbmdzXG4gICAgICogKG9uZSBvciBtb3JlIG1heSBiZSBpbnRlcm1peGVkIHdpdGggbGl0ZXJhbCBzdHJpbmdzKTpcbiAgICAgKiAtIFByb3BlcnR5IGJpbmRpbmc6IGBbW3Byb3BdXWBcbiAgICAgKiAtIFBhdGggYmluZGluZzogYFtbb2JqZWN0LnByb3BdXWBcbiAgICAgKiAtIE5lZ2F0ZWQgcHJvcGVydHkgb3IgcGF0aCBiaW5kaW5nczogYFtbIXByb3BdXWAgb3IgYFtbIW9iamVjdC5wcm9wXV1gXG4gICAgICogLSBUd28td2F5IHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3MgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgKiAgIGB7e3Byb3B9fWAsIGB7e29iamVjdC5wcm9wfX1gLCBge3shcHJvcH19YCBvciBge3shb2JqZWN0LnByb3B9fWBcbiAgICAgKiAtIElubGluZSBjb21wdXRlZCBtZXRob2QgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgKiAgIGBbW2NvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYCwgYFtbIWNvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYFxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gdXNlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgYmVzdFxuICAgICAqIHBlcmZvcm1hbmNlLiBIb3dldmVyLCB0aGUgcmVndWxhciBleHByZXNzaW9uIHVzZXMgYSB3aGl0ZS1saXN0IG9mXG4gICAgICogYWxsb3dlZCBjaGFyYWN0ZXJzIGluIGEgZGF0YS1iaW5kaW5nLCB3aGljaCBjYXVzZXMgcHJvYmxlbXMgZm9yXG4gICAgICogZGF0YS1iaW5kaW5ncyB0aGF0IGRvIHVzZSBjaGFyYWN0ZXJzIG5vdCBpbiB0aGlzIHdoaXRlLWxpc3QuXG4gICAgICpcbiAgICAgKiBJbnN0ZWFkIG9mIHVwZGF0aW5nIHRoZSB3aGl0ZS1saXN0IHdpdGggYWxsIGFsbG93ZWQgY2hhcmFjdGVycyxcbiAgICAgKiB0aGVyZSBpcyBhIFN0cmljdEJpbmRpbmdQYXJzZXIgKHNlZSBsaWIvbWl4aW5zL3N0cmljdC1iaW5kaW5nLXBhcnNlcilcbiAgICAgKiB0aGF0IHVzZXMgYSBzdGF0ZSBtYWNoaW5lIGluc3RlYWQuIFRoaXMgc3RhdGUgbWFjaGluZSBpcyBhYmxlIHRvIGhhbmRsZVxuICAgICAqIGFsbCBjaGFyYWN0ZXJzLiBIb3dldmVyLCBpdCBpcyBzbGlnaHRseSBsZXNzIHBlcmZvcm1hbnQsIHRoZXJlZm9yZSB3ZVxuICAgICAqIGV4dHJhY3RlZCBpdCBpbnRvIGEgc2VwYXJhdGUgb3B0aW9uYWwgbWl4aW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHRvIHBhcnNlIGZyb20gYXR0cmlidXRlIG9yIHRleHRDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBDdXJyZW50IHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogQHJldHVybiB7QXJyYXk8IUJpbmRpbmdQYXJ0Pn0gQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZUJpbmRpbmdzKHRleHQsIHRlbXBsYXRlSW5mbykge1xuICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtO1xuICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAvLyBSZWdleCBtYXRjaGVzOlxuICAgICAgLy8gICAgICAgIEl0ZXJhdGlvbiAxOiAgSXRlcmF0aW9uIDI6XG4gICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgIC8vIG1bMl06ICcnICAgICAgICAgICAgJyEnXG4gICAgICAvLyBtWzNdOiAncHJvcCcgICAgICAgICdjb21wdXRlKGZvbyxiYXIpJ1xuICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCBsaXRlcmFsIHBhcnRcbiAgICAgICAgaWYgKG0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYmluZGluZyBwYXJ0XG4gICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IEJvb2xlYW4obVsyXSk7XG4gICAgICAgIGxldCBzb3VyY2UgPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgIGlmIChtb2RlID09ICd7JyAmJiAoY29sb24gPSBzb3VyY2UuaW5kZXhPZignOjonKSkgPiAwKSB7XG4gICAgICAgICAgbm90aWZ5RXZlbnQgPSBzb3VyY2Uuc3Vic3RyaW5nKGNvbG9uICsgMik7XG4gICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgY3VzdG9tRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICBsZXQge2FyZ3MsIG1ldGhvZE5hbWV9ID0gc2lnbmF0dXJlO1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucztcbiAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgc2lnbmF0dXJlLmR5bmFtaWNGbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFByb3BlcnR5IG9yIHBhdGhcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgZXZlbnQ6IG5vdGlmeUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIGEgZmluYWwgbGl0ZXJhbCBwYXJ0XG4gICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaXRlcmFsID0gdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGxpdGVyYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgKiBvbmUgb3IgbW9yZSBjaGFuZ2VkIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBpbnN0IEVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCBhc1xuICAgICAqICAgICBzY29wZSBmb3IgYmluZGluZyBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcGFyYW0ge0JpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggdGhhdCB0cmlnZ2VyZWQgdGhpcyBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAgICogQHJldHVybiB7Kn0gVmFsdWUgdGhlIGJpbmRpbmcgcGFydCBldmFsdWF0ZWQgdG9cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgdmFsdWUgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBwYXJ0LnNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGggIT0gcGFydC5zb3VyY2UpIHtcbiAgICAgICAgdmFsdWUgPSBnZXQoaW5zdCwgcGFydC5zb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhhc1BhdGhzICYmIGlzUGF0aChwYXRoKSkge1xuICAgICAgICAgIHZhbHVlID0gZ2V0KGluc3QsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW5zdC5fX2RhdGFbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0Lm5lZ2F0ZSkge1xuICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQcm9wZXJ0eUVmZmVjdHM7XG59KTtcblxuLyoqXG4gKiBTdGFjayBmb3IgZW5xdWV1aW5nIGNsaWVudCBkb20gY3JlYXRlZCBieSBhIGhvc3QgZWxlbWVudC5cbiAqXG4gKiBCeSBkZWZhdWx0IGVsZW1lbnRzIGFyZSBmbHVzaGVkIHZpYSBgX2ZsdXNoUHJvcGVydGllc2Agd2hlblxuICogYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBjYWxsZWQuIEVsZW1lbnRzIGF0dGFjaCB0aGVpciBjbGllbnQgZG9tIHRvXG4gKiB0aGVtc2VsdmVzIGF0IGByZWFkeWAgdGltZSB3aGljaCByZXN1bHRzIGZyb20gdGhpcyBmaXJzdCBmbHVzaC5cbiAqIFRoaXMgcHJvdmlkZXMgYW4gb3JkZXJpbmcgZ3VhcmFudGVlIHRoYXQgdGhlIGNsaWVudCBkb20gYW4gZWxlbWVudFxuICogY3JlYXRlcyBpcyBmbHVzaGVkIGJlZm9yZSB0aGUgZWxlbWVudCBpdHNlbGYgKGkuZS4gY2xpZW50IGByZWFkeWBcbiAqIGZpcmVzIGJlZm9yZSBob3N0IGByZWFkeWApLlxuICpcbiAqIEhvd2V2ZXIsIGlmIGBfZmx1c2hQcm9wZXJ0aWVzYCBpcyBjYWxsZWQgKmJlZm9yZSogYW4gZWxlbWVudCBpcyBjb25uZWN0ZWQsXG4gKiBhcyBmb3IgZXhhbXBsZSBgVGVtcGxhdGl6ZWAgZG9lcywgdGhpcyBvcmRlcmluZyBndWFyYW50ZWUgY2Fubm90IGJlXG4gKiBzYXRpc2ZpZWQgYmVjYXVzZSBubyBlbGVtZW50cyBhcmUgY29ubmVjdGVkLiAoTm90ZTogQm91bmQgZWxlbWVudHMgdGhhdFxuICogcmVjZWl2ZSBkYXRhIGRvIGJlY29tZSBlbnF1ZXVlZCBjbGllbnRzIGFuZCBhcmUgcHJvcGVybHkgb3JkZXJlZCBidXRcbiAqIHVuYm91bmQgZWxlbWVudHMgYXJlIG5vdC4pXG4gKlxuICogVG8gbWFpbnRhaW4gdGhlIGRlc2lyZWQgXCJjbGllbnQgYmVmb3JlIGhvc3RcIiBvcmRlcmluZyBndWFyYW50ZWUgZm9yIHRoaXNcbiAqIGNhc2Ugd2UgcmVseSBvbiB0aGUgXCJob3N0IHN0YWNrLiBDbGllbnQgbm9kZXMgcmVnaXN0ZXJzIHRoZW1zZWx2ZXMgd2l0aFxuICogdGhlIGNyZWF0aW5nIGhvc3QgZWxlbWVudCB3aGVuIGNyZWF0ZWQuIFRoaXMgZW5zdXJlcyB0aGF0IGFsbCBjbGllbnQgZG9tXG4gKiBpcyByZWFkaWVkIGluIHRoZSBwcm9wZXIgb3JkZXIsIG1haW50YWluaW5nIHRoZSBkZXNpcmVkIGd1YXJhbnRlZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBob3N0U3RhY2sgPSBbXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-effects.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/template-stamp.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/template-stamp.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TemplateStamp\": () => (/* binding */ TemplateStamp)\n/* harmony export */ });\n/* harmony import */ var _utils_boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\n/**\n * Copies an attribute from one element to another, converting the value to a\n * `TrustedScript` if it is named like a Polymer template event listener.\n *\n * @param {!Element} dest The element to set the attribute on\n * @param {!Element} src The element to read the attribute from\n * @param {string} name The name of the attribute\n */\nconst copyAttributeWithTemplateEventPolicy = (() => {\n  /**\n   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted\n   * Types API where any attribute that starts with `on` may only be set to a\n   * `TrustedScript` value, even if that attribute would not cause an event\n   * listener to be created. (See https://crbug.com/993268 for details.)\n   *\n   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be\n   * written using the `<template is=\"...\">` syntax, even if there is no UA\n   * support for custom element extensions of built-in elements. In doing so, it\n   * copies attributes from the original `<template>` to a newly created\n   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if\n   * any of those attributes uses Polymer's `on-` syntax for event listeners.\n   * (Note, the value of these `on-` listeners is not evaluated as script: it is\n   * the name of a member function of a component that will be used as the event\n   * listener.)\n   *\n   * @type {!TrustedTypePolicy|undefined}\n   */\n  const polymerTemplateEventAttributePolicy = window.trustedTypes && window.trustedTypes.createPolicy('polymer-template-event-attribute-policy', {\n    createScript: x => x\n  });\n  return (dest, src, name) => {\n    const value = src.getAttribute(name);\n    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {\n      dest.setAttribute(name, polymerTemplateEventAttributePolicy.createScript(value, name));\n      return;\n    }\n    dest.setAttribute(name, value);\n  };\n})();\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while (t.attributes.length) {\n      const {\n        name\n      } = t.attributes[0];\n      copyAttributeWithTemplateEventPolicy(node, t, name);\n      t.removeAttribute(name);\n    }\n  }\n  return node;\n}\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function (e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nconst TemplateStamp = (0,_utils_mixin_js__WEBPACK_IMPORTED_MODULE_1__.dedupingMixin)(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nsuperClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let /** ? */templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute && template.hasAttribute('strip-whitespace');\n        // TODO(rictic): fix typing\n        this._parseTemplateContent(template, templateInfo, /** @type {?} */{\n          parent: null\n        });\n      }\n      return template._templateInfo;\n    }\n\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element = /** @type {!HTMLTemplateElement} */node;\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      fixPlaceholder(element);\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n      return noted || nodeInfo.noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */n = next;\n          while (n && n.nodeType === Node.TEXT_NODE) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo = /** @type {!NodeInfo} */{\n          parentIndex,\n          parentInfo: nodeInfo\n        };\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        }\n        // Increment if not removed\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element = /** @type {!HTMLTemplateElement} */node;\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n      let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n      return templateInfo && templateInfo.content || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */document.importNode(content, true);\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n  }\n  return TemplateStamp;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvdGVtcGxhdGUtc3RhbXAuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvdGVtcGxhdGUtc3RhbXAuanM/M2IyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcblxuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcblxuLy8gMS54IGJhY2t3YXJkcy1jb21wYXRpYmxlIGF1dG8td3JhcHBlciBmb3IgdGVtcGxhdGUgdHlwZSBleHRlbnNpb25zXG4vLyBUaGlzIGlzIGEgY2xlYXIgbGF5ZXJpbmcgdmlvbGF0aW9uIGFuZCBnaXZlcyBmYXZvcmVkLW5hdGlvbiBzdGF0dXMgdG9cbi8vIGRvbS1pZiBhbmQgZG9tLXJlcGVhdCB0ZW1wbGF0ZXMuICBUaGlzIGlzIGEgY29uY2VpdCB3ZSdyZSBjaG9vc2luZyB0byBrZWVwXG4vLyBhLikgdG8gZWFzZSAxLnggYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZHVlIHRvIGxvc3Mgb2YgYGlzYCwgYW5kXG4vLyBiLikgdG8gbWFpbnRhaW4gaWYvcmVwZWF0IGNhcGFiaWxpdHkgaW4gcGFyc2VyLWNvbnN0cmFpbmVkIGVsZW1lbnRzXG4vLyAgICAgKGUuZy4gdGFibGUsIHNlbGVjdCkgaW4gbGlldSBvZiBuYXRpdmUgQ0UgdHlwZSBleHRlbnNpb25zIHdpdGhvdXRcbi8vICAgICBtYXNzaXZlIG5ldyBpbnZlbnRpb24gaW4gdGhpcyBzcGFjZSAoZS5nLiBkaXJlY3RpdmUgc3lzdGVtKVxuY29uc3QgdGVtcGxhdGVFeHRlbnNpb25zID0ge1xuICAnZG9tLWlmJzogdHJ1ZSxcbiAgJ2RvbS1yZXBlYXQnOiB0cnVlXG59O1xuXG5sZXQgcGxhY2Vob2xkZXJCdWdEZXRlY3QgPSBmYWxzZTtcbmxldCBwbGFjZWhvbGRlckJ1ZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBoYXNQbGFjZWhvbGRlckJ1ZygpIHtcbiAgaWYgKCFwbGFjZWhvbGRlckJ1Z0RldGVjdCkge1xuICAgIHBsYWNlaG9sZGVyQnVnRGV0ZWN0ID0gdHJ1ZTtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0LnBsYWNlaG9sZGVyID0gJ2EnO1xuICAgIHBsYWNlaG9sZGVyQnVnID0gdC5wbGFjZWhvbGRlciA9PT0gdC50ZXh0Q29udGVudDtcbiAgfVxuICByZXR1cm4gcGxhY2Vob2xkZXJCdWc7XG59XG5cbi8qKlxuICogU29tZSBicm93c2VycyBoYXZlIGEgYnVnIHdpdGggdGV4dGFyZWEsIHdoZXJlIHBsYWNlaG9sZGVyIHRleHQgaXMgY29waWVkIGFzXG4gKiBhIHRleHRub2RlIGNoaWxkIG9mIHRoZSB0ZXh0YXJlYS5cbiAqXG4gKiBJZiB0aGUgcGxhY2Vob2xkZXIgaXMgYSBiaW5kaW5nLCB0aGlzIGNhbiBicmVhayB0ZW1wbGF0ZSBzdGFtcGluZyBpbiB0d29cbiAqIHdheXMuXG4gKlxuICogT25lIGlzc3VlIGlzIHRoYXQgd2hlbiB0aGUgYHBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCB3aGVuIHRoZVxuICogYmluZGluZyBpcyBwcm9jZXNzZWQsIHRoZSB0ZXh0bm9kZSBjaGlsZCBvZiB0aGUgdGV4dGFyZWEgaXMgZGVsZXRlZCwgYW5kIHRoZVxuICogdGVtcGxhdGUgaW5mbyB0cmllcyB0byBiaW5kIGludG8gdGhhdCBub2RlLlxuICpcbiAqIFdpdGggYGxlZ2FjeU9wdGltaXphdGlvbnNgIGluIHVzZSwgd2hlbiB0aGUgdGVtcGxhdGUgaXMgc3RhbXBlZCBhbmQgdGhlXG4gKiBgdGV4dGFyZWEudGV4dENvbnRlbnRgIGJpbmRpbmcgaXMgcHJvY2Vzc2VkLCBubyBjb3JyZXNwb25kaW5nIG5vZGUgaXMgZm91bmRcbiAqIGJlY2F1c2UgaXQgd2FzIHJlbW92ZWQgZHVyaW5nIHBhcnNpbmcuIEFuIGV4Y2VwdGlvbiBpcyBnZW5lcmF0ZWQgd2hlbiB0aGlzXG4gKiBiaW5kaW5nIGlzIHVwZGF0ZWQuXG4gKlxuICogV2l0aCBgbGVnYWN5T3B0aW1pemF0aW9uc2Agbm90IGluIHVzZSwgdGhlIHRlbXBsYXRlIGlzIGNsb25lZCBiZWZvcmVcbiAqIHByb2Nlc3NpbmcgYW5kIHRoaXMgY2hhbmdlcyB0aGUgYWJvdmUgYmVoYXZpb3IuIFRoZSBjbG9uZWQgdGVtcGxhdGUgYWxzbyBoYXNcbiAqIGEgdmFsdWUgcHJvcGVydHkgc2V0IHRvIHRoZSBwbGFjZWhvbGRlciBhbmQgdGV4dENvbnRlbnQuIFRoaXMgcHJldmVudHMgdGhlXG4gKiByZW1vdmFsIG9mIHRoZSB0ZXh0Q29udGVudCB3aGVuIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGUgaXMgcmVtb3ZlZC5cbiAqIFRoZXJlZm9yZSB0aGUgZXhjZXB0aW9uIGRvZXMgbm90IG9jY3VyLiBIb3dldmVyLCB0aGVyZSBpcyBhbiBleHRyYVxuICogdW5uZWNlc3NhcnkgYmluZGluZy5cbiAqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlIENoZWNrIG5vZGUgZm9yIHBsYWNlaG9sZGVyIGJ1Z1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZml4UGxhY2Vob2xkZXIobm9kZSkge1xuICBpZiAoaGFzUGxhY2Vob2xkZXJCdWcoKSAmJiBub2RlLmxvY2FsTmFtZSA9PT0gJ3RleHRhcmVhJyAmJiBub2RlLnBsYWNlaG9sZGVyXG4gICAgICAgICYmIG5vZGUucGxhY2Vob2xkZXIgPT09IG5vZGUudGV4dENvbnRlbnQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvcGllcyBhbiBhdHRyaWJ1dGUgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyLCBjb252ZXJ0aW5nIHRoZSB2YWx1ZSB0byBhXG4gKiBgVHJ1c3RlZFNjcmlwdGAgaWYgaXQgaXMgbmFtZWQgbGlrZSBhIFBvbHltZXIgdGVtcGxhdGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHshRWxlbWVudH0gZGVzdCBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBvblxuICogQHBhcmFtIHshRWxlbWVudH0gc3JjIFRoZSBlbGVtZW50IHRvIHJlYWQgdGhlIGF0dHJpYnV0ZSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gKi9cbmNvbnN0IGNvcHlBdHRyaWJ1dGVXaXRoVGVtcGxhdGVFdmVudFBvbGljeSA9ICgoKSA9PiB7XG4gIC8qKlxuICAgKiBUaGlzIGBUcnVzdGVkVHlwZVBvbGljeWAgaXMgdXNlZCB0byB3b3JrIGFyb3VuZCBhIENocm9tZSBidWcgaW4gdGhlIFRydXN0ZWRcbiAgICogVHlwZXMgQVBJIHdoZXJlIGFueSBhdHRyaWJ1dGUgdGhhdCBzdGFydHMgd2l0aCBgb25gIG1heSBvbmx5IGJlIHNldCB0byBhXG4gICAqIGBUcnVzdGVkU2NyaXB0YCB2YWx1ZSwgZXZlbiBpZiB0aGF0IGF0dHJpYnV0ZSB3b3VsZCBub3QgY2F1c2UgYW4gZXZlbnRcbiAgICogbGlzdGVuZXIgdG8gYmUgY3JlYXRlZC4gKFNlZSBodHRwczovL2NyYnVnLmNvbS85OTMyNjggZm9yIGRldGFpbHMuKVxuICAgKlxuICAgKiBQb2x5bWVyJ3MgdGVtcGxhdGUgc3lzdGVtIGFsbG93cyBgPGRvbS1pZj5gIGFuZCBgPGRvbS1yZXBlYXQ+YCB0byBiZVxuICAgKiB3cml0dGVuIHVzaW5nIHRoZSBgPHRlbXBsYXRlIGlzPVwiLi4uXCI+YCBzeW50YXgsIGV2ZW4gaWYgdGhlcmUgaXMgbm8gVUFcbiAgICogc3VwcG9ydCBmb3IgY3VzdG9tIGVsZW1lbnQgZXh0ZW5zaW9ucyBvZiBidWlsdC1pbiBlbGVtZW50cy4gSW4gZG9pbmcgc28sIGl0XG4gICAqIGNvcGllcyBhdHRyaWJ1dGVzIGZyb20gdGhlIG9yaWdpbmFsIGA8dGVtcGxhdGU+YCB0byBhIG5ld2x5IGNyZWF0ZWRcbiAgICogYDxkb20taWY+YCBvciBgPGRvbS1yZXBlYXQ+YCwgd2hpY2ggY2FuIHRyaWdnZXIgdGhlIGJ1ZyBtZW50aW9uZWQgYWJvdmUgaWZcbiAgICogYW55IG9mIHRob3NlIGF0dHJpYnV0ZXMgdXNlcyBQb2x5bWVyJ3MgYG9uLWAgc3ludGF4IGZvciBldmVudCBsaXN0ZW5lcnMuXG4gICAqIChOb3RlLCB0aGUgdmFsdWUgb2YgdGhlc2UgYG9uLWAgbGlzdGVuZXJzIGlzIG5vdCBldmFsdWF0ZWQgYXMgc2NyaXB0OiBpdCBpc1xuICAgKiB0aGUgbmFtZSBvZiBhIG1lbWJlciBmdW5jdGlvbiBvZiBhIGNvbXBvbmVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgZXZlbnRcbiAgICogbGlzdGVuZXIuKVxuICAgKlxuICAgKiBAdHlwZSB7IVRydXN0ZWRUeXBlUG9saWN5fHVuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN0IHBvbHltZXJUZW1wbGF0ZUV2ZW50QXR0cmlidXRlUG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcyAmJlxuICAgICAgd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koXG4gICAgICAgICAgJ3BvbHltZXItdGVtcGxhdGUtZXZlbnQtYXR0cmlidXRlLXBvbGljeScsIHtcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdDogeCA9PiB4LFxuICAgICAgICAgIH0pO1xuXG4gIHJldHVybiAoZGVzdCwgc3JjLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzcmMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgaWYgKHBvbHltZXJUZW1wbGF0ZUV2ZW50QXR0cmlidXRlUG9saWN5ICYmIG5hbWUuc3RhcnRzV2l0aCgnb24tJykpIHtcbiAgICAgIGRlc3Quc2V0QXR0cmlidXRlKFxuICAgICAgICAgIG5hbWUsIHBvbHltZXJUZW1wbGF0ZUV2ZW50QXR0cmlidXRlUG9saWN5LmNyZWF0ZVNjcmlwdCh2YWx1ZSwgbmFtZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlc3Quc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKSB7XG4gIGxldCBpcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpO1xuICBpZiAoaXMgJiYgdGVtcGxhdGVFeHRlbnNpb25zW2lzXSkge1xuICAgIGxldCB0ID0gbm9kZTtcbiAgICB0LnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICBub2RlID0gdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXMpO1xuICAgIHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgdCk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0KTtcbiAgICB3aGlsZSh0LmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7bmFtZX0gPSB0LmF0dHJpYnV0ZXNbMF07XG4gICAgICBjb3B5QXR0cmlidXRlV2l0aFRlbXBsYXRlRXZlbnRQb2xpY3kobm9kZSwgdCwgbmFtZSk7XG4gICAgICB0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8pIHtcbiAgLy8gcmVjdXJzaXZlbHkgYXNjZW5kIHRyZWUgdW50aWwgd2UgaGl0IHJvb3RcbiAgbGV0IHBhcmVudCA9IG5vZGVJbmZvLnBhcmVudEluZm8gJiYgZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mby5wYXJlbnRJbmZvKTtcbiAgLy8gdW53aW5kIHRoZSBzdGFjaywgcmV0dXJuaW5nIHRoZSBpbmRleGVkIG5vZGUgYXQgZWFjaCBsZXZlbFxuICBpZiAocGFyZW50KSB7XG4gICAgLy8gbm90ZTogbWFyZ2luYWxseSBmYXN0ZXIgdGhhbiBpbmRleGluZyB2aWEgY2hpbGROb2Rlc1xuICAgIC8vIChodHRwOi8vanNwZXJmLmNvbS9jaGlsZG5vZGVzLWxvb2t1cClcbiAgICBmb3IgKGxldCBuPXBhcmVudC5maXJzdENoaWxkLCBpPTA7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG5vZGVJbmZvLnBhcmVudEluZGV4ID09PSBpKyspIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByb290O1xuICB9XG59XG5cbi8vIGNvbnN0cnVjdCBgJGAgbWFwIChmcm9tIGlkIGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlJZFRvTWFwKGluc3QsIG1hcCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmlkKSB7XG4gICAgbWFwW25vZGVJbmZvLmlkXSA9IG5vZGU7XG4gIH1cbn1cblxuLy8gaW5zdGFsbCBldmVudCBsaXN0ZW5lcnMgKGZyb20gZXZlbnQgYW5ub3RhdGlvbnMpXG5mdW5jdGlvbiBhcHBseUV2ZW50TGlzdGVuZXIoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmV2ZW50cyAmJiBub2RlSW5mby5ldmVudHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaj0wLCBlJD1ub2RlSW5mby5ldmVudHMsIGU7IChqPGUkLmxlbmd0aCkgJiYgKGU9ZSRbal0pOyBqKyspIHtcbiAgICAgIGluc3QuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZS5uYW1lLCBlLnZhbHVlLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcHVzaCBjb25maWd1cmF0aW9uIHJlZmVyZW5jZXMgYXQgY29uZmlndXJlIHRpbWVcbmZ1bmN0aW9uIGFwcGx5VGVtcGxhdGVJbmZvKGluc3QsIG5vZGUsIG5vZGVJbmZvLCBwYXJlbnRUZW1wbGF0ZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLnRlbXBsYXRlSW5mbykge1xuICAgIC8vIEdpdmUgdGhlIG5vZGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyB0ZW1wbGF0ZUluZm8gYW5kIHNldCBpdHMgcGFyZW50XG4gICAgbm9kZS5fdGVtcGxhdGVJbmZvID0gbm9kZUluZm8udGVtcGxhdGVJbmZvO1xuICAgIG5vZGUuX3BhcmVudFRlbXBsYXRlSW5mbyA9IHBhcmVudFRlbXBsYXRlSW5mbztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAvLyB0byBmaW5kIG1ldGhvZHMuIEN1cnJlbnRseSB1c2VkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgY29udGV4dCA9IGNvbnRleHQuX21ldGhvZEhvc3QgfHwgY29udGV4dDtcbiAgbGV0IGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNvbnRleHRbbWV0aG9kTmFtZV0pIHtcbiAgICAgIGNvbnRleHRbbWV0aG9kTmFtZV0oZSwgZS5kZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2xpc3RlbmVyIG1ldGhvZCBgJyArIG1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhbmRsZXI7XG59XG5cbi8qKlxuICogRWxlbWVudCBtaXhpbiB0aGF0IHByb3ZpZGVzIGJhc2ljIHRlbXBsYXRlIHBhcnNpbmcgYW5kIHN0YW1waW5nLCBpbmNsdWRpbmdcbiAqIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUtcmVsYXRlZCBmZWF0dXJlcyBmb3Igc3RhbXBlZCB0ZW1wbGF0ZXM6XG4gKlxuICogLSBEZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgKGBvbi1ldmVudG5hbWU9XCJsaXN0ZW5lclwiYClcbiAqIC0gTWFwIG9mIG5vZGUgaWQncyB0byBzdGFtcGVkIG5vZGUgaW5zdGFuY2VzIChgdGhpcy4kLmlkYClcbiAqIC0gTmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQgY2FjaGluZy9yZW1vdmFsIGFuZCByZS1pbnN0YWxsYXRpb24gKHBlcmZvcm1hbmNlXG4gKiAgIG9wdGltaXphdGlvbilcbiAqXG4gKiBAbWl4aW5GdW5jdGlvblxuICogQHBvbHltZXJcbiAqIEBzdW1tYXJ5IEVsZW1lbnQgY2xhc3MgbWl4aW4gdGhhdCBwcm92aWRlcyBiYXNpYyB0ZW1wbGF0ZSBwYXJzaW5nIGFuZCBzdGFtcGluZ1xuICovXG5leHBvcnQgY29uc3QgVGVtcGxhdGVTdGFtcCA9IGRlZHVwaW5nTWl4aW4oXG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpUKX0gc3VwZXJDbGFzcyBDbGFzcyB0byBhcHBseSBtaXhpbiB0by5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VCl9IHN1cGVyQ2xhc3Mgd2l0aCBtaXhpbiBhcHBsaWVkLlxuICAgICAqL1xuICAgIChzdXBlckNsYXNzKSA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAqL1xuICBjbGFzcyBUZW1wbGF0ZVN0YW1wIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAvKipcbiAgICAgKiBTY2FucyBhIHRlbXBsYXRlIHRvIHByb2R1Y2UgdGVtcGxhdGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBUZW1wbGF0ZS1zcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIHRoZSBvYmplY3QgcmV0dXJuZWQsIGFuZCBub2RlLVxuICAgICAqIHNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gb2JqZWN0cyBpbiBpdHMgZmxhdHRlbmVkIGBub2RlSW5mb0xpc3RgXG4gICAgICogYXJyYXkuICBPbmx5IG5vZGVzIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IHdlcmUgcGFyc2VkIGFzIG5vZGVzIG9mXG4gICAgICogaW50ZXJlc3QgY29udGFpbiBhbiBvYmplY3QgaW4gYG5vZGVJbmZvTGlzdGAuICBFYWNoIGBub2RlSW5mb2Agb2JqZWN0XG4gICAgICogY29udGFpbnMgYW4gYGluZGV4YCAoYGNoaWxkTm9kZXNgIGluZGV4IGluIHBhcmVudCkgYW5kIG9wdGlvbmFsbHlcbiAgICAgKiBgcGFyZW50YCwgd2hpY2ggcG9pbnRzIHRvIG5vZGUgaW5mbyBvZiBpdHMgcGFyZW50IChpbmNsdWRpbmcgaXRzIGluZGV4KS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZCBoYXMgdGhlIGZvbGxvd2luZ1xuICAgICAqIHN0cnVjdHVyZSAobWFueSBmaWVsZHMgb3B0aW9uYWwpOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgLy8gRmxhdHRlbmVkIGxpc3Qgb2Ygbm9kZSBtZXRhZGF0YSAoZm9yIG5vZGVzIHRoYXQgZ2VuZXJhdGVkIG1ldGFkYXRhKVxuICAgICAqICAgICBub2RlSW5mb0xpc3Q6IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICAvLyBgaWRgIGF0dHJpYnV0ZSBmb3IgYW55IG5vZGVzIHdpdGggaWQncyBmb3IgZ2VuZXJhdGluZyBgJGAgbWFwXG4gICAgICogICAgICAgICBpZDoge3N0cmluZ30sXG4gICAgICogICAgICAgICAvLyBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIG1ldGFkYXRhXG4gICAgICogICAgICAgICBldmVudHM6IFtcbiAgICAgKiAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgIG5hbWU6IHtzdHJpbmd9LCAgIC8vIGV2ZW50IG5hbWVcbiAgICAgKiAgICAgICAgICAgICB2YWx1ZToge3N0cmluZ30sICAvLyBoYW5kbGVyIG1ldGhvZCBuYW1lXG4gICAgICogICAgICAgICAgIH0sIC4uLlxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIC8vIE5vdGVzIHdoZW4gdGhlIHRlbXBsYXRlIGNvbnRhaW5lZCBhIGA8c2xvdD5gIGZvciBzaGFkeSBET01cbiAgICAgKiAgICAgICAgIC8vIG9wdGltaXphdGlvbiBwdXJwb3Nlc1xuICAgICAqICAgICAgICAgaGFzSW5zZXJ0aW9uUG9pbnQ6IHtib29sZWFufSxcbiAgICAgKiAgICAgICAgIC8vIEZvciBuZXN0ZWQgYDx0ZW1wbGF0ZT5gYCBub2RlcywgbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICB0ZW1wbGF0ZUluZm86IHtvYmplY3R9LCAvLyBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIC8vIE1ldGFkYXRhIHRvIGFsbG93IGVmZmljaWVudCByZXRyaWV2YWwgb2YgaW5zdGFuY2VkIG5vZGVcbiAgICAgKiAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRhZGF0YVxuICAgICAqICAgICAgICAgcGFyZW50SW5mbzoge251bWJlcn0sICAgLy8gcmVmZXJlbmNlIHRvIHBhcmVudCBub2RlSW5mbz5cbiAgICAgKiAgICAgICAgIHBhcmVudEluZGV4OiB7bnVtYmVyfSwgIC8vIGluZGV4IGluIHBhcmVudCdzIGBjaGlsZE5vZGVzYCBjb2xsZWN0aW9uXG4gICAgICogICAgICAgICBpbmZvSW5kZXg6IHtudW1iZXJ9LCAgICAvLyBpbmRleCBvZiB0aGlzIGBub2RlSW5mb2AgaW4gYHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3RgXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAgLy8gV2hlbiB0cnVlLCB0aGUgdGVtcGxhdGUgaGFkIHRoZSBgc3RyaXAtd2hpdGVzcGFjZWAgYXR0cmlidXRlXG4gICAgICogICAgIC8vIG9yIHdhcyBuZXN0ZWQgaW4gYSB0ZW1wbGF0ZSB3aXRoIHRoYXQgc2V0dGluZ1xuICAgICAqICAgICBzdHJpcFdoaXRlc3BhY2U6IHtib29sZWFufSxcbiAgICAgKiAgICAgLy8gRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGlzIG1vdmVkIGludG9cbiAgICAgKiAgICAgLy8gYSBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgaGVyZTsgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gdG9cbiAgICAgKiAgICAgLy8gYXZvaWQgdGhlIGNvc3Qgb2YgbmVzdGVkIHRlbXBsYXRlIGNsb25pbmdcbiAgICAgKiAgICAgY29udGVudDoge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICogICB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBraWNrcyBvZmYgYSByZWN1cnNpdmUgdHJlZXdhbGsgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgIF9wYXJzZVRlbXBsYXRlIDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgICBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlICA8LS0tLS0tLS0tLS0tfC0tK1xuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUgLS0rICB8XG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzIC0tLS0tLS0tLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzXG4gICAgICogICAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG1ldGFkYXRhIGFib3V0IHRlbXBsYXRlc1xuICAgICAqIHRvIGVpdGhlciBgdGVtcGxhdGVJbmZvYCBvciBgbm9kZUluZm9gLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSBiZSBkZXN0cnVjdGl2ZSB0byB0aGUgdGVtcGxhdGUsIGluIHRoYXRcbiAgICAgKiBlLmcuIGV2ZW50IGFubm90YXRpb25zIG1heSBiZSByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIHRoZVxuICAgICAqIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mbz19IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZyb20gdGhlIG91dGVyXG4gICAgICogICB0ZW1wbGF0ZSwgZm9yIHBhcnNpbmcgbmVzdGVkIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFBhcnNlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBvdXRlclRlbXBsYXRlSW5mbykge1xuICAgICAgLy8gc2luY2UgYSB0ZW1wbGF0ZSBtYXkgYmUgcmUtdXNlZCwgbWVtby1pemUgbWV0YWRhdGFcbiAgICAgIGlmICghdGVtcGxhdGUuX3RlbXBsYXRlSW5mbykge1xuICAgICAgICAvLyBUT0RPKHJpY3RpYyk6IGZpeCB0eXBpbmdcbiAgICAgICAgbGV0IC8qKiA/ICovIHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlLl90ZW1wbGF0ZUluZm8gPSB7fTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdCA9IFtdO1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubmVzdGVkVGVtcGxhdGUgPSBCb29sZWFuKG91dGVyVGVtcGxhdGVJbmZvKTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSA9XG4gICAgICAgICAgKG91dGVyVGVtcGxhdGVJbmZvICYmIG91dGVyVGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSkgfHxcbiAgICAgICAgICAodGVtcGxhdGUuaGFzQXR0cmlidXRlICYmIHRlbXBsYXRlLmhhc0F0dHJpYnV0ZSgnc3RyaXAtd2hpdGVzcGFjZScpKTtcbiAgICAgICAgIC8vIFRPRE8ocmljdGljKTogZml4IHR5cGluZ1xuICAgICAgICAgdGhpcy5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQoXG4gICAgICAgICAgICAgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgLyoqIEB0eXBlIHs/fSAqLyAoe3BhcmVudDogbnVsbH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBkb2NzIGZvciBfcGFyc2VUZW1wbGF0ZU5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSAuXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gLlxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyAuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGFuZCBhZGRzIHRlbXBsYXRlIGFuZCBub2RlIG1ldGFkYXRhIGJhc2VkIG9uXG4gICAgICogdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGl0cyBgY2hpbGROb2Rlc2AgYW5kIGBhdHRyaWJ1dGVzYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbm9kZSBvciB0ZW1wbGF0ZSBzcGVjaWZpY1xuICAgICAqIG1ldGFkYXRhIGJhc2VkIG9uIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCBub3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAobm9kZSk7XG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ByZXNlcnZlLWNvbnRlbnQnKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICAvLyBGb3IgU2hhZHlEb20gb3B0aW1pemF0aW9uLCBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgICB0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZml4UGxhY2Vob2xkZXIoZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlcyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNraW5nIGBub2RlSW5mby5ub3RlZGAgYWxsb3dzIGEgY2hpbGQgbm9kZSBvZiB0aGlzIG5vZGUgKHdobyBnZXRzXG4gICAgICAvLyBhY2Nlc3MgdG8gYHBhcmVudEluZm9gKSB0byBjYXVzZSB0aGUgcGFyZW50IHRvIGJlIG5vdGVkLCB3aGljaFxuICAgICAgLy8gb3RoZXJ3aXNlIGhhcyBubyByZXR1cm4gcGF0aCB2aWEgYF9wYXJzZVRlbXBsYXRlQ2hpbGROb2Rlc2AgKHVzZWQgYnlcbiAgICAgIC8vIHNvbWUgb3B0aW1pemF0aW9ucylcbiAgICAgIHJldHVybiBub3RlZCB8fCBub2RlSW5mby5ub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY2hpbGQgbm9kZXMgZm9yIHRoZSBnaXZlbiByb290IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIHdyYXBzIHdoaXRlbGlzdGVkIGxlZ2FjeSB0ZW1wbGF0ZSBleHRlbnNpb25zXG4gICAgICogKGBpcz1cImRvbS1pZlwiYCBhbmQgYGlzPVwiZG9tLXJlcGVhdFwiYCkgd2l0aCB0aGVpciBlcXVpdmFsZW50IGVsZW1lbnRcbiAgICAgKiB3cmFwcGVycywgY29sbGFwc2VzIHRleHQgbm9kZXMsIGFuZCBzdHJpcHMgd2hpdGVzcGFjZSBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAqIGlmIHRoZSBgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVzcGFjZWAgc2V0dGluZyB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgUm9vdCBub2RlIHdob3NlIGBjaGlsZE5vZGVzYCB3aWxsIGJlIHBhcnNlZFxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKHJvb3QsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGlmIChyb290LmxvY2FsTmFtZSA9PT0gJ3NjcmlwdCcgfHwgcm9vdC5sb2NhbE5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgbm9kZT1yb290LmZpcnN0Q2hpbGQsIHBhcmVudEluZGV4PTAsIG5leHQ7IG5vZGU7IG5vZGU9bmV4dCkge1xuICAgICAgICAvLyBXcmFwIHRlbXBsYXRlc1xuICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIG5vZGUgPSB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29sbGFwc2UgYWRqYWNlbnQgdGV4dE5vZGVzOiBmaXhlcyBhbiBJRSBpc3N1ZSB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAvLyB0ZXh0IG5vZGVzIHRvIGJlIGluZXhwbGljYWJseSBzcGxpdCA9KFxuICAgICAgICAvLyBub3RlIHRoYXQgcm9vdC5ub3JtYWxpemUoKSBzaG91bGQgd29yayBidXQgZG9lcyBub3Qgc28gd2UgZG8gdGhpc1xuICAgICAgICAvLyBtYW51YWxseS5cbiAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGxldCAvKiogTm9kZSAqLyBuID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAobiAmJiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpKSB7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ICs9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBuZXh0ID0gbi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgICBuID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3B0aW9uYWxseSBzdHJpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgJiYgIW5vZGUudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZEluZm8gPVxuICAgICAgICAgICAgLyoqIEB0eXBlIHshTm9kZUluZm99ICovICh7cGFyZW50SW5kZXgsIHBhcmVudEluZm86IG5vZGVJbmZvfSk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIGNoaWxkSW5mbykpIHtcbiAgICAgICAgICBjaGlsZEluZm8uaW5mb0luZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5wdXNoKGNoaWxkSW5mbykgLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluY3JlbWVudCBpZiBub3QgcmVtb3ZlZFxuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcGFyZW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjb250ZW50IGZvciB0aGUgZ2l2ZW4gbmVzdGVkIGA8dGVtcGxhdGU+YC5cbiAgICAgKlxuICAgICAqIE5lc3RlZCB0ZW1wbGF0ZSBpbmZvIGlzIHN0b3JlZCBhcyBgdGVtcGxhdGVJbmZvYCBpbiB0aGUgY3VycmVudCBub2RlJ3NcbiAgICAgKiBgbm9kZUluZm9gLiBgdGVtcGxhdGUuY29udGVudGAgaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIGB0ZW1wbGF0ZUluZm9gLlxuICAgICAqIEl0IHdpbGwgdGhlbiBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGhvc3QgdG8gc2V0IGl0IGJhY2sgdG8gdGhlXG4gICAgICogdGVtcGxhdGUgYW5kIGZvciB1c2VycyBzdGFtcGluZyBuZXN0ZWQgdGVtcGxhdGVzIHRvIHVzZSB0aGVcbiAgICAgKiBgX2NvbnRlbnRGb3JUZW1wbGF0ZWAgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBjb250ZW50IGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICogKGFuIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlIChhIDx0ZW1wbGF0ZT4pXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogICB0aGF0IGluY2x1ZGVzIHRoZSB0ZW1wbGF0ZSBgbm9kZWBcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIC8vIFRPRE8ocmljdGljKTogdGhlIHR5cGUgb2Ygbm9kZSBzaG91bGQgYmUgbm9uLW51bGxcbiAgICAgIGxldCBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKG5vZGUpO1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX3BhcnNlVGVtcGxhdGUoZWxlbWVudCwgb3V0ZXJUZW1wbGF0ZUluZm8pO1xuICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCA9XG4gICAgICAgICAgZWxlbWVudC5jb250ZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbGVtZW50LmNvbnRlbnQpO1xuICAgICAgbm9kZUluZm8udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlcyBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBmb3Igbm9kZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50XG4gICAgICogICAgIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgLy8gTWFrZSBjb3B5IG9mIG9yaWdpbmFsIGF0dHJpYnV0ZSBsaXN0LCBzaW5jZSB0aGUgb3JkZXIgbWF5IGNoYW5nZVxuICAgICAgLy8gYXMgYXR0cmlidXRlcyBhcmUgYWRkZWQgYW5kIHJlbW92ZWRcbiAgICAgIGxldCBub3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGF0dHJzID0gQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpO1xuICAgICAgZm9yIChsZXQgaT1hdHRycy5sZW5ndGgtMSwgYTsgKGE9YXR0cnNbaV0pOyBpLS0pIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBhLm5hbWUsIGEudmFsdWUpIHx8IG5vdGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNpbmdsZSB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZSBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvXG4gICAgICogYG5vZGVJbmZvYCBmb3IgYXR0cmlidXRlcyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gYWRkcyBtZXRhZGF0YSBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICogYW5kIGBpZGAgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAvLyBldmVudHMgKG9uLSopXG4gICAgICBpZiAobmFtZS5zbGljZSgwLCAzKSA9PT0gJ29uLScpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIG5vZGVJbmZvLmV2ZW50cyA9IG5vZGVJbmZvLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgbm9kZUluZm8uZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUuc2xpY2UoMyksXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIGlkXG4gICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgIG5vZGVJbmZvLmlkID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBjb250ZW50YCBkb2N1bWVudCBmcmFnbWVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBQb2x5bWVyIHBlcmZvcm1zIGFuIG9wdGltaXphdGlvbiB0byBjYWNoZSBuZXN0ZWRcbiAgICAgKiB0ZW1wbGF0ZSBjb250ZW50IHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgZGVlcGx5IG5lc3RlZCB0ZW1wbGF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgcmV0cmlldmVzIHRoZSBjYWNoZWQgY29udGVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcmV0cmlldmUgYGNvbnRlbnRgIGZvclxuICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IENvbnRlbnQgZnJhZ21lbnRcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50V2l0aEluZm99ICovICh0ZW1wbGF0ZSkuX3RlbXBsYXRlSW5mbztcbiAgICAgIHJldHVybiAodGVtcGxhdGVJbmZvICYmIHRlbXBsYXRlSW5mby5jb250ZW50KSB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgY29udGVudCBhbmQgcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogY29udGFpbmluZyB0aGUgY2xvbmVkIGRvbS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWQgKG9uY2UgYW5kIG1lbW9pemVkKSB1c2luZyB0aGlzIGxpYnJhcnknc1xuICAgICAqIHRlbXBsYXRlIHBhcnNpbmcgZmVhdHVyZXMsIGFuZCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHZhbHVlLWFkZGVkXG4gICAgICogZmVhdHVyZXM6XG4gICAgICogKiBBZGRzIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICogKiBHZW5lcmF0ZXMgYW4gXCJpZCBtYXBcIiBmb3IgYWxsIG5vZGVzIHdpdGggaWQncyB1bmRlciBgJGAgb24gcmV0dXJuZWRcbiAgICAgKiAgIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogKiBQYXNzZXMgdGVtcGxhdGUgaW5mbyBpbmNsdWRpbmcgYGNvbnRlbnRgIGJhY2sgdG8gdGVtcGxhdGVzIGFzXG4gICAgICogICBgX3RlbXBsYXRlSW5mb2AgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGRlZXAgdGVtcGxhdGVcbiAgICAgKiAgIGNsb25pbmcpXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIG1lbW9pemVkIHRlbXBsYXRlIHBhcnNpbmcgcHJvY2VzcyBpcyBkZXN0cnVjdGl2ZSB0byB0aGVcbiAgICAgKiB0ZW1wbGF0ZTogYXR0cmlidXRlcyBmb3IgYmluZGluZ3MgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAgICAgKiByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIG5vdGVzLCBhbmQgYW55IG5lc3RlZCBgPHRlbXBsYXRlPi5jb250ZW50YFxuICAgICAqIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBub3RlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mbz19IHRlbXBsYXRlSW5mbyBPcHRpb25hbCB0ZW1wbGF0ZSBpbmZvIGFzc29jaWF0ZWRcbiAgICAgKiAgIHdpdGggdGhlIHRlbXBsYXRlIHRvIGJlIHN0YW1wZWQ7IGlmIG9taXR0ZWQgdGhlIHRlbXBsYXRlIHdpbGwgYmVcbiAgICAgKiAgIGF1dG9tYXRpY2FsbHkgcGFyc2VkLlxuICAgICAqIEByZXR1cm4geyFTdGFtcGVkVGVtcGxhdGV9IENsb25lZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUsIHRlbXBsYXRlSW5mbykge1xuICAgICAgLy8gUG9seWZpbGwgc3VwcG9ydDogYm9vdHN0cmFwIHRoZSB0ZW1wbGF0ZSBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlblxuICAgICAgaWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb250ZW50ICYmXG4gICAgICAgICAgd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSkge1xuICAgICAgICBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFjY2VwdGluZyB0aGUgYHRlbXBsYXRlSW5mb2AgdmlhIGFuIGFyZ3VtZW50IGFsbG93cyBmb3IgY3JlYXRpbmdcbiAgICAgIC8vIGluc3RhbmNlcyBvZiB0aGUgYHRlbXBsYXRlSW5mb2AgYnkgdGhlIGNhbGxlciwgdXNlZnVsIGZvciBhZGRpbmdcbiAgICAgIC8vIGluc3RhbmNlLXRpbWUgaW5mb3JtYXRpb24gdG8gdGhlIHByb3RvdHlwaWNhbCBkYXRhXG4gICAgICB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm8gfHwgdGhpcy5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBsZXQgbm9kZUluZm8gPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0O1xuICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgbGV0IGRvbSA9IC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi8gKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgLy8gTk9URTogU2hhZHlEb20gb3B0aW1pemF0aW9uIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICBkb20uX19ub0luc2VydGlvblBvaW50ID0gIXRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludDtcbiAgICAgIGxldCBub2RlcyA9IGRvbS5ub2RlTGlzdCA9IG5ldyBBcnJheShub2RlSW5mby5sZW5ndGgpO1xuICAgICAgZG9tLiQgPSB7fTtcbiAgICAgIGZvciAobGV0IGk9MCwgbD1ub2RlSW5mby5sZW5ndGgsIGluZm87IChpPGwpICYmIChpbmZvPW5vZGVJbmZvW2ldKTsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV0gPSBmaW5kVGVtcGxhdGVOb2RlKGRvbSwgaW5mbyk7XG4gICAgICAgIGFwcGx5SWRUb01hcCh0aGlzLCBkb20uJCwgbm9kZSwgaW5mbyk7XG4gICAgICAgIGFwcGx5VGVtcGxhdGVJbmZvKHRoaXMsIG5vZGUsIGluZm8sIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgIGFwcGx5RXZlbnRMaXN0ZW5lcih0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgIH1cbiAgICAgIGRvbSA9IC8qKiBAdHlwZSB7IVN0YW1wZWRUZW1wbGF0ZX0gKi8oZG9tKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGJ5IG1ldGhvZCBuYW1lIGZvciB0aGUgZXZlbnQgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgbG9va3MgdXAgdGhlIG1ldGhvZFxuICAgICAqIG5hbWUgYXQgaGFuZGxpbmcgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSBub2RlIE5vZGUgdG8gYWRkIGxpc3RlbmVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2RcbiAgICAgKiBAcGFyYW0geyo9fSBjb250ZXh0IENvbnRleHQgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiAoZGVmYXVsdHNcbiAgICAgKiAgIHRvIGBub2RlYClcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gR2VuZXJhdGVkIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG5vZGU7XG4gICAgICBsZXQgaGFuZGxlciA9IGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSBub2RlIE5vZGUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOnZvaWR9IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gYWRkXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSBub2RlIE5vZGUgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6dm9pZH0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBUZW1wbGF0ZVN0YW1wO1xuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/template-stamp.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/array-splice.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/array-splice.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateSplices\": () => (/* binding */ calculateSplices)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3;\n\n// Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  let rowCount = oldEnd - oldStart + 1;\n  let columnCount = currentEnd - currentStart + 1;\n  let distances = new Array(rowCount);\n\n  // \"Addition\" rows. Initialize null column.\n  for (let i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  }\n\n  // Initialize null row\n  for (let j = 0; j < columnCount; j++) distances[0][j] = j;\n  for (let i = 1; i < rowCount; i++) {\n    for (let j = 1; j < columnCount; j++) {\n      if (equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1];else {\n        let north = distances[i - 1][j] + 1;\n        let west = distances[i][j - 1] + 1;\n        distances[i][j] = north < west ? north : west;\n      }\n    }\n  }\n  return distances;\n}\n\n// This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\nfunction spliceOperationsFromEditDistances(distances) {\n  let i = distances.length - 1;\n  let j = distances[0].length - 1;\n  let current = distances[i][j];\n  let edits = [];\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n    let northWest = distances[i - 1][j - 1];\n    let west = distances[i - 1][j];\n    let north = distances[i][j - 1];\n    let min;\n    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n  edits.reverse();\n  return edits;\n}\n\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n *\n * @param {!Array} current The current \"changed\" array for which to\n * calculate splices.\n * @param {number} currentStart Starting index in the `current` array for\n * which splices are calculated.\n * @param {number} currentEnd Ending index in the `current` array for\n * which splices are calculated.\n * @param {!Array} old The original \"unchanged\" array to compare `current`\n * against to determine splices.\n * @param {number} oldStart Starting index in the `old` array for\n * which splices are calculated.\n * @param {number} oldEnd Ending index in the `old` array for\n * which splices are calculated.\n * @return {!Array} Returns an array of splice record objects. Each of these\n * contains: `index` the location where the splice occurred; `removed`\n * the array of removed items from this location; `addedCount` the number\n * of items added at this location.\n */\nfunction calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  let prefixCount = 0;\n  let suffixCount = 0;\n  let splice;\n  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);\n  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n    while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);\n    return [splice];\n  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];\n  let ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  splice = undefined;\n  let splices = [];\n  let index = currentStart;\n  let oldIndex = oldStart;\n  for (let i = 0; i < ops.length; i++) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n        index++;\n        oldIndex++;\n        break;\n      case EDIT_UPDATE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n      case EDIT_ADD:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        break;\n      case EDIT_DELETE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n  if (splice) {\n    splices.push(splice);\n  }\n  return splices;\n}\nfunction sharedPrefix(current, old, searchLength) {\n  for (let i = 0; i < searchLength; i++) if (!equals(current[i], old[i])) return i;\n  return searchLength;\n}\nfunction sharedSuffix(current, old, searchLength) {\n  let index1 = current.length;\n  let index2 = old.length;\n  let count = 0;\n  while (count < searchLength && equals(current[--index1], old[--index2])) count++;\n  return count;\n}\n\n/**\n * Returns an array of splice records indicating the minimum edits required\n * to transform the `previous` array into the `current` array.\n *\n * Splice records are ordered by index and contain the following fields:\n * - `index`: index where edit started\n * - `removed`: array of removed items from this index\n * - `addedCount`: number of items added at this index\n *\n * This function is based on the Levenshtein \"minimum edit distance\"\n * algorithm. Note that updates are treated as removal followed by addition.\n *\n * The worst-case time complexity of this algorithm is `O(l * p)`\n *   l: The length of the current array\n *   p: The length of the previous array\n *\n * However, the worst-case complexity is reduced by an `O(n)` optimization\n * to detect any shared prefix & suffix between the two arrays and only\n * perform the more expensive minimum edit distance calculation over the\n * non-shared portions of the arrays.\n *\n * @function\n * @param {!Array} current The \"changed\" array for which splices will be\n * calculated.\n * @param {!Array} previous The \"unchanged\" original array to compare\n * `current` against to determine the splices.\n * @return {!Array} Returns an array of splice record objects. Each of these\n * contains: `index` the location where the splice occurred; `removed`\n * the array of removed items from this location; `addedCount` the number\n * of items added at this location.\n */\nfunction calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0, previous.length);\n}\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuanM/NzcwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5mdW5jdGlvbiBuZXdTcGxpY2UoaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleDogaW5kZXgsXG4gICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICBhZGRlZENvdW50OiBhZGRlZENvdW50XG4gIH07XG59XG5cbmNvbnN0IEVESVRfTEVBVkUgPSAwO1xuY29uc3QgRURJVF9VUERBVEUgPSAxO1xuY29uc3QgRURJVF9BREQgPSAyO1xuY29uc3QgRURJVF9ERUxFVEUgPSAzO1xuXG4vLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzICpiYXNlZCogb24gdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBMZXZlbnNodGVpblxuLy8gXCJlZGl0XCIgZGlzdGFuY2UuIFRoZSBvbmUgY2hhbmdlIGlzIHRoYXQgXCJ1cGRhdGVzXCIgYXJlIHRyZWF0ZWQgYXMgdHdvXG4vLyBlZGl0cyAtIG5vdCBvbmUuIFdpdGggQXJyYXkgc3BsaWNlcywgYW4gdXBkYXRlIGlzIHJlYWxseSBhIGRlbGV0ZVxuLy8gZm9sbG93ZWQgYnkgYW4gYWRkLiBCeSByZXRhaW5pbmcgdGhpcywgd2Ugb3B0aW1pemUgZm9yIFwia2VlcGluZ1wiIHRoZVxuLy8gbWF4aW11bSBhcnJheSBpdGVtcyBpbiB0aGUgb3JpZ2luYWwgYXJyYXkuIEZvciBleGFtcGxlOlxuLy9cbi8vICAgJ3h4eHgxMjMnIC0+ICcxMjN5eXl5J1xuLy9cbi8vIFdpdGggMS1lZGl0IHVwZGF0ZXMsIHRoZSBzaG9ydGVzdCBwYXRoIHdvdWxkIGJlIGp1c3QgdG8gdXBkYXRlIGFsbCBzZXZlblxuLy8gY2hhcmFjdGVycy4gV2l0aCAyLWVkaXQgdXBkYXRlcywgd2UgZGVsZXRlIDQsIGxlYXZlIDMsIGFuZCBhZGQgNC4gVGhpc1xuLy8gbGVhdmVzIHRoZSBzdWJzdHJpbmcgJzEyMycgaW50YWN0LlxuZnVuY3Rpb24gY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICAvLyBcIkRlbGV0aW9uXCIgY29sdW1uc1xuICBsZXQgcm93Q291bnQgPSBvbGRFbmQgLSBvbGRTdGFydCArIDE7XG4gIGxldCBjb2x1bW5Db3VudCA9IGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgKyAxO1xuICBsZXQgZGlzdGFuY2VzID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAvLyBcIkFkZGl0aW9uXCIgcm93cy4gSW5pdGlhbGl6ZSBudWxsIGNvbHVtbi5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgZGlzdGFuY2VzW2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgICBkaXN0YW5jZXNbaV1bMF0gPSBpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBudWxsIHJvd1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbkNvdW50OyBqKyspXG4gICAgZGlzdGFuY2VzWzBdW2pdID0gajtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGNvbHVtbkNvdW50OyBqKyspIHtcbiAgICAgIGlmIChlcXVhbHMoY3VycmVudFtjdXJyZW50U3RhcnQgKyBqIC0gMV0sIG9sZFtvbGRTdGFydCArIGkgLSAxXSkpXG4gICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpIC0gMV1bal0gKyAxO1xuICAgICAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpXVtqIC0gMV0gKyAxO1xuICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBub3J0aCA8IHdlc3QgPyBub3J0aCA6IHdlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlcztcbn1cblxuLy8gVGhpcyBzdGFydHMgYXQgdGhlIGZpbmFsIHdlaWdodCwgYW5kIHdhbGtzIFwiYmFja3dhcmRcIiBieSBmaW5kaW5nXG4vLyB0aGUgbWluaW11bSBwcmV2aW91cyB3ZWlnaHQgcmVjdXJzaXZlbHkgdW50aWwgdGhlIG9yaWdpbiBvZiB0aGUgd2VpZ2h0XG4vLyBtYXRyaXguXG5mdW5jdGlvbiBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoZGlzdGFuY2VzKSB7XG4gIGxldCBpID0gZGlzdGFuY2VzLmxlbmd0aCAtIDE7XG4gIGxldCBqID0gZGlzdGFuY2VzWzBdLmxlbmd0aCAtIDE7XG4gIGxldCBjdXJyZW50ID0gZGlzdGFuY2VzW2ldW2pdO1xuICBsZXQgZWRpdHMgPSBbXTtcbiAgd2hpbGUgKGkgPiAwIHx8IGogPiAwKSB7XG4gICAgaWYgKGkgPT0gMCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICBqLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICBpLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IG5vcnRoV2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqXTtcbiAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaV1baiAtIDFdO1xuXG4gICAgbGV0IG1pbjtcbiAgICBpZiAod2VzdCA8IG5vcnRoKVxuICAgICAgbWluID0gd2VzdCA8IG5vcnRoV2VzdCA/IHdlc3QgOiBub3J0aFdlc3Q7XG4gICAgZWxzZVxuICAgICAgbWluID0gbm9ydGggPCBub3J0aFdlc3QgPyBub3J0aCA6IG5vcnRoV2VzdDtcblxuICAgIGlmIChtaW4gPT0gbm9ydGhXZXN0KSB7XG4gICAgICBpZiAobm9ydGhXZXN0ID09IGN1cnJlbnQpIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0xFQVZFKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9VUERBVEUpO1xuICAgICAgICBjdXJyZW50ID0gbm9ydGhXZXN0O1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgai0tO1xuICAgIH0gZWxzZSBpZiAobWluID09IHdlc3QpIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgaS0tO1xuICAgICAgY3VycmVudCA9IHdlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgai0tO1xuICAgICAgY3VycmVudCA9IG5vcnRoO1xuICAgIH1cbiAgfVxuXG4gIGVkaXRzLnJldmVyc2UoKTtcbiAgcmV0dXJuIGVkaXRzO1xufVxuXG4vKipcbiAqIFNwbGljZSBQcm9qZWN0aW9uIGZ1bmN0aW9uczpcbiAqXG4gKiBBIHNwbGljZSBtYXAgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBob3cgYSBwcmV2aW91cyBhcnJheSBvZiBpdGVtc1xuICogd2FzIHRyYW5zZm9ybWVkIGludG8gYSBuZXcgYXJyYXkgb2YgaXRlbXMuIENvbmNlcHR1YWxseSBpdCBpcyBhIGxpc3Qgb2ZcbiAqIHR1cGxlcyBvZlxuICpcbiAqICAgPGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50PlxuICpcbiAqIHdoaWNoIGFyZSBrZXB0IGluIGFzY2VuZGluZyBpbmRleCBvcmRlciBvZi4gVGhlIHR1cGxlIHJlcHJlc2VudHMgdGhhdCBhdFxuICogdGhlIHxpbmRleHwsIHxyZW1vdmVkfCBzZXF1ZW5jZSBvZiBpdGVtcyB3ZXJlIHJlbW92ZWQsIGFuZCBjb3VudGluZyBmb3J3YXJkXG4gKiBmcm9tIHxpbmRleHwsIHxhZGRlZENvdW50fCBpdGVtcyB3ZXJlIGFkZGVkLlxuICovXG5cbi8qKlxuICogTGFja2luZyBpbmRpdmlkdWFsIHNwbGljZSBtdXRhdGlvbiBpbmZvcm1hdGlvbiwgdGhlIG1pbmltYWwgc2V0IG9mXG4gKiBzcGxpY2VzIGNhbiBiZSBzeW50aGVzaXplZCBnaXZlbiB0aGUgcHJldmlvdXMgc3RhdGUgYW5kIGZpbmFsIHN0YXRlIG9mIGFuXG4gKiBhcnJheS4gVGhlIGJhc2ljIGFwcHJvYWNoIGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWRpdCBkaXN0YW5jZSBtYXRyaXggYW5kXG4gKiBjaG9vc2UgdGhlIHNob3J0ZXN0IHBhdGggdGhyb3VnaCBpdC5cbiAqXG4gKiBDb21wbGV4aXR5OiBPKGwgKiBwKVxuICogICBsOiBUaGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGFycmF5XG4gKiAgIHA6IFRoZSBsZW5ndGggb2YgdGhlIG9sZCBhcnJheVxuICpcbiAqIEBwYXJhbSB7IUFycmF5fSBjdXJyZW50IFRoZSBjdXJyZW50IFwiY2hhbmdlZFwiIGFycmF5IGZvciB3aGljaCB0b1xuICogY2FsY3VsYXRlIHNwbGljZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRFbmQgRW5kaW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHshQXJyYXl9IG9sZCBUaGUgb3JpZ2luYWwgXCJ1bmNoYW5nZWRcIiBhcnJheSB0byBjb21wYXJlIGBjdXJyZW50YFxuICogYWdhaW5zdCB0byBkZXRlcm1pbmUgc3BsaWNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvbGRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG9sZEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEByZXR1cm4geyFBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkIG9iamVjdHMuIEVhY2ggb2YgdGhlc2VcbiAqIGNvbnRhaW5zOiBgaW5kZXhgIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgc3BsaWNlIG9jY3VycmVkOyBgcmVtb3ZlZGBcbiAqIHRoZSBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBsb2NhdGlvbjsgYGFkZGVkQ291bnRgIHRoZSBudW1iZXJcbiAqIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgbG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNhbGNTcGxpY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgbGV0IHByZWZpeENvdW50ID0gMDtcbiAgbGV0IHN1ZmZpeENvdW50ID0gMDtcbiAgbGV0IHNwbGljZTtcblxuICBsZXQgbWluTGVuZ3RoID0gTWF0aC5taW4oY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCwgb2xkRW5kIC0gb2xkU3RhcnQpO1xuICBpZiAoY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkU3RhcnQgPT0gMClcbiAgICBwcmVmaXhDb3VudCA9IHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCk7XG5cbiAgaWYgKGN1cnJlbnRFbmQgPT0gY3VycmVudC5sZW5ndGggJiYgb2xkRW5kID09IG9sZC5sZW5ndGgpXG4gICAgc3VmZml4Q291bnQgPSBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGggLSBwcmVmaXhDb3VudCk7XG5cbiAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICBvbGRTdGFydCArPSBwcmVmaXhDb3VudDtcbiAgY3VycmVudEVuZCAtPSBzdWZmaXhDb3VudDtcbiAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuXG4gIGlmIChjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkRW5kIC0gb2xkU3RhcnQgPT0gMClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKGN1cnJlbnRTdGFydCA9PSBjdXJyZW50RW5kKSB7XG4gICAgc3BsaWNlID0gbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIDApO1xuICAgIHdoaWxlIChvbGRTdGFydCA8IG9sZEVuZClcbiAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZFN0YXJ0KytdKTtcblxuICAgIHJldHVybiBbIHNwbGljZSBdO1xuICB9IGVsc2UgaWYgKG9sZFN0YXJ0ID09IG9sZEVuZClcbiAgICByZXR1cm4gWyBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCkgXTtcblxuICBsZXQgb3BzID0gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKFxuICAgICAgY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpKTtcblxuICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gIGxldCBzcGxpY2VzID0gW107XG4gIGxldCBpbmRleCA9IGN1cnJlbnRTdGFydDtcbiAgbGV0IG9sZEluZGV4ID0gb2xkU3RhcnQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoKG9wc1tpXSkge1xuICAgICAgY2FzZSBFRElUX0xFQVZFOlxuICAgICAgICBpZiAoc3BsaWNlKSB7XG4gICAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgICAgICAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfVVBEQVRFOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFRElUX0FERDpcbiAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfREVMRVRFOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3BsaWNlKSB7XG4gICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gIH1cbiAgcmV0dXJuIHNwbGljZXM7XG59XG5cbmZ1bmN0aW9uIHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaExlbmd0aDsgaSsrKVxuICAgIGlmICghZXF1YWxzKGN1cnJlbnRbaV0sIG9sZFtpXSkpXG4gICAgICByZXR1cm4gaTtcbiAgcmV0dXJuIHNlYXJjaExlbmd0aDtcbn1cblxuZnVuY3Rpb24gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gIGxldCBpbmRleDEgPSBjdXJyZW50Lmxlbmd0aDtcbiAgbGV0IGluZGV4MiA9IG9sZC5sZW5ndGg7XG4gIGxldCBjb3VudCA9IDA7XG4gIHdoaWxlIChjb3VudCA8IHNlYXJjaExlbmd0aCAmJiBlcXVhbHMoY3VycmVudFstLWluZGV4MV0sIG9sZFstLWluZGV4Ml0pKVxuICAgIGNvdW50Kys7XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3BsaWNlIHJlY29yZHMgaW5kaWNhdGluZyB0aGUgbWluaW11bSBlZGl0cyByZXF1aXJlZFxuICogdG8gdHJhbnNmb3JtIHRoZSBgcHJldmlvdXNgIGFycmF5IGludG8gdGhlIGBjdXJyZW50YCBhcnJheS5cbiAqXG4gKiBTcGxpY2UgcmVjb3JkcyBhcmUgb3JkZXJlZCBieSBpbmRleCBhbmQgY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqIC0gYGluZGV4YDogaW5kZXggd2hlcmUgZWRpdCBzdGFydGVkXG4gKiAtIGByZW1vdmVkYDogYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgaW5kZXhcbiAqIC0gYGFkZGVkQ291bnRgOiBudW1iZXIgb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gdGhlIExldmVuc2h0ZWluIFwibWluaW11bSBlZGl0IGRpc3RhbmNlXCJcbiAqIGFsZ29yaXRobS4gTm90ZSB0aGF0IHVwZGF0ZXMgYXJlIHRyZWF0ZWQgYXMgcmVtb3ZhbCBmb2xsb3dlZCBieSBhZGRpdGlvbi5cbiAqXG4gKiBUaGUgd29yc3QtY2FzZSB0aW1lIGNvbXBsZXhpdHkgb2YgdGhpcyBhbGdvcml0aG0gaXMgYE8obCAqIHApYFxuICogICBsOiBUaGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGFycmF5XG4gKiAgIHA6IFRoZSBsZW5ndGggb2YgdGhlIHByZXZpb3VzIGFycmF5XG4gKlxuICogSG93ZXZlciwgdGhlIHdvcnN0LWNhc2UgY29tcGxleGl0eSBpcyByZWR1Y2VkIGJ5IGFuIGBPKG4pYCBvcHRpbWl6YXRpb25cbiAqIHRvIGRldGVjdCBhbnkgc2hhcmVkIHByZWZpeCAmIHN1ZmZpeCBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzIGFuZCBvbmx5XG4gKiBwZXJmb3JtIHRoZSBtb3JlIGV4cGVuc2l2ZSBtaW5pbXVtIGVkaXQgZGlzdGFuY2UgY2FsY3VsYXRpb24gb3ZlciB0aGVcbiAqIG5vbi1zaGFyZWQgcG9ydGlvbnMgb2YgdGhlIGFycmF5cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUFycmF5fSBjdXJyZW50IFRoZSBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggc3BsaWNlcyB3aWxsIGJlXG4gKiBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHshQXJyYXl9IHByZXZpb3VzIFRoZSBcInVuY2hhbmdlZFwiIG9yaWdpbmFsIGFycmF5IHRvIGNvbXBhcmVcbiAqIGBjdXJyZW50YCBhZ2FpbnN0IHRvIGRldGVybWluZSB0aGUgc3BsaWNlcy5cbiAqIEByZXR1cm4geyFBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkIG9iamVjdHMuIEVhY2ggb2YgdGhlc2VcbiAqIGNvbnRhaW5zOiBgaW5kZXhgIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgc3BsaWNlIG9jY3VycmVkOyBgcmVtb3ZlZGBcbiAqIHRoZSBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBsb2NhdGlvbjsgYGFkZGVkQ291bnRgIHRoZSBudW1iZXJcbiAqIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgbG9jYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTcGxpY2VzKGN1cnJlbnQsIHByZXZpb3VzKSB7XG4gIHJldHVybiBjYWxjU3BsaWNlcyhjdXJyZW50LCAwLCBjdXJyZW50Lmxlbmd0aCwgcHJldmlvdXMsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcbiAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gcHJldmlvdXNWYWx1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/array-splice.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/async.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/async.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"animationFrame\": () => (/* binding */ animationFrame),\n/* harmony export */   \"idlePeriod\": () => (/* binding */ idlePeriod),\n/* harmony export */   \"microTask\": () => (/* binding */ microTask),\n/* harmony export */   \"timeOut\": () => (/* binding */ timeOut)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\n\n\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n};\n\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nconst microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcz8xNDY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICpcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgbnVtYmVyIG9mIHN0cmF0ZWdpZXMgZm9yIGVucXVldWluZyBhc3luY2hyb25vdXNcbiAqIHRhc2tzLiBFYWNoIHN1Yi1tb2R1bGUgcHJvdmlkZXMgYSBzdGFuZGFyZCBgcnVuKGZuKWAgaW50ZXJmYWNlIHRoYXQgcmV0dXJucyBhXG4gKiBoYW5kbGUsIGFuZCBhIGBjYW5jZWwoaGFuZGxlKWAgaW50ZXJmYWNlIGZvciBjYW5jZWxpbmcgYXN5bmMgdGFza3MgYmVmb3JlXG4gKiB0aGV5IHJ1bi5cbiAqXG4gKiBAc3VtbWFyeSBNb2R1bGUgdGhhdCBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmdcbiAqIGFzeW5jaHJvbm91cyB0YXNrcy5cbiAqL1xuXG5pbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIE1pY3JvdGFzayBpbXBsZW1lbnRlZCB1c2luZyBNdXRhdGlvbiBPYnNlcnZlclxubGV0IG1pY3JvdGFza0N1cnJIYW5kbGUgPSAwO1xubGV0IG1pY3JvdGFza0xhc3RIYW5kbGUgPSAwO1xubGV0IG1pY3JvdGFza0NhbGxiYWNrcyA9IFtdO1xubGV0IG1pY3JvdGFza05vZGVDb250ZW50ID0gMDtcbmxldCBtaWNyb3Rhc2tTY2hlZHVsZWQgPSBmYWxzZTtcbmxldCBtaWNyb3Rhc2tOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xubmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG1pY3JvdGFza0ZsdXNoKS5vYnNlcnZlKG1pY3JvdGFza05vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0ZsdXNoKCkge1xuICBtaWNyb3Rhc2tTY2hlZHVsZWQgPSBmYWxzZTtcbiAgY29uc3QgbGVuID0gbWljcm90YXNrQ2FsbGJhY2tzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBjYiA9IG1pY3JvdGFza0NhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlOyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbWljcm90YXNrQ2FsbGJhY2tzLnNwbGljZSgwLCBsZW4pO1xuICBtaWNyb3Rhc2tMYXN0SGFuZGxlICs9IGxlbjtcbn1cblxuLyoqXG4gKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHNldFRpbWVvdXRgLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgc2V0VGltZW91dGAuXG4gKi9cbmNvbnN0IHRpbWVPdXQgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3ViLW1vZHVsZSB3aXRoIHRoZSBhc3luYyBpbnRlcmZhY2UgcHJvdmlkaW5nIHRoZSBwcm92aWRlZFxuICAgKiBkZWxheS5cbiAgICpcbiAgICogQG1lbWJlcm9mIHRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXI9fSBkZWxheSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgY2FsbGJhY2tzIGluIG1zXG4gICAqIEByZXR1cm4geyFBc3luY0ludGVyZmFjZX0gQW4gYXN5bmMgdGltZW91dCBpbnRlcmZhY2VcbiAgICovXG4gIGFmdGVyKGRlbGF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bihmbikgeyByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIGRlbGF5KTsgfSxcbiAgICAgIGNhbmNlbChoYW5kbGUpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBpbiB0aGUgbmV4dCB0YXNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgdGltZU91dFxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gZGVsYXkgRGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oZm4sIGRlbGF5KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCBkZWxheSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgdGltZU91dGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiB0aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICB9XG59O1xuZXhwb3J0IHt0aW1lT3V0fTtcblxuLyoqXG4gKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICovXG5jb25zdCBhbmltYXRpb25GcmFtZSA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIGFuaW1hdGlvbkZyYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTp2b2lkfSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihmbikge1xuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgfSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBhbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBhbmltYXRpb25GcmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICB9XG59O1xuZXhwb3J0IHthbmltYXRpb25GcmFtZX07XG5cbi8qKlxuICogQXN5bmMgaW50ZXJmYWNlIHdyYXBwZXIgYXJvdW5kIGByZXF1ZXN0SWRsZUNhbGxiYWNrYC4gIEZhbGxzIGJhY2sgdG9cbiAqIGBzZXRUaW1lb3V0YCBvbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYC5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLlxuICovXG5jb25zdCBpZGxlUGVyaW9kID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIGlkbGVQZXJpb2RcbiAgICogQHBhcmFtIHtmdW5jdGlvbighSWRsZURlYWRsaW5lKTp2b2lkfSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihmbikge1xuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA/XG4gICAgICB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayhmbikgOlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZm4sIDE2KTtcbiAgfSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBpZGxlUGVyaW9kYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIGlkbGVQZXJpb2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID9cbiAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaGFuZGxlKSA6XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gIH1cbn07XG5leHBvcnQge2lkbGVQZXJpb2R9O1xuXG4vKipcbiAqIEFzeW5jIGludGVyZmFjZSBmb3IgZW5xdWV1aW5nIGNhbGxiYWNrcyB0aGF0IHJ1biBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICpcbiAqIE5vdGUgdGhhdCBtaWNyb3Rhc2sgdGltaW5nIGlzIGFjaGlldmVkIHZpYSBhIHNpbmdsZSBgTXV0YXRpb25PYnNlcnZlcmAsXG4gKiBhbmQgdGh1cyBjYWxsYmFja3MgZW5xdWV1ZWQgd2l0aCB0aGlzIEFQSSB3aWxsIGFsbCBydW4gaW4gYSBzaW5nbGVcbiAqIGJhdGNoLCBhbmQgbm90IGludGVybGVhdmVkIHdpdGggb3RoZXIgbWljcm90YXNrcyBzdWNoIGFzIHByb21pc2VzLlxuICogUHJvbWlzZXMgYXJlIGF2b2lkZWQgYXMgYW4gaW1wbGVtZW50YXRpb24gY2hvaWNlIGZvciB0aGUgdGltZSBiZWluZ1xuICogZHVlIHRvIFNhZmFyaSBidWdzIHRoYXQgY2F1c2UgUHJvbWlzZXMgdG8gbGFjayBtaWNyb3Rhc2sgZ3VhcmFudGVlcy5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWluZyBjYWxsYmFja3MgdGhhdCBydW4gYXQgbWljcm90YXNrXG4gKiAgIHRpbWluZy5cbiAqL1xuY29uc3QgbWljcm9UYXNrID0ge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbWljcm9UYXNrXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9uPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oY2FsbGJhY2spIHtcbiAgICBpZiAoIW1pY3JvdGFza1NjaGVkdWxlZCkge1xuICAgICAgbWljcm90YXNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIG1pY3JvdGFza05vZGUudGV4dENvbnRlbnQgPSBtaWNyb3Rhc2tOb2RlQ29udGVudCsrO1xuICAgIH1cbiAgICBtaWNyb3Rhc2tDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIG1pY3JvdGFza0N1cnJIYW5kbGUrKztcbiAgfSxcblxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYG1pY3JvVGFza2AgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtaWNyb1Rhc2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICBjb25zdCBpZHggPSBoYW5kbGUgLSBtaWNyb3Rhc2tMYXN0SGFuZGxlO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaWYgKCFtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXN5bmMgaGFuZGxlOiAnICsgaGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIG1pY3JvdGFza0NhbGxiYWNrc1tpZHhdID0gbnVsbDtcbiAgICB9XG4gIH1cblxufTtcbmV4cG9ydCB7bWljcm9UYXNrfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/async.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable no-unused-vars */\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]\n * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.\n *\n * @param {?} prop Property name\n * @param {*} obj Reference object\n * @return {string} Potentially renamed property name\n */\nwindow.JSCompiler_renameProperty = function (prop, obj) {\n  return prop;\n};\n/* eslint-enable */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9ib290LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qcz85ZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIFdoZW4gdXNpbmcgQ2xvc3VyZSBDb21waWxlciwgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eShwcm9wZXJ0eSwgb2JqZWN0KSBpcyByZXBsYWNlZCBieSB0aGUgbXVuZ2VkIG5hbWUgZm9yIG9iamVjdFtwcm9wZXJ0eV1cbiAqIFdlIGNhbm5vdCBhbGlhcyB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBoYXZlIHRvIHVzZSBhIHNtYWxsIHNoaW0gdGhhdCBoYXMgdGhlIHNhbWUgYmVoYXZpb3Igd2hlbiBub3QgY29tcGlsaW5nLlxuICpcbiAqIEBwYXJhbSB7P30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0geyp9IG9iaiBSZWZlcmVuY2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFBvdGVudGlhbGx5IHJlbmFtZWQgcHJvcGVydHkgbmFtZVxuICovXG53aW5kb3cuSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIG9iaikge1xuICByZXR1cm4gcHJvcDtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmV4cG9ydCB7fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/case-map.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/case-map.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"camelToDashCase\": () => (/* binding */ camelToDashCase),\n/* harmony export */   \"dashToCamelCase\": () => (/* binding */ dashToCamelCase)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nconst caseMap = {};\nconst DASH_TO_CAMEL = /-[a-z]/g;\nconst CAMEL_TO_DASH = /([A-Z])/g;\n\n/**\n * @fileoverview Module with utilities for converting between \"dash-case\" and\n * \"camelCase\" identifiers.\n */\n\n/**\n * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n * (e.g. `fooBarBaz`).\n *\n * @param {string} dash Dash-case identifier\n * @return {string} Camel-case representation of the identifier\n */\nfunction dashToCamelCase(dash) {\n  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));\n}\n\n/**\n * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n * (e.g. `foo-bar-baz`).\n *\n * @param {string} camel Camel-case identifier\n * @return {string} Dash-case representation of the identifier\n */\nfunction camelToDashCase(camel) {\n  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5qcz9jNzI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmNvbnN0IGNhc2VNYXAgPSB7fTtcbmNvbnN0IERBU0hfVE9fQ0FNRUwgPSAvLVthLXpdL2c7XG5jb25zdCBDQU1FTF9UT19EQVNIID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgY29udmVydGluZyBiZXR3ZWVuIFwiZGFzaC1jYXNlXCIgYW5kXG4gKiBcImNhbWVsQ2FzZVwiIGlkZW50aWZpZXJzLlxuICovXG5cbi8qKlxuICogQ29udmVydHMgXCJkYXNoLWNhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb28tYmFyLWJhemApIHRvIFwiY2FtZWxDYXNlXCJcbiAqIChlLmcuIGBmb29CYXJCYXpgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGFzaCBEYXNoLWNhc2UgaWRlbnRpZmllclxuICogQHJldHVybiB7c3RyaW5nfSBDYW1lbC1jYXNlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpZGVudGlmaWVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICByZXR1cm4gY2FzZU1hcFtkYXNoXSB8fCAoXG4gICAgY2FzZU1hcFtkYXNoXSA9IGRhc2guaW5kZXhPZignLScpIDwgMCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoREFTSF9UT19DQU1FTCxcbiAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICApXG4gICk7XG59XG5cbi8qKlxuICogQ29udmVydHMgXCJjYW1lbENhc2VcIiBpZGVudGlmaWVyIChlLmcuIGBmb29CYXJCYXpgKSB0byBcImRhc2gtY2FzZVwiXG4gKiAoZS5nLiBgZm9vLWJhci1iYXpgKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FtZWwgQ2FtZWwtY2FzZSBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERhc2gtY2FzZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaWRlbnRpZmllclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxUb0Rhc2hDYXNlKGNhbWVsKSB7XG4gIHJldHVybiBjYXNlTWFwW2NhbWVsXSB8fCAoXG4gICAgY2FzZU1hcFtjYW1lbF0gPSBjYW1lbC5yZXBsYWNlKENBTUVMX1RPX0RBU0gsICctJDEnKS50b0xvd2VyQ2FzZSgpXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/case-map.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FlattenedNodesObserver\": () => (/* binding */ FlattenedNodesObserver)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _array_splice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array-splice.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/array-splice.js\");\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./async.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/async.js\");\n/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrap.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * Returns true if `node` is a slot element\n * @param {!Node} node Node to test.\n * @return {boolean} Returns true if the given `node` is a slot\n * @private\n */\nfunction isSlot(node) {\n  return node.localName === 'slot';\n}\n\n/**\n * Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`. The list of flattened nodes consists\n * of a node's children and, for any children that are `<slot>` elements,\n * the expanded flattened list of `assignedNodes`.\n * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n * and the `<slot>` has one `<div>` assigned to it, then the flattened\n * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n * `<slot>` elements assigned to it, these are flattened as well.\n *\n * The provided `callback` is called whenever any change to this list\n * of flattened nodes occurs, where an addition or removal of a node is\n * considered a change. The `callback` is called with one argument, an object\n * containing an array of any `addedNodes` and `removedNodes`.\n *\n * Note: the callback is called asynchronous to any changes\n * at a microtask checkpoint. This is because observation is performed using\n * `MutationObserver` and the `<slot>` element's `slotchange` event which\n * are asynchronous.\n *\n * An example:\n * ```js\n * class TestSelfObserve extends PolymerElement {\n *   static get is() { return 'test-self-observe';}\n *   connectedCallback() {\n *     super.connectedCallback();\n *     this._observer = new FlattenedNodesObserver(this, (info) => {\n *       this.info = info;\n *     });\n *   }\n *   disconnectedCallback() {\n *     super.disconnectedCallback();\n *     this._observer.disconnect();\n *   }\n * }\n * customElements.define(TestSelfObserve.is, TestSelfObserve);\n * ```\n *\n * @summary Class that listens for changes (additions or removals) to\n * \"flattened nodes\" on a given `node`.\n * @implements {PolymerDomApi.ObserveHandle}\n */\nlet FlattenedNodesObserver = class {\n  /**\n   * Returns the list of flattened nodes for the given `node`.\n   * This list consists of a node's children and, for any children\n   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.\n   * For example, if the observed node has children `<a></a><slot></slot><b></b>`\n   * and the `<slot>` has one `<div>` assigned to it, then the flattened\n   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other\n   * `<slot>` elements assigned to it, these are flattened as well.\n   *\n   * @param {!HTMLElement|!HTMLSlotElement} node The node for which to\n   *      return the list of flattened nodes.\n   * @return {!Array<!Node>} The list of flattened nodes for the given `node`.\n   * @nocollapse See https://github.com/google/closure-compiler/issues/2763\n   */\n  // eslint-disable-next-line\n  static getFlattenedNodes(node) {\n    const wrapped = (0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(node);\n    if (isSlot(node)) {\n      node = /** @type {!HTMLSlotElement} */node; // eslint-disable-line no-self-assign\n      return wrapped.assignedNodes({\n        flatten: true\n      });\n    } else {\n      return Array.from(wrapped.childNodes).map(node => {\n        if (isSlot(node)) {\n          node = /** @type {!HTMLSlotElement} */node; // eslint-disable-line no-self-assign\n          return (0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(node).assignedNodes({\n            flatten: true\n          });\n        } else {\n          return [node];\n        }\n      }).reduce((a, b) => a.concat(b), []);\n    }\n  }\n\n  /**\n   * @param {!HTMLElement} target Node on which to listen for changes.\n   * @param {?function(this: Element, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions\n   * or removals from the target's list of flattened nodes.\n   */\n  // eslint-disable-next-line\n  constructor(target, callback) {\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n    this._shadyChildrenObserver = null;\n    /**\n     * @type {MutationObserver}\n     * @private\n     */\n    this._nativeChildrenObserver = null;\n    this._connected = false;\n    /**\n     * @type {!HTMLElement}\n     * @private\n     */\n    this._target = target;\n    this.callback = callback;\n    this._effectiveNodes = [];\n    this._observer = null;\n    this._scheduled = false;\n    /**\n     * @type {function()}\n     * @private\n     */\n    this._boundSchedule = () => {\n      this._schedule();\n    };\n    this.connect();\n    this._schedule();\n  }\n\n  /**\n   * Activates an observer. This method is automatically called when\n   * a `FlattenedNodesObserver` is created. It should only be called to\n   * re-activate an observer that has been deactivated via the `disconnect` method.\n   *\n   * @return {void}\n   */\n  connect() {\n    if (isSlot(this._target)) {\n      this._listenSlots([this._target]);\n    } else if ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children) {\n      this._listenSlots( /** @type {!NodeList<!Node>} */(0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children);\n      if (window.ShadyDOM) {\n        this._shadyChildrenObserver = window.ShadyDOM.observeChildren(this._target, mutations => {\n          this._processMutations(mutations);\n        });\n      } else {\n        this._nativeChildrenObserver = new MutationObserver(mutations => {\n          this._processMutations(mutations);\n        });\n        this._nativeChildrenObserver.observe(this._target, {\n          childList: true\n        });\n      }\n    }\n    this._connected = true;\n  }\n\n  /**\n   * Deactivates the flattened nodes observer. After calling this method\n   * the observer callback will not be called when changes to flattened nodes\n   * occur. The `connect` method may be subsequently called to reactivate\n   * the observer.\n   *\n   * @return {void}\n   * @override\n   */\n  disconnect() {\n    if (isSlot(this._target)) {\n      this._unlistenSlots([this._target]);\n    } else if ((0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children) {\n      this._unlistenSlots( /** @type {!NodeList<!Node>} */(0,_wrap_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(this._target).children);\n      if (window.ShadyDOM && this._shadyChildrenObserver) {\n        window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver);\n        this._shadyChildrenObserver = null;\n      } else if (this._nativeChildrenObserver) {\n        this._nativeChildrenObserver.disconnect();\n        this._nativeChildrenObserver = null;\n      }\n    }\n    this._connected = false;\n  }\n\n  /**\n   * @return {void}\n   * @private\n   */\n  _schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n      _async_js__WEBPACK_IMPORTED_MODULE_2__.microTask.run(() => this.flush());\n    }\n  }\n\n  /**\n   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n   * @return {void}\n   * @private\n   */\n  _processMutations(mutations) {\n    this._processSlotMutations(mutations);\n    this.flush();\n  }\n\n  /**\n   * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer\n   * @return {void}\n   * @private\n   */\n  _processSlotMutations(mutations) {\n    if (mutations) {\n      for (let i = 0; i < mutations.length; i++) {\n        let mutation = mutations[i];\n        if (mutation.addedNodes) {\n          this._listenSlots(mutation.addedNodes);\n        }\n        if (mutation.removedNodes) {\n          this._unlistenSlots(mutation.removedNodes);\n        }\n      }\n    }\n  }\n\n  /**\n   * Flushes the observer causing any pending changes to be immediately\n   * delivered the observer callback. By default these changes are delivered\n   * asynchronously at the next microtask checkpoint.\n   *\n   * @return {boolean} Returns true if any pending changes caused the observer\n   * callback to run.\n   */\n  flush() {\n    if (!this._connected) {\n      return false;\n    }\n    if (window.ShadyDOM) {\n      ShadyDOM.flush();\n    }\n    if (this._nativeChildrenObserver) {\n      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());\n    } else if (this._shadyChildrenObserver) {\n      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());\n    }\n    this._scheduled = false;\n    let info = {\n      target: this._target,\n      addedNodes: [],\n      removedNodes: []\n    };\n    let newNodes = this.constructor.getFlattenedNodes(this._target);\n    let splices = (0,_array_splice_js__WEBPACK_IMPORTED_MODULE_1__.calculateSplices)(newNodes, this._effectiveNodes);\n    // process removals\n    for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {\n      for (let j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n        info.removedNodes.push(n);\n      }\n    }\n    // process adds\n    for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {\n      for (let j = s.index; j < s.index + s.addedCount; j++) {\n        info.addedNodes.push(newNodes[j]);\n      }\n    }\n    // update cache\n    this._effectiveNodes = newNodes;\n    let didFlush = false;\n    if (info.addedNodes.length || info.removedNodes.length) {\n      didFlush = true;\n      this.callback.call(this._target, info);\n    }\n    return didFlush;\n  }\n\n  /**\n   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n   * @return {void}\n   * @private\n   */\n  _listenSlots(nodeList) {\n    for (let i = 0; i < nodeList.length; i++) {\n      let n = nodeList[i];\n      if (isSlot(n)) {\n        n.addEventListener('slotchange', this._boundSchedule);\n      }\n    }\n  }\n\n  /**\n   * @param {!Array<!Node>|!NodeList<!Node>} nodeList Nodes that could change\n   * @return {void}\n   * @private\n   */\n  _unlistenSlots(nodeList) {\n    for (let i = 0; i < nodeList.length; i++) {\n      let n = nodeList[i];\n      if (isSlot(n)) {\n        n.removeEventListener('slotchange', this._boundSchedule);\n      }\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qcz8xMDI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmltcG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfSBmcm9tICcuL2FycmF5LXNwbGljZS5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuL2FzeW5jLmpzJztcbmltcG9ydCB7IHdyYXAgfSBmcm9tICcuL3dyYXAuanMnO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZWAgaXMgYSBzbG90IGVsZW1lbnRcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgTm9kZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgYSBzbG90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1Nsb3Qobm9kZSkge1xuICByZXR1cm4gKG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpO1xufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC4gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGNvbnNpc3RzXG4gKiBvZiBhIG5vZGUncyBjaGlsZHJlbiBhbmQsIGZvciBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsXG4gKiB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICogYW5kIHRoZSBgPHNsb3Q+YCBoYXMgb25lIGA8ZGl2PmAgYXNzaWduZWQgdG8gaXQsIHRoZW4gdGhlIGZsYXR0ZW5lZFxuICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gKlxuICogVGhlIHByb3ZpZGVkIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdoZW5ldmVyIGFueSBjaGFuZ2UgdG8gdGhpcyBsaXN0XG4gKiBvZiBmbGF0dGVuZWQgbm9kZXMgb2NjdXJzLCB3aGVyZSBhbiBhZGRpdGlvbiBvciByZW1vdmFsIG9mIGEgbm9kZSBpc1xuICogY29uc2lkZXJlZCBhIGNoYW5nZS4gVGhlIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCBhbiBvYmplY3RcbiAqIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgYW55IGBhZGRlZE5vZGVzYCBhbmQgYHJlbW92ZWROb2Rlc2AuXG4gKlxuICogTm90ZTogdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBhc3luY2hyb25vdXMgdG8gYW55IGNoYW5nZXNcbiAqIGF0IGEgbWljcm90YXNrIGNoZWNrcG9pbnQuIFRoaXMgaXMgYmVjYXVzZSBvYnNlcnZhdGlvbiBpcyBwZXJmb3JtZWQgdXNpbmdcbiAqIGBNdXRhdGlvbk9ic2VydmVyYCBhbmQgdGhlIGA8c2xvdD5gIGVsZW1lbnQncyBgc2xvdGNoYW5nZWAgZXZlbnQgd2hpY2hcbiAqIGFyZSBhc3luY2hyb25vdXMuXG4gKlxuICogQW4gZXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBjbGFzcyBUZXN0U2VsZk9ic2VydmUgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gKiAgIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAndGVzdC1zZWxmLW9ic2VydmUnO31cbiAqICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gKiAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAqICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMsIChpbmZvKSA9PiB7XG4gKiAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICogICAgIH0pO1xuICogICB9XG4gKiAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICogICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gKiAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICogICB9XG4gKiB9XG4gKiBjdXN0b21FbGVtZW50cy5kZWZpbmUoVGVzdFNlbGZPYnNlcnZlLmlzLCBUZXN0U2VsZk9ic2VydmUpO1xuICogYGBgXG4gKlxuICogQHN1bW1hcnkgQ2xhc3MgdGhhdCBsaXN0ZW5zIGZvciBjaGFuZ2VzIChhZGRpdGlvbnMgb3IgcmVtb3ZhbHMpIHRvXG4gKiBcImZsYXR0ZW5lZCBub2Rlc1wiIG9uIGEgZ2l2ZW4gYG5vZGVgLlxuICogQGltcGxlbWVudHMge1BvbHltZXJEb21BcGkuT2JzZXJ2ZUhhbmRsZX1cbiAqL1xuZXhwb3J0IGxldCBGbGF0dGVuZWROb2Rlc09ic2VydmVyID0gY2xhc3Mge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICogVGhpcyBsaXN0IGNvbnNpc3RzIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlblxuICAgKiB0aGF0IGFyZSBgPHNsb3Q+YCBlbGVtZW50cywgdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICAgKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gICAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gICAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fCFIVE1MU2xvdEVsZW1lbnR9IG5vZGUgVGhlIG5vZGUgZm9yIHdoaWNoIHRvXG4gICAqICAgICAgcmV0dXJuIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgICogQHJldHVybiB7IUFycmF5PCFOb2RlPn0gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAgKiBAbm9jb2xsYXBzZSBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8yNzYzXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgc3RhdGljIGdldEZsYXR0ZW5lZE5vZGVzKG5vZGUpIHtcbiAgICBjb25zdCB3cmFwcGVkID0gd3JhcChub2RlKTtcbiAgICBpZiAoaXNTbG90KG5vZGUpKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqLyhub2RlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgcmV0dXJuIHdyYXBwZWQuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh3cmFwcGVkLmNoaWxkTm9kZXMpLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAoaXNTbG90KG5vZGUpKSB7XG4gICAgICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi8obm9kZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICByZXR1cm4gd3JhcChub2RlKS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgfVxuICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gdGFyZ2V0IE5vZGUgb24gd2hpY2ggdG8gbGlzdGVuIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbih0aGlzOiBFbGVtZW50LCB7IHRhcmdldDogIUhUTUxFbGVtZW50LCBhZGRlZE5vZGVzOiAhQXJyYXk8IUVsZW1lbnQ+LCByZW1vdmVkTm9kZXM6ICFBcnJheTwhRWxlbWVudD4gfSk6dm9pZH0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlcmUgYXJlIGFkZGl0aW9uc1xuICAgKiBvciByZW1vdmFscyBmcm9tIHRoZSB0YXJnZXQncyBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBbXTtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ib3VuZFNjaGVkdWxlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9O1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGFuIG9ic2VydmVyLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAqIGEgYEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIGlzIGNyZWF0ZWQuIEl0IHNob3VsZCBvbmx5IGJlIGNhbGxlZCB0b1xuICAgKiByZS1hY3RpdmF0ZSBhbiBvYnNlcnZlciB0aGF0IGhhcyBiZWVuIGRlYWN0aXZhdGVkIHZpYSB0aGUgYGRpc2Nvbm5lY3RgIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICB0aGlzLl9saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgfSBlbHNlIGlmICh3cmFwKHRoaXMuX3RhcmdldCkuY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuX2xpc3RlblNsb3RzKFxuICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGVMaXN0PCFOb2RlPn0gKi8gKHdyYXAodGhpcy5fdGFyZ2V0KS5jaGlsZHJlbikpO1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSkge1xuICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPVxuICAgICAgICAgIHdpbmRvdy5TaGFkeURPTS5vYnNlcnZlQ2hpbGRyZW4odGhpcy5fdGFyZ2V0LCAobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl90YXJnZXQsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgZmxhdHRlbmVkIG5vZGVzIG9ic2VydmVyLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIHRoZSBvYnNlcnZlciBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIGZsYXR0ZW5lZCBub2Rlc1xuICAgKiBvY2N1ci4gVGhlIGBjb25uZWN0YCBtZXRob2QgbWF5IGJlIHN1YnNlcXVlbnRseSBjYWxsZWQgdG8gcmVhY3RpdmF0ZVxuICAgKiB0aGUgb2JzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgIH0gZWxzZSBpZiAod3JhcCh0aGlzLl90YXJnZXQpLmNoaWxkcmVuKSB7XG4gICAgICB0aGlzLl91bmxpc3RlblNsb3RzKFxuICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGVMaXN0PCFOb2RlPn0gKi8gKHdyYXAodGhpcy5fdGFyZ2V0KS5jaGlsZHJlbikpO1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgd2luZG93LlNoYWR5RE9NLnVub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NjaGVkdWxlKCkge1xuICAgIGlmICghdGhpcy5fc2NoZWR1bGVkKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgbWljcm9UYXNrLnJ1bigoKSA9PiB0aGlzLmZsdXNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PE11dGF0aW9uUmVjb3JkPn0gbXV0YXRpb25zIE11dGF0aW9ucyBzaWduYWxlZCBieSB0aGUgbXV0YXRpb24gb2JzZXJ2ZXJcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8TXV0YXRpb25SZWNvcmQ+fSBtdXRhdGlvbnMgTXV0YXRpb25zIHNpZ25hbGVkIGJ5IHRoZSBtdXRhdGlvbiBvYnNlcnZlclxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIGlmIChtdXRhdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgIGlmIChtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuU2xvdHMobXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11dGF0aW9uLnJlbW92ZWROb2Rlcykge1xuICAgICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMobXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGVzIHRoZSBvYnNlcnZlciBjYXVzaW5nIGFueSBwZW5kaW5nIGNoYW5nZXMgdG8gYmUgaW1tZWRpYXRlbHlcbiAgICogZGVsaXZlcmVkIHRoZSBvYnNlcnZlciBjYWxsYmFjay4gQnkgZGVmYXVsdCB0aGVzZSBjaGFuZ2VzIGFyZSBkZWxpdmVyZWRcbiAgICogYXN5bmNocm9ub3VzbHkgYXQgdGhlIG5leHQgbWljcm90YXNrIGNoZWNrcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGVuZGluZyBjaGFuZ2VzIGNhdXNlZCB0aGUgb2JzZXJ2ZXJcbiAgICogY2FsbGJhY2sgdG8gcnVuLlxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TaGFkeURPTSkge1xuICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICB9XG4gICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgbGV0IGluZm8gPSB7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGFkZGVkTm9kZXM6IFtdLFxuICAgICAgcmVtb3ZlZE5vZGVzOiBbXVxuICAgIH07XG4gICAgbGV0IG5ld05vZGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRGbGF0dGVuZWROb2Rlcyh0aGlzLl90YXJnZXQpO1xuICAgIGxldCBzcGxpY2VzID0gY2FsY3VsYXRlU3BsaWNlcyhuZXdOb2RlcyxcbiAgICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzKTtcbiAgICAvLyBwcm9jZXNzIHJlbW92YWxzXG4gICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgZm9yIChsZXQgaj0wLCBuOyAoaiA8IHMucmVtb3ZlZC5sZW5ndGgpICYmIChuPXMucmVtb3ZlZFtqXSk7IGorKykge1xuICAgICAgICBpbmZvLnJlbW92ZWROb2Rlcy5wdXNoKG4pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm9jZXNzIGFkZHNcbiAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqPXMuaW5kZXg7IGogPCBzLmluZGV4ICsgcy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgaW5mby5hZGRlZE5vZGVzLnB1c2gobmV3Tm9kZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgY2FjaGVcbiAgICB0aGlzLl9lZmZlY3RpdmVOb2RlcyA9IG5ld05vZGVzO1xuICAgIGxldCBkaWRGbHVzaCA9IGZhbHNlO1xuICAgIGlmIChpbmZvLmFkZGVkTm9kZXMubGVuZ3RoIHx8IGluZm8ucmVtb3ZlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgZGlkRmx1c2ggPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuX3RhcmdldCwgaW5mbyk7XG4gICAgfVxuICAgIHJldHVybiBkaWRGbHVzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTwhTm9kZT58IU5vZGVMaXN0PCFOb2RlPn0gbm9kZUxpc3QgTm9kZXMgdGhhdCBjb3VsZCBjaGFuZ2VcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9saXN0ZW5TbG90cyhub2RlTGlzdCkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgaWYgKGlzU2xvdChuKSkge1xuICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLl9ib3VuZFNjaGVkdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQXJyYXk8IU5vZGU+fCFOb2RlTGlzdDwhTm9kZT59IG5vZGVMaXN0IE5vZGVzIHRoYXQgY291bGQgY2hhbmdlXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdW5saXN0ZW5TbG90cyhub2RlTGlzdCkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgaWYgKGlzU2xvdChuKSkge1xuICAgICAgICBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLl9ib3VuZFNjaGVkdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/html-tag.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/html-tag.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"html\": () => (/* binding */ html),\n/* harmony export */   \"htmlLiteral\": () => (/* binding */ htmlLiteral)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the Polymer html\n * template tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n *\n * @type {!TrustedTypePolicy|undefined}\n */\nconst policy = window.trustedTypes && trustedTypes.createPolicy('polymer-html-literal', {\n  createHTML: s => s\n});\n\n/**\n * Class representing a static string value which can be used to filter\n * strings by asseting that they have been created via this class. The\n * `value` property returns the string passed to the constructor.\n */\nclass LiteralString {\n  /**\n   * @param {!ITemplateArray} strings Constant parts of tagged template literal\n   * @param {!Array<*>} values Variable parts of tagged template literal\n   */\n  constructor(strings, values) {\n    assertValidTemplateStringParameters(strings, values);\n    const string = values.reduce((acc, v, idx) => acc + literalValue(v) + strings[idx + 1], strings[0]);\n    /** @type {string} */\n    this.value = string.toString();\n  }\n  /**\n   * @return {string} LiteralString string value\n   * @override\n   */\n  toString() {\n    return this.value;\n  }\n}\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\nfunction literalValue(value) {\n  if (value instanceof LiteralString) {\n    return (/** @type {!LiteralString} */value.value\n    );\n  } else {\n    throw new Error(`non-literal value passed to Polymer's htmlLiteral function: ${value}`);\n  }\n}\n\n/**\n * @param {*} value Object to stringify into HTML\n * @return {string} HTML stringified form of `obj`\n */\nfunction htmlValue(value) {\n  if (value instanceof HTMLTemplateElement) {\n    // This might be an mXSS risk  mainly in the case where this template\n    // contains untrusted content that was believed to be sanitized.\n    // However we can't just use the XMLSerializer here because it misencodes\n    // `>` characters inside style tags.\n    // For an example of an actual case that hit this encoding issue,\n    // see b/198592167\n    return (/** @type {!HTMLTemplateElement } */value.innerHTML\n    );\n  } else if (value instanceof LiteralString) {\n    return literalValue(value);\n  } else {\n    throw new Error(`non-template value passed to Polymer's html function: ${value}`);\n  }\n}\n\n/**\n * A template literal tag that creates an HTML <template> element from the\n * contents of the string.\n *\n * This allows you to write a Polymer Template in JavaScript.\n *\n * Templates can be composed by interpolating `HTMLTemplateElement`s in\n * expressions in the JavaScript template literal. The nested template's\n * `innerHTML` is included in the containing template.  The only other\n * values allowed in expressions are those returned from `htmlLiteral`\n * which ensures only literal values from JS source ever reach the HTML, to\n * guard against XSS risks.\n *\n * All other values are disallowed in expressions to help prevent XSS\n * attacks; however, `htmlLiteral` can be used to compose static\n * string values into templates. This is useful to compose strings into\n * places that do not accept html, like the css text of a `style`\n * element.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>:host{ content:\"...\" }</style>\n *         <div class=\"shadowed\">${this.partialTemplate}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get partialTemplate() { return html`<span>Partial!</span>`; }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement\n */\nconst html = function html(strings, ...values) {\n  assertValidTemplateStringParameters(strings, values);\n  const template = /** @type {!HTMLTemplateElement} */document.createElement('template');\n  let value = values.reduce((acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);\n  if (policy) {\n    value = policy.createHTML(value);\n  }\n  template.innerHTML = value;\n  return template;\n};\n\n/**\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {!Array<*>} values Array of values from quasis\n */\nconst assertValidTemplateStringParameters = (strings, values) => {\n  // Note: if/when https://github.com/tc39/proposal-array-is-template-object\n  // is standardized, use that instead when available, as it can perform an\n  // unforgable check (though of course, the function itself can be forged).\n  if (!Array.isArray(strings) || !Array.isArray(strings.raw) || values.length !== strings.length - 1) {\n    // This is either caused by a browser bug, a compiler bug, or someone\n    // calling the html template tag function as a regular function.\n    //\n    throw new TypeError('Invalid call to the html template tag');\n  }\n};\n\n/**\n * An html literal tag that can be used with `html` to compose.\n * a literal string.\n *\n * Example:\n *\n *     static get template() {\n *       return html`\n *         <style>\n *           :host { display: block; }\n *           ${this.styleTemplate()}\n *         </style>\n *         <div class=\"shadowed\">${staticValue}</div>\n *         ${super.template}\n *       `;\n *     }\n *     static get styleTemplate() {\n *        return htmlLiteral`.shadowed { background: gray; }`;\n *     }\n *\n * @param {!ITemplateArray} strings Constant parts of tagged template literal\n * @param {...*} values Variable parts of tagged template literal\n * @return {!LiteralString} Constructed literal string\n */\nconst htmlLiteral = function (strings, ...values) {\n  return new LiteralString(strings, values);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2h0bWwtdGFnLmpzPzRlZGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnLi9ib290LmpzJztcblxuLyoqXG4gKiBPdXIgVHJ1c3RlZFR5cGVQb2xpY3kgZm9yIEhUTUwgd2hpY2ggaXMgZGVjbGFyZWQgdXNpbmcgdGhlIFBvbHltZXIgaHRtbFxuICogdGVtcGxhdGUgdGFnIGZ1bmN0aW9uLlxuICpcbiAqIFRoYXQgSFRNTCBpcyBhIGRldmVsb3Blci1hdXRob3JlZCBjb25zdGFudCwgYW5kIGlzIHBhcnNlZCB3aXRoIGlubmVySFRNTFxuICogYmVmb3JlIGFueSB1bnRydXN0ZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuIG1peGVkIGluLiBUaGVyZWZvciBpdCBpc1xuICogY29uc2lkZXJlZCBzYWZlIGJ5IGNvbnN0cnVjdGlvbi5cbiAqXG4gKiBAdHlwZSB7IVRydXN0ZWRUeXBlUG9saWN5fHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgcG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcyAmJlxuICAgIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koJ3BvbHltZXItaHRtbC1saXRlcmFsJywge2NyZWF0ZUhUTUw6IChzKSA9PiBzfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc3RhdGljIHN0cmluZyB2YWx1ZSB3aGljaCBjYW4gYmUgdXNlZCB0byBmaWx0ZXJcbiAqIHN0cmluZ3MgYnkgYXNzZXRpbmcgdGhhdCB0aGV5IGhhdmUgYmVlbiBjcmVhdGVkIHZpYSB0aGlzIGNsYXNzLiBUaGVcbiAqIGB2YWx1ZWAgcHJvcGVydHkgcmV0dXJucyB0aGUgc3RyaW5nIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKi9cbmNsYXNzIExpdGVyYWxTdHJpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHshSVRlbXBsYXRlQXJyYXl9IHN0cmluZ3MgQ29uc3RhbnQgcGFydHMgb2YgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IHZhbHVlcyBWYXJpYWJsZSBwYXJ0cyBvZiB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzKSB7XG4gICAgYXNzZXJ0VmFsaWRUZW1wbGF0ZVN0cmluZ1BhcmFtZXRlcnMoc3RyaW5ncywgdmFsdWVzKTtcbiAgICBjb25zdCBzdHJpbmcgPSB2YWx1ZXMucmVkdWNlKFxuICAgICAgICAoYWNjLCB2LCBpZHgpID0+IGFjYyArIGxpdGVyYWxWYWx1ZSh2KSArIHN0cmluZ3NbaWR4ICsgMV0sIHN0cmluZ3NbMF0pO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMudmFsdWUgPSBzdHJpbmcudG9TdHJpbmcoKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBMaXRlcmFsU3RyaW5nIHN0cmluZyB2YWx1ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBPYmplY3QgdG8gc3RyaW5naWZ5IGludG8gSFRNTFxuICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHN0cmluZ2lmaWVkIGZvcm0gb2YgYG9iamBcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbFZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdGVyYWxTdHJpbmcpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTGl0ZXJhbFN0cmluZ30gKi8odmFsdWUpLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYG5vbi1saXRlcmFsIHZhbHVlIHBhc3NlZCB0byBQb2x5bWVyJ3MgaHRtbExpdGVyYWwgZnVuY3Rpb246ICR7dmFsdWV9YFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9iamVjdCB0byBzdHJpbmdpZnkgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgc3RyaW5naWZpZWQgZm9ybSBvZiBgb2JqYFxuICovXG5mdW5jdGlvbiBodG1sVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCkge1xuICAgIC8vIFRoaXMgbWlnaHQgYmUgYW4gbVhTUyByaXNrIOKAkyBtYWlubHkgaW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyB0ZW1wbGF0ZVxuICAgIC8vIGNvbnRhaW5zIHVudHJ1c3RlZCBjb250ZW50IHRoYXQgd2FzIGJlbGlldmVkIHRvIGJlIHNhbml0aXplZC5cbiAgICAvLyBIb3dldmVyIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBYTUxTZXJpYWxpemVyIGhlcmUgYmVjYXVzZSBpdCBtaXNlbmNvZGVzXG4gICAgLy8gYD5gIGNoYXJhY3RlcnMgaW5zaWRlIHN0eWxlIHRhZ3MuXG4gICAgLy8gRm9yIGFuIGV4YW1wbGUgb2YgYW4gYWN0dWFsIGNhc2UgdGhhdCBoaXQgdGhpcyBlbmNvZGluZyBpc3N1ZSxcbiAgICAvLyBzZWUgYi8xOTg1OTIxNjdcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudCB9ICovKHZhbHVlKS5pbm5lckhUTUw7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXRlcmFsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGxpdGVyYWxWYWx1ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgbm9uLXRlbXBsYXRlIHZhbHVlIHBhc3NlZCB0byBQb2x5bWVyJ3MgaHRtbCBmdW5jdGlvbjogJHt2YWx1ZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgdGVtcGxhdGUgbGl0ZXJhbCB0YWcgdGhhdCBjcmVhdGVzIGFuIEhUTUwgPHRlbXBsYXRlPiBlbGVtZW50IGZyb20gdGhlXG4gKiBjb250ZW50cyBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB3cml0ZSBhIFBvbHltZXIgVGVtcGxhdGUgaW4gSmF2YVNjcmlwdC5cbiAqXG4gKiBUZW1wbGF0ZXMgY2FuIGJlIGNvbXBvc2VkIGJ5IGludGVycG9sYXRpbmcgYEhUTUxUZW1wbGF0ZUVsZW1lbnRgcyBpblxuICogZXhwcmVzc2lvbnMgaW4gdGhlIEphdmFTY3JpcHQgdGVtcGxhdGUgbGl0ZXJhbC4gVGhlIG5lc3RlZCB0ZW1wbGF0ZSdzXG4gKiBgaW5uZXJIVE1MYCBpcyBpbmNsdWRlZCBpbiB0aGUgY29udGFpbmluZyB0ZW1wbGF0ZS4gIFRoZSBvbmx5IG90aGVyXG4gKiB2YWx1ZXMgYWxsb3dlZCBpbiBleHByZXNzaW9ucyBhcmUgdGhvc2UgcmV0dXJuZWQgZnJvbSBgaHRtbExpdGVyYWxgXG4gKiB3aGljaCBlbnN1cmVzIG9ubHkgbGl0ZXJhbCB2YWx1ZXMgZnJvbSBKUyBzb3VyY2UgZXZlciByZWFjaCB0aGUgSFRNTCwgdG9cbiAqIGd1YXJkIGFnYWluc3QgWFNTIHJpc2tzLlxuICpcbiAqIEFsbCBvdGhlciB2YWx1ZXMgYXJlIGRpc2FsbG93ZWQgaW4gZXhwcmVzc2lvbnMgdG8gaGVscCBwcmV2ZW50IFhTU1xuICogYXR0YWNrczsgaG93ZXZlciwgYGh0bWxMaXRlcmFsYCBjYW4gYmUgdXNlZCB0byBjb21wb3NlIHN0YXRpY1xuICogc3RyaW5nIHZhbHVlcyBpbnRvIHRlbXBsYXRlcy4gVGhpcyBpcyB1c2VmdWwgdG8gY29tcG9zZSBzdHJpbmdzIGludG9cbiAqIHBsYWNlcyB0aGF0IGRvIG5vdCBhY2NlcHQgaHRtbCwgbGlrZSB0aGUgY3NzIHRleHQgb2YgYSBgc3R5bGVgXG4gKiBlbGVtZW50LlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gKiAgICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgICAgPHN0eWxlPjpob3N0eyBjb250ZW50OlwiLi4uXCIgfTwvc3R5bGU+XG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJzaGFkb3dlZFwiPiR7dGhpcy5wYXJ0aWFsVGVtcGxhdGV9PC9kaXY+XG4gKiAgICAgICAgICR7c3VwZXIudGVtcGxhdGV9XG4gKiAgICAgICBgO1xuICogICAgIH1cbiAqICAgICBzdGF0aWMgZ2V0IHBhcnRpYWxUZW1wbGF0ZSgpIHsgcmV0dXJuIGh0bWxgPHNwYW4+UGFydGlhbCE8L3NwYW4+YDsgfVxuICpcbiAqIEBwYXJhbSB7IUlUZW1wbGF0ZUFycmF5fSBzdHJpbmdzIENvbnN0YW50IHBhcnRzIG9mIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXG4gKiBAcGFyYW0gey4uLip9IHZhbHVlcyBWYXJpYWJsZSBwYXJ0cyBvZiB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFxuICogQHJldHVybiB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IENvbnN0cnVjdGVkIEhUTUxUZW1wbGF0ZUVsZW1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWwgPSBmdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICBhc3NlcnRWYWxpZFRlbXBsYXRlU3RyaW5nUGFyYW1ldGVycyhzdHJpbmdzLCB2YWx1ZXMpO1xuICBjb25zdCB0ZW1wbGF0ZSA9XG4gICAgICAvKiogQHR5cGUgeyFIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKSk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlcy5yZWR1Y2UoXG4gICAgICAoYWNjLCB2LCBpZHgpID0+IGFjYyArIGh0bWxWYWx1ZSh2KSArIHN0cmluZ3NbaWR4ICsgMV0sIHN0cmluZ3NbMF0pO1xuICBpZiAocG9saWN5KSB7XG4gICAgdmFsdWUgPSBwb2xpY3kuY3JlYXRlSFRNTCh2YWx1ZSk7XG4gIH1cbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdmFsdWU7XG4gIHJldHVybiB0ZW1wbGF0ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHshSVRlbXBsYXRlQXJyYXl9IHN0cmluZ3MgQ29uc3RhbnQgcGFydHMgb2YgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcbiAqIEBwYXJhbSB7IUFycmF5PCo+fSB2YWx1ZXMgQXJyYXkgb2YgdmFsdWVzIGZyb20gcXVhc2lzXG4gKi9cbmNvbnN0IGFzc2VydFZhbGlkVGVtcGxhdGVTdHJpbmdQYXJhbWV0ZXJzID0gKHN0cmluZ3MsIHZhbHVlcykgPT4ge1xuICAvLyBOb3RlOiBpZi93aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWlzLXRlbXBsYXRlLW9iamVjdFxuICAvLyBpcyBzdGFuZGFyZGl6ZWQsIHVzZSB0aGF0IGluc3RlYWQgd2hlbiBhdmFpbGFibGUsIGFzIGl0IGNhbiBwZXJmb3JtIGFuXG4gIC8vIHVuZm9yZ2FibGUgY2hlY2sgKHRob3VnaCBvZiBjb3Vyc2UsIHRoZSBmdW5jdGlvbiBpdHNlbGYgY2FuIGJlIGZvcmdlZCkuXG4gIGlmICghQXJyYXkuaXNBcnJheShzdHJpbmdzKSB8fCAhQXJyYXkuaXNBcnJheShzdHJpbmdzLnJhdykgfHxcbiAgICAgICh2YWx1ZXMubGVuZ3RoICE9PSBzdHJpbmdzLmxlbmd0aCAtIDEpKSB7XG4gICAgLy8gVGhpcyBpcyBlaXRoZXIgY2F1c2VkIGJ5IGEgYnJvd3NlciBidWcsIGEgY29tcGlsZXIgYnVnLCBvciBzb21lb25lXG4gICAgLy8gY2FsbGluZyB0aGUgaHRtbCB0ZW1wbGF0ZSB0YWcgZnVuY3Rpb24gYXMgYSByZWd1bGFyIGZ1bmN0aW9uLlxuICAgIC8vXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjYWxsIHRvIHRoZSBodG1sIHRlbXBsYXRlIHRhZycpO1xuICB9XG59O1xuXG4vKipcbiAqIEFuIGh0bWwgbGl0ZXJhbCB0YWcgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGBodG1sYCB0byBjb21wb3NlLlxuICogYSBsaXRlcmFsIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICogICAgICAgcmV0dXJuIGh0bWxgXG4gKiAgICAgICAgIDxzdHlsZT5cbiAqICAgICAgICAgICA6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9XG4gKiAgICAgICAgICAgJHt0aGlzLnN0eWxlVGVtcGxhdGUoKX1cbiAqICAgICAgICAgPC9zdHlsZT5cbiAqICAgICAgICAgPGRpdiBjbGFzcz1cInNoYWRvd2VkXCI+JHtzdGF0aWNWYWx1ZX08L2Rpdj5cbiAqICAgICAgICAgJHtzdXBlci50ZW1wbGF0ZX1cbiAqICAgICAgIGA7XG4gKiAgICAgfVxuICogICAgIHN0YXRpYyBnZXQgc3R5bGVUZW1wbGF0ZSgpIHtcbiAqICAgICAgICByZXR1cm4gaHRtbExpdGVyYWxgLnNoYWRvd2VkIHsgYmFja2dyb3VuZDogZ3JheTsgfWA7XG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7IUlUZW1wbGF0ZUFycmF5fSBzdHJpbmdzIENvbnN0YW50IHBhcnRzIG9mIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXG4gKiBAcGFyYW0gey4uLip9IHZhbHVlcyBWYXJpYWJsZSBwYXJ0cyBvZiB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbFxuICogQHJldHVybiB7IUxpdGVyYWxTdHJpbmd9IENvbnN0cnVjdGVkIGxpdGVyYWwgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBodG1sTGl0ZXJhbCA9IGZ1bmN0aW9uKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICByZXR1cm4gbmV3IExpdGVyYWxTdHJpbmcoc3RyaW5ncywgdmFsdWVzKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/html-tag.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dedupingMixin\": () => (/* binding */ dedupingMixin)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n// unique global id for deduping mixins.\nlet dedupeId = 0;\n\n/**\n * @constructor\n * @extends {Function}\n * @private\n */\nfunction MixinFunction() {}\n/** @type {(WeakMap | undefined)} */\nMixinFunction.prototype.__mixinApplications;\n/** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet;\n\n/* eslint-disable valid-jsdoc */\n/**\n * Wraps an ES6 class expression mixin such that the mixin is only applied\n * if it has not already been applied its base argument. Also memoizes mixin\n * applications.\n *\n * @template T\n * @param {T} mixin ES6 class expression mixin to wrap\n * @return {T}\n * @suppress {invalidCasts}\n */\nconst dedupingMixin = function (mixin) {\n  let mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap();\n    /** @type {!MixinFunction} */\n    mixin.__mixinApplications = mixinApplications;\n  }\n  // maintain a unique id for each mixin\n  let mixinDedupeId = dedupeId++;\n  function dedupingMixin(base) {\n    let baseSet = /** @type {!MixinFunction} */base.__mixinSet;\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n    let map = mixinApplications;\n    let extended = map.get(base);\n    if (!extended) {\n      extended = /** @type {!Function} */mixin(base);\n      map.set(base, extended);\n      // copy inherited mixin set from the extended class, or the base class\n      // NOTE: we avoid use of Set here because some browser (IE11)\n      // cannot extend a base Set via the constructor.\n      let mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);\n      mixinSet[mixinDedupeId] = true;\n      /** @type {!MixinFunction} */\n      extended.__mixinSet = mixinSet;\n    }\n    return extended;\n  }\n  return dedupingMixin;\n};\n/* eslint-enable valid-jsdoc *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanM/MDQ3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyB1bmlxdWUgZ2xvYmFsIGlkIGZvciBkZWR1cGluZyBtaXhpbnMuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTWl4aW5GdW5jdGlvbigpe31cbi8qKiBAdHlwZSB7KFdlYWtNYXAgfCB1bmRlZmluZWQpfSAqL1xuTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpbkFwcGxpY2F0aW9ucztcbi8qKiBAdHlwZSB7KE9iamVjdCB8IHVuZGVmaW5lZCl9ICovXG5NaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluU2V0O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuLyoqXG4gKiBXcmFwcyBhbiBFUzYgY2xhc3MgZXhwcmVzc2lvbiBtaXhpbiBzdWNoIHRoYXQgdGhlIG1peGluIGlzIG9ubHkgYXBwbGllZFxuICogaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gYXBwbGllZCBpdHMgYmFzZSBhcmd1bWVudC4gQWxzbyBtZW1vaXplcyBtaXhpblxuICogYXBwbGljYXRpb25zLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IG1peGluIEVTNiBjbGFzcyBleHByZXNzaW9uIG1peGluIHRvIHdyYXBcbiAqIEByZXR1cm4ge1R9XG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZHVwaW5nTWl4aW4gPSBmdW5jdGlvbihtaXhpbikge1xuICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgaWYgKCFtaXhpbkFwcGxpY2F0aW9ucykge1xuICAgIG1peGluQXBwbGljYXRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICB9XG4gIC8vIG1haW50YWluIGEgdW5pcXVlIGlkIGZvciBlYWNoIG1peGluXG4gIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgZnVuY3Rpb24gZGVkdXBpbmdNaXhpbihiYXNlKSB7XG4gICAgbGV0IGJhc2VTZXQgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhiYXNlKS5fX21peGluU2V0O1xuICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgbGV0IGV4dGVuZGVkID0gbWFwLmdldChiYXNlKTtcbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICBtYXAuc2V0KGJhc2UsIGV4dGVuZGVkKTtcbiAgICAgIC8vIGNvcHkgaW5oZXJpdGVkIG1peGluIHNldCBmcm9tIHRoZSBleHRlbmRlZCBjbGFzcywgb3IgdGhlIGJhc2UgY2xhc3NcbiAgICAgIC8vIE5PVEU6IHdlIGF2b2lkIHVzZSBvZiBTZXQgaGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlciAoSUUxMSlcbiAgICAgIC8vIGNhbm5vdCBleHRlbmQgYSBiYXNlIFNldCB2aWEgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgbGV0IG1peGluU2V0ID0gT2JqZWN0LmNyZWF0ZSgvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCB8fCBiYXNlU2V0IHx8IG51bGwpO1xuICAgICAgbWl4aW5TZXRbbWl4aW5EZWR1cGVJZF0gPSB0cnVlO1xuICAgICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oZXh0ZW5kZWQpLl9fbWl4aW5TZXQgPSBtaXhpblNldDtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xuICB9XG5cbiAgcmV0dXJuIGRlZHVwaW5nTWl4aW47XG59O1xuLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/path.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/path.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"get\": () => (/* binding */ get),\n/* harmony export */   \"isAncestor\": () => (/* binding */ isAncestor),\n/* harmony export */   \"isDeep\": () => (/* binding */ isDeep),\n/* harmony export */   \"isDescendant\": () => (/* binding */ isDescendant),\n/* harmony export */   \"isPath\": () => (/* binding */ isPath),\n/* harmony export */   \"matches\": () => (/* binding */ matches),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"root\": () => (/* binding */ root),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"split\": () => (/* binding */ split),\n/* harmony export */   \"translate\": () => (/* binding */ translate)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * Module with utilities for manipulating structured data path strings.\n *\n * @summary Module with utilities for manipulating structured data path strings.\n */\n\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * Example:\n *\n * ```\n * isPath('foo.bar.baz') // true\n * isPath('foo')         // false\n * ```\n *\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\nfunction isPath(path) {\n  return path.indexOf('.') >= 0;\n}\n\n/**\n * Returns the root property name for the given path.\n *\n * Example:\n *\n * ```\n * root('foo.bar.baz') // 'foo'\n * root('foo')         // 'foo'\n * ```\n *\n * @param {string} path Path string\n * @return {string} Root property name\n */\nfunction root(path) {\n  let dotIndex = path.indexOf('.');\n  if (dotIndex === -1) {\n    return path;\n  }\n  return path.slice(0, dotIndex);\n}\n\n/**\n * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n * Returns true if the given path is an ancestor of the base path.\n *\n * Example:\n *\n * ```\n * isAncestor('foo.bar', 'foo')         // true\n * isAncestor('foo.bar', 'foo.bar')     // false\n * isAncestor('foo.bar', 'foo.bar.baz') // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is an ancestor of `base`.\n */\nfunction isAncestor(base, path) {\n  //     base.startsWith(path + '.');\n  return base.indexOf(path + '.') === 0;\n}\n\n/**\n * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n *\n * Example:\n *\n * ```\n * isDescendant('foo.bar', 'foo.bar.baz') // true\n * isDescendant('foo.bar', 'foo.bar')     // false\n * isDescendant('foo.bar', 'foo')         // false\n * ```\n *\n * @param {string} base Path string to test against.\n * @param {string} path Path string to test.\n * @return {boolean} True if `path` is a descendant of `base`.\n */\nfunction isDescendant(base, path) {\n  //     path.startsWith(base + '.');\n  return path.indexOf(base + '.') === 0;\n}\n\n/**\n * Replaces a previous base path with a new base path, preserving the\n * remainder of the path.\n *\n * User must ensure `path` has a prefix of `base`.\n *\n * Example:\n *\n * ```\n * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'\n * ```\n *\n * @param {string} base Current base string to remove\n * @param {string} newBase New base string to replace with\n * @param {string} path Path to translate\n * @return {string} Translated string\n */\nfunction translate(base, newBase, path) {\n  return newBase + path.slice(base.length);\n}\n\n/**\n * @param {string} base Path string to test against\n * @param {string} path Path string to test\n * @return {boolean} True if `path` is equal to `base`\n */\nfunction matches(base, path) {\n  return base === path || isAncestor(base, path) || isDescendant(base, path);\n}\n\n/**\n * Converts array-based paths to flattened path.  String-based paths\n * are returned as-is.\n *\n * Example:\n *\n * ```\n * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {string} Flattened path\n */\nfunction normalize(path) {\n  if (Array.isArray(path)) {\n    let parts = [];\n    for (let i = 0; i < path.length; i++) {\n      let args = path[i].toString().split('.');\n      for (let j = 0; j < args.length; j++) {\n        parts.push(args[j]);\n      }\n    }\n    return parts.join('.');\n  } else {\n    return path;\n  }\n}\n\n/**\n * Splits a path into an array of property names. Accepts either arrays\n * of path parts or strings.\n *\n * Example:\n *\n * ```\n * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n * ```\n *\n * @param {string | !Array<string|number>} path Input path\n * @return {!Array<string>} Array of path parts\n * @suppress {checkTypes}\n */\nfunction split(path) {\n  if (Array.isArray(path)) {\n    return normalize(path).split('.');\n  }\n  return path.toString().split('.');\n}\n\n/**\n * Reads a value from a path.  If any sub-property in the path is `undefined`,\n * this method returns `undefined` (will never throw.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to read\n * @param {Object=} info If an object is provided to `info`, the normalized\n *  (flattened) path will be set to `info.path`.\n * @return {*} Value at path, or `undefined` if the path could not be\n *  fully dereferenced.\n */\nfunction get(root, path, info) {\n  let prop = root;\n  let parts = split(path);\n  // Loop over path parts[0..n-1] and dereference\n  for (let i = 0; i < parts.length; i++) {\n    if (!prop) {\n      return;\n    }\n    let part = parts[i];\n    prop = prop[part];\n  }\n  if (info) {\n    info.path = parts.join('.');\n  }\n  return prop;\n}\n\n/**\n * Sets a value to a path.  If any sub-property in the path is `undefined`,\n * this method will no-op.\n *\n * @param {Object} root Object from which to dereference path from\n * @param {string | !Array<string|number>} path Path to set\n * @param {*} value Value to set to path\n * @return {string | undefined} The normalized version of the input path\n */\nfunction set(root, path, value) {\n  let prop = root;\n  let parts = split(path);\n  let last = parts[parts.length - 1];\n  if (parts.length > 1) {\n    // Loop over path parts[0..n-2] and dereference\n    for (let i = 0; i < parts.length - 1; i++) {\n      let part = parts[i];\n      prop = prop[part];\n      if (!prop) {\n        return;\n      }\n    }\n    // Set value to object at end of path\n    prop[last] = value;\n  } else {\n    // Simple property set\n    prop[path] = value;\n  }\n  return parts.join('.');\n}\n\n/**\n * Returns true if the given string is a structured data path (has dots).\n *\n * This function is deprecated.  Use `isPath` instead.\n *\n * Example:\n *\n * ```\n * isDeep('foo.bar.baz') // true\n * isDeep('foo')         // false\n * ```\n *\n * @deprecated\n * @param {string} path Path string\n * @return {boolean} True if the string contained one or more dots\n */\nconst isDeep = isPath;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanM/ZmM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vKipcbiAqIE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIHN0cnVjdHVyZWQgZGF0YSBwYXRoIHN0cmluZ3MuXG4gKlxuICogQHN1bW1hcnkgTW9kdWxlIHdpdGggdXRpbGl0aWVzIGZvciBtYW5pcHVsYXRpbmcgc3RydWN0dXJlZCBkYXRhIHBhdGggc3RyaW5ncy5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgc3RydWN0dXJlZCBkYXRhIHBhdGggKGhhcyBkb3RzKS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogaXNQYXRoKCdmb28uYmFyLmJheicpIC8vIHRydWVcbiAqIGlzUGF0aCgnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBjb250YWluZWQgb25lIG9yIG1vcmUgZG90c1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZignLicpID49IDA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogcm9vdCgnZm9vLmJhci5iYXonKSAvLyAnZm9vJ1xuICogcm9vdCgnZm9vJykgICAgICAgICAvLyAnZm9vJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gUm9vdCBwcm9wZXJ0eSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb290KHBhdGgpIHtcbiAgbGV0IGRvdEluZGV4ID0gcGF0aC5pbmRleE9mKCcuJyk7XG4gIGlmIChkb3RJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBkb3RJbmRleCk7XG59XG5cbi8qKlxuICogR2l2ZW4gYGJhc2VgIGlzIGBmb28uYmFyYCwgYGZvb2AgaXMgYW4gYW5jZXN0b3IsIGBmb28uYmFyYCBpcyBub3RcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgYmFzZSBwYXRoLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiBpc0FuY2VzdG9yKCdmb28uYmFyJywgJ2ZvbycpICAgICAgICAgLy8gdHJ1ZVxuICogaXNBbmNlc3RvcignZm9vLmJhcicsICdmb28uYmFyJykgICAgIC8vIGZhbHNlXG4gKiBpc0FuY2VzdG9yKCdmb28uYmFyJywgJ2Zvby5iYXIuYmF6JykgLy8gZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFBhdGggc3RyaW5nIHRvIHRlc3QgYWdhaW5zdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBwYXRoYCBpcyBhbiBhbmNlc3RvciBvZiBgYmFzZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FuY2VzdG9yKGJhc2UsIHBhdGgpIHtcbiAgLy8gICAgIGJhc2Uuc3RhcnRzV2l0aChwYXRoICsgJy4nKTtcbiAgcmV0dXJuIGJhc2UuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBHaXZlbiBgYmFzZWAgaXMgYGZvby5iYXJgLCBgZm9vLmJhci5iYXpgIGlzIGFuIGRlc2NlbmRhbnRcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2Zvby5iYXIuYmF6JykgLy8gdHJ1ZVxuICogaXNEZXNjZW5kYW50KCdmb28uYmFyJywgJ2Zvby5iYXInKSAgICAgLy8gZmFsc2VcbiAqIGlzRGVzY2VuZGFudCgnZm9vLmJhcicsICdmb28nKSAgICAgICAgIC8vIGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZSBQYXRoIHN0cmluZyB0byB0ZXN0IGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHN0cmluZyB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgYSBkZXNjZW5kYW50IG9mIGBiYXNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVzY2VuZGFudChiYXNlLCBwYXRoKSB7XG4gIC8vICAgICBwYXRoLnN0YXJ0c1dpdGgoYmFzZSArICcuJyk7XG4gIHJldHVybiBwYXRoLmluZGV4T2YoYmFzZSArICcuJykgPT09IDA7XG59XG5cbi8qKlxuICogUmVwbGFjZXMgYSBwcmV2aW91cyBiYXNlIHBhdGggd2l0aCBhIG5ldyBiYXNlIHBhdGgsIHByZXNlcnZpbmcgdGhlXG4gKiByZW1haW5kZXIgb2YgdGhlIHBhdGguXG4gKlxuICogVXNlciBtdXN0IGVuc3VyZSBgcGF0aGAgaGFzIGEgcHJlZml4IG9mIGBiYXNlYC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogdHJhbnNsYXRlKCdmb28uYmFyJywgJ3pvdCcsICdmb28uYmFyLmJheicpIC8vICd6b3QuYmF6J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgQ3VycmVudCBiYXNlIHN0cmluZyB0byByZW1vdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdCYXNlIE5ldyBiYXNlIHN0cmluZyB0byByZXBsYWNlIHdpdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gdHJhbnNsYXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRyYW5zbGF0ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUoYmFzZSwgbmV3QmFzZSwgcGF0aCkge1xuICByZXR1cm4gbmV3QmFzZSArIHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIFBhdGggc3RyaW5nIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBzdHJpbmcgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgcGF0aGAgaXMgZXF1YWwgdG8gYGJhc2VgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGJhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIChiYXNlID09PSBwYXRoKSB8fFxuICAgICAgICAgaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB8fFxuICAgICAgICAgaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFycmF5LWJhc2VkIHBhdGhzIHRvIGZsYXR0ZW5lZCBwYXRoLiAgU3RyaW5nLWJhc2VkIHBhdGhzXG4gKiBhcmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIG5vcm1hbGl6ZShbJ2Zvby5iYXInLCAwLCAnYmF6J10pICAvLyAnZm9vLmJhci4wLmJheidcbiAqIG5vcm1hbGl6ZSgnZm9vLmJhci4wLmJheicpICAgICAgICAvLyAnZm9vLmJhci4wLmJheidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIElucHV0IHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gRmxhdHRlbmVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgbGV0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBhcmdzID0gcGF0aFtpXS50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICBmb3IgKGxldCBqPTA7IGo8YXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFyZ3Nbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignLicpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG5cbi8qKlxuICogU3BsaXRzIGEgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLiBBY2NlcHRzIGVpdGhlciBhcnJheXNcbiAqIG9mIHBhdGggcGFydHMgb3Igc3RyaW5ncy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogc3BsaXQoWydmb28uYmFyJywgMCwgJ2JheiddKSAgLy8gWydmb28nLCAnYmFyJywgJzAnLCAnYmF6J11cbiAqIHNwbGl0KCdmb28uYmFyLjAuYmF6JykgICAgICAgIC8vIFsnZm9vJywgJ2JhcicsICcwJywgJ2JheiddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBJbnB1dCBwYXRoXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgcGF0aCBwYXJ0c1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXQocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemUocGF0aCkuc3BsaXQoJy4nKTtcbiAgfVxuICByZXR1cm4gcGF0aC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG59XG5cbi8qKlxuICogUmVhZHMgYSB2YWx1ZSBmcm9tIGEgcGF0aC4gIElmIGFueSBzdWItcHJvcGVydHkgaW4gdGhlIHBhdGggaXMgYHVuZGVmaW5lZGAsXG4gKiB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgICh3aWxsIG5ldmVyIHRocm93LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByb290IE9iamVjdCBmcm9tIHdoaWNoIHRvIGRlcmVmZXJlbmNlIHBhdGggZnJvbVxuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byByZWFkXG4gKiBAcGFyYW0ge09iamVjdD19IGluZm8gSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIHRvIGBpbmZvYCwgdGhlIG5vcm1hbGl6ZWRcbiAqICAoZmxhdHRlbmVkKSBwYXRoIHdpbGwgYmUgc2V0IHRvIGBpbmZvLnBhdGhgLlxuICogQHJldHVybiB7Kn0gVmFsdWUgYXQgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHBhdGggY291bGQgbm90IGJlXG4gKiAgZnVsbHkgZGVyZWZlcmVuY2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHJvb3QsIHBhdGgsIGluZm8pIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0xXSBhbmQgZGVyZWZlcmVuY2VcbiAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgcHJvcCA9IHByb3BbcGFydF07XG4gIH1cbiAgaWYgKGluZm8pIHtcbiAgICBpbmZvLnBhdGggPSBwYXJ0cy5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59XG5cbi8qKlxuICogU2V0cyBhIHZhbHVlIHRvIGEgcGF0aC4gIElmIGFueSBzdWItcHJvcGVydHkgaW4gdGhlIHBhdGggaXMgYHVuZGVmaW5lZGAsXG4gKiB0aGlzIG1ldGhvZCB3aWxsIG5vLW9wLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByb290IE9iamVjdCBmcm9tIHdoaWNoIHRvIGRlcmVmZXJlbmNlIHBhdGggZnJvbVxuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IHRvIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQgcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHJvb3QsIHBhdGgsIHZhbHVlKSB7XG4gIGxldCBwcm9wID0gcm9vdDtcbiAgbGV0IHBhcnRzID0gc3BsaXQocGF0aCk7XG4gIGxldCBsYXN0ID0gcGFydHNbcGFydHMubGVuZ3RoLTFdO1xuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgIC8vIExvb3Agb3ZlciBwYXRoIHBhcnRzWzAuLm4tMl0gYW5kIGRlcmVmZXJlbmNlXG4gICAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgICAgIGlmICghcHJvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFNldCB2YWx1ZSB0byBvYmplY3QgYXQgZW5kIG9mIHBhdGhcbiAgICBwcm9wW2xhc3RdID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2ltcGxlIHByb3BlcnR5IHNldFxuICAgIHByb3BbcGF0aF0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcGFydHMuam9pbignLicpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgc3RydWN0dXJlZCBkYXRhIHBhdGggKGhhcyBkb3RzKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuICBVc2UgYGlzUGF0aGAgaW5zdGVhZC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICogaXNEZWVwKCdmb28uYmFyLmJheicpIC8vIHRydWVcbiAqIGlzRGVlcCgnZm9vJykgICAgICAgICAvLyBmYWxzZVxuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggc3RyaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgY29udGFpbmVkIG9uZSBvciBtb3JlIGRvdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRGVlcCA9IGlzUGF0aDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/path.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/render-status.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/render-status.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"afterNextRender\": () => (/* binding */ afterNextRender),\n/* harmony export */   \"beforeNextRender\": () => (/* binding */ beforeNextRender),\n/* harmony export */   \"flush\": () => (/* binding */ flush)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module for scheduling flushable pre-render and post-render tasks.\n *\n * @summary Module for scheduling flushable pre-render and post-render tasks.\n */\n\n\nlet scheduled = false;\nlet beforeRenderQueue = [];\nlet afterRenderQueue = [];\nfunction schedule() {\n  scheduled = true;\n  // before next render\n  requestAnimationFrame(function () {\n    scheduled = false;\n    flushQueue(beforeRenderQueue);\n    // after the render\n    setTimeout(function () {\n      runQueue(afterRenderQueue);\n    });\n  });\n}\nfunction flushQueue(queue) {\n  while (queue.length) {\n    callMethod(queue.shift());\n  }\n}\nfunction runQueue(queue) {\n  for (let i = 0, l = queue.length; i < l; i++) {\n    callMethod(queue.shift());\n  }\n}\nfunction callMethod(info) {\n  const context = info[0];\n  const callback = info[1];\n  const args = info[2];\n  try {\n    callback.apply(context, args);\n  } catch (e) {\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\n/**\n * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`\n * tasks.\n *\n * @return {void}\n */\nfunction flush() {\n  while (beforeRenderQueue.length || afterRenderQueue.length) {\n    flushQueue(beforeRenderQueue);\n    flushQueue(afterRenderQueue);\n  }\n  scheduled = false;\n}\n\n/**\n * Enqueues a callback which will be run before the next render, at\n * `requestAnimationFrame` timing.\n *\n * This method is useful for enqueuing work that requires DOM measurement,\n * since measurement may not be reliable in custom element callbacks before\n * the first render, as well as for batching measurement tasks in general.\n *\n * Tasks in this queue may be flushed by calling `flush()`.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\nfunction beforeNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n  beforeRenderQueue.push([context, callback, args]);\n}\n\n/**\n * Enqueues a callback which will be run after the next render, equivalent\n * to one task (`setTimeout`) after the next `requestAnimationFrame`.\n *\n * This method is useful for tuning the first-render performance of an\n * element or application by deferring non-critical work until after the\n * first paint.  Typical non-render-critical work may include adding UI\n * event listeners and aria attributes.\n *\n * @param {*} context Context object the callback function will be bound to\n * @param {function(...*):void} callback Callback function\n * @param {!Array=} args An array of arguments to call the callback function with\n * @return {void}\n */\nfunction afterNextRender(context, callback, args) {\n  if (!scheduled) {\n    schedule();\n  }\n  afterRenderQueue.push([context, callback, args]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanM/NTdkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4vKipcbiAqIE1vZHVsZSBmb3Igc2NoZWR1bGluZyBmbHVzaGFibGUgcHJlLXJlbmRlciBhbmQgcG9zdC1yZW5kZXIgdGFza3MuXG4gKlxuICogQHN1bW1hcnkgTW9kdWxlIGZvciBzY2hlZHVsaW5nIGZsdXNoYWJsZSBwcmUtcmVuZGVyIGFuZCBwb3N0LXJlbmRlciB0YXNrcy5cbiAqL1xuXG5pbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBzY2hlZHVsZWQgPSBmYWxzZTtcbmxldCBiZWZvcmVSZW5kZXJRdWV1ZSA9IFtdO1xubGV0IGFmdGVyUmVuZGVyUXVldWUgPSBbXTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gIHNjaGVkdWxlZCA9IHRydWU7XG4gIC8vIGJlZm9yZSBuZXh0IHJlbmRlclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgLy8gYWZ0ZXIgdGhlIHJlbmRlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBydW5RdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUXVldWUocXVldWUpIHtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuUXVldWUocXVldWUpIHtcbiAgZm9yIChsZXQgaT0wLCBsPXF1ZXVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbE1ldGhvZChpbmZvKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBpbmZvWzBdO1xuICBjb25zdCBjYWxsYmFjayA9IGluZm9bMV07XG4gIGNvbnN0IGFyZ3MgPSBpbmZvWzJdO1xuICB0cnkge1xuICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGbHVzaGVzIGFsbCBgYmVmb3JlTmV4dFJlbmRlcmAgdGFza3MsIGZvbGxvd2VkIGJ5IGFsbCBgYWZ0ZXJOZXh0UmVuZGVyYFxuICogdGFza3MuXG4gKlxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoKCkge1xuICB3aGlsZSAoYmVmb3JlUmVuZGVyUXVldWUubGVuZ3RoIHx8IGFmdGVyUmVuZGVyUXVldWUubGVuZ3RoKSB7XG4gICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgZmx1c2hRdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgfVxuICBzY2hlZHVsZWQgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEVucXVldWVzIGEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBydW4gYmVmb3JlIHRoZSBuZXh0IHJlbmRlciwgYXRcbiAqIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRpbWluZy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIGVucXVldWluZyB3b3JrIHRoYXQgcmVxdWlyZXMgRE9NIG1lYXN1cmVtZW50LFxuICogc2luY2UgbWVhc3VyZW1lbnQgbWF5IG5vdCBiZSByZWxpYWJsZSBpbiBjdXN0b20gZWxlbWVudCBjYWxsYmFja3MgYmVmb3JlXG4gKiB0aGUgZmlyc3QgcmVuZGVyLCBhcyB3ZWxsIGFzIGZvciBiYXRjaGluZyBtZWFzdXJlbWVudCB0YXNrcyBpbiBnZW5lcmFsLlxuICpcbiAqIFRhc2tzIGluIHRoaXMgcXVldWUgbWF5IGJlIGZsdXNoZWQgYnkgY2FsbGluZyBgZmx1c2goKWAuXG4gKlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgb2JqZWN0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGJvdW5kIHRvXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopOnZvaWR9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFBcnJheT19IGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGhcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVOZXh0UmVuZGVyKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gIGlmICghc2NoZWR1bGVkKSB7XG4gICAgc2NoZWR1bGUoKTtcbiAgfVxuICBiZWZvcmVSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIGEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBydW4gYWZ0ZXIgdGhlIG5leHQgcmVuZGVyLCBlcXVpdmFsZW50XG4gKiB0byBvbmUgdGFzayAoYHNldFRpbWVvdXRgKSBhZnRlciB0aGUgbmV4dCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIHR1bmluZyB0aGUgZmlyc3QtcmVuZGVyIHBlcmZvcm1hbmNlIG9mIGFuXG4gKiBlbGVtZW50IG9yIGFwcGxpY2F0aW9uIGJ5IGRlZmVycmluZyBub24tY3JpdGljYWwgd29yayB1bnRpbCBhZnRlciB0aGVcbiAqIGZpcnN0IHBhaW50LiAgVHlwaWNhbCBub24tcmVuZGVyLWNyaXRpY2FsIHdvcmsgbWF5IGluY2x1ZGUgYWRkaW5nIFVJXG4gKiBldmVudCBsaXN0ZW5lcnMgYW5kIGFyaWEgYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBvYmplY3QgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgYm91bmQgdG9cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uKik6dm9pZH0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUFycmF5PX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gY2FsbCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYWZ0ZXJSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/render-status.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/resolve-url.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/resolve-url.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pathFromUrl\": () => (/* binding */ pathFromUrl),\n/* harmony export */   \"resolveCss\": () => (/* binding */ resolveCss),\n/* harmony export */   \"resolveUrl\": () => (/* binding */ resolveUrl)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nlet CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nlet ABS_URL = /(^\\/[^\\/])|(^#)|(^[\\w-\\d]*:)/;\nlet workingURL;\nlet resolveDoc;\n/**\n * Resolves the given URL against the provided `baseUri'.\n *\n * Note that this function performs no resolution for URLs that start\n * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n * URL resolution, use `window.URL`.\n *\n * @param {string} url Input URL to resolve\n * @param {?string=} baseURI Base URI to resolve the URL against\n * @return {string} resolved URL\n */\nfunction resolveUrl(url, baseURI) {\n  if (url && ABS_URL.test(url)) {\n    return url;\n  }\n  if (url === '//') {\n    return url;\n  }\n  // Lazy feature detection.\n  if (workingURL === undefined) {\n    workingURL = false;\n    try {\n      const u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = u.href === 'http://a/c%20d';\n    } catch (e) {\n      // silently fail\n    }\n  }\n  if (!baseURI) {\n    baseURI = document.baseURI || window.location.href;\n  }\n  if (workingURL) {\n    try {\n      return new URL(url, baseURI).href;\n    } catch (e) {\n      // Bad url or baseURI structure. Do not attempt to resolve.\n      return url;\n    }\n  }\n  // Fallback to creating an anchor into a disconnected document.\n  if (!resolveDoc) {\n    resolveDoc = document.implementation.createHTMLDocument('temp');\n    resolveDoc.base = resolveDoc.createElement('base');\n    resolveDoc.head.appendChild(resolveDoc.base);\n    resolveDoc.anchor = resolveDoc.createElement('a');\n    resolveDoc.body.appendChild(resolveDoc.anchor);\n  }\n  resolveDoc.base.href = baseURI;\n  resolveDoc.anchor.href = url;\n  return resolveDoc.anchor.href || url;\n}\n\n/**\n * Resolves any relative URL's in the given CSS text against the provided\n * `ownerDocument`'s `baseURI`.\n *\n * @param {string} cssText CSS text to process\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Processed CSS text with resolved URL's\n */\nfunction resolveCss(cssText, baseURI) {\n  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\n    return pre + '\\'' + resolveUrl(url.replace(/[\"']/g, ''), baseURI) + '\\'' + post;\n  });\n}\n\n/**\n * Returns a path from a given `url`. The path includes the trailing\n * `/` from the url.\n *\n * @param {string} url Input URL to transform\n * @return {string} resolved path\n */\nfunction pathFromUrl(url) {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3Jlc29sdmUtdXJsLmpzPzFkNzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnLi9ib290LmpzJztcblxubGV0IENTU19VUkxfUlggPSAvKHVybFxcKCkoW14pXSopKFxcKSkvZztcbmxldCBBQlNfVVJMID0gLyheXFwvW15cXC9dKXwoXiMpfCheW1xcdy1cXGRdKjopLztcbmxldCB3b3JraW5nVVJMO1xubGV0IHJlc29sdmVEb2M7XG4vKipcbiAqIFJlc29sdmVzIHRoZSBnaXZlbiBVUkwgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYGJhc2VVcmknLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHBlcmZvcm1zIG5vIHJlc29sdXRpb24gZm9yIFVSTHMgdGhhdCBzdGFydFxuICogd2l0aCBgL2AgKGFic29sdXRlIFVSTHMpIG9yIGAjYCAoaGFzaCBpZGVudGlmaWVycykuICBGb3IgZ2VuZXJhbCBwdXJwb3NlXG4gKiBVUkwgcmVzb2x1dGlvbiwgdXNlIGB3aW5kb3cuVVJMYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byByZXNvbHZlXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIFVSTFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVVybCh1cmwsIGJhc2VVUkkpIHtcbiAgaWYgKHVybCAmJiBBQlNfVVJMLnRlc3QodXJsKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgaWYgKHVybCA9PT0gJy8vJykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgLy8gTGF6eSBmZWF0dXJlIGRldGVjdGlvbi5cbiAgaWYgKHdvcmtpbmdVUkwgPT09IHVuZGVmaW5lZCkge1xuICAgIHdvcmtpbmdVUkwgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdSA9IG5ldyBVUkwoJ2InLCAnaHR0cDovL2EnKTtcbiAgICAgIHUucGF0aG5hbWUgPSAnYyUyMGQnO1xuICAgICAgd29ya2luZ1VSTCA9ICh1LmhyZWYgPT09ICdodHRwOi8vYS9jJTIwZCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGZhaWxcbiAgICB9XG4gIH1cbiAgaWYgKCFiYXNlVVJJKSB7XG4gICAgYmFzZVVSSSA9IGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIH1cbiAgaWYgKHdvcmtpbmdVUkwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChuZXcgVVJMKHVybCwgYmFzZVVSSSkpLmhyZWY7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gQmFkIHVybCBvciBiYXNlVVJJIHN0cnVjdHVyZS4gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZS5cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICB9XG4gIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICBpZiAoIXJlc29sdmVEb2MpIHtcbiAgICByZXNvbHZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd0ZW1wJyk7XG4gICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgcmVzb2x2ZURvYy5oZWFkLmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYmFzZSk7XG4gICAgcmVzb2x2ZURvYy5hbmNob3IgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICB9XG4gIHJlc29sdmVEb2MuYmFzZS5ocmVmID0gYmFzZVVSSTtcbiAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgcmV0dXJuIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgfHwgdXJsO1xuXG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYW55IHJlbGF0aXZlIFVSTCdzIGluIHRoZSBnaXZlbiBDU1MgdGV4dCBhZ2FpbnN0IHRoZSBwcm92aWRlZFxuICogYG93bmVyRG9jdW1lbnRgJ3MgYGJhc2VVUklgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0IENTUyB0ZXh0IHRvIHByb2Nlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1MgdGV4dCB3aXRoIHJlc29sdmVkIFVSTCdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ3NzKGNzc1RleHQsIGJhc2VVUkkpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShDU1NfVVJMX1JYLCBmdW5jdGlvbihtLCBwcmUsIHVybCwgcG9zdCkge1xuICAgIHJldHVybiBwcmUgKyAnXFwnJyArXG4gICAgICByZXNvbHZlVXJsKHVybC5yZXBsYWNlKC9bXCInXS9nLCAnJyksIGJhc2VVUkkpICtcbiAgICAgICdcXCcnICsgcG9zdDtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGggZnJvbSBhIGdpdmVuIGB1cmxgLiBUaGUgcGF0aCBpbmNsdWRlcyB0aGUgdHJhaWxpbmdcbiAqIGAvYCBmcm9tIHRoZSB1cmwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBJbnB1dCBVUkwgdG8gdHJhbnNmb3JtXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGhGcm9tVXJsKHVybCkge1xuICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/resolve-url.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/settings.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/settings.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"allowTemplateFromDomModule\": () => (/* binding */ allowTemplateFromDomModule),\n/* harmony export */   \"cancelSyntheticClickEvents\": () => (/* binding */ cancelSyntheticClickEvents),\n/* harmony export */   \"fastDomIf\": () => (/* binding */ fastDomIf),\n/* harmony export */   \"getSanitizeDOMValue\": () => (/* binding */ getSanitizeDOMValue),\n/* harmony export */   \"legacyNoObservedAttributes\": () => (/* binding */ legacyNoObservedAttributes),\n/* harmony export */   \"legacyOptimizations\": () => (/* binding */ legacyOptimizations),\n/* harmony export */   \"legacyUndefined\": () => (/* binding */ legacyUndefined),\n/* harmony export */   \"legacyWarnings\": () => (/* binding */ legacyWarnings),\n/* harmony export */   \"orderedComputed\": () => (/* binding */ orderedComputed),\n/* harmony export */   \"passiveTouchGestures\": () => (/* binding */ passiveTouchGestures),\n/* harmony export */   \"removeNestedTemplates\": () => (/* binding */ removeNestedTemplates),\n/* harmony export */   \"rootPath\": () => (/* binding */ rootPath),\n/* harmony export */   \"sanitizeDOMValue\": () => (/* binding */ sanitizeDOMValue),\n/* harmony export */   \"setAllowTemplateFromDomModule\": () => (/* binding */ setAllowTemplateFromDomModule),\n/* harmony export */   \"setCancelSyntheticClickEvents\": () => (/* binding */ setCancelSyntheticClickEvents),\n/* harmony export */   \"setFastDomIf\": () => (/* binding */ setFastDomIf),\n/* harmony export */   \"setLegacyNoObservedAttributes\": () => (/* binding */ setLegacyNoObservedAttributes),\n/* harmony export */   \"setLegacyOptimizations\": () => (/* binding */ setLegacyOptimizations),\n/* harmony export */   \"setLegacyUndefined\": () => (/* binding */ setLegacyUndefined),\n/* harmony export */   \"setLegacyWarnings\": () => (/* binding */ setLegacyWarnings),\n/* harmony export */   \"setOrderedComputed\": () => (/* binding */ setOrderedComputed),\n/* harmony export */   \"setPassiveTouchGestures\": () => (/* binding */ setPassiveTouchGestures),\n/* harmony export */   \"setRemoveNestedTemplates\": () => (/* binding */ setRemoveNestedTemplates),\n/* harmony export */   \"setRootPath\": () => (/* binding */ setRootPath),\n/* harmony export */   \"setSanitizeDOMValue\": () => (/* binding */ setSanitizeDOMValue),\n/* harmony export */   \"setStrictTemplatePolicy\": () => (/* binding */ setStrictTemplatePolicy),\n/* harmony export */   \"setSuppressTemplateNotifications\": () => (/* binding */ setSuppressTemplateNotifications),\n/* harmony export */   \"setSyncInitialRender\": () => (/* binding */ setSyncInitialRender),\n/* harmony export */   \"setUseAdoptedStyleSheetsWithBuiltCSS\": () => (/* binding */ setUseAdoptedStyleSheetsWithBuiltCSS),\n/* harmony export */   \"strictTemplatePolicy\": () => (/* binding */ strictTemplatePolicy),\n/* harmony export */   \"supportsAdoptingStyleSheets\": () => (/* binding */ supportsAdoptingStyleSheets),\n/* harmony export */   \"suppressTemplateNotifications\": () => (/* binding */ suppressTemplateNotifications),\n/* harmony export */   \"syncInitialRender\": () => (/* binding */ syncInitialRender),\n/* harmony export */   \"useAdoptedStyleSheetsWithBuiltCSS\": () => (/* binding */ useAdoptedStyleSheetsWithBuiltCSS),\n/* harmony export */   \"useNativeCSSProperties\": () => (/* binding */ useNativeCSSProperties),\n/* harmony export */   \"useNativeCustomElements\": () => (/* binding */ useNativeCustomElements),\n/* harmony export */   \"useShadow\": () => (/* binding */ useShadow)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nconst useShadow = !window.ShadyDOM || !window.ShadyDOM.inUse;\nconst useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\nconst useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;\nconst supportsAdoptingStyleSheets = useShadow && 'adoptedStyleSheets' in Document.prototype && 'replaceSync' in CSSStyleSheet.prototype &&\n// Since spec may change, feature detect exact API we need\n(() => {\n  try {\n    const sheet = new CSSStyleSheet();\n    sheet.replaceSync('');\n    const host = document.createElement('div');\n    host.attachShadow({\n      mode: 'open'\n    });\n    host.shadowRoot.adoptedStyleSheets = [sheet];\n    return host.shadowRoot.adoptedStyleSheets[0] === sheet;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/**\n * Globally settable property that is automatically assigned to\n * `ElementMixin` instances, useful for binding in templates to\n * make URL's relative to an application's root.  Defaults to the main\n * document URL, but can be overridden by users.  It may be useful to set\n * `rootPath` to provide a stable application mount path when\n * using client side routing.\n */\nlet rootPath = window.Polymer && window.Polymer.rootPath || (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.pathFromUrl)(document.baseURI || window.location.href);\n\n/**\n * Sets the global rootPath property used by `ElementMixin` and\n * available via `rootPath`.\n *\n * @param {string} path The new root path\n * @return {void}\n */\nconst setRootPath = function (path) {\n  rootPath = path;\n};\n\n/**\n * A global callback used to sanitize any value before inserting it into the DOM.\n * The callback signature is:\n *\n *  function sanitizeDOMValue(value, name, type, node) { ... }\n *\n * Where:\n *\n * `value` is the value to sanitize.\n * `name` is the name of an attribute or property (for example, href).\n * `type` indicates where the value is being inserted: one of property, attribute, or text.\n * `node` is the node where the value is being inserted.\n *\n * @type {(function(*,string,string,?Node):*)|undefined}\n */\nlet sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || undefined;\n\n/**\n * Sets the global sanitizeDOMValue available via this module's exported\n * `sanitizeDOMValue` variable.\n *\n * @param {(function(*,string,string,?Node):*)|undefined} newSanitizeDOMValue the global sanitizeDOMValue callback\n * @return {void}\n */\nconst setSanitizeDOMValue = function (newSanitizeDOMValue) {\n  sanitizeDOMValue = newSanitizeDOMValue;\n};\n\n/**\n * Gets sanitizeDOMValue, for environments that don't well support `export let`.\n *\n * @return {(function(*,string,string,?Node):*)|undefined} sanitizeDOMValue\n */\nconst getSanitizeDOMValue = function () {\n  return sanitizeDOMValue;\n};\n\n/**\n * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.\n * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother\n * scrolling performance.\n * Defaults to `false` for backwards compatibility.\n */\nlet passiveTouchGestures = window.Polymer && window.Polymer.setPassiveTouchGestures || false;\n\n/**\n * Sets `passiveTouchGestures` globally for all elements using Polymer Gestures.\n *\n * @param {boolean} usePassive enable or disable passive touch gestures globally\n * @return {void}\n */\nconst setPassiveTouchGestures = function (usePassive) {\n  passiveTouchGestures = usePassive;\n};\n\n/**\n * Setting to ensure Polymer template evaluation only occurs based on tempates\n * defined in trusted script.  When true, `<dom-module>` re-registration is\n * disallowed, `<dom-bind>` is disabled, and `<dom-if>`/`<dom-repeat>`\n * templates will only evaluate in the context of a trusted element template.\n */\nlet strictTemplatePolicy = window.Polymer && window.Polymer.strictTemplatePolicy || false;\n\n/**\n * Sets `strictTemplatePolicy` globally for all elements\n *\n * @param {boolean} useStrictPolicy enable or disable strict template policy\n *   globally\n * @return {void}\n */\nconst setStrictTemplatePolicy = function (useStrictPolicy) {\n  strictTemplatePolicy = useStrictPolicy;\n};\n\n/**\n * Setting to enable dom-module lookup from Polymer.Element.  By default,\n * templates must be defined in script using the `static get template()`\n * getter and the `html` tag function.  To enable legacy loading of templates\n * via dom-module, set this flag to true.\n */\nlet allowTemplateFromDomModule = window.Polymer && window.Polymer.allowTemplateFromDomModule || false;\n\n/**\n * Sets `lookupTemplateFromDomModule` globally for all elements\n *\n * @param {boolean} allowDomModule enable or disable template lookup\n *   globally\n * @return {void}\n */\nconst setAllowTemplateFromDomModule = function (allowDomModule) {\n  allowTemplateFromDomModule = allowDomModule;\n};\n\n/**\n * Setting to skip processing style includes and re-writing urls in css styles.\n * Normally \"included\" styles are pulled into the element and all urls in styles\n * are re-written to be relative to the containing script url.\n * If no includes or relative urls are used in styles, these steps can be\n * skipped as an optimization.\n */\nlet legacyOptimizations = window.Polymer && window.Polymer.legacyOptimizations || false;\n\n/**\n * Sets `legacyOptimizations` globally for all elements to enable optimizations\n * when only legacy based elements are used.\n *\n * @param {boolean} useLegacyOptimizations enable or disable legacy optimizations\n * includes and url rewriting\n * @return {void}\n */\nconst setLegacyOptimizations = function (useLegacyOptimizations) {\n  legacyOptimizations = useLegacyOptimizations;\n};\n\n/**\n * Setting to add warnings useful when migrating from Polymer 1.x to 2.x.\n */\nlet legacyWarnings = window.Polymer && window.Polymer.legacyWarnings || false;\n\n/**\n * Sets `legacyWarnings` globally for all elements to migration warnings.\n *\n * @param {boolean} useLegacyWarnings enable or disable warnings\n * @return {void}\n */\nconst setLegacyWarnings = function (useLegacyWarnings) {\n  legacyWarnings = useLegacyWarnings;\n};\n\n/**\n * Setting to perform initial rendering synchronously when running under ShadyDOM.\n * This matches the behavior of Polymer 1.\n */\nlet syncInitialRender = window.Polymer && window.Polymer.syncInitialRender || false;\n\n/**\n * Sets `syncInitialRender` globally for all elements to enable synchronous\n * initial rendering.\n *\n * @param {boolean} useSyncInitialRender enable or disable synchronous initial\n * rendering globally.\n * @return {void}\n */\nconst setSyncInitialRender = function (useSyncInitialRender) {\n  syncInitialRender = useSyncInitialRender;\n};\n\n/**\n * Setting to retain the legacy Polymer 1 behavior for multi-property\n * observers around undefined values. Observers and computed property methods\n * are not called until no argument is undefined.\n */\nlet legacyUndefined = window.Polymer && window.Polymer.legacyUndefined || false;\n\n/**\n * Sets `legacyUndefined` globally for all elements to enable legacy\n * multi-property behavior for undefined values.\n *\n * @param {boolean} useLegacyUndefined enable or disable legacy\n * multi-property behavior for undefined.\n * @return {void}\n */\nconst setLegacyUndefined = function (useLegacyUndefined) {\n  legacyUndefined = useLegacyUndefined;\n};\n\n/**\n * Setting to ensure computed properties are computed in order to ensure\n * re-computation never occurs in a given turn.\n */\nlet orderedComputed = window.Polymer && window.Polymer.orderedComputed || false;\n\n/**\n * Sets `orderedComputed` globally for all elements to enable ordered computed\n * property computation.\n *\n * @param {boolean} useOrderedComputed enable or disable ordered computed effects\n * @return {void}\n */\nconst setOrderedComputed = function (useOrderedComputed) {\n  orderedComputed = useOrderedComputed;\n};\n\n/**\n * Setting to cancel synthetic click events fired by older mobile browsers. Modern browsers\n * no longer fire synthetic click events, and the cancellation behavior can interfere\n * when programmatically clicking on elements.\n */\nlet cancelSyntheticClickEvents = true;\n\n/**\n * Sets `setCancelSyntheticEvents` globally for all elements to cancel synthetic click events.\n *\n * @param {boolean} useCancelSyntheticClickEvents enable or disable cancelling synthetic\n * events\n * @return {void}\n */\nconst setCancelSyntheticClickEvents = function (useCancelSyntheticClickEvents) {\n  cancelSyntheticClickEvents = useCancelSyntheticClickEvents;\n};\n\n/**\n * Setting to remove nested templates inside `dom-if` and `dom-repeat` as\n * part of element template parsing.  This is a performance optimization that\n * eliminates most of the tax of needing two elements due to the loss of\n * type-extended templates as a result of the V1 specification changes.\n */\nlet removeNestedTemplates = window.Polymer && window.Polymer.removeNestedTemplates || false;\n\n/**\n * Sets `removeNestedTemplates` globally, to eliminate nested templates\n * inside `dom-if` and `dom-repeat` as part of template parsing.\n *\n * @param {boolean} useRemoveNestedTemplates enable or disable removing nested\n *   templates during parsing\n * @return {void}\n */\nconst setRemoveNestedTemplates = function (useRemoveNestedTemplates) {\n  removeNestedTemplates = useRemoveNestedTemplates;\n};\n\n/**\n * Setting to place `dom-if` elements in a performance-optimized mode that takes\n * advantage of lighter-weight host runtime template stamping to eliminate the\n * need for an intermediate Templatizer `TemplateInstance` to mange the nodes\n * stamped by `dom-if`.  Under this setting, any Templatizer-provided API's\n * such as `modelForElement` will not be available for nodes stamped by\n * `dom-if`.\n */\nlet fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;\n\n/**\n * Sets `fastDomIf` globally, to put `dom-if` in a performance-optimized mode.\n *\n * @param {boolean} useFastDomIf enable or disable `dom-if` fast-mode\n * @return {void}\n */\nconst setFastDomIf = function (useFastDomIf) {\n  fastDomIf = useFastDomIf;\n};\n\n/**\n * Setting to disable `dom-change` and `rendered-item-count` events from\n * `dom-if` and `dom-repeat`. Users can opt back into `dom-change` events by\n * setting the `notify-dom-change` attribute (`notifyDomChange: true` property)\n * to `dom-if`/`don-repeat` instances.\n */\nlet suppressTemplateNotifications = window.Polymer && window.Polymer.suppressTemplateNotifications || false;\n\n/**\n * Sets `suppressTemplateNotifications` globally, to disable `dom-change` and\n * `rendered-item-count` events from `dom-if` and `dom-repeat`.\n *\n * @param {boolean} suppress enable or disable `suppressTemplateNotifications`\n * @return {void}\n */\nconst setSuppressTemplateNotifications = function (suppress) {\n  suppressTemplateNotifications = suppress;\n};\n\n/**\n * Setting to disable use of dynamic attributes. This is an optimization\n * to avoid setting `observedAttributes`. Instead attributes are read\n * once at create time and set/removeAttribute are patched.\n */\nlet legacyNoObservedAttributes = window.Polymer && window.Polymer.legacyNoObservedAttributes || false;\n\n/**\n * Sets `legacyNoObservedAttributes` globally, to disable `observedAttributes`.\n *\n * @param {boolean} noObservedAttributes enable or disable `legacyNoObservedAttributes`\n * @return {void}\n */\nconst setLegacyNoObservedAttributes = function (noObservedAttributes) {\n  legacyNoObservedAttributes = noObservedAttributes;\n};\n\n/**\n * Setting to enable use of `adoptedStyleSheets` for sharing style sheets\n * between component instances' shadow roots, if the app uses built Shady CSS\n * styles.\n */\nlet useAdoptedStyleSheetsWithBuiltCSS = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;\n\n/**\n * Sets `useAdoptedStyleSheetsWithBuiltCSS` globally.\n *\n * @param {boolean} value enable or disable `useAdoptedStyleSheetsWithBuiltCSS`\n * @return {void}\n */\nconst setUseAdoptedStyleSheetsWithBuiltCSS = function (value) {\n  useAdoptedStyleSheetsWithBuiltCSS = value;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuanM/MTRkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgcGF0aEZyb21VcmwgfSBmcm9tICcuL3Jlc29sdmUtdXJsLmpzJztcbmV4cG9ydCBjb25zdCB1c2VTaGFkb3cgPSAhKHdpbmRvdy5TaGFkeURPTSkgfHwgISh3aW5kb3cuU2hhZHlET00uaW5Vc2UpO1xuZXhwb3J0IGNvbnN0IHVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMgPSBCb29sZWFuKCF3aW5kb3cuU2hhZHlDU1MgfHwgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyk7XG5leHBvcnQgY29uc3QgdXNlTmF0aXZlQ3VzdG9tRWxlbWVudHMgPSAhKHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKTtcbmV4cG9ydCBjb25zdCBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMgPSB1c2VTaGFkb3cgJiZcbiAgICAoJ2Fkb3B0ZWRTdHlsZVNoZWV0cycgaW4gRG9jdW1lbnQucHJvdG90eXBlKSAmJlxuICAgICgncmVwbGFjZVN5bmMnIGluIENTU1N0eWxlU2hlZXQucHJvdG90eXBlKSAmJlxuICAgIC8vIFNpbmNlIHNwZWMgbWF5IGNoYW5nZSwgZmVhdHVyZSBkZXRlY3QgZXhhY3QgQVBJIHdlIG5lZWRcbiAgICAoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2hlZXQgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICBzaGVldC5yZXBsYWNlU3luYygnJyk7XG4gICAgICAgIGNvbnN0IGhvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaG9zdC5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICBob3N0LnNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW3NoZWV0XTtcbiAgICAgICAgcmV0dXJuIChob3N0LnNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzWzBdID09PSBzaGVldCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbi8qKlxuICogR2xvYmFsbHkgc2V0dGFibGUgcHJvcGVydHkgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvXG4gKiBgRWxlbWVudE1peGluYCBpbnN0YW5jZXMsIHVzZWZ1bCBmb3IgYmluZGluZyBpbiB0ZW1wbGF0ZXMgdG9cbiAqIG1ha2UgVVJMJ3MgcmVsYXRpdmUgdG8gYW4gYXBwbGljYXRpb24ncyByb290LiAgRGVmYXVsdHMgdG8gdGhlIG1haW5cbiAqIGRvY3VtZW50IFVSTCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXJzLiAgSXQgbWF5IGJlIHVzZWZ1bCB0byBzZXRcbiAqIGByb290UGF0aGAgdG8gcHJvdmlkZSBhIHN0YWJsZSBhcHBsaWNhdGlvbiBtb3VudCBwYXRoIHdoZW5cbiAqIHVzaW5nIGNsaWVudCBzaWRlIHJvdXRpbmcuXG4gKi9cbmV4cG9ydCBsZXQgcm9vdFBhdGggPSB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci5yb290UGF0aCB8fFxuICBwYXRoRnJvbVVybChkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBnbG9iYWwgcm9vdFBhdGggcHJvcGVydHkgdXNlZCBieSBgRWxlbWVudE1peGluYCBhbmRcbiAqIGF2YWlsYWJsZSB2aWEgYHJvb3RQYXRoYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgbmV3IHJvb3QgcGF0aFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFJvb3RQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICByb290UGF0aCA9IHBhdGg7XG59O1xuXG4vKipcbiAqIEEgZ2xvYmFsIGNhbGxiYWNrIHVzZWQgdG8gc2FuaXRpemUgYW55IHZhbHVlIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgRE9NLlxuICogVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbiAqXG4gKiAgZnVuY3Rpb24gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgbmFtZSwgdHlwZSwgbm9kZSkgeyAuLi4gfVxuICpcbiAqIFdoZXJlOlxuICpcbiAqIGB2YWx1ZWAgaXMgdGhlIHZhbHVlIHRvIHNhbml0aXplLlxuICogYG5hbWVgIGlzIHRoZSBuYW1lIG9mIGFuIGF0dHJpYnV0ZSBvciBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGhyZWYpLlxuICogYHR5cGVgIGluZGljYXRlcyB3aGVyZSB0aGUgdmFsdWUgaXMgYmVpbmcgaW5zZXJ0ZWQ6IG9uZSBvZiBwcm9wZXJ0eSwgYXR0cmlidXRlLCBvciB0ZXh0LlxuICogYG5vZGVgIGlzIHRoZSBub2RlIHdoZXJlIHRoZSB2YWx1ZSBpcyBiZWluZyBpbnNlcnRlZC5cbiAqXG4gKiBAdHlwZSB7KGZ1bmN0aW9uKCosc3RyaW5nLHN0cmluZyw/Tm9kZSk6Kil8dW5kZWZpbmVkfVxuICovXG5leHBvcnQgbGV0IHNhbml0aXplRE9NVmFsdWUgPVxuICB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci5zYW5pdGl6ZURPTVZhbHVlIHx8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBTZXRzIHRoZSBnbG9iYWwgc2FuaXRpemVET01WYWx1ZSBhdmFpbGFibGUgdmlhIHRoaXMgbW9kdWxlJ3MgZXhwb3J0ZWRcbiAqIGBzYW5pdGl6ZURPTVZhbHVlYCB2YXJpYWJsZS5cbiAqXG4gKiBAcGFyYW0geyhmdW5jdGlvbigqLHN0cmluZyxzdHJpbmcsP05vZGUpOiopfHVuZGVmaW5lZH0gbmV3U2FuaXRpemVET01WYWx1ZSB0aGUgZ2xvYmFsIHNhbml0aXplRE9NVmFsdWUgY2FsbGJhY2tcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRTYW5pdGl6ZURPTVZhbHVlID0gZnVuY3Rpb24obmV3U2FuaXRpemVET01WYWx1ZSkge1xuICBzYW5pdGl6ZURPTVZhbHVlID0gbmV3U2FuaXRpemVET01WYWx1ZTtcbn07XG5cbi8qKlxuICogR2V0cyBzYW5pdGl6ZURPTVZhbHVlLCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3Qgd2VsbCBzdXBwb3J0IGBleHBvcnQgbGV0YC5cbiAqXG4gKiBAcmV0dXJuIHsoZnVuY3Rpb24oKixzdHJpbmcsc3RyaW5nLD9Ob2RlKToqKXx1bmRlZmluZWR9IHNhbml0aXplRE9NVmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNhbml0aXplRE9NVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNhbml0aXplRE9NVmFsdWU7XG59O1xuXG4vKipcbiAqIEdsb2JhbGx5IHNldHRhYmxlIHByb3BlcnR5IHRvIG1ha2UgUG9seW1lciBHZXN0dXJlcyB1c2UgcGFzc2l2ZSBUb3VjaEV2ZW50IGxpc3RlbmVycyB3aGVuIHJlY29nbml6aW5nIGdlc3R1cmVzLlxuICogV2hlbiBzZXQgdG8gYHRydWVgLCBnZXN0dXJlcyBtYWRlIGZyb20gdG91Y2ggd2lsbCBub3QgYmUgYWJsZSB0byBwcmV2ZW50IHNjcm9sbGluZywgYWxsb3dpbmcgZm9yIHNtb290aGVyXG4gKiBzY3JvbGxpbmcgcGVyZm9ybWFuY2UuXG4gKiBEZWZhdWx0cyB0byBgZmFsc2VgIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqL1xuZXhwb3J0IGxldCBwYXNzaXZlVG91Y2hHZXN0dXJlcyA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLnNldFBhc3NpdmVUb3VjaEdlc3R1cmVzIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYHBhc3NpdmVUb3VjaEdlc3R1cmVzYCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzIHVzaW5nIFBvbHltZXIgR2VzdHVyZXMuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB1c2VQYXNzaXZlIGVuYWJsZSBvciBkaXNhYmxlIHBhc3NpdmUgdG91Y2ggZ2VzdHVyZXMgZ2xvYmFsbHlcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRQYXNzaXZlVG91Y2hHZXN0dXJlcyA9IGZ1bmN0aW9uKHVzZVBhc3NpdmUpIHtcbiAgcGFzc2l2ZVRvdWNoR2VzdHVyZXMgPSB1c2VQYXNzaXZlO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIGVuc3VyZSBQb2x5bWVyIHRlbXBsYXRlIGV2YWx1YXRpb24gb25seSBvY2N1cnMgYmFzZWQgb24gdGVtcGF0ZXNcbiAqIGRlZmluZWQgaW4gdHJ1c3RlZCBzY3JpcHQuICBXaGVuIHRydWUsIGA8ZG9tLW1vZHVsZT5gIHJlLXJlZ2lzdHJhdGlvbiBpc1xuICogZGlzYWxsb3dlZCwgYDxkb20tYmluZD5gIGlzIGRpc2FibGVkLCBhbmQgYDxkb20taWY+YC9gPGRvbS1yZXBlYXQ+YFxuICogdGVtcGxhdGVzIHdpbGwgb25seSBldmFsdWF0ZSBpbiB0aGUgY29udGV4dCBvZiBhIHRydXN0ZWQgZWxlbWVudCB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0IGxldCBzdHJpY3RUZW1wbGF0ZVBvbGljeSA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLnN0cmljdFRlbXBsYXRlUG9saWN5IHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYHN0cmljdFRlbXBsYXRlUG9saWN5YCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB1c2VTdHJpY3RQb2xpY3kgZW5hYmxlIG9yIGRpc2FibGUgc3RyaWN0IHRlbXBsYXRlIHBvbGljeVxuICogICBnbG9iYWxseVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFN0cmljdFRlbXBsYXRlUG9saWN5ID0gZnVuY3Rpb24odXNlU3RyaWN0UG9saWN5KSB7XG4gIHN0cmljdFRlbXBsYXRlUG9saWN5ID0gdXNlU3RyaWN0UG9saWN5O1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIGVuYWJsZSBkb20tbW9kdWxlIGxvb2t1cCBmcm9tIFBvbHltZXIuRWxlbWVudC4gIEJ5IGRlZmF1bHQsXG4gKiB0ZW1wbGF0ZXMgbXVzdCBiZSBkZWZpbmVkIGluIHNjcmlwdCB1c2luZyB0aGUgYHN0YXRpYyBnZXQgdGVtcGxhdGUoKWBcbiAqIGdldHRlciBhbmQgdGhlIGBodG1sYCB0YWcgZnVuY3Rpb24uICBUbyBlbmFibGUgbGVnYWN5IGxvYWRpbmcgb2YgdGVtcGxhdGVzXG4gKiB2aWEgZG9tLW1vZHVsZSwgc2V0IHRoaXMgZmxhZyB0byB0cnVlLlxuICovXG5leHBvcnQgbGV0IGFsbG93VGVtcGxhdGVGcm9tRG9tTW9kdWxlID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIuYWxsb3dUZW1wbGF0ZUZyb21Eb21Nb2R1bGUgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgbG9va3VwVGVtcGxhdGVGcm9tRG9tTW9kdWxlYCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBhbGxvd0RvbU1vZHVsZSBlbmFibGUgb3IgZGlzYWJsZSB0ZW1wbGF0ZSBsb29rdXBcbiAqICAgZ2xvYmFsbHlcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBbGxvd1RlbXBsYXRlRnJvbURvbU1vZHVsZSA9IGZ1bmN0aW9uKGFsbG93RG9tTW9kdWxlKSB7XG4gIGFsbG93VGVtcGxhdGVGcm9tRG9tTW9kdWxlID0gYWxsb3dEb21Nb2R1bGU7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gc2tpcCBwcm9jZXNzaW5nIHN0eWxlIGluY2x1ZGVzIGFuZCByZS13cml0aW5nIHVybHMgaW4gY3NzIHN0eWxlcy5cbiAqIE5vcm1hbGx5IFwiaW5jbHVkZWRcIiBzdHlsZXMgYXJlIHB1bGxlZCBpbnRvIHRoZSBlbGVtZW50IGFuZCBhbGwgdXJscyBpbiBzdHlsZXNcbiAqIGFyZSByZS13cml0dGVuIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIHNjcmlwdCB1cmwuXG4gKiBJZiBubyBpbmNsdWRlcyBvciByZWxhdGl2ZSB1cmxzIGFyZSB1c2VkIGluIHN0eWxlcywgdGhlc2Ugc3RlcHMgY2FuIGJlXG4gKiBza2lwcGVkIGFzIGFuIG9wdGltaXphdGlvbi5cbiAqL1xuZXhwb3J0IGxldCBsZWdhY3lPcHRpbWl6YXRpb25zID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIubGVnYWN5T3B0aW1pemF0aW9ucyB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGBsZWdhY3lPcHRpbWl6YXRpb25zYCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzIHRvIGVuYWJsZSBvcHRpbWl6YXRpb25zXG4gKiB3aGVuIG9ubHkgbGVnYWN5IGJhc2VkIGVsZW1lbnRzIGFyZSB1c2VkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlTGVnYWN5T3B0aW1pemF0aW9ucyBlbmFibGUgb3IgZGlzYWJsZSBsZWdhY3kgb3B0aW1pemF0aW9uc1xuICogaW5jbHVkZXMgYW5kIHVybCByZXdyaXRpbmdcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRMZWdhY3lPcHRpbWl6YXRpb25zID0gZnVuY3Rpb24odXNlTGVnYWN5T3B0aW1pemF0aW9ucykge1xuICBsZWdhY3lPcHRpbWl6YXRpb25zID0gdXNlTGVnYWN5T3B0aW1pemF0aW9ucztcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byBhZGQgd2FybmluZ3MgdXNlZnVsIHdoZW4gbWlncmF0aW5nIGZyb20gUG9seW1lciAxLnggdG8gMi54LlxuICovXG5leHBvcnQgbGV0IGxlZ2FjeVdhcm5pbmdzID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIubGVnYWN5V2FybmluZ3MgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgbGVnYWN5V2FybmluZ3NgIGdsb2JhbGx5IGZvciBhbGwgZWxlbWVudHMgdG8gbWlncmF0aW9uIHdhcm5pbmdzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlTGVnYWN5V2FybmluZ3MgZW5hYmxlIG9yIGRpc2FibGUgd2FybmluZ3NcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRMZWdhY3lXYXJuaW5ncyA9IGZ1bmN0aW9uKHVzZUxlZ2FjeVdhcm5pbmdzKSB7XG4gIGxlZ2FjeVdhcm5pbmdzID0gdXNlTGVnYWN5V2FybmluZ3M7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gcGVyZm9ybSBpbml0aWFsIHJlbmRlcmluZyBzeW5jaHJvbm91c2x5IHdoZW4gcnVubmluZyB1bmRlciBTaGFkeURPTS5cbiAqIFRoaXMgbWF0Y2hlcyB0aGUgYmVoYXZpb3Igb2YgUG9seW1lciAxLlxuICovXG5leHBvcnQgbGV0IHN5bmNJbml0aWFsUmVuZGVyID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIuc3luY0luaXRpYWxSZW5kZXIgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgc3luY0luaXRpYWxSZW5kZXJgIGdsb2JhbGx5IGZvciBhbGwgZWxlbWVudHMgdG8gZW5hYmxlIHN5bmNocm9ub3VzXG4gKiBpbml0aWFsIHJlbmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVzZVN5bmNJbml0aWFsUmVuZGVyIGVuYWJsZSBvciBkaXNhYmxlIHN5bmNocm9ub3VzIGluaXRpYWxcbiAqIHJlbmRlcmluZyBnbG9iYWxseS5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRTeW5jSW5pdGlhbFJlbmRlciA9IGZ1bmN0aW9uKHVzZVN5bmNJbml0aWFsUmVuZGVyKSB7XG4gIHN5bmNJbml0aWFsUmVuZGVyID0gdXNlU3luY0luaXRpYWxSZW5kZXI7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gcmV0YWluIHRoZSBsZWdhY3kgUG9seW1lciAxIGJlaGF2aW9yIGZvciBtdWx0aS1wcm9wZXJ0eVxuICogb2JzZXJ2ZXJzIGFyb3VuZCB1bmRlZmluZWQgdmFsdWVzLiBPYnNlcnZlcnMgYW5kIGNvbXB1dGVkIHByb3BlcnR5IG1ldGhvZHNcbiAqIGFyZSBub3QgY2FsbGVkIHVudGlsIG5vIGFyZ3VtZW50IGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGxldCBsZWdhY3lVbmRlZmluZWQgPVxuICB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci5sZWdhY3lVbmRlZmluZWQgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgbGVnYWN5VW5kZWZpbmVkYCBnbG9iYWxseSBmb3IgYWxsIGVsZW1lbnRzIHRvIGVuYWJsZSBsZWdhY3lcbiAqIG11bHRpLXByb3BlcnR5IGJlaGF2aW9yIGZvciB1bmRlZmluZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlTGVnYWN5VW5kZWZpbmVkIGVuYWJsZSBvciBkaXNhYmxlIGxlZ2FjeVxuICogbXVsdGktcHJvcGVydHkgYmVoYXZpb3IgZm9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRMZWdhY3lVbmRlZmluZWQgPSBmdW5jdGlvbih1c2VMZWdhY3lVbmRlZmluZWQpIHtcbiAgbGVnYWN5VW5kZWZpbmVkID0gdXNlTGVnYWN5VW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIGVuc3VyZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBjb21wdXRlZCBpbiBvcmRlciB0byBlbnN1cmVcbiAqIHJlLWNvbXB1dGF0aW9uIG5ldmVyIG9jY3VycyBpbiBhIGdpdmVuIHR1cm4uXG4gKi9cbmV4cG9ydCBsZXQgb3JkZXJlZENvbXB1dGVkID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIub3JkZXJlZENvbXB1dGVkIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYG9yZGVyZWRDb21wdXRlZGAgZ2xvYmFsbHkgZm9yIGFsbCBlbGVtZW50cyB0byBlbmFibGUgb3JkZXJlZCBjb21wdXRlZFxuICogcHJvcGVydHkgY29tcHV0YXRpb24uXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB1c2VPcmRlcmVkQ29tcHV0ZWQgZW5hYmxlIG9yIGRpc2FibGUgb3JkZXJlZCBjb21wdXRlZCBlZmZlY3RzXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0T3JkZXJlZENvbXB1dGVkID0gZnVuY3Rpb24odXNlT3JkZXJlZENvbXB1dGVkKSB7XG4gIG9yZGVyZWRDb21wdXRlZCA9IHVzZU9yZGVyZWRDb21wdXRlZDtcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byBjYW5jZWwgc3ludGhldGljIGNsaWNrIGV2ZW50cyBmaXJlZCBieSBvbGRlciBtb2JpbGUgYnJvd3NlcnMuIE1vZGVybiBicm93c2Vyc1xuICogbm8gbG9uZ2VyIGZpcmUgc3ludGhldGljIGNsaWNrIGV2ZW50cywgYW5kIHRoZSBjYW5jZWxsYXRpb24gYmVoYXZpb3IgY2FuIGludGVyZmVyZVxuICogd2hlbiBwcm9ncmFtbWF0aWNhbGx5IGNsaWNraW5nIG9uIGVsZW1lbnRzLlxuICovXG5leHBvcnQgbGV0IGNhbmNlbFN5bnRoZXRpY0NsaWNrRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBTZXRzIGBzZXRDYW5jZWxTeW50aGV0aWNFdmVudHNgIGdsb2JhbGx5IGZvciBhbGwgZWxlbWVudHMgdG8gY2FuY2VsIHN5bnRoZXRpYyBjbGljayBldmVudHMuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB1c2VDYW5jZWxTeW50aGV0aWNDbGlja0V2ZW50cyBlbmFibGUgb3IgZGlzYWJsZSBjYW5jZWxsaW5nIHN5bnRoZXRpY1xuICogZXZlbnRzXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0Q2FuY2VsU3ludGhldGljQ2xpY2tFdmVudHMgPSBmdW5jdGlvbih1c2VDYW5jZWxTeW50aGV0aWNDbGlja0V2ZW50cykge1xuICBjYW5jZWxTeW50aGV0aWNDbGlja0V2ZW50cyA9IHVzZUNhbmNlbFN5bnRoZXRpY0NsaWNrRXZlbnRzO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIHJlbW92ZSBuZXN0ZWQgdGVtcGxhdGVzIGluc2lkZSBgZG9tLWlmYCBhbmQgYGRvbS1yZXBlYXRgIGFzXG4gKiBwYXJ0IG9mIGVsZW1lbnQgdGVtcGxhdGUgcGFyc2luZy4gIFRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdGhhdFxuICogZWxpbWluYXRlcyBtb3N0IG9mIHRoZSB0YXggb2YgbmVlZGluZyB0d28gZWxlbWVudHMgZHVlIHRvIHRoZSBsb3NzIG9mXG4gKiB0eXBlLWV4dGVuZGVkIHRlbXBsYXRlcyBhcyBhIHJlc3VsdCBvZiB0aGUgVjEgc3BlY2lmaWNhdGlvbiBjaGFuZ2VzLlxuICovXG5leHBvcnQgbGV0IHJlbW92ZU5lc3RlZFRlbXBsYXRlcyA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLnJlbW92ZU5lc3RlZFRlbXBsYXRlcyB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGByZW1vdmVOZXN0ZWRUZW1wbGF0ZXNgIGdsb2JhbGx5LCB0byBlbGltaW5hdGUgbmVzdGVkIHRlbXBsYXRlc1xuICogaW5zaWRlIGBkb20taWZgIGFuZCBgZG9tLXJlcGVhdGAgYXMgcGFydCBvZiB0ZW1wbGF0ZSBwYXJzaW5nLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlUmVtb3ZlTmVzdGVkVGVtcGxhdGVzIGVuYWJsZSBvciBkaXNhYmxlIHJlbW92aW5nIG5lc3RlZFxuICogICB0ZW1wbGF0ZXMgZHVyaW5nIHBhcnNpbmdcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRSZW1vdmVOZXN0ZWRUZW1wbGF0ZXMgPSBmdW5jdGlvbih1c2VSZW1vdmVOZXN0ZWRUZW1wbGF0ZXMpIHtcbiAgcmVtb3ZlTmVzdGVkVGVtcGxhdGVzID0gdXNlUmVtb3ZlTmVzdGVkVGVtcGxhdGVzO1xufTtcblxuLyoqXG4gKiBTZXR0aW5nIHRvIHBsYWNlIGBkb20taWZgIGVsZW1lbnRzIGluIGEgcGVyZm9ybWFuY2Utb3B0aW1pemVkIG1vZGUgdGhhdCB0YWtlc1xuICogYWR2YW50YWdlIG9mIGxpZ2h0ZXItd2VpZ2h0IGhvc3QgcnVudGltZSB0ZW1wbGF0ZSBzdGFtcGluZyB0byBlbGltaW5hdGUgdGhlXG4gKiBuZWVkIGZvciBhbiBpbnRlcm1lZGlhdGUgVGVtcGxhdGl6ZXIgYFRlbXBsYXRlSW5zdGFuY2VgIHRvIG1hbmdlIHRoZSBub2Rlc1xuICogc3RhbXBlZCBieSBgZG9tLWlmYC4gIFVuZGVyIHRoaXMgc2V0dGluZywgYW55IFRlbXBsYXRpemVyLXByb3ZpZGVkIEFQSSdzXG4gKiBzdWNoIGFzIGBtb2RlbEZvckVsZW1lbnRgIHdpbGwgbm90IGJlIGF2YWlsYWJsZSBmb3Igbm9kZXMgc3RhbXBlZCBieVxuICogYGRvbS1pZmAuXG4gKi9cbmV4cG9ydCBsZXQgZmFzdERvbUlmID0gd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIuZmFzdERvbUlmIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYGZhc3REb21JZmAgZ2xvYmFsbHksIHRvIHB1dCBgZG9tLWlmYCBpbiBhIHBlcmZvcm1hbmNlLW9wdGltaXplZCBtb2RlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlRmFzdERvbUlmIGVuYWJsZSBvciBkaXNhYmxlIGBkb20taWZgIGZhc3QtbW9kZVxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEZhc3REb21JZiA9IGZ1bmN0aW9uKHVzZUZhc3REb21JZikge1xuICBmYXN0RG9tSWYgPSB1c2VGYXN0RG9tSWY7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gZGlzYWJsZSBgZG9tLWNoYW5nZWAgYW5kIGByZW5kZXJlZC1pdGVtLWNvdW50YCBldmVudHMgZnJvbVxuICogYGRvbS1pZmAgYW5kIGBkb20tcmVwZWF0YC4gVXNlcnMgY2FuIG9wdCBiYWNrIGludG8gYGRvbS1jaGFuZ2VgIGV2ZW50cyBieVxuICogc2V0dGluZyB0aGUgYG5vdGlmeS1kb20tY2hhbmdlYCBhdHRyaWJ1dGUgKGBub3RpZnlEb21DaGFuZ2U6IHRydWVgIHByb3BlcnR5KVxuICogdG8gYGRvbS1pZmAvYGRvbi1yZXBlYXRgIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGxldCBzdXBwcmVzc1RlbXBsYXRlTm90aWZpY2F0aW9ucyA9XG4gIHdpbmRvdy5Qb2x5bWVyICYmIHdpbmRvdy5Qb2x5bWVyLnN1cHByZXNzVGVtcGxhdGVOb3RpZmljYXRpb25zIHx8IGZhbHNlO1xuXG4vKipcbiAqIFNldHMgYHN1cHByZXNzVGVtcGxhdGVOb3RpZmljYXRpb25zYCBnbG9iYWxseSwgdG8gZGlzYWJsZSBgZG9tLWNoYW5nZWAgYW5kXG4gKiBgcmVuZGVyZWQtaXRlbS1jb3VudGAgZXZlbnRzIGZyb20gYGRvbS1pZmAgYW5kIGBkb20tcmVwZWF0YC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN1cHByZXNzIGVuYWJsZSBvciBkaXNhYmxlIGBzdXBwcmVzc1RlbXBsYXRlTm90aWZpY2F0aW9uc2BcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRTdXBwcmVzc1RlbXBsYXRlTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uKHN1cHByZXNzKSB7XG4gIHN1cHByZXNzVGVtcGxhdGVOb3RpZmljYXRpb25zID0gc3VwcHJlc3M7XG59O1xuXG4vKipcbiAqIFNldHRpbmcgdG8gZGlzYWJsZSB1c2Ugb2YgZHluYW1pYyBhdHRyaWJ1dGVzLiBUaGlzIGlzIGFuIG9wdGltaXphdGlvblxuICogdG8gYXZvaWQgc2V0dGluZyBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYC4gSW5zdGVhZCBhdHRyaWJ1dGVzIGFyZSByZWFkXG4gKiBvbmNlIGF0IGNyZWF0ZSB0aW1lIGFuZCBzZXQvcmVtb3ZlQXR0cmlidXRlIGFyZSBwYXRjaGVkLlxuICovXG5leHBvcnQgbGV0IGxlZ2FjeU5vT2JzZXJ2ZWRBdHRyaWJ1dGVzID1cbiAgd2luZG93LlBvbHltZXIgJiYgd2luZG93LlBvbHltZXIubGVnYWN5Tm9PYnNlcnZlZEF0dHJpYnV0ZXMgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgbGVnYWN5Tm9PYnNlcnZlZEF0dHJpYnV0ZXNgIGdsb2JhbGx5LCB0byBkaXNhYmxlIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9PYnNlcnZlZEF0dHJpYnV0ZXMgZW5hYmxlIG9yIGRpc2FibGUgYGxlZ2FjeU5vT2JzZXJ2ZWRBdHRyaWJ1dGVzYFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldExlZ2FjeU5vT2JzZXJ2ZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24obm9PYnNlcnZlZEF0dHJpYnV0ZXMpIHtcbiAgbGVnYWN5Tm9PYnNlcnZlZEF0dHJpYnV0ZXMgPSBub09ic2VydmVkQXR0cmlidXRlcztcbn07XG5cbi8qKlxuICogU2V0dGluZyB0byBlbmFibGUgdXNlIG9mIGBhZG9wdGVkU3R5bGVTaGVldHNgIGZvciBzaGFyaW5nIHN0eWxlIHNoZWV0c1xuICogYmV0d2VlbiBjb21wb25lbnQgaW5zdGFuY2VzJyBzaGFkb3cgcm9vdHMsIGlmIHRoZSBhcHAgdXNlcyBidWlsdCBTaGFkeSBDU1NcbiAqIHN0eWxlcy5cbiAqL1xuZXhwb3J0IGxldCB1c2VBZG9wdGVkU3R5bGVTaGVldHNXaXRoQnVpbHRDU1MgPVxuICB3aW5kb3cuUG9seW1lciAmJiB3aW5kb3cuUG9seW1lci51c2VBZG9wdGVkU3R5bGVTaGVldHNXaXRoQnVpbHRDU1MgfHwgZmFsc2U7XG5cbi8qKlxuICogU2V0cyBgdXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTYCBnbG9iYWxseS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIGVuYWJsZSBvciBkaXNhYmxlIGB1c2VBZG9wdGVkU3R5bGVTaGVldHNXaXRoQnVpbHRDU1NgXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgY29uc3Qgc2V0VXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdXNlQWRvcHRlZFN0eWxlU2hlZXRzV2l0aEJ1aWx0Q1NTID0gdmFsdWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/settings.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/style-gather.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/style-gather.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cssFromModule\": () => (/* binding */ cssFromModule),\n/* harmony export */   \"cssFromModuleImports\": () => (/* binding */ cssFromModuleImports),\n/* harmony export */   \"cssFromModules\": () => (/* binding */ cssFromModules),\n/* harmony export */   \"cssFromTemplate\": () => (/* binding */ cssFromTemplate),\n/* harmony export */   \"stylesFromModule\": () => (/* binding */ stylesFromModule),\n/* harmony export */   \"stylesFromModuleImports\": () => (/* binding */ stylesFromModuleImports),\n/* harmony export */   \"stylesFromModules\": () => (/* binding */ stylesFromModules),\n/* harmony export */   \"stylesFromTemplate\": () => (/* binding */ stylesFromTemplate)\n/* harmony export */ });\n/* harmony import */ var _elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../elements/dom-module.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/elements/dom-module.js\");\n/* harmony import */ var _resolve_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-url.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/resolve-url.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module with utilities for collection CSS text from `<templates>`, external\n * stylesheets, and `dom-module`s.\n *\n * @summary Module with utilities for collection CSS text from various sources.\n */\n\n\n\nconst MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\nconst INCLUDE_ATTR = 'include';\nconst SHADY_UNSCOPED_ATTR = 'shady-unscoped';\n\n/**\n * @param {string} moduleId .\n * @return {?DomModule} .\n */\nfunction importModule(moduleId) {\n  return (/** @type {?DomModule} */_elements_dom_module_js__WEBPACK_IMPORTED_MODULE_0__.DomModule[\"import\"](moduleId)\n  );\n}\nfunction styleForImport(importDoc) {\n  // NOTE: polyfill affordance.\n  // under the HTMLImports polyfill, there will be no 'body',\n  // but the import pseudo-doc can be used directly.\n  let container = importDoc.body ? importDoc.body : importDoc;\n  const importCss = (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveCss)(container.textContent, importDoc.baseURI);\n  const style = document.createElement('style');\n  style.textContent = importCss;\n  return style;\n}\n\n/** @typedef {{assetpath: string}} */\nlet templateWithAssetPath; // eslint-disable-line no-unused-vars\n\n/**\n * Returns a list of <style> elements in a space-separated list of `dom-module`s.\n *\n * @function\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements\n */\nfunction stylesFromModules(moduleIds) {\n  const modules = moduleIds.trim().split(/\\s+/);\n  const styles = [];\n  for (let i = 0; i < modules.length; i++) {\n    styles.push(...stylesFromModule(modules[i]));\n  }\n  return styles;\n}\n\n/**\n * Returns a list of <style> elements in a given `dom-module`.\n * Styles in a `dom-module` can come either from `<style>`s within the\n * first `<template>`, or else from one or more\n * `<link rel=\"import\" type=\"css\">` links outside the template.\n *\n * @param {string} moduleId dom-module id to gather styles from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\nfunction stylesFromModule(moduleId) {\n  const m = importModule(moduleId);\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n    return [];\n  }\n  if (m._styles === undefined) {\n    const styles = [];\n    // module imports: <link rel=\"import\" type=\"css\">\n    styles.push(..._stylesFromModuleImports(m));\n    // include css from the first template in the module\n    const template = /** @type {?HTMLTemplateElement} */\n    m.querySelector('template');\n    if (template) {\n      styles.push(...stylesFromTemplate(template, /** @type {templateWithAssetPath} */m.assetpath));\n    }\n    m._styles = styles;\n  }\n  return m._styles;\n}\n\n/**\n * Returns the `<style>` elements within a given template.\n *\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string=} baseURI baseURI for style content\n * @return {!Array<!HTMLStyleElement>} Array of styles\n */\nfunction stylesFromTemplate(template, baseURI) {\n  if (!template._styles) {\n    const styles = [];\n    // if element is a template, get content from its .content\n    const e$ = template.content.querySelectorAll('style');\n    for (let i = 0; i < e$.length; i++) {\n      let e = e$[i];\n      // support style sharing by allowing styles to \"include\"\n      // other dom-modules that contain styling\n      let include = e.getAttribute(INCLUDE_ATTR);\n      if (include) {\n        styles.push(...stylesFromModules(include).filter(function (item, index, self) {\n          return self.indexOf(item) === index;\n        }));\n      }\n      if (baseURI) {\n        e.textContent = (0,_resolve_url_js__WEBPACK_IMPORTED_MODULE_1__.resolveCss)(e.textContent, /** @type {string} */baseURI);\n      }\n      styles.push(e);\n    }\n    template._styles = styles;\n  }\n  return template._styles;\n}\n\n/**\n * Returns a list of <style> elements  from stylesheets loaded via `<link rel=\"import\" type=\"css\">` links within the specified `dom-module`.\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n */\nfunction stylesFromModuleImports(moduleId) {\n  let m = importModule(moduleId);\n  return m ? _stylesFromModuleImports(m) : [];\n}\n\n/**\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {!Array<!HTMLStyleElement>} Array of contained styles\n */\nfunction _stylesFromModuleImports(module) {\n  const styles = [];\n  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n  for (let i = 0; i < p$.length; i++) {\n    let p = p$[i];\n    if (p.import) {\n      const importDoc = p.import;\n      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);\n      if (unscoped && !importDoc._unscopedStyle) {\n        const style = styleForImport(importDoc);\n        style.setAttribute(SHADY_UNSCOPED_ATTR, '');\n        importDoc._unscopedStyle = style;\n      } else if (!importDoc._style) {\n        importDoc._style = styleForImport(importDoc);\n      }\n      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);\n    }\n  }\n  return styles;\n}\n\n/**\n *\n * Returns CSS text of styles in a space-separated list of `dom-module`s.\n * Note: This method is deprecated, use `stylesFromModules` instead.\n *\n * @deprecated\n * @param {string} moduleIds List of dom-module id's within which to\n * search for css.\n * @return {string} Concatenated CSS content from specified `dom-module`s\n */\nfunction cssFromModules(moduleIds) {\n  let modules = moduleIds.trim().split(/\\s+/);\n  let cssText = '';\n  for (let i = 0; i < modules.length; i++) {\n    cssText += cssFromModule(modules[i]);\n  }\n  return cssText;\n}\n\n/**\n * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n * can come either from `<style>`s within the first `<template>`, or else\n * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n * template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromModule` instead.\n *\n * @deprecated\n * @param {string} moduleId dom-module id to gather styles from\n * @return {string} Concatenated CSS content from specified `dom-module`\n */\nfunction cssFromModule(moduleId) {\n  let m = importModule(moduleId);\n  if (m && m._cssText === undefined) {\n    // module imports: <link rel=\"import\" type=\"css\">\n    let cssText = _cssFromModuleImports(m);\n    // include css from the first template in the module\n    let t = /** @type {?HTMLTemplateElement} */m.querySelector('template');\n    if (t) {\n      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */m.assetpath);\n    }\n    m._cssText = cssText || null;\n  }\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n  }\n  return m && m._cssText || '';\n}\n\n/**\n * Returns CSS text of `<styles>` within a given template.\n *\n * Any `<styles>` processed are removed from their original location.\n * Note: This method is deprecated, use `styleFromTemplate` instead.\n *\n * @deprecated\n * @param {!HTMLTemplateElement} template Template to gather styles from\n * @param {string} baseURI Base URI to resolve the URL against\n * @return {string} Concatenated CSS content from specified template\n */\nfunction cssFromTemplate(template, baseURI) {\n  let cssText = '';\n  const e$ = stylesFromTemplate(template, baseURI);\n  // if element is a template, get content from its .content\n  for (let i = 0; i < e$.length; i++) {\n    let e = e$[i];\n    if (e.parentNode) {\n      e.parentNode.removeChild(e);\n    }\n    cssText += e.textContent;\n  }\n  return cssText;\n}\n\n/**\n * Returns CSS text from stylesheets loaded via `<link rel=\"import\" type=\"css\">`\n * links within the specified `dom-module`.\n *\n * Note: This method is deprecated, use `stylesFromModuleImports` instead.\n *\n * @deprecated\n *\n * @param {string} moduleId Id of `dom-module` to gather CSS from\n * @return {string} Concatenated CSS content from links in specified `dom-module`\n */\nfunction cssFromModuleImports(moduleId) {\n  let m = importModule(moduleId);\n  return m ? _cssFromModuleImports(m) : '';\n}\n\n/**\n * @deprecated\n * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n * @return {string} Concatenated CSS content from links in the dom-module\n */\nfunction _cssFromModuleImports(module) {\n  let cssText = '';\n  let styles = _stylesFromModuleImports(module);\n  for (let i = 0; i < styles.length; i++) {\n    cssText += styles[i].textContent;\n  }\n  return cssText;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmpzPzU5ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyoqXG4gKiBNb2R1bGUgd2l0aCB1dGlsaXRpZXMgZm9yIGNvbGxlY3Rpb24gQ1NTIHRleHQgZnJvbSBgPHRlbXBsYXRlcz5gLCBleHRlcm5hbFxuICogc3R5bGVzaGVldHMsIGFuZCBgZG9tLW1vZHVsZWBzLlxuICpcbiAqIEBzdW1tYXJ5IE1vZHVsZSB3aXRoIHV0aWxpdGllcyBmb3IgY29sbGVjdGlvbiBDU1MgdGV4dCBmcm9tIHZhcmlvdXMgc291cmNlcy5cbiAqL1xuXG5pbXBvcnQgeyBEb21Nb2R1bGUgfSBmcm9tICcuLi9lbGVtZW50cy9kb20tbW9kdWxlLmpzJztcbmltcG9ydCB7IHJlc29sdmVDc3MgfSBmcm9tICcuL3Jlc29sdmUtdXJsLmpzJztcblxuY29uc3QgTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IgPSAnbGlua1tyZWw9aW1wb3J0XVt0eXBlfj1jc3NdJztcbmNvbnN0IElOQ0xVREVfQVRUUiA9ICdpbmNsdWRlJztcbmNvbnN0IFNIQURZX1VOU0NPUEVEX0FUVFIgPSAnc2hhZHktdW5zY29wZWQnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCAuXG4gKiBAcmV0dXJuIHs/RG9tTW9kdWxlfSAuXG4gKi9cbmZ1bmN0aW9uIGltcG9ydE1vZHVsZShtb2R1bGVJZCkge1xuICByZXR1cm4gLyoqIEB0eXBlIHs/RG9tTW9kdWxlfSAqLyhEb21Nb2R1bGUuaW1wb3J0KG1vZHVsZUlkKSk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlRm9ySW1wb3J0KGltcG9ydERvYykge1xuICAvLyBOT1RFOiBwb2x5ZmlsbCBhZmZvcmRhbmNlLlxuICAvLyB1bmRlciB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwsIHRoZXJlIHdpbGwgYmUgbm8gJ2JvZHknLFxuICAvLyBidXQgdGhlIGltcG9ydCBwc2V1ZG8tZG9jIGNhbiBiZSB1c2VkIGRpcmVjdGx5LlxuICBsZXQgY29udGFpbmVyID0gaW1wb3J0RG9jLmJvZHkgPyBpbXBvcnREb2MuYm9keSA6IGltcG9ydERvYztcbiAgY29uc3QgaW1wb3J0Q3NzID0gcmVzb2x2ZUNzcyhjb250YWluZXIudGV4dENvbnRlbnQsXG4gICAgaW1wb3J0RG9jLmJhc2VVUkkpO1xuICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gaW1wb3J0Q3NzO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKiBAdHlwZWRlZiB7e2Fzc2V0cGF0aDogc3RyaW5nfX0gKi9cbmxldCB0ZW1wbGF0ZVdpdGhBc3NldFBhdGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIDxzdHlsZT4gZWxlbWVudHMgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBgZG9tLW1vZHVsZWBzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkcyBMaXN0IG9mIGRvbS1tb2R1bGUgaWQncyB3aXRoaW4gd2hpY2ggdG9cbiAqIHNlYXJjaCBmb3IgY3NzLlxuICogQHJldHVybiB7IUFycmF5PCFIVE1MU3R5bGVFbGVtZW50Pn0gQXJyYXkgb2YgY29udGFpbmVkIDxzdHlsZT4gZWxlbWVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0eWxlc0Zyb21Nb2R1bGVzKG1vZHVsZUlkcykge1xuIGNvbnN0IG1vZHVsZXMgPSBtb2R1bGVJZHMudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gY29uc3Qgc3R5bGVzID0gW107XG4gZm9yIChsZXQgaT0wOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgc3R5bGVzLnB1c2goLi4uc3R5bGVzRnJvbU1vZHVsZShtb2R1bGVzW2ldKSk7XG4gfVxuIHJldHVybiBzdHlsZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgPHN0eWxlPiBlbGVtZW50cyBpbiBhIGdpdmVuIGBkb20tbW9kdWxlYC5cbiAqIFN0eWxlcyBpbiBhIGBkb20tbW9kdWxlYCBjYW4gY29tZSBlaXRoZXIgZnJvbSBgPHN0eWxlPmBzIHdpdGhpbiB0aGVcbiAqIGZpcnN0IGA8dGVtcGxhdGU+YCwgb3IgZWxzZSBmcm9tIG9uZSBvciBtb3JlXG4gKiBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmAgbGlua3Mgb3V0c2lkZSB0aGUgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIGRvbS1tb2R1bGUgaWQgdG8gZ2F0aGVyIHN0eWxlcyBmcm9tXG4gKiBAcmV0dXJuIHshQXJyYXk8IUhUTUxTdHlsZUVsZW1lbnQ+fSBBcnJheSBvZiBjb250YWluZWQgc3R5bGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVzRnJvbU1vZHVsZShtb2R1bGVJZCkge1xuICBjb25zdCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcblxuICBpZiAoIW0pIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHN0eWxlIGRhdGEgaW4gbW9kdWxlIG5hbWVkJywgbW9kdWxlSWQpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmIChtLl9zdHlsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgIC8vIG1vZHVsZSBpbXBvcnRzOiA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+XG4gICAgc3R5bGVzLnB1c2goLi4uX3N0eWxlc0Zyb21Nb2R1bGVJbXBvcnRzKG0pKTtcbiAgICAvLyBpbmNsdWRlIGNzcyBmcm9tIHRoZSBmaXJzdCB0ZW1wbGF0ZSBpbiB0aGUgbW9kdWxlXG4gICAgY29uc3QgdGVtcGxhdGUgPSAvKiogQHR5cGUgez9IVE1MVGVtcGxhdGVFbGVtZW50fSAqLyhcbiAgICAgICAgbS5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIHN0eWxlcy5wdXNoKC4uLnN0eWxlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSxcbiAgICAgICAgLyoqIEB0eXBlIHt0ZW1wbGF0ZVdpdGhBc3NldFBhdGh9ICovKG0pLmFzc2V0cGF0aCkpO1xuICAgIH1cblxuICAgIG0uX3N0eWxlcyA9IHN0eWxlcztcbiAgfVxuXG4gIHJldHVybiBtLl9zdHlsZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYDxzdHlsZT5gIGVsZW1lbnRzIHdpdGhpbiBhIGdpdmVuIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIGdhdGhlciBzdHlsZXMgZnJvbVxuICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlVVJJIGJhc2VVUkkgZm9yIHN0eWxlIGNvbnRlbnRcbiAqIEByZXR1cm4geyFBcnJheTwhSFRNTFN0eWxlRWxlbWVudD59IEFycmF5IG9mIHN0eWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3R5bGVzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKSB7XG4gIGlmICghdGVtcGxhdGUuX3N0eWxlcykge1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgIC8vIGlmIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSwgZ2V0IGNvbnRlbnQgZnJvbSBpdHMgLmNvbnRlbnRcbiAgICBjb25zdCBlJCA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKTtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBlJC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGUgPSBlJFtpXTtcbiAgICAgIC8vIHN1cHBvcnQgc3R5bGUgc2hhcmluZyBieSBhbGxvd2luZyBzdHlsZXMgdG8gXCJpbmNsdWRlXCJcbiAgICAgIC8vIG90aGVyIGRvbS1tb2R1bGVzIHRoYXQgY29udGFpbiBzdHlsaW5nXG4gICAgICBsZXQgaW5jbHVkZSA9IGUuZ2V0QXR0cmlidXRlKElOQ0xVREVfQVRUUik7XG4gICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICBzdHlsZXMucHVzaCguLi5zdHlsZXNGcm9tTW9kdWxlcyhpbmNsdWRlKS5maWx0ZXIoZnVuY3Rpb24oaXRlbSwgaW5kZXgsIHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VVUkkpIHtcbiAgICAgICAgZS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICByZXNvbHZlQ3NzKGUudGV4dENvbnRlbnQsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoYmFzZVVSSSkpO1xuICAgICAgfVxuICAgICAgc3R5bGVzLnB1c2goZSk7XG4gICAgfVxuICAgIHRlbXBsYXRlLl9zdHlsZXMgPSBzdHlsZXM7XG4gIH1cbiAgcmV0dXJuIHRlbXBsYXRlLl9zdHlsZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgPHN0eWxlPiBlbGVtZW50cyAgZnJvbSBzdHlsZXNoZWV0cyBsb2FkZWQgdmlhIGA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+YCBsaW5rcyB3aXRoaW4gdGhlIHNwZWNpZmllZCBgZG9tLW1vZHVsZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZUlkIElkIG9mIGBkb20tbW9kdWxlYCB0byBnYXRoZXIgQ1NTIGZyb21cbiAqIEByZXR1cm4geyFBcnJheTwhSFRNTFN0eWxlRWxlbWVudD59IEFycmF5IG9mIGNvbnRhaW5lZCBzdHlsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHlsZXNGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCkge1xuIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiByZXR1cm4gbSA/IF9zdHlsZXNGcm9tTW9kdWxlSW1wb3J0cyhtKSA6IFtdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBtb2R1bGUgZG9tLW1vZHVsZSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmAgc3R5bGVzXG4gKiBAcmV0dXJuIHshQXJyYXk8IUhUTUxTdHlsZUVsZW1lbnQ+fSBBcnJheSBvZiBjb250YWluZWQgc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIF9zdHlsZXNGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gW107XG4gIGNvbnN0IHAkID0gbW9kdWxlLnF1ZXJ5U2VsZWN0b3JBbGwoTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IpO1xuICBmb3IgKGxldCBpPTA7IGkgPCBwJC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwID0gcCRbaV07XG4gICAgaWYgKHAuaW1wb3J0KSB7XG4gICAgICBjb25zdCBpbXBvcnREb2MgPSBwLmltcG9ydDtcbiAgICAgIGNvbnN0IHVuc2NvcGVkID0gcC5oYXNBdHRyaWJ1dGUoU0hBRFlfVU5TQ09QRURfQVRUUik7XG4gICAgICBpZiAodW5zY29wZWQgJiYgIWltcG9ydERvYy5fdW5zY29wZWRTdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IHN0eWxlRm9ySW1wb3J0KGltcG9ydERvYyk7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShTSEFEWV9VTlNDT1BFRF9BVFRSLCAnJyk7XG4gICAgICAgIGltcG9ydERvYy5fdW5zY29wZWRTdHlsZSA9IHN0eWxlO1xuICAgICAgfSBlbHNlIGlmICghaW1wb3J0RG9jLl9zdHlsZSkge1xuICAgICAgICBpbXBvcnREb2MuX3N0eWxlID0gc3R5bGVGb3JJbXBvcnQoaW1wb3J0RG9jKTtcbiAgICAgIH1cbiAgICAgIHN0eWxlcy5wdXNoKHVuc2NvcGVkID8gaW1wb3J0RG9jLl91bnNjb3BlZFN0eWxlIDogaW1wb3J0RG9jLl9zdHlsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXM7XG59XG5cbi8qKlxuICpcbiAqIFJldHVybnMgQ1NTIHRleHQgb2Ygc3R5bGVzIGluIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgYGRvbS1tb2R1bGVgcy5cbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHVzZSBgc3R5bGVzRnJvbU1vZHVsZXNgIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZHMgTGlzdCBvZiBkb20tbW9kdWxlIGlkJ3Mgd2l0aGluIHdoaWNoIHRvXG4gKiBzZWFyY2ggZm9yIGNzcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29uY2F0ZW5hdGVkIENTUyBjb250ZW50IGZyb20gc3BlY2lmaWVkIGBkb20tbW9kdWxlYHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21Nb2R1bGVzKG1vZHVsZUlkcykge1xuIGxldCBtb2R1bGVzID0gbW9kdWxlSWRzLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuIGxldCBjc3NUZXh0ID0gJyc7XG4gZm9yIChsZXQgaT0wOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgY3NzVGV4dCArPSBjc3NGcm9tTW9kdWxlKG1vZHVsZXNbaV0pO1xuIH1cbiByZXR1cm4gY3NzVGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIENTUyB0ZXh0IG9mIHN0eWxlcyBpbiBhIGdpdmVuIGBkb20tbW9kdWxlYC4gIENTUyBpbiBhIGBkb20tbW9kdWxlYFxuICogY2FuIGNvbWUgZWl0aGVyIGZyb20gYDxzdHlsZT5gcyB3aXRoaW4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCwgb3IgZWxzZVxuICogZnJvbSBvbmUgb3IgbW9yZSBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmAgbGlua3Mgb3V0c2lkZSB0aGVcbiAqIHRlbXBsYXRlLlxuICpcbiAqIEFueSBgPHN0eWxlcz5gIHByb2Nlc3NlZCBhcmUgcmVtb3ZlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uLlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCwgdXNlIGBzdHlsZUZyb21Nb2R1bGVgIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCBkb20tbW9kdWxlIGlkIHRvIGdhdGhlciBzdHlsZXMgZnJvbVxuICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlKG1vZHVsZUlkKSB7XG4gIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgaWYgKG0gJiYgbS5fY3NzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW9kdWxlIGltcG9ydHM6IDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5cbiAgICBsZXQgY3NzVGV4dCA9IF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtKTtcbiAgICAvLyBpbmNsdWRlIGNzcyBmcm9tIHRoZSBmaXJzdCB0ZW1wbGF0ZSBpbiB0aGUgbW9kdWxlXG4gICAgbGV0IHQgPSAvKiogQHR5cGUgez9IVE1MVGVtcGxhdGVFbGVtZW50fSAqLyhtLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpO1xuICAgIGlmICh0KSB7XG4gICAgICBjc3NUZXh0ICs9IGNzc0Zyb21UZW1wbGF0ZSh0LFxuICAgICAgICAvKiogQHR5cGUge3RlbXBsYXRlV2l0aEFzc2V0UGF0aH0gKi8obSkuYXNzZXRwYXRoKTtcbiAgICB9XG4gICAgbS5fY3NzVGV4dCA9IGNzc1RleHQgfHwgbnVsbDtcbiAgfVxuICBpZiAoIW0pIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHN0eWxlIGRhdGEgaW4gbW9kdWxlIG5hbWVkJywgbW9kdWxlSWQpO1xuICB9XG4gIHJldHVybiBtICYmIG0uX2Nzc1RleHQgfHwgJyc7XG59XG5cbi8qKlxuICogUmV0dXJucyBDU1MgdGV4dCBvZiBgPHN0eWxlcz5gIHdpdGhpbiBhIGdpdmVuIHRlbXBsYXRlLlxuICpcbiAqIEFueSBgPHN0eWxlcz5gIHByb2Nlc3NlZCBhcmUgcmVtb3ZlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uLlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCwgdXNlIGBzdHlsZUZyb21UZW1wbGF0ZWAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gZ2F0aGVyIHN0eWxlcyBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBzcGVjaWZpZWQgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkge1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBjb25zdCBlJCA9IHN0eWxlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSk7XG4gIC8vIGlmIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSwgZ2V0IGNvbnRlbnQgZnJvbSBpdHMgLmNvbnRlbnRcbiAgZm9yIChsZXQgaT0wOyBpIDwgZSQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZSA9IGUkW2ldO1xuICAgIGlmIChlLnBhcmVudE5vZGUpIHtcbiAgICAgIGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTtcbiAgICB9XG4gICAgY3NzVGV4dCArPSBlLnRleHRDb250ZW50O1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG4vKipcbiAqIFJldHVybnMgQ1NTIHRleHQgZnJvbSBzdHlsZXNoZWV0cyBsb2FkZWQgdmlhIGA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+YFxuICogbGlua3Mgd2l0aGluIHRoZSBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgLlxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQsIHVzZSBgc3R5bGVzRnJvbU1vZHVsZUltcG9ydHNgIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgSWQgb2YgYGRvbS1tb2R1bGVgIHRvIGdhdGhlciBDU1MgZnJvbVxuICogQHJldHVybiB7c3RyaW5nfSBDb25jYXRlbmF0ZWQgQ1NTIGNvbnRlbnQgZnJvbSBsaW5rcyBpbiBzcGVjaWZpZWQgYGRvbS1tb2R1bGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIHJldHVybiBtID8gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG0pIDogJyc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBtb2R1bGUgZG9tLW1vZHVsZSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBgPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPmAgc3R5bGVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvbmNhdGVuYXRlZCBDU1MgY29udGVudCBmcm9tIGxpbmtzIGluIHRoZSBkb20tbW9kdWxlXG4gKi9cbmZ1bmN0aW9uIF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGUpIHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgbGV0IHN0eWxlcyA9IF9zdHlsZXNGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGUpO1xuICBmb3IgKGxldCBpPTA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjc3NUZXh0ICs9IHN0eWxlc1tpXS50ZXh0Q29udGVudDtcbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/style-gather.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/telemetry.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/telemetry.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dumpRegistrations\": () => (/* binding */ dumpRegistrations),\n/* harmony export */   \"incrementInstanceCount\": () => (/* binding */ incrementInstanceCount),\n/* harmony export */   \"instanceCount\": () => (/* binding */ instanceCount),\n/* harmony export */   \"register\": () => (/* binding */ register),\n/* harmony export */   \"registrations\": () => (/* binding */ registrations)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Total number of Polymer element instances created.\n * @type {number}\n */\nlet instanceCount = 0;\nfunction incrementInstanceCount() {\n  instanceCount++;\n}\n\n/**\n * Array of Polymer element classes that have been finalized.\n * @type {!Array<!PolymerElementConstructor>}\n */\nconst registrations = [];\n\n/**\n * @param {!PolymerElementConstructor} prototype Element prototype to log\n * @private\n */\nfunction _regLog(prototype) {\n  console.log('[' + /** @type {?} */prototype.is + ']: registered');\n}\n\n/**\n * Registers a class prototype for telemetry purposes.\n * @param {!PolymerElementConstructor} prototype Element prototype to register\n * @protected\n */\nfunction register(prototype) {\n  registrations.push(prototype);\n}\n\n/**\n * Logs all elements registered with an `is` to the console.\n * @public\n */\nfunction dumpRegistrations() {\n  registrations.forEach(_regLog);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZWxlbWV0cnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvdGVsZW1ldHJ5LmpzPzE4YWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyoqXG4gKiBUb3RhbCBudW1iZXIgb2YgUG9seW1lciBlbGVtZW50IGluc3RhbmNlcyBjcmVhdGVkLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGxldCBpbnN0YW5jZUNvdW50ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudEluc3RhbmNlQ291bnQoKSB7XG4gIGluc3RhbmNlQ291bnQrKztcbn1cblxuLyoqXG4gKiBBcnJheSBvZiBQb2x5bWVyIGVsZW1lbnQgY2xhc3NlcyB0aGF0IGhhdmUgYmVlbiBmaW5hbGl6ZWQuXG4gKiBAdHlwZSB7IUFycmF5PCFQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBbXTtcblxuLyoqXG4gKiBAcGFyYW0geyFQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBwcm90b3R5cGUgRWxlbWVudCBwcm90b3R5cGUgdG8gbG9nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVnTG9nKHByb3RvdHlwZSkge1xuICBjb25zb2xlLmxvZygnWycgKyAvKiogQHR5cGUgez99ICovKHByb3RvdHlwZSkuaXMgKyAnXTogcmVnaXN0ZXJlZCcpO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGNsYXNzIHByb3RvdHlwZSBmb3IgdGVsZW1ldHJ5IHB1cnBvc2VzLlxuICogQHBhcmFtIHshUG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0gcHJvdG90eXBlIEVsZW1lbnQgcHJvdG90eXBlIHRvIHJlZ2lzdGVyXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcihwcm90b3R5cGUpIHtcbiAgcmVnaXN0cmF0aW9ucy5wdXNoKHByb3RvdHlwZSk7XG59XG5cbi8qKlxuICogTG9ncyBhbGwgZWxlbWVudHMgcmVnaXN0ZXJlZCB3aXRoIGFuIGBpc2AgdG8gdGhlIGNvbnNvbGUuXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkdW1wUmVnaXN0cmF0aW9ucygpIHtcbiAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKF9yZWdMb2cpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/telemetry.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/templatize.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/templatize.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TemplateInstanceBase\": () => (/* binding */ TemplateInstanceBase),\n/* harmony export */   \"modelForElement\": () => (/* binding */ modelForElement),\n/* harmony export */   \"showHideChildren\": () => (/* binding */ showHideChildren),\n/* harmony export */   \"templatize\": () => (/* binding */ templatize)\n/* harmony export */ });\n/* harmony import */ var _boot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./boot.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/boot.js\");\n/* harmony import */ var _mixins_property_effects_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mixins/property-effects.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/property-effects.js\");\n/* harmony import */ var _mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mixins/mutable-data.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/mutable-data.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/settings.js\");\n/* harmony import */ var _wrap_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrap.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module for preparing and stamping instances of templates that utilize\n * Polymer's data-binding and declarative event listener features.\n *\n * Example:\n *\n *     // Get a template from somewhere, e.g. light DOM\n *     let template = this.querySelector('template');\n *     // Prepare the template\n *     let TemplateClass = Templatize.templatize(template);\n *     // Instance the template with an initial data model\n *     let instance = new TemplateClass({myProp: 'initial'});\n *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM\n *     this.shadowRoot.appendChild(instance.root);\n *     // Changing a property on the instance will propagate to bindings\n *     // in the template\n *     instance.myProp = 'new value';\n *\n * The `options` dictionary passed to `templatize` allows for customizing\n * features of the generated template class, including how outer-scope host\n * properties should be forwarded into template instances, how any instance\n * properties added into the template's scope should be notified out to\n * the host, and whether the instance should be decorated as a \"parent model\"\n * of any event handlers.\n *\n *     // Customize property forwarding and event model decoration\n *     let TemplateClass = Templatize.templatize(template, this, {\n *       parentModel: true,\n *       forwardHostProp(property, value) {...},\n *       instanceProps: {...},\n *       notifyInstanceProp(instance, property, value) {...},\n *     });\n *\n * @summary Module for preparing and stamping instances of templates\n *   utilizing Polymer templating features.\n */\n\n\n\n\n\n\n\n// Base class for HTMLTemplateElement extension that has property effects\n// machinery for propagating host properties to children. This is an ES5\n// class only because Babel (incorrectly) requires super() in the class\n// constructor even though no `this` is used and it returns an instance.\nlet newInstance = null;\n\n/**\n * @constructor\n * @extends {HTMLTemplateElement}\n * @private\n */\nfunction HTMLTemplateElementExtension() {\n  return newInstance;\n}\nHTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {\n  constructor: {\n    value: HTMLTemplateElementExtension,\n    writable: true\n  }\n});\n\n/**\n * @constructor\n * @implements {Polymer_PropertyEffects}\n * @extends {HTMLTemplateElementExtension}\n * @private\n */\nconst DataTemplate = (0,_mixins_property_effects_js__WEBPACK_IMPORTED_MODULE_1__.PropertyEffects)(HTMLTemplateElementExtension);\n\n/**\n * @constructor\n * @implements {Polymer_MutableData}\n * @extends {DataTemplate}\n * @private\n */\nconst MutableDataTemplate = (0,_mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_2__.MutableData)(DataTemplate);\n\n// Applies a DataTemplate subclass to a <template> instance\nfunction upgradeTemplate(template, constructor) {\n  newInstance = template;\n  Object.setPrototypeOf(template, constructor.prototype);\n  new constructor();\n  newInstance = null;\n}\n\n/**\n * Base class for TemplateInstance.\n * @constructor\n * @extends {HTMLElement}\n * @implements {Polymer_PropertyEffects}\n * @private\n */\nconst templateInstanceBase = (0,_mixins_property_effects_js__WEBPACK_IMPORTED_MODULE_1__.PropertyEffects)(class {});\nfunction showHideChildren(hide, children) {\n  for (let i = 0; i < children.length; i++) {\n    let n = children[i];\n    // Ignore non-changes\n    if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\n      // clear and restore text\n      if (n.nodeType === Node.TEXT_NODE) {\n        if (hide) {\n          n.__polymerTextContent__ = n.textContent;\n          n.textContent = '';\n        } else {\n          n.textContent = n.__polymerTextContent__;\n        }\n        // remove and replace slot\n      } else if (n.localName === 'slot') {\n        if (hide) {\n          n.__polymerReplaced__ = document.createComment('hidden-slot');\n          (0,_wrap_js__WEBPACK_IMPORTED_MODULE_4__.wrap)((0,_wrap_js__WEBPACK_IMPORTED_MODULE_4__.wrap)(n).parentNode).replaceChild(n.__polymerReplaced__, n);\n        } else {\n          const replace = n.__polymerReplaced__;\n          if (replace) {\n            (0,_wrap_js__WEBPACK_IMPORTED_MODULE_4__.wrap)((0,_wrap_js__WEBPACK_IMPORTED_MODULE_4__.wrap)(replace).parentNode).replaceChild(n, replace);\n          }\n        }\n      }\n      // hide and show nodes\n      else if (n.style) {\n        if (hide) {\n          n.__polymerDisplay__ = n.style.display;\n          n.style.display = 'none';\n        } else {\n          n.style.display = n.__polymerDisplay__;\n        }\n      }\n    }\n    n.__hideTemplateChildren__ = hide;\n    if (n._showHideChildren) {\n      n._showHideChildren(hide);\n    }\n  }\n}\n\n/**\n * @polymer\n * @customElement\n * @appliesMixin PropertyEffects\n * @unrestricted\n */\nclass TemplateInstanceBase extends templateInstanceBase {\n  constructor(props) {\n    super();\n    this._configureProperties(props);\n    /** @type {!StampedTemplate} */\n    this.root = this._stampTemplate(this.__dataHost);\n    // Save list of stamped children\n    let children = [];\n    /** @suppress {invalidCasts} */\n    this.children = /** @type {!NodeList} */children;\n    // Polymer 1.x did not use `Polymer.dom` here so not bothering.\n    for (let n = this.root.firstChild; n; n = n.nextSibling) {\n      children.push(n);\n      n.__templatizeInstance = this;\n    }\n    if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {\n      this._showHideChildren(true);\n    }\n    // Flush props only when props are passed if instance props exist\n    // or when there isn't instance props.\n    let options = this.__templatizeOptions;\n    if (props && options.instanceProps || !options.instanceProps) {\n      this._enableProperties();\n    }\n  }\n  /**\n   * Configure the given `props` by calling `_setPendingProperty`. Also\n   * sets any properties stored in `__hostProps`.\n   * @private\n   * @param {Object} props Object of property name-value pairs to set.\n   * @return {void}\n   */\n  _configureProperties(props) {\n    let options = this.__templatizeOptions;\n    if (options.forwardHostProp) {\n      for (let hprop in this.__hostProps) {\n        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);\n      }\n    }\n    // Any instance props passed in the constructor will overwrite host props;\n    // normally this would be a user error but we don't specifically filter them\n    for (let iprop in props) {\n      this._setPendingProperty(iprop, props[iprop]);\n    }\n  }\n  /**\n   * Forwards a host property to this instance.  This method should be\n   * called on instances from the `options.forwardHostProp` callback\n   * to propagate changes of host properties to each instance.\n   *\n   * Note this method enqueues the change, which are flushed as a batch.\n   *\n   * @param {string} prop Property or path name\n   * @param {*} value Value of the property to forward\n   * @return {void}\n   */\n  forwardHostProp(prop, value) {\n    if (this._setPendingPropertyOrPath(prop, value, false, true)) {\n      this.__dataHost._enqueueClient(this);\n    }\n  }\n\n  /**\n   * Override point for adding custom or simulated event handling.\n   *\n   * @override\n   * @param {!Node} node Node to add event listener to\n   * @param {string} eventName Name of event\n   * @param {function(!Event):void} handler Listener function to add\n   * @return {void}\n   */\n  _addEventListenerToNode(node, eventName, handler) {\n    if (this._methodHost && this.__templatizeOptions.parentModel) {\n      // If this instance should be considered a parent model, decorate\n      // events this template instance as `model`\n      this._methodHost._addEventListenerToNode(node, eventName, e => {\n        e.model = this;\n        handler(e);\n      });\n    } else {\n      // Otherwise delegate to the template's host (which could be)\n      // another template instance\n      let templateHost = this.__dataHost.__dataHost;\n      if (templateHost) {\n        templateHost._addEventListenerToNode(node, eventName, handler);\n      }\n    }\n  }\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hide Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n  _showHideChildren(hide) {\n    showHideChildren(hide, this.children);\n  }\n  /**\n   * Overrides default property-effects implementation to intercept\n   * textContent bindings while children are \"hidden\" and cache in\n   * private storage for later retrieval.\n   *\n   * @override\n   * @param {!Node} node The node to set a property on\n   * @param {string} prop The property to set\n   * @param {*} value The value to set\n   * @return {void}\n   * @protected\n   */\n  _setUnmanagedPropertyToNode(node, prop, value) {\n    if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {\n      node.__polymerTextContent__ = value;\n    } else {\n      super._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n  /**\n   * Find the parent model of this template instance.  The parent model\n   * is either another templatize instance that had option `parentModel: true`,\n   * or else the host element.\n   *\n   * @return {!Polymer_PropertyEffects} The parent model of this instance\n   */\n  get parentModel() {\n    let model = this.__parentModel;\n    if (!model) {\n      let options;\n      model = this;\n      do {\n        // A template instance's `__dataHost` is a <template>\n        // `model.__dataHost.__dataHost` is the template's host\n        model = model.__dataHost.__dataHost;\n      } while ((options = model.__templatizeOptions) && !options.parentModel);\n      this.__parentModel = model;\n    }\n    return model;\n  }\n\n  /**\n   * Stub of HTMLElement's `dispatchEvent`, so that effects that may\n   * dispatch events safely no-op.\n   *\n   * @param {Event} event Event to dispatch\n   * @return {boolean} Always true.\n   * @override\n   */\n  dispatchEvent(event) {\n    // eslint-disable-line no-unused-vars\n    return true;\n  }\n}\n\n/** @type {!DataTemplate} */\nTemplateInstanceBase.prototype.__dataHost;\n/** @type {!TemplatizeOptions} */\nTemplateInstanceBase.prototype.__templatizeOptions;\n/** @type {!Polymer_PropertyEffects} */\nTemplateInstanceBase.prototype._methodHost;\n/** @type {!Object} */\nTemplateInstanceBase.prototype.__templatizeOwner;\n/** @type {!Object} */\nTemplateInstanceBase.prototype.__hostProps;\n\n/**\n * @constructor\n * @extends {TemplateInstanceBase}\n * @implements {Polymer_MutableData}\n * @private\n */\nconst MutableTemplateInstanceBase = (0,_mixins_mutable_data_js__WEBPACK_IMPORTED_MODULE_2__.MutableData)(\n// This cast shouldn't be neccessary, but Closure doesn't understand that\n// TemplateInstanceBase is a constructor function.\n/** @type {function(new:TemplateInstanceBase)} */\nTemplateInstanceBase);\nfunction findMethodHost(template) {\n  // Technically this should be the owner of the outermost template.\n  // In shadow dom, this is always getRootNode().host, but we can\n  // approximate this via cooperation with our dataHost always setting\n  // `_methodHost` as long as there were bindings (or id's) on this\n  // instance causing it to get a dataHost.\n  let templateHost = template.__dataHost;\n  return templateHost && templateHost._methodHost || templateHost;\n}\n\n/* eslint-disable valid-jsdoc */\n/**\n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\nfunction createTemplatizerClass(template, templateInfo, options) {\n  /**\n   * @constructor\n   * @extends {TemplateInstanceBase}\n   */\n  let templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;\n\n  // Affordance for global mixins onto TemplatizeInstance\n  if (templatize.mixin) {\n    templatizerBase = templatize.mixin(templatizerBase);\n  }\n\n  /**\n   * Anonymous class created by the templatize\n   * @constructor\n   * @private\n   */\n  let klass = class extends templatizerBase {};\n  /** @override */\n  klass.prototype.__templatizeOptions = options;\n  klass.prototype._bindTemplate(template);\n  addNotifyEffects(klass, template, templateInfo, options);\n  return klass;\n}\n\n/**\n * Adds propagate effects from the template to the template instance for\n * properties that the host binds to the template using the `_host_` prefix.\n *\n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\nfunction addPropagateEffects(target, templateInfo, options, methodHost) {\n  let userForwardHostProp = options.forwardHostProp;\n  if (userForwardHostProp && templateInfo.hasHostProps) {\n    // Under the `removeNestedTemplates` optimization, a custom element like\n    // `dom-if` or `dom-repeat` can itself be treated as the \"template\"; this\n    // flag is used to switch between upgrading a `<template>` to be a property\n    // effects client vs. adding the effects directly to the custom element\n    const isTemplate = target.localName == 'template';\n    // Provide data API and property effects on memoized template class\n    let klass = templateInfo.templatizeTemplateClass;\n    if (!klass) {\n      if (isTemplate) {\n        /**\n         * @constructor\n         * @extends {DataTemplate}\n         */\n        let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;\n\n        // NOTE: due to https://github.com/google/closure-compiler/issues/2928,\n        // combining the next two lines into one assignment causes a spurious\n        // type error.\n        /** @private */\n        class TemplatizedTemplate extends templatizedBase {}\n        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;\n      } else {\n        /**\n         * @constructor\n         * @extends {PolymerElement}\n         */\n        const templatizedBase = target.constructor;\n\n        // Create a cached subclass of the base custom element class onto which\n        // to put the template-specific propagate effects\n        // NOTE: due to https://github.com/google/closure-compiler/issues/2928,\n        // combining the next two lines into one assignment causes a spurious\n        // type error.\n        /** @private */\n        class TemplatizedTemplateExtension extends templatizedBase {}\n        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplateExtension;\n      }\n      // Add template - >instances effects\n      // and host <- template effects\n      let hostProps = templateInfo.hostProps;\n      for (let prop in hostProps) {\n        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, {\n          fn: createForwardHostPropEffect(prop, userForwardHostProp)\n        });\n        klass.prototype._createNotifyingProperty('_host_' + prop);\n      }\n      if (_settings_js__WEBPACK_IMPORTED_MODULE_3__.legacyWarnings && methodHost) {\n        warnOnUndeclaredProperties(templateInfo, options, methodHost);\n      }\n    }\n    // Mix any pre-bound data into __data; no need to flush this to\n    // instances since they pull from the template at instance-time\n    if (target.__dataProto) {\n      // Note, generally `__dataProto` could be chained, but it's guaranteed\n      // to not be since this is a vanilla template we just added effects to\n      Object.assign(target.__data, target.__dataProto);\n    }\n    if (isTemplate) {\n      upgradeTemplate(target, klass);\n      // Clear any pending data for performance\n      target.__dataTemp = {};\n      target.__dataPending = null;\n      target.__dataOld = null;\n      target._enableProperties();\n    } else {\n      // Swizzle the cached subclass prototype onto the custom element\n      Object.setPrototypeOf(target, klass.prototype);\n      // Check for any pre-bound instance host properties, and do the\n      // instance property delete/assign dance for those (directly into data;\n      // not need to go through accessor since they are pulled at instance time)\n      const hostProps = templateInfo.hostProps;\n      for (let prop in hostProps) {\n        prop = '_host_' + prop;\n        if (prop in target) {\n          const val = target[prop];\n          delete target[prop];\n          target.__data[prop] = val;\n        }\n      }\n    }\n  }\n}\n/* eslint-enable valid-jsdoc */\n\nfunction createForwardHostPropEffect(hostProp, userForwardHostProp) {\n  return function forwardHostProp(template, prop, props) {\n    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);\n  };\n}\nfunction addNotifyEffects(klass, template, templateInfo, options) {\n  let hostProps = templateInfo.hostProps || {};\n  for (let iprop in options.instanceProps) {\n    delete hostProps[iprop];\n    let userNotifyInstanceProp = options.notifyInstanceProp;\n    if (userNotifyInstanceProp) {\n      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {\n        fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)\n      });\n    }\n  }\n  if (options.forwardHostProp && template.__dataHost) {\n    for (let hprop in hostProps) {\n      // As we're iterating hostProps in this function, note whether\n      // there were any, for an optimization in addPropagateEffects\n      if (!templateInfo.hasHostProps) {\n        templateInfo.hasHostProps = true;\n      }\n      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {\n        fn: createNotifyHostPropEffect()\n      });\n    }\n  }\n}\nfunction createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {\n  return function notifyInstanceProp(inst, prop, props) {\n    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);\n  };\n}\nfunction createNotifyHostPropEffect() {\n  return function notifyHostProp(inst, prop, props) {\n    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);\n  };\n}\n\n/**\n * Returns an anonymous `PropertyEffects` class bound to the\n * `<template>` provided.  Instancing the class will result in the\n * template being stamped into a document fragment stored as the instance's\n * `root` property, after which it can be appended to the DOM.\n *\n * Templates may utilize all Polymer data-binding features as well as\n * declarative event listeners.  Event listeners and inline computing\n * functions in the template will be called on the host of the template.\n *\n * The constructor returned takes a single argument dictionary of initial\n * property values to propagate into template bindings.  Additionally\n * host properties can be forwarded in, and instance properties can be\n * notified out by providing optional callbacks in the `options` dictionary.\n *\n * Valid configuration in `options` are as follows:\n *\n * - `forwardHostProp(property, value)`: Called when a property referenced\n *   in the template changed on the template's host. As this library does\n *   not retain references to templates instanced by the user, it is the\n *   templatize owner's responsibility to forward host property changes into\n *   user-stamped instances.  The `instance.forwardHostProp(property, value)`\n *    method on the generated class should be called to forward host\n *   properties into the template to prevent unnecessary property-changed\n *   notifications. Any properties referenced in the template that are not\n *   defined in `instanceProps` will be notified up to the template's host\n *   automatically.\n * - `instanceProps`: Dictionary of property names that will be added\n *   to the instance by the templatize owner.  These properties shadow any\n *   host properties, and changes within the template to these properties\n *   will result in `notifyInstanceProp` being called.\n * - `mutableData`: When `true`, the generated class will skip strict\n *   dirty-checking for objects and arrays (always consider them to be\n *   \"dirty\").\n * - `notifyInstanceProp(instance, property, value)`: Called when\n *   an instance property changes.  Users may choose to call `notifyPath`\n *   on e.g. the owner to notify the change.\n * - `parentModel`: When `true`, events handled by declarative event listeners\n *   (`on-event=\"handler\"`) will be decorated with a `model` property pointing\n *   to the template instance that stamped it.  It will also be returned\n *   from `instance.parentModel` in cases where template instance nesting\n *   causes an inner model to shadow an outer model.\n *\n * All callbacks are called bound to the `owner`. Any context\n * needed for the callbacks (such as references to `instances` stamped)\n * should be stored on the `owner` such that they can be retrieved via\n * `this`.\n *\n * When `options.forwardHostProp` is declared as an option, any properties\n * referenced in the template will be automatically forwarded from the host of\n * the `<template>` to instances, with the exception of any properties listed in\n * the `options.instanceProps` object.  `instanceProps` are assumed to be\n * managed by the owner of the instances, either passed into the constructor\n * or set after the fact.  Note, any properties passed into the constructor will\n * always be set to the instance (regardless of whether they would normally\n * be forwarded from the host).\n *\n * Note that `templatize()` can be run only once for a given `<template>`.\n * Further calls will result in an error. Also, there is a special\n * behavior if the template was duplicated through a mechanism such as\n * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to\n * `templatize()` return the same class for all duplicates of a template.\n * The class returned from `templatize()` is generated only once using\n * the `options` from the first call. This means that any `options`\n * provided to subsequent calls will be ignored. Therefore, it is very\n * important not to close over any variables inside the callbacks. Also,\n * arrow functions must be avoided because they bind the outer `this`.\n * Inside the callbacks, any contextual information can be accessed\n * through `this`, which points to the `owner`.\n *\n * @param {!HTMLTemplateElement} template Template to templatize\n * @param {Polymer_PropertyEffects=} owner Owner of the template instances;\n *   any optional callbacks will be bound to this owner.\n * @param {Object=} options Options dictionary (see summary for details)\n * @return {function(new:TemplateInstanceBase, Object=)} Generated class bound\n *   to the template provided\n * @suppress {invalidCasts}\n */\nfunction templatize(template, owner, options) {\n  // Under strictTemplatePolicy, the templatized element must be owned\n  // by a (trusted) Polymer element, indicated by existence of _methodHost;\n  // e.g. for dom-if & dom-repeat in main document, _methodHost is null\n  if (_settings_js__WEBPACK_IMPORTED_MODULE_3__.strictTemplatePolicy && !findMethodHost(template)) {\n    throw new Error('strictTemplatePolicy: template owner not trusted');\n  }\n  options = /** @type {!TemplatizeOptions} */options || {};\n  if (template.__templatizeOwner) {\n    throw new Error('A <template> can only be templatized once');\n  }\n  template.__templatizeOwner = owner;\n  const ctor = owner ? owner.constructor : TemplateInstanceBase;\n  let templateInfo = ctor._parseTemplate(template);\n  // Get memoized base class for the prototypical template, which\n  // includes property effects for binding template & forwarding\n  /**\n   * @constructor\n   * @extends {TemplateInstanceBase}\n   */\n  let baseClass = templateInfo.templatizeInstanceClass;\n  if (!baseClass) {\n    baseClass = createTemplatizerClass(template, templateInfo, options);\n    templateInfo.templatizeInstanceClass = baseClass;\n  }\n  const methodHost = findMethodHost(template);\n  // Host property forwarding must be installed onto template instance\n  addPropagateEffects(template, templateInfo, options, methodHost);\n  // Subclass base class and add reference for this specific template\n  /** @private */\n  let klass = class TemplateInstance extends baseClass {};\n  /** @override */\n  klass.prototype._methodHost = methodHost;\n  /** @override */\n  klass.prototype.__dataHost = /** @type {!DataTemplate} */template;\n  /** @override */\n  klass.prototype.__templatizeOwner = /** @type {!Object} */owner;\n  /** @override */\n  klass.prototype.__hostProps = templateInfo.hostProps;\n  klass = /** @type {function(new:TemplateInstanceBase)} */klass; //eslint-disable-line no-self-assign\n  return klass;\n}\nfunction warnOnUndeclaredProperties(templateInfo, options, methodHost) {\n  const declaredProps = methodHost.constructor._properties;\n  const {\n    propertyEffects\n  } = templateInfo;\n  const {\n    instanceProps\n  } = options;\n  for (let prop in propertyEffects) {\n    // Ensure properties with template effects are declared on the outermost\n    // host (`methodHost`), unless they are instance props or static functions\n    if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {\n      const effects = propertyEffects[prop];\n      for (let i = 0; i < effects.length; i++) {\n        const {\n          part\n        } = effects[i].info;\n        if (!(part.signature && part.signature.static)) {\n          console.warn(`Property '${prop}' used in template but not ` + `declared in 'properties'; attribute will not be observed.`);\n          break;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Returns the template \"model\" associated with a given element, which\n * serves as the binding scope for the template instance the element is\n * contained in. A template model is an instance of\n * `TemplateInstanceBase`, and should be used to manipulate data\n * associated with this template instance.\n *\n * Example:\n *\n *   let model = modelForElement(el);\n *   if (model.index < 10) {\n *     model.set('item.checked', true);\n *   }\n *\n * @param {HTMLElement} template The model will be returned for\n *   elements stamped from this template (accepts either an HTMLTemplateElement)\n *   or a `<dom-if>`/`<dom-repeat>` element when using `removeNestedTemplates`\n *   optimization.\n * @param {Node=} node Node for which to return a template model.\n * @return {TemplateInstanceBase} Template instance representing the\n *   binding scope for the element\n */\nfunction modelForElement(template, node) {\n  let model;\n  while (node) {\n    // An element with a __templatizeInstance marks the top boundary\n    // of a scope; walk up until we find one, and then ensure that\n    // its __dataHost matches `this`, meaning this dom-repeat stamped it\n    if (model = node.__dataHost ? node : node.__templatizeInstance) {\n      // Found an element stamped by another template; keep walking up\n      // from its __dataHost\n      if (model.__dataHost != template) {\n        node = model.__dataHost;\n      } else {\n        return model;\n      }\n    } else {\n      // Still in a template scope, keep going up until\n      // a __templatizeInstance is found\n      node = (0,_wrap_js__WEBPACK_IMPORTED_MODULE_4__.wrap)(node).parentNode;\n    }\n  }\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3RlbXBsYXRpemUuanM/MDgyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgcHJlcGFyaW5nIGFuZCBzdGFtcGluZyBpbnN0YW5jZXMgb2YgdGVtcGxhdGVzIHRoYXQgdXRpbGl6ZVxuICogUG9seW1lcidzIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXIgZmVhdHVyZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICogICAgIC8vIEluc3RhbmNlIHRoZSB0ZW1wbGF0ZSB3aXRoIGFuIGluaXRpYWwgZGF0YSBtb2RlbFxuICogICAgIGxldCBpbnN0YW5jZSA9IG5ldyBUZW1wbGF0ZUNsYXNzKHtteVByb3A6ICdpbml0aWFsJ30pO1xuICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGVsZW1lbnQncyBzaGFkb3cgRE9NXG4gKiAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICogICAgIC8vIENoYW5naW5nIGEgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlIHdpbGwgcHJvcGFnYXRlIHRvIGJpbmRpbmdzXG4gKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gKlxuICogVGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5IHBhc3NlZCB0byBgdGVtcGxhdGl6ZWAgYWxsb3dzIGZvciBjdXN0b21pemluZ1xuICogZmVhdHVyZXMgb2YgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBjbGFzcywgaW5jbHVkaW5nIGhvdyBvdXRlci1zY29wZSBob3N0XG4gKiBwcm9wZXJ0aWVzIHNob3VsZCBiZSBmb3J3YXJkZWQgaW50byB0ZW1wbGF0ZSBpbnN0YW5jZXMsIGhvdyBhbnkgaW5zdGFuY2VcbiAqIHByb3BlcnRpZXMgYWRkZWQgaW50byB0aGUgdGVtcGxhdGUncyBzY29wZSBzaG91bGQgYmUgbm90aWZpZWQgb3V0IHRvXG4gKiB0aGUgaG9zdCwgYW5kIHdoZXRoZXIgdGhlIGluc3RhbmNlIHNob3VsZCBiZSBkZWNvcmF0ZWQgYXMgYSBcInBhcmVudCBtb2RlbFwiXG4gKiBvZiBhbnkgZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogICAgIC8vIEN1c3RvbWl6ZSBwcm9wZXJ0eSBmb3J3YXJkaW5nIGFuZCBldmVudCBtb2RlbCBkZWNvcmF0aW9uXG4gKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAqICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICogICAgICAgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gKiAgICAgICBpbnN0YW5jZVByb3BzOiB7Li4ufSxcbiAqICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAqICAgICB9KTtcbiAqXG4gKiBAc3VtbWFyeSBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlc1xuICogICB1dGlsaXppbmcgUG9seW1lciB0ZW1wbGF0aW5nIGZlYXR1cmVzLlxuICovXG5cbmltcG9ydCAnLi9ib290LmpzJztcblxuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuaW1wb3J0IHsgTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcbmltcG9ydCB7IHN0cmljdFRlbXBsYXRlUG9saWN5LCBsZWdhY3lXYXJuaW5ncyB9IGZyb20gJy4vc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJy4vd3JhcC5qcyc7XG5cbi8vIEJhc2UgY2xhc3MgZm9yIEhUTUxUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5zaW9uIHRoYXQgaGFzIHByb3BlcnR5IGVmZmVjdHNcbi8vIG1hY2hpbmVyeSBmb3IgcHJvcGFnYXRpbmcgaG9zdCBwcm9wZXJ0aWVzIHRvIGNoaWxkcmVuLiBUaGlzIGlzIGFuIEVTNVxuLy8gY2xhc3Mgb25seSBiZWNhdXNlIEJhYmVsIChpbmNvcnJlY3RseSkgcmVxdWlyZXMgc3VwZXIoKSBpbiB0aGUgY2xhc3Ncbi8vIGNvbnN0cnVjdG9yIGV2ZW4gdGhvdWdoIG5vIGB0aGlzYCBpcyB1c2VkIGFuZCBpdCByZXR1cm5zIGFuIGluc3RhbmNlLlxubGV0IG5ld0luc3RhbmNlID0gbnVsbDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbigpIHsgcmV0dXJuIG5ld0luc3RhbmNlOyB9XG5IVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbixcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9XG59KTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9ufVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgRGF0YVRlbXBsYXRlID0gUHJvcGVydHlFZmZlY3RzKEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24pO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gKiBAZXh0ZW5kcyB7RGF0YVRlbXBsYXRlfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgTXV0YWJsZURhdGFUZW1wbGF0ZSA9IE11dGFibGVEYXRhKERhdGFUZW1wbGF0ZSk7XG5cbi8vIEFwcGxpZXMgYSBEYXRhVGVtcGxhdGUgc3ViY2xhc3MgdG8gYSA8dGVtcGxhdGU+IGluc3RhbmNlXG5mdW5jdGlvbiB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGNvbnN0cnVjdG9yKSB7XG4gIG5ld0luc3RhbmNlID0gdGVtcGxhdGU7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZih0ZW1wbGF0ZSwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgbmV3IGNvbnN0cnVjdG9yKCk7XG4gIG5ld0luc3RhbmNlID0gbnVsbDtcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBUZW1wbGF0ZUluc3RhbmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SFRNTEVsZW1lbnR9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0ZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFByb3BlcnR5RWZmZWN0cyhjbGFzcyB7fSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG93SGlkZUNoaWxkcmVuKGhpZGUsIGNoaWxkcmVuKSB7XG4gIGZvciAobGV0IGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuID0gY2hpbGRyZW5baV07XG4gICAgLy8gSWdub3JlIG5vbi1jaGFuZ2VzXG4gICAgaWYgKEJvb2xlYW4oaGlkZSkgIT0gQm9vbGVhbihuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykpIHtcbiAgICAgIC8vIGNsZWFyIGFuZCByZXN0b3JlIHRleHRcbiAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgIG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXyA9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG4udGV4dENvbnRlbnQgPSBuLl9fcG9seW1lclRleHRDb250ZW50X187XG4gICAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBhbmQgcmVwbGFjZSBzbG90XG4gICAgICB9IGVsc2UgaWYgKG4ubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICBuLl9fcG9seW1lclJlcGxhY2VkX18gPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdoaWRkZW4tc2xvdCcpO1xuICAgICAgICAgIHdyYXAod3JhcChuKS5wYXJlbnROb2RlKS5yZXBsYWNlQ2hpbGQobi5fX3BvbHltZXJSZXBsYWNlZF9fLCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXBsYWNlID0gbi5fX3BvbHltZXJSZXBsYWNlZF9fO1xuICAgICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICB3cmFwKHdyYXAocmVwbGFjZSkucGFyZW50Tm9kZSkucmVwbGFjZUNoaWxkKG4sIHJlcGxhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaGlkZSBhbmQgc2hvdyBub2Rlc1xuICAgICAgZWxzZSBpZiAobi5zdHlsZSkge1xuICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgIG4uX19wb2x5bWVyRGlzcGxheV9fID0gbi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuLnN0eWxlLmRpc3BsYXkgPSBuLl9fcG9seW1lckRpc3BsYXlfXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyA9IGhpZGU7XG4gICAgaWYgKG4uX3Nob3dIaWRlQ2hpbGRyZW4pIHtcbiAgICAgIG4uX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBvbHltZXJcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAYXBwbGllc01peGluIFByb3BlcnR5RWZmZWN0c1xuICogQHVucmVzdHJpY3RlZFxuICovXG5jbGFzcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBleHRlbmRzIHRlbXBsYXRlSW5zdGFuY2VCYXNlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2NvbmZpZ3VyZVByb3BlcnRpZXMocHJvcHMpO1xuICAgIC8qKiBAdHlwZSB7IVN0YW1wZWRUZW1wbGF0ZX0gKi9cbiAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX19kYXRhSG9zdCk7XG4gICAgLy8gU2F2ZSBsaXN0IG9mIHN0YW1wZWQgY2hpbGRyZW5cbiAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAvKiogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9ICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IC8qKiBAdHlwZSB7IU5vZGVMaXN0fSAqLyAoY2hpbGRyZW4pO1xuICAgIC8vIFBvbHltZXIgMS54IGRpZCBub3QgdXNlIGBQb2x5bWVyLmRvbWAgaGVyZSBzbyBub3QgYm90aGVyaW5nLlxuICAgIGZvciAobGV0IG4gPSB0aGlzLnJvb3QuZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKG4pO1xuICAgICAgbi5fX3RlbXBsYXRpemVJbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fdGVtcGxhdGl6ZU93bmVyICYmXG4gICAgICB0aGlzLl9fdGVtcGxhdGl6ZU93bmVyLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykge1xuICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbih0cnVlKTtcbiAgICB9XG4gICAgLy8gRmx1c2ggcHJvcHMgb25seSB3aGVuIHByb3BzIGFyZSBwYXNzZWQgaWYgaW5zdGFuY2UgcHJvcHMgZXhpc3RcbiAgICAvLyBvciB3aGVuIHRoZXJlIGlzbid0IGluc3RhbmNlIHByb3BzLlxuICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgIGlmICgocHJvcHMgJiYgb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB8fCAhb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmUgdGhlIGdpdmVuIGBwcm9wc2AgYnkgY2FsbGluZyBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuIEFsc29cbiAgICogc2V0cyBhbnkgcHJvcGVydGllcyBzdG9yZWQgaW4gYF9faG9zdFByb3BzYC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCBvZiBwcm9wZXJ0eSBuYW1lLXZhbHVlIHBhaXJzIHRvIHNldC5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIF9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wKSB7XG4gICAgICBmb3IgKGxldCBocHJvcCBpbiB0aGlzLl9faG9zdFByb3BzKSB7XG4gICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShocHJvcCwgdGhpcy5fX2RhdGFIb3N0WydfaG9zdF8nICsgaHByb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQW55IGluc3RhbmNlIHByb3BzIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3Igd2lsbCBvdmVyd3JpdGUgaG9zdCBwcm9wcztcbiAgICAvLyBub3JtYWxseSB0aGlzIHdvdWxkIGJlIGEgdXNlciBlcnJvciBidXQgd2UgZG9uJ3Qgc3BlY2lmaWNhbGx5IGZpbHRlciB0aGVtXG4gICAgZm9yIChsZXQgaXByb3AgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShpcHJvcCwgcHJvcHNbaXByb3BdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZvcndhcmRzIGEgaG9zdCBwcm9wZXJ0eSB0byB0aGlzIGluc3RhbmNlLiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gICAqIGNhbGxlZCBvbiBpbnN0YW5jZXMgZnJvbSB0aGUgYG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wYCBjYWxsYmFja1xuICAgKiB0byBwcm9wYWdhdGUgY2hhbmdlcyBvZiBob3N0IHByb3BlcnRpZXMgdG8gZWFjaCBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSB0aGlzIG1ldGhvZCBlbnF1ZXVlcyB0aGUgY2hhbmdlLCB3aGljaCBhcmUgZmx1c2hlZCBhcyBhIGJhdGNoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBvciBwYXRoIG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gZm9yd2FyZFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICB0aGlzLl9fZGF0YUhvc3QuX2VucXVldWVDbGllbnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgTm9kZSB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTp2b2lkfSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIGFkZFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKHRoaXMuX21ldGhvZEhvc3QgJiYgdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zLnBhcmVudE1vZGVsKSB7XG4gICAgICAvLyBJZiB0aGlzIGluc3RhbmNlIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgcGFyZW50IG1vZGVsLCBkZWNvcmF0ZVxuICAgICAgLy8gZXZlbnRzIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UgYXMgYG1vZGVsYFxuICAgICAgdGhpcy5fbWV0aG9kSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgIGUubW9kZWwgPSB0aGlzO1xuICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBkZWxlZ2F0ZSB0byB0aGUgdGVtcGxhdGUncyBob3N0ICh3aGljaCBjb3VsZCBiZSlcbiAgICAgIC8vIGFub3RoZXIgdGVtcGxhdGUgaW5zdGFuY2VcbiAgICAgIGxldCB0ZW1wbGF0ZUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgIGlmICh0ZW1wbGF0ZUhvc3QpIHtcbiAgICAgICAgdGVtcGxhdGVIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTaG93cyBvciBoaWRlcyB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdG9wIGxldmVsIGNoaWxkIGVsZW1lbnRzLiBGb3JcbiAgICogdGV4dCBub2RlcywgYHRleHRDb250ZW50YCBpcyByZW1vdmVkIHdoaWxlIFwiaGlkZGVuXCIgYW5kIHJlcGxhY2VkIHdoZW5cbiAgICogXCJzaG93bi5cIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGUgU2V0IHRvIHRydWUgdG8gaGlkZSB0aGUgY2hpbGRyZW47XG4gICAqIHNldCB0byBmYWxzZSB0byBzaG93IHRoZW0uXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zaG93SGlkZUNoaWxkcmVuKGhpZGUpIHtcbiAgICBzaG93SGlkZUNoaWxkcmVuKGhpZGUsIHRoaXMuY2hpbGRyZW4pO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZGVmYXVsdCBwcm9wZXJ0eS1lZmZlY3RzIGltcGxlbWVudGF0aW9uIHRvIGludGVyY2VwdFxuICAgKiB0ZXh0Q29udGVudCBiaW5kaW5ncyB3aGlsZSBjaGlsZHJlbiBhcmUgXCJoaWRkZW5cIiBhbmQgY2FjaGUgaW5cbiAgICogcHJpdmF0ZSBzdG9yYWdlIGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChub2RlLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyAmJlxuICAgICAgICBub2RlLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFICYmIHByb3AgPT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgbm9kZS5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLl9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBwYXJlbnQgbW9kZWxcbiAgICogaXMgZWl0aGVyIGFub3RoZXIgdGVtcGxhdGl6ZSBpbnN0YW5jZSB0aGF0IGhhZCBvcHRpb24gYHBhcmVudE1vZGVsOiB0cnVlYCxcbiAgICogb3IgZWxzZSB0aGUgaG9zdCBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IFRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHBhcmVudE1vZGVsKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMuX19wYXJlbnRNb2RlbDtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIG1vZGVsID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gQSB0ZW1wbGF0ZSBpbnN0YW5jZSdzIGBfX2RhdGFIb3N0YCBpcyBhIDx0ZW1wbGF0ZT5cbiAgICAgICAgLy8gYG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdGAgaXMgdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICAgICAgICBtb2RlbCA9IG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgIH0gd2hpbGUgKChvcHRpb25zID0gbW9kZWwuX190ZW1wbGF0aXplT3B0aW9ucykgJiYgIW9wdGlvbnMucGFyZW50TW9kZWwpO1xuICAgICAgdGhpcy5fX3BhcmVudE1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHViIG9mIEhUTUxFbGVtZW50J3MgYGRpc3BhdGNoRXZlbnRgLCBzbyB0aGF0IGVmZmVjdHMgdGhhdCBtYXlcbiAgICogZGlzcGF0Y2ggZXZlbnRzIHNhZmVseSBuby1vcC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgdG8gZGlzcGF0Y2hcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQWx3YXlzIHRydWUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKiogQHR5cGUgeyFEYXRhVGVtcGxhdGV9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX19kYXRhSG9zdDtcbi8qKiBAdHlwZSB7IVRlbXBsYXRpemVPcHRpb25zfSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4vKiogQHR5cGUgeyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fbWV0aG9kSG9zdDtcbi8qKiBAdHlwZSB7IU9iamVjdH0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPd25lcjtcbi8qKiBAdHlwZSB7IU9iamVjdH0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2hvc3RQcm9wcztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlID0gTXV0YWJsZURhdGEoXG4gICAgLy8gVGhpcyBjYXN0IHNob3VsZG4ndCBiZSBuZWNjZXNzYXJ5LCBidXQgQ2xvc3VyZSBkb2Vzbid0IHVuZGVyc3RhbmQgdGhhdFxuICAgIC8vIFRlbXBsYXRlSW5zdGFuY2VCYXNlIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UpfSAqLyAoVGVtcGxhdGVJbnN0YW5jZUJhc2UpKTtcblxuZnVuY3Rpb24gZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpIHtcbiAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAvLyBhcHByb3hpbWF0ZSB0aGlzIHZpYSBjb29wZXJhdGlvbiB3aXRoIG91ciBkYXRhSG9zdCBhbHdheXMgc2V0dGluZ1xuICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICBsZXQgdGVtcGxhdGVIb3N0ID0gdGVtcGxhdGUuX19kYXRhSG9zdDtcbiAgcmV0dXJuIHRlbXBsYXRlSG9zdCAmJiB0ZW1wbGF0ZUhvc3QuX21ldGhvZEhvc3QgfHwgdGVtcGxhdGVIb3N0O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuLyoqXG4gKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX1cbiAgICovXG4gIGxldCB0ZW1wbGF0aXplckJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID9cbiAgICBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgOiBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcblxuICAvLyBBZmZvcmRhbmNlIGZvciBnbG9iYWwgbWl4aW5zIG9udG8gVGVtcGxhdGl6ZUluc3RhbmNlXG4gIGlmICh0ZW1wbGF0aXplLm1peGluKSB7XG4gICAgdGVtcGxhdGl6ZXJCYXNlID0gdGVtcGxhdGl6ZS5taXhpbih0ZW1wbGF0aXplckJhc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFub255bW91cyBjbGFzcyBjcmVhdGVkIGJ5IHRoZSB0ZW1wbGF0aXplXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbGV0IGtsYXNzID0gY2xhc3MgZXh0ZW5kcyB0ZW1wbGF0aXplckJhc2UgeyB9O1xuICAvKiogQG92ZXJyaWRlICovXG4gIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zID0gb3B0aW9ucztcbiAga2xhc3MucHJvdG90eXBlLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgcmV0dXJuIGtsYXNzO1xufVxuXG4vKipcbiAqIEFkZHMgcHJvcGFnYXRlIGVmZmVjdHMgZnJvbSB0aGUgdGVtcGxhdGUgdG8gdGhlIHRlbXBsYXRlIGluc3RhbmNlIGZvclxuICogcHJvcGVydGllcyB0aGF0IHRoZSBob3N0IGJpbmRzIHRvIHRoZSB0ZW1wbGF0ZSB1c2luZyB0aGUgYF9ob3N0X2AgcHJlZml4LlxuICpcbiAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAqL1xuZnVuY3Rpb24gYWRkUHJvcGFnYXRlRWZmZWN0cyh0YXJnZXQsIHRlbXBsYXRlSW5mbywgb3B0aW9ucywgbWV0aG9kSG9zdCkge1xuICBsZXQgdXNlckZvcndhcmRIb3N0UHJvcCA9IG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wO1xuICBpZiAodXNlckZvcndhcmRIb3N0UHJvcCAmJiB0ZW1wbGF0ZUluZm8uaGFzSG9zdFByb3BzKSB7XG4gICAgLy8gVW5kZXIgdGhlIGByZW1vdmVOZXN0ZWRUZW1wbGF0ZXNgIG9wdGltaXphdGlvbiwgYSBjdXN0b20gZWxlbWVudCBsaWtlXG4gICAgLy8gYGRvbS1pZmAgb3IgYGRvbS1yZXBlYXRgIGNhbiBpdHNlbGYgYmUgdHJlYXRlZCBhcyB0aGUgXCJ0ZW1wbGF0ZVwiOyB0aGlzXG4gICAgLy8gZmxhZyBpcyB1c2VkIHRvIHN3aXRjaCBiZXR3ZWVuIHVwZ3JhZGluZyBhIGA8dGVtcGxhdGU+YCB0byBiZSBhIHByb3BlcnR5XG4gICAgLy8gZWZmZWN0cyBjbGllbnQgdnMuIGFkZGluZyB0aGUgZWZmZWN0cyBkaXJlY3RseSB0byB0aGUgY3VzdG9tIGVsZW1lbnRcbiAgICBjb25zdCBpc1RlbXBsYXRlID0gdGFyZ2V0LmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnO1xuICAgIC8vIFByb3ZpZGUgZGF0YSBBUEkgYW5kIHByb3BlcnR5IGVmZmVjdHMgb24gbWVtb2l6ZWQgdGVtcGxhdGUgY2xhc3NcbiAgICBsZXQga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3M7XG4gICAgaWYgKCFrbGFzcykge1xuICAgICAgaWYgKGlzVGVtcGxhdGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyB7RGF0YVRlbXBsYXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHRlbXBsYXRpemVkQmFzZSA9XG4gICAgICAgICAgICBvcHRpb25zLm11dGFibGVEYXRhID8gTXV0YWJsZURhdGFUZW1wbGF0ZSA6IERhdGFUZW1wbGF0ZTtcblxuICAgICAgICAvLyBOT1RFOiBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8yOTI4LFxuICAgICAgICAvLyBjb21iaW5pbmcgdGhlIG5leHQgdHdvIGxpbmVzIGludG8gb25lIGFzc2lnbm1lbnQgY2F1c2VzIGEgc3B1cmlvdXNcbiAgICAgICAgLy8gdHlwZSBlcnJvci5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIGNsYXNzIFRlbXBsYXRpemVkVGVtcGxhdGUgZXh0ZW5kcyB0ZW1wbGF0aXplZEJhc2Uge31cbiAgICAgICAga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MgPSBUZW1wbGF0aXplZFRlbXBsYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAZXh0ZW5kcyB7UG9seW1lckVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB0ZW1wbGF0aXplZEJhc2UgPSB0YXJnZXQuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgY2FjaGVkIHN1YmNsYXNzIG9mIHRoZSBiYXNlIGN1c3RvbSBlbGVtZW50IGNsYXNzIG9udG8gd2hpY2hcbiAgICAgICAgLy8gdG8gcHV0IHRoZSB0ZW1wbGF0ZS1zcGVjaWZpYyBwcm9wYWdhdGUgZWZmZWN0c1xuICAgICAgICAvLyBOT1RFOiBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8yOTI4LFxuICAgICAgICAvLyBjb21iaW5pbmcgdGhlIG5leHQgdHdvIGxpbmVzIGludG8gb25lIGFzc2lnbm1lbnQgY2F1c2VzIGEgc3B1cmlvdXNcbiAgICAgICAgLy8gdHlwZSBlcnJvci5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIGNsYXNzIFRlbXBsYXRpemVkVGVtcGxhdGVFeHRlbnNpb24gZXh0ZW5kcyB0ZW1wbGF0aXplZEJhc2Uge31cbiAgICAgICAga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MgPVxuICAgICAgICAgICAgVGVtcGxhdGl6ZWRUZW1wbGF0ZUV4dGVuc2lvbjtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZSAtID5pbnN0YW5jZXMgZWZmZWN0c1xuICAgICAgLy8gYW5kIGhvc3QgPC0gdGVtcGxhdGUgZWZmZWN0c1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIGhvc3RQcm9wcykge1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KCdfaG9zdF8nICsgcHJvcCxcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLlBST1BBR0FURSxcbiAgICAgICAgICB7Zm46IGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChwcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKX0pO1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KCdfaG9zdF8nICsgcHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAobGVnYWN5V2FybmluZ3MgJiYgbWV0aG9kSG9zdCkge1xuICAgICAgICB3YXJuT25VbmRlY2xhcmVkUHJvcGVydGllcyh0ZW1wbGF0ZUluZm8sIG9wdGlvbnMsIG1ldGhvZEhvc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBNaXggYW55IHByZS1ib3VuZCBkYXRhIGludG8gX19kYXRhOyBubyBuZWVkIHRvIGZsdXNoIHRoaXMgdG9cbiAgICAvLyBpbnN0YW5jZXMgc2luY2UgdGhleSBwdWxsIGZyb20gdGhlIHRlbXBsYXRlIGF0IGluc3RhbmNlLXRpbWVcbiAgICBpZiAodGFyZ2V0Ll9fZGF0YVByb3RvKSB7XG4gICAgICAvLyBOb3RlLCBnZW5lcmFsbHkgYF9fZGF0YVByb3RvYCBjb3VsZCBiZSBjaGFpbmVkLCBidXQgaXQncyBndWFyYW50ZWVkXG4gICAgICAvLyB0byBub3QgYmUgc2luY2UgdGhpcyBpcyBhIHZhbmlsbGEgdGVtcGxhdGUgd2UganVzdCBhZGRlZCBlZmZlY3RzIHRvXG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldC5fX2RhdGEsIHRhcmdldC5fX2RhdGFQcm90byk7XG4gICAgfVxuICAgIGlmIChpc1RlbXBsYXRlKSB7XG4gICAgICB1cGdyYWRlVGVtcGxhdGUodGFyZ2V0LCBrbGFzcyk7XG4gICAgICAvLyBDbGVhciBhbnkgcGVuZGluZyBkYXRhIGZvciBwZXJmb3JtYW5jZVxuICAgICAgdGFyZ2V0Ll9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIHRhcmdldC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIHRhcmdldC5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgdGFyZ2V0Ll9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN3aXp6bGUgdGhlIGNhY2hlZCBzdWJjbGFzcyBwcm90b3R5cGUgb250byB0aGUgY3VzdG9tIGVsZW1lbnRcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIGtsYXNzLnByb3RvdHlwZSk7XG4gICAgICAvLyBDaGVjayBmb3IgYW55IHByZS1ib3VuZCBpbnN0YW5jZSBob3N0IHByb3BlcnRpZXMsIGFuZCBkbyB0aGVcbiAgICAgIC8vIGluc3RhbmNlIHByb3BlcnR5IGRlbGV0ZS9hc3NpZ24gZGFuY2UgZm9yIHRob3NlIChkaXJlY3RseSBpbnRvIGRhdGE7XG4gICAgICAvLyBub3QgbmVlZCB0byBnbyB0aHJvdWdoIGFjY2Vzc29yIHNpbmNlIHRoZXkgYXJlIHB1bGxlZCBhdCBpbnN0YW5jZSB0aW1lKVxuICAgICAgY29uc3QgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICAgIGZvciAobGV0IHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIHByb3AgPSAnX2hvc3RfJyArIHByb3A7XG4gICAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgIHRhcmdldC5fX2RhdGFbcHJvcF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuZnVuY3Rpb24gY3JlYXRlRm9yd2FyZEhvc3RQcm9wRWZmZWN0KGhvc3RQcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb3J3YXJkSG9zdFByb3AodGVtcGxhdGUsIHByb3AsIHByb3BzKSB7XG4gICAgdXNlckZvcndhcmRIb3N0UHJvcC5jYWxsKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgcHJvcC5zdWJzdHJpbmcoJ19ob3N0XycubGVuZ3RoKSwgcHJvcHNbcHJvcF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICBkZWxldGUgaG9zdFByb3BzW2lwcm9wXTtcbiAgICBsZXQgdXNlck5vdGlmeUluc3RhbmNlUHJvcCA9IG9wdGlvbnMubm90aWZ5SW5zdGFuY2VQcm9wO1xuICAgIGlmICh1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGlwcm9wLFxuICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLk5PVElGWSxcbiAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaXByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApfSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmZvcndhcmRIb3N0UHJvcCAmJiB0ZW1wbGF0ZS5fX2RhdGFIb3N0KSB7XG4gICAgZm9yIChsZXQgaHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAvLyBBcyB3ZSdyZSBpdGVyYXRpbmcgaG9zdFByb3BzIGluIHRoaXMgZnVuY3Rpb24sIG5vdGUgd2hldGhlclxuICAgICAgLy8gdGhlcmUgd2VyZSBhbnksIGZvciBhbiBvcHRpbWl6YXRpb24gaW4gYWRkUHJvcGFnYXRlRWZmZWN0c1xuICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8uaGFzSG9zdFByb3BzKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5oYXNIb3N0UHJvcHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChocHJvcCxcbiAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgIHtmbjogY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKX0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaW5zdFByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgIHVzZXJOb3RpZnlJbnN0YW5jZVByb3AuY2FsbChpbnN0Ll9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgaW5zdCwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUhvc3RQcm9wKGluc3QsIHByb3AsIHByb3BzKSB7XG4gICAgaW5zdC5fX2RhdGFIb3N0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoJ19ob3N0XycgKyBwcm9wLCBwcm9wc1twcm9wXSwgdHJ1ZSwgdHJ1ZSk7XG4gIH07XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFub255bW91cyBgUHJvcGVydHlFZmZlY3RzYCBjbGFzcyBib3VuZCB0byB0aGVcbiAqIGA8dGVtcGxhdGU+YCBwcm92aWRlZC4gIEluc3RhbmNpbmcgdGhlIGNsYXNzIHdpbGwgcmVzdWx0IGluIHRoZVxuICogdGVtcGxhdGUgYmVpbmcgc3RhbXBlZCBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGFzIHRoZSBpbnN0YW5jZSdzXG4gKiBgcm9vdGAgcHJvcGVydHksIGFmdGVyIHdoaWNoIGl0IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICpcbiAqIFRlbXBsYXRlcyBtYXkgdXRpbGl6ZSBhbGwgUG9seW1lciBkYXRhLWJpbmRpbmcgZmVhdHVyZXMgYXMgd2VsbCBhc1xuICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLiAgRXZlbnQgbGlzdGVuZXJzIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gKiBmdW5jdGlvbnMgaW4gdGhlIHRlbXBsYXRlIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBob3N0IG9mIHRoZSB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGUgY29uc3RydWN0b3IgcmV0dXJuZWQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgZGljdGlvbmFyeSBvZiBpbml0aWFsXG4gKiBwcm9wZXJ0eSB2YWx1ZXMgdG8gcHJvcGFnYXRlIGludG8gdGVtcGxhdGUgYmluZGluZ3MuICBBZGRpdGlvbmFsbHlcbiAqIGhvc3QgcHJvcGVydGllcyBjYW4gYmUgZm9yd2FyZGVkIGluLCBhbmQgaW5zdGFuY2UgcHJvcGVydGllcyBjYW4gYmVcbiAqIG5vdGlmaWVkIG91dCBieSBwcm92aWRpbmcgb3B0aW9uYWwgY2FsbGJhY2tzIGluIHRoZSBgb3B0aW9uc2AgZGljdGlvbmFyeS5cbiAqXG4gKiBWYWxpZCBjb25maWd1cmF0aW9uIGluIGBvcHRpb25zYCBhcmUgYXMgZm9sbG93czpcbiAqXG4gKiAtIGBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuIGEgcHJvcGVydHkgcmVmZXJlbmNlZFxuICogICBpbiB0aGUgdGVtcGxhdGUgY2hhbmdlZCBvbiB0aGUgdGVtcGxhdGUncyBob3N0LiBBcyB0aGlzIGxpYnJhcnkgZG9lc1xuICogICBub3QgcmV0YWluIHJlZmVyZW5jZXMgdG8gdGVtcGxhdGVzIGluc3RhbmNlZCBieSB0aGUgdXNlciwgaXQgaXMgdGhlXG4gKiAgIHRlbXBsYXRpemUgb3duZXIncyByZXNwb25zaWJpbGl0eSB0byBmb3J3YXJkIGhvc3QgcHJvcGVydHkgY2hhbmdlcyBpbnRvXG4gKiAgIHVzZXItc3RhbXBlZCBpbnN0YW5jZXMuICBUaGUgYGluc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpYFxuICogICAgbWV0aG9kIG9uIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgc2hvdWxkIGJlIGNhbGxlZCB0byBmb3J3YXJkIGhvc3RcbiAqICAgcHJvcGVydGllcyBpbnRvIHRoZSB0ZW1wbGF0ZSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHByb3BlcnR5LWNoYW5nZWRcbiAqICAgbm90aWZpY2F0aW9ucy4gQW55IHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUgdGhhdCBhcmUgbm90XG4gKiAgIGRlZmluZWQgaW4gYGluc3RhbmNlUHJvcHNgIHdpbGwgYmUgbm90aWZpZWQgdXAgdG8gdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICogICBhdXRvbWF0aWNhbGx5LlxuICogLSBgaW5zdGFuY2VQcm9wc2A6IERpY3Rpb25hcnkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkXG4gKiAgIHRvIHRoZSBpbnN0YW5jZSBieSB0aGUgdGVtcGxhdGl6ZSBvd25lci4gIFRoZXNlIHByb3BlcnRpZXMgc2hhZG93IGFueVxuICogICBob3N0IHByb3BlcnRpZXMsIGFuZCBjaGFuZ2VzIHdpdGhpbiB0aGUgdGVtcGxhdGUgdG8gdGhlc2UgcHJvcGVydGllc1xuICogICB3aWxsIHJlc3VsdCBpbiBgbm90aWZ5SW5zdGFuY2VQcm9wYCBiZWluZyBjYWxsZWQuXG4gKiAtIGBtdXRhYmxlRGF0YWA6IFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcCBzdHJpY3RcbiAqICAgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmVcbiAqICAgXCJkaXJ0eVwiKS5cbiAqIC0gYG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuXG4gKiAgIGFuIGluc3RhbmNlIHByb3BlcnR5IGNoYW5nZXMuICBVc2VycyBtYXkgY2hvb3NlIHRvIGNhbGwgYG5vdGlmeVBhdGhgXG4gKiAgIG9uIGUuZy4gdGhlIG93bmVyIHRvIG5vdGlmeSB0aGUgY2hhbmdlLlxuICogLSBgcGFyZW50TW9kZWxgOiBXaGVuIGB0cnVlYCwgZXZlbnRzIGhhbmRsZWQgYnkgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzXG4gKiAgIChgb24tZXZlbnQ9XCJoYW5kbGVyXCJgKSB3aWxsIGJlIGRlY29yYXRlZCB3aXRoIGEgYG1vZGVsYCBwcm9wZXJ0eSBwb2ludGluZ1xuICogICB0byB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhhdCBzdGFtcGVkIGl0LiAgSXQgd2lsbCBhbHNvIGJlIHJldHVybmVkXG4gKiAgIGZyb20gYGluc3RhbmNlLnBhcmVudE1vZGVsYCBpbiBjYXNlcyB3aGVyZSB0ZW1wbGF0ZSBpbnN0YW5jZSBuZXN0aW5nXG4gKiAgIGNhdXNlcyBhbiBpbm5lciBtb2RlbCB0byBzaGFkb3cgYW4gb3V0ZXIgbW9kZWwuXG4gKlxuICogQWxsIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJvdW5kIHRvIHRoZSBgb3duZXJgLiBBbnkgY29udGV4dFxuICogbmVlZGVkIGZvciB0aGUgY2FsbGJhY2tzIChzdWNoIGFzIHJlZmVyZW5jZXMgdG8gYGluc3RhbmNlc2Agc3RhbXBlZClcbiAqIHNob3VsZCBiZSBzdG9yZWQgb24gdGhlIGBvd25lcmAgc3VjaCB0aGF0IHRoZXkgY2FuIGJlIHJldHJpZXZlZCB2aWFcbiAqIGB0aGlzYC5cbiAqXG4gKiBXaGVuIGBvcHRpb25zLmZvcndhcmRIb3N0UHJvcGAgaXMgZGVjbGFyZWQgYXMgYW4gb3B0aW9uLCBhbnkgcHJvcGVydGllc1xuICogcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGZvcndhcmRlZCBmcm9tIHRoZSBob3N0IG9mXG4gKiB0aGUgYDx0ZW1wbGF0ZT5gIHRvIGluc3RhbmNlcywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGFueSBwcm9wZXJ0aWVzIGxpc3RlZCBpblxuICogdGhlIGBvcHRpb25zLmluc3RhbmNlUHJvcHNgIG9iamVjdC4gIGBpbnN0YW5jZVByb3BzYCBhcmUgYXNzdW1lZCB0byBiZVxuICogbWFuYWdlZCBieSB0aGUgb3duZXIgb2YgdGhlIGluc3RhbmNlcywgZWl0aGVyIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvclxuICogb3Igc2V0IGFmdGVyIHRoZSBmYWN0LiAgTm90ZSwgYW55IHByb3BlcnRpZXMgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yIHdpbGxcbiAqIGFsd2F5cyBiZSBzZXQgdG8gdGhlIGluc3RhbmNlIChyZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSB3b3VsZCBub3JtYWxseVxuICogYmUgZm9yd2FyZGVkIGZyb20gdGhlIGhvc3QpLlxuICpcbiAqIE5vdGUgdGhhdCBgdGVtcGxhdGl6ZSgpYCBjYW4gYmUgcnVuIG9ubHkgb25jZSBmb3IgYSBnaXZlbiBgPHRlbXBsYXRlPmAuXG4gKiBGdXJ0aGVyIGNhbGxzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yLiBBbHNvLCB0aGVyZSBpcyBhIHNwZWNpYWxcbiAqIGJlaGF2aW9yIGlmIHRoZSB0ZW1wbGF0ZSB3YXMgZHVwbGljYXRlZCB0aHJvdWdoIGEgbWVjaGFuaXNtIHN1Y2ggYXNcbiAqIGA8ZG9tLXJlcGVhdD5gIG9yIGA8dGVzdC1maXh0dXJlPmAuIEluIHRoaXMgY2FzZSwgYWxsIGNhbGxzIHRvXG4gKiBgdGVtcGxhdGl6ZSgpYCByZXR1cm4gdGhlIHNhbWUgY2xhc3MgZm9yIGFsbCBkdXBsaWNhdGVzIG9mIGEgdGVtcGxhdGUuXG4gKiBUaGUgY2xhc3MgcmV0dXJuZWQgZnJvbSBgdGVtcGxhdGl6ZSgpYCBpcyBnZW5lcmF0ZWQgb25seSBvbmNlIHVzaW5nXG4gKiB0aGUgYG9wdGlvbnNgIGZyb20gdGhlIGZpcnN0IGNhbGwuIFRoaXMgbWVhbnMgdGhhdCBhbnkgYG9wdGlvbnNgXG4gKiBwcm92aWRlZCB0byBzdWJzZXF1ZW50IGNhbGxzIHdpbGwgYmUgaWdub3JlZC4gVGhlcmVmb3JlLCBpdCBpcyB2ZXJ5XG4gKiBpbXBvcnRhbnQgbm90IHRvIGNsb3NlIG92ZXIgYW55IHZhcmlhYmxlcyBpbnNpZGUgdGhlIGNhbGxiYWNrcy4gQWxzbyxcbiAqIGFycm93IGZ1bmN0aW9ucyBtdXN0IGJlIGF2b2lkZWQgYmVjYXVzZSB0aGV5IGJpbmQgdGhlIG91dGVyIGB0aGlzYC5cbiAqIEluc2lkZSB0aGUgY2FsbGJhY2tzLCBhbnkgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBjYW4gYmUgYWNjZXNzZWRcbiAqIHRocm91Z2ggYHRoaXNgLCB3aGljaCBwb2ludHMgdG8gdGhlIGBvd25lcmAuXG4gKlxuICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gdGVtcGxhdGl6ZVxuICogQHBhcmFtIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0cz19IG93bmVyIE93bmVyIG9mIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZXM7XG4gKiAgIGFueSBvcHRpb25hbCBjYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGlzIG93bmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgZGljdGlvbmFyeSAoc2VlIHN1bW1hcnkgZm9yIGRldGFpbHMpXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UsIE9iamVjdD0pfSBHZW5lcmF0ZWQgY2xhc3MgYm91bmRcbiAqICAgdG8gdGhlIHRlbXBsYXRlIHByb3ZpZGVkXG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRpemUodGVtcGxhdGUsIG93bmVyLCBvcHRpb25zKSB7XG4gIC8vIFVuZGVyIHN0cmljdFRlbXBsYXRlUG9saWN5LCB0aGUgdGVtcGxhdGl6ZWQgZWxlbWVudCBtdXN0IGJlIG93bmVkXG4gIC8vIGJ5IGEgKHRydXN0ZWQpIFBvbHltZXIgZWxlbWVudCwgaW5kaWNhdGVkIGJ5IGV4aXN0ZW5jZSBvZiBfbWV0aG9kSG9zdDtcbiAgLy8gZS5nLiBmb3IgZG9tLWlmICYgZG9tLXJlcGVhdCBpbiBtYWluIGRvY3VtZW50LCBfbWV0aG9kSG9zdCBpcyBudWxsXG4gIGlmIChzdHJpY3RUZW1wbGF0ZVBvbGljeSAmJiAhZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpY3RUZW1wbGF0ZVBvbGljeTogdGVtcGxhdGUgb3duZXIgbm90IHRydXN0ZWQnKTtcbiAgfVxuICBvcHRpb25zID0gLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovKG9wdGlvbnMgfHwge30pO1xuICBpZiAodGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgPHRlbXBsYXRlPiBjYW4gb25seSBiZSB0ZW1wbGF0aXplZCBvbmNlJyk7XG4gIH1cbiAgdGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIgPSBvd25lcjtcbiAgY29uc3QgY3RvciA9IG93bmVyID8gb3duZXIuY29uc3RydWN0b3IgOiBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcbiAgbGV0IHRlbXBsYXRlSW5mbyA9IGN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAvLyBHZXQgbWVtb2l6ZWQgYmFzZSBjbGFzcyBmb3IgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSwgd2hpY2hcbiAgLy8gaW5jbHVkZXMgcHJvcGVydHkgZWZmZWN0cyBmb3IgYmluZGluZyB0ZW1wbGF0ZSAmIGZvcndhcmRpbmdcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9XG4gICAqL1xuICBsZXQgYmFzZUNsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzO1xuICBpZiAoIWJhc2VDbGFzcykge1xuICAgIGJhc2VDbGFzcyA9IGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzID0gYmFzZUNsYXNzO1xuICB9XG4gIGNvbnN0IG1ldGhvZEhvc3QgPSBmaW5kTWV0aG9kSG9zdCh0ZW1wbGF0ZSk7XG4gIC8vIEhvc3QgcHJvcGVydHkgZm9yd2FyZGluZyBtdXN0IGJlIGluc3RhbGxlZCBvbnRvIHRlbXBsYXRlIGluc3RhbmNlXG4gIGFkZFByb3BhZ2F0ZUVmZmVjdHModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucywgbWV0aG9kSG9zdCk7XG4gIC8vIFN1YmNsYXNzIGJhc2UgY2xhc3MgYW5kIGFkZCByZWZlcmVuY2UgZm9yIHRoaXMgc3BlY2lmaWMgdGVtcGxhdGVcbiAgLyoqIEBwcml2YXRlICovXG4gIGxldCBrbGFzcyA9IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2UgZXh0ZW5kcyBiYXNlQ2xhc3Mge307XG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAga2xhc3MucHJvdG90eXBlLl9tZXRob2RIb3N0ID0gbWV0aG9kSG9zdDtcbiAgLyoqIEBvdmVycmlkZSAqL1xuICBrbGFzcy5wcm90b3R5cGUuX19kYXRhSG9zdCA9IC8qKiBAdHlwZSB7IURhdGFUZW1wbGF0ZX0gKi8gKHRlbXBsYXRlKTtcbiAgLyoqIEBvdmVycmlkZSAqL1xuICBrbGFzcy5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXIgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChvd25lcik7XG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAga2xhc3MucHJvdG90eXBlLl9faG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAga2xhc3MgPSAvKiogQHR5cGUge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9ICovKGtsYXNzKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtYXNzaWduXG4gIHJldHVybiBrbGFzcztcbn1cblxuZnVuY3Rpb24gd2Fybk9uVW5kZWNsYXJlZFByb3BlcnRpZXModGVtcGxhdGVJbmZvLCBvcHRpb25zLCBtZXRob2RIb3N0KSB7XG4gIGNvbnN0IGRlY2xhcmVkUHJvcHMgPSBtZXRob2RIb3N0LmNvbnN0cnVjdG9yLl9wcm9wZXJ0aWVzO1xuICBjb25zdCB7cHJvcGVydHlFZmZlY3RzfSA9IHRlbXBsYXRlSW5mbztcbiAgY29uc3Qge2luc3RhbmNlUHJvcHN9ID0gb3B0aW9ucztcbiAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0eUVmZmVjdHMpIHtcbiAgICAvLyBFbnN1cmUgcHJvcGVydGllcyB3aXRoIHRlbXBsYXRlIGVmZmVjdHMgYXJlIGRlY2xhcmVkIG9uIHRoZSBvdXRlcm1vc3RcbiAgICAvLyBob3N0IChgbWV0aG9kSG9zdGApLCB1bmxlc3MgdGhleSBhcmUgaW5zdGFuY2UgcHJvcHMgb3Igc3RhdGljIGZ1bmN0aW9uc1xuICAgIGlmICghZGVjbGFyZWRQcm9wc1twcm9wXSAmJiAhKGluc3RhbmNlUHJvcHMgJiYgaW5zdGFuY2VQcm9wc1twcm9wXSkpIHtcbiAgICAgIGNvbnN0IGVmZmVjdHMgPSBwcm9wZXJ0eUVmZmVjdHNbcHJvcF07XG4gICAgICBmb3IgKGxldCBpPTA7IGk8ZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7cGFydH0gPSBlZmZlY3RzW2ldLmluZm87XG4gICAgICAgIGlmICghKHBhcnQuc2lnbmF0dXJlICYmIHBhcnQuc2lnbmF0dXJlLnN0YXRpYykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFByb3BlcnR5ICcke3Byb3B9JyB1c2VkIGluIHRlbXBsYXRlIGJ1dCBub3QgYCArXG4gICAgICAgICAgICBgZGVjbGFyZWQgaW4gJ3Byb3BlcnRpZXMnOyBhdHRyaWJ1dGUgd2lsbCBub3QgYmUgb2JzZXJ2ZWQuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAqIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzXG4gKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAqIGBUZW1wbGF0ZUluc3RhbmNlQmFzZWAsIGFuZCBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGFcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICBsZXQgbW9kZWwgPSBtb2RlbEZvckVsZW1lbnQoZWwpO1xuICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gKiAgIH1cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0ZW1wbGF0ZSBUaGUgbW9kZWwgd2lsbCBiZSByZXR1cm5lZCBmb3JcbiAqICAgZWxlbWVudHMgc3RhbXBlZCBmcm9tIHRoaXMgdGVtcGxhdGUgKGFjY2VwdHMgZWl0aGVyIGFuIEhUTUxUZW1wbGF0ZUVsZW1lbnQpXG4gKiAgIG9yIGEgYDxkb20taWY+YC9gPGRvbS1yZXBlYXQ+YCBlbGVtZW50IHdoZW4gdXNpbmcgYHJlbW92ZU5lc3RlZFRlbXBsYXRlc2BcbiAqICAgb3B0aW1pemF0aW9uLlxuICogQHBhcmFtIHtOb2RlPX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBUZW1wbGF0ZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlXG4gKiAgIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2RlbEZvckVsZW1lbnQodGVtcGxhdGUsIG5vZGUpIHtcbiAgbGV0IG1vZGVsO1xuICB3aGlsZSAobm9kZSkge1xuICAgIC8vIEFuIGVsZW1lbnQgd2l0aCBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIG1hcmtzIHRoZSB0b3AgYm91bmRhcnlcbiAgICAvLyBvZiBhIHNjb3BlOyB3YWxrIHVwIHVudGlsIHdlIGZpbmQgb25lLCBhbmQgdGhlbiBlbnN1cmUgdGhhdFxuICAgIC8vIGl0cyBfX2RhdGFIb3N0IG1hdGNoZXMgYHRoaXNgLCBtZWFuaW5nIHRoaXMgZG9tLXJlcGVhdCBzdGFtcGVkIGl0XG4gICAgaWYgKChtb2RlbCA9IG5vZGUuX19kYXRhSG9zdCA/IG5vZGUgOiBub2RlLl9fdGVtcGxhdGl6ZUluc3RhbmNlKSkge1xuICAgICAgLy8gRm91bmQgYW4gZWxlbWVudCBzdGFtcGVkIGJ5IGFub3RoZXIgdGVtcGxhdGU7IGtlZXAgd2Fsa2luZyB1cFxuICAgICAgLy8gZnJvbSBpdHMgX19kYXRhSG9zdFxuICAgICAgaWYgKG1vZGVsLl9fZGF0YUhvc3QgIT0gdGVtcGxhdGUpIHtcbiAgICAgICAgbm9kZSA9IG1vZGVsLl9fZGF0YUhvc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0aWxsIGluIGEgdGVtcGxhdGUgc2NvcGUsIGtlZXAgZ29pbmcgdXAgdW50aWxcbiAgICAgIC8vIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgaXMgZm91bmRcbiAgICAgIG5vZGUgPSB3cmFwKG5vZGUpLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/templatize.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"wrap\": () => (/* binding */ wrap)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/* eslint-disable valid-jsdoc */\n/**\n * Node wrapper to ensure ShadowDOM safe operation regardless of polyfill\n * presence or mode. Note that with the introduction of `ShadyDOM.noPatch`,\n * a node wrapper must be used to access ShadowDOM API.\n * This is similar to using `Polymer.dom` but relies exclusively\n * on the presence of the ShadyDOM polyfill rather than requiring the loading\n * of legacy (Polymer.dom) API.\n * @type {function(Node):Node}\n */\nconst wrap = window['ShadyDOM'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['wrap'] ? window['ShadyDOM']['wrap'] : window['ShadyDOM'] ? n => ShadyDOM['patch'](n) : n => n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy93cmFwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy93cmFwLmpzP2QxZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbi8qKlxuICogTm9kZSB3cmFwcGVyIHRvIGVuc3VyZSBTaGFkb3dET00gc2FmZSBvcGVyYXRpb24gcmVnYXJkbGVzcyBvZiBwb2x5ZmlsbFxuICogcHJlc2VuY2Ugb3IgbW9kZS4gTm90ZSB0aGF0IHdpdGggdGhlIGludHJvZHVjdGlvbiBvZiBgU2hhZHlET00ubm9QYXRjaGAsXG4gKiBhIG5vZGUgd3JhcHBlciBtdXN0IGJlIHVzZWQgdG8gYWNjZXNzIFNoYWRvd0RPTSBBUEkuXG4gKiBUaGlzIGlzIHNpbWlsYXIgdG8gdXNpbmcgYFBvbHltZXIuZG9tYCBidXQgcmVsaWVzIGV4Y2x1c2l2ZWx5XG4gKiBvbiB0aGUgcHJlc2VuY2Ugb2YgdGhlIFNoYWR5RE9NIHBvbHlmaWxsIHJhdGhlciB0aGFuIHJlcXVpcmluZyB0aGUgbG9hZGluZ1xuICogb2YgbGVnYWN5IChQb2x5bWVyLmRvbSkgQVBJLlxuICogQHR5cGUge2Z1bmN0aW9uKE5vZGUpOk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCB3cmFwID0gKHdpbmRvd1snU2hhZHlET00nXSAmJiB3aW5kb3dbJ1NoYWR5RE9NJ11bJ25vUGF0Y2gnXSAmJiB3aW5kb3dbJ1NoYWR5RE9NJ11bJ3dyYXAnXSkgP1xuICB3aW5kb3dbJ1NoYWR5RE9NJ11bJ3dyYXAnXSA6XG4gICh3aW5kb3dbJ1NoYWR5RE9NJ10gPyAobikgPT4gU2hhZHlET01bJ3BhdGNoJ10obikgOiAobikgPT4gbik7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/wrap.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/polymer-element.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/polymer-element.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PolymerElement\": () => (/* binding */ PolymerElement),\n/* harmony export */   \"html\": () => (/* reexport safe */ _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__.html),\n/* harmony export */   \"version\": () => (/* reexport safe */ _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/mixins/element-mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/mixins/element-mixin.js\");\n/* harmony import */ var _lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/utils/html-tag.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n/**\n * Base class that provides the core API for Polymer's meta-programming\n * features including template stamping, data-binding, attribute deserialization,\n * and property change observation.\n *\n * @customElement\n * @polymer\n * @constructor\n * @implements {Polymer_ElementMixin}\n * @extends HTMLElement\n * @appliesMixin ElementMixin\n * @summary Custom element base class that provides the core API for Polymer's\n *   key meta-programming features including template stamping, data-binding,\n *   attribute deserialization, and property change observation\n */\nconst PolymerElement = (0,_lib_mixins_element_mixin_js__WEBPACK_IMPORTED_MODULE_0__.ElementMixin)(HTMLElement);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanM/ZjRiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgeyBFbGVtZW50TWl4aW4sIHZlcnNpb24gfSBmcm9tICcuL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyc7XG5leHBvcnQgeyBodG1sIH0gZnJvbSAnLi9saWIvdXRpbHMvaHRtbC10YWcuanMnO1xuXG5leHBvcnQgeyB2ZXJzaW9uIH07XG5cbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmdcbiAqIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLCBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLFxuICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQHBvbHltZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gRWxlbWVudE1peGluXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAqICAga2V5IG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsXG4gKiAgIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IFBvbHltZXJFbGVtZW50ID0gRWxlbWVudE1peGluKEhUTUxFbGVtZW50KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/polymer-element.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/lit.js":
/*!***********************************************!*\
  !*** ./node_modules/@vaadin/combo-box/lit.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComboBoxRendererDirective": () => (/* reexport safe */ _src_lit_renderer_directives_js__WEBPACK_IMPORTED_MODULE_0__.ComboBoxRendererDirective),
/* harmony export */   "comboBoxRenderer": () => (/* reexport safe */ _src_lit_renderer_directives_js__WEBPACK_IMPORTED_MODULE_0__.comboBoxRenderer)
/* harmony export */ });
/* harmony import */ var _src_lit_renderer_directives_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/lit/renderer-directives.js */ "./node_modules/@vaadin/combo-box/src/lit/renderer-directives.js");


/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemableMixin\": () => (/* binding */ ThemableMixin),\n/* harmony export */   \"__themeRegistry\": () => (/* binding */ themeRegistry),\n/* harmony export */   \"css\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* binding */ registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/@vaadin/combo-box/node_modules/lit/index.js\");\n/* harmony import */ var _vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-theme-property-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nfunction registerStyles(themeFor, styles, options = {}) {\n  if (themeFor) {\n    if (hasThemes(themeFor)) {\n      console.warn(`The custom element definition for \"${themeFor}\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element.`);\n    }\n  }\n  styles = flattenStyles(styles);\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId\n    });\n  }\n}\n\n/**\n * Returns all registered themes. By default the themeRegistry is returned as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  }\n  return themeRegistry;\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some(themeForToken => {\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`).test(tagName);\n  });\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\n    includePriority = 1;\n  } else if (moduleName.startsWith('vaadin-')) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\nfunction flattenStyles(styles = []) {\n  return [styles].flat(Infinity).filter(style => {\n    if (style instanceof lit__WEBPACK_IMPORTED_MODULE_0__.CSSResult) {\n      return true;\n    }\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n    return false;\n  });\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach(includeModuleId => {\n      const includedTheme = getAllThemes().find(s => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = styles.map(style => style.cssText).join('\\n');\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = `${tagName}-default-theme`;\n  const themes = getAllThemes()\n  // Filter by matching themeFor properties\n  .filter(theme => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map(theme => ({\n    ...theme,\n    // Prepend styles from included themes\n    styles: [...getIncludedStyles(theme), ...theme.styles],\n    // Map moduleId to includePriority\n    includePriority: getIncludePriority(theme.moduleId)\n  }))\n  // Sort by includePriority\n  .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n  if (themes.length > 0) {\n    return themes;\n  }\n  // No theme modules found, return the default module if it exists\n  return getAllThemes().filter(theme => theme.moduleId === defaultModuleName);\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction hasThemes(tagName) {\n  return classHasThemes(customElements.get(tagName));\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {Function} elementClass\n * @returns {boolean}\n */\nfunction classHasThemes(elementClass) {\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nconst ThemableMixin = superClass => class VaadinThemableMixin extends (0,_vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ThemePropertyMixin)(superClass) {\n  /**\n   * Covers PolymerElement based component styling\n   * @protected\n   */\n  static finalize() {\n    super.finalize();\n\n    // Make sure not to run the logic intended for PolymerElement when LitElement is used.\n    if (this.elementStyles) {\n      return;\n    }\n    const template = this.prototype._template;\n    if (!template || classHasThemes(this)) {\n      return;\n    }\n    addStylesToTemplate(this.getStylesForThis(), template);\n  }\n\n  /**\n   * Covers LitElement based component styling\n   *\n   * @protected\n   */\n  static finalizeStyles(styles) {\n    // The \"styles\" object originates from the \"static get styles()\" function of\n    // a LitElement based component. The theme styles are added after it\n    // so that they can override the component styles.\n    const themeStyles = this.getStylesForThis();\n    return styles ? [...super.finalizeStyles(styles), ...themeStyles] : themeStyles;\n  }\n\n  /**\n   * Get styles for the component type\n   *\n   * @private\n   */\n  static getStylesForThis() {\n    const parent = Object.getPrototypeOf(this.prototype);\n    const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\n    this.__themes = [...inheritedThemes, ...getThemes(this.is)];\n    const themeStyles = this.__themes.flatMap(theme => theme.styles);\n    // Remove duplicates\n    return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanM/Zjc0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IGNzcywgQ1NTUmVzdWx0LCB1bnNhZmVDU1MgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgVGhlbWVQcm9wZXJ0eU1peGluIH0gZnJvbSAnLi92YWFkaW4tdGhlbWUtcHJvcGVydHktbWl4aW4uanMnO1xuXG5leHBvcnQgeyBjc3MsIHVuc2FmZUNTUyB9O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRoZW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGhlbWVGb3JcbiAqIEBwcm9wZXJ0eSB7Q1NTUmVzdWx0W119IHN0eWxlc1xuICogQHByb3BlcnR5IHtzdHJpbmcgfCBzdHJpbmdbXX0gW2luY2x1ZGVdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21vZHVsZUlkXVxuICpcbiAqIEB0eXBlZGVmIHtDU1NSZXN1bHRbXSB8IENTU1Jlc3VsdH0gQ1NTUmVzdWx0R3JvdXBcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtUaGVtZVtdfVxuICovXG5jb25zdCB0aGVtZVJlZ2lzdHJ5ID0gW107XG5cbi8qKlxuICogUmVnaXN0ZXJzIENTUyBzdHlsZXMgZm9yIGEgY29tcG9uZW50IHR5cGUuIE1ha2Ugc3VyZSB0byByZWdpc3RlciB0aGUgc3R5bGVzIGJlZm9yZVxuICogdGhlIGZpcnN0IGluc3RhbmNlIG9mIGEgY29tcG9uZW50IG9mIHRoZSB0eXBlIGlzIGF0dGFjaGVkIHRvIERPTS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhlbWVGb3IgVGhlIGxvY2FsL3RhZyBuYW1lIG9mIHRoZSBjb21wb25lbnQgdHlwZSB0byByZWdpc3RlciB0aGUgc3R5bGVzIGZvclxuICogQHBhcmFtIHtDU1NSZXN1bHRHcm91cH0gc3R5bGVzIFRoZSBDU1Mgc3R5bGUgcnVsZXMgdG8gYmUgcmVnaXN0ZXJlZCBmb3IgdGhlIGNvbXBvbmVudCB0eXBlXG4gKiBtYXRjaGluZyB0aGVtZUZvciBhbmQgaW5jbHVkZWQgaW4gdGhlIGxvY2FsIHNjb3BlIG9mIGVhY2ggY29tcG9uZW50IGluc3RhbmNlXG4gKiBAcGFyYW0ge3ttb2R1bGVJZD86IHN0cmluZywgaW5jbHVkZT86IHN0cmluZyB8IHN0cmluZ1tdfX0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclN0eWxlcyh0aGVtZUZvciwgc3R5bGVzLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHRoZW1lRm9yKSB7XG4gICAgaWYgKGhhc1RoZW1lcyh0aGVtZUZvcikpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIGN1c3RvbSBlbGVtZW50IGRlZmluaXRpb24gZm9yIFwiJHt0aGVtZUZvcn1cIlxuICAgICAgd2FzIGZpbmFsaXplZCBiZWZvcmUgYSBzdHlsZSBtb2R1bGUgd2FzIHJlZ2lzdGVyZWQuXG4gICAgICBNYWtlIHN1cmUgdG8gYWRkIGNvbXBvbmVudCBzcGVjaWZpYyBzdHlsZSBtb2R1bGVzIGJlZm9yZVxuICAgICAgaW1wb3J0aW5nIHRoZSBjb3JyZXNwb25kaW5nIGN1c3RvbSBlbGVtZW50LmApO1xuICAgIH1cbiAgfVxuXG4gIHN0eWxlcyA9IGZsYXR0ZW5TdHlsZXMoc3R5bGVzKTtcblxuICBpZiAod2luZG93LlZhYWRpbiAmJiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcykge1xuICAgIHdpbmRvdy5WYWFkaW4uc3R5bGVNb2R1bGVzLnJlZ2lzdGVyU3R5bGVzKHRoZW1lRm9yLCBzdHlsZXMsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRoZW1lUmVnaXN0cnkucHVzaCh7XG4gICAgICB0aGVtZUZvcixcbiAgICAgIHN0eWxlcyxcbiAgICAgIGluY2x1ZGU6IG9wdGlvbnMuaW5jbHVkZSxcbiAgICAgIG1vZHVsZUlkOiBvcHRpb25zLm1vZHVsZUlkLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCB0aGVtZXMuIEJ5IGRlZmF1bHQgdGhlIHRoZW1lUmVnaXN0cnkgaXMgcmV0dXJuZWQgYXMgaXMuXG4gKiBJbiBjYXNlIHRoZSBzdHlsZS1tb2R1bGVzIGFkYXB0ZXIgaXMgaW1wb3J0ZWQsIHRoZSB0aGVtZXMgYXJlIG9idGFpbmVkIGZyb20gdGhlcmUgaW5zdGVhZFxuICogQHJldHVybnMge1RoZW1lW119XG4gKi9cbmZ1bmN0aW9uIGdldEFsbFRoZW1lcygpIHtcbiAgaWYgKHdpbmRvdy5WYWFkaW4gJiYgd2luZG93LlZhYWRpbi5zdHlsZU1vZHVsZXMpIHtcbiAgICByZXR1cm4gd2luZG93LlZhYWRpbi5zdHlsZU1vZHVsZXMuZ2V0QWxsVGhlbWVzKCk7XG4gIH1cbiAgcmV0dXJuIHRoZW1lUmVnaXN0cnk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0aGVtZUZvciBzdHJpbmcgbWF0Y2hlcyB0aGUgdGFnIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZUZvclxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaGVzVGhlbWVGb3IodGhlbWVGb3IsIHRhZ05hbWUpIHtcbiAgcmV0dXJuICh0aGVtZUZvciB8fCAnJykuc3BsaXQoJyAnKS5zb21lKCh0aGVtZUZvclRva2VuKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RoZW1lRm9yVG9rZW4uc3BsaXQoJyonKS5qb2luKCcuKicpfSRgKS50ZXN0KHRhZ05hbWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNYXBzIHRoZSBtb2R1bGVOYW1lIHRvIGFuIGluY2x1ZGUgcHJpb3JpdHkgbnVtYmVyIHdoaWNoIGlzIHVzZWQgZm9yXG4gKiBkZXRlcm1pbmluZyB0aGUgb3JkZXIgaW4gd2hpY2ggc3R5bGVzIGFyZSBhcHBsaWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEluY2x1ZGVQcmlvcml0eShtb2R1bGVOYW1lID0gJycpIHtcbiAgbGV0IGluY2x1ZGVQcmlvcml0eSA9IDA7XG4gIGlmIChtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ2x1bW8tJykgfHwgbW9kdWxlTmFtZS5zdGFydHNXaXRoKCdtYXRlcmlhbC0nKSkge1xuICAgIGluY2x1ZGVQcmlvcml0eSA9IDE7XG4gIH0gZWxzZSBpZiAobW9kdWxlTmFtZS5zdGFydHNXaXRoKCd2YWFkaW4tJykpIHtcbiAgICBpbmNsdWRlUHJpb3JpdHkgPSAyO1xuICB9XG4gIHJldHVybiBpbmNsdWRlUHJpb3JpdHk7XG59XG5cbi8qKlxuICogRmxhdHRlbnMgdGhlIHN0eWxlcyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIHN0eWxlcy5cbiAqIEBwYXJhbSB7Q1NTUmVzdWx0R3JvdXB9IHN0eWxlc1xuICogQHBhcmFtIHtDU1NSZXN1bHRbXX0gcmVzdWx0XG4gKiBAcmV0dXJucyB7Q1NTUmVzdWx0W119XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TdHlsZXMoc3R5bGVzID0gW10pIHtcbiAgcmV0dXJuIFtzdHlsZXNdLmZsYXQoSW5maW5pdHkpLmZpbHRlcigoc3R5bGUpID0+IHtcbiAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBDU1NSZXN1bHQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oJ0FuIGl0ZW0gaW4gc3R5bGVzIGlzIG5vdCBvZiB0eXBlIENTU1Jlc3VsdC4gVXNlIGB1bnNhZmVDU1NgIG9yIGBjc3NgLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0cyBhbiBhcnJheSBvZiBDU1NSZXN1bHRzIG1hdGNoaW5nIHRoZSBpbmNsdWRlIHByb3BlcnR5IG9mIHRoZSB0aGVtZS5cbiAqIEBwYXJhbSB7VGhlbWV9IHRoZW1lXG4gKiBAcmV0dXJucyB7Q1NTUmVzdWx0W119XG4gKi9cbmZ1bmN0aW9uIGdldEluY2x1ZGVkU3R5bGVzKHRoZW1lKSB7XG4gIGNvbnN0IGluY2x1ZGVkU3R5bGVzID0gW107XG4gIGlmICh0aGVtZS5pbmNsdWRlKSB7XG4gICAgW10uY29uY2F0KHRoZW1lLmluY2x1ZGUpLmZvckVhY2goKGluY2x1ZGVNb2R1bGVJZCkgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZWRUaGVtZSA9IGdldEFsbFRoZW1lcygpLmZpbmQoKHMpID0+IHMubW9kdWxlSWQgPT09IGluY2x1ZGVNb2R1bGVJZCk7XG4gICAgICBpZiAoaW5jbHVkZWRUaGVtZSkge1xuICAgICAgICBpbmNsdWRlZFN0eWxlcy5wdXNoKC4uLmdldEluY2x1ZGVkU3R5bGVzKGluY2x1ZGVkVGhlbWUpLCAuLi5pbmNsdWRlZFRoZW1lLnN0eWxlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYEluY2x1ZGVkIG1vZHVsZUlkICR7aW5jbHVkZU1vZHVsZUlkfSBub3QgZm91bmQgaW4gc3R5bGUgcmVnaXN0cnlgKTtcbiAgICAgIH1cbiAgICB9LCB0aGVtZS5zdHlsZXMpO1xuICB9XG4gIHJldHVybiBpbmNsdWRlZFN0eWxlcztcbn1cblxuLyoqXG4gKiBJbmNsdWRlcyB0aGUgc3R5bGVzIHRvIHRoZSB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7Q1NTUmVzdWx0W119IHN0eWxlc1xuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICovXG5mdW5jdGlvbiBhZGRTdHlsZXNUb1RlbXBsYXRlKHN0eWxlcywgdGVtcGxhdGUpIHtcbiAgY29uc3Qgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlRWwuaW5uZXJIVE1MID0gc3R5bGVzLm1hcCgoc3R5bGUpID0+IHN0eWxlLmNzc1RleHQpLmpvaW4oJ1xcbicpO1xuICB0ZW1wbGF0ZS5jb250ZW50LmFwcGVuZENoaWxkKHN0eWxlRWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlbWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHN0eWxpbmcgYSBjb21wb25lbnQgbWF0Y2hpbmdcbiAqIHRoZSB0YWcgbmFtZS4gVGhlIGFycmF5IGlzIHNvcnRlZCBieSB0aGUgaW5jbHVkZSBvcmRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcmV0dXJucyB7VGhlbWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0VGhlbWVzKHRhZ05hbWUpIHtcbiAgY29uc3QgZGVmYXVsdE1vZHVsZU5hbWUgPSBgJHt0YWdOYW1lfS1kZWZhdWx0LXRoZW1lYDtcblxuICBjb25zdCB0aGVtZXMgPSBnZXRBbGxUaGVtZXMoKVxuICAgIC8vIEZpbHRlciBieSBtYXRjaGluZyB0aGVtZUZvciBwcm9wZXJ0aWVzXG4gICAgLmZpbHRlcigodGhlbWUpID0+IHRoZW1lLm1vZHVsZUlkICE9PSBkZWZhdWx0TW9kdWxlTmFtZSAmJiBtYXRjaGVzVGhlbWVGb3IodGhlbWUudGhlbWVGb3IsIHRhZ05hbWUpKVxuICAgIC5tYXAoKHRoZW1lKSA9PiAoe1xuICAgICAgLi4udGhlbWUsXG4gICAgICAvLyBQcmVwZW5kIHN0eWxlcyBmcm9tIGluY2x1ZGVkIHRoZW1lc1xuICAgICAgc3R5bGVzOiBbLi4uZ2V0SW5jbHVkZWRTdHlsZXModGhlbWUpLCAuLi50aGVtZS5zdHlsZXNdLFxuICAgICAgLy8gTWFwIG1vZHVsZUlkIHRvIGluY2x1ZGVQcmlvcml0eVxuICAgICAgaW5jbHVkZVByaW9yaXR5OiBnZXRJbmNsdWRlUHJpb3JpdHkodGhlbWUubW9kdWxlSWQpLFxuICAgIH0pKVxuICAgIC8vIFNvcnQgYnkgaW5jbHVkZVByaW9yaXR5XG4gICAgLnNvcnQoKHRoZW1lQSwgdGhlbWVCKSA9PiB0aGVtZUIuaW5jbHVkZVByaW9yaXR5IC0gdGhlbWVBLmluY2x1ZGVQcmlvcml0eSk7XG5cbiAgaWYgKHRoZW1lcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHRoZW1lcztcbiAgfVxuICAvLyBObyB0aGVtZSBtb2R1bGVzIGZvdW5kLCByZXR1cm4gdGhlIGRlZmF1bHQgbW9kdWxlIGlmIGl0IGV4aXN0c1xuICByZXR1cm4gZ2V0QWxsVGhlbWVzKCkuZmlsdGVyKCh0aGVtZSkgPT4gdGhlbWUubW9kdWxlSWQgPT09IGRlZmF1bHRNb2R1bGVOYW1lKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VzdG9tIGVsZW1lbnQgdHlwZSBoYXMgdGhlbWVzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc1RoZW1lcyh0YWdOYW1lKSB7XG4gIHJldHVybiBjbGFzc0hhc1RoZW1lcyhjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXN0b20gZWxlbWVudCB0eXBlIGhhcyB0aGVtZXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVsZW1lbnRDbGFzc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNsYXNzSGFzVGhlbWVzKGVsZW1lbnRDbGFzcykge1xuICByZXR1cm4gZWxlbWVudENsYXNzICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbGVtZW50Q2xhc3MsICdfX3RoZW1lcycpO1xufVxuXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqIEBtaXhlcyBUaGVtZVByb3BlcnR5TWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IFRoZW1hYmxlTWl4aW4gPSAoc3VwZXJDbGFzcykgPT5cbiAgY2xhc3MgVmFhZGluVGhlbWFibGVNaXhpbiBleHRlbmRzIFRoZW1lUHJvcGVydHlNaXhpbihzdXBlckNsYXNzKSB7XG4gICAgLyoqXG4gICAgICogQ292ZXJzIFBvbHltZXJFbGVtZW50IGJhc2VkIGNvbXBvbmVudCBzdHlsaW5nXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5hbGl6ZSgpIHtcbiAgICAgIHN1cGVyLmZpbmFsaXplKCk7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBub3QgdG8gcnVuIHRoZSBsb2dpYyBpbnRlbmRlZCBmb3IgUG9seW1lckVsZW1lbnQgd2hlbiBMaXRFbGVtZW50IGlzIHVzZWQuXG4gICAgICBpZiAodGhpcy5lbGVtZW50U3R5bGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnByb3RvdHlwZS5fdGVtcGxhdGU7XG4gICAgICBpZiAoIXRlbXBsYXRlIHx8IGNsYXNzSGFzVGhlbWVzKHRoaXMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYWRkU3R5bGVzVG9UZW1wbGF0ZSh0aGlzLmdldFN0eWxlc0ZvclRoaXMoKSwgdGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvdmVycyBMaXRFbGVtZW50IGJhc2VkIGNvbXBvbmVudCBzdHlsaW5nXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplU3R5bGVzKHN0eWxlcykge1xuICAgICAgLy8gVGhlIFwic3R5bGVzXCIgb2JqZWN0IG9yaWdpbmF0ZXMgZnJvbSB0aGUgXCJzdGF0aWMgZ2V0IHN0eWxlcygpXCIgZnVuY3Rpb24gb2ZcbiAgICAgIC8vIGEgTGl0RWxlbWVudCBiYXNlZCBjb21wb25lbnQuIFRoZSB0aGVtZSBzdHlsZXMgYXJlIGFkZGVkIGFmdGVyIGl0XG4gICAgICAvLyBzbyB0aGF0IHRoZXkgY2FuIG92ZXJyaWRlIHRoZSBjb21wb25lbnQgc3R5bGVzLlxuICAgICAgY29uc3QgdGhlbWVTdHlsZXMgPSB0aGlzLmdldFN0eWxlc0ZvclRoaXMoKTtcbiAgICAgIHJldHVybiBzdHlsZXMgPyBbLi4uc3VwZXIuZmluYWxpemVTdHlsZXMoc3R5bGVzKSwgLi4udGhlbWVTdHlsZXNdIDogdGhlbWVTdHlsZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHN0eWxlcyBmb3IgdGhlIGNvbXBvbmVudCB0eXBlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTdHlsZXNGb3JUaGlzKCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMucHJvdG90eXBlKTtcbiAgICAgIGNvbnN0IGluaGVyaXRlZFRoZW1lcyA9IChwYXJlbnQgPyBwYXJlbnQuY29uc3RydWN0b3IuX190aGVtZXMgOiBbXSkgfHwgW107XG4gICAgICB0aGlzLl9fdGhlbWVzID0gWy4uLmluaGVyaXRlZFRoZW1lcywgLi4uZ2V0VGhlbWVzKHRoaXMuaXMpXTtcbiAgICAgIGNvbnN0IHRoZW1lU3R5bGVzID0gdGhpcy5fX3RoZW1lcy5mbGF0TWFwKCh0aGVtZSkgPT4gdGhlbWUuc3R5bGVzKTtcbiAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICByZXR1cm4gdGhlbWVTdHlsZXMuZmlsdGVyKChzdHlsZSwgaW5kZXgpID0+IGluZGV4ID09PSB0aGVtZVN0eWxlcy5sYXN0SW5kZXhPZihzdHlsZSkpO1xuICAgIH1cbiAgfTtcblxuZXhwb3J0IHsgdGhlbWVSZWdpc3RyeSBhcyBfX3RoZW1lUmVnaXN0cnkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemePropertyMixin\": () => (/* binding */ ThemePropertyMixin)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nconst ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @deprecated The `theme` property is not supposed for public use and will be dropped in Vaadin 24.\n       * Please, use the `theme` attribute instead.\n       * @protected\n       */\n      theme: {\n        type: String,\n        reflectToAttribute: true,\n        observer: '__deprecatedThemePropertyChanged'\n      },\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @protected\n       */\n      _theme: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n\n  /** @private */\n  __deprecatedThemePropertyChanged(theme) {\n    this._set_theme(theme);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtZS1wcm9wZXJ0eS1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtZS1wcm9wZXJ0eS1taXhpbi5qcz9jMDY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuLyoqXG4gKiBAcG9seW1lck1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBUaGVtZVByb3BlcnR5TWl4aW4gPSAoc3VwZXJDbGFzcykgPT5cbiAgY2xhc3MgVmFhZGluVGhlbWVQcm9wZXJ0eU1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciBwcm9wZXJ0eSB3aXRoIHRoZW1lIGF0dHJpYnV0ZSB2YWx1ZSBmYWNpbGl0YXRpbmcgcHJvcGFnYXRpb25cbiAgICAgICAgICogaW4gc2hhZG93IERPTS5cbiAgICAgICAgICpcbiAgICAgICAgICogRW5hYmxlcyB0aGUgY29tcG9uZW50IGltcGxlbWVudGF0aW9uIHRvIHByb3BhZ2F0ZSB0aGUgYHRoZW1lYFxuICAgICAgICAgKiBhdHRyaWJ1dGUgdmFsdWUgdG8gdGhlIHN1Yi1jb21wb25lbnRzIGluIFNoYWRvdyBET00gYnkgYmluZGluZ1xuICAgICAgICAgKiB0aGUgc3ViLWNvbXBvbmVudOKAmXMgXCJ0aGVtZVwiIGF0dHJpYnV0ZSB0byB0aGUgYHRoZW1lYCBwcm9wZXJ0eSBvZlxuICAgICAgICAgKiB0aGUgaG9zdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFOioqIEV4dGVuZGluZyB0aGUgbWl4aW4gb25seSBwcm92aWRlcyB0aGUgcHJvcGVydHkgZm9yIGJpbmRpbmcsXG4gICAgICAgICAqIGFuZCBkb2VzIG5vdCBtYWtlIHRoZSBwcm9wYWdhdGlvbiBhbG9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIFtTdHlsaW5nIENvbXBvbmVudHM6IFN1Yi1jb21wb25lbnRzXShodHRwczovL3ZhYWRpbi5jb20vZG9jcy9sYXRlc3Qvc3R5bGluZy9jdXN0b20tdGhlbWUvc3R5bGluZy1jb21wb25lbnRzLyNzdWItY29tcG9uZW50cykuXG4gICAgICAgICAqIHBhZ2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFRoZSBgdGhlbWVgIHByb3BlcnR5IGlzIG5vdCBzdXBwb3NlZCBmb3IgcHVibGljIHVzZSBhbmQgd2lsbCBiZSBkcm9wcGVkIGluIFZhYWRpbiAyNC5cbiAgICAgICAgICogUGxlYXNlLCB1c2UgdGhlIGB0aGVtZWAgYXR0cmlidXRlIGluc3RlYWQuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICBvYnNlcnZlcjogJ19fZGVwcmVjYXRlZFRoZW1lUHJvcGVydHlDaGFuZ2VkJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHByb3BlcnR5IHdpdGggdGhlbWUgYXR0cmlidXRlIHZhbHVlIGZhY2lsaXRhdGluZyBwcm9wYWdhdGlvblxuICAgICAgICAgKiBpbiBzaGFkb3cgRE9NLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgXG4gICAgICAgICAqIGF0dHJpYnV0ZSB2YWx1ZSB0byB0aGUgc3ViLWNvbXBvbmVudHMgaW4gU2hhZG93IERPTSBieSBiaW5kaW5nXG4gICAgICAgICAqIHRoZSBzdWItY29tcG9uZW504oCZcyBcInRoZW1lXCIgYXR0cmlidXRlIHRvIHRoZSBgdGhlbWVgIHByb3BlcnR5IG9mXG4gICAgICAgICAqIHRoZSBob3N0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEU6KiogRXh0ZW5kaW5nIHRoZSBtaXhpbiBvbmx5IHByb3ZpZGVzIHRoZSBwcm9wZXJ0eSBmb3IgYmluZGluZyxcbiAgICAgICAgICogYW5kIGRvZXMgbm90IG1ha2UgdGhlIHByb3BhZ2F0aW9uIGFsb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50czogU3ViLWNvbXBvbmVudHNdKGh0dHBzOi8vdmFhZGluLmNvbS9kb2NzL2xhdGVzdC9zdHlsaW5nL2N1c3RvbS10aGVtZS9zdHlsaW5nLWNvbXBvbmVudHMvI3N1Yi1jb21wb25lbnRzKS5cbiAgICAgICAgICogcGFnZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoZW1lOiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfX2RlcHJlY2F0ZWRUaGVtZVByb3BlcnR5Q2hhbmdlZCh0aGVtZSkge1xuICAgICAgdGhpcy5fc2V0X3RoZW1lKHRoZW1lKTtcbiAgICB9XG4gIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/lit/directive.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/lit/directive.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Directive": () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.Directive),
/* harmony export */   "PartType": () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.PartType),
/* harmony export */   "directive": () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.directive)
/* harmony export */ });
/* harmony import */ var lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directive.js */ "./node_modules/lit-html/development/directive.js");


/***/ }),

/***/ "./node_modules/@vaadin/combo-box/node_modules/lit/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/node_modules/lit/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSResult": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.CSSResult),
/* harmony export */   "LitElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),
/* harmony export */   "ReactiveElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.ReactiveElement),
/* harmony export */   "UpdatingElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),
/* harmony export */   "_$LE": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LE),
/* harmony export */   "_$LH": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LH),
/* harmony export */   "adoptStyles": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.adoptStyles),
/* harmony export */   "css": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.css),
/* harmony export */   "defaultConverter": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.defaultConverter),
/* harmony export */   "getCompatibleStyle": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.getCompatibleStyle),
/* harmony export */   "html": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.html),
/* harmony export */   "isServer": () => (/* reexport safe */ lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__.isServer),
/* harmony export */   "noChange": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.noChange),
/* harmony export */   "notEqual": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.notEqual),
/* harmony export */   "nothing": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.nothing),
/* harmony export */   "render": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.render),
/* harmony export */   "supportsAdoptingStyleSheets": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.supportsAdoptingStyleSheets),
/* harmony export */   "svg": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.svg),
/* harmony export */   "unsafeCSS": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ "./node_modules/@lit/reactive-element/development/reactive-element.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit-element/lit-element.js */ "./node_modules/lit-element/development/lit-element.js");
/* harmony import */ var lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit-html/is-server.js */ "./node_modules/lit-html/development/is-server.js");





/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/lit/renderer-directives.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/lit/renderer-directives.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxRendererDirective\": () => (/* binding */ ComboBoxRendererDirective),\n/* harmony export */   \"comboBoxRenderer\": () => (/* binding */ comboBoxRenderer)\n/* harmony export */ });\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/@vaadin/combo-box/node_modules/lit/directive.js\");\n/* harmony import */ var _vaadin_lit_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/lit-renderer */ \"./node_modules/@vaadin/lit-renderer/src/lit-renderer.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\nclass ComboBoxRendererDirective extends _vaadin_lit_renderer__WEBPACK_IMPORTED_MODULE_1__.LitRendererDirective {\n  /**\n   * Adds the renderer callback to the combo-box.\n   */\n  addRenderer() {\n    this.element.renderer = (root, comboBox, model) => {\n      this.renderRenderer(root, model.item, model, comboBox);\n    };\n  }\n\n  /**\n   * Runs the renderer callback on the combo-box.\n   */\n  runRenderer() {\n    this.element.requestContentUpdate();\n  }\n\n  /**\n   * Removes the renderer callback from the combo-box.\n   */\n  removeRenderer() {\n    this.element.renderer = null;\n  }\n}\n\n/**\n * A Lit directive for rendering the content of the `<vaadin-combo-box-item>` elements.\n *\n * The directive accepts a renderer callback returning a Lit template and assigns it to the combo-box\n * via the `renderer` property. The renderer is called for each combo-box item when assigned\n * and whenever a single dependency or an array of dependencies changes.\n * It is not guaranteed that the renderer will be called immediately (synchronously) in both cases.\n *\n * Dependencies can be a single value or an array of values.\n * Values are checked against previous values with strict equality (`===`),\n * so the check won't detect nested property changes inside objects or arrays.\n * When dependencies are provided as an array, each item is checked against the previous value\n * at the same index with strict equality. Nested arrays are also checked only by strict\n * equality.\n *\n * Example of usage:\n * ```js\n * `<vaadin-combo-box\n *   ${comboBoxRenderer((item, model, comboBox) => html`...`)}\n * ></vaadin-combo-box>`\n * ```\n *\n * @param renderer the renderer callback that returns a Lit template.\n * @param dependencies a single dependency or an array of dependencies\n *                     which trigger a re-render when changed.\n */\nconst comboBoxRenderer = (0,lit_directive_js__WEBPACK_IMPORTED_MODULE_0__.directive)(ComboBoxRendererDirective);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL2xpdC9yZW5kZXJlci1kaXJlY3RpdmVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9zcmMvbGl0L3JlbmRlcmVyLWRpcmVjdGl2ZXMuanM/YmU3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IGRpcmVjdGl2ZSB9IGZyb20gJ2xpdC9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgTGl0UmVuZGVyZXJEaXJlY3RpdmUgfSBmcm9tICdAdmFhZGluL2xpdC1yZW5kZXJlcic7XG5cbmV4cG9ydCBjbGFzcyBDb21ib0JveFJlbmRlcmVyRGlyZWN0aXZlIGV4dGVuZHMgTGl0UmVuZGVyZXJEaXJlY3RpdmUge1xuICAvKipcbiAgICogQWRkcyB0aGUgcmVuZGVyZXIgY2FsbGJhY2sgdG8gdGhlIGNvbWJvLWJveC5cbiAgICovXG4gIGFkZFJlbmRlcmVyKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW5kZXJlciA9IChyb290LCBjb21ib0JveCwgbW9kZWwpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyUmVuZGVyZXIocm9vdCwgbW9kZWwuaXRlbSwgbW9kZWwsIGNvbWJvQm94KTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIHJlbmRlcmVyIGNhbGxiYWNrIG9uIHRoZSBjb21iby1ib3guXG4gICAqL1xuICBydW5SZW5kZXJlcigpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSByZW5kZXJlciBjYWxsYmFjayBmcm9tIHRoZSBjb21iby1ib3guXG4gICAqL1xuICByZW1vdmVSZW5kZXJlcigpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVuZGVyZXIgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQSBMaXQgZGlyZWN0aXZlIGZvciByZW5kZXJpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIGA8dmFhZGluLWNvbWJvLWJveC1pdGVtPmAgZWxlbWVudHMuXG4gKlxuICogVGhlIGRpcmVjdGl2ZSBhY2NlcHRzIGEgcmVuZGVyZXIgY2FsbGJhY2sgcmV0dXJuaW5nIGEgTGl0IHRlbXBsYXRlIGFuZCBhc3NpZ25zIGl0IHRvIHRoZSBjb21iby1ib3hcbiAqIHZpYSB0aGUgYHJlbmRlcmVyYCBwcm9wZXJ0eS4gVGhlIHJlbmRlcmVyIGlzIGNhbGxlZCBmb3IgZWFjaCBjb21iby1ib3ggaXRlbSB3aGVuIGFzc2lnbmVkXG4gKiBhbmQgd2hlbmV2ZXIgYSBzaW5nbGUgZGVwZW5kZW5jeSBvciBhbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgY2hhbmdlcy5cbiAqIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgdGhlIHJlbmRlcmVyIHdpbGwgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IChzeW5jaHJvbm91c2x5KSBpbiBib3RoIGNhc2VzLlxuICpcbiAqIERlcGVuZGVuY2llcyBjYW4gYmUgYSBzaW5nbGUgdmFsdWUgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICogVmFsdWVzIGFyZSBjaGVja2VkIGFnYWluc3QgcHJldmlvdXMgdmFsdWVzIHdpdGggc3RyaWN0IGVxdWFsaXR5IChgPT09YCksXG4gKiBzbyB0aGUgY2hlY2sgd29uJ3QgZGV0ZWN0IG5lc3RlZCBwcm9wZXJ0eSBjaGFuZ2VzIGluc2lkZSBvYmplY3RzIG9yIGFycmF5cy5cbiAqIFdoZW4gZGVwZW5kZW5jaWVzIGFyZSBwcm92aWRlZCBhcyBhbiBhcnJheSwgZWFjaCBpdGVtIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGUgcHJldmlvdXMgdmFsdWVcbiAqIGF0IHRoZSBzYW1lIGluZGV4IHdpdGggc3RyaWN0IGVxdWFsaXR5LiBOZXN0ZWQgYXJyYXlzIGFyZSBhbHNvIGNoZWNrZWQgb25seSBieSBzdHJpY3RcbiAqIGVxdWFsaXR5LlxuICpcbiAqIEV4YW1wbGUgb2YgdXNhZ2U6XG4gKiBgYGBqc1xuICogYDx2YWFkaW4tY29tYm8tYm94XG4gKiAgICR7Y29tYm9Cb3hSZW5kZXJlcigoaXRlbSwgbW9kZWwsIGNvbWJvQm94KSA9PiBodG1sYC4uLmApfVxuICogPjwvdmFhZGluLWNvbWJvLWJveD5gXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcmVuZGVyZXIgdGhlIHJlbmRlcmVyIGNhbGxiYWNrIHRoYXQgcmV0dXJucyBhIExpdCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSBkZXBlbmRlbmNpZXMgYSBzaW5nbGUgZGVwZW5kZW5jeSBvciBhbiBhcnJheSBvZiBkZXBlbmRlbmNpZXNcbiAqICAgICAgICAgICAgICAgICAgICAgd2hpY2ggdHJpZ2dlciBhIHJlLXJlbmRlciB3aGVuIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBjb21ib0JveFJlbmRlcmVyID0gZGlyZWN0aXZlKENvbWJvQm94UmVuZGVyZXJEaXJlY3RpdmUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/lit/renderer-directives.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxDataProviderMixin\": () => (/* binding */ ComboBoxDataProviderMixin)\n/* harmony export */ });\n/* harmony import */ var _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-combo-box-placeholder.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * @polymerMixin\n */\nconst ComboBoxDataProviderMixin = superClass => class DataProviderMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       * @attr {number} page-size\n       * @type {number}\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n      /**\n       * Total number of items.\n       * @type {number | undefined}\n       */\n      size: {\n        type: Number,\n        observer: '_sizeChanged'\n      },\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filter` Currently applied filter\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items.\n       * @type {ComboBoxDataProvider | undefined}\n       */\n      dataProvider: {\n        type: Object,\n        observer: '_dataProviderChanged'\n      },\n      /** @private */\n      _pendingRequests: {\n        value: () => {\n          return {};\n        }\n      },\n      /** @private */\n      __placeHolder: {\n        value: new _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_0__.ComboBoxPlaceholder()\n      },\n      /** @private */\n      __previousDataProviderFilter: {\n        type: String\n      }\n    };\n  }\n  static get observers() {\n    return ['_dataProviderFilterChanged(filter)', '_warnDataProviderValue(dataProvider, value)', '_ensureFirstPage(opened)'];\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this._scroller.addEventListener('index-requested', e => {\n      const index = e.detail.index;\n      const currentScrollerPos = e.detail.currentScrollerPos;\n      const allowedIndexRange = Math.floor(this.pageSize * 1.5);\n\n      // Ignores the indexes, which are being re-sent during scrolling reset,\n      // if the corresponding page is around the current scroller position.\n      // Otherwise, there might be a last pages duplicates, which cause the\n      // loading indicator hanging and blank items\n      if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {\n        return;\n      }\n      if (index !== undefined) {\n        const page = this._getPageForIndex(index);\n        if (this._shouldLoadPage(page)) {\n          this._loadPage(page);\n        }\n      }\n    });\n  }\n\n  /** @private */\n  _dataProviderFilterChanged(filter) {\n    if (this.__previousDataProviderFilter === undefined && filter === '') {\n      this.__previousDataProviderFilter = filter;\n      return;\n    }\n    if (this.__previousDataProviderFilter !== filter) {\n      this.__previousDataProviderFilter = filter;\n      this._pendingRequests = {};\n      // Immediately mark as loading if this refresh leads to re-fetching pages\n      // This prevents some issues with the properties below triggering\n      // observers that also rely on the loading state\n      this.loading = this._shouldFetchData();\n      // Reset size and internal loading state\n      this.size = undefined;\n      this.clearCache();\n    }\n  }\n\n  /** @private */\n  _shouldFetchData() {\n    if (!this.dataProvider) {\n      return false;\n    }\n    return this.opened || this.filter && this.filter.length;\n  }\n\n  /** @private */\n  _ensureFirstPage(opened) {\n    if (opened && this._shouldLoadPage(0)) {\n      this._loadPage(0);\n    }\n  }\n\n  /** @private */\n  _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {\n    return currentScrollerPos !== 0 && index >= currentScrollerPos - allowedIndexRange && index <= currentScrollerPos + allowedIndexRange;\n  }\n\n  /** @private */\n  _shouldLoadPage(page) {\n    if (!this.filteredItems || this._forceNextRequest) {\n      this._forceNextRequest = false;\n      return true;\n    }\n    const loadedItem = this.filteredItems[page * this.pageSize];\n    if (loadedItem !== undefined) {\n      return loadedItem instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_0__.ComboBoxPlaceholder;\n    }\n    return this.size === undefined;\n  }\n\n  /** @private */\n  _loadPage(page) {\n    // Make sure same page isn't requested multiple times.\n    if (this._pendingRequests[page] || !this.dataProvider) {\n      return;\n    }\n    const params = {\n      page,\n      pageSize: this.pageSize,\n      filter: this.filter\n    };\n    const callback = (items, size) => {\n      if (this._pendingRequests[page] !== callback) {\n        return;\n      }\n      const filteredItems = this.filteredItems ? [...this.filteredItems] : [];\n      filteredItems.splice(params.page * params.pageSize, items.length, ...items);\n      this.filteredItems = filteredItems;\n      if (!this.opened && !this._isInputFocused()) {\n        this._commitValue();\n      }\n      if (size !== undefined) {\n        this.size = size;\n      }\n      delete this._pendingRequests[page];\n      if (Object.keys(this._pendingRequests).length === 0) {\n        this.loading = false;\n      }\n    };\n    this._pendingRequests[page] = callback;\n    // Set the `loading` flag only after marking the request as pending\n    // to prevent the same page from getting requested multiple times\n    // as a result of `__loadingChanged` in the scroller which requests\n    // a virtualizer update which in turn may trigger a data provider page request.\n    this.loading = true;\n    this.dataProvider(params, callback);\n  }\n\n  /** @private */\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n  clearCache() {\n    if (!this.dataProvider) {\n      return;\n    }\n    this._pendingRequests = {};\n    const filteredItems = [];\n    for (let i = 0; i < (this.size || 0); i++) {\n      filteredItems.push(this.__placeHolder);\n    }\n    this.filteredItems = filteredItems;\n    if (this._shouldFetchData()) {\n      this._forceNextRequest = false;\n      this._loadPage(0);\n    } else {\n      this._forceNextRequest = true;\n    }\n  }\n\n  /** @private */\n  _sizeChanged(size = 0) {\n    const filteredItems = (this.filteredItems || []).slice(0, size);\n    for (let i = 0; i < size; i++) {\n      filteredItems[i] = filteredItems[i] !== undefined ? filteredItems[i] : this.__placeHolder;\n    }\n    this.filteredItems = filteredItems;\n\n    // Cleans up the redundant pending requests for pages > size\n    // Refers to https://github.com/vaadin/vaadin-flow-components/issues/229\n    this._flushPendingRequests(size);\n  }\n\n  /** @private */\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {\n      this.pageSize = oldPageSize;\n      throw new Error('`pageSize` value must be an integer > 0');\n    }\n    this.clearCache();\n  }\n\n  /** @private */\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    this._ensureItemsOrDataProvider(() => {\n      this.dataProvider = oldDataProvider;\n    });\n    this.clearCache();\n  }\n\n  /** @private */\n  _ensureItemsOrDataProvider(restoreOldValueCallback) {\n    if (this.items !== undefined && this.dataProvider !== undefined) {\n      restoreOldValueCallback();\n      throw new Error('Using `items` and `dataProvider` together is not supported');\n    } else if (this.dataProvider && !this.filteredItems) {\n      this.filteredItems = [];\n    }\n  }\n\n  /** @private */\n  _warnDataProviderValue(dataProvider, value) {\n    if (dataProvider && value !== '' && (this.selectedItem === undefined || this.selectedItem === null)) {\n      const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);\n      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {\n        console.warn('Warning: unable to determine the label for the provided `value`. ' + 'Nothing to display in the text field. This usually happens when ' + 'setting an initial `value` before any items are returned from ' + 'the `dataProvider` callback. Consider setting `selectedItem` ' + 'instead of `value`');\n      }\n    }\n  }\n\n  /**\n   * This method cleans up the page callbacks which refers to the\n   * non-existing pages, i.e. which item indexes are greater than the\n   * changed size.\n   * This case is basically happens when:\n   * 1. Users scroll fast to the bottom and combo box generates the\n   * redundant page request/callback\n   * 2. Server side uses undefined size lazy loading and suddenly reaches\n   * the exact size which is on the range edge\n   * (for default page size = 50, it will be 100, 200, 300, ...).\n   * @param size the new size of items\n   * @private\n   */\n  _flushPendingRequests(size) {\n    if (this._pendingRequests) {\n      const lastPage = Math.ceil(size / this.pageSize);\n      const pendingRequestsKeys = Object.keys(this._pendingRequests);\n      for (let reqIdx = 0; reqIdx < pendingRequestsKeys.length; reqIdx++) {\n        const page = parseInt(pendingRequestsKeys[reqIdx]);\n        if (page >= lastPage) {\n          this._pendingRequests[page]([], size);\n        }\n      }\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtZGF0YS1wcm92aWRlci1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtZGF0YS1wcm92aWRlci1taXhpbi5qcz9mZjQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgQ29tYm9Cb3hQbGFjZWhvbGRlciB9IGZyb20gJy4vdmFhZGluLWNvbWJvLWJveC1wbGFjZWhvbGRlci5qcyc7XG5cbi8qKlxuICogQHBvbHltZXJNaXhpblxuICovXG5leHBvcnQgY29uc3QgQ29tYm9Cb3hEYXRhUHJvdmlkZXJNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBEYXRhUHJvdmlkZXJNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgaXRlbXMgZmV0Y2hlZCBhdCBhIHRpbWUgZnJvbSB0aGUgZGF0YXByb3ZpZGVyLlxuICAgICAgICAgKiBAYXR0ciB7bnVtYmVyfSBwYWdlLXNpemVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VTaXplOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiA1MCxcbiAgICAgICAgICBvYnNlcnZlcjogJ19wYWdlU2l6ZUNoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3RhbCBudW1iZXIgb2YgaXRlbXMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIG9ic2VydmVyOiAnX3NpemVDaGFuZ2VkJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBwcm92aWRlcyBpdGVtcyBsYXppbHkuIFJlY2VpdmVzIGFyZ3VtZW50cyBgcGFyYW1zYCwgYGNhbGxiYWNrYFxuICAgICAgICAgKlxuICAgICAgICAgKiBgcGFyYW1zLnBhZ2VgIFJlcXVlc3RlZCBwYWdlIGluZGV4XG4gICAgICAgICAqXG4gICAgICAgICAqIGBwYXJhbXMucGFnZVNpemVgIEN1cnJlbnQgcGFnZSBzaXplXG4gICAgICAgICAqXG4gICAgICAgICAqIGBwYXJhbXMuZmlsdGVyYCBDdXJyZW50bHkgYXBwbGllZCBmaWx0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogYGNhbGxiYWNrKGl0ZW1zLCBzaXplKWAgQ2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHM6XG4gICAgICAgICAqICAgLSBgaXRlbXNgIEN1cnJlbnQgcGFnZSBvZiBpdGVtc1xuICAgICAgICAgKiAgIC0gYHNpemVgIFRvdGFsIG51bWJlciBvZiBpdGVtcy5cbiAgICAgICAgICogQHR5cGUge0NvbWJvQm94RGF0YVByb3ZpZGVyIHwgdW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZGF0YVByb3ZpZGVyOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG9ic2VydmVyOiAnX2RhdGFQcm92aWRlckNoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICBfcGVuZGluZ1JlcXVlc3RzOiB7XG4gICAgICAgICAgdmFsdWU6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICBfX3BsYWNlSG9sZGVyOiB7XG4gICAgICAgICAgdmFsdWU6IG5ldyBDb21ib0JveFBsYWNlaG9sZGVyKCksXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIF9fcHJldmlvdXNEYXRhUHJvdmlkZXJGaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ19kYXRhUHJvdmlkZXJGaWx0ZXJDaGFuZ2VkKGZpbHRlciknLFxuICAgICAgICAnX3dhcm5EYXRhUHJvdmlkZXJWYWx1ZShkYXRhUHJvdmlkZXIsIHZhbHVlKScsXG4gICAgICAgICdfZW5zdXJlRmlyc3RQYWdlKG9wZW5lZCknLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgIHRoaXMuX3Njcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2luZGV4LXJlcXVlc3RlZCcsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZS5kZXRhaWwuaW5kZXg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxlclBvcyA9IGUuZGV0YWlsLmN1cnJlbnRTY3JvbGxlclBvcztcbiAgICAgICAgY29uc3QgYWxsb3dlZEluZGV4UmFuZ2UgPSBNYXRoLmZsb29yKHRoaXMucGFnZVNpemUgKiAxLjUpO1xuXG4gICAgICAgIC8vIElnbm9yZXMgdGhlIGluZGV4ZXMsIHdoaWNoIGFyZSBiZWluZyByZS1zZW50IGR1cmluZyBzY3JvbGxpbmcgcmVzZXQsXG4gICAgICAgIC8vIGlmIHRoZSBjb3JyZXNwb25kaW5nIHBhZ2UgaXMgYXJvdW5kIHRoZSBjdXJyZW50IHNjcm9sbGVyIHBvc2l0aW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZXJlIG1pZ2h0IGJlIGEgbGFzdCBwYWdlcyBkdXBsaWNhdGVzLCB3aGljaCBjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9hZGluZyBpbmRpY2F0b3IgaGFuZ2luZyBhbmQgYmxhbmsgaXRlbXNcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNraXBJbmRleChpbmRleCwgYWxsb3dlZEluZGV4UmFuZ2UsIGN1cnJlbnRTY3JvbGxlclBvcykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlRm9ySW5kZXgoaW5kZXgpO1xuICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRMb2FkUGFnZShwYWdlKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZFBhZ2UocGFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfZGF0YVByb3ZpZGVyRmlsdGVyQ2hhbmdlZChmaWx0ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9fcHJldmlvdXNEYXRhUHJvdmlkZXJGaWx0ZXIgPT09IHVuZGVmaW5lZCAmJiBmaWx0ZXIgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuX19wcmV2aW91c0RhdGFQcm92aWRlckZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fX3ByZXZpb3VzRGF0YVByb3ZpZGVyRmlsdGVyICE9PSBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5fX3ByZXZpb3VzRGF0YVByb3ZpZGVyRmlsdGVyID0gZmlsdGVyO1xuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuICAgICAgICAvLyBJbW1lZGlhdGVseSBtYXJrIGFzIGxvYWRpbmcgaWYgdGhpcyByZWZyZXNoIGxlYWRzIHRvIHJlLWZldGNoaW5nIHBhZ2VzXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgc29tZSBpc3N1ZXMgd2l0aCB0aGUgcHJvcGVydGllcyBiZWxvdyB0cmlnZ2VyaW5nXG4gICAgICAgIC8vIG9ic2VydmVycyB0aGF0IGFsc28gcmVseSBvbiB0aGUgbG9hZGluZyBzdGF0ZVxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0aGlzLl9zaG91bGRGZXRjaERhdGEoKTtcbiAgICAgICAgLy8gUmVzZXQgc2l6ZSBhbmQgaW50ZXJuYWwgbG9hZGluZyBzdGF0ZVxuICAgICAgICB0aGlzLnNpemUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3Nob3VsZEZldGNoRGF0YSgpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5vcGVuZWQgfHwgKHRoaXMuZmlsdGVyICYmIHRoaXMuZmlsdGVyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2Vuc3VyZUZpcnN0UGFnZShvcGVuZWQpIHtcbiAgICAgIGlmIChvcGVuZWQgJiYgdGhpcy5fc2hvdWxkTG9hZFBhZ2UoMCkpIHtcbiAgICAgICAgdGhpcy5fbG9hZFBhZ2UoMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3Nob3VsZFNraXBJbmRleChpbmRleCwgYWxsb3dlZEluZGV4UmFuZ2UsIGN1cnJlbnRTY3JvbGxlclBvcykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3VycmVudFNjcm9sbGVyUG9zICE9PSAwICYmXG4gICAgICAgIGluZGV4ID49IGN1cnJlbnRTY3JvbGxlclBvcyAtIGFsbG93ZWRJbmRleFJhbmdlICYmXG4gICAgICAgIGluZGV4IDw9IGN1cnJlbnRTY3JvbGxlclBvcyArIGFsbG93ZWRJbmRleFJhbmdlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9zaG91bGRMb2FkUGFnZShwYWdlKSB7XG4gICAgICBpZiAoIXRoaXMuZmlsdGVyZWRJdGVtcyB8fCB0aGlzLl9mb3JjZU5leHRSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuX2ZvcmNlTmV4dFJlcXVlc3QgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRlZEl0ZW0gPSB0aGlzLmZpbHRlcmVkSXRlbXNbcGFnZSAqIHRoaXMucGFnZVNpemVdO1xuICAgICAgaWYgKGxvYWRlZEl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbG9hZGVkSXRlbSBpbnN0YW5jZW9mIENvbWJvQm94UGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zaXplID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2xvYWRQYWdlKHBhZ2UpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBzYW1lIHBhZ2UgaXNuJ3QgcmVxdWVzdGVkIG11bHRpcGxlIHRpbWVzLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1twYWdlXSB8fCAhdGhpcy5kYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoaXRlbXMsIHNpemUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1twYWdlXSAhPT0gY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gdGhpcy5maWx0ZXJlZEl0ZW1zID8gWy4uLnRoaXMuZmlsdGVyZWRJdGVtc10gOiBbXTtcbiAgICAgICAgZmlsdGVyZWRJdGVtcy5zcGxpY2UocGFyYW1zLnBhZ2UgKiBwYXJhbXMucGFnZVNpemUsIGl0ZW1zLmxlbmd0aCwgLi4uaXRlbXMpO1xuICAgICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSBmaWx0ZXJlZEl0ZW1zO1xuXG4gICAgICAgIGlmICghdGhpcy5vcGVuZWQgJiYgIXRoaXMuX2lzSW5wdXRGb2N1c2VkKCkpIHtcbiAgICAgICAgICB0aGlzLl9jb21taXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3BhZ2VdO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9wZW5kaW5nUmVxdWVzdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbcGFnZV0gPSBjYWxsYmFjaztcbiAgICAgIC8vIFNldCB0aGUgYGxvYWRpbmdgIGZsYWcgb25seSBhZnRlciBtYXJraW5nIHRoZSByZXF1ZXN0IGFzIHBlbmRpbmdcbiAgICAgIC8vIHRvIHByZXZlbnQgdGhlIHNhbWUgcGFnZSBmcm9tIGdldHRpbmcgcmVxdWVzdGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAvLyBhcyBhIHJlc3VsdCBvZiBgX19sb2FkaW5nQ2hhbmdlZGAgaW4gdGhlIHNjcm9sbGVyIHdoaWNoIHJlcXVlc3RzXG4gICAgICAvLyBhIHZpcnR1YWxpemVyIHVwZGF0ZSB3aGljaCBpbiB0dXJuIG1heSB0cmlnZ2VyIGEgZGF0YSBwcm92aWRlciBwYWdlIHJlcXVlc3QuXG4gICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5kYXRhUHJvdmlkZXIocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2dldFBhZ2VGb3JJbmRleChpbmRleCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnBhZ2VTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBwYWdlcyBhbmQgcmVsb2FkcyBkYXRhIGZyb20gZGF0YXByb3ZpZGVyIHdoZW4gbmVlZGVkLlxuICAgICAqL1xuICAgIGNsZWFyQ2FjaGUoKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YVByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzID0ge307XG4gICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICh0aGlzLnNpemUgfHwgMCk7IGkrKykge1xuICAgICAgICBmaWx0ZXJlZEl0ZW1zLnB1c2godGhpcy5fX3BsYWNlSG9sZGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IGZpbHRlcmVkSXRlbXM7XG5cbiAgICAgIGlmICh0aGlzLl9zaG91bGRGZXRjaERhdGEoKSkge1xuICAgICAgICB0aGlzLl9mb3JjZU5leHRSZXF1ZXN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xvYWRQYWdlKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZm9yY2VOZXh0UmVxdWVzdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3NpemVDaGFuZ2VkKHNpemUgPSAwKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gKHRoaXMuZmlsdGVyZWRJdGVtcyB8fCBbXSkuc2xpY2UoMCwgc2l6ZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBmaWx0ZXJlZEl0ZW1zW2ldID0gZmlsdGVyZWRJdGVtc1tpXSAhPT0gdW5kZWZpbmVkID8gZmlsdGVyZWRJdGVtc1tpXSA6IHRoaXMuX19wbGFjZUhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IGZpbHRlcmVkSXRlbXM7XG5cbiAgICAgIC8vIENsZWFucyB1cCB0aGUgcmVkdW5kYW50IHBlbmRpbmcgcmVxdWVzdHMgZm9yIHBhZ2VzID4gc2l6ZVxuICAgICAgLy8gUmVmZXJzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS92YWFkaW4vdmFhZGluLWZsb3ctY29tcG9uZW50cy9pc3N1ZXMvMjI5XG4gICAgICB0aGlzLl9mbHVzaFBlbmRpbmdSZXF1ZXN0cyhzaXplKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfcGFnZVNpemVDaGFuZ2VkKHBhZ2VTaXplLCBvbGRQYWdlU2l6ZSkge1xuICAgICAgaWYgKE1hdGguZmxvb3IocGFnZVNpemUpICE9PSBwYWdlU2l6ZSB8fCBwYWdlU2l6ZSA8IDEpIHtcbiAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IG9sZFBhZ2VTaXplO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BwYWdlU2l6ZWAgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyID4gMCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2RhdGFQcm92aWRlckNoYW5nZWQoZGF0YVByb3ZpZGVyLCBvbGREYXRhUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZUl0ZW1zT3JEYXRhUHJvdmlkZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IG9sZERhdGFQcm92aWRlcjtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfZW5zdXJlSXRlbXNPckRhdGFQcm92aWRlcihyZXN0b3JlT2xkVmFsdWVDYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuaXRlbXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmRhdGFQcm92aWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3RvcmVPbGRWYWx1ZUNhbGxiYWNrKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgYGl0ZW1zYCBhbmQgYGRhdGFQcm92aWRlcmAgdG9nZXRoZXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFQcm92aWRlciAmJiAhdGhpcy5maWx0ZXJlZEl0ZW1zKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IFtdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF93YXJuRGF0YVByb3ZpZGVyVmFsdWUoZGF0YVByb3ZpZGVyLCB2YWx1ZSkge1xuICAgICAgaWYgKGRhdGFQcm92aWRlciAmJiB2YWx1ZSAhPT0gJycgJiYgKHRoaXMuc2VsZWN0ZWRJdGVtID09PSB1bmRlZmluZWQgfHwgdGhpcy5zZWxlY3RlZEl0ZW0gPT09IG51bGwpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlSW5kZXggPSB0aGlzLl9fZ2V0SXRlbUluZGV4QnlWYWx1ZSh0aGlzLmZpbHRlcmVkSXRlbXMsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlSW5kZXggPCAwIHx8ICF0aGlzLl9nZXRJdGVtTGFiZWwodGhpcy5maWx0ZXJlZEl0ZW1zW3ZhbHVlSW5kZXhdKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdXYXJuaW5nOiB1bmFibGUgdG8gZGV0ZXJtaW5lIHRoZSBsYWJlbCBmb3IgdGhlIHByb3ZpZGVkIGB2YWx1ZWAuICcgK1xuICAgICAgICAgICAgICAnTm90aGluZyB0byBkaXNwbGF5IGluIHRoZSB0ZXh0IGZpZWxkLiBUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuICcgK1xuICAgICAgICAgICAgICAnc2V0dGluZyBhbiBpbml0aWFsIGB2YWx1ZWAgYmVmb3JlIGFueSBpdGVtcyBhcmUgcmV0dXJuZWQgZnJvbSAnICtcbiAgICAgICAgICAgICAgJ3RoZSBgZGF0YVByb3ZpZGVyYCBjYWxsYmFjay4gQ29uc2lkZXIgc2V0dGluZyBgc2VsZWN0ZWRJdGVtYCAnICtcbiAgICAgICAgICAgICAgJ2luc3RlYWQgb2YgYHZhbHVlYCcsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNsZWFucyB1cCB0aGUgcGFnZSBjYWxsYmFja3Mgd2hpY2ggcmVmZXJzIHRvIHRoZVxuICAgICAqIG5vbi1leGlzdGluZyBwYWdlcywgaS5lLiB3aGljaCBpdGVtIGluZGV4ZXMgYXJlIGdyZWF0ZXIgdGhhbiB0aGVcbiAgICAgKiBjaGFuZ2VkIHNpemUuXG4gICAgICogVGhpcyBjYXNlIGlzIGJhc2ljYWxseSBoYXBwZW5zIHdoZW46XG4gICAgICogMS4gVXNlcnMgc2Nyb2xsIGZhc3QgdG8gdGhlIGJvdHRvbSBhbmQgY29tYm8gYm94IGdlbmVyYXRlcyB0aGVcbiAgICAgKiByZWR1bmRhbnQgcGFnZSByZXF1ZXN0L2NhbGxiYWNrXG4gICAgICogMi4gU2VydmVyIHNpZGUgdXNlcyB1bmRlZmluZWQgc2l6ZSBsYXp5IGxvYWRpbmcgYW5kIHN1ZGRlbmx5IHJlYWNoZXNcbiAgICAgKiB0aGUgZXhhY3Qgc2l6ZSB3aGljaCBpcyBvbiB0aGUgcmFuZ2UgZWRnZVxuICAgICAqIChmb3IgZGVmYXVsdCBwYWdlIHNpemUgPSA1MCwgaXQgd2lsbCBiZSAxMDAsIDIwMCwgMzAwLCAuLi4pLlxuICAgICAqIEBwYXJhbSBzaXplIHRoZSBuZXcgc2l6ZSBvZiBpdGVtc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZsdXNoUGVuZGluZ1JlcXVlc3RzKHNpemUpIHtcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVxdWVzdHMpIHtcbiAgICAgICAgY29uc3QgbGFzdFBhZ2UgPSBNYXRoLmNlaWwoc2l6ZSAvIHRoaXMucGFnZVNpemUpO1xuICAgICAgICBjb25zdCBwZW5kaW5nUmVxdWVzdHNLZXlzID0gT2JqZWN0LmtleXModGhpcy5fcGVuZGluZ1JlcXVlc3RzKTtcbiAgICAgICAgZm9yIChsZXQgcmVxSWR4ID0gMDsgcmVxSWR4IDwgcGVuZGluZ1JlcXVlc3RzS2V5cy5sZW5ndGg7IHJlcUlkeCsrKSB7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KHBlbmRpbmdSZXF1ZXN0c0tleXNbcmVxSWR4XSk7XG4gICAgICAgICAgaWYgKHBhZ2UgPj0gbGFzdFBhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1twYWdlXShbXSwgc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxItem\": () => (/* binding */ ComboBoxItem)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/component-base/src/dir-mixin.js */ \"./node_modules/@vaadin/component-base/src/dir-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n/**\n * An item element used by the `<vaadin-combo-box>` dropdown.\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name   | Description\n * ------------|--------------\n * `checkmark` | The graphical checkmark shown for a selected item\n * `content`   | The element that wraps the item content\n *\n * The following state attributes are exposed for styling:\n *\n * Attribute    | Description\n * -------------|-------------\n * `selected`   | Set when the item is selected\n * `focused`    | Set when the item is focused\n *\n * See [Styling Components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components) documentation.\n *\n * @mixes ThemableMixin\n * @mixes DirMixin\n * @private\n */\nclass ComboBoxItem extends (0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__.ThemableMixin)((0,_vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_1__.DirMixin)(_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.PolymerElement)) {\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.html`\n      <style>\n        :host {\n          display: block;\n        }\n\n        :host([hidden]) {\n          display: none;\n        }\n      </style>\n      <span part=\"checkmark\" aria-hidden=\"true\"></span>\n      <div part=\"content\">\n        <slot></slot>\n      </div>\n    `;\n  }\n  static get is() {\n    return 'vaadin-combo-box-item';\n  }\n  static get properties() {\n    return {\n      /**\n       * The index of the item\n       */\n      index: Number,\n      /**\n       * The item to render\n       * @type {(String|Object)}\n       */\n      item: Object,\n      /**\n       * The text label corresponding to the item\n       */\n      label: String,\n      /**\n       * True when item is selected\n       */\n      selected: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * True when item is focused\n       */\n      focused: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * Custom function for rendering the content of the `<vaadin-combo-box-item>` propagated from the combo box element.\n       */\n      renderer: Function,\n      /**\n       * Saved instance of a custom renderer function.\n       */\n      _oldRenderer: Function\n    };\n  }\n  static get observers() {\n    return ['__rendererOrItemChanged(renderer, index, item.*, selected, focused)', '__updateLabel(label, renderer)'];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this._comboBox = this.parentNode.comboBox;\n    const hostDir = this._comboBox.getAttribute('dir');\n    if (hostDir) {\n      this.setAttribute('dir', hostDir);\n    }\n  }\n\n  /**\n   * Requests an update for the content of the item.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (!this.renderer) {\n      return;\n    }\n    const model = {\n      index: this.index,\n      item: this.item,\n      focused: this.focused,\n      selected: this.selected\n    };\n    this.renderer(this, this._comboBox, model);\n  }\n\n  /** @private */\n  __rendererOrItemChanged(renderer, index, item) {\n    if (item === undefined || index === undefined) {\n      return;\n    }\n    if (this._oldRenderer !== renderer) {\n      this.innerHTML = '';\n      // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n      // When clearing the rendered content, this part needs to be manually disposed of.\n      // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n      delete this._$litPart$;\n    }\n    if (renderer) {\n      this._oldRenderer = renderer;\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @private */\n  __updateLabel(label, renderer) {\n    if (renderer) {\n      return;\n    }\n    this.textContent = label;\n  }\n}\ncustomElements.define(ComboBoxItem.is, ComboBoxItem);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtaXRlbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtaXRlbS5qcz82ZWJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgaHRtbCwgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBEaXJNaXhpbiB9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2Rpci1taXhpbi5qcyc7XG5pbXBvcnQgeyBUaGVtYWJsZU1peGluIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuLyoqXG4gKiBBbiBpdGVtIGVsZW1lbnQgdXNlZCBieSB0aGUgYDx2YWFkaW4tY29tYm8tYm94PmAgZHJvcGRvd24uXG4gKlxuICogIyMjIFN0eWxpbmdcbiAqXG4gKiBUaGUgZm9sbG93aW5nIHNoYWRvdyBET00gcGFydHMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcbiAqXG4gKiBQYXJ0IG5hbWUgICB8IERlc2NyaXB0aW9uXG4gKiAtLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS1cbiAqIGBjaGVja21hcmtgIHwgVGhlIGdyYXBoaWNhbCBjaGVja21hcmsgc2hvd24gZm9yIGEgc2VsZWN0ZWQgaXRlbVxuICogYGNvbnRlbnRgICAgfCBUaGUgZWxlbWVudCB0aGF0IHdyYXBzIHRoZSBpdGVtIGNvbnRlbnRcbiAqXG4gKiBUaGUgZm9sbG93aW5nIHN0YXRlIGF0dHJpYnV0ZXMgYXJlIGV4cG9zZWQgZm9yIHN0eWxpbmc6XG4gKlxuICogQXR0cmlidXRlICAgIHwgRGVzY3JpcHRpb25cbiAqIC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLVxuICogYHNlbGVjdGVkYCAgIHwgU2V0IHdoZW4gdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAqIGBmb2N1c2VkYCAgICB8IFNldCB3aGVuIHRoZSBpdGVtIGlzIGZvY3VzZWRcbiAqXG4gKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50c10oaHR0cHM6Ly92YWFkaW4uY29tL2RvY3MvbGF0ZXN0L3N0eWxpbmcvY3VzdG9tLXRoZW1lL3N0eWxpbmctY29tcG9uZW50cykgZG9jdW1lbnRhdGlvbi5cbiAqXG4gKiBAbWl4ZXMgVGhlbWFibGVNaXhpblxuICogQG1peGVzIERpck1peGluXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29tYm9Cb3hJdGVtIGV4dGVuZHMgVGhlbWFibGVNaXhpbihEaXJNaXhpbihQb2x5bWVyRWxlbWVudCkpIHtcbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxzdHlsZT5cbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPHNwYW4gcGFydD1cImNoZWNrbWFya1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbiAgICAgIDxkaXYgcGFydD1cImNvbnRlbnRcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgaXMoKSB7XG4gICAgcmV0dXJuICd2YWFkaW4tY29tYm8tYm94LWl0ZW0nO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgaXRlbVxuICAgICAgICovXG4gICAgICBpbmRleDogTnVtYmVyLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBpdGVtIHRvIHJlbmRlclxuICAgICAgICogQHR5cGUgeyhTdHJpbmd8T2JqZWN0KX1cbiAgICAgICAqL1xuICAgICAgaXRlbTogT2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0ZXh0IGxhYmVsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGl0ZW1cbiAgICAgICAqL1xuICAgICAgbGFiZWw6IFN0cmluZyxcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnVlIHdoZW4gaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICovXG4gICAgICBzZWxlY3RlZDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSB3aGVuIGl0ZW0gaXMgZm9jdXNlZFxuICAgICAgICovXG4gICAgICBmb2N1c2VkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDdXN0b20gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyB0aGUgY29udGVudCBvZiB0aGUgYDx2YWFkaW4tY29tYm8tYm94LWl0ZW0+YCBwcm9wYWdhdGVkIGZyb20gdGhlIGNvbWJvIGJveCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICByZW5kZXJlcjogRnVuY3Rpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2F2ZWQgaW5zdGFuY2Ugb2YgYSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIF9vbGRSZW5kZXJlcjogRnVuY3Rpb24sXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgIHJldHVybiBbJ19fcmVuZGVyZXJPckl0ZW1DaGFuZ2VkKHJlbmRlcmVyLCBpbmRleCwgaXRlbS4qLCBzZWxlY3RlZCwgZm9jdXNlZCknLCAnX191cGRhdGVMYWJlbChsYWJlbCwgcmVuZGVyZXIpJ107XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgdGhpcy5fY29tYm9Cb3ggPSB0aGlzLnBhcmVudE5vZGUuY29tYm9Cb3g7XG5cbiAgICBjb25zdCBob3N0RGlyID0gdGhpcy5fY29tYm9Cb3guZ2V0QXR0cmlidXRlKCdkaXInKTtcbiAgICBpZiAoaG9zdERpcikge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2RpcicsIGhvc3REaXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbiB1cGRhdGUgZm9yIHRoZSBjb250ZW50IG9mIHRoZSBpdGVtLlxuICAgKiBXaGlsZSBwZXJmb3JtaW5nIHRoZSB1cGRhdGUsIGl0IGludm9rZXMgdGhlIHJlbmRlcmVyIHBhc3NlZCBpbiB0aGUgYHJlbmRlcmVyYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCB0aGUgdXBkYXRlIGhhcHBlbnMgaW1tZWRpYXRlbHkgKHN5bmNocm9ub3VzbHkpIGFmdGVyIGl0IGlzIHJlcXVlc3RlZC5cbiAgICovXG4gIHJlcXVlc3RDb250ZW50VXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGVsID0ge1xuICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICBpdGVtOiB0aGlzLml0ZW0sXG4gICAgICBmb2N1c2VkOiB0aGlzLmZvY3VzZWQsXG4gICAgICBzZWxlY3RlZDogdGhpcy5zZWxlY3RlZCxcbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJlcih0aGlzLCB0aGlzLl9jb21ib0JveCwgbW9kZWwpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fcmVuZGVyZXJPckl0ZW1DaGFuZ2VkKHJlbmRlcmVyLCBpbmRleCwgaXRlbSkge1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vbGRSZW5kZXJlciAhPT0gcmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gJyc7XG4gICAgICAvLyBXaGVuZXZlciBhIExpdC1iYXNlZCByZW5kZXJlciBpcyB1c2VkLCBpdCBhc3NpZ25zIGEgTGl0IHBhcnQgdG8gdGhlIG5vZGUgaXQgd2FzIHJlbmRlcmVkIGludG8uXG4gICAgICAvLyBXaGVuIGNsZWFyaW5nIHRoZSByZW5kZXJlZCBjb250ZW50LCB0aGlzIHBhcnQgbmVlZHMgdG8gYmUgbWFudWFsbHkgZGlzcG9zZWQgb2YuXG4gICAgICAvLyBPdGhlcndpc2UsIHVzaW5nIGEgTGl0LWJhc2VkIHJlbmRlcmVyIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gb3IgcmVuZGVyIG5vdGhpbmcgYWZ0ZXJ3YXJkLlxuICAgICAgZGVsZXRlIHRoaXMuXyRsaXRQYXJ0JDtcbiAgICB9XG5cbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuX29sZFJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fdXBkYXRlTGFiZWwobGFiZWwsIHJlbmRlcmVyKSB7XG4gICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGxhYmVsO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShDb21ib0JveEl0ZW0uaXMsIENvbWJvQm94SXRlbSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxLight\": () => (/* binding */ ComboBoxLight)\n/* harmony export */ });\n/* harmony import */ var _vaadin_combo_box_item_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-combo-box-item.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-item.js\");\n/* harmony import */ var _vaadin_combo_box_overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-combo-box-overlay.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js\");\n/* harmony import */ var _vaadin_combo_box_scroller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vaadin-combo-box-scroller.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_case_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/utils/case-map.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/case-map.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/render-status.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/lib/utils/render-status.js\");\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_field_base_src_validate_mixin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @vaadin/field-base/src/validate-mixin.js */ \"./node_modules/@vaadin/field-base/src/validate-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/* harmony import */ var _vaadin_combo_box_data_provider_mixin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vaadin-combo-box-data-provider-mixin.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js\");\n/* harmony import */ var _vaadin_combo_box_mixin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vaadin-combo-box-mixin.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * `<vaadin-combo-box-light>` is a customizable version of the `<vaadin-combo-box>` providing\n * only the dropdown functionality and leaving the input field definition to the user.\n *\n * The element has the same API as `<vaadin-combo-box>`.\n *\n * To create a custom input field, you need to add a child element which has a two-way\n * data-bindable property representing the input value. The property name is expected\n * to be `value` by default. For example, you can use `<vaadin-text-field>` element:\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <vaadin-text-field></vaadin-text-field>\n * </vaadin-combo-box-light>\n * ```\n *\n * If you are using custom input field that has other property for value,\n * set `class=\"input\"` to enable corresponding logic, and use `attr-for-value`\n * attribute to specify which property to use:\n *\n * ```html\n * <vaadin-combo-box-light attr-for-value=\"input-value\">\n *   <custom-input class=\"input\"></custom-input>\n * </vaadin-combo-box-light>\n * ```\n *\n * You can also pass custom toggle and clear buttons with corresponding classes:\n *\n * ```html\n * <vaadin-combo-box-light>\n *   <custom-input class=\"input\" attr-for-value=\"input-value\">\n *     <button slot=\"suffix\" class=\"clear-button\">Clear</button>\n *     <button slot=\"suffix\" class=\"toggle-button\">Toggle</button>\n *   </custom-input>\n * </vaadin-combo-box-light>\n * ```\n *\n * @fires {Event} change - Fired when the user commits a value change.\n * @fires {CustomEvent} custom-value-set - Fired when the user sets a custom value.\n * @fires {CustomEvent} filter-changed - Fired when the `filter` property changes.\n * @fires {CustomEvent} invalid-changed - Fired when the `invalid` property changes.\n * @fires {CustomEvent} opened-changed - Fired when the `opened` property changes.\n * @fires {CustomEvent} selected-item-changed - Fired when the `selectedItem` property changes.\n * @fires {CustomEvent} value-changed - Fired when the `value` property changes.\n * @fires {CustomEvent} validated - Fired whenever the field is validated.\n *\n * @extends HTMLElement\n * @mixes ComboBoxDataProviderMixin\n * @mixes ComboBoxMixin\n * @mixes ThemableMixin\n * @mixes ValidateMixin\n */\nclass ComboBoxLight extends (0,_vaadin_combo_box_data_provider_mixin_js__WEBPACK_IMPORTED_MODULE_8__.ComboBoxDataProviderMixin)((0,_vaadin_combo_box_mixin_js__WEBPACK_IMPORTED_MODULE_9__.ComboBoxMixin)((0,_vaadin_field_base_src_validate_mixin_js__WEBPACK_IMPORTED_MODULE_6__.ValidateMixin)((0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_7__.ThemableMixin)(_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_5__.PolymerElement)))) {\n  static get is() {\n    return 'vaadin-combo-box-light';\n  }\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_5__.html`\n      <style>\n        :host([opened]) {\n          pointer-events: auto;\n        }\n      </style>\n\n      <slot></slot>\n\n      <vaadin-combo-box-overlay\n        id=\"overlay\"\n        opened=\"[[_overlayOpened]]\"\n        loading$=\"[[loading]]\"\n        theme$=\"[[_theme]]\"\n        position-target=\"[[inputElement]]\"\n        no-vertical-overlap\n        restore-focus-node=\"[[inputElement]]\"\n      ></vaadin-combo-box-overlay>\n    `;\n  }\n  static get properties() {\n    return {\n      /**\n       * Name of the two-way data-bindable property representing the\n       * value of the custom input field.\n       * @attr {string} attr-for-value\n       * @type {string}\n       */\n      attrForValue: {\n        type: String,\n        value: 'value'\n      }\n    };\n  }\n\n  /**\n   * Used by `InputControlMixin` as a reference to the clear button element.\n   * @protected\n   * @return {!HTMLElement}\n   */\n  get clearElement() {\n    return this.querySelector('.clear-button');\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this._toggleElement = this.querySelector('.toggle-button');\n\n    // Wait until the slotted input DOM is ready\n    (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_4__.afterNextRender)(this, () => {\n      this._setInputElement(this.querySelector('vaadin-text-field,.input'));\n      this._revertInputValue();\n    });\n  }\n\n  /**\n   * Returns true if the current input value satisfies all constraints (if any).\n   * @return {boolean}\n   */\n  checkValidity() {\n    if (this.inputElement.validate) {\n      return this.inputElement.validate();\n    }\n    return super.checkValidity();\n  }\n\n  /**\n   * @return {string}\n   * @protected\n   */\n  get _propertyForValue() {\n    return (0,_polymer_polymer_lib_utils_case_map_js__WEBPACK_IMPORTED_MODULE_3__.dashToCamelCase)(this.attrForValue);\n  }\n\n  /**\n   * @protected\n   * @override\n   * @return {HTMLInputElement | undefined}\n   */\n  get _nativeInput() {\n    const input = this.inputElement;\n    if (input) {\n      // Support `<input class=\"input\">`\n      if (input instanceof HTMLInputElement) {\n        return input;\n      }\n\n      // Support `<input>` in light DOM (e.g. `vaadin-text-field`)\n      const slottedInput = input.querySelector('input');\n      if (slottedInput) {\n        return slottedInput;\n      }\n      if (input.shadowRoot) {\n        // Support `<input>` in Shadow DOM (e.g. `mwc-textfield`)\n        const shadowInput = input.shadowRoot.querySelector('input');\n        if (shadowInput) {\n          return shadowInput;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /** @protected */\n  _isClearButton(event) {\n    return super._isClearButton(event) || event.type === 'input' && !event.isTrusted ||\n    // Fake input event dispatched by clear button\n    event.composedPath()[0].getAttribute('part') === 'clear-button';\n  }\n\n  /**\n   * @param {!Event} event\n   * @protected\n   */\n  _onChange(event) {\n    super._onChange(event);\n    if (this._isClearButton(event)) {\n      this._clear();\n    }\n  }\n}\ncustomElements.define(ComboBoxLight.is, ComboBoxLight);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtbGlnaHQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9zcmMvdmFhZGluLWNvbWJvLWJveC1saWdodC5qcz9iZjYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0ICcuL3ZhYWRpbi1jb21iby1ib3gtaXRlbS5qcyc7XG5pbXBvcnQgJy4vdmFhZGluLWNvbWJvLWJveC1vdmVybGF5LmpzJztcbmltcG9ydCAnLi92YWFkaW4tY29tYm8tYm94LXNjcm9sbGVyLmpzJztcbmltcG9ydCB7IGRhc2hUb0NhbWVsQ2FzZSB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGFmdGVyTmV4dFJlbmRlciB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMnO1xuaW1wb3J0IHsgaHRtbCwgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBWYWxpZGF0ZU1peGluIH0gZnJvbSAnQHZhYWRpbi9maWVsZC1iYXNlL3NyYy92YWxpZGF0ZS1taXhpbi5qcyc7XG5pbXBvcnQgeyBUaGVtYWJsZU1peGluIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcbmltcG9ydCB7IENvbWJvQm94RGF0YVByb3ZpZGVyTWl4aW4gfSBmcm9tICcuL3ZhYWRpbi1jb21iby1ib3gtZGF0YS1wcm92aWRlci1taXhpbi5qcyc7XG5pbXBvcnQgeyBDb21ib0JveE1peGluIH0gZnJvbSAnLi92YWFkaW4tY29tYm8tYm94LW1peGluLmpzJztcblxuLyoqXG4gKiBgPHZhYWRpbi1jb21iby1ib3gtbGlnaHQ+YCBpcyBhIGN1c3RvbWl6YWJsZSB2ZXJzaW9uIG9mIHRoZSBgPHZhYWRpbi1jb21iby1ib3g+YCBwcm92aWRpbmdcbiAqIG9ubHkgdGhlIGRyb3Bkb3duIGZ1bmN0aW9uYWxpdHkgYW5kIGxlYXZpbmcgdGhlIGlucHV0IGZpZWxkIGRlZmluaXRpb24gdG8gdGhlIHVzZXIuXG4gKlxuICogVGhlIGVsZW1lbnQgaGFzIHRoZSBzYW1lIEFQSSBhcyBgPHZhYWRpbi1jb21iby1ib3g+YC5cbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gaW5wdXQgZmllbGQsIHlvdSBuZWVkIHRvIGFkZCBhIGNoaWxkIGVsZW1lbnQgd2hpY2ggaGFzIGEgdHdvLXdheVxuICogZGF0YS1iaW5kYWJsZSBwcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIGlucHV0IHZhbHVlLiBUaGUgcHJvcGVydHkgbmFtZSBpcyBleHBlY3RlZFxuICogdG8gYmUgYHZhbHVlYCBieSBkZWZhdWx0LiBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgYDx2YWFkaW4tdGV4dC1maWVsZD5gIGVsZW1lbnQ6XG4gKlxuICogYGBgaHRtbFxuICogPHZhYWRpbi1jb21iby1ib3gtbGlnaHQ+XG4gKiAgIDx2YWFkaW4tdGV4dC1maWVsZD48L3ZhYWRpbi10ZXh0LWZpZWxkPlxuICogPC92YWFkaW4tY29tYm8tYm94LWxpZ2h0PlxuICogYGBgXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBjdXN0b20gaW5wdXQgZmllbGQgdGhhdCBoYXMgb3RoZXIgcHJvcGVydHkgZm9yIHZhbHVlLFxuICogc2V0IGBjbGFzcz1cImlucHV0XCJgIHRvIGVuYWJsZSBjb3JyZXNwb25kaW5nIGxvZ2ljLCBhbmQgdXNlIGBhdHRyLWZvci12YWx1ZWBcbiAqIGF0dHJpYnV0ZSB0byBzcGVjaWZ5IHdoaWNoIHByb3BlcnR5IHRvIHVzZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8dmFhZGluLWNvbWJvLWJveC1saWdodCBhdHRyLWZvci12YWx1ZT1cImlucHV0LXZhbHVlXCI+XG4gKiAgIDxjdXN0b20taW5wdXQgY2xhc3M9XCJpbnB1dFwiPjwvY3VzdG9tLWlucHV0PlxuICogPC92YWFkaW4tY29tYm8tYm94LWxpZ2h0PlxuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgY3VzdG9tIHRvZ2dsZSBhbmQgY2xlYXIgYnV0dG9ucyB3aXRoIGNvcnJlc3BvbmRpbmcgY2xhc3NlczpcbiAqXG4gKiBgYGBodG1sXG4gKiA8dmFhZGluLWNvbWJvLWJveC1saWdodD5cbiAqICAgPGN1c3RvbS1pbnB1dCBjbGFzcz1cImlucHV0XCIgYXR0ci1mb3ItdmFsdWU9XCJpbnB1dC12YWx1ZVwiPlxuICogICAgIDxidXR0b24gc2xvdD1cInN1ZmZpeFwiIGNsYXNzPVwiY2xlYXItYnV0dG9uXCI+Q2xlYXI8L2J1dHRvbj5cbiAqICAgICA8YnV0dG9uIHNsb3Q9XCJzdWZmaXhcIiBjbGFzcz1cInRvZ2dsZS1idXR0b25cIj5Ub2dnbGU8L2J1dHRvbj5cbiAqICAgPC9jdXN0b20taW5wdXQ+XG4gKiA8L3ZhYWRpbi1jb21iby1ib3gtbGlnaHQ+XG4gKiBgYGBcbiAqXG4gKiBAZmlyZXMge0V2ZW50fSBjaGFuZ2UgLSBGaXJlZCB3aGVuIHRoZSB1c2VyIGNvbW1pdHMgYSB2YWx1ZSBjaGFuZ2UuXG4gKiBAZmlyZXMge0N1c3RvbUV2ZW50fSBjdXN0b20tdmFsdWUtc2V0IC0gRmlyZWQgd2hlbiB0aGUgdXNlciBzZXRzIGEgY3VzdG9tIHZhbHVlLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gZmlsdGVyLWNoYW5nZWQgLSBGaXJlZCB3aGVuIHRoZSBgZmlsdGVyYCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gaW52YWxpZC1jaGFuZ2VkIC0gRmlyZWQgd2hlbiB0aGUgYGludmFsaWRgIHByb3BlcnR5IGNoYW5nZXMuXG4gKiBAZmlyZXMge0N1c3RvbUV2ZW50fSBvcGVuZWQtY2hhbmdlZCAtIEZpcmVkIHdoZW4gdGhlIGBvcGVuZWRgIHByb3BlcnR5IGNoYW5nZXMuXG4gKiBAZmlyZXMge0N1c3RvbUV2ZW50fSBzZWxlY3RlZC1pdGVtLWNoYW5nZWQgLSBGaXJlZCB3aGVuIHRoZSBgc2VsZWN0ZWRJdGVtYCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gdmFsdWUtY2hhbmdlZCAtIEZpcmVkIHdoZW4gdGhlIGB2YWx1ZWAgcHJvcGVydHkgY2hhbmdlcy5cbiAqIEBmaXJlcyB7Q3VzdG9tRXZlbnR9IHZhbGlkYXRlZCAtIEZpcmVkIHdoZW5ldmVyIHRoZSBmaWVsZCBpcyB2YWxpZGF0ZWQuXG4gKlxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBtaXhlcyBDb21ib0JveERhdGFQcm92aWRlck1peGluXG4gKiBAbWl4ZXMgQ29tYm9Cb3hNaXhpblxuICogQG1peGVzIFRoZW1hYmxlTWl4aW5cbiAqIEBtaXhlcyBWYWxpZGF0ZU1peGluXG4gKi9cbmNsYXNzIENvbWJvQm94TGlnaHQgZXh0ZW5kcyBDb21ib0JveERhdGFQcm92aWRlck1peGluKENvbWJvQm94TWl4aW4oVmFsaWRhdGVNaXhpbihUaGVtYWJsZU1peGluKFBvbHltZXJFbGVtZW50KSkpKSB7XG4gIHN0YXRpYyBnZXQgaXMoKSB7XG4gICAgcmV0dXJuICd2YWFkaW4tY29tYm8tYm94LWxpZ2h0JztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0KFtvcGVuZWRdKSB7XG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxzbG90Pjwvc2xvdD5cblxuICAgICAgPHZhYWRpbi1jb21iby1ib3gtb3ZlcmxheVxuICAgICAgICBpZD1cIm92ZXJsYXlcIlxuICAgICAgICBvcGVuZWQ9XCJbW19vdmVybGF5T3BlbmVkXV1cIlxuICAgICAgICBsb2FkaW5nJD1cIltbbG9hZGluZ11dXCJcbiAgICAgICAgdGhlbWUkPVwiW1tfdGhlbWVdXVwiXG4gICAgICAgIHBvc2l0aW9uLXRhcmdldD1cIltbaW5wdXRFbGVtZW50XV1cIlxuICAgICAgICBuby12ZXJ0aWNhbC1vdmVybGFwXG4gICAgICAgIHJlc3RvcmUtZm9jdXMtbm9kZT1cIltbaW5wdXRFbGVtZW50XV1cIlxuICAgICAgPjwvdmFhZGluLWNvbWJvLWJveC1vdmVybGF5PlxuICAgIGA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogTmFtZSBvZiB0aGUgdHdvLXdheSBkYXRhLWJpbmRhYmxlIHByb3BlcnR5IHJlcHJlc2VudGluZyB0aGVcbiAgICAgICAqIHZhbHVlIG9mIHRoZSBjdXN0b20gaW5wdXQgZmllbGQuXG4gICAgICAgKiBAYXR0ciB7c3RyaW5nfSBhdHRyLWZvci12YWx1ZVxuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgYXR0ckZvclZhbHVlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICd2YWx1ZScsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgSW5wdXRDb250cm9sTWl4aW5gIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBjbGVhciBidXR0b24gZWxlbWVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHshSFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXQgY2xlYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5jbGVhci1idXR0b24nKTtcbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIHJlYWR5KCkge1xuICAgIHN1cGVyLnJlYWR5KCk7XG5cbiAgICB0aGlzLl90b2dnbGVFbGVtZW50ID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcudG9nZ2xlLWJ1dHRvbicpO1xuXG4gICAgLy8gV2FpdCB1bnRpbCB0aGUgc2xvdHRlZCBpbnB1dCBET00gaXMgcmVhZHlcbiAgICBhZnRlck5leHRSZW5kZXIodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0SW5wdXRFbGVtZW50KHRoaXMucXVlcnlTZWxlY3RvcigndmFhZGluLXRleHQtZmllbGQsLmlucHV0JykpO1xuICAgICAgdGhpcy5fcmV2ZXJ0SW5wdXRWYWx1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBpbnB1dCB2YWx1ZSBzYXRpc2ZpZXMgYWxsIGNvbnN0cmFpbnRzIChpZiBhbnkpLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2tWYWxpZGl0eSgpIHtcbiAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQudmFsaWRhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudC52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2hlY2tWYWxpZGl0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0IF9wcm9wZXJ0eUZvclZhbHVlKCkge1xuICAgIHJldHVybiBkYXNoVG9DYW1lbENhc2UodGhpcy5hdHRyRm9yVmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4ge0hUTUxJbnB1dEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgX25hdGl2ZUlucHV0KCkge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dEVsZW1lbnQ7XG5cbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIC8vIFN1cHBvcnQgYDxpbnB1dCBjbGFzcz1cImlucHV0XCI+YFxuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFN1cHBvcnQgYDxpbnB1dD5gIGluIGxpZ2h0IERPTSAoZS5nLiBgdmFhZGluLXRleHQtZmllbGRgKVxuICAgICAgY29uc3Qgc2xvdHRlZElucHV0ID0gaW5wdXQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgIGlmIChzbG90dGVkSW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHNsb3R0ZWRJbnB1dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBgPGlucHV0PmAgaW4gU2hhZG93IERPTSAoZS5nLiBgbXdjLXRleHRmaWVsZGApXG4gICAgICAgIGNvbnN0IHNoYWRvd0lucHV0ID0gaW5wdXQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICBpZiAoc2hhZG93SW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gc2hhZG93SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2lzQ2xlYXJCdXR0b24oZXZlbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3VwZXIuX2lzQ2xlYXJCdXR0b24oZXZlbnQpIHx8XG4gICAgICAoZXZlbnQudHlwZSA9PT0gJ2lucHV0JyAmJiAhZXZlbnQuaXNUcnVzdGVkKSB8fCAvLyBGYWtlIGlucHV0IGV2ZW50IGRpc3BhdGNoZWQgYnkgY2xlYXIgYnV0dG9uXG4gICAgICBldmVudC5jb21wb3NlZFBhdGgoKVswXS5nZXRBdHRyaWJ1dGUoJ3BhcnQnKSA9PT0gJ2NsZWFyLWJ1dHRvbidcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25DaGFuZ2UoZXZlbnQpIHtcbiAgICBzdXBlci5fb25DaGFuZ2UoZXZlbnQpO1xuXG4gICAgaWYgKHRoaXMuX2lzQ2xlYXJCdXR0b24oZXZlbnQpKSB7XG4gICAgICB0aGlzLl9jbGVhcigpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoQ29tYm9Cb3hMaWdodC5pcywgQ29tYm9Cb3hMaWdodCk7XG5cbmV4cG9ydCB7IENvbWJvQm94TGlnaHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxMixin\": () => (/* binding */ ComboBoxMixin)\n/* harmony export */ });\n/* harmony import */ var _vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/component-base/src/browser-utils.js */ \"./node_modules/@vaadin/component-base/src/browser-utils.js\");\n/* harmony import */ var _vaadin_component_base_src_controller_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/component-base/src/controller-mixin.js */ \"./node_modules/@vaadin/component-base/src/controller-mixin.js\");\n/* harmony import */ var _vaadin_component_base_src_disabled_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/component-base/src/disabled-mixin.js */ \"./node_modules/@vaadin/component-base/src/disabled-mixin.js\");\n/* harmony import */ var _vaadin_component_base_src_focus_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/component-base/src/focus-utils.js */ \"./node_modules/@vaadin/component-base/src/focus-utils.js\");\n/* harmony import */ var _vaadin_component_base_src_keyboard_mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/component-base/src/keyboard-mixin.js */ \"./node_modules/@vaadin/component-base/src/keyboard-mixin.js\");\n/* harmony import */ var _vaadin_component_base_src_templates_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @vaadin/component-base/src/templates.js */ \"./node_modules/@vaadin/component-base/src/templates.js\");\n/* harmony import */ var _vaadin_field_base_src_input_mixin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @vaadin/field-base/src/input-mixin.js */ \"./node_modules/@vaadin/field-base/src/input-mixin.js\");\n/* harmony import */ var _vaadin_field_base_src_virtual_keyboard_controller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @vaadin/field-base/src/virtual-keyboard-controller.js */ \"./node_modules/@vaadin/field-base/src/virtual-keyboard-controller.js\");\n/* harmony import */ var _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vaadin-combo-box-placeholder.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * Checks if the value is supported as an item value in this control.\n *\n * @param {unknown} value\n * @return {boolean}\n */\nfunction isValidValue(value) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * Returns the index of the first item that satisfies the provided testing function\n * ignoring placeholder items.\n *\n * @param {Array<ComboBoxItem | string>} items\n * @param {Function} callback\n * @return {number}\n */\nfunction findItemIndex(items, callback) {\n  return items.findIndex(item => {\n    if (item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_8__.ComboBoxPlaceholder) {\n      return false;\n    }\n    return callback(item);\n  });\n}\n\n/**\n * @polymerMixin\n * @param {function(new:HTMLElement)} subclass\n */\nconst ComboBoxMixin = subclass => class VaadinComboBoxMixinElement extends (0,_vaadin_component_base_src_controller_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ControllerMixin)((0,_vaadin_component_base_src_keyboard_mixin_js__WEBPACK_IMPORTED_MODULE_4__.KeyboardMixin)((0,_vaadin_field_base_src_input_mixin_js__WEBPACK_IMPORTED_MODULE_6__.InputMixin)((0,_vaadin_component_base_src_disabled_mixin_js__WEBPACK_IMPORTED_MODULE_2__.DisabledMixin)(subclass)))) {\n  static get properties() {\n    return {\n      /**\n       * True if the dropdown is open, false otherwise.\n       * @type {boolean}\n       */\n      opened: {\n        type: Boolean,\n        notify: true,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_openedChanged'\n      },\n      /**\n       * Set true to prevent the overlay from opening automatically.\n       * @attr {boolean} auto-open-disabled\n       */\n      autoOpenDisabled: {\n        type: Boolean\n      },\n      /**\n       * When present, it specifies that the field is read-only.\n       * @type {boolean}\n       */\n      readonly: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * Custom function for rendering the content of every item.\n       * Receives three arguments:\n       *\n       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.\n       * - `comboBox` The reference to the `<vaadin-combo-box>` element.\n       * - `model` The object with the properties related with the rendered\n       *   item, contains:\n       *   - `model.index` The index of the rendered item.\n       *   - `model.item` The item.\n       * @type {ComboBoxRenderer | undefined}\n       */\n      renderer: Function,\n      /**\n       * A full set of items to filter the visible options from.\n       * The items can be of either `String` or `Object` type.\n       * @type {!Array<!ComboBoxItem | string> | undefined}\n       */\n      items: {\n        type: Array,\n        observer: '_itemsChanged'\n      },\n      /**\n       * If `true`, the user can input a value that is not present in the items list.\n       * `value` property will be set to the input value in this case.\n       * Also, when `value` is set programmatically, the input value will be set\n       * to reflect that value.\n       * @attr {boolean} allow-custom-value\n       * @type {boolean}\n       */\n      allowCustomValue: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * A subset of items, filtered based on the user input. Filtered items\n       * can be assigned directly to omit the internal filtering functionality.\n       * The items can be of either `String` or `Object` type.\n       * @type {!Array<!ComboBoxItem | string> | undefined}\n       */\n      filteredItems: {\n        type: Array,\n        observer: '_filteredItemsChanged'\n      },\n      /**\n       * Used to detect user value changes and fire `change` events.\n       * @private\n       */\n      _lastCommittedValue: String,\n      /**\n       * When set to `true`, \"loading\" attribute is added to host and the overlay element.\n       * @type {boolean}\n       */\n      loading: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * @type {number}\n       * @protected\n       */\n      _focusedIndex: {\n        type: Number,\n        observer: '_focusedIndexChanged',\n        value: -1\n      },\n      /**\n       * Filtering string the user has typed into the input field.\n       * @type {string}\n       */\n      filter: {\n        type: String,\n        value: '',\n        notify: true\n      },\n      /**\n       * The selected item from the `items` array.\n       * @type {ComboBoxItem | string | undefined}\n       */\n      selectedItem: {\n        type: Object,\n        notify: true\n      },\n      /**\n       * Path for label of the item. If `items` is an array of objects, the\n       * `itemLabelPath` is used to fetch the displayed string label for each\n       * item.\n       *\n       * The item label is also used for matching items when processing user\n       * input, i.e., for filtering and selecting items.\n       * @attr {string} item-label-path\n       * @type {string}\n       */\n      itemLabelPath: {\n        type: String,\n        value: 'label',\n        observer: '_itemLabelPathChanged'\n      },\n      /**\n       * Path for the value of the item. If `items` is an array of objects, the\n       * `itemValuePath:` is used to fetch the string value for the selected\n       * item.\n       *\n       * The item value is used in the `value` property of the combo box,\n       * to provide the form value.\n       * @attr {string} item-value-path\n       * @type {string}\n       */\n      itemValuePath: {\n        type: String,\n        value: 'value'\n      },\n      /**\n       * Path for the id of the item. If `items` is an array of objects,\n       * the `itemIdPath` is used to compare and identify the same item\n       * in `selectedItem` and `filteredItems` (items given by the\n       * `dataProvider` callback).\n       * @attr {string} item-id-path\n       */\n      itemIdPath: String,\n      /**\n       * @type {!HTMLElement | undefined}\n       * @protected\n       */\n      _toggleElement: {\n        type: Object,\n        observer: '_toggleElementChanged'\n      },\n      /** @private */\n      _closeOnBlurIsPrevented: Boolean,\n      /** @private */\n      _scroller: Object,\n      /** @private */\n      _overlayOpened: {\n        type: Boolean,\n        observer: '_overlayOpenedChanged'\n      }\n    };\n  }\n  static get observers() {\n    return ['_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)', '_openedOrItemsChanged(opened, filteredItems, loading)', '_updateScroller(_scroller, filteredItems, opened, loading, selectedItem, itemIdPath, _focusedIndex, renderer, theme)'];\n  }\n  constructor() {\n    super();\n    this._boundOnFocusout = this._onFocusout.bind(this);\n    this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this);\n    this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this);\n    this._boundOnClick = this._onClick.bind(this);\n    this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this);\n    this._boundOnTouchend = this._onTouchend.bind(this);\n  }\n\n  /**\n   * Tag name prefix used by scroller and items.\n   * @protected\n   * @return {string}\n   */\n  get _tagNamePrefix() {\n    return 'vaadin-combo-box';\n  }\n\n  /**\n   * @return {string | undefined}\n   * @protected\n   */\n  get _inputElementValue() {\n    return this.inputElement ? this.inputElement[this._propertyForValue] : undefined;\n  }\n\n  /**\n   * @param {string} value\n   * @protected\n   */\n  set _inputElementValue(value) {\n    if (this.inputElement) {\n      this.inputElement[this._propertyForValue] = value;\n    }\n  }\n\n  /**\n   * Get a reference to the native `<input>` element.\n   * Override to provide a custom input.\n   * @protected\n   * @return {HTMLInputElement | undefined}\n   */\n  get _nativeInput() {\n    return this.inputElement;\n  }\n\n  /**\n   * Override method inherited from `InputMixin`\n   * to customize the input element.\n   * @protected\n   * @override\n   */\n  _inputElementChanged(inputElement) {\n    super._inputElementChanged(inputElement);\n    const input = this._nativeInput;\n    if (input) {\n      input.autocomplete = 'off';\n      input.autocapitalize = 'off';\n      input.setAttribute('role', 'combobox');\n      input.setAttribute('aria-autocomplete', 'list');\n      input.setAttribute('aria-expanded', !!this.opened);\n\n      // Disable the macOS Safari spell check auto corrections.\n      input.setAttribute('spellcheck', 'false');\n\n      // Disable iOS autocorrect suggestions.\n      input.setAttribute('autocorrect', 'off');\n      this._revertInputValueToValue();\n      if (this.clearElement) {\n        this.clearElement.addEventListener('mousedown', this._boundOnClearButtonMouseDown);\n      }\n    }\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this._initOverlay();\n    this._initScroller();\n    this.addEventListener('focusout', this._boundOnFocusout);\n    this._lastCommittedValue = this.value;\n    this.addEventListener('click', this._boundOnClick);\n    this.addEventListener('touchend', this._boundOnTouchend);\n    const bringToFrontListener = () => {\n      requestAnimationFrame(() => {\n        this.$.overlay.bringToFront();\n      });\n    };\n    this.addEventListener('mousedown', bringToFrontListener);\n    this.addEventListener('touchstart', bringToFrontListener);\n    (0,_vaadin_component_base_src_templates_js__WEBPACK_IMPORTED_MODULE_5__.processTemplates)(this);\n    this.addController(new _vaadin_field_base_src_virtual_keyboard_controller_js__WEBPACK_IMPORTED_MODULE_7__.VirtualKeyboardController(this));\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    // Close the overlay on detach\n    this.close();\n  }\n\n  /**\n   * Requests an update for the content of items.\n   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (!this._scroller) {\n      return;\n    }\n    this._scroller.requestContentUpdate();\n    this._getItemElements().forEach(item => {\n      item.requestContentUpdate();\n    });\n  }\n\n  /**\n   * Opens the dropdown list.\n   */\n  open() {\n    // Prevent _open() being called when input is disabled or read-only\n    if (!this.disabled && !this.readonly) {\n      this.opened = true;\n    }\n  }\n\n  /**\n   * Closes the dropdown list.\n   */\n  close() {\n    this.opened = false;\n  }\n\n  /**\n   * Override Polymer lifecycle callback to handle `filter` property change after\n   * the observer for `opened` property is triggered. This is needed when opening\n   * combo-box on user input to ensure the focused index is set correctly.\n   *\n   * @param {!Object} currentProps Current accessor values\n   * @param {?Object} changedProps Properties changed since the last call\n   * @param {?Object} oldProps Previous values for each changed property\n   * @protected\n   * @override\n   */\n  _propertiesChanged(currentProps, changedProps, oldProps) {\n    super._propertiesChanged(currentProps, changedProps, oldProps);\n    if (changedProps.filter !== undefined) {\n      this._filterChanged(changedProps.filter);\n    }\n  }\n\n  /** @private */\n  _initOverlay() {\n    const overlay = this.$.overlay;\n\n    // Store instance for detecting \"dir\" attribute on opening\n    overlay._comboBox = this;\n    overlay.addEventListener('touchend', this._boundOnOverlayTouchAction);\n    overlay.addEventListener('touchmove', this._boundOnOverlayTouchAction);\n\n    // Prevent blurring the input when clicking inside the overlay\n    overlay.addEventListener('mousedown', e => e.preventDefault());\n\n    // Manual two-way binding for the overlay \"opened\" property\n    overlay.addEventListener('opened-changed', e => {\n      this._overlayOpened = e.detail.value;\n    });\n  }\n\n  /**\n   * Create and initialize the scroller element.\n   * Override to provide custom host reference.\n   *\n   * @protected\n   */\n  _initScroller(host) {\n    const scrollerTag = `${this._tagNamePrefix}-scroller`;\n    const overlay = this.$.overlay;\n    overlay.renderer = root => {\n      if (!root.firstChild) {\n        root.appendChild(document.createElement(scrollerTag));\n      }\n    };\n\n    // Ensure the scroller is rendered\n    overlay.requestContentUpdate();\n    const scroller = overlay.querySelector(scrollerTag);\n    scroller.comboBox = host || this;\n    scroller.getItemLabel = this._getItemLabel.bind(this);\n    scroller.addEventListener('selection-changed', this._boundOverlaySelectedItemChanged);\n\n    // Trigger the observer to set properties\n    this._scroller = scroller;\n  }\n\n  /** @private */\n  // eslint-disable-next-line max-params\n  _updateScroller(scroller, items, opened, loading, selectedItem, itemIdPath, focusedIndex, renderer, theme) {\n    if (scroller) {\n      if (opened) {\n        scroller.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || '65vh';\n      }\n      scroller.setProperties({\n        items: opened ? items : [],\n        opened,\n        loading,\n        selectedItem,\n        itemIdPath,\n        focusedIndex,\n        renderer,\n        theme\n      });\n    }\n  }\n\n  /** @private */\n  _openedOrItemsChanged(opened, items, loading) {\n    // Close the overlay if there are no items to display.\n    // See https://github.com/vaadin/vaadin-combo-box/pull/964\n    this._overlayOpened = !!(opened && (loading || items && items.length));\n  }\n\n  /** @private */\n  _overlayOpenedChanged(opened, wasOpened) {\n    if (opened) {\n      this.dispatchEvent(new CustomEvent('vaadin-combo-box-dropdown-opened', {\n        bubbles: true,\n        composed: true\n      }));\n      this._onOpened();\n    } else if (wasOpened && this.filteredItems && this.filteredItems.length) {\n      this.close();\n      this.dispatchEvent(new CustomEvent('vaadin-combo-box-dropdown-closed', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n\n  /** @private */\n  _focusedIndexChanged(index, oldIndex) {\n    if (oldIndex === undefined) {\n      return;\n    }\n    this._updateActiveDescendant(index);\n  }\n\n  /** @protected */\n  _isInputFocused() {\n    return this.inputElement && (0,_vaadin_component_base_src_focus_utils_js__WEBPACK_IMPORTED_MODULE_3__.isElementFocused)(this.inputElement);\n  }\n\n  /** @private */\n  _updateActiveDescendant(index) {\n    const input = this._nativeInput;\n    if (!input) {\n      return;\n    }\n    const item = this._getItemElements().find(el => el.index === index);\n    if (item) {\n      input.setAttribute('aria-activedescendant', item.id);\n    } else {\n      input.removeAttribute('aria-activedescendant');\n    }\n  }\n\n  /** @private */\n  _openedChanged(opened, wasOpened) {\n    // Prevent _close() being called when opened is set to its default value (false).\n    if (wasOpened === undefined) {\n      return;\n    }\n    if (opened) {\n      this._openedWithFocusRing = this.hasAttribute('focus-ring');\n      // For touch devices, we don't want to popup virtual keyboard\n      // unless input element is explicitly focused by the user.\n      if (!this._isInputFocused() && !_vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_0__.isTouch) {\n        this.focus();\n      }\n      this.$.overlay.restoreFocusOnClose = true;\n    } else {\n      this._onClosed();\n      if (this._openedWithFocusRing && this._isInputFocused()) {\n        this.setAttribute('focus-ring', '');\n      }\n    }\n    const input = this._nativeInput;\n    if (input) {\n      input.setAttribute('aria-expanded', !!opened);\n      if (opened) {\n        input.setAttribute('aria-controls', this._scroller.id);\n      } else {\n        input.removeAttribute('aria-controls');\n      }\n    }\n  }\n\n  /** @private */\n  _onOverlayTouchAction() {\n    // On touch devices, blur the input on touch start inside the overlay, in order to hide\n    // the virtual keyboard. But don't close the overlay on this blur.\n    this._closeOnBlurIsPrevented = true;\n    this.inputElement.blur();\n    this._closeOnBlurIsPrevented = false;\n  }\n\n  /** @protected */\n  _isClearButton(event) {\n    return event.composedPath()[0] === this.clearElement;\n  }\n\n  /**\n   * @param {Event} event\n   * @protected\n   */\n  _handleClearButtonClick(event) {\n    event.preventDefault();\n    this._clear();\n\n    // De-select dropdown item\n    if (this.opened) {\n      this.requestContentUpdate();\n    }\n  }\n\n  /**\n   * @param {Event} event\n   * @private\n   */\n  _onToggleButtonClick(event) {\n    // Prevent parent components such as `vaadin-grid`\n    // from handling the click event after it bubbles.\n    event.preventDefault();\n    if (this.opened) {\n      this.close();\n    } else {\n      this.open();\n    }\n  }\n\n  /**\n   * @param {Event} event\n   * @protected\n   */\n  _onHostClick(event) {\n    if (!this.autoOpenDisabled) {\n      event.preventDefault();\n      this.open();\n    }\n  }\n\n  /** @private */\n  _onClick(e) {\n    const path = e.composedPath();\n    if (this._isClearButton(e)) {\n      this._handleClearButtonClick(e);\n    } else if (path.indexOf(this._toggleElement) > -1) {\n      this._onToggleButtonClick(e);\n    } else {\n      this._onHostClick(e);\n    }\n  }\n\n  /**\n   * Override an event listener from `KeyboardMixin`.\n   *\n   * @param {KeyboardEvent} e\n   * @protected\n   * @override\n   */\n  _onKeyDown(e) {\n    super._onKeyDown(e);\n    if (e.key === 'Tab') {\n      this.$.overlay.restoreFocusOnClose = false;\n    } else if (e.key === 'ArrowDown') {\n      this._onArrowDown();\n\n      // Prevent caret from moving\n      e.preventDefault();\n    } else if (e.key === 'ArrowUp') {\n      this._onArrowUp();\n\n      // Prevent caret from moving\n      e.preventDefault();\n    }\n  }\n\n  /** @private */\n  _getItemLabel(item) {\n    let label = item && this.itemLabelPath ? this.get(this.itemLabelPath, item) : undefined;\n    if (label === undefined || label === null) {\n      label = item ? item.toString() : '';\n    }\n    return label;\n  }\n\n  /** @private */\n  _getItemValue(item) {\n    let value = item && this.itemValuePath ? this.get(this.itemValuePath, item) : undefined;\n    if (value === undefined) {\n      value = item ? item.toString() : '';\n    }\n    return value;\n  }\n\n  /** @private */\n  _onArrowDown() {\n    if (this.opened) {\n      const items = this.filteredItems;\n      if (items) {\n        this._focusedIndex = Math.min(items.length - 1, this._focusedIndex + 1);\n        this._prefillFocusedItemLabel();\n      }\n    } else {\n      this.open();\n    }\n  }\n\n  /** @private */\n  _onArrowUp() {\n    if (this.opened) {\n      if (this._focusedIndex > -1) {\n        this._focusedIndex = Math.max(0, this._focusedIndex - 1);\n      } else {\n        const items = this.filteredItems;\n        if (items) {\n          this._focusedIndex = items.length - 1;\n        }\n      }\n      this._prefillFocusedItemLabel();\n    } else {\n      this.open();\n    }\n  }\n\n  /** @private */\n  _prefillFocusedItemLabel() {\n    if (this._focusedIndex > -1) {\n      const focusedItem = this.filteredItems[this._focusedIndex];\n      this._inputElementValue = this._getItemLabel(focusedItem);\n      this._markAllSelectionRange();\n    }\n  }\n\n  /** @private */\n  _setSelectionRange(start, end) {\n    // Setting selection range focuses and/or moves the caret in some browsers,\n    // and there's no need to modify the selection range if the input isn't focused anyway.\n    // This affects Safari. When the overlay is open, and then hitting tab, browser should focus\n    // the next focusable element instead of the combo-box itself.\n    if (this._isInputFocused() && this.inputElement.setSelectionRange) {\n      this.inputElement.setSelectionRange(start, end);\n    }\n  }\n\n  /** @private */\n  _markAllSelectionRange() {\n    if (this._inputElementValue !== undefined) {\n      this._setSelectionRange(0, this._inputElementValue.length);\n    }\n  }\n\n  /** @private */\n  _clearSelectionRange() {\n    if (this._inputElementValue !== undefined) {\n      const pos = this._inputElementValue ? this._inputElementValue.length : 0;\n      this._setSelectionRange(pos, pos);\n    }\n  }\n\n  /** @private */\n  _closeOrCommit() {\n    if (!this.opened && !this.loading) {\n      this._commitValue();\n    } else {\n      this.close();\n    }\n  }\n\n  /**\n   * Override an event listener from `KeyboardMixin`.\n   *\n   * @param {KeyboardEvent} e\n   * @protected\n   * @override\n   */\n  _onEnter(e) {\n    // Do not commit value when custom values are disallowed and input value is not a valid option\n    // also stop propagation of the event, otherwise the user could submit a form while the input\n    // still contains an invalid value\n    const hasInvalidOption = this._focusedIndex < 0 && this._inputElementValue !== '' && this._getItemLabel(this.selectedItem) !== this._inputElementValue;\n    if (!this.allowCustomValue && hasInvalidOption) {\n      // Do not submit the surrounding form.\n      e.preventDefault();\n      // Do not trigger global listeners\n      e.stopPropagation();\n      return;\n    }\n\n    // Stop propagation of the enter event only if the dropdown is opened, this\n    // \"consumes\" the enter event for the action of closing the dropdown\n    if (this.opened) {\n      // Do not submit the surrounding form.\n      e.preventDefault();\n      // Do not trigger global listeners\n      e.stopPropagation();\n    }\n    this._closeOrCommit();\n  }\n\n  /**\n   * Override an event listener from `KeyboardMixin`.\n   * Do not call `super` in order to override clear\n   * button logic defined in `InputControlMixin`.\n   *\n   * @param {!KeyboardEvent} e\n   * @protected\n   * @override\n   */\n  _onEscape(e) {\n    if (this.autoOpenDisabled) {\n      // Auto-open is disabled\n      if (this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0) {\n        // The overlay is open or\n        // The input value has changed but the change hasn't been committed, so cancel it.\n        e.stopPropagation();\n        this._focusedIndex = -1;\n        this.cancel();\n      } else if (this.clearButtonVisible && !this.opened && !!this.value) {\n        e.stopPropagation();\n        // The clear button is visible and the overlay is closed, so clear the value.\n        this._clear();\n      }\n    } else if (this.opened) {\n      // Auto-open is enabled\n      // The overlay is open\n      e.stopPropagation();\n      if (this._focusedIndex > -1) {\n        // An item is focused, revert the input to the filtered value\n        this._focusedIndex = -1;\n        this._revertInputValue();\n      } else {\n        // No item is focused, cancel the change and close the overlay\n        this.cancel();\n      }\n    } else if (this.clearButtonVisible && !!this.value) {\n      e.stopPropagation();\n      // The clear button is visible and the overlay is closed, so clear the value.\n      this._clear();\n    }\n  }\n\n  /** @private */\n  _toggleElementChanged(toggleElement) {\n    if (toggleElement) {\n      // Don't blur the input on toggle mousedown\n      toggleElement.addEventListener('mousedown', e => e.preventDefault());\n      // Unfocus previously focused element if focus is not inside combo box (on touch devices)\n      toggleElement.addEventListener('click', () => {\n        if (_vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_0__.isTouch && !this._isInputFocused()) {\n          document.activeElement.blur();\n        }\n      });\n    }\n  }\n\n  /**\n   * Clears the current value.\n   * @protected\n   */\n  _clear() {\n    this.selectedItem = null;\n    if (this.allowCustomValue) {\n      this.value = '';\n    }\n    this._detectAndDispatchChange();\n  }\n\n  /**\n   * Reverts back to original value.\n   */\n  cancel() {\n    this._revertInputValueToValue();\n    // In the next _detectAndDispatchChange() call, the change detection should not pass\n    this._lastCommittedValue = this.value;\n    this._closeOrCommit();\n  }\n\n  /** @private */\n  _onOpened() {\n    // Defer scroll position adjustment to improve performance.\n    requestAnimationFrame(() => {\n      this._scrollIntoView(this._focusedIndex);\n\n      // Set attribute after the items are rendered when overlay is opened for the first time.\n      this._updateActiveDescendant(this._focusedIndex);\n    });\n\n    // _detectAndDispatchChange() should not consider value changes done before opening\n    this._lastCommittedValue = this.value;\n  }\n\n  /** @private */\n  _onClosed() {\n    if (!this.loading || this.allowCustomValue) {\n      this._commitValue();\n    }\n  }\n\n  /** @private */\n  _commitValue() {\n    if (this._focusedIndex > -1) {\n      const focusedItem = this.filteredItems[this._focusedIndex];\n      if (this.selectedItem !== focusedItem) {\n        this.selectedItem = focusedItem;\n      }\n      // Make sure input field is updated in case value doesn't change (i.e. FOO -> foo)\n      this._inputElementValue = this._getItemLabel(this.selectedItem);\n    } else if (this._inputElementValue === '' || this._inputElementValue === undefined) {\n      this.selectedItem = null;\n      if (this.allowCustomValue) {\n        this.value = '';\n      }\n    } else {\n      // Try to find an item which label matches the input value.\n      const items = [...(this.filteredItems || []), this.selectedItem];\n      const itemMatchingInputValue = items[this.__getItemIndexByLabel(items, this._inputElementValue)];\n      if (this.allowCustomValue &&\n      // To prevent a repetitive input value being saved after pressing ESC and Tab.\n      !itemMatchingInputValue) {\n        const customValue = this._inputElementValue;\n\n        // Store reference to the last custom value for checking it on focusout.\n        this._lastCustomValue = customValue;\n\n        // An item matching by label was not found, but custom values are allowed.\n        // Dispatch a custom-value-set event with the input value.\n        const e = new CustomEvent('custom-value-set', {\n          detail: customValue,\n          composed: true,\n          cancelable: true,\n          bubbles: true\n        });\n        this.dispatchEvent(e);\n        if (!e.defaultPrevented) {\n          this.value = customValue;\n        }\n      } else if (!this.allowCustomValue && !this.opened && itemMatchingInputValue) {\n        // An item matching by label was found, select it.\n        this.value = this._getItemValue(itemMatchingInputValue);\n      } else {\n        // Revert the input value\n        this._inputElementValue = this.selectedItem ? this._getItemLabel(this.selectedItem) : this.value || '';\n      }\n    }\n    this._detectAndDispatchChange();\n    this._clearSelectionRange();\n    this.filter = '';\n  }\n\n  /**\n   * @return {string}\n   * @protected\n   */\n  get _propertyForValue() {\n    return 'value';\n  }\n\n  /**\n   * Override an event listener from `InputMixin`.\n   * @param {!Event} event\n   * @protected\n   * @override\n   */\n  _onInput(event) {\n    const filter = this._inputElementValue;\n\n    // When opening dropdown on user input, both `opened` and `filter` properties are set.\n    // Perform a batched property update instead of relying on sync property observers.\n    // This is necessary to avoid an extra data-provider request for loading first page.\n    const props = {};\n    if (this.filter === filter) {\n      // Filter and input value might get out of sync, while keyboard navigating for example.\n      // Afterwards, input value might be changed to the same value as used in filtering.\n      // In situation like these, we need to make sure all the filter changes handlers are run.\n      this._filterChanged(this.filter);\n    } else {\n      props.filter = filter;\n    }\n    if (!this.opened && !this._isClearButton(event) && !this.autoOpenDisabled) {\n      props.opened = true;\n    }\n    this.setProperties(props);\n  }\n\n  /**\n   * Override an event listener from `InputMixin`.\n   * @param {!Event} event\n   * @protected\n   * @override\n   */\n  _onChange(event) {\n    // Suppress the native change event fired on the native input.\n    // We use `_detectAndDispatchChange` to fire a custom event.\n    event.stopPropagation();\n  }\n\n  /** @private */\n  _itemLabelPathChanged(itemLabelPath) {\n    if (typeof itemLabelPath !== 'string') {\n      console.error('You should set itemLabelPath to a valid string');\n    }\n  }\n\n  /** @private */\n  _filterChanged(filter) {\n    // Scroll to the top of the list whenever the filter changes.\n    this._scrollIntoView(0);\n    this._focusedIndex = -1;\n    if (this.items) {\n      this.filteredItems = this._filterItems(this.items, filter);\n    } else {\n      // With certain use cases (e. g., external filtering), `items` are\n      // undefined. Filtering is unnecessary per se, but the filteredItems\n      // observer should still be invoked to update focused item.\n      this._filteredItemsChanged(this.filteredItems);\n    }\n  }\n\n  /** @protected */\n  _revertInputValue() {\n    if (this.filter !== '') {\n      this._inputElementValue = this.filter;\n    } else {\n      this._revertInputValueToValue();\n    }\n    this._clearSelectionRange();\n  }\n\n  /** @private */\n  _revertInputValueToValue() {\n    if (this.allowCustomValue && !this.selectedItem) {\n      this._inputElementValue = this.value;\n    } else {\n      this._inputElementValue = this._getItemLabel(this.selectedItem);\n    }\n  }\n\n  /** @private */\n  _selectedItemChanged(selectedItem) {\n    if (selectedItem === null || selectedItem === undefined) {\n      if (this.filteredItems) {\n        if (!this.allowCustomValue) {\n          this.value = '';\n        }\n        this._toggleHasValue(this._hasValue);\n        this._inputElementValue = this.value;\n      }\n    } else {\n      const value = this._getItemValue(selectedItem);\n      if (this.value !== value) {\n        this.value = value;\n        if (this.value !== value) {\n          // The value was changed to something else in value-changed listener,\n          // so prevent from resetting it to the previous value.\n          return;\n        }\n      }\n      this._toggleHasValue(true);\n      this._inputElementValue = this._getItemLabel(selectedItem);\n    }\n    if (this.filteredItems) {\n      this._focusedIndex = this.filteredItems.indexOf(selectedItem);\n    }\n  }\n\n  /**\n   * Override an observer from `InputMixin`.\n   * @protected\n   * @override\n   */\n  _valueChanged(value, oldVal) {\n    if (value === '' && oldVal === undefined) {\n      // Initializing, no need to do anything\n      // See https://github.com/vaadin/vaadin-combo-box/issues/554\n      return;\n    }\n    if (isValidValue(value)) {\n      if (this._getItemValue(this.selectedItem) !== value) {\n        this._selectItemForValue(value);\n      }\n      if (!this.selectedItem && this.allowCustomValue) {\n        this._inputElementValue = value;\n      }\n      this._toggleHasValue(this._hasValue);\n    } else {\n      this.selectedItem = null;\n    }\n    this.filter = '';\n\n    // In the next _detectAndDispatchChange() call, the change detection should pass\n    this._lastCommittedValue = undefined;\n  }\n\n  /** @private */\n  _detectAndDispatchChange() {\n    if (this.value !== this._lastCommittedValue) {\n      this.dispatchEvent(new CustomEvent('change', {\n        bubbles: true\n      }));\n      this._lastCommittedValue = this.value;\n    }\n  }\n\n  /** @private */\n  _itemsChanged(items, oldItems) {\n    this._ensureItemsOrDataProvider(() => {\n      this.items = oldItems;\n    });\n    if (items) {\n      this.filteredItems = items.slice(0);\n    } else if (oldItems) {\n      // Only clear filteredItems if the component had items previously but got cleared\n      this.filteredItems = null;\n    }\n  }\n\n  /** @private */\n  _filteredItemsChanged(filteredItems, oldFilteredItems) {\n    // Store the currently focused item if any. The focused index preserves\n    // in the case when more filtered items are loading but it is reset\n    // when the user types in a filter query.\n    const focusedItem = oldFilteredItems ? oldFilteredItems[this._focusedIndex] : null;\n\n    // Try to sync `selectedItem` based on `value` once a new set of `filteredItems` is available\n    // (as a result of external filtering or when they have been loaded by the data provider).\n    // When `value` is specified but `selectedItem` is not, it means that there was no item\n    // matching `value` at the moment `value` was set, so `selectedItem` has remained unsynced.\n    const valueIndex = this.__getItemIndexByValue(filteredItems, this.value);\n    if ((this.selectedItem === null || this.selectedItem === undefined) && valueIndex >= 0) {\n      this.selectedItem = filteredItems[valueIndex];\n    }\n\n    // Try to first set focus on the item that had been focused before `filteredItems` were updated\n    // if it is still present in the `filteredItems` array. Otherwise, set the focused index\n    // depending on the selected item or the filter query.\n    const focusedItemIndex = this.__getItemIndexByValue(filteredItems, this._getItemValue(focusedItem));\n    if (focusedItemIndex > -1) {\n      this._focusedIndex = focusedItemIndex;\n    } else {\n      this.__setInitialFocusedIndex();\n    }\n  }\n\n  /** @private */\n  __setInitialFocusedIndex() {\n    const inputValue = this._inputElementValue;\n    if (inputValue === undefined || inputValue === this._getItemLabel(this.selectedItem)) {\n      // When the input element value is the same as the current value or not defined,\n      // set the focused index to the item that matches the value.\n      this._focusedIndex = this.__getItemIndexByLabel(this.filteredItems, this._getItemLabel(this.selectedItem));\n    } else {\n      // When the user filled in something that is different from the current value = filtering is enabled,\n      // set the focused index to the item that matches the filter query.\n      this._focusedIndex = this.__getItemIndexByLabel(this.filteredItems, this.filter);\n    }\n  }\n\n  /** @private */\n  _filterItems(arr, filter) {\n    if (!arr) {\n      return arr;\n    }\n    const filteredItems = arr.filter(item => {\n      filter = filter ? filter.toString().toLowerCase() : '';\n      // Check if item contains input value.\n      return this._getItemLabel(item).toString().toLowerCase().indexOf(filter) > -1;\n    });\n    return filteredItems;\n  }\n\n  /** @private */\n  _selectItemForValue(value) {\n    const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);\n    const previouslySelectedItem = this.selectedItem;\n    if (valueIndex >= 0) {\n      this.selectedItem = this.filteredItems[valueIndex];\n    } else if (this.dataProvider && this.selectedItem === undefined) {\n      this.selectedItem = undefined;\n    } else {\n      this.selectedItem = null;\n    }\n    if (this.selectedItem === null && previouslySelectedItem === null) {\n      this._selectedItemChanged(this.selectedItem);\n    }\n  }\n\n  /** @private */\n  _getItemElements() {\n    return Array.from(this._scroller.querySelectorAll(`${this._tagNamePrefix}-item`));\n  }\n\n  /** @private */\n  _scrollIntoView(index) {\n    if (!this._scroller) {\n      return;\n    }\n    this._scroller.scrollIntoView(index);\n  }\n\n  /**\n   * Returns the first item that matches the provided value.\n   *\n   * @private\n   */\n  __getItemIndexByValue(items, value) {\n    if (!items || !isValidValue(value)) {\n      return -1;\n    }\n    return findItemIndex(items, item => {\n      return this._getItemValue(item) === value;\n    });\n  }\n\n  /**\n   * Returns the first item that matches the provided label.\n   * Labels are matched against each other case insensitively.\n   *\n   * @private\n   */\n  __getItemIndexByLabel(items, label) {\n    if (!items || !label) {\n      return -1;\n    }\n    return findItemIndex(items, item => {\n      return this._getItemLabel(item).toString().toLowerCase() === label.toString().toLowerCase();\n    });\n  }\n\n  /** @private */\n  _overlaySelectedItemChanged(e) {\n    // Stop this private event from leaking outside.\n    e.stopPropagation();\n    if (e.detail.item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_8__.ComboBoxPlaceholder) {\n      // Placeholder items should not be selectable.\n      return;\n    }\n    if (this.opened) {\n      this._focusedIndex = this.filteredItems.indexOf(e.detail.item);\n      this.close();\n    }\n  }\n\n  /** @private */\n  __onClearButtonMouseDown(event) {\n    event.preventDefault(); // Prevent native focusout event\n    this.inputElement.focus();\n  }\n\n  /** @private */\n  _onFocusout(event) {\n    // VoiceOver on iOS fires `focusout` event when moving focus to the item in the dropdown.\n    // Do not focus the input in this case, because it would break announcement for the item.\n    if (event.relatedTarget && event.relatedTarget.localName === `${this._tagNamePrefix}-item`) {\n      return;\n    }\n\n    // Fixes the problem with `focusout` happening when clicking on the scroll bar on Edge\n    if (event.relatedTarget === this.$.overlay) {\n      event.composedPath()[0].focus();\n      return;\n    }\n    if (!this.readonly && !this._closeOnBlurIsPrevented) {\n      // User's logic in `custom-value-set` event listener might cause input to blur,\n      // which will result in attempting to commit the same custom value once again.\n      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {\n        delete this._lastCustomValue;\n        return;\n      }\n      this._closeOrCommit();\n    }\n  }\n\n  /** @private */\n  _onTouchend(event) {\n    if (!this.clearElement || event.composedPath()[0] !== this.clearElement) {\n      return;\n    }\n    event.preventDefault();\n    this._clear();\n  }\n\n  /**\n   * Fired when the value changes.\n   *\n   * @event value-changed\n   * @param {Object} detail\n   * @param {String} detail.value the combobox value\n   */\n\n  /**\n   * Fired when selected item changes.\n   *\n   * @event selected-item-changed\n   * @param {Object} detail\n   * @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.\n   */\n\n  /**\n   * Fired when the user sets a custom value.\n   * @event custom-value-set\n   * @param {String} detail the custom value\n   */\n\n  /**\n   * Fired when value changes.\n   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change\n   * @event change\n   */\n\n  /**\n   * Fired after the `vaadin-combo-box-overlay` opens.\n   *\n   * @event vaadin-combo-box-dropdown-opened\n   */\n\n  /**\n   * Fired after the `vaadin-combo-box-overlay` closes.\n   *\n   * @event vaadin-combo-box-dropdown-closed\n   */\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9zcmMvdmFhZGluLWNvbWJvLWJveC1taXhpbi5qcz9kMjk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgaXNUb3VjaCB9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2Jyb3dzZXItdXRpbHMuanMnO1xuaW1wb3J0IHsgQ29udHJvbGxlck1peGluIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvY29udHJvbGxlci1taXhpbi5qcyc7XG5pbXBvcnQgeyBEaXNhYmxlZE1peGluIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlzYWJsZWQtbWl4aW4uanMnO1xuaW1wb3J0IHsgaXNFbGVtZW50Rm9jdXNlZCB9IGZyb20gJ0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2ZvY3VzLXV0aWxzLmpzJztcbmltcG9ydCB7IEtleWJvYXJkTWl4aW4gfSBmcm9tICdAdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9rZXlib2FyZC1taXhpbi5qcyc7XG5pbXBvcnQgeyBwcm9jZXNzVGVtcGxhdGVzIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdGVtcGxhdGVzLmpzJztcbmltcG9ydCB7IElucHV0TWl4aW4gfSBmcm9tICdAdmFhZGluL2ZpZWxkLWJhc2Uvc3JjL2lucHV0LW1peGluLmpzJztcbmltcG9ydCB7IFZpcnR1YWxLZXlib2FyZENvbnRyb2xsZXIgfSBmcm9tICdAdmFhZGluL2ZpZWxkLWJhc2Uvc3JjL3ZpcnR1YWwta2V5Ym9hcmQtY29udHJvbGxlci5qcyc7XG5pbXBvcnQgeyBDb21ib0JveFBsYWNlaG9sZGVyIH0gZnJvbSAnLi92YWFkaW4tY29tYm8tYm94LXBsYWNlaG9sZGVyLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIHN1cHBvcnRlZCBhcyBhbiBpdGVtIHZhbHVlIGluIHRoaXMgY29udHJvbC5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb25cbiAqIGlnbm9yaW5nIHBsYWNlaG9sZGVyIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Q29tYm9Cb3hJdGVtIHwgc3RyaW5nPn0gaXRlbXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRJdGVtSW5kZXgoaXRlbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBpdGVtcy5maW5kSW5kZXgoKGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbWJvQm94UGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2soaXRlbSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gc3ViY2xhc3NcbiAqL1xuZXhwb3J0IGNvbnN0IENvbWJvQm94TWl4aW4gPSAoc3ViY2xhc3MpID0+XG4gIGNsYXNzIFZhYWRpbkNvbWJvQm94TWl4aW5FbGVtZW50IGV4dGVuZHMgQ29udHJvbGxlck1peGluKEtleWJvYXJkTWl4aW4oSW5wdXRNaXhpbihEaXNhYmxlZE1peGluKHN1YmNsYXNzKSkpKSB7XG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaWYgdGhlIGRyb3Bkb3duIGlzIG9wZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBvcGVuZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVyOiAnX29wZW5lZENoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdHJ1ZSB0byBwcmV2ZW50IHRoZSBvdmVybGF5IGZyb20gb3BlbmluZyBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgKiBAYXR0ciB7Ym9vbGVhbn0gYXV0by1vcGVuLWRpc2FibGVkXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvT3BlbkRpc2FibGVkOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBwcmVzZW50LCBpdCBzcGVjaWZpZXMgdGhhdCB0aGUgZmllbGQgaXMgcmVhZC1vbmx5LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRvbmx5OiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXN0b20gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyB0aGUgY29udGVudCBvZiBldmVyeSBpdGVtLlxuICAgICAgICAgKiBSZWNlaXZlcyB0aHJlZSBhcmd1bWVudHM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYHJvb3RgIFRoZSBgPHZhYWRpbi1jb21iby1ib3gtaXRlbT5gIGludGVybmFsIGNvbnRhaW5lciBET00gZWxlbWVudC5cbiAgICAgICAgICogLSBgY29tYm9Cb3hgIFRoZSByZWZlcmVuY2UgdG8gdGhlIGA8dmFhZGluLWNvbWJvLWJveD5gIGVsZW1lbnQuXG4gICAgICAgICAqIC0gYG1vZGVsYCBUaGUgb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgcmVsYXRlZCB3aXRoIHRoZSByZW5kZXJlZFxuICAgICAgICAgKiAgIGl0ZW0sIGNvbnRhaW5zOlxuICAgICAgICAgKiAgIC0gYG1vZGVsLmluZGV4YCBUaGUgaW5kZXggb2YgdGhlIHJlbmRlcmVkIGl0ZW0uXG4gICAgICAgICAqICAgLSBgbW9kZWwuaXRlbWAgVGhlIGl0ZW0uXG4gICAgICAgICAqIEB0eXBlIHtDb21ib0JveFJlbmRlcmVyIHwgdW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXI6IEZ1bmN0aW9uLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bGwgc2V0IG9mIGl0ZW1zIHRvIGZpbHRlciB0aGUgdmlzaWJsZSBvcHRpb25zIGZyb20uXG4gICAgICAgICAqIFRoZSBpdGVtcyBjYW4gYmUgb2YgZWl0aGVyIGBTdHJpbmdgIG9yIGBPYmplY3RgIHR5cGUuXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXk8IUNvbWJvQm94SXRlbSB8IHN0cmluZz4gfCB1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIG9ic2VydmVyOiAnX2l0ZW1zQ2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlIHVzZXIgY2FuIGlucHV0IGEgdmFsdWUgdGhhdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgaXRlbXMgbGlzdC5cbiAgICAgICAgICogYHZhbHVlYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCB0byB0aGUgaW5wdXQgdmFsdWUgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgKiBBbHNvLCB3aGVuIGB2YWx1ZWAgaXMgc2V0IHByb2dyYW1tYXRpY2FsbHksIHRoZSBpbnB1dCB2YWx1ZSB3aWxsIGJlIHNldFxuICAgICAgICAgKiB0byByZWZsZWN0IHRoYXQgdmFsdWUuXG4gICAgICAgICAqIEBhdHRyIHtib29sZWFufSBhbGxvdy1jdXN0b20tdmFsdWVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBhbGxvd0N1c3RvbVZhbHVlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3Vic2V0IG9mIGl0ZW1zLCBmaWx0ZXJlZCBiYXNlZCBvbiB0aGUgdXNlciBpbnB1dC4gRmlsdGVyZWQgaXRlbXNcbiAgICAgICAgICogY2FuIGJlIGFzc2lnbmVkIGRpcmVjdGx5IHRvIG9taXQgdGhlIGludGVybmFsIGZpbHRlcmluZyBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgKiBUaGUgaXRlbXMgY2FuIGJlIG9mIGVpdGhlciBgU3RyaW5nYCBvciBgT2JqZWN0YCB0eXBlLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PCFDb21ib0JveEl0ZW0gfCBzdHJpbmc+IHwgdW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsdGVyZWRJdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgIG9ic2VydmVyOiAnX2ZpbHRlcmVkSXRlbXNDaGFuZ2VkJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBkZXRlY3QgdXNlciB2YWx1ZSBjaGFuZ2VzIGFuZCBmaXJlIGBjaGFuZ2VgIGV2ZW50cy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9sYXN0Q29tbWl0dGVkVmFsdWU6IFN0cmluZyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBcImxvYWRpbmdcIiBhdHRyaWJ1dGUgaXMgYWRkZWQgdG8gaG9zdCBhbmQgdGhlIG92ZXJsYXkgZWxlbWVudC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsb2FkaW5nOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfZm9jdXNlZEluZGV4OiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIG9ic2VydmVyOiAnX2ZvY3VzZWRJbmRleENoYW5nZWQnLFxuICAgICAgICAgIHZhbHVlOiAtMSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlsdGVyaW5nIHN0cmluZyB0aGUgdXNlciBoYXMgdHlwZWQgaW50byB0aGUgaW5wdXQgZmllbGQuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlbGVjdGVkIGl0ZW0gZnJvbSB0aGUgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAgICogQHR5cGUge0NvbWJvQm94SXRlbSB8IHN0cmluZyB8IHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGggZm9yIGxhYmVsIG9mIHRoZSBpdGVtLiBJZiBgaXRlbXNgIGlzIGFuIGFycmF5IG9mIG9iamVjdHMsIHRoZVxuICAgICAgICAgKiBgaXRlbUxhYmVsUGF0aGAgaXMgdXNlZCB0byBmZXRjaCB0aGUgZGlzcGxheWVkIHN0cmluZyBsYWJlbCBmb3IgZWFjaFxuICAgICAgICAgKiBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaXRlbSBsYWJlbCBpcyBhbHNvIHVzZWQgZm9yIG1hdGNoaW5nIGl0ZW1zIHdoZW4gcHJvY2Vzc2luZyB1c2VyXG4gICAgICAgICAqIGlucHV0LCBpLmUuLCBmb3IgZmlsdGVyaW5nIGFuZCBzZWxlY3RpbmcgaXRlbXMuXG4gICAgICAgICAqIEBhdHRyIHtzdHJpbmd9IGl0ZW0tbGFiZWwtcGF0aFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUxhYmVsUGF0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ2xhYmVsJyxcbiAgICAgICAgICBvYnNlcnZlcjogJ19pdGVtTGFiZWxQYXRoQ2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGggZm9yIHRoZSB2YWx1ZSBvZiB0aGUgaXRlbS4gSWYgYGl0ZW1zYCBpcyBhbiBhcnJheSBvZiBvYmplY3RzLCB0aGVcbiAgICAgICAgICogYGl0ZW1WYWx1ZVBhdGg6YCBpcyB1c2VkIHRvIGZldGNoIHRoZSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBzZWxlY3RlZFxuICAgICAgICAgKiBpdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaXRlbSB2YWx1ZSBpcyB1c2VkIGluIHRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIHRoZSBjb21ibyBib3gsXG4gICAgICAgICAqIHRvIHByb3ZpZGUgdGhlIGZvcm0gdmFsdWUuXG4gICAgICAgICAqIEBhdHRyIHtzdHJpbmd9IGl0ZW0tdmFsdWUtcGF0aFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbVZhbHVlUGF0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ3ZhbHVlJyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGF0aCBmb3IgdGhlIGlkIG9mIHRoZSBpdGVtLiBJZiBgaXRlbXNgIGlzIGFuIGFycmF5IG9mIG9iamVjdHMsXG4gICAgICAgICAqIHRoZSBgaXRlbUlkUGF0aGAgaXMgdXNlZCB0byBjb21wYXJlIGFuZCBpZGVudGlmeSB0aGUgc2FtZSBpdGVtXG4gICAgICAgICAqIGluIGBzZWxlY3RlZEl0ZW1gIGFuZCBgZmlsdGVyZWRJdGVtc2AgKGl0ZW1zIGdpdmVuIGJ5IHRoZVxuICAgICAgICAgKiBgZGF0YVByb3ZpZGVyYCBjYWxsYmFjaykuXG4gICAgICAgICAqIEBhdHRyIHtzdHJpbmd9IGl0ZW0taWQtcGF0aFxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbUlkUGF0aDogU3RyaW5nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50IHwgdW5kZWZpbmVkfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdG9nZ2xlRWxlbWVudDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBvYnNlcnZlcjogJ190b2dnbGVFbGVtZW50Q2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIF9jbG9zZU9uQmx1cklzUHJldmVudGVkOiBCb29sZWFuLFxuXG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICBfc2Nyb2xsZXI6IE9iamVjdCxcblxuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgX292ZXJsYXlPcGVuZWQ6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIG9ic2VydmVyOiAnX292ZXJsYXlPcGVuZWRDaGFuZ2VkJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnX3NlbGVjdGVkSXRlbUNoYW5nZWQoc2VsZWN0ZWRJdGVtLCBpdGVtVmFsdWVQYXRoLCBpdGVtTGFiZWxQYXRoKScsXG4gICAgICAgICdfb3BlbmVkT3JJdGVtc0NoYW5nZWQob3BlbmVkLCBmaWx0ZXJlZEl0ZW1zLCBsb2FkaW5nKScsXG4gICAgICAgICdfdXBkYXRlU2Nyb2xsZXIoX3Njcm9sbGVyLCBmaWx0ZXJlZEl0ZW1zLCBvcGVuZWQsIGxvYWRpbmcsIHNlbGVjdGVkSXRlbSwgaXRlbUlkUGF0aCwgX2ZvY3VzZWRJbmRleCwgcmVuZGVyZXIsIHRoZW1lKScsXG4gICAgICBdO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX2JvdW5kT25Gb2N1c291dCA9IHRoaXMuX29uRm9jdXNvdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2JvdW5kT3ZlcmxheVNlbGVjdGVkSXRlbUNoYW5nZWQgPSB0aGlzLl9vdmVybGF5U2VsZWN0ZWRJdGVtQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fYm91bmRPbkNsZWFyQnV0dG9uTW91c2VEb3duID0gdGhpcy5fX29uQ2xlYXJCdXR0b25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2JvdW5kT25PdmVybGF5VG91Y2hBY3Rpb24gPSB0aGlzLl9vbk92ZXJsYXlUb3VjaEFjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fYm91bmRPblRvdWNoZW5kID0gdGhpcy5fb25Ub3VjaGVuZC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRhZyBuYW1lIHByZWZpeCB1c2VkIGJ5IHNjcm9sbGVyIGFuZCBpdGVtcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBfdGFnTmFtZVByZWZpeCgpIHtcbiAgICAgIHJldHVybiAndmFhZGluLWNvbWJvLWJveCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgX2lucHV0RWxlbWVudFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRFbGVtZW50ID8gdGhpcy5pbnB1dEVsZW1lbnRbdGhpcy5fcHJvcGVydHlGb3JWYWx1ZV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldCBfaW5wdXRFbGVtZW50VmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0RWxlbWVudCkge1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudFt0aGlzLl9wcm9wZXJ0eUZvclZhbHVlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIGA8aW5wdXQ+YCBlbGVtZW50LlxuICAgICAqIE92ZXJyaWRlIHRvIHByb3ZpZGUgYSBjdXN0b20gaW5wdXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge0hUTUxJbnB1dEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gICAgICovXG4gICAgZ2V0IF9uYXRpdmVJbnB1dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBtZXRob2QgaW5oZXJpdGVkIGZyb20gYElucHV0TWl4aW5gXG4gICAgICogdG8gY3VzdG9taXplIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW5wdXRFbGVtZW50Q2hhbmdlZChpbnB1dEVsZW1lbnQpIHtcbiAgICAgIHN1cGVyLl9pbnB1dEVsZW1lbnRDaGFuZ2VkKGlucHV0RWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5fbmF0aXZlSW5wdXQ7XG5cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBpbnB1dC5hdXRvY29tcGxldGUgPSAnb2ZmJztcbiAgICAgICAgaW5wdXQuYXV0b2NhcGl0YWxpemUgPSAnb2ZmJztcblxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnY29tYm9ib3gnKTtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWF1dG9jb21wbGV0ZScsICdsaXN0Jyk7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICEhdGhpcy5vcGVuZWQpO1xuXG4gICAgICAgIC8vIERpc2FibGUgdGhlIG1hY09TIFNhZmFyaSBzcGVsbCBjaGVjayBhdXRvIGNvcnJlY3Rpb25zLlxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcblxuICAgICAgICAvLyBEaXNhYmxlIGlPUyBhdXRvY29ycmVjdCBzdWdnZXN0aW9ucy5cbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcblxuICAgICAgICB0aGlzLl9yZXZlcnRJbnB1dFZhbHVlVG9WYWx1ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNsZWFyRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuY2xlYXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2JvdW5kT25DbGVhckJ1dHRvbk1vdXNlRG93bik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgc3VwZXIucmVhZHkoKTtcblxuICAgICAgdGhpcy5faW5pdE92ZXJsYXkoKTtcbiAgICAgIHRoaXMuX2luaXRTY3JvbGxlcigpO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fYm91bmRPbkZvY3Vzb3V0KTtcblxuICAgICAgdGhpcy5fbGFzdENvbW1pdHRlZFZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmRPblRvdWNoZW5kKTtcblxuICAgICAgY29uc3QgYnJpbmdUb0Zyb250TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4kLm92ZXJsYXkuYnJpbmdUb0Zyb250KCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBicmluZ1RvRnJvbnRMaXN0ZW5lcik7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBicmluZ1RvRnJvbnRMaXN0ZW5lcik7XG5cbiAgICAgIHByb2Nlc3NUZW1wbGF0ZXModGhpcyk7XG5cbiAgICAgIHRoaXMuYWRkQ29udHJvbGxlcihuZXcgVmlydHVhbEtleWJvYXJkQ29udHJvbGxlcih0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICAgIC8vIENsb3NlIHRoZSBvdmVybGF5IG9uIGRldGFjaFxuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGFuIHVwZGF0ZSBmb3IgdGhlIGNvbnRlbnQgb2YgaXRlbXMuXG4gICAgICogV2hpbGUgcGVyZm9ybWluZyB0aGUgdXBkYXRlLCBpdCBpbnZva2VzIHRoZSByZW5kZXJlciAocGFzc2VkIGluIHRoZSBgcmVuZGVyZXJgIHByb3BlcnR5KSBvbmNlIGFuIGl0ZW0uXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IHRoZSB1cGRhdGUgaGFwcGVucyBpbW1lZGlhdGVseSAoc3luY2hyb25vdXNseSkgYWZ0ZXIgaXQgaXMgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIHJlcXVlc3RDb250ZW50VXBkYXRlKCkge1xuICAgICAgaWYgKCF0aGlzLl9zY3JvbGxlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Njcm9sbGVyLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG5cbiAgICAgIHRoaXMuX2dldEl0ZW1FbGVtZW50cygpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaXRlbS5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGRyb3Bkb3duIGxpc3QuXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgIC8vIFByZXZlbnQgX29wZW4oKSBiZWluZyBjYWxsZWQgd2hlbiBpbnB1dCBpcyBkaXNhYmxlZCBvciByZWFkLW9ubHlcbiAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhdGhpcy5yZWFkb25seSkge1xuICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBkcm9wZG93biBsaXN0LlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBQb2x5bWVyIGxpZmVjeWNsZSBjYWxsYmFjayB0byBoYW5kbGUgYGZpbHRlcmAgcHJvcGVydHkgY2hhbmdlIGFmdGVyXG4gICAgICogdGhlIG9ic2VydmVyIGZvciBgb3BlbmVkYCBwcm9wZXJ0eSBpcyB0cmlnZ2VyZWQuIFRoaXMgaXMgbmVlZGVkIHdoZW4gb3BlbmluZ1xuICAgICAqIGNvbWJvLWJveCBvbiB1c2VyIGlucHV0IHRvIGVuc3VyZSB0aGUgZm9jdXNlZCBpbmRleCBpcyBzZXQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjdXJyZW50UHJvcHMgQ3VycmVudCBhY2Nlc3NvciB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IGNoYW5nZWRQcm9wcyBQcm9wZXJ0aWVzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgY2FsbFxuICAgICAqIEBwYXJhbSB7P09iamVjdH0gb2xkUHJvcHMgUHJldmlvdXMgdmFsdWVzIGZvciBlYWNoIGNoYW5nZWQgcHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykge1xuICAgICAgc3VwZXIuX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyk7XG5cbiAgICAgIGlmIChjaGFuZ2VkUHJvcHMuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyQ2hhbmdlZChjaGFuZ2VkUHJvcHMuZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfaW5pdE92ZXJsYXkoKSB7XG4gICAgICBjb25zdCBvdmVybGF5ID0gdGhpcy4kLm92ZXJsYXk7XG5cbiAgICAgIC8vIFN0b3JlIGluc3RhbmNlIGZvciBkZXRlY3RpbmcgXCJkaXJcIiBhdHRyaWJ1dGUgb24gb3BlbmluZ1xuICAgICAgb3ZlcmxheS5fY29tYm9Cb3ggPSB0aGlzO1xuXG4gICAgICBvdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmRPbk92ZXJsYXlUb3VjaEFjdGlvbik7XG4gICAgICBvdmVybGF5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2JvdW5kT25PdmVybGF5VG91Y2hBY3Rpb24pO1xuXG4gICAgICAvLyBQcmV2ZW50IGJsdXJyaW5nIHRoZSBpbnB1dCB3aGVuIGNsaWNraW5nIGluc2lkZSB0aGUgb3ZlcmxheVxuICAgICAgb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKTtcblxuICAgICAgLy8gTWFudWFsIHR3by13YXkgYmluZGluZyBmb3IgdGhlIG92ZXJsYXkgXCJvcGVuZWRcIiBwcm9wZXJ0eVxuICAgICAgb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdvcGVuZWQtY2hhbmdlZCcsIChlKSA9PiB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlPcGVuZWQgPSBlLmRldGFpbC52YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgaW5pdGlhbGl6ZSB0aGUgc2Nyb2xsZXIgZWxlbWVudC5cbiAgICAgKiBPdmVycmlkZSB0byBwcm92aWRlIGN1c3RvbSBob3N0IHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdFNjcm9sbGVyKGhvc3QpIHtcbiAgICAgIGNvbnN0IHNjcm9sbGVyVGFnID0gYCR7dGhpcy5fdGFnTmFtZVByZWZpeH0tc2Nyb2xsZXJgO1xuXG4gICAgICBjb25zdCBvdmVybGF5ID0gdGhpcy4kLm92ZXJsYXk7XG5cbiAgICAgIG92ZXJsYXkucmVuZGVyZXIgPSAocm9vdCkgPT4ge1xuICAgICAgICBpZiAoIXJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzY3JvbGxlclRhZykpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIHNjcm9sbGVyIGlzIHJlbmRlcmVkXG4gICAgICBvdmVybGF5LnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG5cbiAgICAgIGNvbnN0IHNjcm9sbGVyID0gb3ZlcmxheS5xdWVyeVNlbGVjdG9yKHNjcm9sbGVyVGFnKTtcblxuICAgICAgc2Nyb2xsZXIuY29tYm9Cb3ggPSBob3N0IHx8IHRoaXM7XG4gICAgICBzY3JvbGxlci5nZXRJdGVtTGFiZWwgPSB0aGlzLl9nZXRJdGVtTGFiZWwuYmluZCh0aGlzKTtcbiAgICAgIHNjcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbi1jaGFuZ2VkJywgdGhpcy5fYm91bmRPdmVybGF5U2VsZWN0ZWRJdGVtQ2hhbmdlZCk7XG5cbiAgICAgIC8vIFRyaWdnZXIgdGhlIG9ic2VydmVyIHRvIHNldCBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl9zY3JvbGxlciA9IHNjcm9sbGVyO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG4gICAgX3VwZGF0ZVNjcm9sbGVyKHNjcm9sbGVyLCBpdGVtcywgb3BlbmVkLCBsb2FkaW5nLCBzZWxlY3RlZEl0ZW0sIGl0ZW1JZFBhdGgsIGZvY3VzZWRJbmRleCwgcmVuZGVyZXIsIHRoZW1lKSB7XG4gICAgICBpZiAoc2Nyb2xsZXIpIHtcbiAgICAgICAgaWYgKG9wZW5lZCkge1xuICAgICAgICAgIHNjcm9sbGVyLnN0eWxlLm1heEhlaWdodCA9XG4gICAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoYC0tJHt0aGlzLl90YWdOYW1lUHJlZml4fS1vdmVybGF5LW1heC1oZWlnaHRgKSB8fCAnNjV2aCc7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxlci5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICBpdGVtczogb3BlbmVkID8gaXRlbXMgOiBbXSxcbiAgICAgICAgICBvcGVuZWQsXG4gICAgICAgICAgbG9hZGluZyxcbiAgICAgICAgICBzZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgaXRlbUlkUGF0aCxcbiAgICAgICAgICBmb2N1c2VkSW5kZXgsXG4gICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgdGhlbWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vcGVuZWRPckl0ZW1zQ2hhbmdlZChvcGVuZWQsIGl0ZW1zLCBsb2FkaW5nKSB7XG4gICAgICAvLyBDbG9zZSB0aGUgb3ZlcmxheSBpZiB0aGVyZSBhcmUgbm8gaXRlbXMgdG8gZGlzcGxheS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmFhZGluL3ZhYWRpbi1jb21iby1ib3gvcHVsbC85NjRcbiAgICAgIHRoaXMuX292ZXJsYXlPcGVuZWQgPSAhIShvcGVuZWQgJiYgKGxvYWRpbmcgfHwgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCkpKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb3ZlcmxheU9wZW5lZENoYW5nZWQob3BlbmVkLCB3YXNPcGVuZWQpIHtcbiAgICAgIGlmIChvcGVuZWQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndmFhZGluLWNvbWJvLWJveC1kcm9wZG93bi1vcGVuZWQnLCB7IGJ1YmJsZXM6IHRydWUsIGNvbXBvc2VkOiB0cnVlIH0pKTtcblxuICAgICAgICB0aGlzLl9vbk9wZW5lZCgpO1xuICAgICAgfSBlbHNlIGlmICh3YXNPcGVuZWQgJiYgdGhpcy5maWx0ZXJlZEl0ZW1zICYmIHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3ZhYWRpbi1jb21iby1ib3gtZHJvcGRvd24tY2xvc2VkJywgeyBidWJibGVzOiB0cnVlLCBjb21wb3NlZDogdHJ1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2ZvY3VzZWRJbmRleENoYW5nZWQoaW5kZXgsIG9sZEluZGV4KSB7XG4gICAgICBpZiAob2xkSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVEZXNjZW5kYW50KGluZGV4KTtcbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIF9pc0lucHV0Rm9jdXNlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudCAmJiBpc0VsZW1lbnRGb2N1c2VkKHRoaXMuaW5wdXRFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfdXBkYXRlQWN0aXZlRGVzY2VuZGFudChpbmRleCkge1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLl9uYXRpdmVJbnB1dDtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0SXRlbUVsZW1lbnRzKCkuZmluZCgoZWwpID0+IGVsLmluZGV4ID09PSBpbmRleCk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGl0ZW0uaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb3BlbmVkQ2hhbmdlZChvcGVuZWQsIHdhc09wZW5lZCkge1xuICAgICAgLy8gUHJldmVudCBfY2xvc2UoKSBiZWluZyBjYWxsZWQgd2hlbiBvcGVuZWQgaXMgc2V0IHRvIGl0cyBkZWZhdWx0IHZhbHVlIChmYWxzZSkuXG4gICAgICBpZiAod2FzT3BlbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlbmVkKSB7XG4gICAgICAgIHRoaXMuX29wZW5lZFdpdGhGb2N1c1JpbmcgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnZm9jdXMtcmluZycpO1xuICAgICAgICAvLyBGb3IgdG91Y2ggZGV2aWNlcywgd2UgZG9uJ3Qgd2FudCB0byBwb3B1cCB2aXJ0dWFsIGtleWJvYXJkXG4gICAgICAgIC8vIHVubGVzcyBpbnB1dCBlbGVtZW50IGlzIGV4cGxpY2l0bHkgZm9jdXNlZCBieSB0aGUgdXNlci5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0lucHV0Rm9jdXNlZCgpICYmICFpc1RvdWNoKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kLm92ZXJsYXkucmVzdG9yZUZvY3VzT25DbG9zZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkNsb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5fb3BlbmVkV2l0aEZvY3VzUmluZyAmJiB0aGlzLl9pc0lucHV0Rm9jdXNlZCgpKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2ZvY3VzLXJpbmcnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLl9uYXRpdmVJbnB1dDtcbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAhIW9wZW5lZCk7XG5cbiAgICAgICAgaWYgKG9wZW5lZCkge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsIHRoaXMuX3Njcm9sbGVyLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vbk92ZXJsYXlUb3VjaEFjdGlvbigpIHtcbiAgICAgIC8vIE9uIHRvdWNoIGRldmljZXMsIGJsdXIgdGhlIGlucHV0IG9uIHRvdWNoIHN0YXJ0IGluc2lkZSB0aGUgb3ZlcmxheSwgaW4gb3JkZXIgdG8gaGlkZVxuICAgICAgLy8gdGhlIHZpcnR1YWwga2V5Ym9hcmQuIEJ1dCBkb24ndCBjbG9zZSB0aGUgb3ZlcmxheSBvbiB0aGlzIGJsdXIuXG4gICAgICB0aGlzLl9jbG9zZU9uQmx1cklzUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmJsdXIoKTtcbiAgICAgIHRoaXMuX2Nsb3NlT25CbHVySXNQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIF9pc0NsZWFyQnV0dG9uKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gPT09IHRoaXMuY2xlYXJFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYW5kbGVDbGVhckJ1dHRvbkNsaWNrKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fY2xlYXIoKTtcblxuICAgICAgLy8gRGUtc2VsZWN0IGRyb3Bkb3duIGl0ZW1cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblRvZ2dsZUJ1dHRvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAvLyBQcmV2ZW50IHBhcmVudCBjb21wb25lbnRzIHN1Y2ggYXMgYHZhYWRpbi1ncmlkYFxuICAgICAgLy8gZnJvbSBoYW5kbGluZyB0aGUgY2xpY2sgZXZlbnQgYWZ0ZXIgaXQgYnViYmxlcy5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfb25Ib3N0Q2xpY2soZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5hdXRvT3BlbkRpc2FibGVkKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vbkNsaWNrKGUpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBlLmNvbXBvc2VkUGF0aCgpO1xuXG4gICAgICBpZiAodGhpcy5faXNDbGVhckJ1dHRvbihlKSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVDbGVhckJ1dHRvbkNsaWNrKGUpO1xuICAgICAgfSBlbHNlIGlmIChwYXRoLmluZGV4T2YodGhpcy5fdG9nZ2xlRWxlbWVudCkgPiAtMSkge1xuICAgICAgICB0aGlzLl9vblRvZ2dsZUJ1dHRvbkNsaWNrKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb25Ib3N0Q2xpY2soZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBgS2V5Ym9hcmRNaXhpbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uS2V5RG93bihlKSB7XG4gICAgICBzdXBlci5fb25LZXlEb3duKGUpO1xuXG4gICAgICBpZiAoZS5rZXkgPT09ICdUYWInKSB7XG4gICAgICAgIHRoaXMuJC5vdmVybGF5LnJlc3RvcmVGb2N1c09uQ2xvc2UgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XG4gICAgICAgIHRoaXMuX29uQXJyb3dEb3duKCk7XG5cbiAgICAgICAgLy8gUHJldmVudCBjYXJldCBmcm9tIG1vdmluZ1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgdGhpcy5fb25BcnJvd1VwKCk7XG5cbiAgICAgICAgLy8gUHJldmVudCBjYXJldCBmcm9tIG1vdmluZ1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2dldEl0ZW1MYWJlbChpdGVtKSB7XG4gICAgICBsZXQgbGFiZWwgPSBpdGVtICYmIHRoaXMuaXRlbUxhYmVsUGF0aCA/IHRoaXMuZ2V0KHRoaXMuaXRlbUxhYmVsUGF0aCwgaXRlbSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobGFiZWwgPT09IHVuZGVmaW5lZCB8fCBsYWJlbCA9PT0gbnVsbCkge1xuICAgICAgICBsYWJlbCA9IGl0ZW0gPyBpdGVtLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfZ2V0SXRlbVZhbHVlKGl0ZW0pIHtcbiAgICAgIGxldCB2YWx1ZSA9IGl0ZW0gJiYgdGhpcy5pdGVtVmFsdWVQYXRoID8gdGhpcy5nZXQodGhpcy5pdGVtVmFsdWVQYXRoLCBpdGVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gaXRlbSA/IGl0ZW0udG9TdHJpbmcoKSA6ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vbkFycm93RG93bigpIHtcbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuZmlsdGVyZWRJdGVtcztcbiAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgdGhpcy5fZm9jdXNlZEluZGV4ID0gTWF0aC5taW4oaXRlbXMubGVuZ3RoIC0gMSwgdGhpcy5fZm9jdXNlZEluZGV4ICsgMSk7XG4gICAgICAgICAgdGhpcy5fcHJlZmlsbEZvY3VzZWRJdGVtTGFiZWwoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX29uQXJyb3dVcCgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICBpZiAodGhpcy5fZm9jdXNlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSBNYXRoLm1heCgwLCB0aGlzLl9mb2N1c2VkSW5kZXggLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuZmlsdGVyZWRJdGVtcztcbiAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzZWRJbmRleCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJlZmlsbEZvY3VzZWRJdGVtTGFiZWwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9wcmVmaWxsRm9jdXNlZEl0ZW1MYWJlbCgpIHtcbiAgICAgIGlmICh0aGlzLl9mb2N1c2VkSW5kZXggPiAtMSkge1xuICAgICAgICBjb25zdCBmb2N1c2VkSXRlbSA9IHRoaXMuZmlsdGVyZWRJdGVtc1t0aGlzLl9mb2N1c2VkSW5kZXhdO1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMuX2dldEl0ZW1MYWJlbChmb2N1c2VkSXRlbSk7XG4gICAgICAgIHRoaXMuX21hcmtBbGxTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAvLyBTZXR0aW5nIHNlbGVjdGlvbiByYW5nZSBmb2N1c2VzIGFuZC9vciBtb3ZlcyB0aGUgY2FyZXQgaW4gc29tZSBicm93c2VycyxcbiAgICAgIC8vIGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gbW9kaWZ5IHRoZSBzZWxlY3Rpb24gcmFuZ2UgaWYgdGhlIGlucHV0IGlzbid0IGZvY3VzZWQgYW55d2F5LlxuICAgICAgLy8gVGhpcyBhZmZlY3RzIFNhZmFyaS4gV2hlbiB0aGUgb3ZlcmxheSBpcyBvcGVuLCBhbmQgdGhlbiBoaXR0aW5nIHRhYiwgYnJvd3NlciBzaG91bGQgZm9jdXNcbiAgICAgIC8vIHRoZSBuZXh0IGZvY3VzYWJsZSBlbGVtZW50IGluc3RlYWQgb2YgdGhlIGNvbWJvLWJveCBpdHNlbGYuXG4gICAgICBpZiAodGhpcy5faXNJbnB1dEZvY3VzZWQoKSAmJiB0aGlzLmlucHV0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfbWFya0FsbFNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgaWYgKHRoaXMuX2lucHV0RWxlbWVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uUmFuZ2UoMCwgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX2lucHV0RWxlbWVudFZhbHVlID8gdGhpcy5faW5wdXRFbGVtZW50VmFsdWUubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uUmFuZ2UocG9zLCBwb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9jbG9zZU9yQ29tbWl0KCkge1xuICAgICAgaWYgKCF0aGlzLm9wZW5lZCAmJiAhdGhpcy5sb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuX2NvbW1pdFZhbHVlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBgS2V5Ym9hcmRNaXhpbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uRW50ZXIoZSkge1xuICAgICAgLy8gRG8gbm90IGNvbW1pdCB2YWx1ZSB3aGVuIGN1c3RvbSB2YWx1ZXMgYXJlIGRpc2FsbG93ZWQgYW5kIGlucHV0IHZhbHVlIGlzIG5vdCBhIHZhbGlkIG9wdGlvblxuICAgICAgLy8gYWxzbyBzdG9wIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCwgb3RoZXJ3aXNlIHRoZSB1c2VyIGNvdWxkIHN1Ym1pdCBhIGZvcm0gd2hpbGUgdGhlIGlucHV0XG4gICAgICAvLyBzdGlsbCBjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlXG4gICAgICBjb25zdCBoYXNJbnZhbGlkT3B0aW9uID1cbiAgICAgICAgdGhpcy5fZm9jdXNlZEluZGV4IDwgMCAmJlxuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAhPT0gJycgJiZcbiAgICAgICAgdGhpcy5fZ2V0SXRlbUxhYmVsKHRoaXMuc2VsZWN0ZWRJdGVtKSAhPT0gdGhpcy5faW5wdXRFbGVtZW50VmFsdWU7XG4gICAgICBpZiAoIXRoaXMuYWxsb3dDdXN0b21WYWx1ZSAmJiBoYXNJbnZhbGlkT3B0aW9uKSB7XG4gICAgICAgIC8vIERvIG5vdCBzdWJtaXQgdGhlIHN1cnJvdW5kaW5nIGZvcm0uXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gRG8gbm90IHRyaWdnZXIgZ2xvYmFsIGxpc3RlbmVyc1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3AgcHJvcGFnYXRpb24gb2YgdGhlIGVudGVyIGV2ZW50IG9ubHkgaWYgdGhlIGRyb3Bkb3duIGlzIG9wZW5lZCwgdGhpc1xuICAgICAgLy8gXCJjb25zdW1lc1wiIHRoZSBlbnRlciBldmVudCBmb3IgdGhlIGFjdGlvbiBvZiBjbG9zaW5nIHRoZSBkcm9wZG93blxuICAgICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAgIC8vIERvIG5vdCBzdWJtaXQgdGhlIHN1cnJvdW5kaW5nIGZvcm0uXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gRG8gbm90IHRyaWdnZXIgZ2xvYmFsIGxpc3RlbmVyc1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbG9zZU9yQ29tbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBgS2V5Ym9hcmRNaXhpbmAuXG4gICAgICogRG8gbm90IGNhbGwgYHN1cGVyYCBpbiBvcmRlciB0byBvdmVycmlkZSBjbGVhclxuICAgICAqIGJ1dHRvbiBsb2dpYyBkZWZpbmVkIGluIGBJbnB1dENvbnRyb2xNaXhpbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbkVzY2FwZShlKSB7XG4gICAgICBpZiAodGhpcy5hdXRvT3BlbkRpc2FibGVkKSB7XG4gICAgICAgIC8vIEF1dG8tb3BlbiBpcyBkaXNhYmxlZFxuICAgICAgICBpZiAodGhpcy5vcGVuZWQgfHwgKHRoaXMudmFsdWUgIT09IHRoaXMuX2lucHV0RWxlbWVudFZhbHVlICYmIHRoaXMuX2lucHV0RWxlbWVudFZhbHVlLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgLy8gVGhlIG92ZXJsYXkgaXMgb3BlbiBvclxuICAgICAgICAgIC8vIFRoZSBpbnB1dCB2YWx1ZSBoYXMgY2hhbmdlZCBidXQgdGhlIGNoYW5nZSBoYXNuJ3QgYmVlbiBjb21taXR0ZWQsIHNvIGNhbmNlbCBpdC5cbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2ZvY3VzZWRJbmRleCA9IC0xO1xuICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGVhckJ1dHRvblZpc2libGUgJiYgIXRoaXMub3BlbmVkICYmICEhdGhpcy52YWx1ZSkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgLy8gVGhlIGNsZWFyIGJ1dHRvbiBpcyB2aXNpYmxlIGFuZCB0aGUgb3ZlcmxheSBpcyBjbG9zZWQsIHNvIGNsZWFyIHRoZSB2YWx1ZS5cbiAgICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAgIC8vIEF1dG8tb3BlbiBpcyBlbmFibGVkXG4gICAgICAgIC8vIFRoZSBvdmVybGF5IGlzIG9wZW5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5fZm9jdXNlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAvLyBBbiBpdGVtIGlzIGZvY3VzZWQsIHJldmVydCB0aGUgaW5wdXQgdG8gdGhlIGZpbHRlcmVkIHZhbHVlXG4gICAgICAgICAgdGhpcy5fZm9jdXNlZEluZGV4ID0gLTE7XG4gICAgICAgICAgdGhpcy5fcmV2ZXJ0SW5wdXRWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGl0ZW0gaXMgZm9jdXNlZCwgY2FuY2VsIHRoZSBjaGFuZ2UgYW5kIGNsb3NlIHRoZSBvdmVybGF5XG4gICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmNsZWFyQnV0dG9uVmlzaWJsZSAmJiAhIXRoaXMudmFsdWUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gVGhlIGNsZWFyIGJ1dHRvbiBpcyB2aXNpYmxlIGFuZCB0aGUgb3ZlcmxheSBpcyBjbG9zZWQsIHNvIGNsZWFyIHRoZSB2YWx1ZS5cbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfdG9nZ2xlRWxlbWVudENoYW5nZWQodG9nZ2xlRWxlbWVudCkge1xuICAgICAgaWYgKHRvZ2dsZUVsZW1lbnQpIHtcbiAgICAgICAgLy8gRG9uJ3QgYmx1ciB0aGUgaW5wdXQgb24gdG9nZ2xlIG1vdXNlZG93blxuICAgICAgICB0b2dnbGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgICAvLyBVbmZvY3VzIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IGlmIGZvY3VzIGlzIG5vdCBpbnNpZGUgY29tYm8gYm94IChvbiB0b3VjaCBkZXZpY2VzKVxuICAgICAgICB0b2dnbGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIGlmIChpc1RvdWNoICYmICF0aGlzLl9pc0lucHV0Rm9jdXNlZCgpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NsZWFyKCkge1xuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5hbGxvd0N1c3RvbVZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZGV0ZWN0QW5kRGlzcGF0Y2hDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIGJhY2sgdG8gb3JpZ2luYWwgdmFsdWUuXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgICAgdGhpcy5fcmV2ZXJ0SW5wdXRWYWx1ZVRvVmFsdWUoKTtcbiAgICAgIC8vIEluIHRoZSBuZXh0IF9kZXRlY3RBbmREaXNwYXRjaENoYW5nZSgpIGNhbGwsIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIHNob3VsZCBub3QgcGFzc1xuICAgICAgdGhpcy5fbGFzdENvbW1pdHRlZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMuX2Nsb3NlT3JDb21taXQoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb25PcGVuZWQoKSB7XG4gICAgICAvLyBEZWZlciBzY3JvbGwgcG9zaXRpb24gYWRqdXN0bWVudCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsSW50b1ZpZXcodGhpcy5fZm9jdXNlZEluZGV4KTtcblxuICAgICAgICAvLyBTZXQgYXR0cmlidXRlIGFmdGVyIHRoZSBpdGVtcyBhcmUgcmVuZGVyZWQgd2hlbiBvdmVybGF5IGlzIG9wZW5lZCBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZURlc2NlbmRhbnQodGhpcy5fZm9jdXNlZEluZGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBfZGV0ZWN0QW5kRGlzcGF0Y2hDaGFuZ2UoKSBzaG91bGQgbm90IGNvbnNpZGVyIHZhbHVlIGNoYW5nZXMgZG9uZSBiZWZvcmUgb3BlbmluZ1xuICAgICAgdGhpcy5fbGFzdENvbW1pdHRlZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb25DbG9zZWQoKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGluZyB8fCB0aGlzLmFsbG93Q3VzdG9tVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29tbWl0VmFsdWUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfY29tbWl0VmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5fZm9jdXNlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZEl0ZW0gPSB0aGlzLmZpbHRlcmVkSXRlbXNbdGhpcy5fZm9jdXNlZEluZGV4XTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtICE9PSBmb2N1c2VkSXRlbSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gZm9jdXNlZEl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGlucHV0IGZpZWxkIGlzIHVwZGF0ZWQgaW4gY2FzZSB2YWx1ZSBkb2Vzbid0IGNoYW5nZSAoaS5lLiBGT08gLT4gZm9vKVxuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLnNlbGVjdGVkSXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0RWxlbWVudFZhbHVlID09PSAnJyB8fCB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5hbGxvd0N1c3RvbVZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBhbiBpdGVtIHdoaWNoIGxhYmVsIG1hdGNoZXMgdGhlIGlucHV0IHZhbHVlLlxuICAgICAgICBjb25zdCBpdGVtcyA9IFsuLi4odGhpcy5maWx0ZXJlZEl0ZW1zIHx8IFtdKSwgdGhpcy5zZWxlY3RlZEl0ZW1dO1xuICAgICAgICBjb25zdCBpdGVtTWF0Y2hpbmdJbnB1dFZhbHVlID0gaXRlbXNbdGhpcy5fX2dldEl0ZW1JbmRleEJ5TGFiZWwoaXRlbXMsIHRoaXMuX2lucHV0RWxlbWVudFZhbHVlKV07XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuYWxsb3dDdXN0b21WYWx1ZSAmJlxuICAgICAgICAgIC8vIFRvIHByZXZlbnQgYSByZXBldGl0aXZlIGlucHV0IHZhbHVlIGJlaW5nIHNhdmVkIGFmdGVyIHByZXNzaW5nIEVTQyBhbmQgVGFiLlxuICAgICAgICAgICFpdGVtTWF0Y2hpbmdJbnB1dFZhbHVlXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGN1c3RvbVZhbHVlID0gdGhpcy5faW5wdXRFbGVtZW50VmFsdWU7XG5cbiAgICAgICAgICAvLyBTdG9yZSByZWZlcmVuY2UgdG8gdGhlIGxhc3QgY3VzdG9tIHZhbHVlIGZvciBjaGVja2luZyBpdCBvbiBmb2N1c291dC5cbiAgICAgICAgICB0aGlzLl9sYXN0Q3VzdG9tVmFsdWUgPSBjdXN0b21WYWx1ZTtcblxuICAgICAgICAgIC8vIEFuIGl0ZW0gbWF0Y2hpbmcgYnkgbGFiZWwgd2FzIG5vdCBmb3VuZCwgYnV0IGN1c3RvbSB2YWx1ZXMgYXJlIGFsbG93ZWQuXG4gICAgICAgICAgLy8gRGlzcGF0Y2ggYSBjdXN0b20tdmFsdWUtc2V0IGV2ZW50IHdpdGggdGhlIGlucHV0IHZhbHVlLlxuICAgICAgICAgIGNvbnN0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoJ2N1c3RvbS12YWx1ZS1zZXQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGN1c3RvbVZhbHVlLFxuICAgICAgICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjdXN0b21WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYWxsb3dDdXN0b21WYWx1ZSAmJiAhdGhpcy5vcGVuZWQgJiYgaXRlbU1hdGNoaW5nSW5wdXRWYWx1ZSkge1xuICAgICAgICAgIC8vIEFuIGl0ZW0gbWF0Y2hpbmcgYnkgbGFiZWwgd2FzIGZvdW5kLCBzZWxlY3QgaXQuXG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2dldEl0ZW1WYWx1ZShpdGVtTWF0Y2hpbmdJbnB1dFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXZlcnQgdGhlIGlucHV0IHZhbHVlXG4gICAgICAgICAgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgPSB0aGlzLnNlbGVjdGVkSXRlbSA/IHRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLnNlbGVjdGVkSXRlbSkgOiB0aGlzLnZhbHVlIHx8ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RldGVjdEFuZERpc3BhdGNoQ2hhbmdlKCk7XG5cbiAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcblxuICAgICAgdGhpcy5maWx0ZXIgPSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGdldCBfcHJvcGVydHlGb3JWYWx1ZSgpIHtcbiAgICAgIHJldHVybiAndmFsdWUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYElucHV0TWl4aW5gLlxuICAgICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25JbnB1dChldmVudCkge1xuICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5faW5wdXRFbGVtZW50VmFsdWU7XG5cbiAgICAgIC8vIFdoZW4gb3BlbmluZyBkcm9wZG93biBvbiB1c2VyIGlucHV0LCBib3RoIGBvcGVuZWRgIGFuZCBgZmlsdGVyYCBwcm9wZXJ0aWVzIGFyZSBzZXQuXG4gICAgICAvLyBQZXJmb3JtIGEgYmF0Y2hlZCBwcm9wZXJ0eSB1cGRhdGUgaW5zdGVhZCBvZiByZWx5aW5nIG9uIHN5bmMgcHJvcGVydHkgb2JzZXJ2ZXJzLlxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgYW4gZXh0cmEgZGF0YS1wcm92aWRlciByZXF1ZXN0IGZvciBsb2FkaW5nIGZpcnN0IHBhZ2UuXG4gICAgICBjb25zdCBwcm9wcyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5maWx0ZXIgPT09IGZpbHRlcikge1xuICAgICAgICAvLyBGaWx0ZXIgYW5kIGlucHV0IHZhbHVlIG1pZ2h0IGdldCBvdXQgb2Ygc3luYywgd2hpbGUga2V5Ym9hcmQgbmF2aWdhdGluZyBmb3IgZXhhbXBsZS5cbiAgICAgICAgLy8gQWZ0ZXJ3YXJkcywgaW5wdXQgdmFsdWUgbWlnaHQgYmUgY2hhbmdlZCB0byB0aGUgc2FtZSB2YWx1ZSBhcyB1c2VkIGluIGZpbHRlcmluZy5cbiAgICAgICAgLy8gSW4gc2l0dWF0aW9uIGxpa2UgdGhlc2UsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCB0aGUgZmlsdGVyIGNoYW5nZXMgaGFuZGxlcnMgYXJlIHJ1bi5cbiAgICAgICAgdGhpcy5fZmlsdGVyQ2hhbmdlZCh0aGlzLmZpbHRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcGVuZWQgJiYgIXRoaXMuX2lzQ2xlYXJCdXR0b24oZXZlbnQpICYmICF0aGlzLmF1dG9PcGVuRGlzYWJsZWQpIHtcbiAgICAgICAgcHJvcHMub3BlbmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGBJbnB1dE1peGluYC5cbiAgICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAvLyBTdXBwcmVzcyB0aGUgbmF0aXZlIGNoYW5nZSBldmVudCBmaXJlZCBvbiB0aGUgbmF0aXZlIGlucHV0LlxuICAgICAgLy8gV2UgdXNlIGBfZGV0ZWN0QW5kRGlzcGF0Y2hDaGFuZ2VgIHRvIGZpcmUgYSBjdXN0b20gZXZlbnQuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfaXRlbUxhYmVsUGF0aENoYW5nZWQoaXRlbUxhYmVsUGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtTGFiZWxQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdZb3Ugc2hvdWxkIHNldCBpdGVtTGFiZWxQYXRoIHRvIGEgdmFsaWQgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX2ZpbHRlckNoYW5nZWQoZmlsdGVyKSB7XG4gICAgICAvLyBTY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgbGlzdCB3aGVuZXZlciB0aGUgZmlsdGVyIGNoYW5nZXMuXG4gICAgICB0aGlzLl9zY3JvbGxJbnRvVmlldygwKTtcblxuICAgICAgdGhpcy5fZm9jdXNlZEluZGV4ID0gLTE7XG5cbiAgICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyZWRJdGVtcyA9IHRoaXMuX2ZpbHRlckl0ZW1zKHRoaXMuaXRlbXMsIGZpbHRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaXRoIGNlcnRhaW4gdXNlIGNhc2VzIChlLiBnLiwgZXh0ZXJuYWwgZmlsdGVyaW5nKSwgYGl0ZW1zYCBhcmVcbiAgICAgICAgLy8gdW5kZWZpbmVkLiBGaWx0ZXJpbmcgaXMgdW5uZWNlc3NhcnkgcGVyIHNlLCBidXQgdGhlIGZpbHRlcmVkSXRlbXNcbiAgICAgICAgLy8gb2JzZXJ2ZXIgc2hvdWxkIHN0aWxsIGJlIGludm9rZWQgdG8gdXBkYXRlIGZvY3VzZWQgaXRlbS5cbiAgICAgICAgdGhpcy5fZmlsdGVyZWRJdGVtc0NoYW5nZWQodGhpcy5maWx0ZXJlZEl0ZW1zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIF9yZXZlcnRJbnB1dFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyICE9PSAnJykge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMuZmlsdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmV2ZXJ0SW5wdXRWYWx1ZVRvVmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfcmV2ZXJ0SW5wdXRWYWx1ZVRvVmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5hbGxvd0N1c3RvbVZhbHVlICYmICF0aGlzLnNlbGVjdGVkSXRlbSkge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLnNlbGVjdGVkSXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3NlbGVjdGVkSXRlbUNoYW5nZWQoc2VsZWN0ZWRJdGVtKSB7XG4gICAgICBpZiAoc2VsZWN0ZWRJdGVtID09PSBudWxsIHx8IHNlbGVjdGVkSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkSXRlbXMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dDdXN0b21WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3RvZ2dsZUhhc1ZhbHVlKHRoaXMuX2hhc1ZhbHVlKTtcbiAgICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0SXRlbVZhbHVlKHNlbGVjdGVkSXRlbSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgY2hhbmdlZCB0byBzb21ldGhpbmcgZWxzZSBpbiB2YWx1ZS1jaGFuZ2VkIGxpc3RlbmVyLFxuICAgICAgICAgICAgLy8gc28gcHJldmVudCBmcm9tIHJlc2V0dGluZyBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdG9nZ2xlSGFzVmFsdWUodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudFZhbHVlID0gdGhpcy5fZ2V0SXRlbUxhYmVsKHNlbGVjdGVkSXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZpbHRlcmVkSXRlbXMpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZEluZGV4ID0gdGhpcy5maWx0ZXJlZEl0ZW1zLmluZGV4T2Yoc2VsZWN0ZWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBhbiBvYnNlcnZlciBmcm9tIGBJbnB1dE1peGluYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3ZhbHVlQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICcnICYmIG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemluZywgbm8gbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZhYWRpbi92YWFkaW4tY29tYm8tYm94L2lzc3Vlcy81NTRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNWYWxpZFZhbHVlKHZhbHVlKSkge1xuICAgICAgICBpZiAodGhpcy5fZ2V0SXRlbVZhbHVlKHRoaXMuc2VsZWN0ZWRJdGVtKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3RJdGVtRm9yVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkSXRlbSAmJiB0aGlzLmFsbG93Q3VzdG9tVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdG9nZ2xlSGFzVmFsdWUodGhpcy5faGFzVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbHRlciA9ICcnO1xuXG4gICAgICAvLyBJbiB0aGUgbmV4dCBfZGV0ZWN0QW5kRGlzcGF0Y2hDaGFuZ2UoKSBjYWxsLCB0aGUgY2hhbmdlIGRldGVjdGlvbiBzaG91bGQgcGFzc1xuICAgICAgdGhpcy5fbGFzdENvbW1pdHRlZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9kZXRlY3RBbmREaXNwYXRjaENoYW5nZSgpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB0aGlzLl9sYXN0Q29tbWl0dGVkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5fbGFzdENvbW1pdHRlZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfaXRlbXNDaGFuZ2VkKGl0ZW1zLCBvbGRJdGVtcykge1xuICAgICAgdGhpcy5fZW5zdXJlSXRlbXNPckRhdGFQcm92aWRlcigoKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBvbGRJdGVtcztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJlZEl0ZW1zID0gaXRlbXMuc2xpY2UoMCk7XG4gICAgICB9IGVsc2UgaWYgKG9sZEl0ZW1zKSB7XG4gICAgICAgIC8vIE9ubHkgY2xlYXIgZmlsdGVyZWRJdGVtcyBpZiB0aGUgY29tcG9uZW50IGhhZCBpdGVtcyBwcmV2aW91c2x5IGJ1dCBnb3QgY2xlYXJlZFxuICAgICAgICB0aGlzLmZpbHRlcmVkSXRlbXMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9maWx0ZXJlZEl0ZW1zQ2hhbmdlZChmaWx0ZXJlZEl0ZW1zLCBvbGRGaWx0ZXJlZEl0ZW1zKSB7XG4gICAgICAvLyBTdG9yZSB0aGUgY3VycmVudGx5IGZvY3VzZWQgaXRlbSBpZiBhbnkuIFRoZSBmb2N1c2VkIGluZGV4IHByZXNlcnZlc1xuICAgICAgLy8gaW4gdGhlIGNhc2Ugd2hlbiBtb3JlIGZpbHRlcmVkIGl0ZW1zIGFyZSBsb2FkaW5nIGJ1dCBpdCBpcyByZXNldFxuICAgICAgLy8gd2hlbiB0aGUgdXNlciB0eXBlcyBpbiBhIGZpbHRlciBxdWVyeS5cbiAgICAgIGNvbnN0IGZvY3VzZWRJdGVtID0gb2xkRmlsdGVyZWRJdGVtcyA/IG9sZEZpbHRlcmVkSXRlbXNbdGhpcy5fZm9jdXNlZEluZGV4XSA6IG51bGw7XG5cbiAgICAgIC8vIFRyeSB0byBzeW5jIGBzZWxlY3RlZEl0ZW1gIGJhc2VkIG9uIGB2YWx1ZWAgb25jZSBhIG5ldyBzZXQgb2YgYGZpbHRlcmVkSXRlbXNgIGlzIGF2YWlsYWJsZVxuICAgICAgLy8gKGFzIGEgcmVzdWx0IG9mIGV4dGVybmFsIGZpbHRlcmluZyBvciB3aGVuIHRoZXkgaGF2ZSBiZWVuIGxvYWRlZCBieSB0aGUgZGF0YSBwcm92aWRlcikuXG4gICAgICAvLyBXaGVuIGB2YWx1ZWAgaXMgc3BlY2lmaWVkIGJ1dCBgc2VsZWN0ZWRJdGVtYCBpcyBub3QsIGl0IG1lYW5zIHRoYXQgdGhlcmUgd2FzIG5vIGl0ZW1cbiAgICAgIC8vIG1hdGNoaW5nIGB2YWx1ZWAgYXQgdGhlIG1vbWVudCBgdmFsdWVgIHdhcyBzZXQsIHNvIGBzZWxlY3RlZEl0ZW1gIGhhcyByZW1haW5lZCB1bnN5bmNlZC5cbiAgICAgIGNvbnN0IHZhbHVlSW5kZXggPSB0aGlzLl9fZ2V0SXRlbUluZGV4QnlWYWx1ZShmaWx0ZXJlZEl0ZW1zLCB0aGlzLnZhbHVlKTtcbiAgICAgIGlmICgodGhpcy5zZWxlY3RlZEl0ZW0gPT09IG51bGwgfHwgdGhpcy5zZWxlY3RlZEl0ZW0gPT09IHVuZGVmaW5lZCkgJiYgdmFsdWVJbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gZmlsdGVyZWRJdGVtc1t2YWx1ZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IHRvIGZpcnN0IHNldCBmb2N1cyBvbiB0aGUgaXRlbSB0aGF0IGhhZCBiZWVuIGZvY3VzZWQgYmVmb3JlIGBmaWx0ZXJlZEl0ZW1zYCB3ZXJlIHVwZGF0ZWRcbiAgICAgIC8vIGlmIGl0IGlzIHN0aWxsIHByZXNlbnQgaW4gdGhlIGBmaWx0ZXJlZEl0ZW1zYCBhcnJheS4gT3RoZXJ3aXNlLCBzZXQgdGhlIGZvY3VzZWQgaW5kZXhcbiAgICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgc2VsZWN0ZWQgaXRlbSBvciB0aGUgZmlsdGVyIHF1ZXJ5LlxuICAgICAgY29uc3QgZm9jdXNlZEl0ZW1JbmRleCA9IHRoaXMuX19nZXRJdGVtSW5kZXhCeVZhbHVlKGZpbHRlcmVkSXRlbXMsIHRoaXMuX2dldEl0ZW1WYWx1ZShmb2N1c2VkSXRlbSkpO1xuICAgICAgaWYgKGZvY3VzZWRJdGVtSW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSBmb2N1c2VkSXRlbUluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX3NldEluaXRpYWxGb2N1c2VkSW5kZXgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfX3NldEluaXRpYWxGb2N1c2VkSW5kZXgoKSB7XG4gICAgICBjb25zdCBpbnB1dFZhbHVlID0gdGhpcy5faW5wdXRFbGVtZW50VmFsdWU7XG4gICAgICBpZiAoaW5wdXRWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlucHV0VmFsdWUgPT09IHRoaXMuX2dldEl0ZW1MYWJlbCh0aGlzLnNlbGVjdGVkSXRlbSkpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaW5wdXQgZWxlbWVudCB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB2YWx1ZSBvciBub3QgZGVmaW5lZCxcbiAgICAgICAgLy8gc2V0IHRoZSBmb2N1c2VkIGluZGV4IHRvIHRoZSBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgdmFsdWUuXG4gICAgICAgIHRoaXMuX2ZvY3VzZWRJbmRleCA9IHRoaXMuX19nZXRJdGVtSW5kZXhCeUxhYmVsKHRoaXMuZmlsdGVyZWRJdGVtcywgdGhpcy5fZ2V0SXRlbUxhYmVsKHRoaXMuc2VsZWN0ZWRJdGVtKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSB1c2VyIGZpbGxlZCBpbiBzb21ldGhpbmcgdGhhdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCB2YWx1ZSA9IGZpbHRlcmluZyBpcyBlbmFibGVkLFxuICAgICAgICAvLyBzZXQgdGhlIGZvY3VzZWQgaW5kZXggdG8gdGhlIGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBmaWx0ZXIgcXVlcnkuXG4gICAgICAgIHRoaXMuX2ZvY3VzZWRJbmRleCA9IHRoaXMuX19nZXRJdGVtSW5kZXhCeUxhYmVsKHRoaXMuZmlsdGVyZWRJdGVtcywgdGhpcy5maWx0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9maWx0ZXJJdGVtcyhhcnIsIGZpbHRlcikge1xuICAgICAgaWYgKCFhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsdGVyZWRJdGVtcyA9IGFyci5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgZmlsdGVyID0gZmlsdGVyID8gZmlsdGVyLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgICAvLyBDaGVjayBpZiBpdGVtIGNvbnRhaW5zIGlucHV0IHZhbHVlLlxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SXRlbUxhYmVsKGl0ZW0pLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKGZpbHRlcikgPiAtMTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZmlsdGVyZWRJdGVtcztcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfc2VsZWN0SXRlbUZvclZhbHVlKHZhbHVlKSB7XG4gICAgICBjb25zdCB2YWx1ZUluZGV4ID0gdGhpcy5fX2dldEl0ZW1JbmRleEJ5VmFsdWUodGhpcy5maWx0ZXJlZEl0ZW1zLCB2YWx1ZSk7XG4gICAgICBjb25zdCBwcmV2aW91c2x5U2VsZWN0ZWRJdGVtID0gdGhpcy5zZWxlY3RlZEl0ZW07XG5cbiAgICAgIGlmICh2YWx1ZUluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSB0aGlzLmZpbHRlcmVkSXRlbXNbdmFsdWVJbmRleF07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVByb3ZpZGVyICYmIHRoaXMuc2VsZWN0ZWRJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSA9PT0gbnVsbCAmJiBwcmV2aW91c2x5U2VsZWN0ZWRJdGVtID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSXRlbUNoYW5nZWQodGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9nZXRJdGVtRWxlbWVudHMoKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9zY3JvbGxlci5xdWVyeVNlbGVjdG9yQWxsKGAke3RoaXMuX3RhZ05hbWVQcmVmaXh9LWl0ZW1gKSk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX3Njcm9sbEludG9WaWV3KGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3Njcm9sbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbGVyLnNjcm9sbEludG9WaWV3KGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fZ2V0SXRlbUluZGV4QnlWYWx1ZShpdGVtcywgdmFsdWUpIHtcbiAgICAgIGlmICghaXRlbXMgfHwgIWlzVmFsaWRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmluZEl0ZW1JbmRleChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShpdGVtKSA9PT0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgbGFiZWwuXG4gICAgICogTGFiZWxzIGFyZSBtYXRjaGVkIGFnYWluc3QgZWFjaCBvdGhlciBjYXNlIGluc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fZ2V0SXRlbUluZGV4QnlMYWJlbChpdGVtcywgbGFiZWwpIHtcbiAgICAgIGlmICghaXRlbXMgfHwgIWxhYmVsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmRJdGVtSW5kZXgoaXRlbXMsIChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtTGFiZWwoaXRlbSkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBsYWJlbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfb3ZlcmxheVNlbGVjdGVkSXRlbUNoYW5nZWQoZSkge1xuICAgICAgLy8gU3RvcCB0aGlzIHByaXZhdGUgZXZlbnQgZnJvbSBsZWFraW5nIG91dHNpZGUuXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBpZiAoZS5kZXRhaWwuaXRlbSBpbnN0YW5jZW9mIENvbWJvQm94UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgLy8gUGxhY2Vob2xkZXIgaXRlbXMgc2hvdWxkIG5vdCBiZSBzZWxlY3RhYmxlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkSW5kZXggPSB0aGlzLmZpbHRlcmVkSXRlbXMuaW5kZXhPZihlLmRldGFpbC5pdGVtKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9fb25DbGVhckJ1dHRvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBuYXRpdmUgZm9jdXNvdXQgZXZlbnRcbiAgICAgIHRoaXMuaW5wdXRFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX29uRm9jdXNvdXQoZXZlbnQpIHtcbiAgICAgIC8vIFZvaWNlT3ZlciBvbiBpT1MgZmlyZXMgYGZvY3Vzb3V0YCBldmVudCB3aGVuIG1vdmluZyBmb2N1cyB0byB0aGUgaXRlbSBpbiB0aGUgZHJvcGRvd24uXG4gICAgICAvLyBEbyBub3QgZm9jdXMgdGhlIGlucHV0IGluIHRoaXMgY2FzZSwgYmVjYXVzZSBpdCB3b3VsZCBicmVhayBhbm5vdW5jZW1lbnQgZm9yIHRoZSBpdGVtLlxuICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZXZlbnQucmVsYXRlZFRhcmdldC5sb2NhbE5hbWUgPT09IGAke3RoaXMuX3RhZ05hbWVQcmVmaXh9LWl0ZW1gKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRml4ZXMgdGhlIHByb2JsZW0gd2l0aCBgZm9jdXNvdXRgIGhhcHBlbmluZyB3aGVuIGNsaWNraW5nIG9uIHRoZSBzY3JvbGwgYmFyIG9uIEVkZ2VcbiAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ID09PSB0aGlzLiQub3ZlcmxheSkge1xuICAgICAgICBldmVudC5jb21wb3NlZFBhdGgoKVswXS5mb2N1cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVhZG9ubHkgJiYgIXRoaXMuX2Nsb3NlT25CbHVySXNQcmV2ZW50ZWQpIHtcbiAgICAgICAgLy8gVXNlcidzIGxvZ2ljIGluIGBjdXN0b20tdmFsdWUtc2V0YCBldmVudCBsaXN0ZW5lciBtaWdodCBjYXVzZSBpbnB1dCB0byBibHVyLFxuICAgICAgICAvLyB3aGljaCB3aWxsIHJlc3VsdCBpbiBhdHRlbXB0aW5nIHRvIGNvbW1pdCB0aGUgc2FtZSBjdXN0b20gdmFsdWUgb25jZSBhZ2Fpbi5cbiAgICAgICAgaWYgKCF0aGlzLm9wZW5lZCAmJiB0aGlzLmFsbG93Q3VzdG9tVmFsdWUgJiYgdGhpcy5faW5wdXRFbGVtZW50VmFsdWUgPT09IHRoaXMuX2xhc3RDdXN0b21WYWx1ZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sYXN0Q3VzdG9tVmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2xvc2VPckNvbW1pdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9vblRvdWNoZW5kKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuY2xlYXJFbGVtZW50IHx8IGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdICE9PSB0aGlzLmNsZWFyRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgdmFsdWUtY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXRhaWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGV0YWlsLnZhbHVlIHRoZSBjb21ib2JveCB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBzZWxlY3RlZCBpdGVtIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgc2VsZWN0ZWQtaXRlbS1jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGV0YWlsLnZhbHVlIHRoZSBzZWxlY3RlZCBpdGVtLiBUeXBlIGlzIHRoZSBzYW1lIGFzIHRoZSB0eXBlIG9mIGBpdGVtc2AuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIHNldHMgYSBjdXN0b20gdmFsdWUuXG4gICAgICogQGV2ZW50IGN1c3RvbS12YWx1ZS1zZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGV0YWlsIHRoZSBjdXN0b20gdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdmFsdWUgY2hhbmdlcy5cbiAgICAgKiBUbyBjb21wbHkgd2l0aCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvY2hhbmdlXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIGB2YWFkaW4tY29tYm8tYm94LW92ZXJsYXlgIG9wZW5zLlxuICAgICAqXG4gICAgICogQGV2ZW50IHZhYWRpbi1jb21iby1ib3gtZHJvcGRvd24tb3BlbmVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBhZnRlciB0aGUgYHZhYWRpbi1jb21iby1ib3gtb3ZlcmxheWAgY2xvc2VzLlxuICAgICAqXG4gICAgICogQGV2ZW50IHZhYWRpbi1jb21iby1ib3gtZHJvcGRvd24tY2xvc2VkXG4gICAgICovXG4gIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js":
/*!************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxOverlay\": () => (/* binding */ ComboBoxOverlay)\n/* harmony export */ });\n/* harmony import */ var _vaadin_overlay_src_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/overlay/src/vaadin-overlay.js */ \"./node_modules/@vaadin/overlay/src/vaadin-overlay.js\");\n/* harmony import */ var _vaadin_overlay_src_vaadin_overlay_position_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/overlay/src/vaadin-overlay-position-mixin.js */ \"./node_modules/@vaadin/overlay/src/vaadin-overlay-position-mixin.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__.registerStyles)('vaadin-combo-box-overlay', _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_2__.css`\n    #overlay {\n      width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));\n    }\n\n    [part='content'] {\n      display: flex;\n      flex-direction: column;\n      height: 100%;\n    }\n  `, {\n  moduleId: 'vaadin-combo-box-overlay-styles'\n});\nlet memoizedTemplate;\n\n/**\n * An element used internally by `<vaadin-combo-box>`. Not intended to be used separately.\n *\n * @extends Overlay\n * @private\n */\nclass ComboBoxOverlay extends (0,_vaadin_overlay_src_vaadin_overlay_position_mixin_js__WEBPACK_IMPORTED_MODULE_1__.PositionMixin)(_vaadin_overlay_src_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_0__.Overlay) {\n  static get is() {\n    return 'vaadin-combo-box-overlay';\n  }\n  static get template() {\n    if (!memoizedTemplate) {\n      memoizedTemplate = super.template.cloneNode(true);\n      memoizedTemplate.content.querySelector('[part~=\"overlay\"]').removeAttribute('tabindex');\n    }\n    return memoizedTemplate;\n  }\n  static get observers() {\n    return ['_setOverlayWidth(positionTarget, opened)'];\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    const comboBox = this._comboBox;\n    const hostDir = comboBox && comboBox.getAttribute('dir');\n    if (hostDir) {\n      this.setAttribute('dir', hostDir);\n    }\n  }\n  ready() {\n    super.ready();\n    const loader = document.createElement('div');\n    loader.setAttribute('part', 'loader');\n    const content = this.shadowRoot.querySelector('[part~=\"content\"]');\n    content.parentNode.insertBefore(loader, content);\n    this.requiredVerticalSpace = 200;\n  }\n  _outsideClickListener(event) {\n    const eventPath = event.composedPath();\n    if (!eventPath.includes(this.positionTarget) && !eventPath.includes(this)) {\n      this.close();\n    }\n  }\n  _setOverlayWidth(positionTarget, opened) {\n    if (positionTarget && opened) {\n      const propPrefix = this.localName;\n      this.style.setProperty(`--_${propPrefix}-default-width`, `${positionTarget.clientWidth}px`);\n      const customWidth = getComputedStyle(this._comboBox).getPropertyValue(`--${propPrefix}-width`);\n      if (customWidth === '') {\n        this.style.removeProperty(`--${propPrefix}-width`);\n      } else {\n        this.style.setProperty(`--${propPrefix}-width`, customWidth);\n      }\n      this._updatePosition();\n    }\n  }\n}\ncustomElements.define(ComboBoxOverlay.is, ComboBoxOverlay);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtb3ZlcmxheS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbWJvLWJveC9zcmMvdmFhZGluLWNvbWJvLWJveC1vdmVybGF5LmpzPzMzZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBPdmVybGF5IH0gZnJvbSAnQHZhYWRpbi9vdmVybGF5L3NyYy92YWFkaW4tb3ZlcmxheS5qcyc7XG5pbXBvcnQgeyBQb3NpdGlvbk1peGluIH0gZnJvbSAnQHZhYWRpbi9vdmVybGF5L3NyYy92YWFkaW4tb3ZlcmxheS1wb3NpdGlvbi1taXhpbi5qcyc7XG5pbXBvcnQgeyBjc3MsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxucmVnaXN0ZXJTdHlsZXMoXG4gICd2YWFkaW4tY29tYm8tYm94LW92ZXJsYXknLFxuICBjc3NgXG4gICAgI292ZXJsYXkge1xuICAgICAgd2lkdGg6IHZhcigtLXZhYWRpbi1jb21iby1ib3gtb3ZlcmxheS13aWR0aCwgdmFyKC0tX3ZhYWRpbi1jb21iby1ib3gtb3ZlcmxheS1kZWZhdWx0LXdpZHRoLCBhdXRvKSk7XG4gICAgfVxuXG4gICAgW3BhcnQ9J2NvbnRlbnQnXSB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG4gIGAsXG4gIHsgbW9kdWxlSWQ6ICd2YWFkaW4tY29tYm8tYm94LW92ZXJsYXktc3R5bGVzJyB9LFxuKTtcblxubGV0IG1lbW9pemVkVGVtcGxhdGU7XG5cbi8qKlxuICogQW4gZWxlbWVudCB1c2VkIGludGVybmFsbHkgYnkgYDx2YWFkaW4tY29tYm8tYm94PmAuIE5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIHNlcGFyYXRlbHkuXG4gKlxuICogQGV4dGVuZHMgT3ZlcmxheVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbWJvQm94T3ZlcmxheSBleHRlbmRzIFBvc2l0aW9uTWl4aW4oT3ZlcmxheSkge1xuICBzdGF0aWMgZ2V0IGlzKCkge1xuICAgIHJldHVybiAndmFhZGluLWNvbWJvLWJveC1vdmVybGF5JztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgaWYgKCFtZW1vaXplZFRlbXBsYXRlKSB7XG4gICAgICBtZW1vaXplZFRlbXBsYXRlID0gc3VwZXIudGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgbWVtb2l6ZWRUZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ1twYXJ0fj1cIm92ZXJsYXlcIl0nKS5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9pemVkVGVtcGxhdGU7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICByZXR1cm4gWydfc2V0T3ZlcmxheVdpZHRoKHBvc2l0aW9uVGFyZ2V0LCBvcGVuZWQpJ107XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgY29uc3QgY29tYm9Cb3ggPSB0aGlzLl9jb21ib0JveDtcblxuICAgIGNvbnN0IGhvc3REaXIgPSBjb21ib0JveCAmJiBjb21ib0JveC5nZXRBdHRyaWJ1dGUoJ2RpcicpO1xuICAgIGlmIChob3N0RGlyKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlyJywgaG9zdERpcik7XG4gICAgfVxuICB9XG5cbiAgcmVhZHkoKSB7XG4gICAgc3VwZXIucmVhZHkoKTtcbiAgICBjb25zdCBsb2FkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsb2FkZXIuc2V0QXR0cmlidXRlKCdwYXJ0JywgJ2xvYWRlcicpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignW3BhcnR+PVwiY29udGVudFwiXScpO1xuICAgIGNvbnRlbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobG9hZGVyLCBjb250ZW50KTtcbiAgICB0aGlzLnJlcXVpcmVkVmVydGljYWxTcGFjZSA9IDIwMDtcbiAgfVxuXG4gIF9vdXRzaWRlQ2xpY2tMaXN0ZW5lcihldmVudCkge1xuICAgIGNvbnN0IGV2ZW50UGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgIGlmICghZXZlbnRQYXRoLmluY2x1ZGVzKHRoaXMucG9zaXRpb25UYXJnZXQpICYmICFldmVudFBhdGguaW5jbHVkZXModGhpcykpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBfc2V0T3ZlcmxheVdpZHRoKHBvc2l0aW9uVGFyZ2V0LCBvcGVuZWQpIHtcbiAgICBpZiAocG9zaXRpb25UYXJnZXQgJiYgb3BlbmVkKSB7XG4gICAgICBjb25zdCBwcm9wUHJlZml4ID0gdGhpcy5sb2NhbE5hbWU7XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KGAtLV8ke3Byb3BQcmVmaXh9LWRlZmF1bHQtd2lkdGhgLCBgJHtwb3NpdGlvblRhcmdldC5jbGllbnRXaWR0aH1weGApO1xuXG4gICAgICBjb25zdCBjdXN0b21XaWR0aCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fY29tYm9Cb3gpLmdldFByb3BlcnR5VmFsdWUoYC0tJHtwcm9wUHJlZml4fS13aWR0aGApO1xuXG4gICAgICBpZiAoY3VzdG9tV2lkdGggPT09ICcnKSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoYC0tJHtwcm9wUHJlZml4fS13aWR0aGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShgLS0ke3Byb3BQcmVmaXh9LXdpZHRoYCwgY3VzdG9tV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoQ29tYm9Cb3hPdmVybGF5LmlzLCBDb21ib0JveE92ZXJsYXkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxPlaceholder\": () => (/* binding */ ComboBoxPlaceholder)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/*\n * Placeholder object class representing items being loaded.\n *\n * @private\n */\nconst ComboBoxPlaceholder = class ComboBoxPlaceholder {\n  toString() {\n    return '';\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtcGxhY2Vob2xkZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L3NyYy92YWFkaW4tY29tYm8tYm94LXBsYWNlaG9sZGVyLmpzPzg2NGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbi8qXG4gKiBQbGFjZWhvbGRlciBvYmplY3QgY2xhc3MgcmVwcmVzZW50aW5nIGl0ZW1zIGJlaW5nIGxvYWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgQ29tYm9Cb3hQbGFjZWhvbGRlciA9IGNsYXNzIENvbWJvQm94UGxhY2Vob2xkZXIge1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComboBoxScroller\": () => (/* binding */ ComboBoxScroller)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@vaadin/combo-box/node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_component_base_src_unique_id_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/component-base/src/unique-id-utils.js */ \"./node_modules/@vaadin/component-base/src/unique-id-utils.js\");\n/* harmony import */ var _vaadin_component_base_src_virtualizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/component-base/src/virtualizer.js */ \"./node_modules/@vaadin/component-base/src/virtualizer.js\");\n/* harmony import */ var _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vaadin-combo-box-placeholder.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-placeholder.js\");\n/**\n * @license\n * Copyright (c) 2015 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n/**\n * Element for internal use only.\n *\n * @extends HTMLElement\n * @private\n */\nclass ComboBoxScroller extends _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.PolymerElement {\n  static get is() {\n    return 'vaadin-combo-box-scroller';\n  }\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_0__.html`\n      <style>\n        :host {\n          display: block;\n          min-height: 1px;\n          overflow: auto;\n\n          /* Fixes item background from getting on top of scrollbars on Safari */\n          transform: translate3d(0, 0, 0);\n\n          /* Enable momentum scrolling on iOS */\n          -webkit-overflow-scrolling: touch;\n\n          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */\n          box-shadow: 0 0 0 white;\n        }\n\n        #selector {\n          border-width: var(--_vaadin-combo-box-items-container-border-width);\n          border-style: var(--_vaadin-combo-box-items-container-border-style);\n          border-color: var(--_vaadin-combo-box-items-container-border-color);\n        }\n      </style>\n      <div id=\"selector\">\n        <slot></slot>\n      </div>\n    `;\n  }\n  static get properties() {\n    return {\n      /**\n       * A full set of items to filter the visible options from.\n       * Set to an empty array when combo-box is not opened.\n       */\n      items: {\n        type: Array,\n        observer: '__itemsChanged'\n      },\n      /**\n       * Index of an item that has focus outline and is scrolled into view.\n       * The actual focus still remains in the input field.\n       */\n      focusedIndex: {\n        type: Number,\n        observer: '__focusedIndexChanged'\n      },\n      /**\n       * Set to true while combo-box fetches new page from the data provider.\n       */\n      loading: {\n        type: Boolean,\n        observer: '__loadingChanged'\n      },\n      /**\n       * Whether the combo-box is currently opened or not. If set to false,\n       * calling `scrollIntoView` does not have any effect.\n       */\n      opened: {\n        type: Boolean,\n        observer: '__openedChanged'\n      },\n      /**\n       * The selected item from the `items` array.\n       */\n      selectedItem: {\n        type: Object,\n        observer: '__selectedItemChanged'\n      },\n      /**\n       * Path for the id of the item, used to detect whether the item is selected.\n       */\n      itemIdPath: {\n        type: String\n      },\n      /**\n       * Reference to the combo-box, used by the item elements.\n       */\n      comboBox: {\n        type: Object\n      },\n      /**\n       * Function used to set a label for every combo-box item.\n       */\n      getItemLabel: {\n        type: Object\n      },\n      /**\n       * Function used to render the content of every combo-box item.\n       */\n      renderer: {\n        type: Object,\n        observer: '__rendererChanged'\n      },\n      /**\n       * Used to propagate the `theme` attribute from the host element.\n       */\n      theme: {\n        type: String\n      }\n    };\n  }\n  constructor() {\n    super();\n    this.__boundOnItemClick = this.__onItemClick.bind(this);\n  }\n  __openedChanged(opened) {\n    if (opened) {\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n\n    // Ensure every instance has unique ID\n    this.id = `${this.localName}-${(0,_vaadin_component_base_src_unique_id_utils_js__WEBPACK_IMPORTED_MODULE_1__.generateUniqueId)()}`;\n\n    // Allow extensions to customize tag name for the items\n    this.__hostTagName = this.constructor.is.replace('-scroller', '');\n    this.setAttribute('role', 'listbox');\n    this.addEventListener('click', e => e.stopPropagation());\n    this.__patchWheelOverScrolling();\n    this.__virtualizer = new _vaadin_component_base_src_virtualizer_js__WEBPACK_IMPORTED_MODULE_2__.Virtualizer({\n      createElements: this.__createElements.bind(this),\n      updateElement: this.__updateElement.bind(this),\n      elementsContainer: this,\n      scrollTarget: this,\n      scrollContainer: this.$.selector\n    });\n  }\n  requestContentUpdate() {\n    if (this.__virtualizer) {\n      this.__virtualizer.update();\n    }\n  }\n  scrollIntoView(index) {\n    if (!(this.opened && index >= 0)) {\n      return;\n    }\n    const visibleItemsCount = this._visibleItemsCount();\n    let targetIndex = index;\n    if (index > this.__virtualizer.lastVisibleIndex - 1) {\n      // Index is below the bottom, scrolling down. Make the item appear at the bottom.\n      // First scroll to target (will be at the top of the scroller) to make sure it's rendered.\n      this.__virtualizer.scrollToIndex(index);\n      // Then calculate the index for the following scroll (to get the target to bottom of the scroller).\n      targetIndex = index - visibleItemsCount + 1;\n    } else if (index > this.__virtualizer.firstVisibleIndex) {\n      // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set\n      // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.\n      targetIndex = this.__virtualizer.firstVisibleIndex;\n    }\n    this.__virtualizer.scrollToIndex(Math.max(0, targetIndex));\n\n    // Sometimes the item is partly below the bottom edge, detect and adjust.\n    const lastPhysicalItem = [...this.children].find(el => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex);\n    if (!lastPhysicalItem || index !== lastPhysicalItem.index) {\n      return;\n    }\n    const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();\n    const scrollerRect = this.getBoundingClientRect();\n    const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;\n    if (scrollTopAdjust > 0) {\n      this.scrollTop += scrollTopAdjust;\n    }\n  }\n\n  /** @private */\n  __getAriaRole(itemIndex) {\n    return itemIndex !== undefined ? 'option' : false;\n  }\n\n  /** @private */\n  __isItemFocused(focusedIndex, itemIndex) {\n    return !this.loading && focusedIndex === itemIndex;\n  }\n\n  /** @protected */\n  _isItemSelected(item, selectedItem, itemIdPath) {\n    if (item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_3__.ComboBoxPlaceholder) {\n      return false;\n    } else if (itemIdPath && item !== undefined && selectedItem !== undefined) {\n      return this.get(itemIdPath, item) === this.get(itemIdPath, selectedItem);\n    }\n    return item === selectedItem;\n  }\n\n  /** @private */\n  __itemsChanged(items) {\n    if (this.__virtualizer && items) {\n      this.__virtualizer.size = items.length;\n      this.__virtualizer.flush();\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @private */\n  __loadingChanged() {\n    this.requestContentUpdate();\n  }\n\n  /** @private */\n  __selectedItemChanged() {\n    this.requestContentUpdate();\n  }\n\n  /** @private */\n  __focusedIndexChanged(index, oldIndex) {\n    if (index !== oldIndex) {\n      this.requestContentUpdate();\n    }\n\n    // Do not jump back to the previously focused item while loading\n    // when requesting next page from the data provider on scroll.\n    if (index >= 0 && !this.loading) {\n      this.scrollIntoView(index);\n    }\n  }\n\n  /** @private */\n  __rendererChanged(renderer, oldRenderer) {\n    if (renderer || oldRenderer) {\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @private */\n  __createElements(count) {\n    return [...Array(count)].map(() => {\n      const item = document.createElement(`${this.__hostTagName}-item`);\n      item.addEventListener('click', this.__boundOnItemClick);\n      // Negative tabindex prevents the item content from being focused.\n      item.tabIndex = '-1';\n      item.style.width = '100%';\n      return item;\n    });\n  }\n\n  /** @private */\n  __updateElement(el, index) {\n    const item = this.items[index];\n    const focusedIndex = this.focusedIndex;\n    const selected = this._isItemSelected(item, this.selectedItem, this.itemIdPath);\n    el.setProperties({\n      item,\n      index,\n      label: this.getItemLabel(item),\n      selected,\n      renderer: this.renderer,\n      focused: this.__isItemFocused(focusedIndex, index)\n    });\n    el.id = `${this.__hostTagName}-item-${index}`;\n    el.setAttribute('role', this.__getAriaRole(index));\n    el.setAttribute('aria-selected', selected.toString());\n    el.setAttribute('aria-posinset', index + 1);\n    el.setAttribute('aria-setsize', this.items.length);\n    if (this.theme) {\n      el.setAttribute('theme', this.theme);\n    } else {\n      el.removeAttribute('theme');\n    }\n    if (item instanceof _vaadin_combo_box_placeholder_js__WEBPACK_IMPORTED_MODULE_3__.ComboBoxPlaceholder) {\n      this.__requestItemByIndex(index);\n    }\n  }\n\n  /** @private */\n  __onItemClick(e) {\n    this.dispatchEvent(new CustomEvent('selection-changed', {\n      detail: {\n        item: e.currentTarget.item\n      }\n    }));\n  }\n\n  /**\n   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.\n   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow\n   * scrolling the parent similarly to touch scrolling.\n   */\n  __patchWheelOverScrolling() {\n    this.$.selector.addEventListener('wheel', e => {\n      const scrolledToTop = this.scrollTop === 0;\n      const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;\n      if (scrolledToTop && e.deltaY < 0) {\n        e.preventDefault();\n      } else if (scrolledToBottom && e.deltaY > 0) {\n        e.preventDefault();\n      }\n    });\n  }\n  get _viewportTotalPaddingBottom() {\n    if (this._cachedViewportTotalPaddingBottom === undefined) {\n      const itemsStyle = window.getComputedStyle(this.$.selector);\n      this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth].map(v => {\n        return parseInt(v, 10);\n      }).reduce((sum, v) => {\n        return sum + v;\n      });\n    }\n    return this._cachedViewportTotalPaddingBottom;\n  }\n\n  /**\n   * Dispatches an `index-requested` event for the given index to notify\n   * the data provider that it should start loading the page containing the requested index.\n   *\n   * The event is dispatched asynchronously to prevent an immediate page request and therefore\n   * a possible infinite recursion in case the data provider implements page request cancelation logic\n   * by invoking data provider page callbacks with an empty array.\n   * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array\n   * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,\n   * the scroller will synchronously request the page again which may lead to looping in the end.\n   * That was the case for the Flow counterpart:\n   * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828\n   */\n  __requestItemByIndex(index) {\n    requestAnimationFrame(() => {\n      this.dispatchEvent(new CustomEvent('index-requested', {\n        detail: {\n          index,\n          currentScrollerPos: this._oldScrollerPosition\n        }\n      }));\n    });\n  }\n\n  /** @private */\n  _visibleItemsCount() {\n    // Ensure items are positioned\n    this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);\n    const hasItems = this.__virtualizer.size > 0;\n    return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;\n  }\n}\ncustomElements.define(ComboBoxScroller.is, ComboBoxScroller);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvc3JjL3ZhYWRpbi1jb21iby1ib3gtc2Nyb2xsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L3NyYy92YWFkaW4tY29tYm8tYm94LXNjcm9sbGVyLmpzPzhjZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBodG1sLCBQb2x5bWVyRWxlbWVudCB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGdlbmVyYXRlVW5pcXVlSWQgfSBmcm9tICdAdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy91bmlxdWUtaWQtdXRpbHMuanMnO1xuaW1wb3J0IHsgVmlydHVhbGl6ZXIgfSBmcm9tICdAdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy92aXJ0dWFsaXplci5qcyc7XG5pbXBvcnQgeyBDb21ib0JveFBsYWNlaG9sZGVyIH0gZnJvbSAnLi92YWFkaW4tY29tYm8tYm94LXBsYWNlaG9sZGVyLmpzJztcblxuLyoqXG4gKiBFbGVtZW50IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbWJvQm94U2Nyb2xsZXIgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgaXMoKSB7XG4gICAgcmV0dXJuICd2YWFkaW4tY29tYm8tYm94LXNjcm9sbGVyJztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICBtaW4taGVpZ2h0OiAxcHg7XG4gICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG5cbiAgICAgICAgICAvKiBGaXhlcyBpdGVtIGJhY2tncm91bmQgZnJvbSBnZXR0aW5nIG9uIHRvcCBvZiBzY3JvbGxiYXJzIG9uIFNhZmFyaSAqL1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG5cbiAgICAgICAgICAvKiBFbmFibGUgbW9tZW50dW0gc2Nyb2xsaW5nIG9uIGlPUyAqL1xuICAgICAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcblxuICAgICAgICAgIC8qIEZpeGVzIHNjcm9sbGJhciBkaXNhcHBlYXJpbmcgd2hlbiAnU2hvdyBzY3JvbGwgYmFyczogQWx3YXlzJyBlbmFibGVkIGluIFNhZmFyaSAqL1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIHdoaXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgI3NlbGVjdG9yIHtcbiAgICAgICAgICBib3JkZXItd2lkdGg6IHZhcigtLV92YWFkaW4tY29tYm8tYm94LWl0ZW1zLWNvbnRhaW5lci1ib3JkZXItd2lkdGgpO1xuICAgICAgICAgIGJvcmRlci1zdHlsZTogdmFyKC0tX3ZhYWRpbi1jb21iby1ib3gtaXRlbXMtY29udGFpbmVyLWJvcmRlci1zdHlsZSk7XG4gICAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1fdmFhZGluLWNvbWJvLWJveC1pdGVtcy1jb250YWluZXItYm9yZGVyLWNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxkaXYgaWQ9XCJzZWxlY3RvclwiPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEEgZnVsbCBzZXQgb2YgaXRlbXMgdG8gZmlsdGVyIHRoZSB2aXNpYmxlIG9wdGlvbnMgZnJvbS5cbiAgICAgICAqIFNldCB0byBhbiBlbXB0eSBhcnJheSB3aGVuIGNvbWJvLWJveCBpcyBub3Qgb3BlbmVkLlxuICAgICAgICovXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2l0ZW1zQ2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEluZGV4IG9mIGFuIGl0ZW0gdGhhdCBoYXMgZm9jdXMgb3V0bGluZSBhbmQgaXMgc2Nyb2xsZWQgaW50byB2aWV3LlxuICAgICAgICogVGhlIGFjdHVhbCBmb2N1cyBzdGlsbCByZW1haW5zIGluIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgICAqL1xuICAgICAgZm9jdXNlZEluZGV4OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2ZvY3VzZWRJbmRleENoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdG8gdHJ1ZSB3aGlsZSBjb21iby1ib3ggZmV0Y2hlcyBuZXcgcGFnZSBmcm9tIHRoZSBkYXRhIHByb3ZpZGVyLlxuICAgICAgICovXG4gICAgICBsb2FkaW5nOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX19sb2FkaW5nQ2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdGhlIGNvbWJvLWJveCBpcyBjdXJyZW50bHkgb3BlbmVkIG9yIG5vdC4gSWYgc2V0IHRvIGZhbHNlLFxuICAgICAgICogY2FsbGluZyBgc2Nyb2xsSW50b1ZpZXdgIGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdC5cbiAgICAgICAqL1xuICAgICAgb3BlbmVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX19vcGVuZWRDaGFuZ2VkJyxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHNlbGVjdGVkIGl0ZW0gZnJvbSB0aGUgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAqL1xuICAgICAgc2VsZWN0ZWRJdGVtOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX3NlbGVjdGVkSXRlbUNoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQYXRoIGZvciB0aGUgaWQgb2YgdGhlIGl0ZW0sIHVzZWQgdG8gZGV0ZWN0IHdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgKi9cbiAgICAgIGl0ZW1JZFBhdGg6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvbWJvLWJveCwgdXNlZCBieSB0aGUgaXRlbSBlbGVtZW50cy5cbiAgICAgICAqL1xuICAgICAgY29tYm9Cb3g6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHNldCBhIGxhYmVsIGZvciBldmVyeSBjb21iby1ib3ggaXRlbS5cbiAgICAgICAqL1xuICAgICAgZ2V0SXRlbUxhYmVsOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRnVuY3Rpb24gdXNlZCB0byByZW5kZXIgdGhlIGNvbnRlbnQgb2YgZXZlcnkgY29tYm8tYm94IGl0ZW0uXG4gICAgICAgKi9cbiAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX3JlbmRlcmVyQ2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgIGF0dHJpYnV0ZSBmcm9tIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIHRoZW1lOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX2JvdW5kT25JdGVtQ2xpY2sgPSB0aGlzLl9fb25JdGVtQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9fb3BlbmVkQ2hhbmdlZChvcGVuZWQpIHtcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgcmVhZHkoKSB7XG4gICAgc3VwZXIucmVhZHkoKTtcblxuICAgIC8vIEVuc3VyZSBldmVyeSBpbnN0YW5jZSBoYXMgdW5pcXVlIElEXG4gICAgdGhpcy5pZCA9IGAke3RoaXMubG9jYWxOYW1lfS0ke2dlbmVyYXRlVW5pcXVlSWQoKX1gO1xuXG4gICAgLy8gQWxsb3cgZXh0ZW5zaW9ucyB0byBjdXN0b21pemUgdGFnIG5hbWUgZm9yIHRoZSBpdGVtc1xuICAgIHRoaXMuX19ob3N0VGFnTmFtZSA9IHRoaXMuY29uc3RydWN0b3IuaXMucmVwbGFjZSgnLXNjcm9sbGVyJywgJycpO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbGlzdGJveCcpO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpKTtcblxuICAgIHRoaXMuX19wYXRjaFdoZWVsT3ZlclNjcm9sbGluZygpO1xuXG4gICAgdGhpcy5fX3ZpcnR1YWxpemVyID0gbmV3IFZpcnR1YWxpemVyKHtcbiAgICAgIGNyZWF0ZUVsZW1lbnRzOiB0aGlzLl9fY3JlYXRlRWxlbWVudHMuYmluZCh0aGlzKSxcbiAgICAgIHVwZGF0ZUVsZW1lbnQ6IHRoaXMuX191cGRhdGVFbGVtZW50LmJpbmQodGhpcyksXG4gICAgICBlbGVtZW50c0NvbnRhaW5lcjogdGhpcyxcbiAgICAgIHNjcm9sbFRhcmdldDogdGhpcyxcbiAgICAgIHNjcm9sbENvbnRhaW5lcjogdGhpcy4kLnNlbGVjdG9yLFxuICAgIH0pO1xuICB9XG5cbiAgcmVxdWVzdENvbnRlbnRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX192aXJ0dWFsaXplcikge1xuICAgICAgdGhpcy5fX3ZpcnR1YWxpemVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHNjcm9sbEludG9WaWV3KGluZGV4KSB7XG4gICAgaWYgKCEodGhpcy5vcGVuZWQgJiYgaW5kZXggPj0gMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB2aXNpYmxlSXRlbXNDb3VudCA9IHRoaXMuX3Zpc2libGVJdGVtc0NvdW50KCk7XG5cbiAgICBsZXQgdGFyZ2V0SW5kZXggPSBpbmRleDtcblxuICAgIGlmIChpbmRleCA+IHRoaXMuX192aXJ0dWFsaXplci5sYXN0VmlzaWJsZUluZGV4IC0gMSkge1xuICAgICAgLy8gSW5kZXggaXMgYmVsb3cgdGhlIGJvdHRvbSwgc2Nyb2xsaW5nIGRvd24uIE1ha2UgdGhlIGl0ZW0gYXBwZWFyIGF0IHRoZSBib3R0b20uXG4gICAgICAvLyBGaXJzdCBzY3JvbGwgdG8gdGFyZ2V0ICh3aWxsIGJlIGF0IHRoZSB0b3Agb2YgdGhlIHNjcm9sbGVyKSB0byBtYWtlIHN1cmUgaXQncyByZW5kZXJlZC5cbiAgICAgIHRoaXMuX192aXJ0dWFsaXplci5zY3JvbGxUb0luZGV4KGluZGV4KTtcbiAgICAgIC8vIFRoZW4gY2FsY3VsYXRlIHRoZSBpbmRleCBmb3IgdGhlIGZvbGxvd2luZyBzY3JvbGwgKHRvIGdldCB0aGUgdGFyZ2V0IHRvIGJvdHRvbSBvZiB0aGUgc2Nyb2xsZXIpLlxuICAgICAgdGFyZ2V0SW5kZXggPSBpbmRleCAtIHZpc2libGVJdGVtc0NvdW50ICsgMTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID4gdGhpcy5fX3ZpcnR1YWxpemVyLmZpcnN0VmlzaWJsZUluZGV4KSB7XG4gICAgICAvLyBUaGUgaXRlbSBpcyBhbHJlYWR5IHZpc2libGUsIHNjcm9sbGluZyBpcyB1bm5lY2Vzc2FyeSBwZXIgc2UuIEJ1dCB3ZSBuZWVkIHRvIHRyaWdnZXIgaXJvbi1saXN0IHRvIHNldFxuICAgICAgLy8gdGhlIGNvcnJlY3Qgc2Nyb2xsVG9wIG9uIHRoZSBzY3JvbGxUYXJnZXQuIFNjcm9sbGluZyB0byBmaXJzdFZpc2libGVJbmRleC5cbiAgICAgIHRhcmdldEluZGV4ID0gdGhpcy5fX3ZpcnR1YWxpemVyLmZpcnN0VmlzaWJsZUluZGV4O1xuICAgIH1cbiAgICB0aGlzLl9fdmlydHVhbGl6ZXIuc2Nyb2xsVG9JbmRleChNYXRoLm1heCgwLCB0YXJnZXRJbmRleCkpO1xuXG4gICAgLy8gU29tZXRpbWVzIHRoZSBpdGVtIGlzIHBhcnRseSBiZWxvdyB0aGUgYm90dG9tIGVkZ2UsIGRldGVjdCBhbmQgYWRqdXN0LlxuICAgIGNvbnN0IGxhc3RQaHlzaWNhbEl0ZW0gPSBbLi4udGhpcy5jaGlsZHJlbl0uZmluZChcbiAgICAgIChlbCkgPT4gIWVsLmhpZGRlbiAmJiBlbC5pbmRleCA9PT0gdGhpcy5fX3ZpcnR1YWxpemVyLmxhc3RWaXNpYmxlSW5kZXgsXG4gICAgKTtcbiAgICBpZiAoIWxhc3RQaHlzaWNhbEl0ZW0gfHwgaW5kZXggIT09IGxhc3RQaHlzaWNhbEl0ZW0uaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdFBoeXNpY2FsSXRlbVJlY3QgPSBsYXN0UGh5c2ljYWxJdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNjcm9sbGVyUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc2Nyb2xsVG9wQWRqdXN0ID0gbGFzdFBoeXNpY2FsSXRlbVJlY3QuYm90dG9tIC0gc2Nyb2xsZXJSZWN0LmJvdHRvbSArIHRoaXMuX3ZpZXdwb3J0VG90YWxQYWRkaW5nQm90dG9tO1xuICAgIGlmIChzY3JvbGxUb3BBZGp1c3QgPiAwKSB7XG4gICAgICB0aGlzLnNjcm9sbFRvcCArPSBzY3JvbGxUb3BBZGp1c3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fZ2V0QXJpYVJvbGUoaXRlbUluZGV4KSB7XG4gICAgcmV0dXJuIGl0ZW1JbmRleCAhPT0gdW5kZWZpbmVkID8gJ29wdGlvbicgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX2lzSXRlbUZvY3VzZWQoZm9jdXNlZEluZGV4LCBpdGVtSW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMubG9hZGluZyAmJiBmb2N1c2VkSW5kZXggPT09IGl0ZW1JbmRleDtcbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIF9pc0l0ZW1TZWxlY3RlZChpdGVtLCBzZWxlY3RlZEl0ZW0sIGl0ZW1JZFBhdGgpIHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbWJvQm94UGxhY2Vob2xkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGl0ZW1JZFBhdGggJiYgaXRlbSAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGVkSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoaXRlbUlkUGF0aCwgaXRlbSkgPT09IHRoaXMuZ2V0KGl0ZW1JZFBhdGgsIHNlbGVjdGVkSXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtID09PSBzZWxlY3RlZEl0ZW07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19pdGVtc0NoYW5nZWQoaXRlbXMpIHtcbiAgICBpZiAodGhpcy5fX3ZpcnR1YWxpemVyICYmIGl0ZW1zKSB7XG4gICAgICB0aGlzLl9fdmlydHVhbGl6ZXIuc2l6ZSA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgIHRoaXMuX192aXJ0dWFsaXplci5mbHVzaCgpO1xuICAgICAgdGhpcy5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX2xvYWRpbmdDaGFuZ2VkKCkge1xuICAgIHRoaXMucmVxdWVzdENvbnRlbnRVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX3NlbGVjdGVkSXRlbUNoYW5nZWQoKSB7XG4gICAgdGhpcy5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fZm9jdXNlZEluZGV4Q2hhbmdlZChpbmRleCwgb2xkSW5kZXgpIHtcbiAgICBpZiAoaW5kZXggIT09IG9sZEluZGV4KSB7XG4gICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGp1bXAgYmFjayB0byB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGl0ZW0gd2hpbGUgbG9hZGluZ1xuICAgIC8vIHdoZW4gcmVxdWVzdGluZyBuZXh0IHBhZ2UgZnJvbSB0aGUgZGF0YSBwcm92aWRlciBvbiBzY3JvbGwuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgIXRoaXMubG9hZGluZykge1xuICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fcmVuZGVyZXJDaGFuZ2VkKHJlbmRlcmVyLCBvbGRSZW5kZXJlcikge1xuICAgIGlmIChyZW5kZXJlciB8fCBvbGRSZW5kZXJlcikge1xuICAgICAgdGhpcy5yZXF1ZXN0Q29udGVudFVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX2NyZWF0ZUVsZW1lbnRzKGNvdW50KSB7XG4gICAgcmV0dXJuIFsuLi5BcnJheShjb3VudCldLm1hcCgoKSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChgJHt0aGlzLl9faG9zdFRhZ05hbWV9LWl0ZW1gKTtcbiAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9fYm91bmRPbkl0ZW1DbGljayk7XG4gICAgICAvLyBOZWdhdGl2ZSB0YWJpbmRleCBwcmV2ZW50cyB0aGUgaXRlbSBjb250ZW50IGZyb20gYmVpbmcgZm9jdXNlZC5cbiAgICAgIGl0ZW0udGFiSW5kZXggPSAnLTEnO1xuICAgICAgaXRlbS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fdXBkYXRlRWxlbWVudChlbCwgaW5kZXgpIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgY29uc3QgZm9jdXNlZEluZGV4ID0gdGhpcy5mb2N1c2VkSW5kZXg7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLl9pc0l0ZW1TZWxlY3RlZChpdGVtLCB0aGlzLnNlbGVjdGVkSXRlbSwgdGhpcy5pdGVtSWRQYXRoKTtcblxuICAgIGVsLnNldFByb3BlcnRpZXMoe1xuICAgICAgaXRlbSxcbiAgICAgIGluZGV4LFxuICAgICAgbGFiZWw6IHRoaXMuZ2V0SXRlbUxhYmVsKGl0ZW0pLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICByZW5kZXJlcjogdGhpcy5yZW5kZXJlcixcbiAgICAgIGZvY3VzZWQ6IHRoaXMuX19pc0l0ZW1Gb2N1c2VkKGZvY3VzZWRJbmRleCwgaW5kZXgpLFxuICAgIH0pO1xuXG4gICAgZWwuaWQgPSBgJHt0aGlzLl9faG9zdFRhZ05hbWV9LWl0ZW0tJHtpbmRleH1gO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsIHRoaXMuX19nZXRBcmlhUm9sZShpbmRleCkpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHNlbGVjdGVkLnRvU3RyaW5nKCkpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1wb3NpbnNldCcsIGluZGV4ICsgMSk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLXNldHNpemUnLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG5cbiAgICBpZiAodGhpcy50aGVtZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aGVtZScsIHRoaXMudGhlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3RoZW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDb21ib0JveFBsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLl9fcmVxdWVzdEl0ZW1CeUluZGV4KGluZGV4KTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19vbkl0ZW1DbGljayhlKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc2VsZWN0aW9uLWNoYW5nZWQnLCB7IGRldGFpbDogeyBpdGVtOiBlLmN1cnJlbnRUYXJnZXQuaXRlbSB9IH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIHByZXZlbnQgdGhlIGtpbmV0aWMgc2Nyb2xsaW5nIGVuZXJneSBmcm9tIGJlaW5nIHRyYW5zZmVycmVkIGZyb20gdGhlIG92ZXJsYXkgY29udGVudHMgb3ZlciB0byB0aGUgcGFyZW50LlxuICAgKiBGdXJ0aGVyIGltcHJvdmVtZW50IGlkZWFzOiBhZnRlciB0aGUgY29udGVudHMgaGF2ZSBiZWVuIHNjcm9sbGVkIHRvIHRoZSB0b3Agb3IgYm90dG9tIGFuZCBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIGl0IGNvdWxkIGFsbG93XG4gICAqIHNjcm9sbGluZyB0aGUgcGFyZW50IHNpbWlsYXJseSB0byB0b3VjaCBzY3JvbGxpbmcuXG4gICAqL1xuICBfX3BhdGNoV2hlZWxPdmVyU2Nyb2xsaW5nKCkge1xuICAgIHRoaXMuJC5zZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxlZFRvVG9wID0gdGhpcy5zY3JvbGxUb3AgPT09IDA7XG4gICAgICBjb25zdCBzY3JvbGxlZFRvQm90dG9tID0gdGhpcy5zY3JvbGxIZWlnaHQgLSB0aGlzLnNjcm9sbFRvcCAtIHRoaXMuY2xpZW50SGVpZ2h0IDw9IDE7XG4gICAgICBpZiAoc2Nyb2xsZWRUb1RvcCAmJiBlLmRlbHRhWSA8IDApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxlZFRvQm90dG9tICYmIGUuZGVsdGFZID4gMCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX3ZpZXdwb3J0VG90YWxQYWRkaW5nQm90dG9tKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRWaWV3cG9ydFRvdGFsUGFkZGluZ0JvdHRvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpdGVtc1N0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kLnNlbGVjdG9yKTtcbiAgICAgIHRoaXMuX2NhY2hlZFZpZXdwb3J0VG90YWxQYWRkaW5nQm90dG9tID0gW2l0ZW1zU3R5bGUucGFkZGluZ0JvdHRvbSwgaXRlbXNTdHlsZS5ib3JkZXJCb3R0b21XaWR0aF1cbiAgICAgICAgLm1hcCgodikgPT4ge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludCh2LCAxMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgdikgPT4ge1xuICAgICAgICAgIHJldHVybiBzdW0gKyB2O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkVmlld3BvcnRUb3RhbFBhZGRpbmdCb3R0b207XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBgaW5kZXgtcmVxdWVzdGVkYCBldmVudCBmb3IgdGhlIGdpdmVuIGluZGV4IHRvIG5vdGlmeVxuICAgKiB0aGUgZGF0YSBwcm92aWRlciB0aGF0IGl0IHNob3VsZCBzdGFydCBsb2FkaW5nIHRoZSBwYWdlIGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBpbmRleC5cbiAgICpcbiAgICogVGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQgYXN5bmNocm9ub3VzbHkgdG8gcHJldmVudCBhbiBpbW1lZGlhdGUgcGFnZSByZXF1ZXN0IGFuZCB0aGVyZWZvcmVcbiAgICogYSBwb3NzaWJsZSBpbmZpbml0ZSByZWN1cnNpb24gaW4gY2FzZSB0aGUgZGF0YSBwcm92aWRlciBpbXBsZW1lbnRzIHBhZ2UgcmVxdWVzdCBjYW5jZWxhdGlvbiBsb2dpY1xuICAgKiBieSBpbnZva2luZyBkYXRhIHByb3ZpZGVyIHBhZ2UgY2FsbGJhY2tzIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAqIFRoZSBpbmZpbml0ZSByZWN1cnNpb24gbWF5IG9jY3VyIG90aGVyd2lzZSBzaW5jZSBpbnZva2luZyBhIGRhdGEgcHJvdmlkZXIgcGFnZSBjYWxsYmFjayB3aXRoIGFuIGVtcHR5IGFycmF5XG4gICAqIHRyaWdnZXJzIGEgc3luY2hyb25vdXMgc2Nyb2xsZXIgdXBkYXRlIGFuZCwgaWYgdGhlIGNhbGxiYWNrIGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBwYWdlLFxuICAgKiB0aGUgc2Nyb2xsZXIgd2lsbCBzeW5jaHJvbm91c2x5IHJlcXVlc3QgdGhlIHBhZ2UgYWdhaW4gd2hpY2ggbWF5IGxlYWQgdG8gbG9vcGluZyBpbiB0aGUgZW5kLlxuICAgKiBUaGF0IHdhcyB0aGUgY2FzZSBmb3IgdGhlIEZsb3cgY291bnRlcnBhcnQ6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS92YWFkaW4vZmxvdy1jb21wb25lbnRzL2lzc3Vlcy8zNTUzI2lzc3VlY29tbWVudC0xMjM5MzQ0ODI4XG4gICAqL1xuICBfX3JlcXVlc3RJdGVtQnlJbmRleChpbmRleCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudCgnaW5kZXgtcmVxdWVzdGVkJywge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBjdXJyZW50U2Nyb2xsZXJQb3M6IHRoaXMuX29sZFNjcm9sbGVyUG9zaXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF92aXNpYmxlSXRlbXNDb3VudCgpIHtcbiAgICAvLyBFbnN1cmUgaXRlbXMgYXJlIHBvc2l0aW9uZWRcbiAgICB0aGlzLl9fdmlydHVhbGl6ZXIuc2Nyb2xsVG9JbmRleCh0aGlzLl9fdmlydHVhbGl6ZXIuZmlyc3RWaXNpYmxlSW5kZXgpO1xuICAgIGNvbnN0IGhhc0l0ZW1zID0gdGhpcy5fX3ZpcnR1YWxpemVyLnNpemUgPiAwO1xuICAgIHJldHVybiBoYXNJdGVtcyA/IHRoaXMuX192aXJ0dWFsaXplci5sYXN0VmlzaWJsZUluZGV4IC0gdGhpcy5fX3ZpcnR1YWxpemVyLmZpcnN0VmlzaWJsZUluZGV4ICsgMSA6IDA7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKENvbWJvQm94U2Nyb2xsZXIuaXMsIENvbWJvQm94U2Nyb2xsZXIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_vaadin_material_styles_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_overlay_theme_material_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/overlay/theme/material/vaadin-overlay.js */ \"./node_modules/@vaadin/overlay/theme/material/vaadin-overlay.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_mixins_loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/mixins/loader.js */ \"./node_modules/@vaadin/vaadin-material-styles/mixins/loader.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_mixins_menu_overlay_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/mixins/menu-overlay.js */ \"./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n\n\n\nconst comboBoxOverlay = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__.css`\n  :host {\n    --_vaadin-combo-box-items-container-border-width: 8px 0;\n    --_vaadin-combo-box-items-container-border-style: solid;\n    --_vaadin-combo-box-items-container-border-color: transparent;\n  }\n\n  [part='overlay'] {\n    position: relative;\n    overflow: visible;\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  }\n\n  [part='content'] {\n    padding: 0;\n  }\n\n  [part~='loader'] {\n    position: absolute;\n    z-index: 1;\n    top: -2px;\n    left: 0;\n    right: 0;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__.registerStyles)('vaadin-combo-box-overlay', [_vaadin_vaadin_material_styles_mixins_menu_overlay_js__WEBPACK_IMPORTED_MODULE_3__.menuOverlay, comboBoxOverlay, _vaadin_vaadin_material_styles_mixins_loader_js__WEBPACK_IMPORTED_MODULE_2__.loader], {\n  moduleId: 'material-combo-box-overlay'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1kcm9wZG93bi1zdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tYm8tYm94L3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1jb21iby1ib3gtZHJvcGRvd24tc3R5bGVzLmpzPzNlODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvY29sb3IuanMnO1xuaW1wb3J0ICdAdmFhZGluL292ZXJsYXkvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLW92ZXJsYXkuanMnO1xuaW1wb3J0IHsgbG9hZGVyIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9sb2FkZXIuanMnO1xuaW1wb3J0IHsgbWVudU92ZXJsYXkgfSBmcm9tICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvbWl4aW5zL21lbnUtb3ZlcmxheS5qcyc7XG5pbXBvcnQgeyBjc3MsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuY29uc3QgY29tYm9Cb3hPdmVybGF5ID0gY3NzYFxuICA6aG9zdCB7XG4gICAgLS1fdmFhZGluLWNvbWJvLWJveC1pdGVtcy1jb250YWluZXItYm9yZGVyLXdpZHRoOiA4cHggMDtcbiAgICAtLV92YWFkaW4tY29tYm8tYm94LWl0ZW1zLWNvbnRhaW5lci1ib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgIC0tX3ZhYWRpbi1jb21iby1ib3gtaXRlbXMtY29udGFpbmVyLWJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIH1cblxuICBbcGFydD0nb3ZlcmxheSddIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgb3ZlcmZsb3c6IHZpc2libGU7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcbiAgfVxuXG4gIFtwYXJ0PSdjb250ZW50J10ge1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cblxuICBbcGFydH49J2xvYWRlciddIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogMTtcbiAgICB0b3A6IC0ycHg7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgfVxuYDtcblxucmVnaXN0ZXJTdHlsZXMoJ3ZhYWRpbi1jb21iby1ib3gtb3ZlcmxheScsIFttZW51T3ZlcmxheSwgY29tYm9Cb3hPdmVybGF5LCBsb2FkZXJdLCB7XG4gIG1vZHVsZUlkOiAnbWF0ZXJpYWwtY29tYm8tYm94LW92ZXJsYXknLFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_vaadin_material_styles_color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/font-icons.js */ \"./node_modules/@vaadin/vaadin-material-styles/font-icons.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/typography.js */ \"./node_modules/@vaadin/vaadin-material-styles/typography.js\");\n/* harmony import */ var _vaadin_item_theme_material_vaadin_item_styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/item/theme/material/vaadin-item-styles.js */ \"./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/combo-box/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n\n\n\nconst comboBoxItem = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__.css`\n  :host {\n    cursor: pointer;\n    -webkit-tap-highlight-color: transparent;\n    padding: 4px 10px;\n    --_material-item-selected-icon-display: block;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_4__.registerStyles)('vaadin-combo-box-item', [_vaadin_item_theme_material_vaadin_item_styles_js__WEBPACK_IMPORTED_MODULE_3__.item, comboBoxItem], {\n  moduleId: 'material-combo-box-item'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1pdGVtLXN0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1pdGVtLXN0eWxlcy5qcz9kNTA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2NvbG9yLmpzJztcbmltcG9ydCAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2ZvbnQtaWNvbnMuanMnO1xuaW1wb3J0ICdAdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvdHlwb2dyYXBoeS5qcyc7XG5pbXBvcnQgeyBpdGVtIH0gZnJvbSAnQHZhYWRpbi9pdGVtL3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1pdGVtLXN0eWxlcy5qcyc7XG5pbXBvcnQgeyBjc3MsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuY29uc3QgY29tYm9Cb3hJdGVtID0gY3NzYFxuICA6aG9zdCB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgcGFkZGluZzogNHB4IDEwcHg7XG4gICAgLS1fbWF0ZXJpYWwtaXRlbS1zZWxlY3RlZC1pY29uLWRpc3BsYXk6IGJsb2NrO1xuICB9XG5gO1xuXG5yZWdpc3RlclN0eWxlcygndmFhZGluLWNvbWJvLWJveC1pdGVtJywgW2l0ZW0sIGNvbWJvQm94SXRlbV0sIHtcbiAgbW9kdWxlSWQ6ICdtYXRlcmlhbC1jb21iby1ib3gtaXRlbScsXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-light.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-light.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_combo_box_dropdown_styles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-combo-box-dropdown-styles.js */ \"./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-dropdown-styles.js\");\n/* harmony import */ var _vaadin_combo_box_item_styles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-combo-box-item-styles.js */ \"./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-item-styles.js\");\n/* harmony import */ var _src_vaadin_combo_box_light_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../src/vaadin-combo-box-light.js */ \"./node_modules/@vaadin/combo-box/src/vaadin-combo-box-light.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1saWdodC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21iby1ib3gvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLWNvbWJvLWJveC1saWdodC5qcz81MTRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi92YWFkaW4tY29tYm8tYm94LWRyb3Bkb3duLXN0eWxlcy5qcyc7XG5pbXBvcnQgJy4vdmFhZGluLWNvbWJvLWJveC1pdGVtLXN0eWxlcy5qcyc7XG5pbXBvcnQgJy4uLy4uL3NyYy92YWFkaW4tY29tYm8tYm94LWxpZ2h0LmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/combo-box/theme/material/vaadin-combo-box-light.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/async.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/async.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"animationFrame\": () => (/* binding */ animationFrame),\n/* harmony export */   \"idlePeriod\": () => (/* binding */ idlePeriod),\n/* harmony export */   \"microTask\": () => (/* binding */ microTask),\n/* harmony export */   \"timeOut\": () => (/* binding */ timeOut)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nconst microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nconst microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n  for (let i = 0; i < len; i++) {\n    const cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\n\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    if (window.cancelIdleCallback) {\n      window.cancelIdleCallback(handle);\n    } else {\n      window.clearTimeout(handle);\n    }\n  }\n};\n\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nconst microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent;\n      microtaskNodeContent += 1;\n    }\n    microtaskCallbacks.push(callback);\n    const result = microtaskCurrHandle;\n    microtaskCurrHandle += 1;\n    return result;\n  },\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error(`invalid async handle: ${handle}`);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYXN5bmMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9hc3luYy5qcz9lNGIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqXG4gKiBUaGlzIG1vZHVsZSBwcm92aWRlcyBhIG51bWJlciBvZiBzdHJhdGVnaWVzIGZvciBlbnF1ZXVpbmcgYXN5bmNocm9ub3VzXG4gKiB0YXNrcy4gRWFjaCBzdWItbW9kdWxlIHByb3ZpZGVzIGEgc3RhbmRhcmQgYHJ1bihmbilgIGludGVyZmFjZSB0aGF0IHJldHVybnMgYVxuICogaGFuZGxlLCBhbmQgYSBgY2FuY2VsKGhhbmRsZSlgIGludGVyZmFjZSBmb3IgY2FuY2VsaW5nIGFzeW5jIHRhc2tzIGJlZm9yZVxuICogdGhleSBydW4uXG4gKlxuICogQHN1bW1hcnkgTW9kdWxlIHRoYXQgcHJvdmlkZXMgYSBudW1iZXIgb2Ygc3RyYXRlZ2llcyBmb3IgZW5xdWV1aW5nXG4gKiBhc3luY2hyb25vdXMgdGFza3MuXG4gKi9cblxuLy8gTWljcm90YXNrIGltcGxlbWVudGVkIHVzaW5nIE11dGF0aW9uIE9ic2VydmVyXG5sZXQgbWljcm90YXNrQ3VyckhhbmRsZSA9IDA7XG5sZXQgbWljcm90YXNrTGFzdEhhbmRsZSA9IDA7XG5jb25zdCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbmxldCBtaWNyb3Rhc2tOb2RlQ29udGVudCA9IDA7XG5sZXQgbWljcm90YXNrU2NoZWR1bGVkID0gZmFsc2U7XG5jb25zdCBtaWNyb3Rhc2tOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xubmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG1pY3JvdGFza0ZsdXNoKS5vYnNlcnZlKG1pY3JvdGFza05vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gbWljcm90YXNrRmx1c2goKSB7XG4gIG1pY3JvdGFza1NjaGVkdWxlZCA9IGZhbHNlO1xuICBjb25zdCBsZW4gPSBtaWNyb3Rhc2tDYWxsYmFja3MubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2IgPSBtaWNyb3Rhc2tDYWxsYmFja3NbaV07XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbWljcm90YXNrQ2FsbGJhY2tzLnNwbGljZSgwLCBsZW4pO1xuICBtaWNyb3Rhc2tMYXN0SGFuZGxlICs9IGxlbjtcbn1cblxuLyoqXG4gKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHNldFRpbWVvdXRgLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgc2V0VGltZW91dGAuXG4gKi9cbmNvbnN0IHRpbWVPdXQgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3ViLW1vZHVsZSB3aXRoIHRoZSBhc3luYyBpbnRlcmZhY2UgcHJvdmlkaW5nIHRoZSBwcm92aWRlZFxuICAgKiBkZWxheS5cbiAgICpcbiAgICogQG1lbWJlcm9mIHRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXI9fSBkZWxheSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgY2FsbGJhY2tzIGluIG1zXG4gICAqIEByZXR1cm4geyFBc3luY0ludGVyZmFjZX0gQW4gYXN5bmMgdGltZW91dCBpbnRlcmZhY2VcbiAgICovXG4gIGFmdGVyKGRlbGF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bihmbikge1xuICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIGRlbGF5KTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGluIHRoZSBuZXh0IHRhc2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiB0aW1lT3V0XG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBkZWxheSBEZWxheSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihmbiwgZGVsYXkpIHtcbiAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIGRlbGF5KTtcbiAgfSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGB0aW1lT3V0YCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIHRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gIH0sXG59O1xuZXhwb3J0IHsgdGltZU91dCB9O1xuXG4vKipcbiAqIEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAc3VtbWFyeSBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKi9cbmNvbnN0IGFuaW1hdGlvbkZyYW1lID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgYW5pbWF0aW9uRnJhbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnZvaWR9IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGZuKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICB9LFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIGFuaW1hdGlvbkZyYW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gIH0sXG59O1xuZXhwb3J0IHsgYW5pbWF0aW9uRnJhbWUgfTtcblxuLyoqXG4gKiBBc3luYyBpbnRlcmZhY2Ugd3JhcHBlciBhcm91bmQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLiAgRmFsbHMgYmFjayB0b1xuICogYHNldFRpbWVvdXRgIG9uIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBzdW1tYXJ5IEFzeW5jIGludGVyZmFjZSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AuXG4gKi9cbmNvbnN0IGlkbGVQZXJpb2QgPSB7XG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdElkbGVDYWxsYmFja2AgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgaWRsZVBlcmlvZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFJZGxlRGVhZGxpbmUpOnZvaWR9IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGZuKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID8gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soZm4pIDogd2luZG93LnNldFRpbWVvdXQoZm4sIDE2KTtcbiAgfSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBpZGxlUGVyaW9kYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIGlkbGVQZXJpb2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICBpZiAod2luZG93LmNhbmNlbElkbGVDYWxsYmFjaykge1xuICAgICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayhoYW5kbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgfVxuICB9LFxufTtcbmV4cG9ydCB7IGlkbGVQZXJpb2QgfTtcblxuLyoqXG4gKiBBc3luYyBpbnRlcmZhY2UgZm9yIGVucXVldWluZyBjYWxsYmFja3MgdGhhdCBydW4gYXQgbWljcm90YXNrIHRpbWluZy5cbiAqXG4gKiBOb3RlIHRoYXQgbWljcm90YXNrIHRpbWluZyBpcyBhY2hpZXZlZCB2aWEgYSBzaW5nbGUgYE11dGF0aW9uT2JzZXJ2ZXJgLFxuICogYW5kIHRodXMgY2FsbGJhY2tzIGVucXVldWVkIHdpdGggdGhpcyBBUEkgd2lsbCBhbGwgcnVuIGluIGEgc2luZ2xlXG4gKiBiYXRjaCwgYW5kIG5vdCBpbnRlcmxlYXZlZCB3aXRoIG90aGVyIG1pY3JvdGFza3Mgc3VjaCBhcyBwcm9taXNlcy5cbiAqIFByb21pc2VzIGFyZSBhdm9pZGVkIGFzIGFuIGltcGxlbWVudGF0aW9uIGNob2ljZSBmb3IgdGhlIHRpbWUgYmVpbmdcbiAqIGR1ZSB0byBTYWZhcmkgYnVncyB0aGF0IGNhdXNlIFByb21pc2VzIHRvIGxhY2sgbWljcm90YXNrIGd1YXJhbnRlZXMuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHN1bW1hcnkgQXN5bmMgaW50ZXJmYWNlIGZvciBlbnF1ZXVpbmcgY2FsbGJhY2tzIHRoYXQgcnVuIGF0IG1pY3JvdGFza1xuICogICB0aW1pbmcuXG4gKi9cbmNvbnN0IG1pY3JvVGFzayA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IG1pY3JvdGFzayB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtaWNyb1Rhc2tcbiAgICogQHBhcmFtIHshRnVuY3Rpb249fSBjYWxsYmFjayBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihjYWxsYmFjaykge1xuICAgIGlmICghbWljcm90YXNrU2NoZWR1bGVkKSB7XG4gICAgICBtaWNyb3Rhc2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgbWljcm90YXNrTm9kZS50ZXh0Q29udGVudCA9IG1pY3JvdGFza05vZGVDb250ZW50O1xuICAgICAgbWljcm90YXNrTm9kZUNvbnRlbnQgKz0gMTtcbiAgICB9XG4gICAgbWljcm90YXNrQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1pY3JvdGFza0N1cnJIYW5kbGU7XG4gICAgbWljcm90YXNrQ3VyckhhbmRsZSArPSAxO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBtaWNyb1Rhc2tgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbWljcm9UYXNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgY29uc3QgaWR4ID0gaGFuZGxlIC0gbWljcm90YXNrTGFzdEhhbmRsZTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFzeW5jIGhhbmRsZTogJHtoYW5kbGV9YCk7XG4gICAgICB9XG4gICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgfVxuICB9LFxufTtcbmV4cG9ydCB7IG1pY3JvVGFzayB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/async.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/browser-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/browser-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isAndroid\": () => (/* binding */ isAndroid),\n/* harmony export */   \"isChrome\": () => (/* binding */ isChrome),\n/* harmony export */   \"isFirefox\": () => (/* binding */ isFirefox),\n/* harmony export */   \"isIOS\": () => (/* binding */ isIOS),\n/* harmony export */   \"isIPad\": () => (/* binding */ isIPad),\n/* harmony export */   \"isIPhone\": () => (/* binding */ isIPhone),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari),\n/* harmony export */   \"isTouch\": () => (/* binding */ isTouch)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\nconst testUserAgent = regexp => regexp.test(navigator.userAgent);\nconst testPlatform = regexp => regexp.test(navigator.platform);\nconst testVendor = regexp => regexp.test(navigator.vendor);\nconst isAndroid = testUserAgent(/Android/);\nconst isChrome = testUserAgent(/Chrome/) && testVendor(/Google Inc/);\nconst isFirefox = testUserAgent(/Firefox/);\n\n// IPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\nconst isIPad = testPlatform(/^iPad/) || testPlatform(/^Mac/) && navigator.maxTouchPoints > 1;\nconst isIPhone = testPlatform(/^iPhone/);\nconst isIOS = isIPhone || isIPad;\nconst isSafari = testUserAgent(/^((?!chrome|android).)*safari/i);\nconst isTouch = (() => {\n  try {\n    document.createEvent('TouchEvent');\n    return true;\n  } catch (e) {\n    return false;\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYnJvd3Nlci11dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9icm93c2VyLXV0aWxzLmpzP2Q3NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbmNvbnN0IHRlc3RVc2VyQWdlbnQgPSAocmVnZXhwKSA9PiByZWdleHAudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuY29uc3QgdGVzdFBsYXRmb3JtID0gKHJlZ2V4cCkgPT4gcmVnZXhwLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcblxuY29uc3QgdGVzdFZlbmRvciA9IChyZWdleHApID0+IHJlZ2V4cC50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xuXG5leHBvcnQgY29uc3QgaXNBbmRyb2lkID0gdGVzdFVzZXJBZ2VudCgvQW5kcm9pZC8pO1xuXG5leHBvcnQgY29uc3QgaXNDaHJvbWUgPSB0ZXN0VXNlckFnZW50KC9DaHJvbWUvKSAmJiB0ZXN0VmVuZG9yKC9Hb29nbGUgSW5jLyk7XG5cbmV4cG9ydCBjb25zdCBpc0ZpcmVmb3ggPSB0ZXN0VXNlckFnZW50KC9GaXJlZm94Lyk7XG5cbi8vIElQYWRPUyAxMyBsaWVzIGFuZCBzYXlzIGl0J3MgYSBNYWMsIGJ1dCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYnkgZGV0ZWN0aW5nIHRvdWNoIHN1cHBvcnQuXG5leHBvcnQgY29uc3QgaXNJUGFkID0gdGVzdFBsYXRmb3JtKC9eaVBhZC8pIHx8ICh0ZXN0UGxhdGZvcm0oL15NYWMvKSAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKTtcblxuZXhwb3J0IGNvbnN0IGlzSVBob25lID0gdGVzdFBsYXRmb3JtKC9eaVBob25lLyk7XG5cbmV4cG9ydCBjb25zdCBpc0lPUyA9IGlzSVBob25lIHx8IGlzSVBhZDtcblxuZXhwb3J0IGNvbnN0IGlzU2FmYXJpID0gdGVzdFVzZXJBZ2VudCgvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaSk7XG5cbmV4cG9ydCBjb25zdCBpc1RvdWNoID0gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFdmVudCgnVG91Y2hFdmVudCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/browser-utils.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/controller-mixin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/controller-mixin.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ControllerMixin\": () => (/* binding */ ControllerMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * @typedef ReactiveController\n * @type {import('lit').ReactiveController}\n */\n\n/**\n * A mixin for connecting controllers to the element.\n *\n * @polymerMixin\n */\nconst ControllerMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superClass => class ControllerMixinClass extends superClass {\n  constructor() {\n    super();\n\n    /**\n     * @type {Set<ReactiveController>}\n     */\n    this.__controllers = new Set();\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    this.__controllers.forEach(c => {\n      if (c.hostConnected) {\n        c.hostConnected();\n      }\n    });\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__controllers.forEach(c => {\n      if (c.hostDisconnected) {\n        c.hostDisconnected();\n      }\n    });\n  }\n\n  /**\n   * Registers a controller to participate in the element update cycle.\n   *\n   * @param {ReactiveController} controller\n   * @protected\n   */\n  addController(controller) {\n    this.__controllers.add(controller);\n    // Call hostConnected if a controller is added after the element is attached.\n    if (this.$ !== undefined && this.isConnected && controller.hostConnected) {\n      controller.hostConnected();\n    }\n  }\n\n  /**\n   * Removes a controller from the element.\n   *\n   * @param {ReactiveController} controller\n   * @protected\n   */\n  removeController(controller) {\n    this.__controllers.delete(controller);\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvY29udHJvbGxlci1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvY29udHJvbGxlci1taXhpbi5qcz84NzliIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiBSZWFjdGl2ZUNvbnRyb2xsZXJcbiAqIEB0eXBlIHtpbXBvcnQoJ2xpdCcpLlJlYWN0aXZlQ29udHJvbGxlcn1cbiAqL1xuXG4vKipcbiAqIEEgbWl4aW4gZm9yIGNvbm5lY3RpbmcgY29udHJvbGxlcnMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQHBvbHltZXJNaXhpblxuICovXG5leHBvcnQgY29uc3QgQ29udHJvbGxlck1peGluID0gZGVkdXBpbmdNaXhpbihcbiAgKHN1cGVyQ2xhc3MpID0+XG4gICAgY2xhc3MgQ29udHJvbGxlck1peGluQ2xhc3MgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2V0PFJlYWN0aXZlQ29udHJvbGxlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fY29udHJvbGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgICAgICB0aGlzLl9fY29udHJvbGxlcnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgIGlmIChjLmhvc3RDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGMuaG9zdENvbm5lY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgICAgICB0aGlzLl9fY29udHJvbGxlcnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgIGlmIChjLmhvc3REaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGMuaG9zdERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXJzIGEgY29udHJvbGxlciB0byBwYXJ0aWNpcGF0ZSBpbiB0aGUgZWxlbWVudCB1cGRhdGUgY3ljbGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtSZWFjdGl2ZUNvbnRyb2xsZXJ9IGNvbnRyb2xsZXJcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgYWRkQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuX19jb250cm9sbGVycy5hZGQoY29udHJvbGxlcik7XG4gICAgICAgIC8vIENhbGwgaG9zdENvbm5lY3RlZCBpZiBhIGNvbnRyb2xsZXIgaXMgYWRkZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICh0aGlzLiQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzQ29ubmVjdGVkICYmIGNvbnRyb2xsZXIuaG9zdENvbm5lY3RlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuaG9zdENvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhIGNvbnRyb2xsZXIgZnJvbSB0aGUgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge1JlYWN0aXZlQ29udHJvbGxlcn0gY29udHJvbGxlclxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICByZW1vdmVDb250cm9sbGVyKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXJzLmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/controller-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/debounce.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/debounce.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Debouncer\": () => (/* binding */ Debouncer),\n/* harmony export */   \"enqueueDebouncer\": () => (/* binding */ enqueueDebouncer),\n/* harmony export */   \"flush\": () => (/* binding */ flush),\n/* harmony export */   \"flushDebouncers\": () => (/* binding */ flushDebouncers)\n/* harmony export */ });\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nclass Debouncer {\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@vaadin/component-base/src/async.js';\n   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel( /** @type {number} */this._timer);\n      this._timer = null;\n    }\n  }\n\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n}\nlet debouncerQueue = new Set();\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nfunction enqueueDebouncer(debouncer) {\n  debouncerQueue.add(debouncer);\n}\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nfunction flushDebouncers() {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n}\nconst flush = () => {\n  let debouncers;\n  do {\n    debouncers = flushDebouncers();\n  } while (debouncers);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGVib3VuY2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2RlYm91bmNlLmpzPzViMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBDb2xsYXBzZSBtdWx0aXBsZSBjYWxsYmFja3MgaW50byBvbmUgaW52b2NhdGlvbiBhZnRlciBhIHRpbWVyLlxuICovXG5leHBvcnQgY2xhc3MgRGVib3VuY2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkZWJvdW5jZXIgaWYgbm8gZGVib3VuY2VyIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICAgKiBvciBpdCBjYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgb3RoZXJ3aXNlLiBUaGUgZm9sbG93aW5nXG4gICAqIGV4YW1wbGUgc2hvd3MgaG93IGEgZGVib3VuY2VyIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIGFcbiAgICogbWljcm90YXNrIGFuZCBcImRlYm91bmNlZFwiIHN1Y2ggdGhhdCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gaXNcbiAgICogY2FsbGVkIG9uY2UuIEFkZCB0aGlzIG1ldGhvZCB0byBhIGN1c3RvbSBlbGVtZW50OlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQge21pY3JvVGFza30gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYXN5bmMuanMnO1xuICAgKiBpbXBvcnQge0RlYm91bmNlcn0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGVib3VuY2UuanMnO1xuICAgKiAvLyAuLi5cbiAgICpcbiAgICogX2RlYm91bmNlV29yaygpIHtcbiAgICogICB0aGlzLl9kZWJvdW5jZUpvYiA9IERlYm91bmNlci5kZWJvdW5jZSh0aGlzLl9kZWJvdW5jZUpvYixcbiAgICogICAgICAgbWljcm9UYXNrLCAoKSA9PiB0aGlzLl9kb1dvcmsoKSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIElmIHRoZSBgX2RlYm91bmNlV29ya2AgbWV0aG9kIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoaW4gdGhlIHNhbWVcbiAgICogbWljcm90YXNrLCB0aGUgYF9kb1dvcmtgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBhdCB0aGUgbmV4dFxuICAgKiBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAgICpcbiAgICogTm90ZTogSW4gdGVzdGluZyBpdCBpcyBvZnRlbiBjb252ZW5pZW50IHRvIGF2b2lkIGFzeW5jaHJvbnkuIFRvIGFjY29tcGxpc2hcbiAgICogdGhpcyB3aXRoIGEgZGVib3VuY2VyLCB5b3UgY2FuIHVzZSBgZW5xdWV1ZURlYm91bmNlcmAgYW5kXG4gICAqIGBmbHVzaGAuIEZvciBleGFtcGxlLCBleHRlbmQgdGhlIGFib3ZlIGV4YW1wbGUgYnkgYWRkaW5nXG4gICAqIGBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX2RlYm91bmNlSm9iKWAgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICogYF9kZWJvdW5jZVdvcmtgIG1ldGhvZC4gVGhlbiBpbiBhIHRlc3QsIGNhbGwgYGZsdXNoYCB0byBlbnN1cmVcbiAgICogdGhlIGRlYm91bmNlciBoYXMgY29tcGxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RlYm91bmNlcj99IGRlYm91bmNlciBEZWJvdW5jZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0geyFBc3luY0ludGVyZmFjZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuLlxuICAgKiBAcmV0dXJuIHshRGVib3VuY2VyfSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBkZWJvdW5jZShkZWJvdW5jZXIsIGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgIGlmIChkZWJvdW5jZXIgaW5zdGFuY2VvZiBEZWJvdW5jZXIpIHtcbiAgICAgIC8vIENhbmNlbCB0aGUgYXN5bmMgY2FsbGJhY2ssIGJ1dCBsZWF2ZSBpbiBkZWJvdW5jZXJRdWV1ZSBpZiBpdCB3YXNcbiAgICAgIC8vIGVucXVldWVkLCB0byBtYWludGFpbiAxLnggZmx1c2ggb3JkZXJcbiAgICAgIGRlYm91bmNlci5fY2FuY2VsQXN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVib3VuY2VyID0gbmV3IERlYm91bmNlcigpO1xuICAgIH1cbiAgICBkZWJvdW5jZXIuc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIGRlYm91bmNlcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gbnVsbDtcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjaGVkdWxlcjsgdGhhdCBpcywgYSBtb2R1bGUgd2l0aCB0aGUgQXN5bmMgaW50ZXJmYWNlLFxuICAgKiBhIGNhbGxiYWNrIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBydW4gZnVuY3Rpb25cbiAgICogZnJvbSB0aGUgYXN5bmMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0geyFBc3luY0ludGVyZmFjZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hc3luY01vZHVsZSA9IGFzeW5jTW9kdWxlO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZXIgPSB0aGlzLl9hc3luY01vZHVsZS5ydW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgZGVib3VuY2VyUXVldWUuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX2NhbmNlbEFzeW5jKCk7XG4gICAgICAvLyBDYW5jZWxpbmcgYSBkZWJvdW5jZXIgcmVtb3ZlcyBpdHMgc3BvdCBmcm9tIHRoZSBmbHVzaCBxdWV1ZSxcbiAgICAgIC8vIHNvIGlmIGEgZGVib3VuY2VyIGlzIG1hbnVhbGx5IGNhbmNlbGVkIGFuZCByZS1kZWJvdW5jZWQsIGl0XG4gICAgICAvLyB3aWxsIHJlc2V0IGl0cyBmbHVzaCBvcmRlciAodGhpcyBpcyBhIHZlcnkgbWlub3IgZGlmZmVyZW5jZSBmcm9tIDEueClcbiAgICAgIC8vIFJlLWRlYm91bmNpbmcgdmlhIHRoZSBgZGVib3VuY2VgIEFQSSByZXRhaW5zIHRoZSAxLnggRklGTyBmbHVzaCBvcmRlclxuICAgICAgZGVib3VuY2VyUXVldWUuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgZGVib3VuY2VyJ3MgYXN5bmMgY2FsbGJhY2suXG4gICAqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBfY2FuY2VsQXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fYXN5bmNNb2R1bGUuY2FuY2VsKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5fdGltZXIpKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVyICE9IG51bGw7XG4gIH1cbn1cblxubGV0IGRlYm91bmNlclF1ZXVlID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEFkZHMgYSBgRGVib3VuY2VyYCB0byBhIGxpc3Qgb2YgZ2xvYmFsbHkgZmx1c2hhYmxlIHRhc2tzLlxuICpcbiAqIEBwYXJhbSB7IURlYm91bmNlcn0gZGVib3VuY2VyIERlYm91bmNlciB0byBlbnF1ZXVlXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZURlYm91bmNlcihkZWJvdW5jZXIpIHtcbiAgZGVib3VuY2VyUXVldWUuYWRkKGRlYm91bmNlcik7XG59XG5cbi8qKlxuICogRmx1c2hlcyBhbnkgZW5xdWV1ZWQgZGVib3VuY2Vyc1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgd2hldGhlciBhbnkgZGVib3VuY2VycyB3ZXJlIGZsdXNoZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoRGVib3VuY2VycygpIHtcbiAgY29uc3QgZGlkRmx1c2ggPSBCb29sZWFuKGRlYm91bmNlclF1ZXVlLnNpemUpO1xuICAvLyBJZiBuZXcgZGVib3VuY2VycyBhcmUgYWRkZWQgd2hpbGUgZmx1c2hpbmcsIFNldC5mb3JFYWNoIHdpbGwgZW5zdXJlXG4gIC8vIG5ld2x5IGFkZGVkIG9uZXMgYXJlIGFsc28gZmx1c2hlZFxuICBkZWJvdW5jZXJRdWV1ZS5mb3JFYWNoKChkZWJvdW5jZXIpID0+IHtcbiAgICB0cnkge1xuICAgICAgZGVib3VuY2VyLmZsdXNoKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGlkRmx1c2g7XG59XG5cbmV4cG9ydCBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgbGV0IGRlYm91bmNlcnM7XG4gIGRvIHtcbiAgICBkZWJvdW5jZXJzID0gZmx1c2hEZWJvdW5jZXJzKCk7XG4gIH0gd2hpbGUgKGRlYm91bmNlcnMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/debounce.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/dir-helper.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/dir-helper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirHelper\": () => (/* binding */ DirHelper)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Helper that provides a set of functions for RTL.\n */\nclass DirHelper {\n  /**\n   * Get the scroll type in the current browser view.\n   *\n   * @return {string} the scroll type. Possible values are `default|reverse|negative`\n   */\n  static detectScrollType() {\n    const dummy = document.createElement('div');\n    dummy.textContent = 'ABCD';\n    dummy.dir = 'rtl';\n    dummy.style.fontSize = '14px';\n    dummy.style.width = '4px';\n    dummy.style.height = '1px';\n    dummy.style.position = 'absolute';\n    dummy.style.top = '-1000px';\n    dummy.style.overflow = 'scroll';\n    document.body.appendChild(dummy);\n    let cachedType = 'reverse';\n    if (dummy.scrollLeft > 0) {\n      cachedType = 'default';\n    } else {\n      dummy.scrollLeft = 2;\n      if (dummy.scrollLeft < 2) {\n        cachedType = 'negative';\n      }\n    }\n    document.body.removeChild(dummy);\n    return cachedType;\n  }\n\n  /**\n   * Get the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @return {number} the scrollLeft value.\n   */\n  static getNormalizedScrollLeft(scrollType, direction, element) {\n    const {\n      scrollLeft\n    } = element;\n    if (direction !== 'rtl' || !scrollType) {\n      return scrollLeft;\n    }\n    switch (scrollType) {\n      case 'negative':\n        return element.scrollWidth - element.clientWidth + scrollLeft;\n      case 'reverse':\n        return element.scrollWidth - element.clientWidth - scrollLeft;\n      default:\n        return scrollLeft;\n    }\n  }\n\n  /**\n   * Set the scrollLeft value of the element relative to the direction\n   *\n   * @param {string} scrollType type of the scroll detected with `detectScrollType`\n   * @param {string} direction current direction of the element\n   * @param {Element} element\n   * @param {number} scrollLeft the scrollLeft value to be set\n   */\n  static setNormalizedScrollLeft(scrollType, direction, element, scrollLeft) {\n    if (direction !== 'rtl' || !scrollType) {\n      element.scrollLeft = scrollLeft;\n      return;\n    }\n    switch (scrollType) {\n      case 'negative':\n        element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;\n        break;\n      case 'reverse':\n        element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;\n        break;\n      default:\n        element.scrollLeft = scrollLeft;\n        break;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlyLWhlbHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9kaXItaGVscGVyLmpzP2ExOTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbi8qKlxuICogSGVscGVyIHRoYXQgcHJvdmlkZXMgYSBzZXQgb2YgZnVuY3Rpb25zIGZvciBSVEwuXG4gKi9cbmNsYXNzIERpckhlbHBlciB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHNjcm9sbCB0eXBlIGluIHRoZSBjdXJyZW50IGJyb3dzZXIgdmlldy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgc2Nyb2xsIHR5cGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYGRlZmF1bHR8cmV2ZXJzZXxuZWdhdGl2ZWBcbiAgICovXG4gIHN0YXRpYyBkZXRlY3RTY3JvbGxUeXBlKCkge1xuICAgIGNvbnN0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZHVtbXkudGV4dENvbnRlbnQgPSAnQUJDRCc7XG4gICAgZHVtbXkuZGlyID0gJ3J0bCc7XG4gICAgZHVtbXkuc3R5bGUuZm9udFNpemUgPSAnMTRweCc7XG4gICAgZHVtbXkuc3R5bGUud2lkdGggPSAnNHB4JztcbiAgICBkdW1teS5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICBkdW1teS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZHVtbXkuc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGR1bW15LnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkdW1teSk7XG5cbiAgICBsZXQgY2FjaGVkVHlwZSA9ICdyZXZlcnNlJztcbiAgICBpZiAoZHVtbXkuc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgIGNhY2hlZFR5cGUgPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15LnNjcm9sbExlZnQgPSAyO1xuICAgICAgaWYgKGR1bW15LnNjcm9sbExlZnQgPCAyKSB7XG4gICAgICAgIGNhY2hlZFR5cGUgPSAnbmVnYXRpdmUnO1xuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGR1bW15KTtcbiAgICByZXR1cm4gY2FjaGVkVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNjcm9sbExlZnQgdmFsdWUgb2YgdGhlIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2Nyb2xsVHlwZSB0eXBlIG9mIHRoZSBzY3JvbGwgZGV0ZWN0ZWQgd2l0aCBgZGV0ZWN0U2Nyb2xsVHlwZWBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBjdXJyZW50IGRpcmVjdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgc2Nyb2xsTGVmdCB2YWx1ZS5cbiAgICovXG4gIHN0YXRpYyBnZXROb3JtYWxpemVkU2Nyb2xsTGVmdChzY3JvbGxUeXBlLCBkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICBjb25zdCB7IHNjcm9sbExlZnQgfSA9IGVsZW1lbnQ7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3J0bCcgfHwgIXNjcm9sbFR5cGUpIHtcbiAgICAgIHJldHVybiBzY3JvbGxMZWZ0O1xuICAgIH1cblxuICAgIHN3aXRjaCAoc2Nyb2xsVHlwZSkge1xuICAgICAgY2FzZSAnbmVnYXRpdmUnOlxuICAgICAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxMZWZ0O1xuICAgICAgY2FzZSAncmV2ZXJzZSc6XG4gICAgICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aCAtIHNjcm9sbExlZnQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc2Nyb2xsTGVmdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY3JvbGxMZWZ0IHZhbHVlIG9mIHRoZSBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkaXJlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjcm9sbFR5cGUgdHlwZSBvZiB0aGUgc2Nyb2xsIGRldGVjdGVkIHdpdGggYGRldGVjdFNjcm9sbFR5cGVgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gY3VycmVudCBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxMZWZ0IHRoZSBzY3JvbGxMZWZ0IHZhbHVlIHRvIGJlIHNldFxuICAgKi9cbiAgc3RhdGljIHNldE5vcm1hbGl6ZWRTY3JvbGxMZWZ0KHNjcm9sbFR5cGUsIGRpcmVjdGlvbiwgZWxlbWVudCwgc2Nyb2xsTGVmdCkge1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdydGwnIHx8ICFzY3JvbGxUeXBlKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc2Nyb2xsVHlwZSkge1xuICAgICAgY2FzZSAnbmVnYXRpdmUnOlxuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBlbGVtZW50LmNsaWVudFdpZHRoIC0gZWxlbWVudC5zY3JvbGxXaWR0aCArIHNjcm9sbExlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmV2ZXJzZSc6XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50LmNsaWVudFdpZHRoIC0gc2Nyb2xsTGVmdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgRGlySGVscGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/dir-helper.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/dir-mixin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/dir-mixin.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DirMixin\": () => (/* binding */ DirMixin)\n/* harmony export */ });\n/* harmony import */ var _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dir-helper.js */ \"./node_modules/@vaadin/component-base/src/dir-helper.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * Array of Vaadin custom element classes that have been subscribed to the dir changes.\n */\nconst directionSubscribers = [];\nfunction directionUpdater() {\n  const documentDir = getDocumentDir();\n  directionSubscribers.forEach(element => {\n    alignDirs(element, documentDir);\n  });\n}\nlet scrollType;\nconst directionObserver = new MutationObserver(directionUpdater);\ndirectionObserver.observe(document.documentElement, {\n  attributes: true,\n  attributeFilter: ['dir']\n});\nfunction alignDirs(element, documentDir, elementDir = element.getAttribute('dir')) {\n  if (documentDir) {\n    element.setAttribute('dir', documentDir);\n  } else if (elementDir != null) {\n    element.removeAttribute('dir');\n  }\n}\nfunction getDocumentDir() {\n  return document.documentElement.getAttribute('dir');\n}\n\n/**\n * A mixin to handle `dir` attribute based on the one set on the `<html>` element.\n *\n * @polymerMixin\n */\nconst DirMixin = superClass => class VaadinDirMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * @protected\n       */\n      dir: {\n        type: String,\n        value: '',\n        reflectToAttribute: true,\n        converter: {\n          fromAttribute: attr => {\n            return !attr ? '' : attr;\n          },\n          toAttribute: prop => {\n            return prop === '' ? null : prop;\n          }\n        }\n      }\n    };\n  }\n\n  /** @protected */\n  static finalize() {\n    super.finalize();\n    if (!scrollType) {\n      scrollType = _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.detectScrollType();\n    }\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!this.hasAttribute('dir') || this.__restoreSubscription) {\n      this.__subscribe();\n      alignDirs(this, getDocumentDir(), null);\n    }\n  }\n\n  /** @protected */\n  attributeChangedCallback(name, oldValue, newValue) {\n    super.attributeChangedCallback(name, oldValue, newValue);\n    if (name !== 'dir') {\n      return;\n    }\n    const documentDir = getDocumentDir();\n\n    // New value equals to the document direction and the element is not subscribed to the changes\n    const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1;\n    // Value was emptied and the element is not subscribed to the changes\n    const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;\n    // New value is different and the old equals to document direction and the element is not subscribed to the changes\n    const newDiffValue = newValue !== documentDir && oldValue === documentDir;\n    if (newValueEqlDocDir || newValueEmptied) {\n      this.__subscribe();\n      alignDirs(this, documentDir, newValue);\n    } else if (newDiffValue) {\n      this.__unsubscribe();\n    }\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__restoreSubscription = directionSubscribers.includes(this);\n    this.__unsubscribe();\n  }\n\n  /** @protected */\n  _valueToNodeAttribute(node, value, attribute) {\n    // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n    // If the property contains an empty string then it should not create an empty attribute\n    if (attribute === 'dir' && value === '' && !node.hasAttribute('dir')) {\n      return;\n    }\n    super._valueToNodeAttribute(node, value, attribute);\n  }\n\n  /** @protected */\n  _attributeToProperty(attribute, value, type) {\n    // Override default Polymer attribute reflection to match native behavior of HTMLElement.dir property\n    // If the attribute is removed, then the dir property should contain an empty string instead of null\n    if (attribute === 'dir' && !value) {\n      this.dir = '';\n    } else {\n      super._attributeToProperty(attribute, value, type);\n    }\n  }\n\n  /** @private */\n  __subscribe() {\n    if (!directionSubscribers.includes(this)) {\n      directionSubscribers.push(this);\n    }\n  }\n\n  /** @private */\n  __unsubscribe() {\n    if (directionSubscribers.includes(this)) {\n      directionSubscribers.splice(directionSubscribers.indexOf(this), 1);\n    }\n  }\n\n  /**\n   * @param {Element} element\n   * @return {number}\n   * @protected\n   */\n  __getNormalizedScrollLeft(element) {\n    return _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.getNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element);\n  }\n\n  /**\n   * @param {Element} element\n   * @param {number} scrollLeft\n   * @protected\n   */\n  __setNormalizedScrollLeft(element, scrollLeft) {\n    return _dir_helper_js__WEBPACK_IMPORTED_MODULE_0__.DirHelper.setNormalizedScrollLeft(scrollType, this.getAttribute('dir') || 'ltr', element, scrollLeft);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlyLW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlyLW1peGluLmpzPzRlM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBEaXJIZWxwZXIgfSBmcm9tICcuL2Rpci1oZWxwZXIuanMnO1xuXG4vKipcbiAqIEFycmF5IG9mIFZhYWRpbiBjdXN0b20gZWxlbWVudCBjbGFzc2VzIHRoYXQgaGF2ZSBiZWVuIHN1YnNjcmliZWQgdG8gdGhlIGRpciBjaGFuZ2VzLlxuICovXG5jb25zdCBkaXJlY3Rpb25TdWJzY3JpYmVycyA9IFtdO1xuXG5mdW5jdGlvbiBkaXJlY3Rpb25VcGRhdGVyKCkge1xuICBjb25zdCBkb2N1bWVudERpciA9IGdldERvY3VtZW50RGlyKCk7XG4gIGRpcmVjdGlvblN1YnNjcmliZXJzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICBhbGlnbkRpcnMoZWxlbWVudCwgZG9jdW1lbnREaXIpO1xuICB9KTtcbn1cblxubGV0IHNjcm9sbFR5cGU7XG5cbmNvbnN0IGRpcmVjdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZGlyZWN0aW9uVXBkYXRlcik7XG5kaXJlY3Rpb25PYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6IFsnZGlyJ10gfSk7XG5cbmZ1bmN0aW9uIGFsaWduRGlycyhlbGVtZW50LCBkb2N1bWVudERpciwgZWxlbWVudERpciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKSkge1xuICBpZiAoZG9jdW1lbnREaXIpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlyJywgZG9jdW1lbnREaXIpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnREaXIgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkaXInKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudERpcigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpO1xufVxuXG4vKipcbiAqIEEgbWl4aW4gdG8gaGFuZGxlIGBkaXJgIGF0dHJpYnV0ZSBiYXNlZCBvbiB0aGUgb25lIHNldCBvbiB0aGUgYDxodG1sPmAgZWxlbWVudC5cbiAqXG4gKiBAcG9seW1lck1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBEaXJNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5EaXJNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkaXI6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICBjb252ZXJ0ZXI6IHtcbiAgICAgICAgICAgIGZyb21BdHRyaWJ1dGU6IChhdHRyKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAhYXR0ciA/ICcnIDogYXR0cjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b0F0dHJpYnV0ZTogKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3AgPT09ICcnID8gbnVsbCA6IHByb3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgc3VwZXIuZmluYWxpemUoKTtcblxuICAgICAgaWYgKCFzY3JvbGxUeXBlKSB7XG4gICAgICAgIHNjcm9sbFR5cGUgPSBEaXJIZWxwZXIuZGV0ZWN0U2Nyb2xsVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdkaXInKSB8fCB0aGlzLl9fcmVzdG9yZVN1YnNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLl9fc3Vic2NyaWJlKCk7XG4gICAgICAgIGFsaWduRGlycyh0aGlzLCBnZXREb2N1bWVudERpcigpLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgaWYgKG5hbWUgIT09ICdkaXInKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZG9jdW1lbnREaXIgPSBnZXREb2N1bWVudERpcigpO1xuXG4gICAgICAvLyBOZXcgdmFsdWUgZXF1YWxzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3Rpb24gYW5kIHRoZSBlbGVtZW50IGlzIG5vdCBzdWJzY3JpYmVkIHRvIHRoZSBjaGFuZ2VzXG4gICAgICBjb25zdCBuZXdWYWx1ZUVxbERvY0RpciA9IG5ld1ZhbHVlID09PSBkb2N1bWVudERpciAmJiBkaXJlY3Rpb25TdWJzY3JpYmVycy5pbmRleE9mKHRoaXMpID09PSAtMTtcbiAgICAgIC8vIFZhbHVlIHdhcyBlbXB0aWVkIGFuZCB0aGUgZWxlbWVudCBpcyBub3Qgc3Vic2NyaWJlZCB0byB0aGUgY2hhbmdlc1xuICAgICAgY29uc3QgbmV3VmFsdWVFbXB0aWVkID0gIW5ld1ZhbHVlICYmIG9sZFZhbHVlICYmIGRpcmVjdGlvblN1YnNjcmliZXJzLmluZGV4T2YodGhpcykgPT09IC0xO1xuICAgICAgLy8gTmV3IHZhbHVlIGlzIGRpZmZlcmVudCBhbmQgdGhlIG9sZCBlcXVhbHMgdG8gZG9jdW1lbnQgZGlyZWN0aW9uIGFuZCB0aGUgZWxlbWVudCBpcyBub3Qgc3Vic2NyaWJlZCB0byB0aGUgY2hhbmdlc1xuICAgICAgY29uc3QgbmV3RGlmZlZhbHVlID0gbmV3VmFsdWUgIT09IGRvY3VtZW50RGlyICYmIG9sZFZhbHVlID09PSBkb2N1bWVudERpcjtcblxuICAgICAgaWYgKG5ld1ZhbHVlRXFsRG9jRGlyIHx8IG5ld1ZhbHVlRW1wdGllZCkge1xuICAgICAgICB0aGlzLl9fc3Vic2NyaWJlKCk7XG4gICAgICAgIGFsaWduRGlycyh0aGlzLCBkb2N1bWVudERpciwgbmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChuZXdEaWZmVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX3Vuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLl9fcmVzdG9yZVN1YnNjcmlwdGlvbiA9IGRpcmVjdGlvblN1YnNjcmliZXJzLmluY2x1ZGVzKHRoaXMpO1xuICAgICAgdGhpcy5fX3Vuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICBfdmFsdWVUb05vZGVBdHRyaWJ1dGUobm9kZSwgdmFsdWUsIGF0dHJpYnV0ZSkge1xuICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBQb2x5bWVyIGF0dHJpYnV0ZSByZWZsZWN0aW9uIHRvIG1hdGNoIG5hdGl2ZSBiZWhhdmlvciBvZiBIVE1MRWxlbWVudC5kaXIgcHJvcGVydHlcbiAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBjb250YWlucyBhbiBlbXB0eSBzdHJpbmcgdGhlbiBpdCBzaG91bGQgbm90IGNyZWF0ZSBhbiBlbXB0eSBhdHRyaWJ1dGVcbiAgICAgIGlmIChhdHRyaWJ1dGUgPT09ICdkaXInICYmIHZhbHVlID09PSAnJyAmJiAhbm9kZS5oYXNBdHRyaWJ1dGUoJ2RpcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1cGVyLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGRlZmF1bHQgUG9seW1lciBhdHRyaWJ1dGUgcmVmbGVjdGlvbiB0byBtYXRjaCBuYXRpdmUgYmVoYXZpb3Igb2YgSFRNTEVsZW1lbnQuZGlyIHByb3BlcnR5XG4gICAgICAvLyBJZiB0aGUgYXR0cmlidXRlIGlzIHJlbW92ZWQsIHRoZW4gdGhlIGRpciBwcm9wZXJ0eSBzaG91bGQgY29udGFpbiBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiBudWxsXG4gICAgICBpZiAoYXR0cmlidXRlID09PSAnZGlyJyAmJiAhdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXIgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9fc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFkaXJlY3Rpb25TdWJzY3JpYmVycy5pbmNsdWRlcyh0aGlzKSkge1xuICAgICAgICBkaXJlY3Rpb25TdWJzY3JpYmVycy5wdXNoKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9fdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uU3Vic2NyaWJlcnMuaW5jbHVkZXModGhpcykpIHtcbiAgICAgICAgZGlyZWN0aW9uU3Vic2NyaWJlcnMuc3BsaWNlKGRpcmVjdGlvblN1YnNjcmliZXJzLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX19nZXROb3JtYWxpemVkU2Nyb2xsTGVmdChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gRGlySGVscGVyLmdldE5vcm1hbGl6ZWRTY3JvbGxMZWZ0KHNjcm9sbFR5cGUsIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXInKSB8fCAnbHRyJywgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbExlZnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX19zZXROb3JtYWxpemVkU2Nyb2xsTGVmdChlbGVtZW50LCBzY3JvbGxMZWZ0KSB7XG4gICAgICByZXR1cm4gRGlySGVscGVyLnNldE5vcm1hbGl6ZWRTY3JvbGxMZWZ0KHNjcm9sbFR5cGUsIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXInKSB8fCAnbHRyJywgZWxlbWVudCwgc2Nyb2xsTGVmdCk7XG4gICAgfVxuICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/dir-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/disabled-mixin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/disabled-mixin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DisabledMixin\": () => (/* binding */ DisabledMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * A mixin to provide disabled property for field components.\n *\n * @polymerMixin\n */\nconst DisabledMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superclass => class DisabledMixinClass extends superclass {\n  static get properties() {\n    return {\n      /**\n       * If true, the user cannot interact with this element.\n       */\n      disabled: {\n        type: Boolean,\n        value: false,\n        observer: '_disabledChanged',\n        reflectToAttribute: true\n      }\n    };\n  }\n\n  /**\n   * @param {boolean} disabled\n   * @protected\n   */\n  _disabledChanged(disabled) {\n    this._setAriaDisabled(disabled);\n  }\n\n  /**\n   * @param {boolean} disabled\n   * @protected\n   */\n  _setAriaDisabled(disabled) {\n    if (disabled) {\n      this.setAttribute('aria-disabled', 'true');\n    } else {\n      this.removeAttribute('aria-disabled');\n    }\n  }\n\n  /**\n   * Overrides the default element `click` method in order to prevent\n   * firing the `click` event when the element is disabled.\n   * @protected\n   * @override\n   */\n  click() {\n    if (!this.disabled) {\n      super.click();\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlzYWJsZWQtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2Rpc2FibGVkLW1peGluLmpzPzY2MWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanMnO1xuXG4vKipcbiAqIEEgbWl4aW4gdG8gcHJvdmlkZSBkaXNhYmxlZCBwcm9wZXJ0eSBmb3IgZmllbGQgY29tcG9uZW50cy5cbiAqXG4gKiBAcG9seW1lck1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBEaXNhYmxlZE1peGluID0gZGVkdXBpbmdNaXhpbihcbiAgKHN1cGVyY2xhc3MpID0+XG4gICAgY2xhc3MgRGlzYWJsZWRNaXhpbkNsYXNzIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG4gICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhpcyBlbGVtZW50LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfZGlzYWJsZWRDaGFuZ2VkJyxcbiAgICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX2Rpc2FibGVkQ2hhbmdlZChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLl9zZXRBcmlhRGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX3NldEFyaWFEaXNhYmxlZChkaXNhYmxlZCkge1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBlbGVtZW50IGBjbGlja2AgbWV0aG9kIGluIG9yZGVyIHRvIHByZXZlbnRcbiAgICAgICAqIGZpcmluZyB0aGUgYGNsaWNrYCBldmVudCB3aGVuIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkLlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgKi9cbiAgICAgIGNsaWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICBzdXBlci5jbGljaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/disabled-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/dom-utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/dom-utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addValueToAttribute\": () => (/* binding */ addValueToAttribute),\n/* harmony export */   \"getAncestorRootNodes\": () => (/* binding */ getAncestorRootNodes),\n/* harmony export */   \"isEmptyTextNode\": () => (/* binding */ isEmptyTextNode),\n/* harmony export */   \"removeValueFromAttribute\": () => (/* binding */ removeValueFromAttribute)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Returns an array of ancestor root nodes for the given node.\n *\n * A root node is either a document node or a document fragment node (Shadow Root).\n * The array is collected by a bottom-up DOM traversing that starts with the given node\n * and involves both the light DOM and ancestor shadow DOM trees.\n *\n * @param {Node} node\n * @return {Node[]}\n */\nfunction getAncestorRootNodes(node) {\n  const result = [];\n  while (node) {\n    if (node.nodeType === Node.DOCUMENT_NODE) {\n      result.push(node);\n      break;\n    }\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      result.push(node);\n      node = node.host;\n      continue;\n    }\n    if (node.assignedSlot) {\n      node = node.assignedSlot;\n      continue;\n    }\n    node = node.parentNode;\n  }\n  return result;\n}\n\n/**\n * @param {string} value\n * @return {Set<string>}\n */\nfunction deserializeAttributeValue(value) {\n  if (!value) {\n    return new Set();\n  }\n  return new Set(value.split(' '));\n}\n\n/**\n * @param {Set<string>} values\n * @return {string}\n */\nfunction serializeAttributeValue(values) {\n  return [...values].join(' ');\n}\n\n/**\n * Adds a value to an attribute containing space-delimited values.\n *\n * @param {HTMLElement} element\n * @param {string} attr\n * @param {string} value\n */\nfunction addValueToAttribute(element, attr, value) {\n  const values = deserializeAttributeValue(element.getAttribute(attr));\n  values.add(value);\n  element.setAttribute(attr, serializeAttributeValue(values));\n}\n\n/**\n * Removes a value from an attribute containing space-delimited values.\n * If the value is the last one, the whole attribute is removed.\n *\n * @param {HTMLElement} element\n * @param {string} attr\n * @param {string} value\n */\nfunction removeValueFromAttribute(element, attr, value) {\n  const values = deserializeAttributeValue(element.getAttribute(attr));\n  values.delete(value);\n  if (values.size === 0) {\n    element.removeAttribute(attr);\n    return;\n  }\n  element.setAttribute(attr, serializeAttributeValue(values));\n}\n\n/**\n * Returns true if the given node is an empty text node, false otherwise.\n *\n * @param {Node} node\n * @return {boolean}\n */\nfunction isEmptyTextNode(node) {\n  return node.nodeType === Node.TEXT_NODE && node.textContent.trim() === '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZG9tLXV0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2RvbS11dGlscy5qcz80NTU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYW5jZXN0b3Igcm9vdCBub2RlcyBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQSByb290IG5vZGUgaXMgZWl0aGVyIGEgZG9jdW1lbnQgbm9kZSBvciBhIGRvY3VtZW50IGZyYWdtZW50IG5vZGUgKFNoYWRvdyBSb290KS5cbiAqIFRoZSBhcnJheSBpcyBjb2xsZWN0ZWQgYnkgYSBib3R0b20tdXAgRE9NIHRyYXZlcnNpbmcgdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gbm9kZVxuICogYW5kIGludm9sdmVzIGJvdGggdGhlIGxpZ2h0IERPTSBhbmQgYW5jZXN0b3Igc2hhZG93IERPTSB0cmVlcy5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge05vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFuY2VzdG9yUm9vdE5vZGVzKG5vZGUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuaG9zdDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLmFzc2lnbmVkU2xvdCkge1xuICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZGVzZXJpYWxpemVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2V0KHZhbHVlLnNwbGl0KCcgJykpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2V0PHN0cmluZz59IHZhbHVlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZXMpIHtcbiAgcmV0dXJuIFsuLi52YWx1ZXNdLmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gYW4gYXR0cmlidXRlIGNvbnRhaW5pbmcgc3BhY2UtZGVsaW1pdGVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRWYWx1ZVRvQXR0cmlidXRlKGVsZW1lbnQsIGF0dHIsIHZhbHVlKSB7XG4gIGNvbnN0IHZhbHVlcyA9IGRlc2VyaWFsaXplQXR0cmlidXRlVmFsdWUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICB2YWx1ZXMuYWRkKHZhbHVlKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgc2VyaWFsaXplQXR0cmlidXRlVmFsdWUodmFsdWVzKSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gYW4gYXR0cmlidXRlIGNvbnRhaW5pbmcgc3BhY2UtZGVsaW1pdGVkIHZhbHVlcy5cbiAqIElmIHRoZSB2YWx1ZSBpcyB0aGUgbGFzdCBvbmUsIHRoZSB3aG9sZSBhdHRyaWJ1dGUgaXMgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVWYWx1ZUZyb21BdHRyaWJ1dGUoZWxlbWVudCwgYXR0ciwgdmFsdWUpIHtcbiAgY29uc3QgdmFsdWVzID0gZGVzZXJpYWxpemVBdHRyaWJ1dGVWYWx1ZShlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gIHZhbHVlcy5kZWxldGUodmFsdWUpO1xuICBpZiAodmFsdWVzLnNpemUgPT09IDApIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgc2VyaWFsaXplQXR0cmlidXRlVmFsdWUodmFsdWVzKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBub2RlIGlzIGFuIGVtcHR5IHRleHQgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gJyc7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/dom-utils.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/focus-trap-controller.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/focus-trap-controller.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FocusTrapController\": () => (/* binding */ FocusTrapController)\n/* harmony export */ });\n/* harmony import */ var _focus_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./focus-utils.js */ \"./node_modules/@vaadin/component-base/src/focus-utils.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\nconst instances = [];\n\n/**\n * A controller for trapping focus within a DOM node.\n */\nclass FocusTrapController {\n  /**\n   * @param {HTMLElement} host\n   */\n  constructor(host) {\n    /**\n     * The controller host element.\n     *\n     * @type {HTMLElement}\n     */\n    this.host = host;\n\n    /**\n     * A node for trapping focus in.\n     *\n     * @type {HTMLElement | null}\n     * @private\n     */\n    this.__trapNode = null;\n    this.__onKeyDown = this.__onKeyDown.bind(this);\n  }\n  hostConnected() {\n    document.addEventListener('keydown', this.__onKeyDown);\n  }\n  hostDisconnected() {\n    document.removeEventListener('keydown', this.__onKeyDown);\n  }\n\n  /**\n   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.\n   * The trap can be deactivated with the `.releaseFocus()` method.\n   *\n   * If focus is initially outside the trap, the method will move focus inside,\n   * on the first focusable element of the trap in the tab order.\n   * The first focusable element can be the trap node itself if it is focusable\n   * and comes first in the tab order.\n   *\n   * If there are no focusable elements, the method will throw an exception\n   * and the trap will not be set.\n   *\n   * @param {HTMLElement} trapNode\n   */\n  trapFocus(trapNode) {\n    this.__trapNode = trapNode;\n    if (this.__focusableElements.length === 0) {\n      this.__trapNode = null;\n      throw new Error('The trap node should have at least one focusable descendant or be focusable itself.');\n    }\n    instances.push(this);\n    if (this.__focusedElementIndex === -1) {\n      this.__focusableElements[0].focus();\n    }\n  }\n\n  /**\n   * Deactivates the focus trap set with the `.trapFocus()` method\n   * so that it becomes possible to tab outside the trap node.\n   */\n  releaseFocus() {\n    this.__trapNode = null;\n    instances.pop();\n  }\n\n  /**\n   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.\n   *\n   * - Moves focus to the next focusable element of the trap on `Tab` press.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.\n   * When no prev element to focus, the method moves focus to the last focusable element.\n   *\n   * @param {KeyboardEvent} event\n   * @private\n   */\n  __onKeyDown(event) {\n    if (!this.__trapNode) {\n      return;\n    }\n\n    // Only handle events for the last instance\n    if (this !== Array.from(instances).pop()) {\n      return;\n    }\n    if (event.key === 'Tab') {\n      event.preventDefault();\n      const backward = event.shiftKey;\n      this.__focusNextElement(backward);\n    }\n  }\n\n  /**\n   * - Moves focus to the next focusable element if `backward === false`.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element if `backward === true`.\n   * When no prev element to focus the method moves focus to the last focusable element.\n   *\n   * If no focusable elements, the method returns immediately.\n   *\n   * @param {boolean} backward\n   * @private\n   */\n  __focusNextElement(backward = false) {\n    const focusableElements = this.__focusableElements;\n    const step = backward ? -1 : 1;\n    const currentIndex = this.__focusedElementIndex;\n    const nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;\n    const element = focusableElements[nextIndex];\n    element.focus();\n    if (element.localName === 'input') {\n      element.select();\n    }\n  }\n\n  /**\n   * An array of tab-ordered focusable elements inside the trap node.\n   *\n   * @return {HTMLElement[]}\n   * @private\n   */\n  get __focusableElements() {\n    return (0,_focus_utils_js__WEBPACK_IMPORTED_MODULE_0__.getFocusableElements)(this.__trapNode);\n  }\n\n  /**\n   * The index of the element inside the trap node that currently has focus.\n   *\n   * @return {HTMLElement | undefined}\n   * @private\n   */\n  get __focusedElementIndex() {\n    const focusableElements = this.__focusableElements;\n    return focusableElements.indexOf(focusableElements.filter(_focus_utils_js__WEBPACK_IMPORTED_MODULE_0__.isElementFocused).pop());\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZm9jdXMtdHJhcC1jb250cm9sbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2ZvY3VzLXRyYXAtY29udHJvbGxlci5qcz83M2VjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgZ2V0Rm9jdXNhYmxlRWxlbWVudHMsIGlzRWxlbWVudEZvY3VzZWQgfSBmcm9tICcuL2ZvY3VzLXV0aWxzLmpzJztcblxuY29uc3QgaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogQSBjb250cm9sbGVyIGZvciB0cmFwcGluZyBmb2N1cyB3aXRoaW4gYSBET00gbm9kZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZvY3VzVHJhcENvbnRyb2xsZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaG9zdFxuICAgKi9cbiAgY29uc3RydWN0b3IoaG9zdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sbGVyIGhvc3QgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmhvc3QgPSBob3N0O1xuXG4gICAgLyoqXG4gICAgICogQSBub2RlIGZvciB0cmFwcGluZyBmb2N1cyBpbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9fdHJhcE5vZGUgPSBudWxsO1xuXG4gICAgdGhpcy5fX29uS2V5RG93biA9IHRoaXMuX19vbktleURvd24uYmluZCh0aGlzKTtcbiAgfVxuXG4gIGhvc3RDb25uZWN0ZWQoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX19vbktleURvd24pO1xuICB9XG5cbiAgaG9zdERpc2Nvbm5lY3RlZCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fX29uS2V5RG93bik7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGEgZm9jdXMgdHJhcCBmb3IgYSBET00gbm9kZSB0aGF0IHdpbGwgcHJldmVudCBmb2N1cyBmcm9tIGVzY2FwaW5nIHRoZSBub2RlLlxuICAgKiBUaGUgdHJhcCBjYW4gYmUgZGVhY3RpdmF0ZWQgd2l0aCB0aGUgYC5yZWxlYXNlRm9jdXMoKWAgbWV0aG9kLlxuICAgKlxuICAgKiBJZiBmb2N1cyBpcyBpbml0aWFsbHkgb3V0c2lkZSB0aGUgdHJhcCwgdGhlIG1ldGhvZCB3aWxsIG1vdmUgZm9jdXMgaW5zaWRlLFxuICAgKiBvbiB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgb2YgdGhlIHRyYXAgaW4gdGhlIHRhYiBvcmRlci5cbiAgICogVGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGNhbiBiZSB0aGUgdHJhcCBub2RlIGl0c2VsZiBpZiBpdCBpcyBmb2N1c2FibGVcbiAgICogYW5kIGNvbWVzIGZpcnN0IGluIHRoZSB0YWIgb3JkZXIuXG4gICAqXG4gICAqIElmIHRoZXJlIGFyZSBubyBmb2N1c2FibGUgZWxlbWVudHMsIHRoZSBtZXRob2Qgd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICogYW5kIHRoZSB0cmFwIHdpbGwgbm90IGJlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdHJhcE5vZGVcbiAgICovXG4gIHRyYXBGb2N1cyh0cmFwTm9kZSkge1xuICAgIHRoaXMuX190cmFwTm9kZSA9IHRyYXBOb2RlO1xuXG4gICAgaWYgKHRoaXMuX19mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX190cmFwTm9kZSA9IG51bGw7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmFwIG5vZGUgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBkZXNjZW5kYW50IG9yIGJlIGZvY3VzYWJsZSBpdHNlbGYuJyk7XG4gICAgfVxuXG4gICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XG5cbiAgICBpZiAodGhpcy5fX2ZvY3VzZWRFbGVtZW50SW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLl9fZm9jdXNhYmxlRWxlbWVudHNbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGZvY3VzIHRyYXAgc2V0IHdpdGggdGhlIGAudHJhcEZvY3VzKClgIG1ldGhvZFxuICAgKiBzbyB0aGF0IGl0IGJlY29tZXMgcG9zc2libGUgdG8gdGFiIG91dHNpZGUgdGhlIHRyYXAgbm9kZS5cbiAgICovXG4gIHJlbGVhc2VGb2N1cygpIHtcbiAgICB0aGlzLl9fdHJhcE5vZGUgPSBudWxsO1xuXG4gICAgaW5zdGFuY2VzLnBvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgYGtleWRvd25gIGV2ZW50IGhhbmRsZXIgdGhhdCBtYW5hZ2VzIHRhYmJpbmcgbmF2aWdhdGlvbiB3aGVuIHRoZSB0cmFwIGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIC0gTW92ZXMgZm9jdXMgdG8gdGhlIG5leHQgZm9jdXNhYmxlIGVsZW1lbnQgb2YgdGhlIHRyYXAgb24gYFRhYmAgcHJlc3MuXG4gICAqIFdoZW4gbm8gbmV4dCBlbGVtZW50IHRvIGZvY3VzLCB0aGUgbWV0aG9kIG1vdmVzIGZvY3VzIHRvIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudC5cbiAgICogLSBNb3ZlcyBmb2N1cyB0byB0aGUgcHJldiBmb2N1c2FibGUgZWxlbWVudCBvZiB0aGUgdHJhcCBvbiBgU2hpZnQrVGFiYCBwcmVzcy5cbiAgICogV2hlbiBubyBwcmV2IGVsZW1lbnQgdG8gZm9jdXMsIHRoZSBtZXRob2QgbW92ZXMgZm9jdXMgdG8gdGhlIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fb25LZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9fdHJhcE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGhhbmRsZSBldmVudHMgZm9yIHRoZSBsYXN0IGluc3RhbmNlXG4gICAgaWYgKHRoaXMgIT09IEFycmF5LmZyb20oaW5zdGFuY2VzKS5wb3AoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBjb25zdCBiYWNrd2FyZCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgdGhpcy5fX2ZvY3VzTmV4dEVsZW1lbnQoYmFja3dhcmQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAtIE1vdmVzIGZvY3VzIHRvIHRoZSBuZXh0IGZvY3VzYWJsZSBlbGVtZW50IGlmIGBiYWNrd2FyZCA9PT0gZmFsc2VgLlxuICAgKiBXaGVuIG5vIG5leHQgZWxlbWVudCB0byBmb2N1cywgdGhlIG1ldGhvZCBtb3ZlcyBmb2N1cyB0byB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQuXG4gICAqIC0gTW92ZXMgZm9jdXMgdG8gdGhlIHByZXYgZm9jdXNhYmxlIGVsZW1lbnQgaWYgYGJhY2t3YXJkID09PSB0cnVlYC5cbiAgICogV2hlbiBubyBwcmV2IGVsZW1lbnQgdG8gZm9jdXMgdGhlIG1ldGhvZCBtb3ZlcyBmb2N1cyB0byB0aGUgbGFzdCBmb2N1c2FibGUgZWxlbWVudC5cbiAgICpcbiAgICogSWYgbm8gZm9jdXNhYmxlIGVsZW1lbnRzLCB0aGUgbWV0aG9kIHJldHVybnMgaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFja3dhcmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fZm9jdXNOZXh0RWxlbWVudChiYWNrd2FyZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSB0aGlzLl9fZm9jdXNhYmxlRWxlbWVudHM7XG4gICAgY29uc3Qgc3RlcCA9IGJhY2t3YXJkID8gLTEgOiAxO1xuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX19mb2N1c2VkRWxlbWVudEluZGV4O1xuICAgIGNvbnN0IG5leHRJbmRleCA9IChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggKyBjdXJyZW50SW5kZXggKyBzdGVwKSAlIGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBlbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbbmV4dEluZGV4XTtcbiAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgICBlbGVtZW50LnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB0YWItb3JkZXJlZCBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIHRoZSB0cmFwIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgX19mb2N1c2FibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gZ2V0Rm9jdXNhYmxlRWxlbWVudHModGhpcy5fX3RyYXBOb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSB0cmFwIG5vZGUgdGhhdCBjdXJyZW50bHkgaGFzIGZvY3VzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IHVuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBfX2ZvY3VzZWRFbGVtZW50SW5kZXgoKSB7XG4gICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSB0aGlzLl9fZm9jdXNhYmxlRWxlbWVudHM7XG4gICAgcmV0dXJuIGZvY3VzYWJsZUVsZW1lbnRzLmluZGV4T2YoZm9jdXNhYmxlRWxlbWVudHMuZmlsdGVyKGlzRWxlbWVudEZvY3VzZWQpLnBvcCgpKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/focus-trap-controller.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/focus-utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/focus-utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getFocusableElements\": () => (/* binding */ getFocusableElements),\n/* harmony export */   \"isElementFocusable\": () => (/* binding */ isElementFocusable),\n/* harmony export */   \"isElementFocused\": () => (/* binding */ isElementFocused),\n/* harmony export */   \"isElementHidden\": () => (/* binding */ isElementHidden),\n/* harmony export */   \"isKeyboardActive\": () => (/* binding */ isKeyboardActive)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n// We consider the keyboard to be active if the window has received a keydown\n// event since the last mousedown event.\nlet keyboardActive = false;\n\n// Listen for top-level keydown and mousedown events.\n// Use capture phase so we detect events even if they're handled.\nwindow.addEventListener('keydown', () => {\n  keyboardActive = true;\n}, {\n  capture: true\n});\nwindow.addEventListener('mousedown', () => {\n  keyboardActive = false;\n}, {\n  capture: true\n});\n\n/**\n * Returns true if the window has received a keydown\n * event since the last mousedown event.\n *\n * @return {boolean}\n */\nfunction isKeyboardActive() {\n  return keyboardActive;\n}\n\n/**\n * Returns true if the element is hidden directly with `display: none` or `visibility: hidden`,\n * false otherwise.\n *\n * The method doesn't traverse the element's ancestors, it only checks for the CSS properties\n * set directly to or inherited by the element.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nfunction isElementHiddenDirectly(element) {\n  // Check inline style first to save a re-flow.\n  const style = element.style;\n  if (style.visibility === 'hidden' || style.display === 'none') {\n    return true;\n  }\n  const computedStyle = window.getComputedStyle(element);\n  if (computedStyle.visibility === 'hidden' || computedStyle.display === 'none') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns the normalized element tabindex. If not focusable, returns -1.\n * It checks for the attribute \"tabindex\" instead of the element property\n * `tabIndex` since browsers assign different values to it.\n * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n *\n * @param {HTMLElement} element\n * @return {number}\n */\nfunction normalizeTabIndex(element) {\n  if (!isElementFocusable(element)) {\n    return -1;\n  }\n  const tabIndex = element.getAttribute('tabindex') || 0;\n  return Number(tabIndex);\n}\n\n/**\n * Returns if element `a` has lower tab order compared to element `b`\n * (both elements are assumed to be focusable and tabbable).\n * Elements with tabindex = 0 have lower tab order compared to elements\n * with tabindex > 0.\n * If both have same tabindex, it returns false.\n *\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n * @return {boolean}\n */\nfunction hasLowerTabOrder(a, b) {\n  // Normalize tabIndexes\n  // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n  const ati = Math.max(a.tabIndex, 0);\n  const bti = Math.max(b.tabIndex, 0);\n  return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n}\n\n/**\n * Merge sort iterator, merges the two arrays into one, sorted by tabindex.\n *\n * @param {HTMLElement[]} left\n * @param {HTMLElement[]} right\n * @return {HTMLElement[]}\n */\nfunction mergeSortByTabIndex(left, right) {\n  const result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (hasLowerTabOrder(left[0], right[0])) {\n      result.push(right.shift());\n    } else {\n      result.push(left.shift());\n    }\n  }\n  return result.concat(left, right);\n}\n\n/**\n * Sorts an array of elements by tabindex. Returns a new array.\n *\n * @param {HTMLElement[]} elements\n * @return {HTMLElement[]}\n */\nfunction sortElementsByTabIndex(elements) {\n  // Implement a merge sort as Array.prototype.sort does a non-stable sort\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n  const len = elements.length;\n  if (len < 2) {\n    return elements;\n  }\n  const pivot = Math.ceil(len / 2);\n  const left = sortElementsByTabIndex(elements.slice(0, pivot));\n  const right = sortElementsByTabIndex(elements.slice(pivot));\n  return mergeSortByTabIndex(left, right);\n}\n\n/**\n * Searches for nodes that are tabbable and adds them to the `result` array.\n * Returns if the `result` array needs to be sorted by tabindex.\n *\n * @param {Node} node The starting point for the search; added to `result` if tabbable.\n * @param {HTMLElement[]} result\n * @return {boolean}\n * @private\n */\nfunction collectFocusableNodes(node, result) {\n  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {\n    // Don't traverse children if the node is not an HTML element or not visible.\n    return false;\n  }\n  const element = /** @type {HTMLElement} */node;\n  const tabIndex = normalizeTabIndex(element);\n  let needsSort = tabIndex > 0;\n  if (tabIndex >= 0) {\n    result.push(element);\n  }\n  let children = [];\n  if (element.localName === 'slot') {\n    children = element.assignedNodes({\n      flatten: true\n    });\n  } else {\n    // Use shadow root if possible, will check for distributed nodes.\n    children = (element.shadowRoot || element).children;\n  }\n  [...children].forEach(child => {\n    // Ensure method is always invoked to collect focusable children.\n    needsSort = collectFocusableNodes(child, result) || needsSort;\n  });\n  return needsSort;\n}\n\n/**\n * Returns true if the element is hidden, false otherwise.\n *\n * An element is treated as hidden when any of the following conditions are met:\n * - the element itself or one of its ancestors has `display: none`.\n * - the element has or inherits `visibility: hidden`.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nfunction isElementHidden(element) {\n  // `offsetParent` is `null` when the element itself\n  // or one of its ancestors is hidden with `display: none`.\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n  if (element.offsetParent === null) {\n    return true;\n  }\n  return isElementHiddenDirectly(element);\n}\n\n/**\n * Returns true if the element is focusable, otherwise false.\n *\n * The list of focusable elements is taken from http://stackoverflow.com/a/1600194/4228703.\n * However, there isn't a definite list, it's up to the browser.\n * The only standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,\n * according to which the only elements that have a `focus()` method are:\n * - HTMLInputElement\n * - HTMLSelectElement\n * - HTMLTextAreaElement\n * - HTMLAnchorElement\n *\n * This notably omits HTMLButtonElement and HTMLAreaElement.\n * Referring to these tests with tabbables in different browsers\n * http://allyjs.io/data-tables/focusable.html\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nfunction isElementFocusable(element) {\n  // The element cannot be focused if its `tabindex` attribute is set to `-1`.\n  if (element.matches('[tabindex=\"-1\"]')) {\n    return false;\n  }\n\n  // Elements that cannot be focused if they have a `disabled` attribute.\n  if (element.matches('input, select, textarea, button, object')) {\n    return element.matches(':not([disabled])');\n  }\n\n  // Elements that can be focused even if they have a `disabled` attribute.\n  return element.matches('a[href], area[href], iframe, [tabindex], [contentEditable]');\n}\n\n/**\n * Returns true if the element is focused, false otherwise.\n *\n * @param {HTMLElement} element\n * @return {boolean}\n */\nfunction isElementFocused(element) {\n  return element.getRootNode().activeElement === element;\n}\n\n/**\n * Returns a tab-ordered array of focusable elements for a root element.\n * The resulting array will include the root element if it is focusable.\n *\n * The method traverses nodes in shadow DOM trees too if any.\n *\n * @param {HTMLElement} element\n * @return {HTMLElement[]}\n */\nfunction getFocusableElements(element) {\n  const focusableElements = [];\n  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);\n  // If there is at least one element with tabindex > 0, we need to sort\n  // the final array by tabindex.\n  if (needsSortByTabIndex) {\n    return sortElementsByTabIndex(focusableElements);\n  }\n  return focusableElements;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZm9jdXMtdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vY29tcG9uZW50LWJhc2Uvc3JjL2ZvY3VzLXV0aWxzLmpzP2M0OTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbi8vIFdlIGNvbnNpZGVyIHRoZSBrZXlib2FyZCB0byBiZSBhY3RpdmUgaWYgdGhlIHdpbmRvdyBoYXMgcmVjZWl2ZWQgYSBrZXlkb3duXG4vLyBldmVudCBzaW5jZSB0aGUgbGFzdCBtb3VzZWRvd24gZXZlbnQuXG5sZXQga2V5Ym9hcmRBY3RpdmUgPSBmYWxzZTtcblxuLy8gTGlzdGVuIGZvciB0b3AtbGV2ZWwga2V5ZG93biBhbmQgbW91c2Vkb3duIGV2ZW50cy5cbi8vIFVzZSBjYXB0dXJlIHBoYXNlIHNvIHdlIGRldGVjdCBldmVudHMgZXZlbiBpZiB0aGV5J3JlIGhhbmRsZWQuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgJ2tleWRvd24nLFxuICAoKSA9PiB7XG4gICAga2V5Ym9hcmRBY3RpdmUgPSB0cnVlO1xuICB9LFxuICB7IGNhcHR1cmU6IHRydWUgfSxcbik7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAnbW91c2Vkb3duJyxcbiAgKCkgPT4ge1xuICAgIGtleWJvYXJkQWN0aXZlID0gZmFsc2U7XG4gIH0sXG4gIHsgY2FwdHVyZTogdHJ1ZSB9LFxuKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHdpbmRvdyBoYXMgcmVjZWl2ZWQgYSBrZXlkb3duXG4gKiBldmVudCBzaW5jZSB0aGUgbGFzdCBtb3VzZWRvd24gZXZlbnQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5Ym9hcmRBY3RpdmUoKSB7XG4gIHJldHVybiBrZXlib2FyZEFjdGl2ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgaGlkZGVuIGRpcmVjdGx5IHdpdGggYGRpc3BsYXk6IG5vbmVgIG9yIGB2aXNpYmlsaXR5OiBoaWRkZW5gLFxuICogZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIFRoZSBtZXRob2QgZG9lc24ndCB0cmF2ZXJzZSB0aGUgZWxlbWVudCdzIGFuY2VzdG9ycywgaXQgb25seSBjaGVja3MgZm9yIHRoZSBDU1MgcHJvcGVydGllc1xuICogc2V0IGRpcmVjdGx5IHRvIG9yIGluaGVyaXRlZCBieSB0aGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnRIaWRkZW5EaXJlY3RseShlbGVtZW50KSB7XG4gIC8vIENoZWNrIGlubGluZSBzdHlsZSBmaXJzdCB0byBzYXZlIGEgcmUtZmxvdy5cbiAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICBpZiAoc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHwgc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGlmIChjb21wdXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nIHx8IGNvbXB1dGVkU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBlbGVtZW50IHRhYmluZGV4LiBJZiBub3QgZm9jdXNhYmxlLCByZXR1cm5zIC0xLlxuICogSXQgY2hlY2tzIGZvciB0aGUgYXR0cmlidXRlIFwidGFiaW5kZXhcIiBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IHByb3BlcnR5XG4gKiBgdGFiSW5kZXhgIHNpbmNlIGJyb3dzZXJzIGFzc2lnbiBkaWZmZXJlbnQgdmFsdWVzIHRvIGl0LlxuICogZS5nLiBpbiBGaXJlZm94IGA8ZGl2IGNvbnRlbnRlZGl0YWJsZT5gIGhhcyBgdGFiSW5kZXggPSAtMWBcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhYkluZGV4KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0VsZW1lbnRGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpIHx8IDA7XG4gIHJldHVybiBOdW1iZXIodGFiSW5kZXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgaWYgZWxlbWVudCBgYWAgaGFzIGxvd2VyIHRhYiBvcmRlciBjb21wYXJlZCB0byBlbGVtZW50IGBiYFxuICogKGJvdGggZWxlbWVudHMgYXJlIGFzc3VtZWQgdG8gYmUgZm9jdXNhYmxlIGFuZCB0YWJiYWJsZSkuXG4gKiBFbGVtZW50cyB3aXRoIHRhYmluZGV4ID0gMCBoYXZlIGxvd2VyIHRhYiBvcmRlciBjb21wYXJlZCB0byBlbGVtZW50c1xuICogd2l0aCB0YWJpbmRleCA+IDAuXG4gKiBJZiBib3RoIGhhdmUgc2FtZSB0YWJpbmRleCwgaXQgcmV0dXJucyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNMb3dlclRhYk9yZGVyKGEsIGIpIHtcbiAgLy8gTm9ybWFsaXplIHRhYkluZGV4ZXNcbiAgLy8gZS5nLiBpbiBGaXJlZm94IGA8ZGl2IGNvbnRlbnRlZGl0YWJsZT5gIGhhcyBgdGFiSW5kZXggPSAtMWBcbiAgY29uc3QgYXRpID0gTWF0aC5tYXgoYS50YWJJbmRleCwgMCk7XG4gIGNvbnN0IGJ0aSA9IE1hdGgubWF4KGIudGFiSW5kZXgsIDApO1xuICByZXR1cm4gYXRpID09PSAwIHx8IGJ0aSA9PT0gMCA/IGJ0aSA+IGF0aSA6IGF0aSA+IGJ0aTtcbn1cblxuLyoqXG4gKiBNZXJnZSBzb3J0IGl0ZXJhdG9yLCBtZXJnZXMgdGhlIHR3byBhcnJheXMgaW50byBvbmUsIHNvcnRlZCBieSB0YWJpbmRleC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IGxlZnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gcmlnaHRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gKi9cbmZ1bmN0aW9uIG1lcmdlU29ydEJ5VGFiSW5kZXgobGVmdCwgcmlnaHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHdoaWxlIChsZWZ0Lmxlbmd0aCA+IDAgJiYgcmlnaHQubGVuZ3RoID4gMCkge1xuICAgIGlmIChoYXNMb3dlclRhYk9yZGVyKGxlZnRbMF0sIHJpZ2h0WzBdKSkge1xuICAgICAgcmVzdWx0LnB1c2gocmlnaHQuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5jb25jYXQobGVmdCwgcmlnaHQpO1xufVxuXG4vKipcbiAqIFNvcnRzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGJ5IHRhYmluZGV4LiBSZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gZWxlbWVudHNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XG4gKi9cbmZ1bmN0aW9uIHNvcnRFbGVtZW50c0J5VGFiSW5kZXgoZWxlbWVudHMpIHtcbiAgLy8gSW1wbGVtZW50IGEgbWVyZ2Ugc29ydCBhcyBBcnJheS5wcm90b3R5cGUuc29ydCBkb2VzIGEgbm9uLXN0YWJsZSBzb3J0XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnRcbiAgY29uc3QgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBlbGVtZW50cztcbiAgfVxuICBjb25zdCBwaXZvdCA9IE1hdGguY2VpbChsZW4gLyAyKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRFbGVtZW50c0J5VGFiSW5kZXgoZWxlbWVudHMuc2xpY2UoMCwgcGl2b3QpKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0RWxlbWVudHNCeVRhYkluZGV4KGVsZW1lbnRzLnNsaWNlKHBpdm90KSk7XG5cbiAgcmV0dXJuIG1lcmdlU29ydEJ5VGFiSW5kZXgobGVmdCwgcmlnaHQpO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBub2RlcyB0aGF0IGFyZSB0YWJiYWJsZSBhbmQgYWRkcyB0aGVtIHRvIHRoZSBgcmVzdWx0YCBhcnJheS5cbiAqIFJldHVybnMgaWYgdGhlIGByZXN1bHRgIGFycmF5IG5lZWRzIHRvIGJlIHNvcnRlZCBieSB0YWJpbmRleC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgc2VhcmNoOyBhZGRlZCB0byBgcmVzdWx0YCBpZiB0YWJiYWJsZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29sbGVjdEZvY3VzYWJsZU5vZGVzKG5vZGUsIHJlc3VsdCkge1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgfHwgaXNFbGVtZW50SGlkZGVuRGlyZWN0bHkobm9kZSkpIHtcbiAgICAvLyBEb24ndCB0cmF2ZXJzZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBpcyBub3QgYW4gSFRNTCBlbGVtZW50IG9yIG5vdCB2aXNpYmxlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSk7XG4gIGNvbnN0IHRhYkluZGV4ID0gbm9ybWFsaXplVGFiSW5kZXgoZWxlbWVudCk7XG4gIGxldCBuZWVkc1NvcnQgPSB0YWJJbmRleCA+IDA7XG4gIGlmICh0YWJJbmRleCA+PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gIH1cblxuICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICBjaGlsZHJlbiA9IGVsZW1lbnQuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIHNoYWRvdyByb290IGlmIHBvc3NpYmxlLCB3aWxsIGNoZWNrIGZvciBkaXN0cmlidXRlZCBub2Rlcy5cbiAgICBjaGlsZHJlbiA9IChlbGVtZW50LnNoYWRvd1Jvb3QgfHwgZWxlbWVudCkuY2hpbGRyZW47XG4gIH1cbiAgWy4uLmNoaWxkcmVuXS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIC8vIEVuc3VyZSBtZXRob2QgaXMgYWx3YXlzIGludm9rZWQgdG8gY29sbGVjdCBmb2N1c2FibGUgY2hpbGRyZW4uXG4gICAgbmVlZHNTb3J0ID0gY29sbGVjdEZvY3VzYWJsZU5vZGVzKGNoaWxkLCByZXN1bHQpIHx8IG5lZWRzU29ydDtcbiAgfSk7XG4gIHJldHVybiBuZWVkc1NvcnQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRlbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEFuIGVsZW1lbnQgaXMgdHJlYXRlZCBhcyBoaWRkZW4gd2hlbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAtIHRoZSBlbGVtZW50IGl0c2VsZiBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgYGRpc3BsYXk6IG5vbmVgLlxuICogLSB0aGUgZWxlbWVudCBoYXMgb3IgaW5oZXJpdHMgYHZpc2liaWxpdHk6IGhpZGRlbmAuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudEhpZGRlbihlbGVtZW50KSB7XG4gIC8vIGBvZmZzZXRQYXJlbnRgIGlzIGBudWxsYCB3aGVuIHRoZSBlbGVtZW50IGl0c2VsZlxuICAvLyBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBpcyBoaWRkZW4gd2l0aCBgZGlzcGxheTogbm9uZWAuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudC9vZmZzZXRQYXJlbnRcbiAgaWYgKGVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gaXNFbGVtZW50SGlkZGVuRGlyZWN0bHkoZWxlbWVudCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGZvY3VzYWJsZSwgb3RoZXJ3aXNlIGZhbHNlLlxuICpcbiAqIFRoZSBsaXN0IG9mIGZvY3VzYWJsZSBlbGVtZW50cyBpcyB0YWtlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MDAxOTQvNDIyODcwMy5cbiAqIEhvd2V2ZXIsIHRoZXJlIGlzbid0IGEgZGVmaW5pdGUgbGlzdCwgaXQncyB1cCB0byB0aGUgYnJvd3Nlci5cbiAqIFRoZSBvbmx5IHN0YW5kYXJkIHdlIGhhdmUgaXMgRE9NIExldmVsIDIgSFRNTCBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwsXG4gKiBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIG9ubHkgZWxlbWVudHMgdGhhdCBoYXZlIGEgYGZvY3VzKClgIG1ldGhvZCBhcmU6XG4gKiAtIEhUTUxJbnB1dEVsZW1lbnRcbiAqIC0gSFRNTFNlbGVjdEVsZW1lbnRcbiAqIC0gSFRNTFRleHRBcmVhRWxlbWVudFxuICogLSBIVE1MQW5jaG9yRWxlbWVudFxuICpcbiAqIFRoaXMgbm90YWJseSBvbWl0cyBIVE1MQnV0dG9uRWxlbWVudCBhbmQgSFRNTEFyZWFFbGVtZW50LlxuICogUmVmZXJyaW5nIHRvIHRoZXNlIHRlc3RzIHdpdGggdGFiYmFibGVzIGluIGRpZmZlcmVudCBicm93c2Vyc1xuICogaHR0cDovL2FsbHlqcy5pby9kYXRhLXRhYmxlcy9mb2N1c2FibGUuaHRtbFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnRGb2N1c2FibGUoZWxlbWVudCkge1xuICAvLyBUaGUgZWxlbWVudCBjYW5ub3QgYmUgZm9jdXNlZCBpZiBpdHMgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaXMgc2V0IHRvIGAtMWAuXG4gIGlmIChlbGVtZW50Lm1hdGNoZXMoJ1t0YWJpbmRleD1cIi0xXCJdJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFbGVtZW50cyB0aGF0IGNhbm5vdCBiZSBmb2N1c2VkIGlmIHRoZXkgaGF2ZSBhIGBkaXNhYmxlZGAgYXR0cmlidXRlLlxuICBpZiAoZWxlbWVudC5tYXRjaGVzKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYnV0dG9uLCBvYmplY3QnKSkge1xuICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoJzpub3QoW2Rpc2FibGVkXSknKTtcbiAgfVxuXG4gIC8vIEVsZW1lbnRzIHRoYXQgY2FuIGJlIGZvY3VzZWQgZXZlbiBpZiB0aGV5IGhhdmUgYSBgZGlzYWJsZWRgIGF0dHJpYnV0ZS5cbiAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcygnYVtocmVmXSwgYXJlYVtocmVmXSwgaWZyYW1lLCBbdGFiaW5kZXhdLCBbY29udGVudEVkaXRhYmxlXScpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBmb2N1c2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudEZvY3VzZWQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRSb290Tm9kZSgpLmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHRhYi1vcmRlcmVkIGFycmF5IG9mIGZvY3VzYWJsZSBlbGVtZW50cyBmb3IgYSByb290IGVsZW1lbnQuXG4gKiBUaGUgcmVzdWx0aW5nIGFycmF5IHdpbGwgaW5jbHVkZSB0aGUgcm9vdCBlbGVtZW50IGlmIGl0IGlzIGZvY3VzYWJsZS5cbiAqXG4gKiBUaGUgbWV0aG9kIHRyYXZlcnNlcyBub2RlcyBpbiBzaGFkb3cgRE9NIHRyZWVzIHRvbyBpZiBhbnkuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvY3VzYWJsZUVsZW1lbnRzKGVsZW1lbnQpIHtcbiAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBbXTtcbiAgY29uc3QgbmVlZHNTb3J0QnlUYWJJbmRleCA9IGNvbGxlY3RGb2N1c2FibGVOb2RlcyhlbGVtZW50LCBmb2N1c2FibGVFbGVtZW50cyk7XG4gIC8vIElmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbGVtZW50IHdpdGggdGFiaW5kZXggPiAwLCB3ZSBuZWVkIHRvIHNvcnRcbiAgLy8gdGhlIGZpbmFsIGFycmF5IGJ5IHRhYmluZGV4LuKJiFxuICBpZiAobmVlZHNTb3J0QnlUYWJJbmRleCkge1xuICAgIHJldHVybiBzb3J0RWxlbWVudHNCeVRhYkluZGV4KGZvY3VzYWJsZUVsZW1lbnRzKTtcbiAgfVxuICByZXR1cm4gZm9jdXNhYmxlRWxlbWVudHM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/focus-utils.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/iron-list-core.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/iron-list-core.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ironList\": () => (/* binding */ ironList)\n/* harmony export */ });\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async.js */ \"./node_modules/@vaadin/component-base/src/async.js\");\n/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debounce.js */ \"./node_modules/@vaadin/component-base/src/debounce.js\");\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * DO NOT EDIT THIS FILE!\n *\n * This file includes the iron-list scrolling engine copied from\n * https://github.com/PolymerElements/iron-list/blob/master/iron-list.js\n *\n * If something in the scrolling engine needs to be changed\n * for the virtualizer's purposes, override a function\n * in virtualizer-iron-list-adapter.js instead of changing it here.\n * If a function on this file is no longer needed, the code can be safely deleted.\n *\n * This will allow us to keep the iron-list code here as close to\n * the original as possible.\n */\nconst ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    return this._physicalSize - this._viewportHeight;\n  },\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    const virtualCount = this._virtualCount;\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    this._virtualStartVal = val;\n  },\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val %= this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    this._physicalStartVal = val;\n  },\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    let idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      idx = this._iterateItems((pidx, vidx) => {\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n        if (physicalOffset > this._scrollPosition) {\n          return vidx;\n        }\n      }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    let idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      this._iterateItems((pidx, vidx) => {\n        if (physicalOffset < this._scrollBottom) {\n          idx = vidx;\n        }\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n      });\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler() {\n    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    let delta = scrollTop - this._scrollPosition;\n    const isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta -= this._scrollOffset;\n      const idxAdjustment = Math.round(delta / this._physicalAverage);\n      this._virtualStart += idxAdjustment;\n      this._physicalStart += idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      const reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart += reusables.indexes.length;\n        this._physicalStart += reusables.indexes.length;\n      } else {\n        this._virtualStart -= reusables.indexes.length;\n        this._physicalStart -= reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), _async_js__WEBPACK_IMPORTED_MODULE_0__.microTask);\n    }\n  },\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables(fromTop) {\n    let ith, offsetContent, physicalItemHeight;\n    const idxs = [];\n    const protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    const virtualStart = this._virtualStart;\n    const virtualEnd = this._virtualEnd;\n    const physicalCount = this._physicalCount;\n    let top = this._physicalTop + this._scrollOffset;\n    const bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    const scrollTop = this._scrollPosition;\n    const scrollBottom = this._scrollBottom;\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent -= physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top += physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top -= physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return {\n      indexes: idxs,\n      physicalTop: top - this._scrollOffset\n    };\n  },\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update(itemSet, movingUp) {\n    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {\n      return;\n    }\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        const idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n  _isClientFull() {\n    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;\n  },\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded(count) {\n    const nextPhysicalCount = this._clamp(this._physicalCount + count, DEFAULT_PHYSICAL_COUNT, this._virtualCount - this._virtualStart);\n    const delta = nextPhysicalCount - this._physicalCount;\n    let nextIncrease = Math.round(this._physicalCount * 0.5);\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      const ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (let i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount += delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {\n        this._physicalStart += delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), _async_js__WEBPACK_IMPORTED_MODULE_0__.microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)), _async_js__WEBPACK_IMPORTED_MODULE_0__.idlePeriod);\n    }\n  },\n  /**\n   * Renders the a new list.\n   */\n  _render() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      const reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart += reusables.indexes.length;\n      this._physicalStart += reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      this._physicalCount = this._physicalCount || 0;\n      this._physicalItems = this._physicalItems || [];\n      this._physicalSizes = this._physicalSizes || [];\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._debounce('_render', this._render, _async_js__WEBPACK_IMPORTED_MODULE_0__.animationFrame);\n    }\n  },\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems(fn, itemSet) {\n    let pidx, vidx, rtn, i;\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems() {\n    this._adjustScrollPosition();\n    let y = this._physicalTop;\n    this._iterateItems(pidx => {\n      this.translate3d(0, `${y}px`, 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n  _getPhysicalSizeIncrement(pidx) {\n    return this._physicalSizes[pidx];\n  },\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition() {\n    const deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop -= deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      const scrollTop = this._scrollPosition;\n      // Juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize(forceUpdate) {\n    this._estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n    forceUpdate = forceUpdate || this._scrollHeight === 0;\n    forceUpdate = forceUpdate || this._scrollPosition >= this._estScrollHeight - this._physicalSize;\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate || Math.abs(this._estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = `${this._estScrollHeight}px`;\n      this._scrollHeight = this._estScrollHeight;\n    }\n  },\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__.flush)();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = idx - 1;\n    }\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = this._virtualStart * this._physicalAverage;\n    let currentTopItem = this._physicalStart;\n    let currentVirtualItem = this._virtualStart;\n    let targetOffsetTop = 0;\n    const hiddenContentSize = this._hiddenContentSize;\n    // Scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem += 1;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // Clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler() {\n    this._debounce('_render', () => {\n      // Clear cached visible index.\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (this._isVisible) {\n        this.updateViewportBoundaries();\n        // Reinstall the scroll event listener.\n        this.toggleScrollListener(true);\n        this._resetAverage();\n        this._render();\n      } else {\n        // Uninstall the scroll event listener.\n        this.toggleScrollListener(false);\n      }\n    }, _async_js__WEBPACK_IMPORTED_MODULE_0__.animationFrame);\n  },\n  _isIndexRendered(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n  _getPhysicalIndex(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n  _clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n  _debounce(name, cb, asyncModule) {\n    this._debouncers = this._debouncers || {};\n    this._debouncers[name] = _debounce_js__WEBPACK_IMPORTED_MODULE_1__.Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__.enqueueDebouncer)(this._debouncers[name]);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvaXJvbi1saXN0LWNvcmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvaXJvbi1saXN0LWNvcmUuanM/NWY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IGFuaW1hdGlvbkZyYW1lLCBpZGxlUGVyaW9kLCBtaWNyb1Rhc2sgfSBmcm9tICcuL2FzeW5jLmpzJztcbmltcG9ydCB7IERlYm91bmNlciwgZW5xdWV1ZURlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuL2RlYm91bmNlLmpzJztcblxuY29uc3QgSU9TID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVAoPzpob25lfGFkOyg/OiBVOyk/IENQVSkgT1MgKFxcZCspLyk7XG5jb25zdCBJT1NfVE9VQ0hfU0NST0xMSU5HID0gSU9TICYmIElPU1sxXSA+PSA4O1xuY29uc3QgREVGQVVMVF9QSFlTSUNBTF9DT1VOVCA9IDM7XG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFIVxuICpcbiAqIFRoaXMgZmlsZSBpbmNsdWRlcyB0aGUgaXJvbi1saXN0IHNjcm9sbGluZyBlbmdpbmUgY29waWVkIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyRWxlbWVudHMvaXJvbi1saXN0L2Jsb2IvbWFzdGVyL2lyb24tbGlzdC5qc1xuICpcbiAqIElmIHNvbWV0aGluZyBpbiB0aGUgc2Nyb2xsaW5nIGVuZ2luZSBuZWVkcyB0byBiZSBjaGFuZ2VkXG4gKiBmb3IgdGhlIHZpcnR1YWxpemVyJ3MgcHVycG9zZXMsIG92ZXJyaWRlIGEgZnVuY3Rpb25cbiAqIGluIHZpcnR1YWxpemVyLWlyb24tbGlzdC1hZGFwdGVyLmpzIGluc3RlYWQgb2YgY2hhbmdpbmcgaXQgaGVyZS5cbiAqIElmIGEgZnVuY3Rpb24gb24gdGhpcyBmaWxlIGlzIG5vIGxvbmdlciBuZWVkZWQsIHRoZSBjb2RlIGNhbiBiZSBzYWZlbHkgZGVsZXRlZC5cbiAqXG4gKiBUaGlzIHdpbGwgYWxsb3cgdXMgdG8ga2VlcCB0aGUgaXJvbi1saXN0IGNvZGUgaGVyZSBhcyBjbG9zZSB0b1xuICogdGhlIG9yaWdpbmFsIGFzIHBvc3NpYmxlLlxuICovXG5leHBvcnQgY29uc3QgaXJvbkxpc3QgPSB7XG4gIC8qKlxuICAgKiBUaGUgcmF0aW8gb2YgaGlkZGVuIHRpbGVzIHRoYXQgc2hvdWxkIHJlbWFpbiBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbi5cbiAgICogUmVjb21tZW5kZWQgdmFsdWUgfjAuNSwgc28gaXQgd2lsbCBkaXN0cmlidXRlIHRpbGVzIGV2ZW5seSBpbiBib3RoXG4gICAqIGRpcmVjdGlvbnMuXG4gICAqL1xuICBfcmF0aW86IDAuNSxcblxuICAvKipcbiAgICogVGhlIHBhZGRpbmctdG9wIHZhbHVlIGZvciB0aGUgbGlzdC5cbiAgICovXG4gIF9zY3JvbGxlclBhZGRpbmdUb3A6IDAsXG5cbiAgLyoqXG4gICAqIFRoaXMgdmFsdWUgaXMgYSBjYWNoZWQgdmFsdWUgb2YgYHNjcm9sbFRvcGAgZnJvbSB0aGUgbGFzdCBgc2Nyb2xsYCBldmVudC5cbiAgICovXG4gIF9zY3JvbGxQb3NpdGlvbjogMCxcblxuICAvKipcbiAgICogVGhlIHN1bSBvZiB0aGUgaGVpZ2h0cyBvZiBhbGwgdGhlIHRpbGVzIGluIHRoZSBET00uXG4gICAqL1xuICBfcGh5c2ljYWxTaXplOiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgYXZlcmFnZSBgb2Zmc2V0SGVpZ2h0YCBvZiB0aGUgdGlsZXMgb2JzZXJ2ZWQgdGlsbCBub3cuXG4gICAqL1xuICBfcGh5c2ljYWxBdmVyYWdlOiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHRpbGVzIHdoaWNoIGBvZmZzZXRIZWlnaHRgID4gMCBvYnNlcnZlZCB1bnRpbCBub3cuXG4gICAqL1xuICBfcGh5c2ljYWxBdmVyYWdlQ291bnQ6IDAsXG5cbiAgLyoqXG4gICAqIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHJlbmRlcmVkIGluIHRoZSBgX3BoeXNpY2FsU3RhcnRgXG4gICAqIHRpbGUgcmVsYXRpdmUgdG8gdGhlIHNjcm9sbGluZyBsaXN0LlxuICAgKi9cbiAgX3BoeXNpY2FsVG9wOiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0LlxuICAgKi9cbiAgX3ZpcnR1YWxDb3VudDogMCxcblxuICAvKipcbiAgICogVGhlIGVzdGltYXRlZCBzY3JvbGwgaGVpZ2h0IGJhc2VkIG9uIGBfcGh5c2ljYWxBdmVyYWdlYFxuICAgKi9cbiAgX2VzdFNjcm9sbEhlaWdodDogMCxcblxuICAvKipcbiAgICogVGhlIHNjcm9sbCBoZWlnaHQgb2YgdGhlIGRvbSBub2RlXG4gICAqL1xuICBfc2Nyb2xsSGVpZ2h0OiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBsaXN0LiBUaGlzIGlzIHJlZmVycmVkIGFzIHRoZSB2aWV3cG9ydCBpbiB0aGUgY29udGV4dCBvZlxuICAgKiBsaXN0LlxuICAgKi9cbiAgX3ZpZXdwb3J0SGVpZ2h0OiAwLFxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIGxpc3QuIFRoaXMgaXMgcmVmZXJyZWQgYXMgdGhlIHZpZXdwb3J0IGluIHRoZSBjb250ZXh0IG9mXG4gICAqIGxpc3QuXG4gICAqL1xuICBfdmlld3BvcnRXaWR0aDogMCxcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgRE9NIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiB0aGUgdHJlZVxuICAgKiBAdHlwZSB7P0FycmF5PCFIVE1MRWxlbWVudD59XG4gICAqL1xuICBfcGh5c2ljYWxJdGVtczogbnVsbCxcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgaGVpZ2h0cyBmb3IgZWFjaCBpdGVtIGluIGBfcGh5c2ljYWxJdGVtc2BcbiAgICogQHR5cGUgez9BcnJheTxudW1iZXI+fVxuICAgKi9cbiAgX3BoeXNpY2FsU2l6ZXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEEgY2FjaGVkIHZhbHVlIGZvciB0aGUgZmlyc3QgdmlzaWJsZSBpbmRleC5cbiAgICogU2VlIGBmaXJzdFZpc2libGVJbmRleGBcbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqL1xuICBfZmlyc3RWaXNpYmxlSW5kZXhWYWw6IG51bGwsXG5cbiAgLyoqXG4gICAqIEEgY2FjaGVkIHZhbHVlIGZvciB0aGUgbGFzdCB2aXNpYmxlIGluZGV4LlxuICAgKiBTZWUgYGxhc3RWaXNpYmxlSW5kZXhgXG4gICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgKi9cbiAgX2xhc3RWaXNpYmxlSW5kZXhWYWw6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRoZSBtYXggbnVtYmVyIG9mIHBhZ2VzIHRvIHJlbmRlci4gT25lIHBhZ2UgaXMgZXF1aXZhbGVudCB0byB0aGUgaGVpZ2h0IG9mXG4gICAqIHRoZSBsaXN0LlxuICAgKi9cbiAgX21heFBhZ2VzOiAyLFxuXG4gIC8qKlxuICAgKiBUaGUgY29zdCBvZiBzdGFtcGluZyBhIHRlbXBsYXRlIGluIG1zLlxuICAgKi9cbiAgX3RlbXBsYXRlQ29zdDogMCxcblxuICAvKipcbiAgICogVGhlIGJvdHRvbSBvZiB0aGUgcGh5c2ljYWwgY29udGVudC5cbiAgICovXG4gIGdldCBfcGh5c2ljYWxCb3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsVG9wICsgdGhpcy5fcGh5c2ljYWxTaXplO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYm90dG9tIG9mIHRoZSBzY3JvbGwuXG4gICAqL1xuICBnZXQgX3Njcm9sbEJvdHRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3cG9ydEhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIG4tdGggaXRlbSByZW5kZXJlZCBpbiB0aGUgbGFzdCBwaHlzaWNhbCBpdGVtLlxuICAgKi9cbiAgZ2V0IF92aXJ0dWFsRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl92aXJ0dWFsU3RhcnQgKyB0aGlzLl9waHlzaWNhbENvdW50IC0gMTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgcGh5c2ljYWwgY29udGVudCB0aGF0IGlzbid0IG9uIHRoZSBzY3JlZW4uXG4gICAqL1xuICBnZXQgX2hpZGRlbkNvbnRlbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9waHlzaWNhbFNpemUgLSB0aGlzLl92aWV3cG9ydEhlaWdodDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gc2Nyb2xsIHRvcCB2YWx1ZS5cbiAgICovXG4gIGdldCBfbWF4U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9lc3RTY3JvbGxIZWlnaHQgLSB0aGlzLl92aWV3cG9ydEhlaWdodCArIHRoaXMuX3Njcm9sbE9mZnNldDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGxhcmdlc3Qgbi10aCB2YWx1ZSBmb3IgYW4gaXRlbSBzdWNoIHRoYXQgaXQgY2FuIGJlIHJlbmRlcmVkIGluXG4gICAqIGBfcGh5c2ljYWxTdGFydGAuXG4gICAqL1xuICBnZXQgX21heFZpcnR1YWxTdGFydCgpIHtcbiAgICBjb25zdCB2aXJ0dWFsQ291bnQgPSB0aGlzLl92aXJ0dWFsQ291bnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHZpcnR1YWxDb3VudCAtIHRoaXMuX3BoeXNpY2FsQ291bnQpO1xuICB9LFxuXG4gIGdldCBfdmlydHVhbFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl92aXJ0dWFsU3RhcnRWYWwgfHwgMDtcbiAgfSxcblxuICBzZXQgX3ZpcnR1YWxTdGFydCh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLl9jbGFtcCh2YWwsIDAsIHRoaXMuX21heFZpcnR1YWxTdGFydCk7XG4gICAgdGhpcy5fdmlydHVhbFN0YXJ0VmFsID0gdmFsO1xuICB9LFxuXG4gIGdldCBfcGh5c2ljYWxTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGh5c2ljYWxTdGFydFZhbCB8fCAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgay10aCB0aWxlIHRoYXQgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc2Nyb2xsaW5nIGxpc3QuXG4gICAqL1xuICBzZXQgX3BoeXNpY2FsU3RhcnQodmFsKSB7XG4gICAgdmFsICU9IHRoaXMuX3BoeXNpY2FsQ291bnQ7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgIHZhbCA9IHRoaXMuX3BoeXNpY2FsQ291bnQgKyB2YWw7XG4gICAgfVxuICAgIHRoaXMuX3BoeXNpY2FsU3RhcnRWYWwgPSB2YWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBrLXRoIHRpbGUgdGhhdCBpcyBhdCB0aGUgYm90dG9tIG9mIHRoZSBzY3JvbGxpbmcgbGlzdC5cbiAgICovXG4gIGdldCBfcGh5c2ljYWxFbmQoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9waHlzaWNhbFN0YXJ0ICsgdGhpcy5fcGh5c2ljYWxDb3VudCAtIDEpICUgdGhpcy5fcGh5c2ljYWxDb3VudDtcbiAgfSxcblxuICBnZXQgX3BoeXNpY2FsQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsQ291bnRWYWwgfHwgMDtcbiAgfSxcblxuICBzZXQgX3BoeXNpY2FsQ291bnQodmFsKSB7XG4gICAgdGhpcy5fcGh5c2ljYWxDb3VudFZhbCA9IHZhbDtcbiAgfSxcblxuICAvKipcbiAgICogQW4gb3B0aW1hbCBwaHlzaWNhbCBzaXplIHN1Y2ggdGhhdCB3ZSB3aWxsIGhhdmUgZW5vdWdoIHBoeXNpY2FsIGl0ZW1zXG4gICAqIHRvIGZpbGwgdXAgdGhlIHZpZXdwb3J0IGFuZCByZWN5Y2xlIHdoZW4gdGhlIHVzZXIgc2Nyb2xscy5cbiAgICpcbiAgICogVGhpcyBkZWZhdWx0IHZhbHVlIGFzc3VtZXMgdGhhdCB3ZSB3aWxsIGF0IGxlYXN0IGhhdmUgdGhlIGVxdWl2YWxlbnRcbiAgICogdG8gYSB2aWV3cG9ydCBvZiBwaHlzaWNhbCBpdGVtcyBhYm92ZSBhbmQgYmVsb3cgdGhlIHVzZXIncyB2aWV3cG9ydC5cbiAgICovXG4gIGdldCBfb3B0UGh5c2ljYWxTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydEhlaWdodCA9PT0gMCA/IEluZmluaXR5IDogdGhpcy5fdmlld3BvcnRIZWlnaHQgKiB0aGlzLl9tYXhQYWdlcztcbiAgfSxcblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgY3VycmVudCBsaXN0IGlzIHZpc2libGUuXG4gICAqL1xuICBnZXQgX2lzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9mZnNldFdpZHRoIHx8IHRoaXMub2Zmc2V0SGVpZ2h0KTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHZpc2libGUgaXRlbSBpbiB0aGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZmlyc3RWaXNpYmxlSW5kZXgoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMuX2ZpcnN0VmlzaWJsZUluZGV4VmFsO1xuICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgbGV0IHBoeXNpY2FsT2Zmc2V0ID0gdGhpcy5fcGh5c2ljYWxUb3AgKyB0aGlzLl9zY3JvbGxPZmZzZXQ7XG5cbiAgICAgIGlkeCA9XG4gICAgICAgIHRoaXMuX2l0ZXJhdGVJdGVtcygocGlkeCwgdmlkeCkgPT4ge1xuICAgICAgICAgIHBoeXNpY2FsT2Zmc2V0ICs9IHRoaXMuX2dldFBoeXNpY2FsU2l6ZUluY3JlbWVudChwaWR4KTtcblxuICAgICAgICAgIGlmIChwaHlzaWNhbE9mZnNldCA+IHRoaXMuX3Njcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlkeDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHx8IDA7XG4gICAgICB0aGlzLl9maXJzdFZpc2libGVJbmRleFZhbCA9IGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdmlzaWJsZSBpdGVtIGluIHRoZSB2aWV3cG9ydC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBsYXN0VmlzaWJsZUluZGV4KCkge1xuICAgIGxldCBpZHggPSB0aGlzLl9sYXN0VmlzaWJsZUluZGV4VmFsO1xuICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgbGV0IHBoeXNpY2FsT2Zmc2V0ID0gdGhpcy5fcGh5c2ljYWxUb3AgKyB0aGlzLl9zY3JvbGxPZmZzZXQ7XG4gICAgICB0aGlzLl9pdGVyYXRlSXRlbXMoKHBpZHgsIHZpZHgpID0+IHtcbiAgICAgICAgaWYgKHBoeXNpY2FsT2Zmc2V0IDwgdGhpcy5fc2Nyb2xsQm90dG9tKSB7XG4gICAgICAgICAgaWR4ID0gdmlkeDtcbiAgICAgICAgfVxuICAgICAgICBwaHlzaWNhbE9mZnNldCArPSB0aGlzLl9nZXRQaHlzaWNhbFNpemVJbmNyZW1lbnQocGlkeCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fbGFzdFZpc2libGVJbmRleFZhbCA9IGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfSxcblxuICBnZXQgX3Njcm9sbE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsZXJQYWRkaW5nVG9wICsgdGhpcy5zY3JvbGxPZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY3ljbGVzIHRoZSBwaHlzaWNhbCBpdGVtcyB3aGVuIG5lZWRlZC5cbiAgICovXG4gIF9zY3JvbGxIYW5kbGVyKCkge1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX21heFNjcm9sbFRvcCwgdGhpcy5fc2Nyb2xsVG9wKSk7XG4gICAgbGV0IGRlbHRhID0gc2Nyb2xsVG9wIC0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgY29uc3QgaXNTY3JvbGxpbmdEb3duID0gZGVsdGEgPj0gMDtcbiAgICAvLyBUcmFjayB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24uXG4gICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxUb3A7XG4gICAgLy8gQ2xlYXIgaW5kZXhlcyBmb3IgZmlyc3QgYW5kIGxhc3QgdmlzaWJsZSBpbmRleGVzLlxuICAgIHRoaXMuX2ZpcnN0VmlzaWJsZUluZGV4VmFsID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0VmlzaWJsZUluZGV4VmFsID0gbnVsbDtcbiAgICAvLyBSYW5kb20gYWNjZXNzLlxuICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiB0aGlzLl9waHlzaWNhbFNpemUgJiYgdGhpcy5fcGh5c2ljYWxTaXplID4gMCkge1xuICAgICAgZGVsdGEgLT0gdGhpcy5fc2Nyb2xsT2Zmc2V0O1xuICAgICAgY29uc3QgaWR4QWRqdXN0bWVudCA9IE1hdGgucm91bmQoZGVsdGEgLyB0aGlzLl9waHlzaWNhbEF2ZXJhZ2UpO1xuICAgICAgdGhpcy5fdmlydHVhbFN0YXJ0ICs9IGlkeEFkanVzdG1lbnQ7XG4gICAgICB0aGlzLl9waHlzaWNhbFN0YXJ0ICs9IGlkeEFkanVzdG1lbnQ7XG4gICAgICAvLyBFc3RpbWF0ZSBuZXcgcGh5c2ljYWwgb2Zmc2V0IGJhc2VkIG9uIHRoZSB2aXJ0dWFsIHN0YXJ0IGluZGV4LlxuICAgICAgLy8gYWRqdXN0cyB0aGUgcGh5c2ljYWwgc3RhcnQgcG9zaXRpb24gdG8gc3RheSBpbiBzeW5jIHdpdGggdGhlIGNsYW1wZWRcbiAgICAgIC8vIHZpcnR1YWwgc3RhcnQgaW5kZXguIEl0J3MgY3JpdGljYWwgbm90IHRvIGxldCB0aGlzIHZhbHVlIGJlXG4gICAgICAvLyBtb3JlIHRoYW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBob3dldmVyLCBzaW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBpblxuICAgICAgLy8gdGhlIHBoeXNpY2FsIGl0ZW1zIG5vdCBjb3ZlcmluZyB0aGUgdmlld3BvcnQsIGFuZCBsZWFkaW5nIHRvXG4gICAgICAvLyBfaW5jcmVhc2VQb29sSWZOZWVkZWQgdG8gcnVuIGF3YXkgY3JlYXRpbmcgaXRlbXMgdG8gdHJ5IHRvIGZpbGwgaXQuXG4gICAgICB0aGlzLl9waHlzaWNhbFRvcCA9IE1hdGgubWluKE1hdGguZmxvb3IodGhpcy5fdmlydHVhbFN0YXJ0KSAqIHRoaXMuX3BoeXNpY2FsQXZlcmFnZSwgdGhpcy5fc2Nyb2xsUG9zaXRpb24pO1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9waHlzaWNhbENvdW50ID4gMCkge1xuICAgICAgY29uc3QgcmV1c2FibGVzID0gdGhpcy5fZ2V0UmV1c2FibGVzKGlzU2Nyb2xsaW5nRG93bik7XG4gICAgICBpZiAoaXNTY3JvbGxpbmdEb3duKSB7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsVG9wID0gcmV1c2FibGVzLnBoeXNpY2FsVG9wO1xuICAgICAgICB0aGlzLl92aXJ0dWFsU3RhcnQgKz0gcmV1c2FibGVzLmluZGV4ZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9waHlzaWNhbFN0YXJ0ICs9IHJldXNhYmxlcy5pbmRleGVzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxTdGFydCAtPSByZXVzYWJsZXMuaW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsU3RhcnQgLT0gcmV1c2FibGVzLmluZGV4ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlKHJldXNhYmxlcy5pbmRleGVzLCBpc1Njcm9sbGluZ0Rvd24gPyBudWxsIDogcmV1c2FibGVzLmluZGV4ZXMpO1xuICAgICAgdGhpcy5fZGVib3VuY2UoJ19pbmNyZWFzZVBvb2xJZk5lZWRlZCcsIHRoaXMuX2luY3JlYXNlUG9vbElmTmVlZGVkLmJpbmQodGhpcywgMCksIG1pY3JvVGFzayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBpbmRleGVzIG9mIHRoZSBwaHlzaWNhbCBpdGVtc1xuICAgKiB0aGF0IG1pZ2h0IGJlIHJldXNlZCBhbmQgdGhlIHBoeXNpY2FsVG9wLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZyb21Ub3AgSWYgdGhlIHBvdGVudGlhbCByZXVzYWJsZSBpdGVtcyBhcmUgYWJvdmUgdGhlIHNjcm9sbGluZyByZWdpb24uXG4gICAqL1xuICBfZ2V0UmV1c2FibGVzKGZyb21Ub3ApIHtcbiAgICBsZXQgaXRoLCBvZmZzZXRDb250ZW50LCBwaHlzaWNhbEl0ZW1IZWlnaHQ7XG4gICAgY29uc3QgaWR4cyA9IFtdO1xuICAgIGNvbnN0IHByb3RlY3RlZE9mZnNldENvbnRlbnQgPSB0aGlzLl9oaWRkZW5Db250ZW50U2l6ZSAqIHRoaXMuX3JhdGlvO1xuICAgIGNvbnN0IHZpcnR1YWxTdGFydCA9IHRoaXMuX3ZpcnR1YWxTdGFydDtcbiAgICBjb25zdCB2aXJ0dWFsRW5kID0gdGhpcy5fdmlydHVhbEVuZDtcbiAgICBjb25zdCBwaHlzaWNhbENvdW50ID0gdGhpcy5fcGh5c2ljYWxDb3VudDtcbiAgICBsZXQgdG9wID0gdGhpcy5fcGh5c2ljYWxUb3AgKyB0aGlzLl9zY3JvbGxPZmZzZXQ7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy5fcGh5c2ljYWxCb3R0b20gKyB0aGlzLl9zY3JvbGxPZmZzZXQ7XG4gICAgLy8gVGhpcyBtYXkgYmUgY2FsbGVkIG91dHNpZGUgb2YgYSBzY3JvbGxIYW5kbGVyLCBzbyB1c2UgbGFzdCBjYWNoZWQgcG9zaXRpb25cbiAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCBzY3JvbGxCb3R0b20gPSB0aGlzLl9zY3JvbGxCb3R0b207XG5cbiAgICBpZiAoZnJvbVRvcCkge1xuICAgICAgaXRoID0gdGhpcy5fcGh5c2ljYWxTdGFydDtcbiAgICAgIG9mZnNldENvbnRlbnQgPSBzY3JvbGxUb3AgLSB0b3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0aCA9IHRoaXMuX3BoeXNpY2FsRW5kO1xuICAgICAgb2Zmc2V0Q29udGVudCA9IGJvdHRvbSAtIHNjcm9sbEJvdHRvbTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBwaHlzaWNhbEl0ZW1IZWlnaHQgPSB0aGlzLl9nZXRQaHlzaWNhbFNpemVJbmNyZW1lbnQoaXRoKTtcbiAgICAgIG9mZnNldENvbnRlbnQgLT0gcGh5c2ljYWxJdGVtSGVpZ2h0O1xuICAgICAgaWYgKGlkeHMubGVuZ3RoID49IHBoeXNpY2FsQ291bnQgfHwgb2Zmc2V0Q29udGVudCA8PSBwcm90ZWN0ZWRPZmZzZXRDb250ZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGZyb21Ub3ApIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBpbmRleCBpcyB3aXRoaW4gdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgICBpZiAodmlydHVhbEVuZCArIGlkeHMubGVuZ3RoICsgMSA+PSB0aGlzLl92aXJ0dWFsQ291bnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBpbmRleCBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKHRvcCArIHBoeXNpY2FsSXRlbUhlaWdodCA+PSBzY3JvbGxUb3AgLSB0aGlzLl9zY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZHhzLnB1c2goaXRoKTtcbiAgICAgICAgdG9wICs9IHBoeXNpY2FsSXRlbUhlaWdodDtcbiAgICAgICAgaXRoID0gKGl0aCArIDEpICUgcGh5c2ljYWxDb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgaW5kZXggaXMgd2l0aGluIHRoZSB2YWxpZCByYW5nZS5cbiAgICAgICAgaWYgKHZpcnR1YWxTdGFydCAtIGlkeHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBpbmRleCBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKHRvcCArIHRoaXMuX3BoeXNpY2FsU2l6ZSAtIHBoeXNpY2FsSXRlbUhlaWdodCA8PSBzY3JvbGxCb3R0b20pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZHhzLnB1c2goaXRoKTtcbiAgICAgICAgdG9wIC09IHBoeXNpY2FsSXRlbUhlaWdodDtcbiAgICAgICAgaXRoID0gaXRoID09PSAwID8gcGh5c2ljYWxDb3VudCAtIDEgOiBpdGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBpbmRleGVzOiBpZHhzLCBwaHlzaWNhbFRvcDogdG9wIC0gdGhpcy5fc2Nyb2xsT2Zmc2V0IH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBpdGVtcywgc3RhcnRpbmcgZnJvbSB0aGUgYF92aXJ0dWFsU3RhcnRgIGl0ZW0uXG4gICAqIEBwYXJhbSB7IUFycmF5PG51bWJlcj49fSBpdGVtU2V0XG4gICAqIEBwYXJhbSB7IUFycmF5PG51bWJlcj49fSBtb3ZpbmdVcFxuICAgKi9cbiAgX3VwZGF0ZShpdGVtU2V0LCBtb3ZpbmdVcCkge1xuICAgIGlmICgoaXRlbVNldCAmJiBpdGVtU2V0Lmxlbmd0aCA9PT0gMCkgfHwgdGhpcy5fcGh5c2ljYWxDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hc3NpZ25Nb2RlbHMoaXRlbVNldCk7XG4gICAgdGhpcy5fdXBkYXRlTWV0cmljcyhpdGVtU2V0KTtcbiAgICAvLyBBZGp1c3Qgb2Zmc2V0IGFmdGVyIG1lYXN1cmluZy5cbiAgICBpZiAobW92aW5nVXApIHtcbiAgICAgIHdoaWxlIChtb3ZpbmdVcC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gbW92aW5nVXAucG9wKCk7XG4gICAgICAgIHRoaXMuX3BoeXNpY2FsVG9wIC09IHRoaXMuX2dldFBoeXNpY2FsU2l6ZUluY3JlbWVudChpZHgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9wb3NpdGlvbkl0ZW1zKCk7XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsZXJTaXplKCk7XG4gIH0sXG5cbiAgX2lzQ2xpZW50RnVsbCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fc2Nyb2xsQm90dG9tICE9PSAwICYmXG4gICAgICB0aGlzLl9waHlzaWNhbEJvdHRvbSAtIDEgPj0gdGhpcy5fc2Nyb2xsQm90dG9tICYmXG4gICAgICB0aGlzLl9waHlzaWNhbFRvcCA8PSB0aGlzLl9zY3JvbGxQb3NpdGlvblxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluY3JlYXNlcyB0aGUgcG9vbCBzaXplLlxuICAgKi9cbiAgX2luY3JlYXNlUG9vbElmTmVlZGVkKGNvdW50KSB7XG4gICAgY29uc3QgbmV4dFBoeXNpY2FsQ291bnQgPSB0aGlzLl9jbGFtcChcbiAgICAgIHRoaXMuX3BoeXNpY2FsQ291bnQgKyBjb3VudCxcbiAgICAgIERFRkFVTFRfUEhZU0lDQUxfQ09VTlQsXG4gICAgICB0aGlzLl92aXJ0dWFsQ291bnQgLSB0aGlzLl92aXJ0dWFsU3RhcnQsXG4gICAgKTtcbiAgICBjb25zdCBkZWx0YSA9IG5leHRQaHlzaWNhbENvdW50IC0gdGhpcy5fcGh5c2ljYWxDb3VudDtcbiAgICBsZXQgbmV4dEluY3JlYXNlID0gTWF0aC5yb3VuZCh0aGlzLl9waHlzaWNhbENvdW50ICogMC41KTtcblxuICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgY29uc3QgdHMgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAvLyBDb25jYXQgYXJyYXlzIGluIHBsYWNlLlxuICAgICAgW10ucHVzaC5hcHBseSh0aGlzLl9waHlzaWNhbEl0ZW1zLCB0aGlzLl9jcmVhdGVQb29sKGRlbHRhKSk7XG4gICAgICAvLyBQdXNoIDBzIGludG8gcGh5c2ljYWxTaXplcy4gQ2FuJ3QgdXNlIEFycmF5LmZpbGwgYmVjYXVzZSBJRTExIGRvZXNuJ3RcbiAgICAgIC8vIHN1cHBvcnQgaXQuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcGh5c2ljYWxTaXplcy5wdXNoKDApO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGh5c2ljYWxDb3VudCArPSBkZWx0YTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcGh5c2ljYWwgc3RhcnQgaWYgaXQgbmVlZHMgdG8gcHJlc2VydmUgdGhlIG1vZGVsIG9mIHRoZVxuICAgICAgLy8gZm9jdXNlZCBpdGVtLiBJbiB0aGlzIHNpdHVhdGlvbiwgdGhlIGZvY3VzZWQgaXRlbSBpcyBjdXJyZW50bHkgcmVuZGVyZWRcbiAgICAgIC8vIGFuZCBpdHMgbW9kZWwgd291bGQgaGF2ZSBjaGFuZ2VkIGFmdGVyIGluY3JlYXNpbmcgdGhlIHBvb2wgaWYgdGhlXG4gICAgICAvLyBwaHlzaWNhbCBzdGFydCByZW1haW5lZCB1bmNoYW5nZWQuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX3BoeXNpY2FsU3RhcnQgPiB0aGlzLl9waHlzaWNhbEVuZCAmJlxuICAgICAgICB0aGlzLl9pc0luZGV4UmVuZGVyZWQodGhpcy5fZm9jdXNlZFZpcnR1YWxJbmRleCkgJiZcbiAgICAgICAgdGhpcy5fZ2V0UGh5c2ljYWxJbmRleCh0aGlzLl9mb2N1c2VkVmlydHVhbEluZGV4KSA8IHRoaXMuX3BoeXNpY2FsRW5kXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fcGh5c2ljYWxTdGFydCArPSBkZWx0YTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fdGVtcGxhdGVDb3N0ID0gKHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHRzKSAvIGRlbHRhO1xuICAgICAgbmV4dEluY3JlYXNlID0gTWF0aC5yb3VuZCh0aGlzLl9waHlzaWNhbENvdW50ICogMC41KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZpcnR1YWxFbmQgPj0gdGhpcy5fdmlydHVhbENvdW50IC0gMSB8fCBuZXh0SW5jcmVhc2UgPT09IDApIHtcbiAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNDbGllbnRGdWxsKCkpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlKCdfaW5jcmVhc2VQb29sSWZOZWVkZWQnLCB0aGlzLl9pbmNyZWFzZVBvb2xJZk5lZWRlZC5iaW5kKHRoaXMsIG5leHRJbmNyZWFzZSksIG1pY3JvVGFzayk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9waHlzaWNhbFNpemUgPCB0aGlzLl9vcHRQaHlzaWNhbFNpemUpIHtcbiAgICAgIC8vIFlpZWxkIGFuZCBpbmNyZWFzZSB0aGUgcG9vbCBkdXJpbmcgaWRsZSB0aW1lIHVudGlsIHRoZSBwaHlzaWNhbCBzaXplIGlzXG4gICAgICAvLyBvcHRpbWFsLlxuICAgICAgdGhpcy5fZGVib3VuY2UoXG4gICAgICAgICdfaW5jcmVhc2VQb29sSWZOZWVkZWQnLFxuICAgICAgICB0aGlzLl9pbmNyZWFzZVBvb2xJZk5lZWRlZC5iaW5kKHRoaXMsIHRoaXMuX2NsYW1wKE1hdGgucm91bmQoNTAgLyB0aGlzLl90ZW1wbGF0ZUNvc3QpLCAxLCBuZXh0SW5jcmVhc2UpKSxcbiAgICAgICAgaWRsZVBlcmlvZCxcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBhIG5ldyBsaXN0LlxuICAgKi9cbiAgX3JlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCB8fCAhdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9waHlzaWNhbENvdW50ICE9PSAwKSB7XG4gICAgICBjb25zdCByZXVzYWJsZXMgPSB0aGlzLl9nZXRSZXVzYWJsZXModHJ1ZSk7XG4gICAgICB0aGlzLl9waHlzaWNhbFRvcCA9IHJldXNhYmxlcy5waHlzaWNhbFRvcDtcbiAgICAgIHRoaXMuX3ZpcnR1YWxTdGFydCArPSByZXVzYWJsZXMuaW5kZXhlcy5sZW5ndGg7XG4gICAgICB0aGlzLl9waHlzaWNhbFN0YXJ0ICs9IHJldXNhYmxlcy5pbmRleGVzLmxlbmd0aDtcbiAgICAgIHRoaXMuX3VwZGF0ZShyZXVzYWJsZXMuaW5kZXhlcyk7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX2luY3JlYXNlUG9vbElmTmVlZGVkKDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdmlydHVhbENvdW50ID4gMCkge1xuICAgICAgLy8gSW5pdGlhbCByZW5kZXJcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLl9pbmNyZWFzZVBvb2xJZk5lZWRlZChERUZBVUxUX1BIWVNJQ0FMX0NPVU5UKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBpdGVtcyBoYXZlIGNoYW5nZWQuIFRoYXQgaXMsIHJlYXNzaWdubWVudHNcbiAgICogdG8gYGl0ZW1zYCwgc3BsaWNlcyBvciB1cGRhdGVzIHRvIGEgc2luZ2xlIGl0ZW0uXG4gICAqL1xuICBfaXRlbXNDaGFuZ2VkKGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UucGF0aCA9PT0gJ2l0ZW1zJykge1xuICAgICAgdGhpcy5fdmlydHVhbFN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuX3BoeXNpY2FsVG9wID0gMDtcbiAgICAgIHRoaXMuX3ZpcnR1YWxDb3VudCA9IHRoaXMuaXRlbXMgPyB0aGlzLml0ZW1zLmxlbmd0aCA6IDA7XG4gICAgICB0aGlzLl9waHlzaWNhbEluZGV4Rm9yS2V5ID0ge307XG4gICAgICB0aGlzLl9maXJzdFZpc2libGVJbmRleFZhbCA9IG51bGw7XG4gICAgICB0aGlzLl9sYXN0VmlzaWJsZUluZGV4VmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX3BoeXNpY2FsQ291bnQgPSB0aGlzLl9waHlzaWNhbENvdW50IHx8IDA7XG4gICAgICB0aGlzLl9waHlzaWNhbEl0ZW1zID0gdGhpcy5fcGh5c2ljYWxJdGVtcyB8fCBbXTtcbiAgICAgIHRoaXMuX3BoeXNpY2FsU2l6ZXMgPSB0aGlzLl9waHlzaWNhbFNpemVzIHx8IFtdO1xuICAgICAgdGhpcy5fcGh5c2ljYWxTdGFydCA9IDA7XG4gICAgICBpZiAodGhpcy5fc2Nyb2xsVG9wID4gdGhpcy5fc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0U2Nyb2xsUG9zaXRpb24oMCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kZWJvdW5jZSgnX3JlbmRlcicsIHRoaXMuX3JlbmRlciwgYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBwZXIgZXZlcnkgcGh5c2ljYWwgaW5kZXggaW4gYGl0ZW1TZXRgXG4gICAqIGBpdGVtU2V0YCBkZWZhdWx0IHZhbHVlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGVudGlyZSBzZXQgb2YgcGh5c2ljYWxcbiAgICogaW5kZXhlcy5cbiAgICpcbiAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpfSBmblxuICAgKiBAcGFyYW0geyFBcnJheTxudW1iZXI+PX0gaXRlbVNldFxuICAgKi9cbiAgX2l0ZXJhdGVJdGVtcyhmbiwgaXRlbVNldCkge1xuICAgIGxldCBwaWR4LCB2aWR4LCBydG4sIGk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiBpdGVtU2V0KSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwaWR4ID0gaXRlbVNldFtpXTtcbiAgICAgICAgdmlkeCA9IHRoaXMuX2NvbXB1dGVWaWR4KHBpZHgpO1xuICAgICAgICBpZiAoKHJ0biA9IGZuLmNhbGwodGhpcywgcGlkeCwgdmlkeCkpICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcnRuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpZHggPSB0aGlzLl9waHlzaWNhbFN0YXJ0O1xuICAgICAgdmlkeCA9IHRoaXMuX3ZpcnR1YWxTdGFydDtcbiAgICAgIGZvciAoOyBwaWR4IDwgdGhpcy5fcGh5c2ljYWxDb3VudDsgcGlkeCsrLCB2aWR4KyspIHtcbiAgICAgICAgaWYgKChydG4gPSBmbi5jYWxsKHRoaXMsIHBpZHgsIHZpZHgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJ0bjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChwaWR4ID0gMDsgcGlkeCA8IHRoaXMuX3BoeXNpY2FsU3RhcnQ7IHBpZHgrKywgdmlkeCsrKSB7XG4gICAgICAgIGlmICgocnRuID0gZm4uY2FsbCh0aGlzLCBwaWR4LCB2aWR4KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBydG47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZpcnR1YWwgaW5kZXggZm9yIGEgZ2l2ZW4gcGh5c2ljYWwgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpZHggUGh5c2ljYWwgaW5kZXhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgX2NvbXB1dGVWaWR4KHBpZHgpIHtcbiAgICBpZiAocGlkeCA+PSB0aGlzLl9waHlzaWNhbFN0YXJ0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlydHVhbFN0YXJ0ICsgKHBpZHggLSB0aGlzLl9waHlzaWNhbFN0YXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxTdGFydCArICh0aGlzLl9waHlzaWNhbENvdW50IC0gdGhpcy5fcGh5c2ljYWxTdGFydCkgKyBwaWR4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGh5c2ljYWwgaXRlbXMuXG4gICAqL1xuICBfcG9zaXRpb25JdGVtcygpIHtcbiAgICB0aGlzLl9hZGp1c3RTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgbGV0IHkgPSB0aGlzLl9waHlzaWNhbFRvcDtcblxuICAgIHRoaXMuX2l0ZXJhdGVJdGVtcygocGlkeCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2xhdGUzZCgwLCBgJHt5fXB4YCwgMCwgdGhpcy5fcGh5c2ljYWxJdGVtc1twaWR4XSk7XG4gICAgICB5ICs9IHRoaXMuX3BoeXNpY2FsU2l6ZXNbcGlkeF07XG4gICAgfSk7XG4gIH0sXG5cbiAgX2dldFBoeXNpY2FsU2l6ZUluY3JlbWVudChwaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuX3BoeXNpY2FsU2l6ZXNbcGlkeF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkanVzdHMgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IHdhcyBvdmVyZXN0aW1hdGVkLlxuICAgKi9cbiAgX2FkanVzdFNjcm9sbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGRlbHRhSGVpZ2h0ID1cbiAgICAgIHRoaXMuX3ZpcnR1YWxTdGFydCA9PT0gMCA/IHRoaXMuX3BoeXNpY2FsVG9wIDogTWF0aC5taW4odGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl9waHlzaWNhbFRvcCwgMCk7XG4gICAgLy8gTm90ZTogdGhlIGRlbHRhIGNhbiBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS5cbiAgICBpZiAoZGVsdGFIZWlnaHQgIT09IDApIHtcbiAgICAgIHRoaXMuX3BoeXNpY2FsVG9wIC09IGRlbHRhSGVpZ2h0O1xuICAgICAgLy8gVGhpcyBtYXkgYmUgY2FsbGVkIG91dHNpZGUgb2YgYSBzY3JvbGxIYW5kbGVyLCBzbyB1c2UgbGFzdCBjYWNoZWQgcG9zaXRpb25cbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuICAgICAgLy8gSnVraW5nIHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgaW50ZXJpYWwgc2Nyb2xsaW5nIG9uIGlPUyBpcyBubyBidWVub1xuICAgICAgaWYgKCFJT1NfVE9VQ0hfU0NST0xMSU5HICYmIHNjcm9sbFRvcCA+IDApIHtcbiAgICAgICAgdGhpcy5fcmVzZXRTY3JvbGxQb3NpdGlvbihzY3JvbGxUb3AgLSBkZWx0YUhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2Nyb2xsLlxuICAgKi9cbiAgX3Jlc2V0U2Nyb2xsUG9zaXRpb24ocG9zKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsVGFyZ2V0ICYmIHBvcyA+PSAwKSB7XG4gICAgICB0aGlzLl9zY3JvbGxUb3AgPSBwb3M7XG4gICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3Njcm9sbFRvcDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjcm9sbCBoZWlnaHQsIHRoYXQncyB0aGUgaGVpZ2h0IG9mIHRoZSBjb250ZW50LFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVVwZGF0ZSBJZiB0cnVlLCB1cGRhdGVzIHRoZSBoZWlnaHQgbm8gbWF0dGVyIHdoYXQuXG4gICAqL1xuICBfdXBkYXRlU2Nyb2xsZXJTaXplKGZvcmNlVXBkYXRlKSB7XG4gICAgdGhpcy5fZXN0U2Nyb2xsSGVpZ2h0ID1cbiAgICAgIHRoaXMuX3BoeXNpY2FsQm90dG9tICtcbiAgICAgIE1hdGgubWF4KHRoaXMuX3ZpcnR1YWxDb3VudCAtIHRoaXMuX3BoeXNpY2FsQ291bnQgLSB0aGlzLl92aXJ0dWFsU3RhcnQsIDApICogdGhpcy5fcGh5c2ljYWxBdmVyYWdlO1xuXG4gICAgZm9yY2VVcGRhdGUgPSBmb3JjZVVwZGF0ZSB8fCB0aGlzLl9zY3JvbGxIZWlnaHQgPT09IDA7XG4gICAgZm9yY2VVcGRhdGUgPSBmb3JjZVVwZGF0ZSB8fCB0aGlzLl9zY3JvbGxQb3NpdGlvbiA+PSB0aGlzLl9lc3RTY3JvbGxIZWlnaHQgLSB0aGlzLl9waHlzaWNhbFNpemU7XG4gICAgLy8gQW1vcnRpemUgaGVpZ2h0IGFkanVzdG1lbnQsIHNvIGl0IHdvbid0IHRyaWdnZXIgbGFyZ2UgcmVwYWludHMgdG9vIG9mdGVuLlxuICAgIGlmIChmb3JjZVVwZGF0ZSB8fCBNYXRoLmFicyh0aGlzLl9lc3RTY3JvbGxIZWlnaHQgLSB0aGlzLl9zY3JvbGxIZWlnaHQpID49IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgICB0aGlzLiQuaXRlbXMuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5fZXN0U2Nyb2xsSGVpZ2h0fXB4YDtcbiAgICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2VzdFNjcm9sbEhlaWdodDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNjcm9sbCB0byBhIHNwZWNpZmljIGluZGV4IGluIHRoZSB2aXJ0dWFsIGxpc3QgcmVnYXJkbGVzc1xuICAgKiBvZiB0aGUgcGh5c2ljYWwgaXRlbXMgaW4gdGhlIERPTSB0cmVlLlxuICAgKlxuICAgKiBAbWV0aG9kIHNjcm9sbFRvSW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBUaGUgaW5kZXggb2YgdGhlIGl0ZW1cbiAgICovXG4gIHNjcm9sbFRvSW5kZXgoaWR4KSB7XG4gICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInIHx8IGlkeCA8IDAgfHwgaWR4ID4gdGhpcy5pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZsdXNoKCk7XG4gICAgLy8gSXRlbXMgc2hvdWxkIGhhdmUgYmVlbiByZW5kZXJlZCBwcmlvciBzY3JvbGxpbmcgdG8gYW4gaW5kZXguXG4gICAgaWYgKHRoaXMuX3BoeXNpY2FsQ291bnQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWR4ID0gdGhpcy5fY2xhbXAoaWR4LCAwLCB0aGlzLl92aXJ0dWFsQ291bnQgLSAxKTtcbiAgICAvLyBVcGRhdGUgdGhlIHZpcnR1YWwgc3RhcnQgb25seSB3aGVuIG5lZWRlZC5cbiAgICBpZiAoIXRoaXMuX2lzSW5kZXhSZW5kZXJlZChpZHgpIHx8IGlkeCA+PSB0aGlzLl9tYXhWaXJ0dWFsU3RhcnQpIHtcbiAgICAgIHRoaXMuX3ZpcnR1YWxTdGFydCA9IGlkeCAtIDE7XG4gICAgfVxuICAgIHRoaXMuX2Fzc2lnbk1vZGVscygpO1xuICAgIHRoaXMuX3VwZGF0ZU1ldHJpY3MoKTtcbiAgICAvLyBFc3RpbWF0ZSBuZXcgcGh5c2ljYWwgb2Zmc2V0LlxuICAgIHRoaXMuX3BoeXNpY2FsVG9wID0gdGhpcy5fdmlydHVhbFN0YXJ0ICogdGhpcy5fcGh5c2ljYWxBdmVyYWdlO1xuXG4gICAgbGV0IGN1cnJlbnRUb3BJdGVtID0gdGhpcy5fcGh5c2ljYWxTdGFydDtcbiAgICBsZXQgY3VycmVudFZpcnR1YWxJdGVtID0gdGhpcy5fdmlydHVhbFN0YXJ0O1xuICAgIGxldCB0YXJnZXRPZmZzZXRUb3AgPSAwO1xuICAgIGNvbnN0IGhpZGRlbkNvbnRlbnRTaXplID0gdGhpcy5faGlkZGVuQ29udGVudFNpemU7XG4gICAgLy8gU2Nyb2xsIHRvIHRoZSBpdGVtIGFzIG11Y2ggYXMgd2UgY2FuLlxuICAgIHdoaWxlIChjdXJyZW50VmlydHVhbEl0ZW0gPCBpZHggJiYgdGFyZ2V0T2Zmc2V0VG9wIDw9IGhpZGRlbkNvbnRlbnRTaXplKSB7XG4gICAgICB0YXJnZXRPZmZzZXRUb3AgKz0gdGhpcy5fZ2V0UGh5c2ljYWxTaXplSW5jcmVtZW50KGN1cnJlbnRUb3BJdGVtKTtcbiAgICAgIGN1cnJlbnRUb3BJdGVtID0gKGN1cnJlbnRUb3BJdGVtICsgMSkgJSB0aGlzLl9waHlzaWNhbENvdW50O1xuICAgICAgY3VycmVudFZpcnR1YWxJdGVtICs9IDE7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVNjcm9sbGVyU2l6ZSh0cnVlKTtcbiAgICB0aGlzLl9wb3NpdGlvbkl0ZW1zKCk7XG4gICAgdGhpcy5fcmVzZXRTY3JvbGxQb3NpdGlvbih0aGlzLl9waHlzaWNhbFRvcCArIHRoaXMuX3Njcm9sbE9mZnNldCArIHRhcmdldE9mZnNldFRvcCk7XG4gICAgdGhpcy5faW5jcmVhc2VQb29sSWZOZWVkZWQoMCk7XG4gICAgLy8gQ2xlYXIgY2FjaGVkIHZpc2libGUgaW5kZXguXG4gICAgdGhpcy5fZmlyc3RWaXNpYmxlSW5kZXhWYWwgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RWaXNpYmxlSW5kZXhWYWwgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcGh5c2ljYWwgYXZlcmFnZSBhbmQgdGhlIGF2ZXJhZ2UgY291bnQuXG4gICAqL1xuICBfcmVzZXRBdmVyYWdlKCkge1xuICAgIHRoaXMuX3BoeXNpY2FsQXZlcmFnZSA9IDA7XG4gICAgdGhpcy5fcGh5c2ljYWxBdmVyYWdlQ291bnQgPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBIGhhbmRsZXIgZm9yIHRoZSBgaXJvbi1yZXNpemVgIGV2ZW50IHRyaWdnZXJlZCBieSBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYFxuICAgKiB3aGVuIHRoZSBlbGVtZW50IGlzIHJlc2l6ZWQuXG4gICAqL1xuICBfcmVzaXplSGFuZGxlcigpIHtcbiAgICB0aGlzLl9kZWJvdW5jZShcbiAgICAgICdfcmVuZGVyJyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgLy8gQ2xlYXIgY2FjaGVkIHZpc2libGUgaW5kZXguXG4gICAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZUluZGV4VmFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdFZpc2libGVJbmRleFZhbCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9pc1Zpc2libGUpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgICAgIC8vIFJlaW5zdGFsbCB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgIHRoaXMudG9nZ2xlU2Nyb2xsTGlzdGVuZXIodHJ1ZSk7XG4gICAgICAgICAgdGhpcy5fcmVzZXRBdmVyYWdlKCk7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVW5pbnN0YWxsIHRoZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgICAgdGhpcy50b2dnbGVTY3JvbGxMaXN0ZW5lcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbmltYXRpb25GcmFtZSxcbiAgICApO1xuICB9LFxuXG4gIF9pc0luZGV4UmVuZGVyZWQoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA+PSB0aGlzLl92aXJ0dWFsU3RhcnQgJiYgaWR4IDw9IHRoaXMuX3ZpcnR1YWxFbmQ7XG4gIH0sXG5cbiAgX2dldFBoeXNpY2FsSW5kZXgodmlkeCkge1xuICAgIHJldHVybiAodGhpcy5fcGh5c2ljYWxTdGFydCArICh2aWR4IC0gdGhpcy5fdmlydHVhbFN0YXJ0KSkgJSB0aGlzLl9waHlzaWNhbENvdW50O1xuICB9LFxuXG4gIF9jbGFtcCh2LCBtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdikpO1xuICB9LFxuXG4gIF9kZWJvdW5jZShuYW1lLCBjYiwgYXN5bmNNb2R1bGUpIHtcbiAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICB0aGlzLl9kZWJvdW5jZXJzW25hbWVdID0gRGVib3VuY2VyLmRlYm91bmNlKHRoaXMuX2RlYm91bmNlcnNbbmFtZV0sIGFzeW5jTW9kdWxlLCBjYi5iaW5kKHRoaXMpKTtcbiAgICBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX2RlYm91bmNlcnNbbmFtZV0pO1xuICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/iron-list-core.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/keyboard-mixin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/keyboard-mixin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyboardMixin\": () => (/* binding */ KeyboardMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@vaadin/component-base/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * A mixin that manages keyboard handling.\n * The mixin subscribes to the keyboard events while an actual implementation\n * for the event handlers is left to the client (a component or another mixin).\n *\n * @polymerMixin\n */\nconst KeyboardMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superclass => class KeyboardMixinClass extends superclass {\n  /** @protected */\n  ready() {\n    super.ready();\n    this.addEventListener('keydown', event => {\n      this._onKeyDown(event);\n    });\n    this.addEventListener('keyup', event => {\n      this._onKeyUp(event);\n    });\n  }\n\n  /**\n   * A handler for the `keydown` event. By default, it calls\n   * separate methods for handling \"Enter\" and \"Escape\" keys.\n   * Override the method to implement your own behavior.\n   *\n   * @param {KeyboardEvent} event\n   * @protected\n   */\n  _onKeyDown(event) {\n    switch (event.key) {\n      case 'Enter':\n        this._onEnter(event);\n        break;\n      case 'Escape':\n        this._onEscape(event);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * A handler for the `keyup` event. By default, it does nothing.\n   * Override the method to implement your own behavior.\n   *\n   * @param {KeyboardEvent} _event\n   * @protected\n   */\n  _onKeyUp(_event) {\n    // To be implemented.\n  }\n\n  /**\n   * A handler for the \"Enter\" key. By default, it does nothing.\n   * Override the method to implement your own behavior.\n   *\n   * @param {KeyboardEvent} _event\n   * @protected\n   */\n  _onEnter(_event) {\n    // To be implemented.\n  }\n\n  /**\n   * A handler for the \"Escape\" key. By default, it does nothing.\n   * Override the method to implement your own behavior.\n   *\n   * @param {KeyboardEvent} _event\n   * @protected\n   */\n  _onEscape(_event) {\n    // To be implemented.\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMva2V5Ym9hcmQtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMva2V5Ym9hcmQtbWl4aW4uanM/MzA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcyc7XG5cbi8qKlxuICogQSBtaXhpbiB0aGF0IG1hbmFnZXMga2V5Ym9hcmQgaGFuZGxpbmcuXG4gKiBUaGUgbWl4aW4gc3Vic2NyaWJlcyB0byB0aGUga2V5Ym9hcmQgZXZlbnRzIHdoaWxlIGFuIGFjdHVhbCBpbXBsZW1lbnRhdGlvblxuICogZm9yIHRoZSBldmVudCBoYW5kbGVycyBpcyBsZWZ0IHRvIHRoZSBjbGllbnQgKGEgY29tcG9uZW50IG9yIGFub3RoZXIgbWl4aW4pLlxuICpcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IEtleWJvYXJkTWl4aW4gPSBkZWR1cGluZ01peGluKFxuICAoc3VwZXJjbGFzcykgPT5cbiAgICBjbGFzcyBLZXlib2FyZE1peGluQ2xhc3MgZXh0ZW5kcyBzdXBlcmNsYXNzIHtcbiAgICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgICByZWFkeSgpIHtcbiAgICAgICAgc3VwZXIucmVhZHkoKTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25LZXlVcChldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEEgaGFuZGxlciBmb3IgdGhlIGBrZXlkb3duYCBldmVudC4gQnkgZGVmYXVsdCwgaXQgY2FsbHNcbiAgICAgICAqIHNlcGFyYXRlIG1ldGhvZHMgZm9yIGhhbmRsaW5nIFwiRW50ZXJcIiBhbmQgXCJFc2NhcGVcIiBrZXlzLlxuICAgICAgICogT3ZlcnJpZGUgdGhlIG1ldGhvZCB0byBpbXBsZW1lbnQgeW91ciBvd24gYmVoYXZpb3IuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgdGhpcy5fb25FbnRlcihldmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgdGhpcy5fb25Fc2NhcGUoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBoYW5kbGVyIGZvciB0aGUgYGtleXVwYCBldmVudC4gQnkgZGVmYXVsdCwgaXQgZG9lcyBub3RoaW5nLlxuICAgICAgICogT3ZlcnJpZGUgdGhlIG1ldGhvZCB0byBpbXBsZW1lbnQgeW91ciBvd24gYmVoYXZpb3IuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBfZXZlbnRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX29uS2V5VXAoX2V2ZW50KSB7XG4gICAgICAgIC8vIFRvIGJlIGltcGxlbWVudGVkLlxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEEgaGFuZGxlciBmb3IgdGhlIFwiRW50ZXJcIiBrZXkuIEJ5IGRlZmF1bHQsIGl0IGRvZXMgbm90aGluZy5cbiAgICAgICAqIE92ZXJyaWRlIHRoZSBtZXRob2QgdG8gaW1wbGVtZW50IHlvdXIgb3duIGJlaGF2aW9yLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gX2V2ZW50XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9vbkVudGVyKF9ldmVudCkge1xuICAgICAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZC5cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBIGhhbmRsZXIgZm9yIHRoZSBcIkVzY2FwZVwiIGtleS4gQnkgZGVmYXVsdCwgaXQgZG9lcyBub3RoaW5nLlxuICAgICAgICogT3ZlcnJpZGUgdGhlIG1ldGhvZCB0byBpbXBsZW1lbnQgeW91ciBvd24gYmVoYXZpb3IuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBfZXZlbnRcbiAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAqL1xuICAgICAgX29uRXNjYXBlKF9ldmVudCkge1xuICAgICAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZC5cbiAgICAgIH1cbiAgICB9LFxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/keyboard-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/templates.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/templates.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"processTemplates\": () => (/* binding */ processTemplates)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Passes the component to the template renderer callback if the template renderer is imported.\n * Otherwise, if there is a template, it warns that the template renderer needs to be imported.\n *\n * @param {HTMLElement} component\n */\nfunction processTemplates(component) {\n  if (window.Vaadin && window.Vaadin.templateRendererCallback) {\n    window.Vaadin.templateRendererCallback(component);\n    return;\n  }\n  if (component.querySelector('template')) {\n    console.warn(`WARNING: <template> inside <${component.localName}> is no longer supported. Import @vaadin/polymer-legacy-adapter/template-renderer.js to enable compatibility.`);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdGVtcGxhdGVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdGVtcGxhdGVzLmpzPzhlN2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbi8qKlxuICogUGFzc2VzIHRoZSBjb21wb25lbnQgdG8gdGhlIHRlbXBsYXRlIHJlbmRlcmVyIGNhbGxiYWNrIGlmIHRoZSB0ZW1wbGF0ZSByZW5kZXJlciBpcyBpbXBvcnRlZC5cbiAqIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgYSB0ZW1wbGF0ZSwgaXQgd2FybnMgdGhhdCB0aGUgdGVtcGxhdGUgcmVuZGVyZXIgbmVlZHMgdG8gYmUgaW1wb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29tcG9uZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVGVtcGxhdGVzKGNvbXBvbmVudCkge1xuICBpZiAod2luZG93LlZhYWRpbiAmJiB3aW5kb3cuVmFhZGluLnRlbXBsYXRlUmVuZGVyZXJDYWxsYmFjaykge1xuICAgIHdpbmRvdy5WYWFkaW4udGVtcGxhdGVSZW5kZXJlckNhbGxiYWNrKGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFdBUk5JTkc6IDx0ZW1wbGF0ZT4gaW5zaWRlIDwke2NvbXBvbmVudC5sb2NhbE5hbWV9PiBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBJbXBvcnQgQHZhYWRpbi9wb2x5bWVyLWxlZ2FjeS1hZGFwdGVyL3RlbXBsYXRlLXJlbmRlcmVyLmpzIHRvIGVuYWJsZSBjb21wYXRpYmlsaXR5LmAsXG4gICAgKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/templates.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/unique-id-utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/unique-id-utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateUniqueId\": () => (/* binding */ generateUniqueId),\n/* harmony export */   \"resetUniqueId\": () => (/* binding */ resetUniqueId)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\nlet uniqueId = 0;\n\n/**\n * Resets the unique id counter.\n *\n * @return {void}\n */\nfunction resetUniqueId() {\n  uniqueId = 0;\n}\n\n/**\n * Returns a unique integer id.\n *\n * @return {number}\n */\nfunction generateUniqueId() {\n  // eslint-disable-next-line no-plusplus\n  return uniqueId++;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdW5pcXVlLWlkLXV0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdW5pcXVlLWlkLXV0aWxzLmpzPzU5OGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbmxldCB1bmlxdWVJZCA9IDA7XG5cbi8qKlxuICogUmVzZXRzIHRoZSB1bmlxdWUgaWQgY291bnRlci5cbiAqXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRVbmlxdWVJZCgpIHtcbiAgdW5pcXVlSWQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaW50ZWdlciBpZC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZUlkKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcbiAgcmV0dXJuIHVuaXF1ZUlkKys7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/unique-id-utils.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IronListAdapter\": () => (/* binding */ IronListAdapter)\n/* harmony export */ });\n/* harmony import */ var _async_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async.js */ \"./node_modules/@vaadin/component-base/src/async.js\");\n/* harmony import */ var _browser_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./browser-utils.js */ \"./node_modules/@vaadin/component-base/src/browser-utils.js\");\n/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debounce.js */ \"./node_modules/@vaadin/component-base/src/debounce.js\");\n/* harmony import */ var _iron_list_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./iron-list-core.js */ \"./node_modules/@vaadin/component-base/src/iron-list-core.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\nclass IronListAdapter {\n  constructor({\n    createElements,\n    updateElement,\n    scrollTarget,\n    scrollContainer,\n    elementsContainer,\n    reorderElements\n  }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100\n    };\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', e => this.__onWheel(e));\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n  get scrollOffset() {\n    return 0;\n  }\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    index = this._clamp(index, 0, this.size - 1);\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n  }\n  flush() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n    this._resizeHandler();\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)();\n    this._scrollHandler();\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.flush();\n    }\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n  }\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__getVisibleElements().forEach(el => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n      }\n    });\n  }\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)();\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);\n    }\n  }\n  __getBorderBoxHeight(el) {\n    const style = getComputedStyle(el);\n    const itemHeight = parseFloat(style.height) || 0;\n    if (style.boxSizing === 'border-box') {\n      return itemHeight;\n    }\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\n    const paddingTop = parseFloat(style.paddingTop) || 0;\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n  }\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.style.paddingTop) {\n      el.style.paddingTop = '';\n    }\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n    const elementHeight = el.offsetHeight;\n    if (elementHeight === 0) {\n      // If the elements have 0 height after update (for example due to lazy rendering),\n      // it results in iron-list requesting to create an unlimited count of elements.\n      // Assign a temporary placeholder sizing to elements that would otherwise end up having\n      // no height.\n      el.style.paddingTop = `${this.__placeholderHeight}px`;\n\n      // Manually schedule the resize handler to make sure the placeholder padding is\n      // cleared in case the resize observer never triggers.\n      requestAnimationFrame(() => this._resizeHandler());\n    } else {\n      // Add element height to the queue\n      this.__elementHeightQueue.push(elementHeight);\n      this.__elementHeightQueue.shift();\n\n      // Calcualte new placeholder height based on the average of the defined values in the\n      // element height queue\n      const filteredHeights = this.__elementHeightQueue.filter(h => h !== undefined);\n      this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n    }\n  }\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find(el => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n  get size() {\n    return this.__size;\n  }\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n    // Cancel active debouncers\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.cancel();\n    }\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n      // Avoid creating unnecessary elements on the following flush()\n      this._debouncers._increasePoolIfNeeded.cancel();\n    }\n\n    // Prevent element update while the scroll position is being restored\n    this.__preventElementUpdates = true;\n\n    // Record the scroll position before changing the size\n    let fvi; // First visible index\n    let fviOffsetBefore; // Scroll offset of the first visible index\n    if (size > 0) {\n      fvi = this.adjustedFirstVisibleIndex;\n      fviOffsetBefore = this.__getIndexScrollOffset(fvi);\n    }\n\n    // Change the size\n    this.__size = size;\n    this._itemsChanged({\n      path: 'items'\n    });\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)();\n\n    // Try to restore the scroll position if the new size is larger than 0\n    if (size > 0) {\n      fvi = Math.min(fvi, size - 1);\n      this.scrollToIndex(fvi);\n      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);\n      if (fviOffsetBefore !== undefined && fviOffsetAfter !== undefined) {\n        this._scrollTop += fviOffsetBefore - fviOffsetAfter;\n      }\n    }\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n    this.__preventElementUpdates = false;\n    // Schedule and flush a resize handler\n    this._resizeHandler();\n    (0,_debounce_js__WEBPACK_IMPORTED_MODULE_2__.flush)();\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT)\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach(el => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n  _scrollHandler() {\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\n    super._scrollHandler();\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n    if (delta) {\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\n      this.__fixInvalidItemPositioningDebouncer = _debounce_js__WEBPACK_IMPORTED_MODULE_2__.Debouncer.debounce(this.__fixInvalidItemPositioningDebouncer, _async_js__WEBPACK_IMPORTED_MODULE_0__.timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING), () => this.__fixInvalidItemPositioning());\n    }\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = _debounce_js__WEBPACK_IMPORTED_MODULE_2__.Debouncer.debounce(this.__scrollReorderDebouncer, _async_js__WEBPACK_IMPORTED_MODULE_0__.timeOut.after(this.timeouts.SCROLL_REORDER), () => this.__reorderElements());\n    }\n    this.__previousScrollTop = this._scrollTop;\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // scroll to index 0 to fix the issue.\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n      this.scrollToIndex(0);\n    }\n  }\n\n  /**\n   * Work around an iron-list issue with invalid item positioning.\n   * See https://github.com/vaadin/flow-components/issues/4306\n   * @private\n   */\n  __fixInvalidItemPositioning() {\n    if (!this.scrollTarget.isConnected) {\n      return;\n    }\n\n    // Check if the first physical item element is below the top of the viewport\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\n    // Check if the last physical item element is above the bottom of the viewport\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n    // Check if the first index is visible\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n    // Check if the last index is visible\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n    if (physicalTopBelowTop && !firstIndexVisible || physicalBottomAboveBottom && !lastIndexVisible) {\n      // Invalid state! Try to recover.\n\n      const isScrollingDown = physicalBottomAboveBottom;\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n      // place all the free physical items on one side of the viewport.\n      const originalRatio = this._ratio;\n      this._ratio = 0;\n      // Fake a scroll change to make _scrollHandler place the physical items\n      // on the desired side.\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n      this._scrollHandler();\n      // Restore the original \"_ratio\" value.\n      this._ratio = originalRatio;\n    }\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n    this._deltaYAcc = this._deltaYAcc || 0;\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = _debounce_js__WEBPACK_IMPORTED_MODULE_2__.Debouncer.debounce(this.__debouncerWheelAnimationFrame, _async_js__WEBPACK_IMPORTED_MODULE_0__.animationFrame, () => {\n      this._wheelAnimationFrame = false;\n    });\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n      this._hasResidualMomentum = true;\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = _debounce_js__WEBPACK_IMPORTED_MODULE_2__.Debouncer.debounce(this._debouncerIgnoreNewWheel, _async_js__WEBPACK_IMPORTED_MODULE_0__.timeOut.after(this.timeouts.IGNORE_WHEEL), () => {\n        this._ignoreNewWheel = false;\n      });\n    } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n  _canScroll(el, deltaX, deltaY) {\n    return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter(element => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n    const elementWithFocus = visibleElements.find(element => element.contains(this.elementsContainer.getRootNode().activeElement) || element.contains(this.scrollTarget.getRootNode().activeElement));\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (_browser_utils_js__WEBPACK_IMPORTED_MODULE_1__.isSafari) {\n      const {\n        transform\n      } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\nObject.setPrototypeOf(IronListAdapter.prototype, _iron_list_core_js__WEBPACK_IMPORTED_MODULE_3__.ironList);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdmlydHVhbGl6ZXItaXJvbi1saXN0LWFkYXB0ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUtBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdmlydHVhbGl6ZXItaXJvbi1saXN0LWFkYXB0ZXIuanM/ZGI3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IGFuaW1hdGlvbkZyYW1lLCB0aW1lT3V0IH0gZnJvbSAnLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBpc1NhZmFyaSB9IGZyb20gJy4vYnJvd3Nlci11dGlscy5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIsIGZsdXNoIH0gZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyBpcm9uTGlzdCB9IGZyb20gJy4vaXJvbi1saXN0LWNvcmUuanMnO1xuXG4vLyBJcm9uLWxpc3QgY2FuIGJ5IGRlZmF1bHQgaGFuZGxlIHNpemVzIHVwIHRvIGFyb3VuZCAxMDAwMDAuXG4vLyBXaGVuIHRoZSBzaXplIGlzIGxhcmdlciB0aGFuIE1BWF9WSVJUVUFMX0NPVU5UIF92aWR4T2Zmc2V0IGlzIHVzZWRcbmNvbnN0IE1BWF9WSVJUVUFMX0NPVU5UID0gMTAwMDAwO1xuY29uc3QgT0ZGU0VUX0FESlVTVF9NSU5fVEhSRVNIT0xEID0gMTAwMDtcblxuZXhwb3J0IGNsYXNzIElyb25MaXN0QWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKHsgY3JlYXRlRWxlbWVudHMsIHVwZGF0ZUVsZW1lbnQsIHNjcm9sbFRhcmdldCwgc2Nyb2xsQ29udGFpbmVyLCBlbGVtZW50c0NvbnRhaW5lciwgcmVvcmRlckVsZW1lbnRzIH0pIHtcbiAgICB0aGlzLmlzQXR0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSAwO1xuICAgIHRoaXMuY3JlYXRlRWxlbWVudHMgPSBjcmVhdGVFbGVtZW50cztcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQgPSB1cGRhdGVFbGVtZW50O1xuICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVyO1xuICAgIHRoaXMuZWxlbWVudHNDb250YWluZXIgPSBlbGVtZW50c0NvbnRhaW5lciB8fCBzY3JvbGxDb250YWluZXI7XG4gICAgdGhpcy5yZW9yZGVyRWxlbWVudHMgPSByZW9yZGVyRWxlbWVudHM7XG4gICAgLy8gSXJvbi1saXN0IHVzZXMgdGhpcyB2YWx1ZSB0byBkZXRlcm1pbmUgaG93IG1hbnkgcGFnZXMgb2YgZWxlbWVudHMgdG8gcmVuZGVyXG4gICAgdGhpcy5fbWF4UGFnZXMgPSAxLjM7XG5cbiAgICAvLyBQbGFjZWhvbGRlciBoZWlnaHQgKHVzZWQgZm9yIHNpemluZyBlbGVtZW50cyB0aGF0IGhhdmUgaW50cmluc2ljIDAgaGVpZ2h0IGFmdGVyIHVwZGF0ZSlcbiAgICB0aGlzLl9fcGxhY2Vob2xkZXJIZWlnaHQgPSAyMDA7XG4gICAgLy8gQSBxdWV1ZSBvZiAxMCBwcmV2aW91cyBlbGVtZW50IGhlaWdodHNcbiAgICB0aGlzLl9fZWxlbWVudEhlaWdodFF1ZXVlID0gQXJyYXkoMTApO1xuXG4gICAgdGhpcy50aW1lb3V0cyA9IHtcbiAgICAgIFNDUk9MTF9SRU9SREVSOiA1MDAsXG4gICAgICBJR05PUkVfV0hFRUw6IDUwMCxcbiAgICAgIEZJWF9JTlZBTElEX0lURU1fUE9TSVRJT05JTkc6IDEwMCxcbiAgICB9O1xuXG4gICAgdGhpcy5fX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKSk7XG5cbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnNjcm9sbFRhcmdldCkub3ZlcmZsb3cgPT09ICd2aXNpYmxlJykge1xuICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxDb250YWluZXIpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cblxuICAgIHRoaXMuX19yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICB0aGlzLnNjcm9sbFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PiB0aGlzLl9zY3JvbGxIYW5kbGVyKCkpO1xuXG4gICAgdGhpcy5fc2Nyb2xsTGluZUhlaWdodCA9IHRoaXMuX2dldFNjcm9sbExpbmVIZWlnaHQoKTtcbiAgICB0aGlzLnNjcm9sbFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChlKSA9PiB0aGlzLl9fb25XaGVlbChlKSk7XG5cbiAgICBpZiAodGhpcy5yZW9yZGVyRWxlbWVudHMpIHtcbiAgICAgIC8vIFJlb3JkZXJpbmcgdGhlIHBoeXNpY2FsIGVsZW1lbnRzIGNhbmNlbHMgdGhlIHVzZXIncyBncmFiIG9mIHRoZSBzY3JvbGwgYmFyIGhhbmRsZSBvbiBTYWZhcmkuXG4gICAgICAvLyBOZWVkIHRvIGRlZmVyIHJlb3JkZXJpbmcgdW50aWwgdGhlIHVzZXIgbGV0cyBnbyBvZiB0aGUgc2Nyb2xsIGJhciBoYW5kbGUuXG4gICAgICB0aGlzLnNjcm9sbFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX19tb3VzZURvd24gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNjcm9sbFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9fbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9fcGVuZGluZ1Jlb3JkZXIpIHtcbiAgICAgICAgICB0aGlzLl9fcmVvcmRlckVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzY3JvbGxPZmZzZXQoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXQgYWRqdXN0ZWRGaXJzdFZpc2libGVJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXJzdFZpc2libGVJbmRleCArIHRoaXMuX3ZpZHhPZmZzZXQ7XG4gIH1cblxuICBnZXQgYWRqdXN0ZWRMYXN0VmlzaWJsZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RWaXNpYmxlSW5kZXggKyB0aGlzLl92aWR4T2Zmc2V0O1xuICB9XG5cbiAgc2Nyb2xsVG9JbmRleChpbmRleCkge1xuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInIHx8IGlzTmFOKGluZGV4KSB8fCB0aGlzLnNpemUgPT09IDAgfHwgIXRoaXMuc2Nyb2xsVGFyZ2V0Lm9mZnNldEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmRleCA9IHRoaXMuX2NsYW1wKGluZGV4LCAwLCB0aGlzLnNpemUgLSAxKTtcblxuICAgIGNvbnN0IHZpc2libGVFbGVtZW50Q291bnQgPSB0aGlzLl9fZ2V0VmlzaWJsZUVsZW1lbnRzKCkubGVuZ3RoO1xuICAgIGxldCB0YXJnZXRWaXJ0dWFsSW5kZXggPSBNYXRoLmZsb29yKChpbmRleCAvIHRoaXMuc2l6ZSkgKiB0aGlzLl92aXJ0dWFsQ291bnQpO1xuICAgIGlmICh0aGlzLl92aXJ0dWFsQ291bnQgLSB0YXJnZXRWaXJ0dWFsSW5kZXggPCB2aXNpYmxlRWxlbWVudENvdW50KSB7XG4gICAgICB0YXJnZXRWaXJ0dWFsSW5kZXggPSB0aGlzLl92aXJ0dWFsQ291bnQgLSAodGhpcy5zaXplIC0gaW5kZXgpO1xuICAgICAgdGhpcy5fdmlkeE9mZnNldCA9IHRoaXMuc2l6ZSAtIHRoaXMuX3ZpcnR1YWxDb3VudDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFZpcnR1YWxJbmRleCA8IHZpc2libGVFbGVtZW50Q291bnQpIHtcbiAgICAgIGlmIChpbmRleCA8IE9GRlNFVF9BREpVU1RfTUlOX1RIUkVTSE9MRCkge1xuICAgICAgICB0YXJnZXRWaXJ0dWFsSW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fdmlkeE9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaXJ0dWFsSW5kZXggPSBPRkZTRVRfQURKVVNUX01JTl9USFJFU0hPTEQ7XG4gICAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSBpbmRleCAtIHRhcmdldFZpcnR1YWxJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmlkeE9mZnNldCA9IGluZGV4IC0gdGFyZ2V0VmlydHVhbEluZGV4O1xuICAgIH1cblxuICAgIHRoaXMuX19za2lwTmV4dFZpcnR1YWxJbmRleEFkanVzdCA9IHRydWU7XG4gICAgc3VwZXIuc2Nyb2xsVG9JbmRleCh0YXJnZXRWaXJ0dWFsSW5kZXgpO1xuXG4gICAgaWYgKHRoaXMuYWRqdXN0ZWRGaXJzdFZpc2libGVJbmRleCAhPT0gaW5kZXggJiYgdGhpcy5fc2Nyb2xsVG9wIDwgdGhpcy5fbWF4U2Nyb2xsVG9wICYmICF0aGlzLmdyaWQpIHtcbiAgICAgIC8vIFdvcmthcm91bmQgYW4gaXJvbi1saXN0IGlzc3VlIGJ5IG1hbnVhbGx5IGFkanVzdGluZyB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICB0aGlzLl9zY3JvbGxUb3AgLT0gdGhpcy5fX2dldEluZGV4U2Nyb2xsT2Zmc2V0KGluZGV4KSB8fCAwO1xuICAgIH1cbiAgICB0aGlzLl9zY3JvbGxIYW5kbGVyKCk7XG4gIH1cblxuICBmbHVzaCgpIHtcbiAgICAvLyBUaGUgc2Nyb2xsIHRhcmdldCBpcyBoaWRkZW4uXG4gICAgaWYgKHRoaXMuc2Nyb2xsVGFyZ2V0Lm9mZnNldEhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKTtcbiAgICBmbHVzaCgpO1xuICAgIHRoaXMuX3Njcm9sbEhhbmRsZXIoKTtcbiAgICBpZiAodGhpcy5fX2ZpeEludmFsaWRJdGVtUG9zaXRpb25pbmdEZWJvdW5jZXIpIHtcbiAgICAgIHRoaXMuX19maXhJbnZhbGlkSXRlbVBvc2l0aW9uaW5nRGVib3VuY2VyLmZsdXNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fc2Nyb2xsUmVvcmRlckRlYm91bmNlcikge1xuICAgICAgdGhpcy5fX3Njcm9sbFJlb3JkZXJEZWJvdW5jZXIuZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19kZWJvdW5jZXJXaGVlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB0aGlzLl9fZGVib3VuY2VyV2hlZWxBbmltYXRpb25GcmFtZS5mbHVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSB0aGlzLnNpemUgLSAxKSB7XG4gICAgdGhpcy5fX2dldFZpc2libGVFbGVtZW50cygpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBpZiAoZWwuX192aXJ0dWFsSW5kZXggPj0gc3RhcnRJbmRleCAmJiBlbC5fX3ZpcnR1YWxJbmRleCA8PSBlbmRJbmRleCkge1xuICAgICAgICB0aGlzLl9fdXBkYXRlRWxlbWVudChlbCwgZWwuX192aXJ0dWFsSW5kZXgsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGhlaWdodCBmb3IgYSBnaXZlbiBzZXQgb2YgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7IUFycmF5PG51bWJlcj49fSBpdGVtU2V0XG4gICAqL1xuICBfdXBkYXRlTWV0cmljcyhpdGVtU2V0KSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGRpc3RyaWJ1dGVkIGFsbCB0aGUgcGh5c2ljYWwgaXRlbXNcbiAgICAvLyBzbyB3ZSBjYW4gbWVhc3VyZSB0aGVtLlxuICAgIGZsdXNoKCk7XG5cbiAgICBsZXQgbmV3UGh5c2ljYWxTaXplID0gMDtcbiAgICBsZXQgb2xkUGh5c2ljYWxTaXplID0gMDtcbiAgICBjb25zdCBwcmV2QXZnQ291bnQgPSB0aGlzLl9waHlzaWNhbEF2ZXJhZ2VDb3VudDtcbiAgICBjb25zdCBwcmV2UGh5c2ljYWxBdmcgPSB0aGlzLl9waHlzaWNhbEF2ZXJhZ2U7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdGhpcy5faXRlcmF0ZUl0ZW1zKChwaWR4LCB2aWR4KSA9PiB7XG4gICAgICBvbGRQaHlzaWNhbFNpemUgKz0gdGhpcy5fcGh5c2ljYWxTaXplc1twaWR4XTtcbiAgICAgIHRoaXMuX3BoeXNpY2FsU2l6ZXNbcGlkeF0gPSBNYXRoLmNlaWwodGhpcy5fX2dldEJvcmRlckJveEhlaWdodCh0aGlzLl9waHlzaWNhbEl0ZW1zW3BpZHhdKSk7XG4gICAgICBuZXdQaHlzaWNhbFNpemUgKz0gdGhpcy5fcGh5c2ljYWxTaXplc1twaWR4XTtcbiAgICAgIHRoaXMuX3BoeXNpY2FsQXZlcmFnZUNvdW50ICs9IHRoaXMuX3BoeXNpY2FsU2l6ZXNbcGlkeF0gPyAxIDogMDtcbiAgICB9LCBpdGVtU2V0KTtcblxuICAgIHRoaXMuX3BoeXNpY2FsU2l6ZSA9IHRoaXMuX3BoeXNpY2FsU2l6ZSArIG5ld1BoeXNpY2FsU2l6ZSAtIG9sZFBoeXNpY2FsU2l6ZTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYXZlcmFnZSBpZiBpdCBtZWFzdXJlZCBzb21ldGhpbmcuXG4gICAgaWYgKHRoaXMuX3BoeXNpY2FsQXZlcmFnZUNvdW50ICE9PSBwcmV2QXZnQ291bnQpIHtcbiAgICAgIHRoaXMuX3BoeXNpY2FsQXZlcmFnZSA9IE1hdGgucm91bmQoXG4gICAgICAgIChwcmV2UGh5c2ljYWxBdmcgKiBwcmV2QXZnQ291bnQgKyBuZXdQaHlzaWNhbFNpemUpIC8gdGhpcy5fcGh5c2ljYWxBdmVyYWdlQ291bnQsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIF9fZ2V0Qm9yZGVyQm94SGVpZ2h0KGVsKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmhlaWdodCkgfHwgMDtcblxuICAgIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgcmV0dXJuIGl0ZW1IZWlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSkgfHwgMDtcbiAgICBjb25zdCBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwO1xuICAgIGNvbnN0IGJvcmRlckJvdHRvbVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCkgfHwgMDtcbiAgICBjb25zdCBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG5cbiAgICByZXR1cm4gaXRlbUhlaWdodCArIHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nVG9wICsgYm9yZGVyQm90dG9tV2lkdGggKyBib3JkZXJUb3BXaWR0aDtcbiAgfVxuXG4gIF9fdXBkYXRlRWxlbWVudChlbCwgaW5kZXgsIGZvcmNlU2FtZUluZGV4VXBkYXRlcykge1xuICAgIC8vIENsZWFuIHVwIHRlbXBvcmFyeSBwbGFjZWhvbGRlciBzaXppbmdcbiAgICBpZiAoZWwuc3R5bGUucGFkZGluZ1RvcCkge1xuICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9ICcnO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fX3ByZXZlbnRFbGVtZW50VXBkYXRlcyAmJiAoZWwuX19sYXN0VXBkYXRlZEluZGV4ICE9PSBpbmRleCB8fCBmb3JjZVNhbWVJbmRleFVwZGF0ZXMpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoZWwsIGluZGV4KTtcbiAgICAgIGVsLl9fbGFzdFVwZGF0ZWRJbmRleCA9IGluZGV4O1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKGVsZW1lbnRIZWlnaHQgPT09IDApIHtcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50cyBoYXZlIDAgaGVpZ2h0IGFmdGVyIHVwZGF0ZSAoZm9yIGV4YW1wbGUgZHVlIHRvIGxhenkgcmVuZGVyaW5nKSxcbiAgICAgIC8vIGl0IHJlc3VsdHMgaW4gaXJvbi1saXN0IHJlcXVlc3RpbmcgdG8gY3JlYXRlIGFuIHVubGltaXRlZCBjb3VudCBvZiBlbGVtZW50cy5cbiAgICAgIC8vIEFzc2lnbiBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlciBzaXppbmcgdG8gZWxlbWVudHMgdGhhdCB3b3VsZCBvdGhlcndpc2UgZW5kIHVwIGhhdmluZ1xuICAgICAgLy8gbm8gaGVpZ2h0LlxuICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9IGAke3RoaXMuX19wbGFjZWhvbGRlckhlaWdodH1weGA7XG5cbiAgICAgIC8vIE1hbnVhbGx5IHNjaGVkdWxlIHRoZSByZXNpemUgaGFuZGxlciB0byBtYWtlIHN1cmUgdGhlIHBsYWNlaG9sZGVyIHBhZGRpbmcgaXNcbiAgICAgIC8vIGNsZWFyZWQgaW4gY2FzZSB0aGUgcmVzaXplIG9ic2VydmVyIG5ldmVyIHRyaWdnZXJzLlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCBlbGVtZW50IGhlaWdodCB0byB0aGUgcXVldWVcbiAgICAgIHRoaXMuX19lbGVtZW50SGVpZ2h0UXVldWUucHVzaChlbGVtZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuX19lbGVtZW50SGVpZ2h0UXVldWUuc2hpZnQoKTtcblxuICAgICAgLy8gQ2FsY3VhbHRlIG5ldyBwbGFjZWhvbGRlciBoZWlnaHQgYmFzZWQgb24gdGhlIGF2ZXJhZ2Ugb2YgdGhlIGRlZmluZWQgdmFsdWVzIGluIHRoZVxuICAgICAgLy8gZWxlbWVudCBoZWlnaHQgcXVldWVcbiAgICAgIGNvbnN0IGZpbHRlcmVkSGVpZ2h0cyA9IHRoaXMuX19lbGVtZW50SGVpZ2h0UXVldWUuZmlsdGVyKChoKSA9PiBoICE9PSB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5fX3BsYWNlaG9sZGVySGVpZ2h0ID0gTWF0aC5yb3VuZChmaWx0ZXJlZEhlaWdodHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBmaWx0ZXJlZEhlaWdodHMubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICBfX2dldEluZGV4U2Nyb2xsT2Zmc2V0KGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX19nZXRWaXNpYmxlRWxlbWVudHMoKS5maW5kKChlbCkgPT4gZWwuX192aXJ0dWFsSW5kZXggPT09IGluZGV4KTtcbiAgICByZXR1cm4gZWxlbWVudCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zaXplO1xuICB9XG5cbiAgc2V0IHNpemUoc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB0aGlzLnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2FuY2VsIGFjdGl2ZSBkZWJvdW5jZXJzXG4gICAgaWYgKHRoaXMuX19maXhJbnZhbGlkSXRlbVBvc2l0aW9uaW5nRGVib3VuY2VyKSB7XG4gICAgICB0aGlzLl9fZml4SW52YWxpZEl0ZW1Qb3NpdGlvbmluZ0RlYm91bmNlci5jYW5jZWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlYm91bmNlcnMgJiYgdGhpcy5fZGVib3VuY2Vycy5faW5jcmVhc2VQb29sSWZOZWVkZWQpIHtcbiAgICAgIC8vIEF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IGVsZW1lbnRzIG9uIHRoZSBmb2xsb3dpbmcgZmx1c2goKVxuICAgICAgdGhpcy5fZGVib3VuY2Vycy5faW5jcmVhc2VQb29sSWZOZWVkZWQuY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBlbGVtZW50IHVwZGF0ZSB3aGlsZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHJlc3RvcmVkXG4gICAgdGhpcy5fX3ByZXZlbnRFbGVtZW50VXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBSZWNvcmQgdGhlIHNjcm9sbCBwb3NpdGlvbiBiZWZvcmUgY2hhbmdpbmcgdGhlIHNpemVcbiAgICBsZXQgZnZpOyAvLyBGaXJzdCB2aXNpYmxlIGluZGV4XG4gICAgbGV0IGZ2aU9mZnNldEJlZm9yZTsgLy8gU2Nyb2xsIG9mZnNldCBvZiB0aGUgZmlyc3QgdmlzaWJsZSBpbmRleFxuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgZnZpID0gdGhpcy5hZGp1c3RlZEZpcnN0VmlzaWJsZUluZGV4O1xuICAgICAgZnZpT2Zmc2V0QmVmb3JlID0gdGhpcy5fX2dldEluZGV4U2Nyb2xsT2Zmc2V0KGZ2aSk7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzaXplXG4gICAgdGhpcy5fX3NpemUgPSBzaXplO1xuXG4gICAgdGhpcy5faXRlbXNDaGFuZ2VkKHtcbiAgICAgIHBhdGg6ICdpdGVtcycsXG4gICAgfSk7XG4gICAgZmx1c2goKTtcblxuICAgIC8vIFRyeSB0byByZXN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gaWYgdGhlIG5ldyBzaXplIGlzIGxhcmdlciB0aGFuIDBcbiAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgIGZ2aSA9IE1hdGgubWluKGZ2aSwgc2l6ZSAtIDEpO1xuICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KGZ2aSk7XG5cbiAgICAgIGNvbnN0IGZ2aU9mZnNldEFmdGVyID0gdGhpcy5fX2dldEluZGV4U2Nyb2xsT2Zmc2V0KGZ2aSk7XG4gICAgICBpZiAoZnZpT2Zmc2V0QmVmb3JlICE9PSB1bmRlZmluZWQgJiYgZnZpT2Zmc2V0QWZ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxUb3AgKz0gZnZpT2Zmc2V0QmVmb3JlIC0gZnZpT2Zmc2V0QWZ0ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fX3ByZXZlbnRFbGVtZW50VXBkYXRlcyA9IGZhbHNlO1xuICAgIC8vIFNjaGVkdWxlIGFuZCBmbHVzaCBhIHJlc2l6ZSBoYW5kbGVyXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlcigpO1xuICAgIGZsdXNoKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IF9zY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcDtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXQgX3Njcm9sbFRvcCh0b3ApIHtcbiAgICB0aGlzLnNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSB0b3A7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IE1hdGgubWluKHRoaXMuc2l6ZSwgTUFYX1ZJUlRVQUxfQ09VTlQpLFxuICAgIH07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZ2V0IG9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxUYXJnZXQub2Zmc2V0SGVpZ2h0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGdldCAkKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtczogdGhpcy5zY3JvbGxDb250YWluZXIsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1cGRhdGVWaWV3cG9ydEJvdW5kYXJpZXMoKSB7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxUYXJnZXQpO1xuICAgIHRoaXMuX3Njcm9sbGVyUGFkZGluZ1RvcCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID09PSB0aGlzID8gMCA6IHBhcnNlSW50KHN0eWxlc1sncGFkZGluZy10b3AnXSwgMTApO1xuICAgIHRoaXMuX2lzUlRMID0gQm9vbGVhbihzdHlsZXMuZGlyZWN0aW9uID09PSAncnRsJyk7XG4gICAgdGhpcy5fdmlld3BvcnRXaWR0aCA9IHRoaXMuZWxlbWVudHNDb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5fdmlld3BvcnRIZWlnaHQgPSB0aGlzLnNjcm9sbFRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5fc2Nyb2xsUGFnZUhlaWdodCA9IHRoaXMuX3ZpZXdwb3J0SGVpZ2h0IC0gdGhpcy5fc2Nyb2xsTGluZUhlaWdodDtcbiAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICB0aGlzLl91cGRhdGVHcmlkTWV0cmljcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBzZXRBdHRyaWJ1dGUoKSB7fVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfY3JlYXRlUG9vbChzaXplKSB7XG4gICAgY29uc3QgcGh5c2ljYWxJdGVtcyA9IHRoaXMuY3JlYXRlRWxlbWVudHMoc2l6ZSk7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgcGh5c2ljYWxJdGVtcy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgdGhpcy5fX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWwpO1xuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHNDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIHJldHVybiBwaHlzaWNhbEl0ZW1zO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9hc3NpZ25Nb2RlbHMoaXRlbVNldCkge1xuICAgIHRoaXMuX2l0ZXJhdGVJdGVtcygocGlkeCwgdmlkeCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLl9waHlzaWNhbEl0ZW1zW3BpZHhdO1xuICAgICAgZWwuaGlkZGVuID0gdmlkeCA+PSB0aGlzLnNpemU7XG4gICAgICBpZiAoIWVsLmhpZGRlbikge1xuICAgICAgICBlbC5fX3ZpcnR1YWxJbmRleCA9IHZpZHggKyAodGhpcy5fdmlkeE9mZnNldCB8fCAwKTtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUVsZW1lbnQoZWwsIGVsLl9fdmlydHVhbEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBlbC5fX2xhc3RVcGRhdGVkSW5kZXg7XG4gICAgICB9XG4gICAgfSwgaXRlbVNldCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2lzQ2xpZW50RnVsbCgpIHtcbiAgICAvLyBXb3JrYXJvdW5kIGFuIGlzc3VlIGluIGlyb24tbGlzdCB0aGF0IGNhbiBjYXVzZSBpdCB0byBmcmVlemUgb24gZmFzdCBzY3JvbGxcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX19jbGllbnRGdWxsID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fX2NsaWVudEZ1bGwgfHwgc3VwZXIuX2lzQ2xpZW50RnVsbCgpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRyYW5zbGF0ZTNkKF94LCB5LCBfeiwgZWwpIHtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke3l9KWA7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdG9nZ2xlU2Nyb2xsTGlzdGVuZXIoKSB7fVxuXG4gIF9zY3JvbGxIYW5kbGVyKCkge1xuICAgIHRoaXMuX2FkanVzdFZpcnR1YWxJbmRleE9mZnNldCh0aGlzLl9zY3JvbGxUb3AgLSAodGhpcy5fX3ByZXZpb3VzU2Nyb2xsVG9wIHx8IDApKTtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbFRvcCAtIHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuXG4gICAgc3VwZXIuX3Njcm9sbEhhbmRsZXIoKTtcblxuICAgIGlmICh0aGlzLl9waHlzaWNhbENvdW50ICE9PSAwKSB7XG4gICAgICBjb25zdCBpc1Njcm9sbGluZ0Rvd24gPSBkZWx0YSA+PSAwO1xuICAgICAgY29uc3QgcmV1c2FibGVzID0gdGhpcy5fZ2V0UmV1c2FibGVzKCFpc1Njcm9sbGluZ0Rvd24pO1xuXG4gICAgICBpZiAocmV1c2FibGVzLmluZGV4ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFmdGVyIHJ1bm5pbmcgc3VwZXIuX3Njcm9sbEhhbmRsZXIsIGZpeCBpbnRlcm5hbCBwcm9wZXJ0aWVzIHRvIHdvcmthcm91bmQgYW4gaXJvbi1saXN0IGlzc3VlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZhYWRpbi93ZWItY29tcG9uZW50cy9pc3N1ZXMvMTY5MVxuICAgICAgICB0aGlzLl9waHlzaWNhbFRvcCA9IHJldXNhYmxlcy5waHlzaWNhbFRvcDtcblxuICAgICAgICBpZiAoaXNTY3JvbGxpbmdEb3duKSB7XG4gICAgICAgICAgdGhpcy5fdmlydHVhbFN0YXJ0IC09IHJldXNhYmxlcy5pbmRleGVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9waHlzaWNhbFN0YXJ0IC09IHJldXNhYmxlcy5pbmRleGVzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl92aXJ0dWFsU3RhcnQgKz0gcmV1c2FibGVzLmluZGV4ZXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX3BoeXNpY2FsU3RhcnQgKz0gcmV1c2FibGVzLmluZGV4ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIC8vIFRoZXJlIHdhcyBhIGNoYW5nZSBpbiBzY3JvbGwgdG9wLiBTY2hlZHVsZSBhIGNoZWNrIGZvciBpbnZhbGlkIGl0ZW0gcG9zaXRpb25pbmcuXG4gICAgICB0aGlzLl9fZml4SW52YWxpZEl0ZW1Qb3NpdGlvbmluZ0RlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgdGhpcy5fX2ZpeEludmFsaWRJdGVtUG9zaXRpb25pbmdEZWJvdW5jZXIsXG4gICAgICAgIHRpbWVPdXQuYWZ0ZXIodGhpcy50aW1lb3V0cy5GSVhfSU5WQUxJRF9JVEVNX1BPU0lUSU9OSU5HKSxcbiAgICAgICAgKCkgPT4gdGhpcy5fX2ZpeEludmFsaWRJdGVtUG9zaXRpb25pbmcoKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVvcmRlckVsZW1lbnRzKSB7XG4gICAgICB0aGlzLl9fc2Nyb2xsUmVvcmRlckRlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgdGhpcy5fX3Njcm9sbFJlb3JkZXJEZWJvdW5jZXIsXG4gICAgICAgIHRpbWVPdXQuYWZ0ZXIodGhpcy50aW1lb3V0cy5TQ1JPTExfUkVPUkRFUiksXG4gICAgICAgICgpID0+IHRoaXMuX19yZW9yZGVyRWxlbWVudHMoKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fX3ByZXZpb3VzU2Nyb2xsVG9wID0gdGhpcy5fc2Nyb2xsVG9wO1xuXG4gICAgLy8gSWYgdGhlIGZpcnN0IHZpc2libGUgaW5kZXggaXMgbm90IDAgd2hlbiBzY3JvbGxlZCB0byB0aGUgdG9wLFxuICAgIC8vIHNjcm9sbCB0byBpbmRleCAwIHRvIGZpeCB0aGUgaXNzdWUuXG4gICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA9PT0gMCAmJiB0aGlzLmZpcnN0VmlzaWJsZUluZGV4ICE9PSAwICYmIE1hdGguYWJzKGRlbHRhKSA+IDApIHtcbiAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleCgwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV29yayBhcm91bmQgYW4gaXJvbi1saXN0IGlzc3VlIHdpdGggaW52YWxpZCBpdGVtIHBvc2l0aW9uaW5nLlxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZhYWRpbi9mbG93LWNvbXBvbmVudHMvaXNzdWVzLzQzMDZcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fZml4SW52YWxpZEl0ZW1Qb3NpdGlvbmluZygpIHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsVGFyZ2V0LmlzQ29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IHBoeXNpY2FsIGl0ZW0gZWxlbWVudCBpcyBiZWxvdyB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydFxuICAgIGNvbnN0IHBoeXNpY2FsVG9wQmVsb3dUb3AgPSB0aGlzLl9waHlzaWNhbFRvcCA+IHRoaXMuX3Njcm9sbFRvcDtcbiAgICAvLyBDaGVjayBpZiB0aGUgbGFzdCBwaHlzaWNhbCBpdGVtIGVsZW1lbnQgaXMgYWJvdmUgdGhlIGJvdHRvbSBvZiB0aGUgdmlld3BvcnRcbiAgICBjb25zdCBwaHlzaWNhbEJvdHRvbUFib3ZlQm90dG9tID0gdGhpcy5fcGh5c2ljYWxCb3R0b20gPCB0aGlzLl9zY3JvbGxCb3R0b207XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgaW5kZXggaXMgdmlzaWJsZVxuICAgIGNvbnN0IGZpcnN0SW5kZXhWaXNpYmxlID0gdGhpcy5hZGp1c3RlZEZpcnN0VmlzaWJsZUluZGV4ID09PSAwO1xuICAgIC8vIENoZWNrIGlmIHRoZSBsYXN0IGluZGV4IGlzIHZpc2libGVcbiAgICBjb25zdCBsYXN0SW5kZXhWaXNpYmxlID0gdGhpcy5hZGp1c3RlZExhc3RWaXNpYmxlSW5kZXggPT09IHRoaXMuc2l6ZSAtIDE7XG5cbiAgICBpZiAoKHBoeXNpY2FsVG9wQmVsb3dUb3AgJiYgIWZpcnN0SW5kZXhWaXNpYmxlKSB8fCAocGh5c2ljYWxCb3R0b21BYm92ZUJvdHRvbSAmJiAhbGFzdEluZGV4VmlzaWJsZSkpIHtcbiAgICAgIC8vIEludmFsaWQgc3RhdGUhIFRyeSB0byByZWNvdmVyLlxuXG4gICAgICBjb25zdCBpc1Njcm9sbGluZ0Rvd24gPSBwaHlzaWNhbEJvdHRvbUFib3ZlQm90dG9tO1xuICAgICAgLy8gU2V0IHRoZSBcIl9yYXRpb1wiIHByb3BlcnR5IHRlbXBvcmFyaWx5IHRvIDAgdG8gbWFrZSBpcm9uLWxpc3QncyBfZ2V0UmV1c2FibGVzXG4gICAgICAvLyBwbGFjZSBhbGwgdGhlIGZyZWUgcGh5c2ljYWwgaXRlbXMgb24gb25lIHNpZGUgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgY29uc3Qgb3JpZ2luYWxSYXRpbyA9IHRoaXMuX3JhdGlvO1xuICAgICAgdGhpcy5fcmF0aW8gPSAwO1xuICAgICAgLy8gRmFrZSBhIHNjcm9sbCBjaGFuZ2UgdG8gbWFrZSBfc2Nyb2xsSGFuZGxlciBwbGFjZSB0aGUgcGh5c2ljYWwgaXRlbXNcbiAgICAgIC8vIG9uIHRoZSBkZXNpcmVkIHNpZGUuXG4gICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3Njcm9sbFRvcCArIChpc1Njcm9sbGluZ0Rvd24gPyAtMSA6IDEpO1xuICAgICAgdGhpcy5fc2Nyb2xsSGFuZGxlcigpO1xuICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgXCJfcmF0aW9cIiB2YWx1ZS5cbiAgICAgIHRoaXMuX3JhdGlvID0gb3JpZ2luYWxSYXRpbztcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX19vbldoZWVsKGUpIHtcbiAgICBpZiAoZS5jdHJsS2V5IHx8IHRoaXMuX2hhc1Njcm9sbGVkQW5jZXN0b3IoZS50YXJnZXQsIGUuZGVsdGFYLCBlLmRlbHRhWSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZGVsdGFZID0gZS5kZWx0YVk7XG4gICAgaWYgKGUuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICAvLyBTY3JvbGxpbmcgYnkgXCJsaW5lcyBvZiB0ZXh0XCIgaW5zdGVhZCBvZiBwaXhlbHNcbiAgICAgIGRlbHRhWSAqPSB0aGlzLl9zY3JvbGxMaW5lSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoZS5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UpIHtcbiAgICAgIC8vIFNjcm9sbGluZyBieSBcInBhZ2VzXCIgaW5zdGVhZCBvZiBwaXhlbHNcbiAgICAgIGRlbHRhWSAqPSB0aGlzLl9zY3JvbGxQYWdlSGVpZ2h0O1xuICAgIH1cblxuICAgIHRoaXMuX2RlbHRhWUFjYyA9IHRoaXMuX2RlbHRhWUFjYyB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3doZWVsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIC8vIEFjY3VtdWxhdGUgd2hlZWwgZGVsdGEgd2hpbGUgYSBmcmFtZSBpcyBiZWluZyBwcm9jZXNzZWRcbiAgICAgIHRoaXMuX2RlbHRhWUFjYyArPSBkZWx0YVk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsdGFZICs9IHRoaXMuX2RlbHRhWUFjYztcbiAgICB0aGlzLl9kZWx0YVlBY2MgPSAwO1xuXG4gICAgdGhpcy5fd2hlZWxBbmltYXRpb25GcmFtZSA9IHRydWU7XG4gICAgdGhpcy5fX2RlYm91bmNlcldoZWVsQW5pbWF0aW9uRnJhbWUgPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICB0aGlzLl9fZGVib3VuY2VyV2hlZWxBbmltYXRpb25GcmFtZSxcbiAgICAgIGFuaW1hdGlvbkZyYW1lLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl93aGVlbEFuaW1hdGlvbkZyYW1lID0gZmFsc2U7XG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCBtb21lbnR1bSA9IE1hdGguYWJzKGUuZGVsdGFYKSArIE1hdGguYWJzKGRlbHRhWSk7XG5cbiAgICBpZiAodGhpcy5fY2FuU2Nyb2xsKHRoaXMuc2Nyb2xsVGFyZ2V0LCBlLmRlbHRhWCwgZGVsdGFZKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zY3JvbGxUYXJnZXQuc2Nyb2xsVG9wICs9IGRlbHRhWTtcbiAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbExlZnQgKz0gZS5kZWx0YVg7XG5cbiAgICAgIHRoaXMuX2hhc1Jlc2lkdWFsTW9tZW50dW0gPSB0cnVlO1xuXG4gICAgICB0aGlzLl9pZ25vcmVOZXdXaGVlbCA9IHRydWU7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJJZ25vcmVOZXdXaGVlbCA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgdGhpcy5fZGVib3VuY2VySWdub3JlTmV3V2hlZWwsXG4gICAgICAgIHRpbWVPdXQuYWZ0ZXIodGhpcy50aW1lb3V0cy5JR05PUkVfV0hFRUwpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faWdub3JlTmV3V2hlZWwgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgodGhpcy5faGFzUmVzaWR1YWxNb21lbnR1bSAmJiBtb21lbnR1bSA8PSB0aGlzLl9wcmV2aW91c01vbWVudHVtKSB8fCB0aGlzLl9pZ25vcmVOZXdXaGVlbCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAobW9tZW50dW0gPiB0aGlzLl9wcmV2aW91c01vbWVudHVtKSB7XG4gICAgICB0aGlzLl9oYXNSZXNpZHVhbE1vbWVudHVtID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZpb3VzTW9tZW50dW0gPSBtb21lbnR1bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IGhhcyBhbiBhbmNlc3RvciB0aGF0IGhhbmRsZXMgdGhlIHNjcm9sbCBkZWx0YSBwcmlvciB0byB0aGlzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFzU2Nyb2xsZWRBbmNlc3RvcihlbCwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBpZiAoZWwgPT09IHRoaXMuc2Nyb2xsVGFyZ2V0IHx8IGVsID09PSB0aGlzLnNjcm9sbFRhcmdldC5nZXRSb290Tm9kZSgpLmhvc3QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fY2FuU2Nyb2xsKGVsLCBkZWx0YVgsIGRlbHRhWSkgJiZcbiAgICAgIFsnYXV0bycsICdzY3JvbGwnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWwpLm92ZXJmbG93KSAhPT0gLTFcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWwgIT09IHRoaXMgJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Njcm9sbGVkQW5jZXN0b3IoZWwucGFyZW50RWxlbWVudCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIH1cbiAgfVxuXG4gIF9jYW5TY3JvbGwoZWwsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChkZWx0YVkgPiAwICYmIGVsLnNjcm9sbFRvcCA8IGVsLnNjcm9sbEhlaWdodCAtIGVsLm9mZnNldEhlaWdodCkgfHxcbiAgICAgIChkZWx0YVkgPCAwICYmIGVsLnNjcm9sbFRvcCA+IDApIHx8XG4gICAgICAoZGVsdGFYID4gMCAmJiBlbC5zY3JvbGxMZWZ0IDwgZWwuc2Nyb2xsV2lkdGggLSBlbC5vZmZzZXRXaWR0aCkgfHxcbiAgICAgIChkZWx0YVggPCAwICYmIGVsLnNjcm9sbExlZnQgPiAwKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge051bWJlcnx1bmRlZmluZWR9IC0gVGhlIGJyb3dzZXIncyBkZWZhdWx0IGZvbnQtc2l6ZSBpbiBwaXhlbHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRTY3JvbGxMaW5lSGVpZ2h0KCkge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUuZm9udFNpemUgPSAnaW5pdGlhbCc7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5mb250U2l6ZTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gZm9udFNpemUgPyB3aW5kb3cucGFyc2VJbnQoZm9udFNpemUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgX19nZXRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50c0NvbnRhaW5lci5jaGlsZHJlbikuZmlsdGVyKChlbGVtZW50KSA9PiAhZWxlbWVudC5oaWRkZW4pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9fcmVvcmRlckVsZW1lbnRzKCkge1xuICAgIGlmICh0aGlzLl9fbW91c2VEb3duKSB7XG4gICAgICB0aGlzLl9fcGVuZGluZ1Jlb3JkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fcGVuZGluZ1Jlb3JkZXIgPSBmYWxzZTtcblxuICAgIGNvbnN0IGFkanVzdGVkVmlydHVhbFN0YXJ0ID0gdGhpcy5fdmlydHVhbFN0YXJ0ICsgKHRoaXMuX3ZpZHhPZmZzZXQgfHwgMCk7XG5cbiAgICAvLyBXaGljaCByb3cgdG8gdXNlIGFzIGEgdGFyZ2V0P1xuICAgIGNvbnN0IHZpc2libGVFbGVtZW50cyA9IHRoaXMuX19nZXRWaXNpYmxlRWxlbWVudHMoKTtcblxuICAgIGNvbnN0IGVsZW1lbnRXaXRoRm9jdXMgPSB2aXNpYmxlRWxlbWVudHMuZmluZChcbiAgICAgIChlbGVtZW50KSA9PlxuICAgICAgICBlbGVtZW50LmNvbnRhaW5zKHRoaXMuZWxlbWVudHNDb250YWluZXIuZ2V0Um9vdE5vZGUoKS5hY3RpdmVFbGVtZW50KSB8fFxuICAgICAgICBlbGVtZW50LmNvbnRhaW5zKHRoaXMuc2Nyb2xsVGFyZ2V0LmdldFJvb3ROb2RlKCkuYWN0aXZlRWxlbWVudCksXG4gICAgKTtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZWxlbWVudFdpdGhGb2N1cyB8fCB2aXNpYmxlRWxlbWVudHNbMF07XG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgICAvLyBBbGwgZWxlbWVudHMgYXJlIGhpZGRlbiwgZG9uJ3QgcmVvcmRlclxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoZXJlIHRoZSB0YXJnZXQgcm93IHNob3VsZCBiZT9cbiAgICBjb25zdCB0YXJnZXRQaHlzaWNhbEluZGV4ID0gdGFyZ2V0RWxlbWVudC5fX3ZpcnR1YWxJbmRleCAtIGFkanVzdGVkVmlydHVhbFN0YXJ0O1xuXG4gICAgLy8gUmVvZHJlciB0aGUgRE9NIGVsZW1lbnRzIHRvIGtlZXAgdGhlIHRhcmdldCByb3cgYXQgdGhlIHRhcmdldCBwaHlzaWNhbCBpbmRleFxuICAgIGNvbnN0IGRlbHRhID0gdmlzaWJsZUVsZW1lbnRzLmluZGV4T2YodGFyZ2V0RWxlbWVudCkgLSB0YXJnZXRQaHlzaWNhbEluZGV4O1xuICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGE7IGkrKykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzQ29udGFpbmVyLmFwcGVuZENoaWxkKHZpc2libGVFbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSB2aXNpYmxlRWxlbWVudHMubGVuZ3RoICsgZGVsdGE7IGkgPCB2aXNpYmxlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c0NvbnRhaW5lci5pbnNlcnRCZWZvcmUodmlzaWJsZUVsZW1lbnRzW2ldLCB2aXNpYmxlRWxlbWVudHNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIER1ZSB0byBhIHJlbmRlcmluZyBidWcsIHJlb3JkZXJpbmcgdGhlIHJvd3MgY2FuIG1ha2UgcGFydHMgb2YgdGhlIHNjcm9sbCB0YXJnZXQgZGlzYXBwZWFyXG4gICAgLy8gb24gU2FmYXJpIHdoZW4gdXNpbmcgc3RpY2t5IHBvc2l0aW9uaW5nIGluIGNhc2UgdGhlIHNjcm9sbCB0YXJnZXQgaXMgaW5zaWRlIGEgZmxleGJveC5cbiAgICAvLyBUaGlzIGlzc3VlIG1hbmlmZXN0cyB3aXRoIGdyaWQgKHRoZSBoZWFkZXIgY2FuIGRpc2FwcGVhciBpZiBncmlkIGlzIHVzZWQgaW5zaWRlIGEgZmxleGJveClcbiAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNmb3JtIH0gPSB0aGlzLnNjcm9sbFRhcmdldC5zdHlsZTtcbiAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2FkanVzdFZpcnR1YWxJbmRleE9mZnNldChkZWx0YSkge1xuICAgIGlmICh0aGlzLl92aXJ0dWFsQ291bnQgPj0gdGhpcy5zaXplKSB7XG4gICAgICB0aGlzLl92aWR4T2Zmc2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX19za2lwTmV4dFZpcnR1YWxJbmRleEFkanVzdCkge1xuICAgICAgdGhpcy5fX3NraXBOZXh0VmlydHVhbEluZGV4QWRqdXN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChNYXRoLmFicyhkZWx0YSkgPiAxMDAwMCkge1xuICAgICAgLy8gUHJvY2VzcyBhIGxhcmdlIHNjcm9sbCBwb3NpdGlvbiBjaGFuZ2VcbiAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fc2Nyb2xsVG9wIC8gKHRoaXMuc2Nyb2xsVGFyZ2V0LnNjcm9sbEhlaWdodCAtIHRoaXMuc2Nyb2xsVGFyZ2V0Lm9mZnNldEhlaWdodCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBzY2FsZSAqIHRoaXMuc2l6ZTtcbiAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCAtIHNjYWxlICogdGhpcy5fdmlydHVhbENvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFrZSBzdXJlIHVzZXIgY2FuIGFsd2F5cyBzd2lwZS93aGVlbCBzY3JvbGwgdG8gdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICAgIGNvbnN0IG9sZE9mZnNldCA9IHRoaXMuX3ZpZHhPZmZzZXQ7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBPRkZTRVRfQURKVVNUX01JTl9USFJFU0hPTEQ7XG4gICAgICBjb25zdCBtYXhTaGlmdCA9IDEwMDtcblxuICAgICAgLy8gTmVhciBzdGFydFxuICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICB0aGlzLl92aWR4T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKG9sZE9mZnNldCAhPT0gdGhpcy5fdmlkeE9mZnNldCkge1xuICAgICAgICAgIHN1cGVyLnNjcm9sbFRvSW5kZXgoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5maXJzdFZpc2libGVJbmRleCA8IHRocmVzaG9sZCAmJiB0aGlzLl92aWR4T2Zmc2V0ID4gMCkge1xuICAgICAgICB0aGlzLl92aWR4T2Zmc2V0IC09IE1hdGgubWluKHRoaXMuX3ZpZHhPZmZzZXQsIG1heFNoaWZ0KTtcbiAgICAgICAgc3VwZXIuc2Nyb2xsVG9JbmRleCh0aGlzLmZpcnN0VmlzaWJsZUluZGV4ICsgKG9sZE9mZnNldCAtIHRoaXMuX3ZpZHhPZmZzZXQpKTtcbiAgICAgIH1cblxuICAgICAgLy8gTmVhciBlbmRcbiAgICAgIGNvbnN0IG1heE9mZnNldCA9IHRoaXMuc2l6ZSAtIHRoaXMuX3ZpcnR1YWxDb3VudDtcbiAgICAgIGlmICh0aGlzLl9zY3JvbGxUb3AgPj0gdGhpcy5fbWF4U2Nyb2xsVG9wICYmIHRoaXMuX21heFNjcm9sbFRvcCA+IDApIHtcbiAgICAgICAgdGhpcy5fdmlkeE9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgICAgaWYgKG9sZE9mZnNldCAhPT0gdGhpcy5fdmlkeE9mZnNldCkge1xuICAgICAgICAgIHN1cGVyLnNjcm9sbFRvSW5kZXgodGhpcy5fdmlydHVhbENvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5maXJzdFZpc2libGVJbmRleCA+IHRoaXMuX3ZpcnR1YWxDb3VudCAtIHRocmVzaG9sZCAmJiB0aGlzLl92aWR4T2Zmc2V0IDwgbWF4T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3ZpZHhPZmZzZXQgKz0gTWF0aC5taW4obWF4T2Zmc2V0IC0gdGhpcy5fdmlkeE9mZnNldCwgbWF4U2hpZnQpO1xuICAgICAgICBzdXBlci5zY3JvbGxUb0luZGV4KHRoaXMuZmlyc3RWaXNpYmxlSW5kZXggLSAodGhpcy5fdmlkeE9mZnNldCAtIG9sZE9mZnNldCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoSXJvbkxpc3RBZGFwdGVyLnByb3RvdHlwZSwgaXJvbkxpc3QpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/component-base/src/virtualizer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vaadin/component-base/src/virtualizer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Virtualizer\": () => (/* binding */ Virtualizer)\n/* harmony export */ });\n/* harmony import */ var _virtualizer_iron_list_adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./virtualizer-iron-list-adapter.js */ \"./node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js\");\n\nclass Virtualizer {\n  /**\n   * @typedef {Object} VirtualizerConfig\n   * @property {Function} createElements Function that returns the given number of new elements\n   * @property {Function} updateElement Function that updates the element at a specific index\n   * @property {HTMLElement} scrollTarget Reference to the scrolling element\n   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget\n   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer\n   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM\n   * @param {VirtualizerConfig} config Configuration for the virtualizer\n   */\n  constructor(config) {\n    this.__adapter = new _virtualizer_iron_list_adapter_js__WEBPACK_IMPORTED_MODULE_0__.IronListAdapter(config);\n  }\n\n  /**\n   * The size of the virtualizer\n   * @return {number | undefined} The size of the virtualizer\n   */\n  get size() {\n    return this.__adapter.size;\n  }\n\n  /**\n   * The size of the virtualizer\n   * @param {number} size The size of the virtualizer\n   */\n  set size(size) {\n    this.__adapter.size = size;\n  }\n\n  /**\n   * Scroll to a specific index in the virtual list\n   *\n   * @method scrollToIndex\n   * @param {number} index The index of the item\n   */\n  scrollToIndex(index) {\n    this.__adapter.scrollToIndex(index);\n  }\n\n  /**\n   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n  update(startIndex = 0, endIndex = this.size - 1) {\n    this.__adapter.update(startIndex, endIndex);\n  }\n\n  /**\n   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state\n   *\n   * @method update\n   * @param {number | undefined} startIndex The start index of the range\n   * @param {number | undefined} endIndex The end index of the range\n   */\n  flush() {\n    this.__adapter.flush();\n  }\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get firstVisibleIndex() {\n    return this.__adapter.adjustedFirstVisibleIndex;\n  }\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @return {number}\n   */\n  get lastVisibleIndex() {\n    return this.__adapter.adjustedLastVisibleIndex;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvdmlydHVhbGl6ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy92aXJ0dWFsaXplci5qcz85ZmY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElyb25MaXN0QWRhcHRlciB9IGZyb20gJy4vdmlydHVhbGl6ZXItaXJvbi1saXN0LWFkYXB0ZXIuanMnO1xuXG5leHBvcnQgY2xhc3MgVmlydHVhbGl6ZXIge1xuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gVmlydHVhbGl6ZXJDb25maWdcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY3JlYXRlRWxlbWVudHMgRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBnaXZlbiBudW1iZXIgb2YgbmV3IGVsZW1lbnRzXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVwZGF0ZUVsZW1lbnQgRnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gc2Nyb2xsVGFyZ2V0IFJlZmVyZW5jZSB0byB0aGUgc2Nyb2xsaW5nIGVsZW1lbnRcbiAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gc2Nyb2xsQ29udGFpbmVyIFJlZmVyZW5jZSB0byBhIHdyYXBwZXIgZm9yIHRoZSBpdGVtIGVsZW1lbnRzIChvciBhIHNsb3QpIGluc2lkZSB0aGUgc2Nyb2xsVGFyZ2V0XG4gICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9IGVsZW1lbnRzQ29udGFpbmVyIFJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGluIHdoaWNoIHRoZSBpdGVtIGVsZW1lbnRzIGFyZSBwbGFjZWQsIGRlZmF1bHRzIHRvIHNjcm9sbENvbnRhaW5lclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB1bmRlZmluZWR9IHJlb3JkZXJFbGVtZW50cyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBoeXNpY2FsIGl0ZW0gZWxlbWVudHMgc2hvdWxkIGJlIGtlcHQgaW4gb3JkZXIgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1ZpcnR1YWxpemVyQ29uZmlnfSBjb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZpcnR1YWxpemVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9fYWRhcHRlciA9IG5ldyBJcm9uTGlzdEFkYXB0ZXIoY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgdmlydHVhbGl6ZXJcbiAgICogQHJldHVybiB7bnVtYmVyIHwgdW5kZWZpbmVkfSBUaGUgc2l6ZSBvZiB0aGUgdmlydHVhbGl6ZXJcbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9fYWRhcHRlci5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSB2aXJ0dWFsaXplclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgdmlydHVhbGl6ZXJcbiAgICovXG4gIHNldCBzaXplKHNpemUpIHtcbiAgICB0aGlzLl9fYWRhcHRlci5zaXplID0gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gYSBzcGVjaWZpYyBpbmRleCBpbiB0aGUgdmlydHVhbCBsaXN0XG4gICAqXG4gICAqIEBtZXRob2Qgc2Nyb2xsVG9JbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpdGVtXG4gICAqL1xuICBzY3JvbGxUb0luZGV4KGluZGV4KSB7XG4gICAgdGhpcy5fX2FkYXB0ZXIuc2Nyb2xsVG9JbmRleChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHZpcnR1YWxpemVyIHRvIHJlLXJlbmRlciB0aGUgaXRlbSBlbGVtZW50cyBvbiBhbiBpbmRleCByYW5nZSwgaWYgY3VycmVudGx5IGluIHRoZSBET01cbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZVxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2VcbiAgICovXG4gIHVwZGF0ZShzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSB0aGlzLnNpemUgLSAxKSB7XG4gICAgdGhpcy5fX2FkYXB0ZXIudXBkYXRlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGVzIGFjdGl2ZSBhc3luY2hyb25vdXMgdGFza3Mgc28gdGhhdCB0aGUgY29tcG9uZW50IGFuZCB0aGUgRE9NIGVuZCB1cCBpbiBhIHN0YWJsZSBzdGF0ZVxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZVxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgdGhpcy5fX2FkYXB0ZXIuZmx1c2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdmlzaWJsZSBpdGVtIGluIHRoZSB2aWV3cG9ydC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGZpcnN0VmlzaWJsZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9fYWRhcHRlci5hZGp1c3RlZEZpcnN0VmlzaWJsZUluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHZpc2libGUgaXRlbSBpbiB0aGUgdmlld3BvcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBsYXN0VmlzaWJsZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9fYWRhcHRlci5hZGp1c3RlZExhc3RWaXNpYmxlSW5kZXg7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/component-base/src/virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/field-base/src/input-mixin.js":
/*!************************************************************!*\
  !*** ./node_modules/@vaadin/field-base/src/input-mixin.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputMixin\": () => (/* binding */ InputMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * A mixin to store the reference to an input element\n * and add input and change event listeners to it.\n *\n * @polymerMixin\n */\nconst InputMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superclass => class InputMixinClass extends superclass {\n  static get properties() {\n    return {\n      /**\n       * A reference to the input element controlled by the mixin.\n       * Any component implementing this mixin is expected to provide it\n       * by using `this._setInputElement(input)` Polymer API.\n       *\n       * A typical case is using `InputController` that does this automatically.\n       * However, the input element does not have to always be native <input>:\n       * as an example, <vaadin-combo-box-light> accepts other components.\n       *\n       * @protected\n       * @type {!HTMLElement}\n       */\n      inputElement: {\n        type: Object,\n        readOnly: true,\n        observer: '_inputElementChanged'\n      },\n      /**\n       * String used to define input type.\n       * @protected\n       */\n      type: {\n        type: String,\n        readOnly: true\n      },\n      /**\n       * The value of the field.\n       */\n      value: {\n        type: String,\n        value: '',\n        observer: '_valueChanged',\n        notify: true\n      },\n      /**\n       * When true, the input element has a non-empty value entered by the user.\n       * @protected\n       */\n      _hasInputValue: {\n        type: Boolean,\n        value: false,\n        observer: '_hasInputValueChanged'\n      }\n    };\n  }\n  constructor() {\n    super();\n    this._boundOnInput = this.__onInput.bind(this);\n    this._boundOnChange = this._onChange.bind(this);\n  }\n\n  /**\n   * Clear the value of the field.\n   */\n  clear() {\n    this.value = '';\n  }\n\n  /**\n   * Add event listeners to the input element instance.\n   * Override this method to add custom listeners.\n   * @param {!HTMLElement} input\n   * @protected\n   */\n  _addInputListeners(input) {\n    input.addEventListener('input', this._boundOnInput);\n    input.addEventListener('change', this._boundOnChange);\n  }\n\n  /**\n   * Remove event listeners from the input element instance.\n   * @param {!HTMLElement} input\n   * @protected\n   */\n  _removeInputListeners(input) {\n    input.removeEventListener('input', this._boundOnInput);\n    input.removeEventListener('change', this._boundOnChange);\n  }\n\n  /**\n   * A method to forward the value property set on the field\n   * programmatically back to the input element value.\n   * Override this method to perform additional checks,\n   * for example to skip this in certain conditions.\n   * @param {string} value\n   * @protected\n   */\n  _forwardInputValue(value) {\n    // Value might be set before an input element is initialized.\n    // This case should be handled separately by a component that\n    // implements this mixin, for example in `connectedCallback`.\n    if (!this.inputElement) {\n      return;\n    }\n    if (value != null) {\n      this.inputElement.value = value;\n    } else {\n      this.inputElement.value = '';\n    }\n  }\n\n  /**\n   * @param {HTMLElement | undefined} input\n   * @param {HTMLElement | undefined} oldInput\n   * @protected\n   */\n  _inputElementChanged(input, oldInput) {\n    if (input) {\n      this._addInputListeners(input);\n    } else if (oldInput) {\n      this._removeInputListeners(oldInput);\n    }\n  }\n\n  /**\n   * Observer to notify about the change of private property.\n   *\n   * @private\n   */\n  _hasInputValueChanged(hasValue, oldHasValue) {\n    if (hasValue || oldHasValue) {\n      this.dispatchEvent(new CustomEvent('has-input-value-changed'));\n    }\n  }\n\n  /**\n   * An input event listener used to update `_hasInputValue` property.\n   * Do not override this method.\n   *\n   * @param {Event} event\n   * @private\n   */\n  __onInput(event) {\n    this._setHasInputValue(event);\n    this._onInput(event);\n  }\n\n  /**\n   * An input event listener used to update the field value.\n   *\n   * @param {Event} event\n   * @protected\n   */\n  _onInput(event) {\n    // In the case a custom web component is passed as `inputElement`,\n    // the actual native input element, on which the event occurred,\n    // can be inside shadow trees.\n    const target = event.composedPath()[0];\n    // Ignore fake input events e.g. used by clear button.\n    this.__userInput = event.isTrusted;\n    this.value = target.value;\n    this.__userInput = false;\n  }\n\n  /**\n   * A change event listener.\n   * Override this method with an actual implementation.\n   * @param {Event} _event\n   * @protected\n   */\n  _onChange(_event) {}\n\n  /**\n   * Toggle the has-value attribute based on the value property.\n   *\n   * @param {boolean} hasValue\n   * @protected\n   */\n  _toggleHasValue(hasValue) {\n    this.toggleAttribute('has-value', hasValue);\n  }\n\n  /**\n   * Observer called when a value property changes.\n   * @param {string | undefined} newVal\n   * @param {string | undefined} oldVal\n   * @protected\n   */\n  _valueChanged(newVal, oldVal) {\n    this._toggleHasValue(this._hasValue);\n\n    // Setting initial value to empty string, do nothing.\n    if (newVal === '' && oldVal === undefined) {\n      return;\n    }\n\n    // Value is set by the user, no need to sync it back to input.\n    if (this.__userInput) {\n      return;\n    }\n\n    // Setting a value programmatically, sync it to input element.\n    this._forwardInputValue(newVal);\n  }\n\n  /**\n   * Indicates whether the value is different from the default one.\n   * Override if the `value` property has a type other than `string`.\n   *\n   * @protected\n   */\n  get _hasValue() {\n    return this.value != null && this.value !== '';\n  }\n\n  /**\n   * Sets the `_hasInputValue` property based on the `input` event.\n   *\n   * @param {InputEvent} event\n   * @protected\n   */\n  _setHasInputValue(event) {\n    // In the case a custom web component is passed as `inputElement`,\n    // the actual native input element, on which the event occurred,\n    // can be inside shadow trees.\n    const target = event.composedPath()[0];\n    this._hasInputValue = target.value.length > 0;\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL3NyYy9pbnB1dC1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL3NyYy9pbnB1dC1taXhpbi5qcz80Yzc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzJztcblxuLyoqXG4gKiBBIG1peGluIHRvIHN0b3JlIHRoZSByZWZlcmVuY2UgdG8gYW4gaW5wdXQgZWxlbWVudFxuICogYW5kIGFkZCBpbnB1dCBhbmQgY2hhbmdlIGV2ZW50IGxpc3RlbmVycyB0byBpdC5cbiAqXG4gKiBAcG9seW1lck1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBJbnB1dE1peGluID0gZGVkdXBpbmdNaXhpbihcbiAgKHN1cGVyY2xhc3MpID0+XG4gICAgY2xhc3MgSW5wdXRNaXhpbkNsYXNzIGV4dGVuZHMgc3VwZXJjbGFzcyB7XG4gICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGlucHV0IGVsZW1lbnQgY29udHJvbGxlZCBieSB0aGUgbWl4aW4uXG4gICAgICAgICAgICogQW55IGNvbXBvbmVudCBpbXBsZW1lbnRpbmcgdGhpcyBtaXhpbiBpcyBleHBlY3RlZCB0byBwcm92aWRlIGl0XG4gICAgICAgICAgICogYnkgdXNpbmcgYHRoaXMuX3NldElucHV0RWxlbWVudChpbnB1dClgIFBvbHltZXIgQVBJLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQSB0eXBpY2FsIGNhc2UgaXMgdXNpbmcgYElucHV0Q29udHJvbGxlcmAgdGhhdCBkb2VzIHRoaXMgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgKiBIb3dldmVyLCB0aGUgaW5wdXQgZWxlbWVudCBkb2VzIG5vdCBoYXZlIHRvIGFsd2F5cyBiZSBuYXRpdmUgPGlucHV0PjpcbiAgICAgICAgICAgKiBhcyBhbiBleGFtcGxlLCA8dmFhZGluLWNvbWJvLWJveC1saWdodD4gYWNjZXB0cyBvdGhlciBjb21wb25lbnRzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAqIEB0eXBlIHshSFRNTEVsZW1lbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgaW5wdXRFbGVtZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICAgIG9ic2VydmVyOiAnX2lucHV0RWxlbWVudENoYW5nZWQnLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBTdHJpbmcgdXNlZCB0byBkZWZpbmUgaW5wdXQgdHlwZS5cbiAgICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAgICovXG4gICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgZmllbGQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgIG9ic2VydmVyOiAnX3ZhbHVlQ2hhbmdlZCcsXG4gICAgICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGlucHV0IGVsZW1lbnQgaGFzIGEgbm9uLWVtcHR5IHZhbHVlIGVudGVyZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAqL1xuICAgICAgICAgIF9oYXNJbnB1dFZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6ICdfaGFzSW5wdXRWYWx1ZUNoYW5nZWQnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX19vbklucHV0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsZWFyIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGQuXG4gICAgICAgKi9cbiAgICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgaW5wdXQgZWxlbWVudCBpbnN0YW5jZS5cbiAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBjdXN0b20gbGlzdGVuZXJzLlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGlucHV0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9hZGRJbnB1dExpc3RlbmVycyhpbnB1dCkge1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCBpbnN0YW5jZS5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBpbnB1dFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfcmVtb3ZlSW5wdXRMaXN0ZW5lcnMoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBIG1ldGhvZCB0byBmb3J3YXJkIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzZXQgb24gdGhlIGZpZWxkXG4gICAgICAgKiBwcm9ncmFtbWF0aWNhbGx5IGJhY2sgdG8gdGhlIGlucHV0IGVsZW1lbnQgdmFsdWUuXG4gICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGFkZGl0aW9uYWwgY2hlY2tzLFxuICAgICAgICogZm9yIGV4YW1wbGUgdG8gc2tpcCB0aGlzIGluIGNlcnRhaW4gY29uZGl0aW9ucy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfZm9yd2FyZElucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgLy8gVmFsdWUgbWlnaHQgYmUgc2V0IGJlZm9yZSBhbiBpbnB1dCBlbGVtZW50IGlzIGluaXRpYWxpemVkLlxuICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIGJlIGhhbmRsZWQgc2VwYXJhdGVseSBieSBhIGNvbXBvbmVudCB0aGF0XG4gICAgICAgIC8vIGltcGxlbWVudHMgdGhpcyBtaXhpbiwgZm9yIGV4YW1wbGUgaW4gYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgICAgaWYgKCF0aGlzLmlucHV0RWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IHVuZGVmaW5lZH0gaW5wdXRcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9IG9sZElucHV0XG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF9pbnB1dEVsZW1lbnRDaGFuZ2VkKGlucHV0LCBvbGRJbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICB0aGlzLl9hZGRJbnB1dExpc3RlbmVycyhpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkSW5wdXQpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVJbnB1dExpc3RlbmVycyhvbGRJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPYnNlcnZlciB0byBub3RpZnkgYWJvdXQgdGhlIGNoYW5nZSBvZiBwcml2YXRlIHByb3BlcnR5LlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9oYXNJbnB1dFZhbHVlQ2hhbmdlZChoYXNWYWx1ZSwgb2xkSGFzVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc1ZhbHVlIHx8IG9sZEhhc1ZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaGFzLWlucHV0LXZhbHVlLWNoYW5nZWQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBpbnB1dCBldmVudCBsaXN0ZW5lciB1c2VkIHRvIHVwZGF0ZSBgX2hhc0lucHV0VmFsdWVgIHByb3BlcnR5LlxuICAgICAgICogRG8gbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfX29uSW5wdXQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fc2V0SGFzSW5wdXRWYWx1ZShldmVudCk7XG4gICAgICAgIHRoaXMuX29uSW5wdXQoZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFuIGlucHV0IGV2ZW50IGxpc3RlbmVyIHVzZWQgdG8gdXBkYXRlIHRoZSBmaWVsZCB2YWx1ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfb25JbnB1dChldmVudCkge1xuICAgICAgICAvLyBJbiB0aGUgY2FzZSBhIGN1c3RvbSB3ZWIgY29tcG9uZW50IGlzIHBhc3NlZCBhcyBgaW5wdXRFbGVtZW50YCxcbiAgICAgICAgLy8gdGhlIGFjdHVhbCBuYXRpdmUgaW5wdXQgZWxlbWVudCwgb24gd2hpY2ggdGhlIGV2ZW50IG9jY3VycmVkLFxuICAgICAgICAvLyBjYW4gYmUgaW5zaWRlIHNoYWRvdyB0cmVlcy5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICAgIC8vIElnbm9yZSBmYWtlIGlucHV0IGV2ZW50cyBlLmcuIHVzZWQgYnkgY2xlYXIgYnV0dG9uLlxuICAgICAgICB0aGlzLl9fdXNlcklucHV0ID0gZXZlbnQuaXNUcnVzdGVkO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICB0aGlzLl9fdXNlcklucHV0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBjaGFuZ2UgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB3aXRoIGFuIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IF9ldmVudFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfb25DaGFuZ2UoX2V2ZW50KSB7fVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSB0aGUgaGFzLXZhbHVlIGF0dHJpYnV0ZSBiYXNlZCBvbiB0aGUgdmFsdWUgcHJvcGVydHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBoYXNWYWx1ZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfdG9nZ2xlSGFzVmFsdWUoaGFzVmFsdWUpIHtcbiAgICAgICAgdGhpcy50b2dnbGVBdHRyaWJ1dGUoJ2hhcy12YWx1ZScsIGhhc1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPYnNlcnZlciBjYWxsZWQgd2hlbiBhIHZhbHVlIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbmV3VmFsXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gb2xkVmFsXG4gICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgKi9cbiAgICAgIF92YWx1ZUNoYW5nZWQobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlSGFzVmFsdWUodGhpcy5faGFzVmFsdWUpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgaW5pdGlhbCB2YWx1ZSB0byBlbXB0eSBzdHJpbmcsIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmIChuZXdWYWwgPT09ICcnICYmIG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsdWUgaXMgc2V0IGJ5IHRoZSB1c2VyLCBubyBuZWVkIHRvIHN5bmMgaXQgYmFjayB0byBpbnB1dC5cbiAgICAgICAgaWYgKHRoaXMuX191c2VySW5wdXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR0aW5nIGEgdmFsdWUgcHJvZ3JhbW1hdGljYWxseSwgc3luYyBpdCB0byBpbnB1dCBlbGVtZW50LlxuICAgICAgICB0aGlzLl9mb3J3YXJkSW5wdXRWYWx1ZShuZXdWYWwpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICAgKiBPdmVycmlkZSBpZiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBoYXMgYSB0eXBlIG90aGVyIHRoYW4gYHN0cmluZ2AuXG4gICAgICAgKlxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBnZXQgX2hhc1ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAhPSBudWxsICYmIHRoaXMudmFsdWUgIT09ICcnO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGBfaGFzSW5wdXRWYWx1ZWAgcHJvcGVydHkgYmFzZWQgb24gdGhlIGBpbnB1dGAgZXZlbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtJbnB1dEV2ZW50fSBldmVudFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0SGFzSW5wdXRWYWx1ZShldmVudCkge1xuICAgICAgICAvLyBJbiB0aGUgY2FzZSBhIGN1c3RvbSB3ZWIgY29tcG9uZW50IGlzIHBhc3NlZCBhcyBgaW5wdXRFbGVtZW50YCxcbiAgICAgICAgLy8gdGhlIGFjdHVhbCBuYXRpdmUgaW5wdXQgZWxlbWVudCwgb24gd2hpY2ggdGhlIGV2ZW50IG9jY3VycmVkLFxuICAgICAgICAvLyBjYW4gYmUgaW5zaWRlIHNoYWRvdyB0cmVlcy5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICAgIHRoaXMuX2hhc0lucHV0VmFsdWUgPSB0YXJnZXQudmFsdWUubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9LFxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/field-base/src/input-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/field-base/src/validate-mixin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vaadin/field-base/src/validate-mixin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValidateMixin\": () => (/* binding */ ValidateMixin)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/mixin.js */ \"./node_modules/@vaadin/field-base/node_modules/@polymer/polymer/lib/utils/mixin.js\");\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n/**\n * A mixin to provide required state and validation logic.\n *\n * @polymerMixin\n */\nconst ValidateMixin = (0,_polymer_polymer_lib_utils_mixin_js__WEBPACK_IMPORTED_MODULE_0__.dedupingMixin)(superclass => class ValidateMixinClass extends superclass {\n  static get properties() {\n    return {\n      /**\n       * Set to true when the field is invalid.\n       */\n      invalid: {\n        type: Boolean,\n        reflectToAttribute: true,\n        notify: true,\n        value: false\n      },\n      /**\n       * Specifies that the user must fill in a value.\n       */\n      required: {\n        type: Boolean,\n        reflectToAttribute: true\n      }\n    };\n  }\n\n  /**\n   * Validates the field and sets the `invalid` property based on the result.\n   *\n   * The method fires a `validated` event with the result of the validation.\n   *\n   * @return {boolean} True if the value is valid.\n   */\n  validate() {\n    const isValid = this.checkValidity();\n    this._setInvalid(!isValid);\n    this.dispatchEvent(new CustomEvent('validated', {\n      detail: {\n        valid: isValid\n      }\n    }));\n    return isValid;\n  }\n\n  /**\n   * Returns true if the field value satisfies all constraints (if any).\n   *\n   * @return {boolean}\n   */\n  checkValidity() {\n    return !this.required || !!this.value;\n  }\n\n  /**\n   * @param {boolean} invalid\n   * @protected\n   */\n  _setInvalid(invalid) {\n    if (this._shouldSetInvalid(invalid)) {\n      this.invalid = invalid;\n    }\n  }\n\n  /**\n   * Override this method to define whether the given `invalid` state should be set.\n   *\n   * @param {boolean} _invalid\n   * @return {boolean}\n   * @protected\n   */\n  _shouldSetInvalid(_invalid) {\n    return true;\n  }\n\n  /**\n   * Fired whenever the field is validated.\n   *\n   * @event validated\n   * @param {Object} detail\n   * @param {boolean} detail.valid the result of the validation.\n   */\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL3NyYy92YWxpZGF0ZS1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL3NyYy92YWxpZGF0ZS1taXhpbi5qcz9lMzUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAyMSAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzJztcblxuLyoqXG4gKiBBIG1peGluIHRvIHByb3ZpZGUgcmVxdWlyZWQgc3RhdGUgYW5kIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogQHBvbHltZXJNaXhpblxuICovXG5leHBvcnQgY29uc3QgVmFsaWRhdGVNaXhpbiA9IGRlZHVwaW5nTWl4aW4oXG4gIChzdXBlcmNsYXNzKSA9PlxuICAgIGNsYXNzIFZhbGlkYXRlTWl4aW5DbGFzcyBleHRlbmRzIHN1cGVyY2xhc3Mge1xuICAgICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFNldCB0byB0cnVlIHdoZW4gdGhlIGZpZWxkIGlzIGludmFsaWQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaW52YWxpZDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgdGhlIHVzZXIgbXVzdCBmaWxsIGluIGEgdmFsdWUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcmVxdWlyZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBWYWxpZGF0ZXMgdGhlIGZpZWxkIGFuZCBzZXRzIHRoZSBgaW52YWxpZGAgcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlc3VsdC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgbWV0aG9kIGZpcmVzIGEgYHZhbGlkYXRlZGAgZXZlbnQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHZhbGlkLlxuICAgICAgICovXG4gICAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICB0aGlzLl9zZXRJbnZhbGlkKCFpc1ZhbGlkKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndmFsaWRhdGVkJywgeyBkZXRhaWw6IHsgdmFsaWQ6IGlzVmFsaWQgfSB9KSk7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmllbGQgdmFsdWUgc2F0aXNmaWVzIGFsbCBjb25zdHJhaW50cyAoaWYgYW55KS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBjaGVja1ZhbGlkaXR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucmVxdWlyZWQgfHwgISF0aGlzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW52YWxpZFxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2V0SW52YWxpZChpbnZhbGlkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRTZXRJbnZhbGlkKGludmFsaWQpKSB7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRlZmluZSB3aGV0aGVyIHRoZSBnaXZlbiBgaW52YWxpZGAgc3RhdGUgc2hvdWxkIGJlIHNldC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IF9pbnZhbGlkXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICovXG4gICAgICBfc2hvdWxkU2V0SW52YWxpZChfaW52YWxpZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgZmllbGQgaXMgdmFsaWRhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCB2YWxpZGF0ZWRcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXRhaWxcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGV0YWlsLnZhbGlkIHRoZSByZXN1bHQgb2YgdGhlIHZhbGlkYXRpb24uXG4gICAgICAgKi9cbiAgICB9LFxuKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/field-base/src/validate-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/field-base/src/virtual-keyboard-controller.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vaadin/field-base/src/virtual-keyboard-controller.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VirtualKeyboardController\": () => (/* binding */ VirtualKeyboardController)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2021 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * A controller which prevents the virtual keyboard from showing up on mobile devices\n * when the field's overlay is closed.\n */\nclass VirtualKeyboardController {\n  /**\n   * @param {{ inputElement?: HTMLElement; opened: boolean } & HTMLElement} host\n   */\n  constructor(host) {\n    this.host = host;\n    host.addEventListener('opened-changed', () => {\n      if (!host.opened) {\n        // Prevent opening the virtual keyboard when the input gets re-focused on dropdown close\n        this.__setVirtualKeyboardEnabled(false);\n      }\n    });\n\n    // Re-enable virtual keyboard on blur, so it gets opened when the field is focused again\n    host.addEventListener('blur', () => this.__setVirtualKeyboardEnabled(true));\n\n    // Re-enable the virtual keyboard whenever the field is touched\n    host.addEventListener('touchstart', () => this.__setVirtualKeyboardEnabled(true));\n  }\n\n  /** @private */\n  __setVirtualKeyboardEnabled(value) {\n    if (this.host.inputElement) {\n      this.host.inputElement.inputMode = value ? '' : 'none';\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9maWVsZC1iYXNlL3NyYy92aXJ0dWFsLWtleWJvYXJkLWNvbnRyb2xsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vZmllbGQtYmFzZS9zcmMvdmlydHVhbC1rZXlib2FyZC1jb250cm9sbGVyLmpzP2ZiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDIxIC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5cbi8qKlxuICogQSBjb250cm9sbGVyIHdoaWNoIHByZXZlbnRzIHRoZSB2aXJ0dWFsIGtleWJvYXJkIGZyb20gc2hvd2luZyB1cCBvbiBtb2JpbGUgZGV2aWNlc1xuICogd2hlbiB0aGUgZmllbGQncyBvdmVybGF5IGlzIGNsb3NlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFZpcnR1YWxLZXlib2FyZENvbnRyb2xsZXIge1xuICAvKipcbiAgICogQHBhcmFtIHt7IGlucHV0RWxlbWVudD86IEhUTUxFbGVtZW50OyBvcGVuZWQ6IGJvb2xlYW4gfSAmIEhUTUxFbGVtZW50fSBob3N0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihob3N0KSB7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcblxuICAgIGhvc3QuYWRkRXZlbnRMaXN0ZW5lcignb3BlbmVkLWNoYW5nZWQnLCAoKSA9PiB7XG4gICAgICBpZiAoIWhvc3Qub3BlbmVkKSB7XG4gICAgICAgIC8vIFByZXZlbnQgb3BlbmluZyB0aGUgdmlydHVhbCBrZXlib2FyZCB3aGVuIHRoZSBpbnB1dCBnZXRzIHJlLWZvY3VzZWQgb24gZHJvcGRvd24gY2xvc2VcbiAgICAgICAgdGhpcy5fX3NldFZpcnR1YWxLZXlib2FyZEVuYWJsZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmUtZW5hYmxlIHZpcnR1YWwga2V5Ym9hcmQgb24gYmx1ciwgc28gaXQgZ2V0cyBvcGVuZWQgd2hlbiB0aGUgZmllbGQgaXMgZm9jdXNlZCBhZ2FpblxuICAgIGhvc3QuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHRoaXMuX19zZXRWaXJ0dWFsS2V5Ym9hcmRFbmFibGVkKHRydWUpKTtcblxuICAgIC8vIFJlLWVuYWJsZSB0aGUgdmlydHVhbCBrZXlib2FyZCB3aGVuZXZlciB0aGUgZmllbGQgaXMgdG91Y2hlZFxuICAgIGhvc3QuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsICgpID0+IHRoaXMuX19zZXRWaXJ0dWFsS2V5Ym9hcmRFbmFibGVkKHRydWUpKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfX3NldFZpcnR1YWxLZXlib2FyZEVuYWJsZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5ob3N0LmlucHV0RWxlbWVudCkge1xuICAgICAgdGhpcy5ob3N0LmlucHV0RWxlbWVudC5pbnB1dE1vZGUgPSB2YWx1ZSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/field-base/src/virtual-keyboard-controller.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemableMixin\": () => (/* binding */ ThemableMixin),\n/* harmony export */   \"__themeRegistry\": () => (/* binding */ themeRegistry),\n/* harmony export */   \"css\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* binding */ registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/@vaadin/item/node_modules/lit/index.js\");\n/* harmony import */ var _vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-theme-property-mixin.js */ \"./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nfunction registerStyles(themeFor, styles, options = {}) {\n  if (themeFor) {\n    if (hasThemes(themeFor)) {\n      console.warn(`The custom element definition for \"${themeFor}\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element.`);\n    }\n  }\n  styles = flattenStyles(styles);\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId\n    });\n  }\n}\n\n/**\n * Returns all registered themes. By default the themeRegistry is returned as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  }\n  return themeRegistry;\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some(themeForToken => {\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`).test(tagName);\n  });\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\n    includePriority = 1;\n  } else if (moduleName.startsWith('vaadin-')) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\nfunction flattenStyles(styles = []) {\n  return [styles].flat(Infinity).filter(style => {\n    if (style instanceof lit__WEBPACK_IMPORTED_MODULE_0__.CSSResult) {\n      return true;\n    }\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n    return false;\n  });\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach(includeModuleId => {\n      const includedTheme = getAllThemes().find(s => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = styles.map(style => style.cssText).join('\\n');\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = `${tagName}-default-theme`;\n  const themes = getAllThemes()\n  // Filter by matching themeFor properties\n  .filter(theme => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map(theme => ({\n    ...theme,\n    // Prepend styles from included themes\n    styles: [...getIncludedStyles(theme), ...theme.styles],\n    // Map moduleId to includePriority\n    includePriority: getIncludePriority(theme.moduleId)\n  }))\n  // Sort by includePriority\n  .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n  if (themes.length > 0) {\n    return themes;\n  }\n  // No theme modules found, return the default module if it exists\n  return getAllThemes().filter(theme => theme.moduleId === defaultModuleName);\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction hasThemes(tagName) {\n  return classHasThemes(customElements.get(tagName));\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {Function} elementClass\n * @returns {boolean}\n */\nfunction classHasThemes(elementClass) {\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nconst ThemableMixin = superClass => class VaadinThemableMixin extends (0,_vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ThemePropertyMixin)(superClass) {\n  /**\n   * Covers PolymerElement based component styling\n   * @protected\n   */\n  static finalize() {\n    super.finalize();\n\n    // Make sure not to run the logic intended for PolymerElement when LitElement is used.\n    if (this.elementStyles) {\n      return;\n    }\n    const template = this.prototype._template;\n    if (!template || classHasThemes(this)) {\n      return;\n    }\n    addStylesToTemplate(this.getStylesForThis(), template);\n  }\n\n  /**\n   * Covers LitElement based component styling\n   *\n   * @protected\n   */\n  static finalizeStyles(styles) {\n    // The \"styles\" object originates from the \"static get styles()\" function of\n    // a LitElement based component. The theme styles are added after it\n    // so that they can override the component styles.\n    const themeStyles = this.getStylesForThis();\n    return styles ? [...super.finalizeStyles(styles), ...themeStyles] : themeStyles;\n  }\n\n  /**\n   * Get styles for the component type\n   *\n   * @private\n   */\n  static getStylesForThis() {\n    const parent = Object.getPrototypeOf(this.prototype);\n    const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\n    this.__themes = [...inheritedThemes, ...getThemes(this.is)];\n    const themeStyles = this.__themes.flatMap(theme => theme.styles);\n    // Remove duplicates\n    return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9pdGVtL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL2l0ZW0vbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcz80ZTFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgY3NzLCBDU1NSZXN1bHQsIHVuc2FmZUNTUyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBUaGVtZVByb3BlcnR5TWl4aW4gfSBmcm9tICcuL3ZhYWRpbi10aGVtZS1wcm9wZXJ0eS1taXhpbi5qcyc7XG5cbmV4cG9ydCB7IGNzcywgdW5zYWZlQ1NTIH07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGhlbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aGVtZUZvclxuICogQHByb3BlcnR5IHtDU1NSZXN1bHRbXX0gc3R5bGVzXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHN0cmluZ1tdfSBbaW5jbHVkZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbW9kdWxlSWRdXG4gKlxuICogQHR5cGVkZWYge0NTU1Jlc3VsdFtdIHwgQ1NTUmVzdWx0fSBDU1NSZXN1bHRHcm91cFxuICovXG5cbi8qKlxuICogQHR5cGUge1RoZW1lW119XG4gKi9cbmNvbnN0IHRoZW1lUmVnaXN0cnkgPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgQ1NTIHN0eWxlcyBmb3IgYSBjb21wb25lbnQgdHlwZS4gTWFrZSBzdXJlIHRvIHJlZ2lzdGVyIHRoZSBzdHlsZXMgYmVmb3JlXG4gKiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgb2YgdGhlIHR5cGUgaXMgYXR0YWNoZWQgdG8gRE9NLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZUZvciBUaGUgbG9jYWwvdGFnIG5hbWUgb2YgdGhlIGNvbXBvbmVudCB0eXBlIHRvIHJlZ2lzdGVyIHRoZSBzdHlsZXMgZm9yXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdEdyb3VwfSBzdHlsZXMgVGhlIENTUyBzdHlsZSBydWxlcyB0byBiZSByZWdpc3RlcmVkIGZvciB0aGUgY29tcG9uZW50IHR5cGVcbiAqIG1hdGNoaW5nIHRoZW1lRm9yIGFuZCBpbmNsdWRlZCBpbiB0aGUgbG9jYWwgc2NvcGUgb2YgZWFjaCBjb21wb25lbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7e21vZHVsZUlkPzogc3RyaW5nLCBpbmNsdWRlPzogc3RyaW5nIHwgc3RyaW5nW119fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKHRoZW1lRm9yLCBzdHlsZXMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodGhlbWVGb3IpIHtcbiAgICBpZiAoaGFzVGhlbWVzKHRoZW1lRm9yKSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgY3VzdG9tIGVsZW1lbnQgZGVmaW5pdGlvbiBmb3IgXCIke3RoZW1lRm9yfVwiXG4gICAgICB3YXMgZmluYWxpemVkIGJlZm9yZSBhIHN0eWxlIG1vZHVsZSB3YXMgcmVnaXN0ZXJlZC5cbiAgICAgIE1ha2Ugc3VyZSB0byBhZGQgY29tcG9uZW50IHNwZWNpZmljIHN0eWxlIG1vZHVsZXMgYmVmb3JlXG4gICAgICBpbXBvcnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgfVxuICB9XG5cbiAgc3R5bGVzID0gZmxhdHRlblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmICh3aW5kb3cuVmFhZGluICYmIHdpbmRvdy5WYWFkaW4uc3R5bGVNb2R1bGVzKSB7XG4gICAgd2luZG93LlZhYWRpbi5zdHlsZU1vZHVsZXMucmVnaXN0ZXJTdHlsZXModGhlbWVGb3IsIHN0eWxlcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhlbWVSZWdpc3RyeS5wdXNoKHtcbiAgICAgIHRoZW1lRm9yLFxuICAgICAgc3R5bGVzLFxuICAgICAgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlLFxuICAgICAgbW9kdWxlSWQ6IG9wdGlvbnMubW9kdWxlSWQsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHRoZW1lcy4gQnkgZGVmYXVsdCB0aGUgdGhlbWVSZWdpc3RyeSBpcyByZXR1cm5lZCBhcyBpcy5cbiAqIEluIGNhc2UgdGhlIHN0eWxlLW1vZHVsZXMgYWRhcHRlciBpcyBpbXBvcnRlZCwgdGhlIHRoZW1lcyBhcmUgb2J0YWluZWQgZnJvbSB0aGVyZSBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7VGhlbWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsVGhlbWVzKCkge1xuICBpZiAod2luZG93LlZhYWRpbiAmJiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcykge1xuICAgIHJldHVybiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcy5nZXRBbGxUaGVtZXMoKTtcbiAgfVxuICByZXR1cm4gdGhlbWVSZWdpc3RyeTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRoZW1lRm9yIHN0cmluZyBtYXRjaGVzIHRoZSB0YWcgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lRm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNUaGVtZUZvcih0aGVtZUZvciwgdGFnTmFtZSkge1xuICByZXR1cm4gKHRoZW1lRm9yIHx8ICcnKS5zcGxpdCgnICcpLnNvbWUoKHRoZW1lRm9yVG9rZW4pID0+IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGhlbWVGb3JUb2tlbi5zcGxpdCgnKicpLmpvaW4oJy4qJyl9JGApLnRlc3QodGFnTmFtZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hcHMgdGhlIG1vZHVsZU5hbWUgdG8gYW4gaW5jbHVkZSBwcmlvcml0eSBudW1iZXIgd2hpY2ggaXMgdXNlZCBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBvcmRlciBpbiB3aGljaCBzdHlsZXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0SW5jbHVkZVByaW9yaXR5KG1vZHVsZU5hbWUgPSAnJykge1xuICBsZXQgaW5jbHVkZVByaW9yaXR5ID0gMDtcbiAgaWYgKG1vZHVsZU5hbWUuc3RhcnRzV2l0aCgnbHVtby0nKSB8fCBtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ21hdGVyaWFsLScpKSB7XG4gICAgaW5jbHVkZVByaW9yaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ3ZhYWRpbi0nKSkge1xuICAgIGluY2x1ZGVQcmlvcml0eSA9IDI7XG4gIH1cbiAgcmV0dXJuIGluY2x1ZGVQcmlvcml0eTtcbn1cblxuLyoqXG4gKiBGbGF0dGVucyB0aGUgc3R5bGVzIGludG8gYSBzaW5nbGUgYXJyYXkgb2Ygc3R5bGVzLlxuICogQHBhcmFtIHtDU1NSZXN1bHRHcm91cH0gc3R5bGVzXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdFtdfSByZXN1bHRcbiAqIEByZXR1cm5zIHtDU1NSZXN1bHRbXX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhzdHlsZXMgPSBbXSkge1xuICByZXR1cm4gW3N0eWxlc10uZmxhdChJbmZpbml0eSkuZmlsdGVyKChzdHlsZSkgPT4ge1xuICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIENTU1Jlc3VsdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybignQW4gaXRlbSBpbiBzdHlsZXMgaXMgbm90IG9mIHR5cGUgQ1NTUmVzdWx0LiBVc2UgYHVuc2FmZUNTU2Agb3IgYGNzc2AuJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGFycmF5IG9mIENTU1Jlc3VsdHMgbWF0Y2hpbmcgdGhlIGluY2x1ZGUgcHJvcGVydHkgb2YgdGhlIHRoZW1lLlxuICogQHBhcmFtIHtUaGVtZX0gdGhlbWVcbiAqIEByZXR1cm5zIHtDU1NSZXN1bHRbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0SW5jbHVkZWRTdHlsZXModGhlbWUpIHtcbiAgY29uc3QgaW5jbHVkZWRTdHlsZXMgPSBbXTtcbiAgaWYgKHRoZW1lLmluY2x1ZGUpIHtcbiAgICBbXS5jb25jYXQodGhlbWUuaW5jbHVkZSkuZm9yRWFjaCgoaW5jbHVkZU1vZHVsZUlkKSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlZFRoZW1lID0gZ2V0QWxsVGhlbWVzKCkuZmluZCgocykgPT4gcy5tb2R1bGVJZCA9PT0gaW5jbHVkZU1vZHVsZUlkKTtcbiAgICAgIGlmIChpbmNsdWRlZFRoZW1lKSB7XG4gICAgICAgIGluY2x1ZGVkU3R5bGVzLnB1c2goLi4uZ2V0SW5jbHVkZWRTdHlsZXMoaW5jbHVkZWRUaGVtZSksIC4uLmluY2x1ZGVkVGhlbWUuc3R5bGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW5jbHVkZWQgbW9kdWxlSWQgJHtpbmNsdWRlTW9kdWxlSWR9IG5vdCBmb3VuZCBpbiBzdHlsZSByZWdpc3RyeWApO1xuICAgICAgfVxuICAgIH0sIHRoZW1lLnN0eWxlcyk7XG4gIH1cbiAgcmV0dXJuIGluY2x1ZGVkU3R5bGVzO1xufVxuXG4vKipcbiAqIEluY2x1ZGVzIHRoZSBzdHlsZXMgdG8gdGhlIHRlbXBsYXRlLlxuICogQHBhcmFtIHtDU1NSZXN1bHRbXX0gc3R5bGVzXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvVGVtcGxhdGUoc3R5bGVzLCB0ZW1wbGF0ZSkge1xuICBjb25zdCBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGVFbC5pbm5lckhUTUwgPSBzdHlsZXMubWFwKChzdHlsZSkgPT4gc3R5bGUuY3NzVGV4dCkuam9pbignXFxuJyk7XG4gIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGVtZXMgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3Igc3R5bGluZyBhIGNvbXBvbmVudCBtYXRjaGluZ1xuICogdGhlIHRhZyBuYW1lLiBUaGUgYXJyYXkgaXMgc29ydGVkIGJ5IHRoZSBpbmNsdWRlIG9yZGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAqIEByZXR1cm5zIHtUaGVtZVtdfVxuICovXG5mdW5jdGlvbiBnZXRUaGVtZXModGFnTmFtZSkge1xuICBjb25zdCBkZWZhdWx0TW9kdWxlTmFtZSA9IGAke3RhZ05hbWV9LWRlZmF1bHQtdGhlbWVgO1xuXG4gIGNvbnN0IHRoZW1lcyA9IGdldEFsbFRoZW1lcygpXG4gICAgLy8gRmlsdGVyIGJ5IG1hdGNoaW5nIHRoZW1lRm9yIHByb3BlcnRpZXNcbiAgICAuZmlsdGVyKCh0aGVtZSkgPT4gdGhlbWUubW9kdWxlSWQgIT09IGRlZmF1bHRNb2R1bGVOYW1lICYmIG1hdGNoZXNUaGVtZUZvcih0aGVtZS50aGVtZUZvciwgdGFnTmFtZSkpXG4gICAgLm1hcCgodGhlbWUpID0+ICh7XG4gICAgICAuLi50aGVtZSxcbiAgICAgIC8vIFByZXBlbmQgc3R5bGVzIGZyb20gaW5jbHVkZWQgdGhlbWVzXG4gICAgICBzdHlsZXM6IFsuLi5nZXRJbmNsdWRlZFN0eWxlcyh0aGVtZSksIC4uLnRoZW1lLnN0eWxlc10sXG4gICAgICAvLyBNYXAgbW9kdWxlSWQgdG8gaW5jbHVkZVByaW9yaXR5XG4gICAgICBpbmNsdWRlUHJpb3JpdHk6IGdldEluY2x1ZGVQcmlvcml0eSh0aGVtZS5tb2R1bGVJZCksXG4gICAgfSkpXG4gICAgLy8gU29ydCBieSBpbmNsdWRlUHJpb3JpdHlcbiAgICAuc29ydCgodGhlbWVBLCB0aGVtZUIpID0+IHRoZW1lQi5pbmNsdWRlUHJpb3JpdHkgLSB0aGVtZUEuaW5jbHVkZVByaW9yaXR5KTtcblxuICBpZiAodGhlbWVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdGhlbWVzO1xuICB9XG4gIC8vIE5vIHRoZW1lIG1vZHVsZXMgZm91bmQsIHJldHVybiB0aGUgZGVmYXVsdCBtb2R1bGUgaWYgaXQgZXhpc3RzXG4gIHJldHVybiBnZXRBbGxUaGVtZXMoKS5maWx0ZXIoKHRoZW1lKSA9PiB0aGVtZS5tb2R1bGVJZCA9PT0gZGVmYXVsdE1vZHVsZU5hbWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXN0b20gZWxlbWVudCB0eXBlIGhhcyB0aGVtZXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzVGhlbWVzKHRhZ05hbWUpIHtcbiAgcmV0dXJuIGNsYXNzSGFzVGhlbWVzKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1c3RvbSBlbGVtZW50IHR5cGUgaGFzIHRoZW1lcyBhcHBsaWVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWxlbWVudENsYXNzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2xhc3NIYXNUaGVtZXMoZWxlbWVudENsYXNzKSB7XG4gIHJldHVybiBlbGVtZW50Q2xhc3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnRDbGFzcywgJ19fdGhlbWVzJyk7XG59XG5cbi8qKlxuICogQHBvbHltZXJNaXhpblxuICogQG1peGVzIFRoZW1lUHJvcGVydHlNaXhpblxuICovXG5leHBvcnQgY29uc3QgVGhlbWFibGVNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5UaGVtYWJsZU1peGluIGV4dGVuZHMgVGhlbWVQcm9wZXJ0eU1peGluKHN1cGVyQ2xhc3MpIHtcbiAgICAvKipcbiAgICAgKiBDb3ZlcnMgUG9seW1lckVsZW1lbnQgYmFzZWQgY29tcG9uZW50IHN0eWxpbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgc3VwZXIuZmluYWxpemUoKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIG5vdCB0byBydW4gdGhlIGxvZ2ljIGludGVuZGVkIGZvciBQb2x5bWVyRWxlbWVudCB3aGVuIExpdEVsZW1lbnQgaXMgdXNlZC5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnRTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZTtcbiAgICAgIGlmICghdGVtcGxhdGUgfHwgY2xhc3NIYXNUaGVtZXModGhpcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhZGRTdHlsZXNUb1RlbXBsYXRlKHRoaXMuZ2V0U3R5bGVzRm9yVGhpcygpLCB0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ292ZXJzIExpdEVsZW1lbnQgYmFzZWQgY29tcG9uZW50IHN0eWxpbmdcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemVTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAvLyBUaGUgXCJzdHlsZXNcIiBvYmplY3Qgb3JpZ2luYXRlcyBmcm9tIHRoZSBcInN0YXRpYyBnZXQgc3R5bGVzKClcIiBmdW5jdGlvbiBvZlxuICAgICAgLy8gYSBMaXRFbGVtZW50IGJhc2VkIGNvbXBvbmVudC4gVGhlIHRoZW1lIHN0eWxlcyBhcmUgYWRkZWQgYWZ0ZXIgaXRcbiAgICAgIC8vIHNvIHRoYXQgdGhleSBjYW4gb3ZlcnJpZGUgdGhlIGNvbXBvbmVudCBzdHlsZXMuXG4gICAgICBjb25zdCB0aGVtZVN0eWxlcyA9IHRoaXMuZ2V0U3R5bGVzRm9yVGhpcygpO1xuICAgICAgcmV0dXJuIHN0eWxlcyA/IFsuLi5zdXBlci5maW5hbGl6ZVN0eWxlcyhzdHlsZXMpLCAuLi50aGVtZVN0eWxlc10gOiB0aGVtZVN0eWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3R5bGVzIGZvciB0aGUgY29tcG9uZW50IHR5cGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0eWxlc0ZvclRoaXMoKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5wcm90b3R5cGUpO1xuICAgICAgY29uc3QgaW5oZXJpdGVkVGhlbWVzID0gKHBhcmVudCA/IHBhcmVudC5jb25zdHJ1Y3Rvci5fX3RoZW1lcyA6IFtdKSB8fCBbXTtcbiAgICAgIHRoaXMuX190aGVtZXMgPSBbLi4uaW5oZXJpdGVkVGhlbWVzLCAuLi5nZXRUaGVtZXModGhpcy5pcyldO1xuICAgICAgY29uc3QgdGhlbWVTdHlsZXMgPSB0aGlzLl9fdGhlbWVzLmZsYXRNYXAoKHRoZW1lKSA9PiB0aGVtZS5zdHlsZXMpO1xuICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgIHJldHVybiB0aGVtZVN0eWxlcy5maWx0ZXIoKHN0eWxlLCBpbmRleCkgPT4gaW5kZXggPT09IHRoZW1lU3R5bGVzLmxhc3RJbmRleE9mKHN0eWxlKSk7XG4gICAgfVxuICB9O1xuXG5leHBvcnQgeyB0aGVtZVJlZ2lzdHJ5IGFzIF9fdGhlbWVSZWdpc3RyeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemePropertyMixin\": () => (/* binding */ ThemePropertyMixin)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nconst ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @deprecated The `theme` property is not supposed for public use and will be dropped in Vaadin 24.\n       * Please, use the `theme` attribute instead.\n       * @protected\n       */\n      theme: {\n        type: String,\n        reflectToAttribute: true,\n        observer: '__deprecatedThemePropertyChanged'\n      },\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @protected\n       */\n      _theme: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n\n  /** @private */\n  __deprecatedThemePropertyChanged(theme) {\n    this._set_theme(theme);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9pdGVtL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWUtcHJvcGVydHktbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vaXRlbS9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzPzQzOTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IFRoZW1lUHJvcGVydHlNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5UaGVtZVByb3BlcnR5TWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHByb3BlcnR5IHdpdGggdGhlbWUgYXR0cmlidXRlIHZhbHVlIGZhY2lsaXRhdGluZyBwcm9wYWdhdGlvblxuICAgICAgICAgKiBpbiBzaGFkb3cgRE9NLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgXG4gICAgICAgICAqIGF0dHJpYnV0ZSB2YWx1ZSB0byB0aGUgc3ViLWNvbXBvbmVudHMgaW4gU2hhZG93IERPTSBieSBiaW5kaW5nXG4gICAgICAgICAqIHRoZSBzdWItY29tcG9uZW504oCZcyBcInRoZW1lXCIgYXR0cmlidXRlIHRvIHRoZSBgdGhlbWVgIHByb3BlcnR5IG9mXG4gICAgICAgICAqIHRoZSBob3N0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEU6KiogRXh0ZW5kaW5nIHRoZSBtaXhpbiBvbmx5IHByb3ZpZGVzIHRoZSBwcm9wZXJ0eSBmb3IgYmluZGluZyxcbiAgICAgICAgICogYW5kIGRvZXMgbm90IG1ha2UgdGhlIHByb3BhZ2F0aW9uIGFsb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50czogU3ViLWNvbXBvbmVudHNdKGh0dHBzOi8vdmFhZGluLmNvbS9kb2NzL2xhdGVzdC9zdHlsaW5nL2N1c3RvbS10aGVtZS9zdHlsaW5nLWNvbXBvbmVudHMvI3N1Yi1jb21wb25lbnRzKS5cbiAgICAgICAgICogcGFnZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVGhlIGB0aGVtZWAgcHJvcGVydHkgaXMgbm90IHN1cHBvc2VkIGZvciBwdWJsaWMgdXNlIGFuZCB3aWxsIGJlIGRyb3BwZWQgaW4gVmFhZGluIDI0LlxuICAgICAgICAgKiBQbGVhc2UsIHVzZSB0aGUgYHRoZW1lYCBhdHRyaWJ1dGUgaW5zdGVhZC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19kZXByZWNhdGVkVGhlbWVQcm9wZXJ0eUNoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgcHJvcGVydHkgd2l0aCB0aGVtZSBhdHRyaWJ1dGUgdmFsdWUgZmFjaWxpdGF0aW5nIHByb3BhZ2F0aW9uXG4gICAgICAgICAqIGluIHNoYWRvdyBET00uXG4gICAgICAgICAqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbiB0byBwcm9wYWdhdGUgdGhlIGB0aGVtZWBcbiAgICAgICAgICogYXR0cmlidXRlIHZhbHVlIHRvIHRoZSBzdWItY29tcG9uZW50cyBpbiBTaGFkb3cgRE9NIGJ5IGJpbmRpbmdcbiAgICAgICAgICogdGhlIHN1Yi1jb21wb25lbnTigJlzIFwidGhlbWVcIiBhdHRyaWJ1dGUgdG8gdGhlIGB0aGVtZWAgcHJvcGVydHkgb2ZcbiAgICAgICAgICogdGhlIGhvc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URToqKiBFeHRlbmRpbmcgdGhlIG1peGluIG9ubHkgcHJvdmlkZXMgdGhlIHByb3BlcnR5IGZvciBiaW5kaW5nLFxuICAgICAgICAgKiBhbmQgZG9lcyBub3QgbWFrZSB0aGUgcHJvcGFnYXRpb24gYWxvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBbU3R5bGluZyBDb21wb25lbnRzOiBTdWItY29tcG9uZW50c10oaHR0cHM6Ly92YWFkaW4uY29tL2RvY3MvbGF0ZXN0L3N0eWxpbmcvY3VzdG9tLXRoZW1lL3N0eWxpbmctY29tcG9uZW50cy8jc3ViLWNvbXBvbmVudHMpLlxuICAgICAgICAgKiBwYWdlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdGhlbWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9fZGVwcmVjYXRlZFRoZW1lUHJvcGVydHlDaGFuZ2VkKHRoZW1lKSB7XG4gICAgICB0aGlzLl9zZXRfdGhlbWUodGhlbWUpO1xuICAgIH1cbiAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/item/node_modules/lit/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vaadin/item/node_modules/lit/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSResult": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.CSSResult),
/* harmony export */   "LitElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),
/* harmony export */   "ReactiveElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.ReactiveElement),
/* harmony export */   "UpdatingElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),
/* harmony export */   "_$LE": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LE),
/* harmony export */   "_$LH": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LH),
/* harmony export */   "adoptStyles": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.adoptStyles),
/* harmony export */   "css": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.css),
/* harmony export */   "defaultConverter": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.defaultConverter),
/* harmony export */   "getCompatibleStyle": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.getCompatibleStyle),
/* harmony export */   "html": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.html),
/* harmony export */   "isServer": () => (/* reexport safe */ lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__.isServer),
/* harmony export */   "noChange": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.noChange),
/* harmony export */   "notEqual": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.notEqual),
/* harmony export */   "nothing": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.nothing),
/* harmony export */   "render": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.render),
/* harmony export */   "supportsAdoptingStyleSheets": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.supportsAdoptingStyleSheets),
/* harmony export */   "svg": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.svg),
/* harmony export */   "unsafeCSS": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ "./node_modules/@lit/reactive-element/development/reactive-element.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit-element/lit-element.js */ "./node_modules/lit-element/development/lit-element.js");
/* harmony import */ var lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit-html/is-server.js */ "./node_modules/lit-html/development/is-server.js");





/***/ }),

/***/ "./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js":
/*!************************************************************************!*\
  !*** ./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"item\": () => (/* binding */ item)\n/* harmony export */ });\n/* harmony import */ var _vaadin_vaadin_material_styles_font_icons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/font-icons.js */ \"./node_modules/@vaadin/vaadin-material-styles/font-icons.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_vaadin_material_styles_typography_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/typography.js */ \"./node_modules/@vaadin/vaadin-material-styles/typography.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/item/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n\n\nconst item = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.css`\n  :host {\n    display: flex;\n    align-items: center;\n    box-sizing: border-box;\n    min-height: 36px;\n    padding: 8px 32px 8px 10px;\n    overflow: hidden;\n    font-family: var(--material-font-family);\n    font-size: var(--material-small-font-size);\n    line-height: 24px;\n  }\n\n  /* It's the list-box's responsibility to add the focus style */\n  :host([focused]) {\n    outline: none;\n  }\n\n  /* Checkmark */\n  [part='checkmark']::before {\n    display: var(--_material-item-selected-icon-display, none);\n    content: '';\n    font-family: material-icons;\n    font-size: 24px;\n    line-height: 1;\n    font-weight: 400;\n    width: 24px;\n    text-align: center;\n    margin-right: 10px;\n    color: var(--material-secondary-text-color);\n    flex: none;\n  }\n\n  :host([selected]) [part='checkmark']::before {\n    content: var(--material-icons-check);\n  }\n\n  @media (any-hover: hover) {\n    :host(:hover:not([disabled])) {\n      background-color: var(--material-secondary-background-color);\n    }\n\n    :host([focused]:not([disabled])) {\n      background-color: var(--material-divider-color);\n    }\n  }\n\n  /* Disabled */\n  :host([disabled]) {\n    color: var(--material-disabled-text-color);\n    cursor: default;\n    pointer-events: none;\n  }\n\n  /* RTL specific styles */\n  :host([dir='rtl']) {\n    padding: 8px 10px 8px 32px;\n  }\n\n  :host([dir='rtl']) [part='checkmark']::before {\n    margin-right: 0;\n    margin-left: 10px;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.registerStyles)('vaadin-item', item, {\n  moduleId: 'material-item'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9pdGVtL3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1pdGVtLXN0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vaXRlbS90aGVtZS9tYXRlcmlhbC92YWFkaW4taXRlbS1zdHlsZXMuanM/N2NlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ0B2YWFkaW4vdmFhZGluLW1hdGVyaWFsLXN0eWxlcy9mb250LWljb25zLmpzJztcbmltcG9ydCAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2NvbG9yLmpzJztcbmltcG9ydCAnQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0IHsgY3NzLCByZWdpc3RlclN0eWxlcyB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5cbmNvbnN0IGl0ZW0gPSBjc3NgXG4gIDpob3N0IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBtaW4taGVpZ2h0OiAzNnB4O1xuICAgIHBhZGRpbmc6IDhweCAzMnB4IDhweCAxMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLW1hdGVyaWFsLWZvbnQtZmFtaWx5KTtcbiAgICBmb250LXNpemU6IHZhcigtLW1hdGVyaWFsLXNtYWxsLWZvbnQtc2l6ZSk7XG4gICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gIH1cblxuICAvKiBJdCdzIHRoZSBsaXN0LWJveCdzIHJlc3BvbnNpYmlsaXR5IHRvIGFkZCB0aGUgZm9jdXMgc3R5bGUgKi9cbiAgOmhvc3QoW2ZvY3VzZWRdKSB7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgfVxuXG4gIC8qIENoZWNrbWFyayAqL1xuICBbcGFydD0nY2hlY2ttYXJrJ106OmJlZm9yZSB7XG4gICAgZGlzcGxheTogdmFyKC0tX21hdGVyaWFsLWl0ZW0tc2VsZWN0ZWQtaWNvbi1kaXNwbGF5LCBub25lKTtcbiAgICBjb250ZW50OiAnJztcbiAgICBmb250LWZhbWlseTogbWF0ZXJpYWwtaWNvbnM7XG4gICAgZm9udC1zaXplOiAyNHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgd2lkdGg6IDI0cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1hcmdpbi1yaWdodDogMTBweDtcbiAgICBjb2xvcjogdmFyKC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xuICAgIGZsZXg6IG5vbmU7XG4gIH1cblxuICA6aG9zdChbc2VsZWN0ZWRdKSBbcGFydD0nY2hlY2ttYXJrJ106OmJlZm9yZSB7XG4gICAgY29udGVudDogdmFyKC0tbWF0ZXJpYWwtaWNvbnMtY2hlY2spO1xuICB9XG5cbiAgQG1lZGlhIChhbnktaG92ZXI6IGhvdmVyKSB7XG4gICAgOmhvc3QoOmhvdmVyOm5vdChbZGlzYWJsZWRdKSkge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LWJhY2tncm91bmQtY29sb3IpO1xuICAgIH1cblxuICAgIDpob3N0KFtmb2N1c2VkXTpub3QoW2Rpc2FibGVkXSkpIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW1hdGVyaWFsLWRpdmlkZXItY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qIERpc2FibGVkICovXG4gIDpob3N0KFtkaXNhYmxlZF0pIHtcbiAgICBjb2xvcjogdmFyKC0tbWF0ZXJpYWwtZGlzYWJsZWQtdGV4dC1jb2xvcik7XG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG5cbiAgLyogUlRMIHNwZWNpZmljIHN0eWxlcyAqL1xuICA6aG9zdChbZGlyPSdydGwnXSkge1xuICAgIHBhZGRpbmc6IDhweCAxMHB4IDhweCAzMnB4O1xuICB9XG5cbiAgOmhvc3QoW2Rpcj0ncnRsJ10pIFtwYXJ0PSdjaGVja21hcmsnXTo6YmVmb3JlIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XG4gIH1cbmA7XG5cbnJlZ2lzdGVyU3R5bGVzKCd2YWFkaW4taXRlbScsIGl0ZW0sIHsgbW9kdWxlSWQ6ICdtYXRlcmlhbC1pdGVtJyB9KTtcblxuZXhwb3J0IHsgaXRlbSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/item/theme/material/vaadin-item-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/lit-renderer/node_modules/lit/async-directive.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@vaadin/lit-renderer/node_modules/lit/async-directive.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncDirective": () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.AsyncDirective),
/* harmony export */   "Directive": () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.Directive),
/* harmony export */   "PartType": () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.PartType),
/* harmony export */   "directive": () => (/* reexport safe */ lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__.directive)
/* harmony export */ });
/* harmony import */ var lit_html_async_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/async-directive.js */ "./node_modules/lit-html/development/async-directive.js");


/***/ }),

/***/ "./node_modules/@vaadin/lit-renderer/node_modules/lit/directive.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vaadin/lit-renderer/node_modules/lit/directive.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Directive": () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.Directive),
/* harmony export */   "PartType": () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.PartType),
/* harmony export */   "directive": () => (/* reexport safe */ lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__.directive)
/* harmony export */ });
/* harmony import */ var lit_html_directive_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-html/directive.js */ "./node_modules/lit-html/development/directive.js");


/***/ }),

/***/ "./node_modules/@vaadin/lit-renderer/node_modules/lit/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vaadin/lit-renderer/node_modules/lit/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSResult": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.CSSResult),
/* harmony export */   "LitElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),
/* harmony export */   "ReactiveElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.ReactiveElement),
/* harmony export */   "UpdatingElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),
/* harmony export */   "_$LE": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LE),
/* harmony export */   "_$LH": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LH),
/* harmony export */   "adoptStyles": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.adoptStyles),
/* harmony export */   "css": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.css),
/* harmony export */   "defaultConverter": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.defaultConverter),
/* harmony export */   "getCompatibleStyle": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.getCompatibleStyle),
/* harmony export */   "html": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.html),
/* harmony export */   "isServer": () => (/* reexport safe */ lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__.isServer),
/* harmony export */   "noChange": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.noChange),
/* harmony export */   "notEqual": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.notEqual),
/* harmony export */   "nothing": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.nothing),
/* harmony export */   "render": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.render),
/* harmony export */   "supportsAdoptingStyleSheets": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.supportsAdoptingStyleSheets),
/* harmony export */   "svg": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.svg),
/* harmony export */   "unsafeCSS": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ "./node_modules/@lit/reactive-element/development/reactive-element.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit-element/lit-element.js */ "./node_modules/lit-element/development/lit-element.js");
/* harmony import */ var lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit-html/is-server.js */ "./node_modules/lit-html/development/is-server.js");





/***/ }),

/***/ "./node_modules/@vaadin/lit-renderer/src/lit-renderer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vaadin/lit-renderer/src/lit-renderer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LitRendererDirective\": () => (/* binding */ LitRendererDirective)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/@vaadin/lit-renderer/node_modules/lit/index.js\");\n/* harmony import */ var lit_async_directive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/async-directive.js */ \"./node_modules/@vaadin/lit-renderer/node_modules/lit/async-directive.js\");\n/* harmony import */ var lit_directive_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/directive.js */ \"./node_modules/@vaadin/lit-renderer/node_modules/lit/directive.js\");\n/**\n * @license\n * Copyright (c) 2016 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n// A symbol indicating that the directive hasn't been initialized.\nconst VALUE_NOT_INITIALIZED = Symbol('valueNotInitialized');\nclass LitRendererDirective extends lit_async_directive_js__WEBPACK_IMPORTED_MODULE_1__.AsyncDirective {\n  constructor(part) {\n    super(part);\n    if (part.type !== lit_directive_js__WEBPACK_IMPORTED_MODULE_2__.PartType.ELEMENT) {\n      throw new Error(`\\`${this.constructor.name}\\` must be bound to an element.`);\n    }\n    this.previousValue = VALUE_NOT_INITIALIZED;\n  }\n\n  /** @override */\n  render(_renderer, _value) {\n    return lit__WEBPACK_IMPORTED_MODULE_0__.nothing;\n  }\n\n  /** @override */\n  update(part, [renderer, value]) {\n    if (!this.hasChanged(value)) {\n      return lit__WEBPACK_IMPORTED_MODULE_0__.nothing;\n    }\n    this.host = part.options && part.options.host;\n    this.element = part.element;\n    this.renderer = renderer;\n    const firstRender = this.previousValue === VALUE_NOT_INITIALIZED;\n    if (firstRender) {\n      this.addRenderer();\n    } else {\n      this.runRenderer();\n    }\n\n    // Copy the value if it is an array in order to keep it\n    // from possible outside mutations.\n    this.previousValue = Array.isArray(value) ? [...value] : value;\n    return lit__WEBPACK_IMPORTED_MODULE_0__.nothing;\n  }\n\n  /** @override */\n  reconnected() {\n    this.addRenderer();\n  }\n\n  /** @override */\n  disconnected() {\n    this.removeRenderer();\n  }\n\n  /** @abstract */\n  addRenderer() {\n    throw new Error('The `addRenderer` method must be implemented.');\n  }\n\n  /** @abstract */\n  runRenderer() {\n    throw new Error('The `runRenderer` method must be implemented.');\n  }\n\n  /** @abstract */\n  removeRenderer() {\n    throw new Error('The `removeRenderer` method must be implemented.');\n  }\n\n  /** @protected */\n  renderRenderer(container, ...args) {\n    const templateResult = this.renderer.call(this.host, ...args);\n    (0,lit__WEBPACK_IMPORTED_MODULE_0__.render)(templateResult, container, {\n      host: this.host\n    });\n  }\n\n  /** @protected */\n  hasChanged(value) {\n    if (Array.isArray(value)) {\n      if (!Array.isArray(this.previousValue)) {\n        return true;\n      }\n      if (this.previousValue.length !== value.length) {\n        return true;\n      }\n\n      // For arrays, perform shallow dirty checking for each element.\n      return value.some((v, i) => v !== this.previousValue[i]);\n    }\n    return this.previousValue !== value;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9saXQtcmVuZGVyZXIvc3JjL2xpdC1yZW5kZXJlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9saXQtcmVuZGVyZXIvc3JjL2xpdC1yZW5kZXJlci5qcz83MjZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgbm90aGluZywgcmVuZGVyIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IEFzeW5jRGlyZWN0aXZlIH0gZnJvbSAnbGl0L2FzeW5jLWRpcmVjdGl2ZS5qcyc7XG5pbXBvcnQgeyBQYXJ0VHlwZSB9IGZyb20gJ2xpdC9kaXJlY3RpdmUuanMnO1xuXG4vLyBBIHN5bWJvbCBpbmRpY2F0aW5nIHRoYXQgdGhlIGRpcmVjdGl2ZSBoYXNuJ3QgYmVlbiBpbml0aWFsaXplZC5cbmNvbnN0IFZBTFVFX05PVF9JTklUSUFMSVpFRCA9IFN5bWJvbCgndmFsdWVOb3RJbml0aWFsaXplZCcpO1xuXG5leHBvcnQgY2xhc3MgTGl0UmVuZGVyZXJEaXJlY3RpdmUgZXh0ZW5kcyBBc3luY0RpcmVjdGl2ZSB7XG4gIGNvbnN0cnVjdG9yKHBhcnQpIHtcbiAgICBzdXBlcihwYXJ0KTtcblxuICAgIGlmIChwYXJ0LnR5cGUgIT09IFBhcnRUeXBlLkVMRU1FTlQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9XFxgIG11c3QgYmUgYm91bmQgdG8gYW4gZWxlbWVudC5gKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBWQUxVRV9OT1RfSU5JVElBTElaRUQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHJlbmRlcihfcmVuZGVyZXIsIF92YWx1ZSkge1xuICAgIHJldHVybiBub3RoaW5nO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICB1cGRhdGUocGFydCwgW3JlbmRlcmVyLCB2YWx1ZV0pIHtcbiAgICBpZiAoIXRoaXMuaGFzQ2hhbmdlZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBub3RoaW5nO1xuICAgIH1cblxuICAgIHRoaXMuaG9zdCA9IHBhcnQub3B0aW9ucyAmJiBwYXJ0Lm9wdGlvbnMuaG9zdDtcbiAgICB0aGlzLmVsZW1lbnQgPSBwYXJ0LmVsZW1lbnQ7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gICAgY29uc3QgZmlyc3RSZW5kZXIgPSB0aGlzLnByZXZpb3VzVmFsdWUgPT09IFZBTFVFX05PVF9JTklUSUFMSVpFRDtcbiAgICBpZiAoZmlyc3RSZW5kZXIpIHtcbiAgICAgIHRoaXMuYWRkUmVuZGVyZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydW5SZW5kZXJlcigpO1xuICAgIH1cblxuICAgIC8vIENvcHkgdGhlIHZhbHVlIGlmIGl0IGlzIGFuIGFycmF5IGluIG9yZGVyIHRvIGtlZXAgaXRcbiAgICAvLyBmcm9tIHBvc3NpYmxlIG91dHNpZGUgbXV0YXRpb25zLlxuICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gWy4uLnZhbHVlXSA6IHZhbHVlO1xuXG4gICAgcmV0dXJuIG5vdGhpbmc7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHJlY29ubmVjdGVkKCkge1xuICAgIHRoaXMuYWRkUmVuZGVyZXIoKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGlzY29ubmVjdGVkKCkge1xuICAgIHRoaXMucmVtb3ZlUmVuZGVyZXIoKTtcbiAgfVxuXG4gIC8qKiBAYWJzdHJhY3QgKi9cbiAgYWRkUmVuZGVyZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGFkZFJlbmRlcmVyYCBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAYWJzdHJhY3QgKi9cbiAgcnVuUmVuZGVyZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHJ1blJlbmRlcmVyYCBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAYWJzdHJhY3QgKi9cbiAgcmVtb3ZlUmVuZGVyZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHJlbW92ZVJlbmRlcmVyYCBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIHJlbmRlclJlbmRlcmVyKGNvbnRhaW5lciwgLi4uYXJncykge1xuICAgIGNvbnN0IHRlbXBsYXRlUmVzdWx0ID0gdGhpcy5yZW5kZXJlci5jYWxsKHRoaXMuaG9zdCwgLi4uYXJncyk7XG4gICAgcmVuZGVyKHRlbXBsYXRlUmVzdWx0LCBjb250YWluZXIsIHsgaG9zdDogdGhpcy5ob3N0IH0pO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgaGFzQ2hhbmdlZCh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMucHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZXZpb3VzVmFsdWUubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBhcnJheXMsIHBlcmZvcm0gc2hhbGxvdyBkaXJ0eSBjaGVja2luZyBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAgcmV0dXJuIHZhbHVlLnNvbWUoKHYsIGkpID0+IHYgIT09IHRoaXMucHJldmlvdXNWYWx1ZVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZSAhPT0gdmFsdWU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/lit-renderer/src/lit-renderer.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemableMixin\": () => (/* binding */ ThemableMixin),\n/* harmony export */   \"__themeRegistry\": () => (/* binding */ themeRegistry),\n/* harmony export */   \"css\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* binding */ registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/@vaadin/overlay/node_modules/lit/index.js\");\n/* harmony import */ var _vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-theme-property-mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nfunction registerStyles(themeFor, styles, options = {}) {\n  if (themeFor) {\n    if (hasThemes(themeFor)) {\n      console.warn(`The custom element definition for \"${themeFor}\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element.`);\n    }\n  }\n  styles = flattenStyles(styles);\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId\n    });\n  }\n}\n\n/**\n * Returns all registered themes. By default the themeRegistry is returned as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  }\n  return themeRegistry;\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some(themeForToken => {\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`).test(tagName);\n  });\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\n    includePriority = 1;\n  } else if (moduleName.startsWith('vaadin-')) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\nfunction flattenStyles(styles = []) {\n  return [styles].flat(Infinity).filter(style => {\n    if (style instanceof lit__WEBPACK_IMPORTED_MODULE_0__.CSSResult) {\n      return true;\n    }\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n    return false;\n  });\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach(includeModuleId => {\n      const includedTheme = getAllThemes().find(s => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = styles.map(style => style.cssText).join('\\n');\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = `${tagName}-default-theme`;\n  const themes = getAllThemes()\n  // Filter by matching themeFor properties\n  .filter(theme => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map(theme => ({\n    ...theme,\n    // Prepend styles from included themes\n    styles: [...getIncludedStyles(theme), ...theme.styles],\n    // Map moduleId to includePriority\n    includePriority: getIncludePriority(theme.moduleId)\n  }))\n  // Sort by includePriority\n  .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n  if (themes.length > 0) {\n    return themes;\n  }\n  // No theme modules found, return the default module if it exists\n  return getAllThemes().filter(theme => theme.moduleId === defaultModuleName);\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction hasThemes(tagName) {\n  return classHasThemes(customElements.get(tagName));\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {Function} elementClass\n * @returns {boolean}\n */\nfunction classHasThemes(elementClass) {\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nconst ThemableMixin = superClass => class VaadinThemableMixin extends (0,_vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ThemePropertyMixin)(superClass) {\n  /**\n   * Covers PolymerElement based component styling\n   * @protected\n   */\n  static finalize() {\n    super.finalize();\n\n    // Make sure not to run the logic intended for PolymerElement when LitElement is used.\n    if (this.elementStyles) {\n      return;\n    }\n    const template = this.prototype._template;\n    if (!template || classHasThemes(this)) {\n      return;\n    }\n    addStylesToTemplate(this.getStylesForThis(), template);\n  }\n\n  /**\n   * Covers LitElement based component styling\n   *\n   * @protected\n   */\n  static finalizeStyles(styles) {\n    // The \"styles\" object originates from the \"static get styles()\" function of\n    // a LitElement based component. The theme styles are added after it\n    // so that they can override the component styles.\n    const themeStyles = this.getStylesForThis();\n    return styles ? [...super.finalizeStyles(styles), ...themeStyles] : themeStyles;\n  }\n\n  /**\n   * Get styles for the component type\n   *\n   * @private\n   */\n  static getStylesForThis() {\n    const parent = Object.getPrototypeOf(this.prototype);\n    const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\n    this.__themes = [...inheritedThemes, ...getThemes(this.is)];\n    const themeStyles = this.__themes.flatMap(theme => theme.styles);\n    // Remove duplicates\n    return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcz8zZGJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgY3NzLCBDU1NSZXN1bHQsIHVuc2FmZUNTUyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBUaGVtZVByb3BlcnR5TWl4aW4gfSBmcm9tICcuL3ZhYWRpbi10aGVtZS1wcm9wZXJ0eS1taXhpbi5qcyc7XG5cbmV4cG9ydCB7IGNzcywgdW5zYWZlQ1NTIH07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGhlbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aGVtZUZvclxuICogQHByb3BlcnR5IHtDU1NSZXN1bHRbXX0gc3R5bGVzXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHN0cmluZ1tdfSBbaW5jbHVkZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbW9kdWxlSWRdXG4gKlxuICogQHR5cGVkZWYge0NTU1Jlc3VsdFtdIHwgQ1NTUmVzdWx0fSBDU1NSZXN1bHRHcm91cFxuICovXG5cbi8qKlxuICogQHR5cGUge1RoZW1lW119XG4gKi9cbmNvbnN0IHRoZW1lUmVnaXN0cnkgPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgQ1NTIHN0eWxlcyBmb3IgYSBjb21wb25lbnQgdHlwZS4gTWFrZSBzdXJlIHRvIHJlZ2lzdGVyIHRoZSBzdHlsZXMgYmVmb3JlXG4gKiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgb2YgdGhlIHR5cGUgaXMgYXR0YWNoZWQgdG8gRE9NLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZUZvciBUaGUgbG9jYWwvdGFnIG5hbWUgb2YgdGhlIGNvbXBvbmVudCB0eXBlIHRvIHJlZ2lzdGVyIHRoZSBzdHlsZXMgZm9yXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdEdyb3VwfSBzdHlsZXMgVGhlIENTUyBzdHlsZSBydWxlcyB0byBiZSByZWdpc3RlcmVkIGZvciB0aGUgY29tcG9uZW50IHR5cGVcbiAqIG1hdGNoaW5nIHRoZW1lRm9yIGFuZCBpbmNsdWRlZCBpbiB0aGUgbG9jYWwgc2NvcGUgb2YgZWFjaCBjb21wb25lbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7e21vZHVsZUlkPzogc3RyaW5nLCBpbmNsdWRlPzogc3RyaW5nIHwgc3RyaW5nW119fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKHRoZW1lRm9yLCBzdHlsZXMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodGhlbWVGb3IpIHtcbiAgICBpZiAoaGFzVGhlbWVzKHRoZW1lRm9yKSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgY3VzdG9tIGVsZW1lbnQgZGVmaW5pdGlvbiBmb3IgXCIke3RoZW1lRm9yfVwiXG4gICAgICB3YXMgZmluYWxpemVkIGJlZm9yZSBhIHN0eWxlIG1vZHVsZSB3YXMgcmVnaXN0ZXJlZC5cbiAgICAgIE1ha2Ugc3VyZSB0byBhZGQgY29tcG9uZW50IHNwZWNpZmljIHN0eWxlIG1vZHVsZXMgYmVmb3JlXG4gICAgICBpbXBvcnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgfVxuICB9XG5cbiAgc3R5bGVzID0gZmxhdHRlblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmICh3aW5kb3cuVmFhZGluICYmIHdpbmRvdy5WYWFkaW4uc3R5bGVNb2R1bGVzKSB7XG4gICAgd2luZG93LlZhYWRpbi5zdHlsZU1vZHVsZXMucmVnaXN0ZXJTdHlsZXModGhlbWVGb3IsIHN0eWxlcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhlbWVSZWdpc3RyeS5wdXNoKHtcbiAgICAgIHRoZW1lRm9yLFxuICAgICAgc3R5bGVzLFxuICAgICAgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlLFxuICAgICAgbW9kdWxlSWQ6IG9wdGlvbnMubW9kdWxlSWQsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHRoZW1lcy4gQnkgZGVmYXVsdCB0aGUgdGhlbWVSZWdpc3RyeSBpcyByZXR1cm5lZCBhcyBpcy5cbiAqIEluIGNhc2UgdGhlIHN0eWxlLW1vZHVsZXMgYWRhcHRlciBpcyBpbXBvcnRlZCwgdGhlIHRoZW1lcyBhcmUgb2J0YWluZWQgZnJvbSB0aGVyZSBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7VGhlbWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsVGhlbWVzKCkge1xuICBpZiAod2luZG93LlZhYWRpbiAmJiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcykge1xuICAgIHJldHVybiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcy5nZXRBbGxUaGVtZXMoKTtcbiAgfVxuICByZXR1cm4gdGhlbWVSZWdpc3RyeTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRoZW1lRm9yIHN0cmluZyBtYXRjaGVzIHRoZSB0YWcgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lRm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNUaGVtZUZvcih0aGVtZUZvciwgdGFnTmFtZSkge1xuICByZXR1cm4gKHRoZW1lRm9yIHx8ICcnKS5zcGxpdCgnICcpLnNvbWUoKHRoZW1lRm9yVG9rZW4pID0+IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGhlbWVGb3JUb2tlbi5zcGxpdCgnKicpLmpvaW4oJy4qJyl9JGApLnRlc3QodGFnTmFtZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hcHMgdGhlIG1vZHVsZU5hbWUgdG8gYW4gaW5jbHVkZSBwcmlvcml0eSBudW1iZXIgd2hpY2ggaXMgdXNlZCBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBvcmRlciBpbiB3aGljaCBzdHlsZXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0SW5jbHVkZVByaW9yaXR5KG1vZHVsZU5hbWUgPSAnJykge1xuICBsZXQgaW5jbHVkZVByaW9yaXR5ID0gMDtcbiAgaWYgKG1vZHVsZU5hbWUuc3RhcnRzV2l0aCgnbHVtby0nKSB8fCBtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ21hdGVyaWFsLScpKSB7XG4gICAgaW5jbHVkZVByaW9yaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ3ZhYWRpbi0nKSkge1xuICAgIGluY2x1ZGVQcmlvcml0eSA9IDI7XG4gIH1cbiAgcmV0dXJuIGluY2x1ZGVQcmlvcml0eTtcbn1cblxuLyoqXG4gKiBGbGF0dGVucyB0aGUgc3R5bGVzIGludG8gYSBzaW5nbGUgYXJyYXkgb2Ygc3R5bGVzLlxuICogQHBhcmFtIHtDU1NSZXN1bHRHcm91cH0gc3R5bGVzXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdFtdfSByZXN1bHRcbiAqIEByZXR1cm5zIHtDU1NSZXN1bHRbXX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhzdHlsZXMgPSBbXSkge1xuICByZXR1cm4gW3N0eWxlc10uZmxhdChJbmZpbml0eSkuZmlsdGVyKChzdHlsZSkgPT4ge1xuICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIENTU1Jlc3VsdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybignQW4gaXRlbSBpbiBzdHlsZXMgaXMgbm90IG9mIHR5cGUgQ1NTUmVzdWx0LiBVc2UgYHVuc2FmZUNTU2Agb3IgYGNzc2AuJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGFycmF5IG9mIENTU1Jlc3VsdHMgbWF0Y2hpbmcgdGhlIGluY2x1ZGUgcHJvcGVydHkgb2YgdGhlIHRoZW1lLlxuICogQHBhcmFtIHtUaGVtZX0gdGhlbWVcbiAqIEByZXR1cm5zIHtDU1NSZXN1bHRbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0SW5jbHVkZWRTdHlsZXModGhlbWUpIHtcbiAgY29uc3QgaW5jbHVkZWRTdHlsZXMgPSBbXTtcbiAgaWYgKHRoZW1lLmluY2x1ZGUpIHtcbiAgICBbXS5jb25jYXQodGhlbWUuaW5jbHVkZSkuZm9yRWFjaCgoaW5jbHVkZU1vZHVsZUlkKSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlZFRoZW1lID0gZ2V0QWxsVGhlbWVzKCkuZmluZCgocykgPT4gcy5tb2R1bGVJZCA9PT0gaW5jbHVkZU1vZHVsZUlkKTtcbiAgICAgIGlmIChpbmNsdWRlZFRoZW1lKSB7XG4gICAgICAgIGluY2x1ZGVkU3R5bGVzLnB1c2goLi4uZ2V0SW5jbHVkZWRTdHlsZXMoaW5jbHVkZWRUaGVtZSksIC4uLmluY2x1ZGVkVGhlbWUuc3R5bGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW5jbHVkZWQgbW9kdWxlSWQgJHtpbmNsdWRlTW9kdWxlSWR9IG5vdCBmb3VuZCBpbiBzdHlsZSByZWdpc3RyeWApO1xuICAgICAgfVxuICAgIH0sIHRoZW1lLnN0eWxlcyk7XG4gIH1cbiAgcmV0dXJuIGluY2x1ZGVkU3R5bGVzO1xufVxuXG4vKipcbiAqIEluY2x1ZGVzIHRoZSBzdHlsZXMgdG8gdGhlIHRlbXBsYXRlLlxuICogQHBhcmFtIHtDU1NSZXN1bHRbXX0gc3R5bGVzXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvVGVtcGxhdGUoc3R5bGVzLCB0ZW1wbGF0ZSkge1xuICBjb25zdCBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGVFbC5pbm5lckhUTUwgPSBzdHlsZXMubWFwKChzdHlsZSkgPT4gc3R5bGUuY3NzVGV4dCkuam9pbignXFxuJyk7XG4gIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGVtZXMgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3Igc3R5bGluZyBhIGNvbXBvbmVudCBtYXRjaGluZ1xuICogdGhlIHRhZyBuYW1lLiBUaGUgYXJyYXkgaXMgc29ydGVkIGJ5IHRoZSBpbmNsdWRlIG9yZGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAqIEByZXR1cm5zIHtUaGVtZVtdfVxuICovXG5mdW5jdGlvbiBnZXRUaGVtZXModGFnTmFtZSkge1xuICBjb25zdCBkZWZhdWx0TW9kdWxlTmFtZSA9IGAke3RhZ05hbWV9LWRlZmF1bHQtdGhlbWVgO1xuXG4gIGNvbnN0IHRoZW1lcyA9IGdldEFsbFRoZW1lcygpXG4gICAgLy8gRmlsdGVyIGJ5IG1hdGNoaW5nIHRoZW1lRm9yIHByb3BlcnRpZXNcbiAgICAuZmlsdGVyKCh0aGVtZSkgPT4gdGhlbWUubW9kdWxlSWQgIT09IGRlZmF1bHRNb2R1bGVOYW1lICYmIG1hdGNoZXNUaGVtZUZvcih0aGVtZS50aGVtZUZvciwgdGFnTmFtZSkpXG4gICAgLm1hcCgodGhlbWUpID0+ICh7XG4gICAgICAuLi50aGVtZSxcbiAgICAgIC8vIFByZXBlbmQgc3R5bGVzIGZyb20gaW5jbHVkZWQgdGhlbWVzXG4gICAgICBzdHlsZXM6IFsuLi5nZXRJbmNsdWRlZFN0eWxlcyh0aGVtZSksIC4uLnRoZW1lLnN0eWxlc10sXG4gICAgICAvLyBNYXAgbW9kdWxlSWQgdG8gaW5jbHVkZVByaW9yaXR5XG4gICAgICBpbmNsdWRlUHJpb3JpdHk6IGdldEluY2x1ZGVQcmlvcml0eSh0aGVtZS5tb2R1bGVJZCksXG4gICAgfSkpXG4gICAgLy8gU29ydCBieSBpbmNsdWRlUHJpb3JpdHlcbiAgICAuc29ydCgodGhlbWVBLCB0aGVtZUIpID0+IHRoZW1lQi5pbmNsdWRlUHJpb3JpdHkgLSB0aGVtZUEuaW5jbHVkZVByaW9yaXR5KTtcblxuICBpZiAodGhlbWVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdGhlbWVzO1xuICB9XG4gIC8vIE5vIHRoZW1lIG1vZHVsZXMgZm91bmQsIHJldHVybiB0aGUgZGVmYXVsdCBtb2R1bGUgaWYgaXQgZXhpc3RzXG4gIHJldHVybiBnZXRBbGxUaGVtZXMoKS5maWx0ZXIoKHRoZW1lKSA9PiB0aGVtZS5tb2R1bGVJZCA9PT0gZGVmYXVsdE1vZHVsZU5hbWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXN0b20gZWxlbWVudCB0eXBlIGhhcyB0aGVtZXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzVGhlbWVzKHRhZ05hbWUpIHtcbiAgcmV0dXJuIGNsYXNzSGFzVGhlbWVzKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1c3RvbSBlbGVtZW50IHR5cGUgaGFzIHRoZW1lcyBhcHBsaWVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWxlbWVudENsYXNzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2xhc3NIYXNUaGVtZXMoZWxlbWVudENsYXNzKSB7XG4gIHJldHVybiBlbGVtZW50Q2xhc3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnRDbGFzcywgJ19fdGhlbWVzJyk7XG59XG5cbi8qKlxuICogQHBvbHltZXJNaXhpblxuICogQG1peGVzIFRoZW1lUHJvcGVydHlNaXhpblxuICovXG5leHBvcnQgY29uc3QgVGhlbWFibGVNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5UaGVtYWJsZU1peGluIGV4dGVuZHMgVGhlbWVQcm9wZXJ0eU1peGluKHN1cGVyQ2xhc3MpIHtcbiAgICAvKipcbiAgICAgKiBDb3ZlcnMgUG9seW1lckVsZW1lbnQgYmFzZWQgY29tcG9uZW50IHN0eWxpbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgc3VwZXIuZmluYWxpemUoKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIG5vdCB0byBydW4gdGhlIGxvZ2ljIGludGVuZGVkIGZvciBQb2x5bWVyRWxlbWVudCB3aGVuIExpdEVsZW1lbnQgaXMgdXNlZC5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnRTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZTtcbiAgICAgIGlmICghdGVtcGxhdGUgfHwgY2xhc3NIYXNUaGVtZXModGhpcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhZGRTdHlsZXNUb1RlbXBsYXRlKHRoaXMuZ2V0U3R5bGVzRm9yVGhpcygpLCB0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ292ZXJzIExpdEVsZW1lbnQgYmFzZWQgY29tcG9uZW50IHN0eWxpbmdcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemVTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAvLyBUaGUgXCJzdHlsZXNcIiBvYmplY3Qgb3JpZ2luYXRlcyBmcm9tIHRoZSBcInN0YXRpYyBnZXQgc3R5bGVzKClcIiBmdW5jdGlvbiBvZlxuICAgICAgLy8gYSBMaXRFbGVtZW50IGJhc2VkIGNvbXBvbmVudC4gVGhlIHRoZW1lIHN0eWxlcyBhcmUgYWRkZWQgYWZ0ZXIgaXRcbiAgICAgIC8vIHNvIHRoYXQgdGhleSBjYW4gb3ZlcnJpZGUgdGhlIGNvbXBvbmVudCBzdHlsZXMuXG4gICAgICBjb25zdCB0aGVtZVN0eWxlcyA9IHRoaXMuZ2V0U3R5bGVzRm9yVGhpcygpO1xuICAgICAgcmV0dXJuIHN0eWxlcyA/IFsuLi5zdXBlci5maW5hbGl6ZVN0eWxlcyhzdHlsZXMpLCAuLi50aGVtZVN0eWxlc10gOiB0aGVtZVN0eWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3R5bGVzIGZvciB0aGUgY29tcG9uZW50IHR5cGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0eWxlc0ZvclRoaXMoKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5wcm90b3R5cGUpO1xuICAgICAgY29uc3QgaW5oZXJpdGVkVGhlbWVzID0gKHBhcmVudCA/IHBhcmVudC5jb25zdHJ1Y3Rvci5fX3RoZW1lcyA6IFtdKSB8fCBbXTtcbiAgICAgIHRoaXMuX190aGVtZXMgPSBbLi4uaW5oZXJpdGVkVGhlbWVzLCAuLi5nZXRUaGVtZXModGhpcy5pcyldO1xuICAgICAgY29uc3QgdGhlbWVTdHlsZXMgPSB0aGlzLl9fdGhlbWVzLmZsYXRNYXAoKHRoZW1lKSA9PiB0aGVtZS5zdHlsZXMpO1xuICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgIHJldHVybiB0aGVtZVN0eWxlcy5maWx0ZXIoKHN0eWxlLCBpbmRleCkgPT4gaW5kZXggPT09IHRoZW1lU3R5bGVzLmxhc3RJbmRleE9mKHN0eWxlKSk7XG4gICAgfVxuICB9O1xuXG5leHBvcnQgeyB0aGVtZVJlZ2lzdHJ5IGFzIF9fdGhlbWVSZWdpc3RyeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemePropertyMixin\": () => (/* binding */ ThemePropertyMixin)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nconst ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @deprecated The `theme` property is not supposed for public use and will be dropped in Vaadin 24.\n       * Please, use the `theme` attribute instead.\n       * @protected\n       */\n      theme: {\n        type: String,\n        reflectToAttribute: true,\n        observer: '__deprecatedThemePropertyChanged'\n      },\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @protected\n       */\n      _theme: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n\n  /** @private */\n  __deprecatedThemePropertyChanged(theme) {\n    this._set_theme(theme);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWUtcHJvcGVydHktbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzP2JiNWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IFRoZW1lUHJvcGVydHlNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5UaGVtZVByb3BlcnR5TWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHByb3BlcnR5IHdpdGggdGhlbWUgYXR0cmlidXRlIHZhbHVlIGZhY2lsaXRhdGluZyBwcm9wYWdhdGlvblxuICAgICAgICAgKiBpbiBzaGFkb3cgRE9NLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgXG4gICAgICAgICAqIGF0dHJpYnV0ZSB2YWx1ZSB0byB0aGUgc3ViLWNvbXBvbmVudHMgaW4gU2hhZG93IERPTSBieSBiaW5kaW5nXG4gICAgICAgICAqIHRoZSBzdWItY29tcG9uZW504oCZcyBcInRoZW1lXCIgYXR0cmlidXRlIHRvIHRoZSBgdGhlbWVgIHByb3BlcnR5IG9mXG4gICAgICAgICAqIHRoZSBob3N0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEU6KiogRXh0ZW5kaW5nIHRoZSBtaXhpbiBvbmx5IHByb3ZpZGVzIHRoZSBwcm9wZXJ0eSBmb3IgYmluZGluZyxcbiAgICAgICAgICogYW5kIGRvZXMgbm90IG1ha2UgdGhlIHByb3BhZ2F0aW9uIGFsb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50czogU3ViLWNvbXBvbmVudHNdKGh0dHBzOi8vdmFhZGluLmNvbS9kb2NzL2xhdGVzdC9zdHlsaW5nL2N1c3RvbS10aGVtZS9zdHlsaW5nLWNvbXBvbmVudHMvI3N1Yi1jb21wb25lbnRzKS5cbiAgICAgICAgICogcGFnZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVGhlIGB0aGVtZWAgcHJvcGVydHkgaXMgbm90IHN1cHBvc2VkIGZvciBwdWJsaWMgdXNlIGFuZCB3aWxsIGJlIGRyb3BwZWQgaW4gVmFhZGluIDI0LlxuICAgICAgICAgKiBQbGVhc2UsIHVzZSB0aGUgYHRoZW1lYCBhdHRyaWJ1dGUgaW5zdGVhZC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19kZXByZWNhdGVkVGhlbWVQcm9wZXJ0eUNoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgcHJvcGVydHkgd2l0aCB0aGVtZSBhdHRyaWJ1dGUgdmFsdWUgZmFjaWxpdGF0aW5nIHByb3BhZ2F0aW9uXG4gICAgICAgICAqIGluIHNoYWRvdyBET00uXG4gICAgICAgICAqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbiB0byBwcm9wYWdhdGUgdGhlIGB0aGVtZWBcbiAgICAgICAgICogYXR0cmlidXRlIHZhbHVlIHRvIHRoZSBzdWItY29tcG9uZW50cyBpbiBTaGFkb3cgRE9NIGJ5IGJpbmRpbmdcbiAgICAgICAgICogdGhlIHN1Yi1jb21wb25lbnTigJlzIFwidGhlbWVcIiBhdHRyaWJ1dGUgdG8gdGhlIGB0aGVtZWAgcHJvcGVydHkgb2ZcbiAgICAgICAgICogdGhlIGhvc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URToqKiBFeHRlbmRpbmcgdGhlIG1peGluIG9ubHkgcHJvdmlkZXMgdGhlIHByb3BlcnR5IGZvciBiaW5kaW5nLFxuICAgICAgICAgKiBhbmQgZG9lcyBub3QgbWFrZSB0aGUgcHJvcGFnYXRpb24gYWxvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBbU3R5bGluZyBDb21wb25lbnRzOiBTdWItY29tcG9uZW50c10oaHR0cHM6Ly92YWFkaW4uY29tL2RvY3MvbGF0ZXN0L3N0eWxpbmcvY3VzdG9tLXRoZW1lL3N0eWxpbmctY29tcG9uZW50cy8jc3ViLWNvbXBvbmVudHMpLlxuICAgICAgICAgKiBwYWdlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdGhlbWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9fZGVwcmVjYXRlZFRoZW1lUHJvcGVydHlDaGFuZ2VkKHRoZW1lKSB7XG4gICAgICB0aGlzLl9zZXRfdGhlbWUodGhlbWUpO1xuICAgIH1cbiAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/node_modules/lit/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/node_modules/lit/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSResult": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.CSSResult),
/* harmony export */   "LitElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),
/* harmony export */   "ReactiveElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.ReactiveElement),
/* harmony export */   "UpdatingElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),
/* harmony export */   "_$LE": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LE),
/* harmony export */   "_$LH": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LH),
/* harmony export */   "adoptStyles": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.adoptStyles),
/* harmony export */   "css": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.css),
/* harmony export */   "defaultConverter": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.defaultConverter),
/* harmony export */   "getCompatibleStyle": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.getCompatibleStyle),
/* harmony export */   "html": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.html),
/* harmony export */   "isServer": () => (/* reexport safe */ lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__.isServer),
/* harmony export */   "noChange": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.noChange),
/* harmony export */   "notEqual": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.notEqual),
/* harmony export */   "nothing": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.nothing),
/* harmony export */   "render": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.render),
/* harmony export */   "supportsAdoptingStyleSheets": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.supportsAdoptingStyleSheets),
/* harmony export */   "svg": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.svg),
/* harmony export */   "unsafeCSS": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ "./node_modules/@lit/reactive-element/development/reactive-element.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit-element/lit-element.js */ "./node_modules/lit-element/development/lit-element.js");
/* harmony import */ var lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit-html/is-server.js */ "./node_modules/lit-html/development/is-server.js");





/***/ }),

/***/ "./node_modules/@vaadin/overlay/src/vaadin-overlay-position-mixin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/src/vaadin-overlay-position-mixin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PositionMixin\": () => (/* binding */ PositionMixin)\n/* harmony export */ });\n/* harmony import */ var _vaadin_component_base_src_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/component-base/src/dom-utils.js */ \"./node_modules/@vaadin/component-base/src/dom-utils.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom'\n};\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right'\n};\nconst targetResizeObserver = new ResizeObserver(entries => {\n  setTimeout(() => {\n    entries.forEach(entry => {\n      if (entry.target.__overlay) {\n        entry.target.__overlay._updatePosition();\n      }\n    });\n  });\n});\n\n/**\n * @polymerMixin\n */\nconst PositionMixin = superClass => class PositionMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * The element next to which this overlay should be aligned.\n       * The position of the overlay relative to the positionTarget can be adjusted\n       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n       * and `noVerticalOverlap`.\n       */\n      positionTarget: {\n        type: Object,\n        value: null\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether to align the overlay's\n       * left or right side to the target element by default.\n       * Possible values are `start` and `end`.\n       * RTL is taken into account when interpreting the value.\n       * The overlay is automatically flipped to the opposite side when it doesn't fit into\n       * the default side defined by this property.\n       *\n       * @attr {start|end} horizontal-align\n       */\n      horizontalAlign: {\n        type: String,\n        value: 'start'\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether to align the overlay's\n       * top or bottom side to the target element by default.\n       * Possible values are `top` and `bottom`.\n       * The overlay is automatically flipped to the opposite side when it doesn't fit into\n       * the default side defined by this property.\n       *\n       * @attr {top|bottom} vertical-align\n       */\n      verticalAlign: {\n        type: String,\n        value: 'top'\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether the overlay should overlap\n       * the target element in the x-axis, or be positioned right next to it.\n       *\n       * @attr {boolean} no-horizontal-overlap\n       */\n      noHorizontalOverlap: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether the overlay should overlap\n       * the target element in the y-axis, or be positioned right above/below it.\n       *\n       * @attr {boolean} no-vertical-overlap\n       */\n      noVerticalOverlap: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * If the overlay content has no intrinsic height, this property can be used to set\n       * the minimum vertical space (in pixels) required by the overlay. Setting a value to\n       * the property effectively disables the content measurement in favor of using this\n       * fixed value for determining the open direction.\n       *\n       * @attr {number} required-vertical-space\n       */\n      requiredVerticalSpace: {\n        type: Number,\n        value: 0\n      }\n    };\n  }\n  static get observers() {\n    return ['__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)', '__overlayOpenedChanged(opened, positionTarget)'];\n  }\n  constructor() {\n    super();\n    this.__onScroll = this.__onScroll.bind(this);\n    this._updatePosition = this._updatePosition.bind(this);\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    if (this.opened) {\n      this.__addUpdatePositionEventListeners();\n    }\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__removeUpdatePositionEventListeners();\n  }\n\n  /** @private */\n  __addUpdatePositionEventListeners() {\n    window.addEventListener('resize', this._updatePosition);\n    this.__positionTargetAncestorRootNodes = (0,_vaadin_component_base_src_dom_utils_js__WEBPACK_IMPORTED_MODULE_0__.getAncestorRootNodes)(this.positionTarget);\n    this.__positionTargetAncestorRootNodes.forEach(node => {\n      node.addEventListener('scroll', this.__onScroll, true);\n    });\n  }\n\n  /** @private */\n  __removeUpdatePositionEventListeners() {\n    window.removeEventListener('resize', this._updatePosition);\n    if (this.__positionTargetAncestorRootNodes) {\n      this.__positionTargetAncestorRootNodes.forEach(node => {\n        node.removeEventListener('scroll', this.__onScroll, true);\n      });\n      this.__positionTargetAncestorRootNodes = null;\n    }\n  }\n\n  /** @private */\n  __overlayOpenedChanged(opened, positionTarget) {\n    this.__removeUpdatePositionEventListeners();\n    if (positionTarget) {\n      positionTarget.__overlay = null;\n      targetResizeObserver.unobserve(positionTarget);\n      if (opened) {\n        this.__addUpdatePositionEventListeners();\n        positionTarget.__overlay = this;\n        targetResizeObserver.observe(positionTarget);\n      }\n    }\n    if (opened) {\n      const computedStyle = getComputedStyle(this);\n      if (!this.__margins) {\n        this.__margins = {};\n        ['top', 'bottom', 'left', 'right'].forEach(propName => {\n          this.__margins[propName] = parseInt(computedStyle[propName], 10);\n        });\n      }\n      this.setAttribute('dir', computedStyle.direction);\n      this._updatePosition();\n      // Schedule another position update (to cover virtual keyboard opening for example)\n      requestAnimationFrame(() => this._updatePosition());\n    }\n  }\n  get __isRTL() {\n    return this.getAttribute('dir') === 'rtl';\n  }\n  __positionSettingsChanged() {\n    this._updatePosition();\n  }\n\n  /** @private */\n  __onScroll(e) {\n    // If the scroll event occurred inside the overlay, ignore it.\n    if (!this.contains(e.target)) {\n      this._updatePosition();\n    }\n  }\n  _updatePosition() {\n    if (!this.positionTarget || !this.opened) {\n      return;\n    }\n    const targetRect = this.positionTarget.getBoundingClientRect();\n\n    // Detect the desired alignment and update the layout accordingly\n    const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n    this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n    const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, this.__isRTL);\n    const flexStart = !this.__isRTL && shouldAlignStartHorizontally || this.__isRTL && !shouldAlignStartHorizontally;\n    this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n    // Get the overlay rect after possible overlay alignment changes\n    const overlayRect = this.getBoundingClientRect();\n\n    // Obtain vertical positioning properties\n    const verticalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noVerticalOverlap, PROP_NAMES_VERTICAL, this, shouldAlignStartVertically);\n\n    // Obtain horizontal positioning properties\n    const horizontalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL, this, shouldAlignStartHorizontally);\n\n    // Apply the positioning properties to the overlay\n    Object.assign(this.style, verticalProps, horizontalProps);\n    this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n    this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n    this.toggleAttribute('end-aligned', !flexStart);\n    this.toggleAttribute('start-aligned', flexStart);\n  }\n  __shouldAlignStartHorizontally(targetRect, rtl) {\n    // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n    // smaller than its current space before the fit-calculations.\n    const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n    this.__oldContentWidth = this.$.overlay.offsetWidth;\n    const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n    const defaultAlignLeft = !rtl && this.horizontalAlign === 'start' || rtl && this.horizontalAlign === 'end';\n    return this.__shouldAlignStart(targetRect, contentWidth, viewportWidth, this.__margins, defaultAlignLeft, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL);\n  }\n  __shouldAlignStartVertically(targetRect) {\n    // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n    // smaller than its current space before the fit-calculations.\n    const contentHeight = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n    this.__oldContentHeight = this.$.overlay.offsetHeight;\n    const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n    const defaultAlignTop = this.verticalAlign === 'top';\n    return this.__shouldAlignStart(targetRect, contentHeight, viewportHeight, this.__margins, defaultAlignTop, this.noVerticalOverlap, PROP_NAMES_VERTICAL);\n  }\n\n  // eslint-disable-next-line max-params\n  __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n    const spaceForStartAlignment = viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n    const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n    const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n    const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n    const shouldGoToDefaultSide = spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n    return defaultAlignStart === shouldGoToDefaultSide;\n  }\n\n  /**\n   * Returns an adjusted value after resizing the browser window,\n   * to avoid wrong calculations when e.g. previously set `bottom`\n   * CSS property value is larger than the updated viewport height.\n   * See https://github.com/vaadin/web-components/issues/4604\n   */\n  __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\n    let adjustedProp;\n    if (cssPropNameToSet === propNames.end) {\n      // Adjust horizontally\n      if (propNames.end === PROP_NAMES_VERTICAL.end) {\n        const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n        if (currentValue > viewportHeight && this.__oldViewportHeight) {\n          const heightDiff = this.__oldViewportHeight - viewportHeight;\n          adjustedProp = currentValue - heightDiff;\n        }\n        this.__oldViewportHeight = viewportHeight;\n      }\n\n      // Adjust vertically\n      if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\n        const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n        if (currentValue > viewportWidth && this.__oldViewportWidth) {\n          const widthDiff = this.__oldViewportWidth - viewportWidth;\n          adjustedProp = currentValue - widthDiff;\n        }\n        this.__oldViewportWidth = viewportWidth;\n      }\n    }\n    return adjustedProp;\n  }\n\n  /**\n   * Returns an object with CSS position properties to set,\n   * e.g. { top: \"100px\" }\n   */\n  // eslint-disable-next-line max-params\n  __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n    const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n    const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n    const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n    const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\n    const diff = overlayRect[shouldAlignStart ? propNames.start : propNames.end] - targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n    const valueToSet = adjustedValue ? `${adjustedValue}px` : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;\n    return {\n      [cssPropNameToSet]: valueToSet,\n      [cssPropNameToClear]: ''\n    };\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L3NyYy92YWFkaW4tb3ZlcmxheS1wb3NpdGlvbi1taXhpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBU0E7QUFDQTs7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9zcmMvdmFhZGluLW92ZXJsYXktcG9zaXRpb24tbWl4aW4uanM/ZjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IGdldEFuY2VzdG9yUm9vdE5vZGVzIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZG9tLXV0aWxzLmpzJztcblxuY29uc3QgUFJPUF9OQU1FU19WRVJUSUNBTCA9IHtcbiAgc3RhcnQ6ICd0b3AnLFxuICBlbmQ6ICdib3R0b20nLFxufTtcblxuY29uc3QgUFJPUF9OQU1FU19IT1JJWk9OVEFMID0ge1xuICBzdGFydDogJ2xlZnQnLFxuICBlbmQ6ICdyaWdodCcsXG59O1xuXG5jb25zdCB0YXJnZXRSZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBpZiAoZW50cnkudGFyZ2V0Ll9fb3ZlcmxheSkge1xuICAgICAgICBlbnRyeS50YXJnZXQuX19vdmVybGF5Ll91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IFBvc2l0aW9uTWl4aW4gPSAoc3VwZXJDbGFzcykgPT5cbiAgY2xhc3MgUG9zaXRpb25NaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZWxlbWVudCBuZXh0IHRvIHdoaWNoIHRoaXMgb3ZlcmxheSBzaG91bGQgYmUgYWxpZ25lZC5cbiAgICAgICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IHJlbGF0aXZlIHRvIHRoZSBwb3NpdGlvblRhcmdldCBjYW4gYmUgYWRqdXN0ZWRcbiAgICAgICAgICogd2l0aCBwcm9wZXJ0aWVzIGBob3Jpem9udGFsQWxpZ25gLCBgdmVydGljYWxBbGlnbmAsIGBub0hvcml6b250YWxPdmVybGFwYFxuICAgICAgICAgKiBhbmQgYG5vVmVydGljYWxPdmVybGFwYC5cbiAgICAgICAgICovXG4gICAgICAgIHBvc2l0aW9uVGFyZ2V0OiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBwb3NpdGlvblRhcmdldGAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IGRlZmluZXMgd2hldGhlciB0byBhbGlnbiB0aGUgb3ZlcmxheSdzXG4gICAgICAgICAqIGxlZnQgb3IgcmlnaHQgc2lkZSB0byB0aGUgdGFyZ2V0IGVsZW1lbnQgYnkgZGVmYXVsdC5cbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgc3RhcnRgIGFuZCBgZW5kYC5cbiAgICAgICAgICogUlRMIGlzIHRha2VuIGludG8gYWNjb3VudCB3aGVuIGludGVycHJldGluZyB0aGUgdmFsdWUuXG4gICAgICAgICAqIFRoZSBvdmVybGF5IGlzIGF1dG9tYXRpY2FsbHkgZmxpcHBlZCB0byB0aGUgb3Bwb3NpdGUgc2lkZSB3aGVuIGl0IGRvZXNuJ3QgZml0IGludG9cbiAgICAgICAgICogdGhlIGRlZmF1bHQgc2lkZSBkZWZpbmVkIGJ5IHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhdHRyIHtzdGFydHxlbmR9IGhvcml6b250YWwtYWxpZ25cbiAgICAgICAgICovXG4gICAgICAgIGhvcml6b250YWxBbGlnbjoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogJ3N0YXJ0JyxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgcG9zaXRpb25UYXJnZXRgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIHdoZXRoZXIgdG8gYWxpZ24gdGhlIG92ZXJsYXknc1xuICAgICAgICAgKiB0b3Agb3IgYm90dG9tIHNpZGUgdG8gdGhlIHRhcmdldCBlbGVtZW50IGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmUgYHRvcGAgYW5kIGBib3R0b21gLlxuICAgICAgICAgKiBUaGUgb3ZlcmxheSBpcyBhdXRvbWF0aWNhbGx5IGZsaXBwZWQgdG8gdGhlIG9wcG9zaXRlIHNpZGUgd2hlbiBpdCBkb2Vzbid0IGZpdCBpbnRvXG4gICAgICAgICAqIHRoZSBkZWZhdWx0IHNpZGUgZGVmaW5lZCBieSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0ciB7dG9wfGJvdHRvbX0gdmVydGljYWwtYWxpZ25cbiAgICAgICAgICovXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgdmFsdWU6ICd0b3AnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBwb3NpdGlvblRhcmdldGAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IGRlZmluZXMgd2hldGhlciB0aGUgb3ZlcmxheSBzaG91bGQgb3ZlcmxhcFxuICAgICAgICAgKiB0aGUgdGFyZ2V0IGVsZW1lbnQgaW4gdGhlIHgtYXhpcywgb3IgYmUgcG9zaXRpb25lZCByaWdodCBuZXh0IHRvIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0ciB7Ym9vbGVhbn0gbm8taG9yaXpvbnRhbC1vdmVybGFwXG4gICAgICAgICAqL1xuICAgICAgICBub0hvcml6b250YWxPdmVybGFwOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYHBvc2l0aW9uVGFyZ2V0YCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgZGVmaW5lcyB3aGV0aGVyIHRoZSBvdmVybGF5IHNob3VsZCBvdmVybGFwXG4gICAgICAgICAqIHRoZSB0YXJnZXQgZWxlbWVudCBpbiB0aGUgeS1heGlzLCBvciBiZSBwb3NpdGlvbmVkIHJpZ2h0IGFib3ZlL2JlbG93IGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0ciB7Ym9vbGVhbn0gbm8tdmVydGljYWwtb3ZlcmxhcFxuICAgICAgICAgKi9cbiAgICAgICAgbm9WZXJ0aWNhbE92ZXJsYXA6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIG92ZXJsYXkgY29udGVudCBoYXMgbm8gaW50cmluc2ljIGhlaWdodCwgdGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBzZXRcbiAgICAgICAgICogdGhlIG1pbmltdW0gdmVydGljYWwgc3BhY2UgKGluIHBpeGVscykgcmVxdWlyZWQgYnkgdGhlIG92ZXJsYXkuIFNldHRpbmcgYSB2YWx1ZSB0b1xuICAgICAgICAgKiB0aGUgcHJvcGVydHkgZWZmZWN0aXZlbHkgZGlzYWJsZXMgdGhlIGNvbnRlbnQgbWVhc3VyZW1lbnQgaW4gZmF2b3Igb2YgdXNpbmcgdGhpc1xuICAgICAgICAgKiBmaXhlZCB2YWx1ZSBmb3IgZGV0ZXJtaW5pbmcgdGhlIG9wZW4gZGlyZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAYXR0ciB7bnVtYmVyfSByZXF1aXJlZC12ZXJ0aWNhbC1zcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWlyZWRWZXJ0aWNhbFNwYWNlOiB7XG4gICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICdfX3Bvc2l0aW9uU2V0dGluZ3NDaGFuZ2VkKGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwgbm9Ib3Jpem9udGFsT3ZlcmxhcCwgbm9WZXJ0aWNhbE92ZXJsYXAsIHJlcXVpcmVkVmVydGljYWxTcGFjZSknLFxuICAgICAgICAnX19vdmVybGF5T3BlbmVkQ2hhbmdlZChvcGVuZWQsIHBvc2l0aW9uVGFyZ2V0KScsXG4gICAgICBdO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcblxuICAgICAgdGhpcy5fX29uU2Nyb2xsID0gdGhpcy5fX29uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbiA9IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLl9fYWRkVXBkYXRlUG9zaXRpb25FdmVudExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgdGhpcy5fX3JlbW92ZVVwZGF0ZVBvc2l0aW9uRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfX2FkZFVwZGF0ZVBvc2l0aW9uRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pO1xuXG4gICAgICB0aGlzLl9fcG9zaXRpb25UYXJnZXRBbmNlc3RvclJvb3ROb2RlcyA9IGdldEFuY2VzdG9yUm9vdE5vZGVzKHRoaXMucG9zaXRpb25UYXJnZXQpO1xuICAgICAgdGhpcy5fX3Bvc2l0aW9uVGFyZ2V0QW5jZXN0b3JSb290Tm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX19vblNjcm9sbCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfX3JlbW92ZVVwZGF0ZVBvc2l0aW9uRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pO1xuXG4gICAgICBpZiAodGhpcy5fX3Bvc2l0aW9uVGFyZ2V0QW5jZXN0b3JSb290Tm9kZXMpIHtcbiAgICAgICAgdGhpcy5fX3Bvc2l0aW9uVGFyZ2V0QW5jZXN0b3JSb290Tm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fX29uU2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX19wb3NpdGlvblRhcmdldEFuY2VzdG9yUm9vdE5vZGVzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBfX292ZXJsYXlPcGVuZWRDaGFuZ2VkKG9wZW5lZCwgcG9zaXRpb25UYXJnZXQpIHtcbiAgICAgIHRoaXMuX19yZW1vdmVVcGRhdGVQb3NpdGlvbkV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgIGlmIChwb3NpdGlvblRhcmdldCkge1xuICAgICAgICBwb3NpdGlvblRhcmdldC5fX292ZXJsYXkgPSBudWxsO1xuICAgICAgICB0YXJnZXRSZXNpemVPYnNlcnZlci51bm9ic2VydmUocG9zaXRpb25UYXJnZXQpO1xuXG4gICAgICAgIGlmIChvcGVuZWQpIHtcbiAgICAgICAgICB0aGlzLl9fYWRkVXBkYXRlUG9zaXRpb25FdmVudExpc3RlbmVycygpO1xuICAgICAgICAgIHBvc2l0aW9uVGFyZ2V0Ll9fb3ZlcmxheSA9IHRoaXM7XG4gICAgICAgICAgdGFyZ2V0UmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShwb3NpdGlvblRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wZW5lZCkge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLl9fbWFyZ2lucykge1xuICAgICAgICAgIHRoaXMuX19tYXJnaW5zID0ge307XG4gICAgICAgICAgWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXS5mb3JFYWNoKChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX21hcmdpbnNbcHJvcE5hbWVdID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVtwcm9wTmFtZV0sIDEwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlyJywgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIC8vIFNjaGVkdWxlIGFub3RoZXIgcG9zaXRpb24gdXBkYXRlICh0byBjb3ZlciB2aXJ0dWFsIGtleWJvYXJkIG9wZW5pbmcgZm9yIGV4YW1wbGUpXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLl91cGRhdGVQb3NpdGlvbigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgX19pc1JUTCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZGlyJykgPT09ICdydGwnO1xuICAgIH1cblxuICAgIF9fcG9zaXRpb25TZXR0aW5nc0NoYW5nZWQoKSB7XG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9fb25TY3JvbGwoZSkge1xuICAgICAgLy8gSWYgdGhlIHNjcm9sbCBldmVudCBvY2N1cnJlZCBpbnNpZGUgdGhlIG92ZXJsYXksIGlnbm9yZSBpdC5cbiAgICAgIGlmICghdGhpcy5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucG9zaXRpb25UYXJnZXQgfHwgIXRoaXMub3BlbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRoaXMucG9zaXRpb25UYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIERldGVjdCB0aGUgZGVzaXJlZCBhbGlnbm1lbnQgYW5kIHVwZGF0ZSB0aGUgbGF5b3V0IGFjY29yZGluZ2x5XG4gICAgICBjb25zdCBzaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSA9IHRoaXMuX19zaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSh0YXJnZXRSZWN0KTtcbiAgICAgIHRoaXMuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBzaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSA/ICdmbGV4LXN0YXJ0JyA6ICdmbGV4LWVuZCc7XG5cbiAgICAgIGNvbnN0IHNob3VsZEFsaWduU3RhcnRIb3Jpem9udGFsbHkgPSB0aGlzLl9fc2hvdWxkQWxpZ25TdGFydEhvcml6b250YWxseSh0YXJnZXRSZWN0LCB0aGlzLl9faXNSVEwpO1xuICAgICAgY29uc3QgZmxleFN0YXJ0ID1cbiAgICAgICAgKCF0aGlzLl9faXNSVEwgJiYgc2hvdWxkQWxpZ25TdGFydEhvcml6b250YWxseSkgfHwgKHRoaXMuX19pc1JUTCAmJiAhc2hvdWxkQWxpZ25TdGFydEhvcml6b250YWxseSk7XG4gICAgICB0aGlzLnN0eWxlLmFsaWduSXRlbXMgPSBmbGV4U3RhcnQgPyAnZmxleC1zdGFydCcgOiAnZmxleC1lbmQnO1xuXG4gICAgICAvLyBHZXQgdGhlIG92ZXJsYXkgcmVjdCBhZnRlciBwb3NzaWJsZSBvdmVybGF5IGFsaWdubWVudCBjaGFuZ2VzXG4gICAgICBjb25zdCBvdmVybGF5UmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIE9idGFpbiB2ZXJ0aWNhbCBwb3NpdGlvbmluZyBwcm9wZXJ0aWVzXG4gICAgICBjb25zdCB2ZXJ0aWNhbFByb3BzID0gdGhpcy5fX2NhbGN1bGF0ZVBvc2l0aW9uSW5PbmVEaW1lbnNpb24oXG4gICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgIG92ZXJsYXlSZWN0LFxuICAgICAgICB0aGlzLm5vVmVydGljYWxPdmVybGFwLFxuICAgICAgICBQUk9QX05BTUVTX1ZFUlRJQ0FMLFxuICAgICAgICB0aGlzLFxuICAgICAgICBzaG91bGRBbGlnblN0YXJ0VmVydGljYWxseSxcbiAgICAgICk7XG5cbiAgICAgIC8vIE9idGFpbiBob3Jpem9udGFsIHBvc2l0aW9uaW5nIHByb3BlcnRpZXNcbiAgICAgIGNvbnN0IGhvcml6b250YWxQcm9wcyA9IHRoaXMuX19jYWxjdWxhdGVQb3NpdGlvbkluT25lRGltZW5zaW9uKFxuICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICBvdmVybGF5UmVjdCxcbiAgICAgICAgdGhpcy5ub0hvcml6b250YWxPdmVybGFwLFxuICAgICAgICBQUk9QX05BTUVTX0hPUklaT05UQUwsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHNob3VsZEFsaWduU3RhcnRIb3Jpem9udGFsbHksXG4gICAgICApO1xuXG4gICAgICAvLyBBcHBseSB0aGUgcG9zaXRpb25pbmcgcHJvcGVydGllcyB0byB0aGUgb3ZlcmxheVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0eWxlLCB2ZXJ0aWNhbFByb3BzLCBob3Jpem9udGFsUHJvcHMpO1xuXG4gICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZSgnYm90dG9tLWFsaWduZWQnLCAhc2hvdWxkQWxpZ25TdGFydFZlcnRpY2FsbHkpO1xuICAgICAgdGhpcy50b2dnbGVBdHRyaWJ1dGUoJ3RvcC1hbGlnbmVkJywgc2hvdWxkQWxpZ25TdGFydFZlcnRpY2FsbHkpO1xuXG4gICAgICB0aGlzLnRvZ2dsZUF0dHJpYnV0ZSgnZW5kLWFsaWduZWQnLCAhZmxleFN0YXJ0KTtcbiAgICAgIHRoaXMudG9nZ2xlQXR0cmlidXRlKCdzdGFydC1hbGlnbmVkJywgZmxleFN0YXJ0KTtcbiAgICB9XG5cbiAgICBfX3Nob3VsZEFsaWduU3RhcnRIb3Jpem9udGFsbHkodGFyZ2V0UmVjdCwgcnRsKSB7XG4gICAgICAvLyBVc2luZyBwcmV2aW91cyBzaXplIHRvIGZpeCBhIGNhc2Ugd2hlcmUgd2luZG93IHJlc2l6ZSBtYXkgY2F1c2UgdGhlIG92ZXJsYXkgdG8gYmUgc3F1ZWV6ZWRcbiAgICAgIC8vIHNtYWxsZXIgdGhhbiBpdHMgY3VycmVudCBzcGFjZSBiZWZvcmUgdGhlIGZpdC1jYWxjdWxhdGlvbnMuXG4gICAgICBjb25zdCBjb250ZW50V2lkdGggPSBNYXRoLm1heCh0aGlzLl9fb2xkQ29udGVudFdpZHRoIHx8IDAsIHRoaXMuJC5vdmVybGF5Lm9mZnNldFdpZHRoKTtcbiAgICAgIHRoaXMuX19vbGRDb250ZW50V2lkdGggPSB0aGlzLiQub3ZlcmxheS5vZmZzZXRXaWR0aDtcblxuICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgICAgY29uc3QgZGVmYXVsdEFsaWduTGVmdCA9ICghcnRsICYmIHRoaXMuaG9yaXpvbnRhbEFsaWduID09PSAnc3RhcnQnKSB8fCAocnRsICYmIHRoaXMuaG9yaXpvbnRhbEFsaWduID09PSAnZW5kJyk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc2hvdWxkQWxpZ25TdGFydChcbiAgICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgICAgY29udGVudFdpZHRoLFxuICAgICAgICB2aWV3cG9ydFdpZHRoLFxuICAgICAgICB0aGlzLl9fbWFyZ2lucyxcbiAgICAgICAgZGVmYXVsdEFsaWduTGVmdCxcbiAgICAgICAgdGhpcy5ub0hvcml6b250YWxPdmVybGFwLFxuICAgICAgICBQUk9QX05BTUVTX0hPUklaT05UQUwsXG4gICAgICApO1xuICAgIH1cblxuICAgIF9fc2hvdWxkQWxpZ25TdGFydFZlcnRpY2FsbHkodGFyZ2V0UmVjdCkge1xuICAgICAgLy8gVXNpbmcgcHJldmlvdXMgc2l6ZSB0byBmaXggYSBjYXNlIHdoZXJlIHdpbmRvdyByZXNpemUgbWF5IGNhdXNlIHRoZSBvdmVybGF5IHRvIGJlIHNxdWVlemVkXG4gICAgICAvLyBzbWFsbGVyIHRoYW4gaXRzIGN1cnJlbnQgc3BhY2UgYmVmb3JlIHRoZSBmaXQtY2FsY3VsYXRpb25zLlxuICAgICAgY29uc3QgY29udGVudEhlaWdodCA9XG4gICAgICAgIHRoaXMucmVxdWlyZWRWZXJ0aWNhbFNwYWNlIHx8IE1hdGgubWF4KHRoaXMuX19vbGRDb250ZW50SGVpZ2h0IHx8IDAsIHRoaXMuJC5vdmVybGF5Lm9mZnNldEhlaWdodCk7XG4gICAgICB0aGlzLl9fb2xkQ29udGVudEhlaWdodCA9IHRoaXMuJC5vdmVybGF5Lm9mZnNldEhlaWdodDtcblxuICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgY29uc3QgZGVmYXVsdEFsaWduVG9wID0gdGhpcy52ZXJ0aWNhbEFsaWduID09PSAndG9wJztcblxuICAgICAgcmV0dXJuIHRoaXMuX19zaG91bGRBbGlnblN0YXJ0KFxuICAgICAgICB0YXJnZXRSZWN0LFxuICAgICAgICBjb250ZW50SGVpZ2h0LFxuICAgICAgICB2aWV3cG9ydEhlaWdodCxcbiAgICAgICAgdGhpcy5fX21hcmdpbnMsXG4gICAgICAgIGRlZmF1bHRBbGlnblRvcCxcbiAgICAgICAgdGhpcy5ub1ZlcnRpY2FsT3ZlcmxhcCxcbiAgICAgICAgUFJPUF9OQU1FU19WRVJUSUNBTCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgICBfX3Nob3VsZEFsaWduU3RhcnQodGFyZ2V0UmVjdCwgY29udGVudFNpemUsIHZpZXdwb3J0U2l6ZSwgbWFyZ2lucywgZGVmYXVsdEFsaWduU3RhcnQsIG5vT3ZlcmxhcCwgcHJvcE5hbWVzKSB7XG4gICAgICBjb25zdCBzcGFjZUZvclN0YXJ0QWxpZ25tZW50ID1cbiAgICAgICAgdmlld3BvcnRTaXplIC0gdGFyZ2V0UmVjdFtub092ZXJsYXAgPyBwcm9wTmFtZXMuZW5kIDogcHJvcE5hbWVzLnN0YXJ0XSAtIG1hcmdpbnNbcHJvcE5hbWVzLmVuZF07XG4gICAgICBjb25zdCBzcGFjZUZvckVuZEFsaWdubWVudCA9IHRhcmdldFJlY3Rbbm9PdmVybGFwID8gcHJvcE5hbWVzLnN0YXJ0IDogcHJvcE5hbWVzLmVuZF0gLSBtYXJnaW5zW3Byb3BOYW1lcy5zdGFydF07XG5cbiAgICAgIGNvbnN0IHNwYWNlRm9yRGVmYXVsdEFsaWdubWVudCA9IGRlZmF1bHRBbGlnblN0YXJ0ID8gc3BhY2VGb3JTdGFydEFsaWdubWVudCA6IHNwYWNlRm9yRW5kQWxpZ25tZW50O1xuICAgICAgY29uc3Qgc3BhY2VGb3JPdGhlckFsaWdubWVudCA9IGRlZmF1bHRBbGlnblN0YXJ0ID8gc3BhY2VGb3JFbmRBbGlnbm1lbnQgOiBzcGFjZUZvclN0YXJ0QWxpZ25tZW50O1xuXG4gICAgICBjb25zdCBzaG91bGRHb1RvRGVmYXVsdFNpZGUgPVxuICAgICAgICBzcGFjZUZvckRlZmF1bHRBbGlnbm1lbnQgPiBzcGFjZUZvck90aGVyQWxpZ25tZW50IHx8IHNwYWNlRm9yRGVmYXVsdEFsaWdubWVudCA+IGNvbnRlbnRTaXplO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdEFsaWduU3RhcnQgPT09IHNob3VsZEdvVG9EZWZhdWx0U2lkZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFkanVzdGVkIHZhbHVlIGFmdGVyIHJlc2l6aW5nIHRoZSBicm93c2VyIHdpbmRvdyxcbiAgICAgKiB0byBhdm9pZCB3cm9uZyBjYWxjdWxhdGlvbnMgd2hlbiBlLmcuIHByZXZpb3VzbHkgc2V0IGBib3R0b21gXG4gICAgICogQ1NTIHByb3BlcnR5IHZhbHVlIGlzIGxhcmdlciB0aGFuIHRoZSB1cGRhdGVkIHZpZXdwb3J0IGhlaWdodC5cbiAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZhYWRpbi93ZWItY29tcG9uZW50cy9pc3N1ZXMvNDYwNFxuICAgICAqL1xuICAgIF9fYWRqdXN0Qm90dG9tUHJvcGVydHkoY3NzUHJvcE5hbWVUb1NldCwgcHJvcE5hbWVzLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgIGxldCBhZGp1c3RlZFByb3A7XG5cbiAgICAgIGlmIChjc3NQcm9wTmFtZVRvU2V0ID09PSBwcm9wTmFtZXMuZW5kKSB7XG4gICAgICAgIC8vIEFkanVzdCBob3Jpem9udGFsbHlcbiAgICAgICAgaWYgKHByb3BOYW1lcy5lbmQgPT09IFBST1BfTkFNRVNfVkVSVElDQUwuZW5kKSB7XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+IHZpZXdwb3J0SGVpZ2h0ICYmIHRoaXMuX19vbGRWaWV3cG9ydEhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0RGlmZiA9IHRoaXMuX19vbGRWaWV3cG9ydEhlaWdodCAtIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgICAgICAgYWRqdXN0ZWRQcm9wID0gY3VycmVudFZhbHVlIC0gaGVpZ2h0RGlmZjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fb2xkVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkanVzdCB2ZXJ0aWNhbGx5XG4gICAgICAgIGlmIChwcm9wTmFtZXMuZW5kID09PSBQUk9QX05BTUVTX0hPUklaT05UQUwuZW5kKSB7XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+IHZpZXdwb3J0V2lkdGggJiYgdGhpcy5fX29sZFZpZXdwb3J0V2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoRGlmZiA9IHRoaXMuX19vbGRWaWV3cG9ydFdpZHRoIC0gdmlld3BvcnRXaWR0aDtcbiAgICAgICAgICAgIGFkanVzdGVkUHJvcCA9IGN1cnJlbnRWYWx1ZSAtIHdpZHRoRGlmZjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fb2xkVmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0V2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkanVzdGVkUHJvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIENTUyBwb3NpdGlvbiBwcm9wZXJ0aWVzIHRvIHNldCxcbiAgICAgKiBlLmcuIHsgdG9wOiBcIjEwMHB4XCIgfVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG4gICAgX19jYWxjdWxhdGVQb3NpdGlvbkluT25lRGltZW5zaW9uKHRhcmdldFJlY3QsIG92ZXJsYXlSZWN0LCBub092ZXJsYXAsIHByb3BOYW1lcywgb3ZlcmxheSwgc2hvdWxkQWxpZ25TdGFydCkge1xuICAgICAgY29uc3QgY3NzUHJvcE5hbWVUb1NldCA9IHNob3VsZEFsaWduU3RhcnQgPyBwcm9wTmFtZXMuc3RhcnQgOiBwcm9wTmFtZXMuZW5kO1xuICAgICAgY29uc3QgY3NzUHJvcE5hbWVUb0NsZWFyID0gc2hvdWxkQWxpZ25TdGFydCA/IHByb3BOYW1lcy5lbmQgOiBwcm9wTmFtZXMuc3RhcnQ7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQob3ZlcmxheS5zdHlsZVtjc3NQcm9wTmFtZVRvU2V0XSB8fCBnZXRDb21wdXRlZFN0eWxlKG92ZXJsYXkpW2Nzc1Byb3BOYW1lVG9TZXRdKTtcbiAgICAgIGNvbnN0IGFkanVzdGVkVmFsdWUgPSB0aGlzLl9fYWRqdXN0Qm90dG9tUHJvcGVydHkoY3NzUHJvcE5hbWVUb1NldCwgcHJvcE5hbWVzLCBjdXJyZW50VmFsdWUpO1xuXG4gICAgICBjb25zdCBkaWZmID1cbiAgICAgICAgb3ZlcmxheVJlY3Rbc2hvdWxkQWxpZ25TdGFydCA/IHByb3BOYW1lcy5zdGFydCA6IHByb3BOYW1lcy5lbmRdIC1cbiAgICAgICAgdGFyZ2V0UmVjdFtub092ZXJsYXAgPT09IHNob3VsZEFsaWduU3RhcnQgPyBwcm9wTmFtZXMuZW5kIDogcHJvcE5hbWVzLnN0YXJ0XTtcblxuICAgICAgY29uc3QgdmFsdWVUb1NldCA9IGFkanVzdGVkVmFsdWVcbiAgICAgICAgPyBgJHthZGp1c3RlZFZhbHVlfXB4YFxuICAgICAgICA6IGAke2N1cnJlbnRWYWx1ZSArIGRpZmYgKiAoc2hvdWxkQWxpZ25TdGFydCA/IC0xIDogMSl9cHhgO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBbY3NzUHJvcE5hbWVUb1NldF06IHZhbHVlVG9TZXQsXG4gICAgICAgIFtjc3NQcm9wTmFtZVRvQ2xlYXJdOiAnJyxcbiAgICAgIH07XG4gICAgfVxuICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/src/vaadin-overlay-position-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/src/vaadin-overlay.js":
/*!************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/src/vaadin-overlay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Overlay\": () => (/* binding */ Overlay)\n/* harmony export */ });\n/* harmony import */ var _polymer_polymer_lib_utils_flattened_nodes_observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/flattened-nodes-observer.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/flattened-nodes-observer.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/lib/utils/render-status.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/render-status.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_templatize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/utils/templatize.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/lib/utils/templatize.js\");\n/* harmony import */ var _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/polymer-element.js */ \"./node_modules/@vaadin/overlay/node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @vaadin/component-base/src/browser-utils.js */ \"./node_modules/@vaadin/component-base/src/browser-utils.js\");\n/* harmony import */ var _vaadin_component_base_src_controller_mixin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @vaadin/component-base/src/controller-mixin.js */ \"./node_modules/@vaadin/component-base/src/controller-mixin.js\");\n/* harmony import */ var _vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @vaadin/component-base/src/dir-mixin.js */ \"./node_modules/@vaadin/component-base/src/dir-mixin.js\");\n/* harmony import */ var _vaadin_component_base_src_focus_trap_controller_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @vaadin/component-base/src/focus-trap-controller.js */ \"./node_modules/@vaadin/component-base/src/focus-trap-controller.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n\n\n\n\n\n\n/**\n *\n * `<vaadin-overlay>` is a Web Component for creating overlays. The content of the overlay\n * can be populated in two ways: imperatively by using renderer callback function and\n * declaratively by using Polymer's Templates.\n *\n * ### Rendering\n *\n * By default, the overlay uses the content provided by using the renderer callback function.\n *\n * The renderer function provides `root`, `owner`, `model` arguments when applicable.\n * Generate DOM content by using `model` object properties if needed, append it to the `root`\n * element and control the state of the host element by accessing `owner`. Before generating new\n * content, users are able to check if there is already content in `root` for reusing it.\n *\n * ```html\n * <vaadin-overlay id=\"overlay\"></vaadin-overlay>\n * ```\n * ```js\n * const overlay = document.querySelector('#overlay');\n * overlay.renderer = function(root) {\n *  root.textContent = \"Overlay content\";\n * };\n * ```\n *\n * Renderer is called on the opening of the overlay and each time the related model is updated.\n * DOM generated during the renderer call can be reused\n * in the next renderer call and will be provided with the `root` argument.\n * On first call it will be empty.\n *\n * **NOTE:** when the renderer property is defined, the `<template>` content is not used.\n *\n * ### Templating\n *\n * Alternatively, the content can be provided with Polymer Template.\n * Overlay finds the first child template and uses that in case renderer callback function\n * is not provided. You can also set a custom template using the `template` property.\n *\n * After the content from the template is stamped, the `content` property\n * points to the content container.\n *\n * The overlay provides `forwardHostProp` when calling\n * `Polymer.Templatize.templatize` for the template, so that the bindings\n * from the parent scope propagate to the content.\n *\n * ### Styling\n *\n * To style the overlay content, use styles in the parent scope:\n *\n * - If the overlay is used in a component, then the component styles\n *   apply the overlay content.\n * - If the overlay is used in the global DOM scope, then global styles\n *   apply to the overlay content.\n *\n * See examples for styling the overlay content in the live demos.\n *\n * The following Shadow DOM parts are available for styling the overlay component itself:\n *\n * Part name  | Description\n * -----------|---------------------------------------------------------|\n * `backdrop` | Backdrop of the overlay\n * `overlay`  | Container for position/sizing/alignment of the content\n * `content`  | Content of the overlay\n *\n * The following state attributes are available for styling:\n *\n * Attribute | Description | Part\n * ---|---|---\n * `opening` | Applied just after the overlay is attached to the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n * `closing` | Applied just before the overlay is detached from the DOM. You can apply a CSS @keyframe animation for this state. | `:host`\n *\n * The following custom CSS properties are available for styling:\n *\n * Custom CSS property | Description | Default value\n * ---|---|---\n * `--vaadin-overlay-viewport-bottom` | Bottom offset of the visible viewport area | `0` or detected offset\n *\n * See [Styling Components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components) documentation.\n *\n * @fires {CustomEvent} opened-changed - Fired when the `opened` property changes.\n * @fires {CustomEvent} vaadin-overlay-open - Fired after the overlay is opened.\n * @fires {CustomEvent} vaadin-overlay-close - Fired before the overlay will be closed. If canceled the closing of the overlay is canceled as well.\n * @fires {CustomEvent} vaadin-overlay-closing - Fired when the overlay will be closed.\n * @fires {CustomEvent} vaadin-overlay-outside-click - Fired before the overlay will be closed on outside click. If canceled the closing of the overlay is canceled as well.\n * @fires {CustomEvent} vaadin-overlay-escape-press - Fired before the overlay will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.\n *\n * @extends HTMLElement\n * @mixes ThemableMixin\n * @mixes DirMixin\n * @mixes ControllerMixin\n */\nclass Overlay extends (0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_8__.ThemableMixin)((0,_vaadin_component_base_src_dir_mixin_js__WEBPACK_IMPORTED_MODULE_6__.DirMixin)((0,_vaadin_component_base_src_controller_mixin_js__WEBPACK_IMPORTED_MODULE_5__.ControllerMixin)(_polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__.PolymerElement))) {\n  static get template() {\n    return _polymer_polymer_polymer_element_js__WEBPACK_IMPORTED_MODULE_3__.html`\n      <style>\n        :host {\n          z-index: 200;\n          position: fixed;\n\n          /* Despite of what the names say, <vaadin-overlay> is just a container\n          for position/sizing/alignment. The actual overlay is the overlay part. */\n\n          /* Default position constraints: the entire viewport. Note: themes can\n          override this to introduce gaps between the overlay and the viewport. */\n          top: 0;\n          right: 0;\n          bottom: var(--vaadin-overlay-viewport-bottom);\n          left: 0;\n\n          /* Use flexbox alignment for the overlay part. */\n          display: flex;\n          flex-direction: column; /* makes dropdowns sizing easier */\n          /* Align to center by default. */\n          align-items: center;\n          justify-content: center;\n\n          /* Allow centering when max-width/max-height applies. */\n          margin: auto;\n\n          /* The host is not clickable, only the overlay part is. */\n          pointer-events: none;\n\n          /* Remove tap highlight on touch devices. */\n          -webkit-tap-highlight-color: transparent;\n\n          /* CSS API for host */\n          --vaadin-overlay-viewport-bottom: 0;\n        }\n\n        :host([hidden]),\n        :host(:not([opened]):not([closing])) {\n          display: none !important;\n        }\n\n        [part='overlay'] {\n          -webkit-overflow-scrolling: touch;\n          overflow: auto;\n          pointer-events: auto;\n\n          /* Prevent overflowing the host in MSIE 11 */\n          max-width: 100%;\n          box-sizing: border-box;\n\n          -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */\n        }\n\n        [part='backdrop'] {\n          z-index: -1;\n          content: '';\n          background: rgba(0, 0, 0, 0.5);\n          position: fixed;\n          top: 0;\n          left: 0;\n          bottom: 0;\n          right: 0;\n          pointer-events: auto;\n        }\n      </style>\n\n      <div id=\"backdrop\" part=\"backdrop\" hidden$=\"[[!withBackdrop]]\"></div>\n      <div part=\"overlay\" id=\"overlay\" tabindex=\"0\">\n        <div part=\"content\" id=\"content\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n  }\n  static get is() {\n    return 'vaadin-overlay';\n  }\n  static get properties() {\n    return {\n      /**\n       * When true, the overlay is visible and attached to body.\n       */\n      opened: {\n        type: Boolean,\n        notify: true,\n        observer: '_openedChanged',\n        reflectToAttribute: true\n      },\n      /**\n       * Owner element passed with renderer function\n       * @type {HTMLElement}\n       */\n      owner: Element,\n      /**\n       * Custom function for rendering the content of the overlay.\n       * Receives three arguments:\n       *\n       * - `root` The root container DOM element. Append your content to it.\n       * - `owner` The host element of the renderer function.\n       * - `model` The object with the properties related with rendering.\n       * @type {OverlayRenderer | null | undefined}\n       */\n      renderer: Function,\n      /**\n       * The template of the overlay content.\n       * @type {HTMLTemplateElement | null | undefined}\n       */\n      template: {\n        type: Object,\n        notify: true\n      },\n      /**\n       * References the content container after the template is stamped.\n       * @type {!HTMLElement | undefined}\n       */\n      content: {\n        type: Object,\n        notify: true\n      },\n      /**\n       * When true the overlay has backdrop on top of content when opened.\n       * @type {boolean}\n       */\n      withBackdrop: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * Object with properties that is passed to `renderer` function\n       */\n      model: Object,\n      /**\n       * When true the overlay won't disable the main content, showing\n       * it doesnt change the functionality of the user interface.\n       * @type {boolean}\n       */\n      modeless: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true,\n        observer: '_modelessChanged'\n      },\n      /**\n       * When set to true, the overlay is hidden. This also closes the overlay\n       * immediately in case there is a closing animation in progress.\n       * @type {boolean}\n       */\n      hidden: {\n        type: Boolean,\n        reflectToAttribute: true,\n        observer: '_hiddenChanged'\n      },\n      /**\n       * When true move focus to the first focusable element in the overlay,\n       * or to the overlay if there are no focusable elements.\n       * @type {boolean}\n       */\n      focusTrap: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * Set to true to enable restoring of focus when overlay is closed.\n       * @type {boolean}\n       */\n      restoreFocusOnClose: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * Set to specify the element which should be focused on overlay close,\n       * if `restoreFocusOnClose` is set to true.\n       * @type {HTMLElement}\n       */\n      restoreFocusNode: {\n        type: HTMLElement\n      },\n      /** @private */\n      _mouseDownInside: {\n        type: Boolean\n      },\n      /** @private */\n      _mouseUpInside: {\n        type: Boolean\n      },\n      /** @private */\n      _instance: {\n        type: Object\n      },\n      /** @private */\n      _originalContentPart: Object,\n      /** @private */\n      _contentNodes: Array,\n      /** @private */\n      _oldOwner: Element,\n      /** @private */\n      _oldModel: Object,\n      /** @private */\n      _oldTemplate: Object,\n      /** @private */\n      _oldRenderer: Object,\n      /** @private */\n      _oldOpened: Boolean\n    };\n  }\n  static get observers() {\n    return ['_templateOrRendererChanged(template, renderer, owner, model, opened)'];\n  }\n  constructor() {\n    super();\n    this._boundMouseDownListener = this._mouseDownListener.bind(this);\n    this._boundMouseUpListener = this._mouseUpListener.bind(this);\n    this._boundOutsideClickListener = this._outsideClickListener.bind(this);\n    this._boundKeydownListener = this._keydownListener.bind(this);\n    this._observer = new _polymer_polymer_lib_utils_flattened_nodes_observer_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedNodesObserver(this, info => {\n      this._setTemplateFromNodes(info.addedNodes);\n    });\n\n    // Listener for preventing closing of the paper-dialog and all components extending `iron-overlay-behavior`.\n    this._boundIronOverlayCanceledListener = this._ironOverlayCanceled.bind(this);\n\n    /* c8 ignore next 3 */\n    if (_vaadin_component_base_src_browser_utils_js__WEBPACK_IMPORTED_MODULE_4__.isIOS) {\n      this._boundIosResizeListener = () => this._detectIosNavbar();\n    }\n    this.__focusTrapController = new _vaadin_component_base_src_focus_trap_controller_js__WEBPACK_IMPORTED_MODULE_7__.FocusTrapController(this);\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this._observer.flush();\n\n    // Need to add dummy click listeners to this and the backdrop or else\n    // the document click event listener (_outsideClickListener) may never\n    // get invoked on iOS Safari (reproducible in <vaadin-dialog>\n    // and <vaadin-context-menu>).\n    this.addEventListener('click', () => {});\n    this.$.backdrop.addEventListener('click', () => {});\n    this.addController(this.__focusTrapController);\n  }\n\n  /** @private */\n  _detectIosNavbar() {\n    /* c8 ignore next 15 */\n    if (!this.opened) {\n      return;\n    }\n    const innerHeight = window.innerHeight;\n    const innerWidth = window.innerWidth;\n    const landscape = innerWidth > innerHeight;\n    const clientHeight = document.documentElement.clientHeight;\n    if (landscape && clientHeight > innerHeight) {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', `${clientHeight - innerHeight}px`);\n    } else {\n      this.style.setProperty('--vaadin-overlay-viewport-bottom', '0');\n    }\n  }\n\n  /**\n   * @param {!Array<!Element>} nodes\n   * @protected\n   */\n  _setTemplateFromNodes(nodes) {\n    this.template = nodes.find(node => node.localName && node.localName === 'template') || this.template;\n  }\n\n  /**\n   * @param {Event=} sourceEvent\n   * @event vaadin-overlay-close\n   * fired before the `vaadin-overlay` will be closed. If canceled the closing of the overlay is canceled as well.\n   */\n  close(sourceEvent) {\n    const evt = new CustomEvent('vaadin-overlay-close', {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        sourceEvent\n      }\n    });\n    this.dispatchEvent(evt);\n    if (!evt.defaultPrevented) {\n      this.opened = false;\n    }\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n\n    /* c8 ignore next 3 */\n    if (this._boundIosResizeListener) {\n      this._detectIosNavbar();\n      window.addEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    /* c8 ignore next 3 */\n    if (this._boundIosResizeListener) {\n      window.removeEventListener('resize', this._boundIosResizeListener);\n    }\n  }\n\n  /**\n   * Requests an update for the content of the overlay.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (this.renderer) {\n      this.renderer.call(this.owner, this.content, this.owner, this.model);\n    }\n  }\n\n  /** @private */\n  _ironOverlayCanceled(event) {\n    event.preventDefault();\n  }\n\n  /** @private */\n  _mouseDownListener(event) {\n    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n\n  /** @private */\n  _mouseUpListener(event) {\n    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;\n  }\n\n  /**\n   * We need to listen on 'click' / 'tap' event and capture it and close the overlay before\n   * propagating the event to the listener in the button. Otherwise, if the clicked button would call\n   * open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4\n   *\n   * @event vaadin-overlay-outside-click\n   * fired before the `vaadin-overlay` will be closed on outside click. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n  _outsideClickListener(event) {\n    if (event.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {\n      this._mouseDownInside = false;\n      this._mouseUpInside = false;\n      return;\n    }\n    if (!this._last) {\n      return;\n    }\n    const evt = new CustomEvent('vaadin-overlay-outside-click', {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        sourceEvent: event\n      }\n    });\n    this.dispatchEvent(evt);\n    if (this.opened && !evt.defaultPrevented) {\n      this.close(event);\n    }\n  }\n\n  /**\n   * @event vaadin-overlay-escape-press\n   * fired before the `vaadin-overlay` will be closed on ESC button press. If canceled the closing of the overlay is canceled as well.\n   *\n   * @private\n   */\n  _keydownListener(event) {\n    if (!this._last) {\n      return;\n    }\n\n    // Only close modeless overlay on Esc press when it contains focus\n    if (this.modeless && !event.composedPath().includes(this.$.overlay)) {\n      return;\n    }\n    if (event.key === 'Escape') {\n      const evt = new CustomEvent('vaadin-overlay-escape-press', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          sourceEvent: event\n        }\n      });\n      this.dispatchEvent(evt);\n      if (this.opened && !evt.defaultPrevented) {\n        this.close(event);\n      }\n    }\n  }\n\n  /** @protected */\n  _ensureTemplatized() {\n    this._setTemplateFromNodes(Array.from(this.children));\n  }\n\n  /**\n   * @event vaadin-overlay-open\n   * fired after the `vaadin-overlay` is opened.\n   *\n   * @private\n   */\n  _openedChanged(opened, wasOpened) {\n    if (!this._instance) {\n      this._ensureTemplatized();\n    }\n    if (opened) {\n      // Store focused node.\n      this.__restoreFocusNode = this._getActiveElement();\n      this._animatedOpening();\n      (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_1__.afterNextRender)(this, () => {\n        if (this.focusTrap) {\n          this.__focusTrapController.trapFocus(this.$.overlay);\n        }\n        const evt = new CustomEvent('vaadin-overlay-open', {\n          bubbles: true\n        });\n        this.dispatchEvent(evt);\n      });\n      document.addEventListener('keydown', this._boundKeydownListener);\n      if (!this.modeless) {\n        this._addGlobalListeners();\n      }\n    } else if (wasOpened) {\n      if (this.focusTrap) {\n        this.__focusTrapController.releaseFocus();\n      }\n      this._animatedClosing();\n      document.removeEventListener('keydown', this._boundKeydownListener);\n      if (!this.modeless) {\n        this._removeGlobalListeners();\n      }\n    }\n  }\n\n  /** @private */\n  _hiddenChanged(hidden) {\n    if (hidden && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n  }\n\n  /**\n   * @return {boolean}\n   * @protected\n   */\n  _shouldAnimate() {\n    const name = getComputedStyle(this).getPropertyValue('animation-name');\n    const hidden = getComputedStyle(this).getPropertyValue('display') === 'none';\n    return !hidden && name && name !== 'none';\n  }\n\n  /**\n   * @param {string} type\n   * @param {Function} callback\n   * @protected\n   */\n  _enqueueAnimation(type, callback) {\n    const handler = `__${type}Handler`;\n    const listener = event => {\n      if (event && event.target !== this) {\n        return;\n      }\n      callback();\n      this.removeEventListener('animationend', listener);\n      delete this[handler];\n    };\n    this[handler] = listener;\n    this.addEventListener('animationend', listener);\n  }\n\n  /**\n   * @param {string} type\n   * @protected\n   */\n  _flushAnimation(type) {\n    const handler = `__${type}Handler`;\n    if (typeof this[handler] === 'function') {\n      this[handler]();\n    }\n  }\n\n  /** @protected */\n  _animatedOpening() {\n    if (this.parentNode === document.body && this.hasAttribute('closing')) {\n      this._flushAnimation('closing');\n    }\n    this._attachOverlay();\n    if (!this.modeless) {\n      this._enterModalState();\n    }\n    this.setAttribute('opening', '');\n    if (this._shouldAnimate()) {\n      this._enqueueAnimation('opening', () => {\n        this._finishOpening();\n      });\n    } else {\n      this._finishOpening();\n    }\n  }\n\n  /** @protected */\n  _attachOverlay() {\n    this._placeholder = document.createComment('vaadin-overlay-placeholder');\n    this.parentNode.insertBefore(this._placeholder, this);\n    document.body.appendChild(this);\n    this.bringToFront();\n  }\n\n  /** @protected */\n  _finishOpening() {\n    document.addEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n    this.removeAttribute('opening');\n  }\n\n  /** @protected */\n  _finishClosing() {\n    document.removeEventListener('iron-overlay-canceled', this._boundIronOverlayCanceledListener);\n    this._detachOverlay();\n    this.$.overlay.style.removeProperty('pointer-events');\n    this.removeAttribute('closing');\n  }\n\n  /**\n   * @event vaadin-overlay-closing\n   * Fired when the overlay will be closed.\n   *\n   * @protected\n   */\n  _animatedClosing() {\n    if (this.hasAttribute('opening')) {\n      this._flushAnimation('opening');\n    }\n    if (this._placeholder) {\n      this._exitModalState();\n\n      // Use this.restoreFocusNode if specified, otherwise fallback to the node\n      // which was focused before opening the overlay.\n      const restoreFocusNode = this.restoreFocusNode || this.__restoreFocusNode;\n      if (this.restoreFocusOnClose && restoreFocusNode) {\n        // If the activeElement is `<body>` or inside the overlay,\n        // we are allowed to restore the focus. In all the other\n        // cases focus might have been moved elsewhere by another\n        // component or by the user interaction (e.g. click on a\n        // button outside the overlay).\n        const activeElement = this._getActiveElement();\n        if (activeElement === document.body || this._deepContains(activeElement)) {\n          // Focusing the restoreFocusNode doesn't always work synchronously on Firefox and Safari\n          // (e.g. combo-box overlay close on outside click).\n          setTimeout(() => restoreFocusNode.focus());\n        }\n        this.__restoreFocusNode = null;\n      }\n      this.setAttribute('closing', '');\n      this.dispatchEvent(new CustomEvent('vaadin-overlay-closing'));\n      if (this._shouldAnimate()) {\n        this._enqueueAnimation('closing', () => {\n          this._finishClosing();\n        });\n      } else {\n        this._finishClosing();\n      }\n    }\n  }\n\n  /** @protected */\n  _detachOverlay() {\n    this._placeholder.parentNode.insertBefore(this, this._placeholder);\n    this._placeholder.parentNode.removeChild(this._placeholder);\n  }\n\n  /**\n   * Returns all attached overlays in visual stacking order.\n   * @private\n   */\n  static get __attachedInstances() {\n    return Array.from(document.body.children).filter(el => el instanceof Overlay && !el.hasAttribute('closing')).sort((a, b) => a.__zIndex - b.__zIndex || 0);\n  }\n\n  /**\n   * Returns true if this is the last one in the opened overlays stack\n   * @return {boolean}\n   * @protected\n   */\n  get _last() {\n    return this === Overlay.__attachedInstances.pop();\n  }\n\n  /** @private */\n  _modelessChanged(modeless) {\n    if (!modeless) {\n      if (this.opened) {\n        this._addGlobalListeners();\n        this._enterModalState();\n      }\n    } else {\n      this._removeGlobalListeners();\n      this._exitModalState();\n    }\n  }\n\n  /** @protected */\n  _addGlobalListeners() {\n    document.addEventListener('mousedown', this._boundMouseDownListener);\n    document.addEventListener('mouseup', this._boundMouseUpListener);\n    // Firefox leaks click to document on contextmenu even if prevented\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=990614\n    document.documentElement.addEventListener('click', this._boundOutsideClickListener, true);\n  }\n\n  /** @protected */\n  _enterModalState() {\n    if (document.body.style.pointerEvents !== 'none') {\n      // Set body pointer-events to 'none' to disable mouse interactions with\n      // other document nodes.\n      this._previousDocumentPointerEvents = document.body.style.pointerEvents;\n      document.body.style.pointerEvents = 'none';\n    }\n\n    // Disable pointer events in other attached overlays\n    Overlay.__attachedInstances.forEach(el => {\n      if (el !== this) {\n        el.shadowRoot.querySelector('[part=\"overlay\"]').style.pointerEvents = 'none';\n      }\n    });\n  }\n\n  /** @protected */\n  _removeGlobalListeners() {\n    document.removeEventListener('mousedown', this._boundMouseDownListener);\n    document.removeEventListener('mouseup', this._boundMouseUpListener);\n    document.documentElement.removeEventListener('click', this._boundOutsideClickListener, true);\n  }\n\n  /** @protected */\n  _exitModalState() {\n    if (this._previousDocumentPointerEvents !== undefined) {\n      // Restore body pointer-events\n      document.body.style.pointerEvents = this._previousDocumentPointerEvents;\n      delete this._previousDocumentPointerEvents;\n    }\n\n    // Restore pointer events in the previous overlay(s)\n    const instances = Overlay.__attachedInstances;\n    let el;\n    // Use instances.pop() to ensure the reverse order\n    while (el = instances.pop()) {\n      if (el === this) {\n        // Skip the current instance\n        continue;\n      }\n      el.shadowRoot.querySelector('[part=\"overlay\"]').style.removeProperty('pointer-events');\n      if (!el.modeless) {\n        // Stop after the last modal\n        break;\n      }\n    }\n  }\n\n  /** @protected */\n  _removeOldContent() {\n    if (!this.content || !this._contentNodes) {\n      return;\n    }\n    this._observer.disconnect();\n    this._contentNodes.forEach(node => {\n      if (node.parentNode === this.content) {\n        this.content.removeChild(node);\n      }\n    });\n    if (this._originalContentPart) {\n      // Restore the original <div part=\"content\">\n      this.$.content.parentNode.replaceChild(this._originalContentPart, this.$.content);\n      this.$.content = this._originalContentPart;\n      this._originalContentPart = undefined;\n    }\n    this._observer.connect();\n    this._contentNodes = undefined;\n    this.content = undefined;\n  }\n\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @protected\n   */\n  _stampOverlayTemplate(template) {\n    this._removeOldContent();\n    if (!template._Templatizer) {\n      template._Templatizer = (0,_polymer_polymer_lib_utils_templatize_js__WEBPACK_IMPORTED_MODULE_2__.templatize)(template, this, {\n        forwardHostProp(prop, value) {\n          if (this._instance) {\n            this._instance.forwardHostProp(prop, value);\n          }\n        }\n      });\n    }\n    this._instance = new template._Templatizer({});\n    this._contentNodes = Array.from(this._instance.root.childNodes);\n    const templateRoot = template._templateRoot || (template._templateRoot = template.getRootNode());\n    if (templateRoot !== document) {\n      if (!this.$.content.shadowRoot) {\n        this.$.content.attachShadow({\n          mode: 'open'\n        });\n      }\n      let scopeCssText = Array.from(templateRoot.querySelectorAll('style')).reduce((result, style) => result + style.textContent, '');\n\n      // The overlay roots :host styles should not apply inside the overlay\n      scopeCssText = scopeCssText.replace(/:host/g, ':host-nomatch');\n      if (scopeCssText) {\n        // Append a style to the content shadowRoot\n        const style = document.createElement('style');\n        style.textContent = scopeCssText;\n        this.$.content.shadowRoot.appendChild(style);\n        this._contentNodes.unshift(style);\n      }\n      this.$.content.shadowRoot.appendChild(this._instance.root);\n      this.content = this.$.content.shadowRoot;\n    } else {\n      this.appendChild(this._instance.root);\n      this.content = this;\n    }\n  }\n\n  /** @private */\n  _removeNewRendererOrTemplate(template, oldTemplate, renderer, oldRenderer) {\n    if (template !== oldTemplate) {\n      this.template = undefined;\n    } else if (renderer !== oldRenderer) {\n      this.renderer = undefined;\n    }\n  }\n\n  /** @private */\n  // eslint-disable-next-line max-params\n  _templateOrRendererChanged(template, renderer, owner, model, opened) {\n    if (template && renderer) {\n      this._removeNewRendererOrTemplate(template, this._oldTemplate, renderer, this._oldRenderer);\n      throw new Error('You should only use either a renderer or a template for overlay content');\n    }\n    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;\n    this._oldModel = model;\n    this._oldOwner = owner;\n    const templateChanged = this._oldTemplate !== template;\n    this._oldTemplate = template;\n    const rendererChanged = this._oldRenderer !== renderer;\n    this._oldRenderer = renderer;\n    const openedChanged = this._oldOpened !== opened;\n    this._oldOpened = opened;\n    if (rendererChanged) {\n      this.content = this;\n      this.content.innerHTML = '';\n      // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n      // When clearing the rendered content, this part needs to be manually disposed of.\n      // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n      delete this.content._$litPart$;\n    }\n    if (template && templateChanged) {\n      this._stampOverlayTemplate(template);\n    } else if (renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {\n      if (opened) {\n        this.requestContentUpdate();\n      }\n    }\n  }\n\n  /**\n   * @return {!Element}\n   * @protected\n   */\n  _getActiveElement() {\n    // Document.activeElement can be null\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement\n    let active = document.activeElement || document.body;\n    while (active.shadowRoot && active.shadowRoot.activeElement) {\n      active = active.shadowRoot.activeElement;\n    }\n    return active;\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   * @protected\n   */\n  _deepContains(node) {\n    if (this.contains(node)) {\n      return true;\n    }\n    let n = node;\n    const doc = node.ownerDocument;\n    // Walk from node to `this` or `document`\n    while (n && n !== doc && n !== this) {\n      n = n.parentNode || n.host;\n    }\n    return n === this;\n  }\n\n  /**\n   * Brings the overlay as visually the frontmost one\n   */\n  bringToFront() {\n    let zIndex = '';\n    const frontmost = Overlay.__attachedInstances.filter(o => o !== this).pop();\n    if (frontmost) {\n      const frontmostZIndex = frontmost.__zIndex;\n      zIndex = frontmostZIndex + 1;\n    }\n    this.style.zIndex = zIndex;\n    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);\n  }\n}\ncustomElements.define(Overlay.is, Overlay);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L3NyYy92YWFkaW4tb3ZlcmxheS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vb3ZlcmxheS9zcmMvdmFhZGluLW92ZXJsYXkuanM/N2YzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCB7IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgYWZ0ZXJOZXh0UmVuZGVyIH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0aXplIH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5pbXBvcnQgeyBodG1sLCBQb2x5bWVyRWxlbWVudCB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGlzSU9TIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvYnJvd3Nlci11dGlscy5qcyc7XG5pbXBvcnQgeyBDb250cm9sbGVyTWl4aW4gfSBmcm9tICdAdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9jb250cm9sbGVyLW1peGluLmpzJztcbmltcG9ydCB7IERpck1peGluIH0gZnJvbSAnQHZhYWRpbi9jb21wb25lbnQtYmFzZS9zcmMvZGlyLW1peGluLmpzJztcbmltcG9ydCB7IEZvY3VzVHJhcENvbnRyb2xsZXIgfSBmcm9tICdAdmFhZGluL2NvbXBvbmVudC1iYXNlL3NyYy9mb2N1cy10cmFwLWNvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHsgVGhlbWFibGVNaXhpbiB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5cbi8qKlxuICpcbiAqIGA8dmFhZGluLW92ZXJsYXk+YCBpcyBhIFdlYiBDb21wb25lbnQgZm9yIGNyZWF0aW5nIG92ZXJsYXlzLiBUaGUgY29udGVudCBvZiB0aGUgb3ZlcmxheVxuICogY2FuIGJlIHBvcHVsYXRlZCBpbiB0d28gd2F5czogaW1wZXJhdGl2ZWx5IGJ5IHVzaW5nIHJlbmRlcmVyIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZFxuICogZGVjbGFyYXRpdmVseSBieSB1c2luZyBQb2x5bWVyJ3MgVGVtcGxhdGVzLlxuICpcbiAqICMjIyBSZW5kZXJpbmdcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgb3ZlcmxheSB1c2VzIHRoZSBjb250ZW50IHByb3ZpZGVkIGJ5IHVzaW5nIHRoZSByZW5kZXJlciBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgcmVuZGVyZXIgZnVuY3Rpb24gcHJvdmlkZXMgYHJvb3RgLCBgb3duZXJgLCBgbW9kZWxgIGFyZ3VtZW50cyB3aGVuIGFwcGxpY2FibGUuXG4gKiBHZW5lcmF0ZSBET00gY29udGVudCBieSB1c2luZyBgbW9kZWxgIG9iamVjdCBwcm9wZXJ0aWVzIGlmIG5lZWRlZCwgYXBwZW5kIGl0IHRvIHRoZSBgcm9vdGBcbiAqIGVsZW1lbnQgYW5kIGNvbnRyb2wgdGhlIHN0YXRlIG9mIHRoZSBob3N0IGVsZW1lbnQgYnkgYWNjZXNzaW5nIGBvd25lcmAuIEJlZm9yZSBnZW5lcmF0aW5nIG5ld1xuICogY29udGVudCwgdXNlcnMgYXJlIGFibGUgdG8gY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBjb250ZW50IGluIGByb290YCBmb3IgcmV1c2luZyBpdC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8dmFhZGluLW92ZXJsYXkgaWQ9XCJvdmVybGF5XCI+PC92YWFkaW4tb3ZlcmxheT5cbiAqIGBgYFxuICogYGBganNcbiAqIGNvbnN0IG92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3ZlcmxheScpO1xuICogb3ZlcmxheS5yZW5kZXJlciA9IGZ1bmN0aW9uKHJvb3QpIHtcbiAqICByb290LnRleHRDb250ZW50ID0gXCJPdmVybGF5IGNvbnRlbnRcIjtcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBSZW5kZXJlciBpcyBjYWxsZWQgb24gdGhlIG9wZW5pbmcgb2YgdGhlIG92ZXJsYXkgYW5kIGVhY2ggdGltZSB0aGUgcmVsYXRlZCBtb2RlbCBpcyB1cGRhdGVkLlxuICogRE9NIGdlbmVyYXRlZCBkdXJpbmcgdGhlIHJlbmRlcmVyIGNhbGwgY2FuIGJlIHJldXNlZFxuICogaW4gdGhlIG5leHQgcmVuZGVyZXIgY2FsbCBhbmQgd2lsbCBiZSBwcm92aWRlZCB3aXRoIHRoZSBgcm9vdGAgYXJndW1lbnQuXG4gKiBPbiBmaXJzdCBjYWxsIGl0IHdpbGwgYmUgZW1wdHkuXG4gKlxuICogKipOT1RFOioqIHdoZW4gdGhlIHJlbmRlcmVyIHByb3BlcnR5IGlzIGRlZmluZWQsIHRoZSBgPHRlbXBsYXRlPmAgY29udGVudCBpcyBub3QgdXNlZC5cbiAqXG4gKiAjIyMgVGVtcGxhdGluZ1xuICpcbiAqIEFsdGVybmF0aXZlbHksIHRoZSBjb250ZW50IGNhbiBiZSBwcm92aWRlZCB3aXRoIFBvbHltZXIgVGVtcGxhdGUuXG4gKiBPdmVybGF5IGZpbmRzIHRoZSBmaXJzdCBjaGlsZCB0ZW1wbGF0ZSBhbmQgdXNlcyB0aGF0IGluIGNhc2UgcmVuZGVyZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIGlzIG5vdCBwcm92aWRlZC4gWW91IGNhbiBhbHNvIHNldCBhIGN1c3RvbSB0ZW1wbGF0ZSB1c2luZyB0aGUgYHRlbXBsYXRlYCBwcm9wZXJ0eS5cbiAqXG4gKiBBZnRlciB0aGUgY29udGVudCBmcm9tIHRoZSB0ZW1wbGF0ZSBpcyBzdGFtcGVkLCB0aGUgYGNvbnRlbnRgIHByb3BlcnR5XG4gKiBwb2ludHMgdG8gdGhlIGNvbnRlbnQgY29udGFpbmVyLlxuICpcbiAqIFRoZSBvdmVybGF5IHByb3ZpZGVzIGBmb3J3YXJkSG9zdFByb3BgIHdoZW4gY2FsbGluZ1xuICogYFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplYCBmb3IgdGhlIHRlbXBsYXRlLCBzbyB0aGF0IHRoZSBiaW5kaW5nc1xuICogZnJvbSB0aGUgcGFyZW50IHNjb3BlIHByb3BhZ2F0ZSB0byB0aGUgY29udGVudC5cbiAqXG4gKiAjIyMgU3R5bGluZ1xuICpcbiAqIFRvIHN0eWxlIHRoZSBvdmVybGF5IGNvbnRlbnQsIHVzZSBzdHlsZXMgaW4gdGhlIHBhcmVudCBzY29wZTpcbiAqXG4gKiAtIElmIHRoZSBvdmVybGF5IGlzIHVzZWQgaW4gYSBjb21wb25lbnQsIHRoZW4gdGhlIGNvbXBvbmVudCBzdHlsZXNcbiAqICAgYXBwbHkgdGhlIG92ZXJsYXkgY29udGVudC5cbiAqIC0gSWYgdGhlIG92ZXJsYXkgaXMgdXNlZCBpbiB0aGUgZ2xvYmFsIERPTSBzY29wZSwgdGhlbiBnbG9iYWwgc3R5bGVzXG4gKiAgIGFwcGx5IHRvIHRoZSBvdmVybGF5IGNvbnRlbnQuXG4gKlxuICogU2VlIGV4YW1wbGVzIGZvciBzdHlsaW5nIHRoZSBvdmVybGF5IGNvbnRlbnQgaW4gdGhlIGxpdmUgZGVtb3MuXG4gKlxuICogVGhlIGZvbGxvd2luZyBTaGFkb3cgRE9NIHBhcnRzIGFyZSBhdmFpbGFibGUgZm9yIHN0eWxpbmcgdGhlIG92ZXJsYXkgY29tcG9uZW50IGl0c2VsZjpcbiAqXG4gKiBQYXJ0IG5hbWUgIHwgRGVzY3JpcHRpb25cbiAqIC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIGBiYWNrZHJvcGAgfCBCYWNrZHJvcCBvZiB0aGUgb3ZlcmxheVxuICogYG92ZXJsYXlgICB8IENvbnRhaW5lciBmb3IgcG9zaXRpb24vc2l6aW5nL2FsaWdubWVudCBvZiB0aGUgY29udGVudFxuICogYGNvbnRlbnRgICB8IENvbnRlbnQgb2YgdGhlIG92ZXJsYXlcbiAqXG4gKiBUaGUgZm9sbG93aW5nIHN0YXRlIGF0dHJpYnV0ZXMgYXJlIGF2YWlsYWJsZSBmb3Igc3R5bGluZzpcbiAqXG4gKiBBdHRyaWJ1dGUgfCBEZXNjcmlwdGlvbiB8IFBhcnRcbiAqIC0tLXwtLS18LS0tXG4gKiBgb3BlbmluZ2AgfCBBcHBsaWVkIGp1c3QgYWZ0ZXIgdGhlIG92ZXJsYXkgaXMgYXR0YWNoZWQgdG8gdGhlIERPTS4gWW91IGNhbiBhcHBseSBhIENTUyBAa2V5ZnJhbWUgYW5pbWF0aW9uIGZvciB0aGlzIHN0YXRlLiB8IGA6aG9zdGBcbiAqIGBjbG9zaW5nYCB8IEFwcGxpZWQganVzdCBiZWZvcmUgdGhlIG92ZXJsYXkgaXMgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLiBZb3UgY2FuIGFwcGx5IGEgQ1NTIEBrZXlmcmFtZSBhbmltYXRpb24gZm9yIHRoaXMgc3RhdGUuIHwgYDpob3N0YFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgY3VzdG9tIENTUyBwcm9wZXJ0aWVzIGFyZSBhdmFpbGFibGUgZm9yIHN0eWxpbmc6XG4gKlxuICogQ3VzdG9tIENTUyBwcm9wZXJ0eSB8IERlc2NyaXB0aW9uIHwgRGVmYXVsdCB2YWx1ZVxuICogLS0tfC0tLXwtLS1cbiAqIGAtLXZhYWRpbi1vdmVybGF5LXZpZXdwb3J0LWJvdHRvbWAgfCBCb3R0b20gb2Zmc2V0IG9mIHRoZSB2aXNpYmxlIHZpZXdwb3J0IGFyZWEgfCBgMGAgb3IgZGV0ZWN0ZWQgb2Zmc2V0XG4gKlxuICogU2VlIFtTdHlsaW5nIENvbXBvbmVudHNdKGh0dHBzOi8vdmFhZGluLmNvbS9kb2NzL2xhdGVzdC9zdHlsaW5nL2N1c3RvbS10aGVtZS9zdHlsaW5nLWNvbXBvbmVudHMpIGRvY3VtZW50YXRpb24uXG4gKlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gb3BlbmVkLWNoYW5nZWQgLSBGaXJlZCB3aGVuIHRoZSBgb3BlbmVkYCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gdmFhZGluLW92ZXJsYXktb3BlbiAtIEZpcmVkIGFmdGVyIHRoZSBvdmVybGF5IGlzIG9wZW5lZC5cbiAqIEBmaXJlcyB7Q3VzdG9tRXZlbnR9IHZhYWRpbi1vdmVybGF5LWNsb3NlIC0gRmlyZWQgYmVmb3JlIHRoZSBvdmVybGF5IHdpbGwgYmUgY2xvc2VkLiBJZiBjYW5jZWxlZCB0aGUgY2xvc2luZyBvZiB0aGUgb3ZlcmxheSBpcyBjYW5jZWxlZCBhcyB3ZWxsLlxuICogQGZpcmVzIHtDdXN0b21FdmVudH0gdmFhZGluLW92ZXJsYXktY2xvc2luZyAtIEZpcmVkIHdoZW4gdGhlIG92ZXJsYXkgd2lsbCBiZSBjbG9zZWQuXG4gKiBAZmlyZXMge0N1c3RvbUV2ZW50fSB2YWFkaW4tb3ZlcmxheS1vdXRzaWRlLWNsaWNrIC0gRmlyZWQgYmVmb3JlIHRoZSBvdmVybGF5IHdpbGwgYmUgY2xvc2VkIG9uIG91dHNpZGUgY2xpY2suIElmIGNhbmNlbGVkIHRoZSBjbG9zaW5nIG9mIHRoZSBvdmVybGF5IGlzIGNhbmNlbGVkIGFzIHdlbGwuXG4gKiBAZmlyZXMge0N1c3RvbUV2ZW50fSB2YWFkaW4tb3ZlcmxheS1lc2NhcGUtcHJlc3MgLSBGaXJlZCBiZWZvcmUgdGhlIG92ZXJsYXkgd2lsbCBiZSBjbG9zZWQgb24gRVNDIGJ1dHRvbiBwcmVzcy4gSWYgY2FuY2VsZWQgdGhlIGNsb3Npbmcgb2YgdGhlIG92ZXJsYXkgaXMgY2FuY2VsZWQgYXMgd2VsbC5cbiAqXG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQG1peGVzIFRoZW1hYmxlTWl4aW5cbiAqIEBtaXhlcyBEaXJNaXhpblxuICogQG1peGVzIENvbnRyb2xsZXJNaXhpblxuICovXG5jbGFzcyBPdmVybGF5IGV4dGVuZHMgVGhlbWFibGVNaXhpbihEaXJNaXhpbihDb250cm9sbGVyTWl4aW4oUG9seW1lckVsZW1lbnQpKSkge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgei1pbmRleDogMjAwO1xuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcblxuICAgICAgICAgIC8qIERlc3BpdGUgb2Ygd2hhdCB0aGUgbmFtZXMgc2F5LCA8dmFhZGluLW92ZXJsYXk+IGlzIGp1c3QgYSBjb250YWluZXJcbiAgICAgICAgICBmb3IgcG9zaXRpb24vc2l6aW5nL2FsaWdubWVudC4gVGhlIGFjdHVhbCBvdmVybGF5IGlzIHRoZSBvdmVybGF5IHBhcnQuICovXG5cbiAgICAgICAgICAvKiBEZWZhdWx0IHBvc2l0aW9uIGNvbnN0cmFpbnRzOiB0aGUgZW50aXJlIHZpZXdwb3J0LiBOb3RlOiB0aGVtZXMgY2FuXG4gICAgICAgICAgb3ZlcnJpZGUgdGhpcyB0byBpbnRyb2R1Y2UgZ2FwcyBiZXR3ZWVuIHRoZSBvdmVybGF5IGFuZCB0aGUgdmlld3BvcnQuICovXG4gICAgICAgICAgdG9wOiAwO1xuICAgICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICAgIGJvdHRvbTogdmFyKC0tdmFhZGluLW92ZXJsYXktdmlld3BvcnQtYm90dG9tKTtcbiAgICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgICAgLyogVXNlIGZsZXhib3ggYWxpZ25tZW50IGZvciB0aGUgb3ZlcmxheSBwYXJ0LiAqL1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgLyogbWFrZXMgZHJvcGRvd25zIHNpemluZyBlYXNpZXIgKi9cbiAgICAgICAgICAvKiBBbGlnbiB0byBjZW50ZXIgYnkgZGVmYXVsdC4gKi9cbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXG4gICAgICAgICAgLyogQWxsb3cgY2VudGVyaW5nIHdoZW4gbWF4LXdpZHRoL21heC1oZWlnaHQgYXBwbGllcy4gKi9cbiAgICAgICAgICBtYXJnaW46IGF1dG87XG5cbiAgICAgICAgICAvKiBUaGUgaG9zdCBpcyBub3QgY2xpY2thYmxlLCBvbmx5IHRoZSBvdmVybGF5IHBhcnQgaXMuICovXG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG5cbiAgICAgICAgICAvKiBSZW1vdmUgdGFwIGhpZ2hsaWdodCBvbiB0b3VjaCBkZXZpY2VzLiAqL1xuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgICAvKiBDU1MgQVBJIGZvciBob3N0ICovXG4gICAgICAgICAgLS12YWFkaW4tb3ZlcmxheS12aWV3cG9ydC1ib3R0b206IDA7XG4gICAgICAgIH1cblxuICAgICAgICA6aG9zdChbaGlkZGVuXSksXG4gICAgICAgIDpob3N0KDpub3QoW29wZW5lZF0pOm5vdChbY2xvc2luZ10pKSB7XG4gICAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICB9XG5cbiAgICAgICAgW3BhcnQ9J292ZXJsYXknXSB7XG4gICAgICAgICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuXG4gICAgICAgICAgLyogUHJldmVudCBvdmVyZmxvd2luZyB0aGUgaG9zdCBpbiBNU0lFIDExICovXG4gICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IGluaXRpYWw7IC8qIHJlZW5hYmxlIHRhcCBoaWdobGlnaHQgaW5zaWRlICovXG4gICAgICAgIH1cblxuICAgICAgICBbcGFydD0nYmFja2Ryb3AnXSB7XG4gICAgICAgICAgei1pbmRleDogLTE7XG4gICAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICBib3R0b206IDA7XG4gICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgaWQ9XCJiYWNrZHJvcFwiIHBhcnQ9XCJiYWNrZHJvcFwiIGhpZGRlbiQ9XCJbWyF3aXRoQmFja2Ryb3BdXVwiPjwvZGl2PlxuICAgICAgPGRpdiBwYXJ0PVwib3ZlcmxheVwiIGlkPVwib3ZlcmxheVwiIHRhYmluZGV4PVwiMFwiPlxuICAgICAgICA8ZGl2IHBhcnQ9XCJjb250ZW50XCIgaWQ9XCJjb250ZW50XCI+XG4gICAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzKCkge1xuICAgIHJldHVybiAndmFhZGluLW92ZXJsYXknO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdHJ1ZSwgdGhlIG92ZXJsYXkgaXMgdmlzaWJsZSBhbmQgYXR0YWNoZWQgdG8gYm9keS5cbiAgICAgICAqL1xuICAgICAgb3BlbmVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfb3BlbmVkQ2hhbmdlZCcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogT3duZXIgZWxlbWVudCBwYXNzZWQgd2l0aCByZW5kZXJlciBmdW5jdGlvblxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICBvd25lcjogRWxlbWVudCxcblxuICAgICAgLyoqXG4gICAgICAgKiBDdXN0b20gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyB0aGUgY29udGVudCBvZiB0aGUgb3ZlcmxheS5cbiAgICAgICAqIFJlY2VpdmVzIHRocmVlIGFyZ3VtZW50czpcbiAgICAgICAqXG4gICAgICAgKiAtIGByb290YCBUaGUgcm9vdCBjb250YWluZXIgRE9NIGVsZW1lbnQuIEFwcGVuZCB5b3VyIGNvbnRlbnQgdG8gaXQuXG4gICAgICAgKiAtIGBvd25lcmAgVGhlIGhvc3QgZWxlbWVudCBvZiB0aGUgcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAgICAgKiAtIGBtb2RlbGAgVGhlIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIHJlbGF0ZWQgd2l0aCByZW5kZXJpbmcuXG4gICAgICAgKiBAdHlwZSB7T3ZlcmxheVJlbmRlcmVyIHwgbnVsbCB8IHVuZGVmaW5lZH1cbiAgICAgICAqL1xuICAgICAgcmVuZGVyZXI6IEZ1bmN0aW9uLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0ZW1wbGF0ZSBvZiB0aGUgb3ZlcmxheSBjb250ZW50LlxuICAgICAgICogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkfVxuICAgICAgICovXG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVmZXJlbmNlcyB0aGUgY29udGVudCBjb250YWluZXIgYWZ0ZXIgdGhlIHRlbXBsYXRlIGlzIHN0YW1wZWQuXG4gICAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50IHwgdW5kZWZpbmVkfVxuICAgICAgICovXG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRydWUgdGhlIG92ZXJsYXkgaGFzIGJhY2tkcm9wIG9uIHRvcCBvZiBjb250ZW50IHdoZW4gb3BlbmVkLlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHdpdGhCYWNrZHJvcDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogT2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IGlzIHBhc3NlZCB0byBgcmVuZGVyZXJgIGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIG1vZGVsOiBPYmplY3QsXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0cnVlIHRoZSBvdmVybGF5IHdvbid0IGRpc2FibGUgdGhlIG1haW4gY29udGVudCwgc2hvd2luZ1xuICAgICAgICogaXQgZG9lc27igJl0IGNoYW5nZSB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGUgdXNlciBpbnRlcmZhY2UuXG4gICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgbW9kZWxlc3M6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAnX21vZGVsZXNzQ2hhbmdlZCcsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBvdmVybGF5IGlzIGhpZGRlbi4gVGhpcyBhbHNvIGNsb3NlcyB0aGUgb3ZlcmxheVxuICAgICAgICogaW1tZWRpYXRlbHkgaW4gY2FzZSB0aGVyZSBpcyBhIGNsb3NpbmcgYW5pbWF0aW9uIGluIHByb2dyZXNzLlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGhpZGRlbjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgIG9ic2VydmVyOiAnX2hpZGRlbkNoYW5nZWQnLFxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRydWUgbW92ZSBmb2N1cyB0byB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgaW4gdGhlIG92ZXJsYXksXG4gICAgICAgKiBvciB0byB0aGUgb3ZlcmxheSBpZiB0aGVyZSBhcmUgbm8gZm9jdXNhYmxlIGVsZW1lbnRzLlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGZvY3VzVHJhcDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSByZXN0b3Jpbmcgb2YgZm9jdXMgd2hlbiBvdmVybGF5IGlzIGNsb3NlZC5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICByZXN0b3JlRm9jdXNPbkNsb3NlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHRvIHNwZWNpZnkgdGhlIGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIGZvY3VzZWQgb24gb3ZlcmxheSBjbG9zZSxcbiAgICAgICAqIGlmIGByZXN0b3JlRm9jdXNPbkNsb3NlYCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgcmVzdG9yZUZvY3VzTm9kZToge1xuICAgICAgICB0eXBlOiBIVE1MRWxlbWVudCxcbiAgICAgIH0sXG5cbiAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgX21vdXNlRG93bkluc2lkZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgfSxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfbW91c2VVcEluc2lkZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgfSxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfaW5zdGFuY2U6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgfSxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb3JpZ2luYWxDb250ZW50UGFydDogT2JqZWN0LFxuXG4gICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgIF9jb250ZW50Tm9kZXM6IEFycmF5LFxuXG4gICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgIF9vbGRPd25lcjogRWxlbWVudCxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb2xkTW9kZWw6IE9iamVjdCxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb2xkVGVtcGxhdGU6IE9iamVjdCxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb2xkUmVuZGVyZXI6IE9iamVjdCxcblxuICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICBfb2xkT3BlbmVkOiBCb29sZWFuLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICByZXR1cm4gWydfdGVtcGxhdGVPclJlbmRlcmVyQ2hhbmdlZCh0ZW1wbGF0ZSwgcmVuZGVyZXIsIG93bmVyLCBtb2RlbCwgb3BlbmVkKSddO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9ib3VuZE1vdXNlRG93bkxpc3RlbmVyID0gdGhpcy5fbW91c2VEb3duTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE1vdXNlVXBMaXN0ZW5lciA9IHRoaXMuX21vdXNlVXBMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT3V0c2lkZUNsaWNrTGlzdGVuZXIgPSB0aGlzLl9vdXRzaWRlQ2xpY2tMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kS2V5ZG93bkxpc3RlbmVyID0gdGhpcy5fa2V5ZG93bkxpc3RlbmVyLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMsIChpbmZvKSA9PiB7XG4gICAgICB0aGlzLl9zZXRUZW1wbGF0ZUZyb21Ob2RlcyhpbmZvLmFkZGVkTm9kZXMpO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuZXIgZm9yIHByZXZlbnRpbmcgY2xvc2luZyBvZiB0aGUgcGFwZXItZGlhbG9nIGFuZCBhbGwgY29tcG9uZW50cyBleHRlbmRpbmcgYGlyb24tb3ZlcmxheS1iZWhhdmlvcmAuXG4gICAgdGhpcy5fYm91bmRJcm9uT3ZlcmxheUNhbmNlbGVkTGlzdGVuZXIgPSB0aGlzLl9pcm9uT3ZlcmxheUNhbmNlbGVkLmJpbmQodGhpcyk7XG5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKGlzSU9TKSB7XG4gICAgICB0aGlzLl9ib3VuZElvc1Jlc2l6ZUxpc3RlbmVyID0gKCkgPT4gdGhpcy5fZGV0ZWN0SW9zTmF2YmFyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fX2ZvY3VzVHJhcENvbnRyb2xsZXIgPSBuZXcgRm9jdXNUcmFwQ29udHJvbGxlcih0aGlzKTtcbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIHJlYWR5KCkge1xuICAgIHN1cGVyLnJlYWR5KCk7XG5cbiAgICB0aGlzLl9vYnNlcnZlci5mbHVzaCgpO1xuXG4gICAgLy8gTmVlZCB0byBhZGQgZHVtbXkgY2xpY2sgbGlzdGVuZXJzIHRvIHRoaXMgYW5kIHRoZSBiYWNrZHJvcCBvciBlbHNlXG4gICAgLy8gdGhlIGRvY3VtZW50IGNsaWNrIGV2ZW50IGxpc3RlbmVyIChfb3V0c2lkZUNsaWNrTGlzdGVuZXIpIG1heSBuZXZlclxuICAgIC8vIGdldCBpbnZva2VkIG9uIGlPUyBTYWZhcmkgKHJlcHJvZHVjaWJsZSBpbiA8dmFhZGluLWRpYWxvZz5cbiAgICAvLyBhbmQgPHZhYWRpbi1jb250ZXh0LW1lbnU+KS5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge30pO1xuICAgIHRoaXMuJC5iYWNrZHJvcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHt9KTtcblxuICAgIHRoaXMuYWRkQ29udHJvbGxlcih0aGlzLl9fZm9jdXNUcmFwQ29udHJvbGxlcik7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2RldGVjdElvc05hdmJhcigpIHtcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAxNSAqL1xuICAgIGlmICghdGhpcy5vcGVuZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbm5lckhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBjb25zdCBpbm5lcldpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cbiAgICBjb25zdCBsYW5kc2NhcGUgPSBpbm5lcldpZHRoID4gaW5uZXJIZWlnaHQ7XG5cbiAgICBjb25zdCBjbGllbnRIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgaWYgKGxhbmRzY2FwZSAmJiBjbGllbnRIZWlnaHQgPiBpbm5lckhlaWdodCkge1xuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12YWFkaW4tb3ZlcmxheS12aWV3cG9ydC1ib3R0b20nLCBgJHtjbGllbnRIZWlnaHQgLSBpbm5lckhlaWdodH1weGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KCctLXZhYWRpbi1vdmVybGF5LXZpZXdwb3J0LWJvdHRvbScsICcwJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PCFFbGVtZW50Pn0gbm9kZXNcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3NldFRlbXBsYXRlRnJvbU5vZGVzKG5vZGVzKSB7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IG5vZGVzLmZpbmQoKG5vZGUpID0+IG5vZGUubG9jYWxOYW1lICYmIG5vZGUubG9jYWxOYW1lID09PSAndGVtcGxhdGUnKSB8fCB0aGlzLnRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBzb3VyY2VFdmVudFxuICAgKiBAZXZlbnQgdmFhZGluLW92ZXJsYXktY2xvc2VcbiAgICogZmlyZWQgYmVmb3JlIHRoZSBgdmFhZGluLW92ZXJsYXlgIHdpbGwgYmUgY2xvc2VkLiBJZiBjYW5jZWxlZCB0aGUgY2xvc2luZyBvZiB0aGUgb3ZlcmxheSBpcyBjYW5jZWxlZCBhcyB3ZWxsLlxuICAgKi9cbiAgY2xvc2Uoc291cmNlRXZlbnQpIHtcbiAgICBjb25zdCBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3ZhYWRpbi1vdmVybGF5LWNsb3NlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgc291cmNlRXZlbnQgfSxcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICBpZiAoIWV2dC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKHRoaXMuX2JvdW5kSW9zUmVzaXplTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2RldGVjdElvc05hdmJhcigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kSW9zUmVzaXplTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgaWYgKHRoaXMuX2JvdW5kSW9zUmVzaXplTGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZElvc1Jlc2l6ZUxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgYW4gdXBkYXRlIGZvciB0aGUgY29udGVudCBvZiB0aGUgb3ZlcmxheS5cbiAgICogV2hpbGUgcGVyZm9ybWluZyB0aGUgdXBkYXRlLCBpdCBpbnZva2VzIHRoZSByZW5kZXJlciBwYXNzZWQgaW4gdGhlIGByZW5kZXJlcmAgcHJvcGVydHkuXG4gICAqXG4gICAqIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgdGhlIHVwZGF0ZSBoYXBwZW5zIGltbWVkaWF0ZWx5IChzeW5jaHJvbm91c2x5KSBhZnRlciBpdCBpcyByZXF1ZXN0ZWQuXG4gICAqL1xuICByZXF1ZXN0Q29udGVudFVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5jYWxsKHRoaXMub3duZXIsIHRoaXMuY29udGVudCwgdGhpcy5vd25lciwgdGhpcy5tb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9pcm9uT3ZlcmxheUNhbmNlbGVkKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfbW91c2VEb3duTGlzdGVuZXIoZXZlbnQpIHtcbiAgICB0aGlzLl9tb3VzZURvd25JbnNpZGUgPSBldmVudC5jb21wb3NlZFBhdGgoKS5pbmRleE9mKHRoaXMuJC5vdmVybGF5KSA+PSAwO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9tb3VzZVVwTGlzdGVuZXIoZXZlbnQpIHtcbiAgICB0aGlzLl9tb3VzZVVwSW5zaWRlID0gZXZlbnQuY29tcG9zZWRQYXRoKCkuaW5kZXhPZih0aGlzLiQub3ZlcmxheSkgPj0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBuZWVkIHRvIGxpc3RlbiBvbiAnY2xpY2snIC8gJ3RhcCcgZXZlbnQgYW5kIGNhcHR1cmUgaXQgYW5kIGNsb3NlIHRoZSBvdmVybGF5IGJlZm9yZVxuICAgKiBwcm9wYWdhdGluZyB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyIGluIHRoZSBidXR0b24uIE90aGVyd2lzZSwgaWYgdGhlIGNsaWNrZWQgYnV0dG9uIHdvdWxkIGNhbGxcbiAgICogb3BlbigpLCB0aGlzIHdvdWxkIGhhcHBlbjogaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1aODZWX0lDVUNENFxuICAgKlxuICAgKiBAZXZlbnQgdmFhZGluLW92ZXJsYXktb3V0c2lkZS1jbGlja1xuICAgKiBmaXJlZCBiZWZvcmUgdGhlIGB2YWFkaW4tb3ZlcmxheWAgd2lsbCBiZSBjbG9zZWQgb24gb3V0c2lkZSBjbGljay4gSWYgY2FuY2VsZWQgdGhlIGNsb3Npbmcgb2YgdGhlIG92ZXJsYXkgaXMgY2FuY2VsZWQgYXMgd2VsbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vdXRzaWRlQ2xpY2tMaXN0ZW5lcihldmVudCkge1xuICAgIGlmIChldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyh0aGlzLiQub3ZlcmxheSkgfHwgdGhpcy5fbW91c2VEb3duSW5zaWRlIHx8IHRoaXMuX21vdXNlVXBJbnNpZGUpIHtcbiAgICAgIHRoaXMuX21vdXNlRG93bkluc2lkZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbW91c2VVcEluc2lkZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2xhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3ZhYWRpbi1vdmVybGF5LW91dHNpZGUtY2xpY2snLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGRldGFpbDogeyBzb3VyY2VFdmVudDogZXZlbnQgfSxcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgIGlmICh0aGlzLm9wZW5lZCAmJiAhZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZXZlbnQgdmFhZGluLW92ZXJsYXktZXNjYXBlLXByZXNzXG4gICAqIGZpcmVkIGJlZm9yZSB0aGUgYHZhYWRpbi1vdmVybGF5YCB3aWxsIGJlIGNsb3NlZCBvbiBFU0MgYnV0dG9uIHByZXNzLiBJZiBjYW5jZWxlZCB0aGUgY2xvc2luZyBvZiB0aGUgb3ZlcmxheSBpcyBjYW5jZWxlZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2tleWRvd25MaXN0ZW5lcihldmVudCkge1xuICAgIGlmICghdGhpcy5fbGFzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE9ubHkgY2xvc2UgbW9kZWxlc3Mgb3ZlcmxheSBvbiBFc2MgcHJlc3Mgd2hlbiBpdCBjb250YWlucyBmb2N1c1xuICAgIGlmICh0aGlzLm1vZGVsZXNzICYmICFldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyh0aGlzLiQub3ZlcmxheSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgY29uc3QgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCd2YWFkaW4tb3ZlcmxheS1lc2NhcGUtcHJlc3MnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgIGRldGFpbDogeyBzb3VyY2VFdmVudDogZXZlbnQgfSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCAmJiAhZXZ0LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2Vuc3VyZVRlbXBsYXRpemVkKCkge1xuICAgIHRoaXMuX3NldFRlbXBsYXRlRnJvbU5vZGVzKEFycmF5LmZyb20odGhpcy5jaGlsZHJlbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBldmVudCB2YWFkaW4tb3ZlcmxheS1vcGVuXG4gICAqIGZpcmVkIGFmdGVyIHRoZSBgdmFhZGluLW92ZXJsYXlgIGlzIG9wZW5lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vcGVuZWRDaGFuZ2VkKG9wZW5lZCwgd2FzT3BlbmVkKSB7XG4gICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5fZW5zdXJlVGVtcGxhdGl6ZWQoKTtcbiAgICB9XG5cbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICAvLyBTdG9yZSBmb2N1c2VkIG5vZGUuXG4gICAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2FuaW1hdGVkT3BlbmluZygpO1xuXG4gICAgICBhZnRlck5leHRSZW5kZXIodGhpcywgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgICB0aGlzLl9fZm9jdXNUcmFwQ29udHJvbGxlci50cmFwRm9jdXModGhpcy4kLm92ZXJsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KCd2YWFkaW4tb3ZlcmxheS1vcGVuJywgeyBidWJibGVzOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIH0pO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRLZXlkb3duTGlzdGVuZXIpO1xuXG4gICAgICBpZiAoIXRoaXMubW9kZWxlc3MpIHtcbiAgICAgICAgdGhpcy5fYWRkR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3YXNPcGVuZWQpIHtcbiAgICAgIGlmICh0aGlzLmZvY3VzVHJhcCkge1xuICAgICAgICB0aGlzLl9fZm9jdXNUcmFwQ29udHJvbGxlci5yZWxlYXNlRm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYW5pbWF0ZWRDbG9zaW5nKCk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEtleWRvd25MaXN0ZW5lcik7XG5cbiAgICAgIGlmICghdGhpcy5tb2RlbGVzcykge1xuICAgICAgICB0aGlzLl9yZW1vdmVHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX2hpZGRlbkNoYW5nZWQoaGlkZGVuKSB7XG4gICAgaWYgKGhpZGRlbiAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2xvc2luZycpKSB7XG4gICAgICB0aGlzLl9mbHVzaEFuaW1hdGlvbignY2xvc2luZycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvdWxkQW5pbWF0ZSgpIHtcbiAgICBjb25zdCBuYW1lID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKCdhbmltYXRpb24tbmFtZScpO1xuICAgIGNvbnN0IGhpZGRlbiA9IGdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpID09PSAnbm9uZSc7XG4gICAgcmV0dXJuICFoaWRkZW4gJiYgbmFtZSAmJiBuYW1lICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2VucXVldWVBbmltYXRpb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBoYW5kbGVyID0gYF9fJHt0eXBlfUhhbmRsZXJgO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGxpc3RlbmVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzW2hhbmRsZXJdO1xuICAgIH07XG4gICAgdGhpc1toYW5kbGVyXSA9IGxpc3RlbmVyO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9mbHVzaEFuaW1hdGlvbih0eXBlKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IGBfXyR7dHlwZX1IYW5kbGVyYDtcbiAgICBpZiAodHlwZW9mIHRoaXNbaGFuZGxlcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaGFuZGxlcl0oKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfYW5pbWF0ZWRPcGVuaW5nKCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2Nsb3NpbmcnKSkge1xuICAgICAgdGhpcy5fZmx1c2hBbmltYXRpb24oJ2Nsb3NpbmcnKTtcbiAgICB9XG4gICAgdGhpcy5fYXR0YWNoT3ZlcmxheSgpO1xuICAgIGlmICghdGhpcy5tb2RlbGVzcykge1xuICAgICAgdGhpcy5fZW50ZXJNb2RhbFN0YXRlKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdvcGVuaW5nJywgJycpO1xuXG4gICAgaWYgKHRoaXMuX3Nob3VsZEFuaW1hdGUoKSkge1xuICAgICAgdGhpcy5fZW5xdWV1ZUFuaW1hdGlvbignb3BlbmluZycsICgpID0+IHtcbiAgICAgICAgdGhpcy5fZmluaXNoT3BlbmluZygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpbmlzaE9wZW5pbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfYXR0YWNoT3ZlcmxheSgpIHtcbiAgICB0aGlzLl9wbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3ZhYWRpbi1vdmVybGF5LXBsYWNlaG9sZGVyJyk7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9wbGFjZWhvbGRlciwgdGhpcyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICB0aGlzLmJyaW5nVG9Gcm9udCgpO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2ZpbmlzaE9wZW5pbmcoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaXJvbi1vdmVybGF5LWNhbmNlbGVkJywgdGhpcy5fYm91bmRJcm9uT3ZlcmxheUNhbmNlbGVkTGlzdGVuZXIpO1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdvcGVuaW5nJyk7XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfZmluaXNoQ2xvc2luZygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpcm9uLW92ZXJsYXktY2FuY2VsZWQnLCB0aGlzLl9ib3VuZElyb25PdmVybGF5Q2FuY2VsZWRMaXN0ZW5lcik7XG4gICAgdGhpcy5fZGV0YWNoT3ZlcmxheSgpO1xuICAgIHRoaXMuJC5vdmVybGF5LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycpO1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdjbG9zaW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogQGV2ZW50IHZhYWRpbi1vdmVybGF5LWNsb3NpbmdcbiAgICogRmlyZWQgd2hlbiB0aGUgb3ZlcmxheSB3aWxsIGJlIGNsb3NlZC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2FuaW1hdGVkQ2xvc2luZygpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29wZW5pbmcnKSkge1xuICAgICAgdGhpcy5fZmx1c2hBbmltYXRpb24oJ29wZW5pbmcnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLl9leGl0TW9kYWxTdGF0ZSgpO1xuXG4gICAgICAvLyBVc2UgdGhpcy5yZXN0b3JlRm9jdXNOb2RlIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIHRoZSBub2RlXG4gICAgICAvLyB3aGljaCB3YXMgZm9jdXNlZCBiZWZvcmUgb3BlbmluZyB0aGUgb3ZlcmxheS5cbiAgICAgIGNvbnN0IHJlc3RvcmVGb2N1c05vZGUgPSB0aGlzLnJlc3RvcmVGb2N1c05vZGUgfHwgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGU7XG5cbiAgICAgIGlmICh0aGlzLnJlc3RvcmVGb2N1c09uQ2xvc2UgJiYgcmVzdG9yZUZvY3VzTm9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgYWN0aXZlRWxlbWVudCBpcyBgPGJvZHk+YCBvciBpbnNpZGUgdGhlIG92ZXJsYXksXG4gICAgICAgIC8vIHdlIGFyZSBhbGxvd2VkIHRvIHJlc3RvcmUgdGhlIGZvY3VzLiBJbiBhbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGZvY3VzIG1pZ2h0IGhhdmUgYmVlbiBtb3ZlZCBlbHNld2hlcmUgYnkgYW5vdGhlclxuICAgICAgICAvLyBjb21wb25lbnQgb3IgYnkgdGhlIHVzZXIgaW50ZXJhY3Rpb24gKGUuZy4gY2xpY2sgb24gYVxuICAgICAgICAvLyBidXR0b24gb3V0c2lkZSB0aGUgb3ZlcmxheSkuXG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50KCk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgfHwgdGhpcy5fZGVlcENvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgLy8gRm9jdXNpbmcgdGhlIHJlc3RvcmVGb2N1c05vZGUgZG9lc24ndCBhbHdheXMgd29yayBzeW5jaHJvbm91c2x5IG9uIEZpcmVmb3ggYW5kIFNhZmFyaVxuICAgICAgICAgIC8vIChlLmcuIGNvbWJvLWJveCBvdmVybGF5IGNsb3NlIG9uIG91dHNpZGUgY2xpY2spLlxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzdG9yZUZvY3VzTm9kZS5mb2N1cygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjbG9zaW5nJywgJycpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgndmFhZGluLW92ZXJsYXktY2xvc2luZycpKTtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZEFuaW1hdGUoKSkge1xuICAgICAgICB0aGlzLl9lbnF1ZXVlQW5pbWF0aW9uKCdjbG9zaW5nJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2ZpbmlzaENsb3NpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maW5pc2hDbG9zaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2RldGFjaE92ZXJsYXkoKSB7XG4gICAgdGhpcy5fcGxhY2Vob2xkZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5fcGxhY2Vob2xkZXIpO1xuICAgIHRoaXMuX3BsYWNlaG9sZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fcGxhY2Vob2xkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dGFjaGVkIG92ZXJsYXlzIGluIHZpc3VhbCBzdGFja2luZyBvcmRlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBnZXQgX19hdHRhY2hlZEluc3RhbmNlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKVxuICAgICAgLmZpbHRlcigoZWwpID0+IGVsIGluc3RhbmNlb2YgT3ZlcmxheSAmJiAhZWwuaGFzQXR0cmlidXRlKCdjbG9zaW5nJykpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5fX3pJbmRleCAtIGIuX196SW5kZXggfHwgMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb25lIGluIHRoZSBvcGVuZWQgb3ZlcmxheXMgc3RhY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0IF9sYXN0KCkge1xuICAgIHJldHVybiB0aGlzID09PSBPdmVybGF5Ll9fYXR0YWNoZWRJbnN0YW5jZXMucG9wKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX21vZGVsZXNzQ2hhbmdlZChtb2RlbGVzcykge1xuICAgIGlmICghbW9kZWxlc3MpIHtcbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLl9hZGRHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fZW50ZXJNb2RhbFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbW92ZUdsb2JhbExpc3RlbmVycygpO1xuICAgICAgdGhpcy5fZXhpdE1vZGFsU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfYWRkR2xvYmFsTGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2JvdW5kTW91c2VEb3duTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9ib3VuZE1vdXNlVXBMaXN0ZW5lcik7XG4gICAgLy8gRmlyZWZveCBsZWFrcyBjbGljayB0byBkb2N1bWVudCBvbiBjb250ZXh0bWVudSBldmVuIGlmIHByZXZlbnRlZFxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTk5MDYxNFxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT3V0c2lkZUNsaWNrTGlzdGVuZXIsIHRydWUpO1xuICB9XG5cbiAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgX2VudGVyTW9kYWxTdGF0ZSgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzICE9PSAnbm9uZScpIHtcbiAgICAgIC8vIFNldCBib2R5IHBvaW50ZXItZXZlbnRzIHRvICdub25lJyB0byBkaXNhYmxlIG1vdXNlIGludGVyYWN0aW9ucyB3aXRoXG4gICAgICAvLyBvdGhlciBkb2N1bWVudCBub2Rlcy5cbiAgICAgIHRoaXMuX3ByZXZpb3VzRG9jdW1lbnRQb2ludGVyRXZlbnRzID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIERpc2FibGUgcG9pbnRlciBldmVudHMgaW4gb3RoZXIgYXR0YWNoZWQgb3ZlcmxheXNcbiAgICBPdmVybGF5Ll9fYXR0YWNoZWRJbnN0YW5jZXMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGlmIChlbCAhPT0gdGhpcykge1xuICAgICAgICBlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ1twYXJ0PVwib3ZlcmxheVwiXScpLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfcmVtb3ZlR2xvYmFsTGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2JvdW5kTW91c2VEb3duTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9ib3VuZE1vdXNlVXBMaXN0ZW5lcik7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPdXRzaWRlQ2xpY2tMaXN0ZW5lciwgdHJ1ZSk7XG4gIH1cblxuICAvKiogQHByb3RlY3RlZCAqL1xuICBfZXhpdE1vZGFsU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzRG9jdW1lbnRQb2ludGVyRXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFJlc3RvcmUgYm9keSBwb2ludGVyLWV2ZW50c1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gdGhpcy5fcHJldmlvdXNEb2N1bWVudFBvaW50ZXJFdmVudHM7XG4gICAgICBkZWxldGUgdGhpcy5fcHJldmlvdXNEb2N1bWVudFBvaW50ZXJFdmVudHM7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBwb2ludGVyIGV2ZW50cyBpbiB0aGUgcHJldmlvdXMgb3ZlcmxheShzKVxuICAgIGNvbnN0IGluc3RhbmNlcyA9IE92ZXJsYXkuX19hdHRhY2hlZEluc3RhbmNlcztcbiAgICBsZXQgZWw7XG4gICAgLy8gVXNlIGluc3RhbmNlcy5wb3AoKSB0byBlbnN1cmUgdGhlIHJldmVyc2Ugb3JkZXJcbiAgICB3aGlsZSAoKGVsID0gaW5zdGFuY2VzLnBvcCgpKSkge1xuICAgICAgaWYgKGVsID09PSB0aGlzKSB7XG4gICAgICAgIC8vIFNraXAgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ1twYXJ0PVwib3ZlcmxheVwiXScpLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycpO1xuICAgICAgaWYgKCFlbC5tb2RlbGVzcykge1xuICAgICAgICAvLyBTdG9wIGFmdGVyIHRoZSBsYXN0IG1vZGFsXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIF9yZW1vdmVPbGRDb250ZW50KCkge1xuICAgIGlmICghdGhpcy5jb250ZW50IHx8ICF0aGlzLl9jb250ZW50Tm9kZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICB0aGlzLl9jb250ZW50Tm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSA9PT0gdGhpcy5jb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl9vcmlnaW5hbENvbnRlbnRQYXJ0KSB7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCA8ZGl2IHBhcnQ9XCJjb250ZW50XCI+XG4gICAgICB0aGlzLiQuY29udGVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLl9vcmlnaW5hbENvbnRlbnRQYXJ0LCB0aGlzLiQuY29udGVudCk7XG4gICAgICB0aGlzLiQuY29udGVudCA9IHRoaXMuX29yaWdpbmFsQ29udGVudFBhcnQ7XG4gICAgICB0aGlzLl9vcmlnaW5hbENvbnRlbnRQYXJ0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuX29ic2VydmVyLmNvbm5lY3QoKTtcblxuICAgIHRoaXMuX2NvbnRlbnROb2RlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRlbnQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3N0YW1wT3ZlcmxheVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgdGhpcy5fcmVtb3ZlT2xkQ29udGVudCgpO1xuXG4gICAgaWYgKCF0ZW1wbGF0ZS5fVGVtcGxhdGl6ZXIpIHtcbiAgICAgIHRlbXBsYXRlLl9UZW1wbGF0aXplciA9IHRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2luc3RhbmNlID0gbmV3IHRlbXBsYXRlLl9UZW1wbGF0aXplcih7fSk7XG4gICAgdGhpcy5fY29udGVudE5vZGVzID0gQXJyYXkuZnJvbSh0aGlzLl9pbnN0YW5jZS5yb290LmNoaWxkTm9kZXMpO1xuXG4gICAgY29uc3QgdGVtcGxhdGVSb290ID0gdGVtcGxhdGUuX3RlbXBsYXRlUm9vdCB8fCAodGVtcGxhdGUuX3RlbXBsYXRlUm9vdCA9IHRlbXBsYXRlLmdldFJvb3ROb2RlKCkpO1xuXG4gICAgaWYgKHRlbXBsYXRlUm9vdCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIGlmICghdGhpcy4kLmNvbnRlbnQuc2hhZG93Um9vdCkge1xuICAgICAgICB0aGlzLiQuY29udGVudC5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzY29wZUNzc1RleHQgPSBBcnJheS5mcm9tKHRlbXBsYXRlUm9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpKS5yZWR1Y2UoXG4gICAgICAgIChyZXN1bHQsIHN0eWxlKSA9PiByZXN1bHQgKyBzdHlsZS50ZXh0Q29udGVudCxcbiAgICAgICAgJycsXG4gICAgICApO1xuXG4gICAgICAvLyBUaGUgb3ZlcmxheSByb2904oCZcyA6aG9zdCBzdHlsZXMgc2hvdWxkIG5vdCBhcHBseSBpbnNpZGUgdGhlIG92ZXJsYXlcbiAgICAgIHNjb3BlQ3NzVGV4dCA9IHNjb3BlQ3NzVGV4dC5yZXBsYWNlKC86aG9zdC9nLCAnOmhvc3Qtbm9tYXRjaCcpO1xuXG4gICAgICBpZiAoc2NvcGVDc3NUZXh0KSB7XG4gICAgICAgIC8vIEFwcGVuZCBhIHN0eWxlIHRvIHRoZSBjb250ZW50IHNoYWRvd1Jvb3RcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHNjb3BlQ3NzVGV4dDtcbiAgICAgICAgdGhpcy4kLmNvbnRlbnQuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnROb2Rlcy51bnNoaWZ0KHN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kLmNvbnRlbnQuc2hhZG93Um9vdC5hcHBlbmRDaGlsZCh0aGlzLl9pbnN0YW5jZS5yb290KTtcbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuJC5jb250ZW50LnNoYWRvd1Jvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5faW5zdGFuY2Uucm9vdCk7XG4gICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfcmVtb3ZlTmV3UmVuZGVyZXJPclRlbXBsYXRlKHRlbXBsYXRlLCBvbGRUZW1wbGF0ZSwgcmVuZGVyZXIsIG9sZFJlbmRlcmVyKSB7XG4gICAgaWYgKHRlbXBsYXRlICE9PSBvbGRUZW1wbGF0ZSkge1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICE9PSBvbGRSZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcbiAgX3RlbXBsYXRlT3JSZW5kZXJlckNoYW5nZWQodGVtcGxhdGUsIHJlbmRlcmVyLCBvd25lciwgbW9kZWwsIG9wZW5lZCkge1xuICAgIGlmICh0ZW1wbGF0ZSAmJiByZW5kZXJlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTmV3UmVuZGVyZXJPclRlbXBsYXRlKHRlbXBsYXRlLCB0aGlzLl9vbGRUZW1wbGF0ZSwgcmVuZGVyZXIsIHRoaXMuX29sZFJlbmRlcmVyKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHNob3VsZCBvbmx5IHVzZSBlaXRoZXIgYSByZW5kZXJlciBvciBhIHRlbXBsYXRlIGZvciBvdmVybGF5IGNvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvd25lck9yTW9kZWxDaGFuZ2VkID0gdGhpcy5fb2xkT3duZXIgIT09IG93bmVyIHx8IHRoaXMuX29sZE1vZGVsICE9PSBtb2RlbDtcbiAgICB0aGlzLl9vbGRNb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuX29sZE93bmVyID0gb3duZXI7XG5cbiAgICBjb25zdCB0ZW1wbGF0ZUNoYW5nZWQgPSB0aGlzLl9vbGRUZW1wbGF0ZSAhPT0gdGVtcGxhdGU7XG4gICAgdGhpcy5fb2xkVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgIGNvbnN0IHJlbmRlcmVyQ2hhbmdlZCA9IHRoaXMuX29sZFJlbmRlcmVyICE9PSByZW5kZXJlcjtcbiAgICB0aGlzLl9vbGRSZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gICAgY29uc3Qgb3BlbmVkQ2hhbmdlZCA9IHRoaXMuX29sZE9wZW5lZCAhPT0gb3BlbmVkO1xuICAgIHRoaXMuX29sZE9wZW5lZCA9IG9wZW5lZDtcblxuICAgIGlmIChyZW5kZXJlckNoYW5nZWQpIHtcbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXM7XG4gICAgICB0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAvLyBXaGVuZXZlciBhIExpdC1iYXNlZCByZW5kZXJlciBpcyB1c2VkLCBpdCBhc3NpZ25zIGEgTGl0IHBhcnQgdG8gdGhlIG5vZGUgaXQgd2FzIHJlbmRlcmVkIGludG8uXG4gICAgICAvLyBXaGVuIGNsZWFyaW5nIHRoZSByZW5kZXJlZCBjb250ZW50LCB0aGlzIHBhcnQgbmVlZHMgdG8gYmUgbWFudWFsbHkgZGlzcG9zZWQgb2YuXG4gICAgICAvLyBPdGhlcndpc2UsIHVzaW5nIGEgTGl0LWJhc2VkIHJlbmRlcmVyIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gb3IgcmVuZGVyIG5vdGhpbmcgYWZ0ZXJ3YXJkLlxuICAgICAgZGVsZXRlIHRoaXMuY29udGVudC5fJGxpdFBhcnQkO1xuICAgIH1cblxuICAgIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3N0YW1wT3ZlcmxheVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9IGVsc2UgaWYgKHJlbmRlcmVyICYmIChyZW5kZXJlckNoYW5nZWQgfHwgb3BlbmVkQ2hhbmdlZCB8fCBvd25lck9yTW9kZWxDaGFuZ2VkKSkge1xuICAgICAgaWYgKG9wZW5lZCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RDb250ZW50VXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFFbGVtZW50fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudCgpIHtcbiAgICAvLyBEb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2FjdGl2ZUVsZW1lbnRcbiAgICBsZXQgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHdoaWxlIChhY3RpdmUuc2hhZG93Um9vdCAmJiBhY3RpdmUuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICBhY3RpdmUgPSBhY3RpdmUuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2RlZXBDb250YWlucyhub2RlKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnMobm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgbiA9IG5vZGU7XG4gICAgY29uc3QgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIC8vIFdhbGsgZnJvbSBub2RlIHRvIGB0aGlzYCBvciBgZG9jdW1lbnRgXG4gICAgd2hpbGUgKG4gJiYgbiAhPT0gZG9jICYmIG4gIT09IHRoaXMpIHtcbiAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgIH1cbiAgICByZXR1cm4gbiA9PT0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCcmluZ3MgdGhlIG92ZXJsYXkgYXMgdmlzdWFsbHkgdGhlIGZyb250bW9zdCBvbmVcbiAgICovXG4gIGJyaW5nVG9Gcm9udCgpIHtcbiAgICBsZXQgekluZGV4ID0gJyc7XG4gICAgY29uc3QgZnJvbnRtb3N0ID0gT3ZlcmxheS5fX2F0dGFjaGVkSW5zdGFuY2VzLmZpbHRlcigobykgPT4gbyAhPT0gdGhpcykucG9wKCk7XG4gICAgaWYgKGZyb250bW9zdCkge1xuICAgICAgY29uc3QgZnJvbnRtb3N0WkluZGV4ID0gZnJvbnRtb3N0Ll9fekluZGV4O1xuICAgICAgekluZGV4ID0gZnJvbnRtb3N0WkluZGV4ICsgMTtcbiAgICB9XG4gICAgdGhpcy5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG4gICAgdGhpcy5fX3pJbmRleCA9IHpJbmRleCB8fCBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUodGhpcykuekluZGV4KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoT3ZlcmxheS5pcywgT3ZlcmxheSk7XG5cbmV4cG9ydCB7IE92ZXJsYXkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/src/vaadin-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/theme/material/vaadin-overlay-styles.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/theme/material/vaadin-overlay-styles.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_vaadin_material_styles_mixins_overlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vaadin/vaadin-material-styles/mixins/overlay.js */ \"./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/overlay/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n\n\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.registerStyles)('vaadin-overlay', _vaadin_vaadin_material_styles_mixins_overlay_js__WEBPACK_IMPORTED_MODULE_0__.overlay, {\n  moduleId: 'material-vaadin-overlay'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1vdmVybGF5LXN0eWxlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLW92ZXJsYXktc3R5bGVzLmpzP2VjYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3ZlcmxheSB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLW1hdGVyaWFsLXN0eWxlcy9taXhpbnMvb3ZlcmxheS5qcyc7XG5pbXBvcnQgeyByZWdpc3RlclN0eWxlcyB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5cbnJlZ2lzdGVyU3R5bGVzKCd2YWFkaW4tb3ZlcmxheScsIG92ZXJsYXksIHsgbW9kdWxlSWQ6ICdtYXRlcmlhbC12YWFkaW4tb3ZlcmxheScgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/theme/material/vaadin-overlay-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/overlay/theme/material/vaadin-overlay.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/overlay/theme/material/vaadin-overlay.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vaadin_overlay_styles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-overlay-styles.js */ \"./node_modules/@vaadin/overlay/theme/material/vaadin-overlay-styles.js\");\n/* harmony import */ var _src_vaadin_overlay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/vaadin-overlay.js */ \"./node_modules/@vaadin/overlay/src/vaadin-overlay.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi9vdmVybGF5L3RoZW1lL21hdGVyaWFsL3ZhYWRpbi1vdmVybGF5LmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL292ZXJsYXkvdGhlbWUvbWF0ZXJpYWwvdmFhZGluLW92ZXJsYXkuanM/NzgzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vdmFhZGluLW92ZXJsYXktc3R5bGVzLmpzJztcbmltcG9ydCAnLi4vLi4vc3JjL3ZhYWRpbi1vdmVybGF5LmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/overlay/theme/material/vaadin-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/color.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/color.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"colorBase\": () => (/* binding */ colorBase),\n/* harmony export */   \"colorDark\": () => (/* binding */ colorDark),\n/* harmony export */   \"colorLight\": () => (/* binding */ colorLight)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"./node_modules/@vaadin/vaadin-material-styles/version.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\nconst colorLight = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  :host {\n    /* Text colors */\n    --material-body-text-color: var(--light-theme-text-color, rgba(0, 0, 0, 0.87));\n    --material-secondary-text-color: var(--light-theme-secondary-color, rgba(0, 0, 0, 0.54));\n    --material-disabled-text-color: var(--light-theme-disabled-color, rgba(0, 0, 0, 0.38));\n\n    /* Primary colors */\n    --material-primary-color: var(--primary-color, #6200ee);\n    --material-primary-contrast-color: var(--dark-theme-base-color, #fff);\n    --material-primary-text-color: var(--material-primary-color);\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #b00020);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--light-theme-background-color, #fff);\n    --material-secondary-background-color: var(--light-theme-secondary-background-color, #f5f5f5);\n    --material-disabled-color: rgba(0, 0, 0, 0.26);\n\n    /* Divider colors */\n    --material-divider-color: rgba(0, 0, 0, 0.12);\n\n    /* Undocumented internal properties (prefixed with three dashes) */\n\n    /* Text field tweaks */\n    --_material-text-field-input-line-background-color: initial;\n    --_material-text-field-input-line-opacity: initial;\n    --_material-text-field-input-line-hover-opacity: initial;\n    --_material-text-field-focused-label-opacity: initial;\n\n    /* Button tweaks */\n    --_material-button-raised-background-color: initial;\n    --_material-button-outline-color: initial;\n\n    /* Grid tweaks */\n    --_material-grid-row-hover-background-color: initial;\n\n    /* Split layout tweaks */\n    --_material-split-layout-splitter-background-color: initial;\n\n    background-color: var(--material-background-color);\n    color: var(--material-body-text-color);\n  }\n\n  [theme~='dark'] {\n    /* Text colors */\n    --material-body-text-color: var(--dark-theme-text-color, rgba(255, 255, 255, 1));\n    --material-secondary-text-color: var(--dark-theme-secondary-color, rgba(255, 255, 255, 0.7));\n    --material-disabled-text-color: var(--dark-theme-disabled-color, rgba(255, 255, 255, 0.5));\n\n    /* Primary colors */\n    --material-primary-color: var(--light-primary-color, #7e3ff2);\n    --material-primary-text-color: #b794f6;\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #de2839);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--dark-theme-background-color, #303030);\n    --material-secondary-background-color: var(--dark-theme-secondary-background-color, #3b3b3b);\n    --material-disabled-color: rgba(255, 255, 255, 0.3);\n\n    /* Divider colors */\n    --material-divider-color: rgba(255, 255, 255, 0.12);\n\n    /* Undocumented internal properties (prefixed with three dashes) */\n\n    /* Text field tweaks */\n    --_material-text-field-input-line-background-color: #fff;\n    --_material-text-field-input-line-opacity: 0.7;\n    --_material-text-field-input-line-hover-opacity: 1;\n    --_material-text-field-focused-label-opacity: 1;\n\n    /* Button tweaks */\n    --_material-button-raised-background-color: rgba(255, 255, 255, 0.08);\n    --_material-button-outline-color: rgba(255, 255, 255, 0.2);\n\n    /* Grid tweaks */\n    --_material-grid-row-hover-background-color: rgba(255, 255, 255, 0.08);\n    --_material-grid-row-selected-overlay-opacity: 0.16;\n\n    /* Split layout tweaks */\n    --_material-split-layout-splitter-background-color: rgba(255, 255, 255, 0.8);\n\n    background-color: var(--material-background-color);\n    color: var(--material-body-text-color);\n  }\n\n  a {\n    color: inherit;\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.registerStyles)('', colorLight, {\n  moduleId: 'material-color-light'\n});\nconst colorDark = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  :host {\n    /* Text colors */\n    --material-body-text-color: var(--dark-theme-text-color, rgba(255, 255, 255, 1));\n    --material-secondary-text-color: var(--dark-theme-secondary-color, rgba(255, 255, 255, 0.7));\n    --material-disabled-text-color: var(--dark-theme-disabled-color, rgba(255, 255, 255, 0.5));\n\n    /* Primary colors */\n    --material-primary-color: var(--light-primary-color, #7e3ff2);\n    --material-primary-text-color: #b794f6;\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #de2839);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--dark-theme-background-color, #303030);\n    --material-secondary-background-color: var(--dark-theme-secondary-background-color, #3b3b3b);\n    --material-disabled-color: rgba(255, 255, 255, 0.3);\n\n    /* Divider colors */\n    --material-divider-color: rgba(255, 255, 255, 0.12);\n\n    /* Undocumented internal properties (prefixed with three dashes) */\n\n    /* Text field tweaks */\n    --_material-text-field-input-line-background-color: #fff;\n    --_material-text-field-input-line-opacity: 0.7;\n    --_material-text-field-input-line-hover-opacity: 1;\n    --_material-text-field-focused-label-opacity: 1;\n\n    /* Button tweaks */\n    --_material-button-raised-background-color: rgba(255, 255, 255, 0.08);\n    --_material-button-outline-color: rgba(255, 255, 255, 0.2);\n\n    /* Grid tweaks */\n    --_material-grid-row-hover-background-color: rgba(255, 255, 255, 0.08);\n    --_material-grid-row-selected-overlay-opacity: 0.16;\n\n    /* Split layout tweaks */\n    --_material-split-layout-splitter-background-color: rgba(255, 255, 255, 0.8);\n\n    background-color: var(--material-background-color);\n    color: var(--material-body-text-color);\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.registerStyles)('', colorDark, {\n  moduleId: 'material-color-dark'\n});\nconst colorBase = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  :host {\n    /* Text colors */\n    --material-body-text-color: var(--light-theme-text-color, rgba(0, 0, 0, 0.87));\n    --material-secondary-text-color: var(--light-theme-secondary-color, rgba(0, 0, 0, 0.54));\n    --material-disabled-text-color: var(--light-theme-disabled-color, rgba(0, 0, 0, 0.38));\n\n    /* Primary colors */\n    --material-primary-color: var(--primary-color, #6200ee);\n    --material-primary-contrast-color: var(--dark-theme-base-color, #fff);\n    --material-primary-text-color: var(--material-primary-color);\n\n    /* Error colors */\n    --material-error-color: var(--error-color, #b00020);\n    --material-error-text-color: var(--material-error-color);\n\n    /* Background colors */\n    --material-background-color: var(--light-theme-background-color, #fff);\n    --material-secondary-background-color: var(--light-theme-secondary-background-color, #f5f5f5);\n    --material-disabled-color: rgba(0, 0, 0, 0.26);\n\n    /* Divider colors */\n    --material-divider-color: rgba(0, 0, 0, 0.12);\n  }\n`;\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${colorBase.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2NvbG9yLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL2NvbG9yLmpzPzVkY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgJy4vdmVyc2lvbi5qcyc7XG5pbXBvcnQgeyBjc3MsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuY29uc3QgY29sb3JMaWdodCA9IGNzc2BcbiAgOmhvc3Qge1xuICAgIC8qIFRleHQgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1ib2R5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXRleHQtY29sb3IsIHJnYmEoMCwgMCwgMCwgMC44NykpO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjU0KSk7XG4gICAgLS1tYXRlcmlhbC1kaXNhYmxlZC10ZXh0LWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1kaXNhYmxlZC1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjM4KSk7XG5cbiAgICAvKiBQcmltYXJ5IGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtcHJpbWFyeS1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvciwgIzYyMDBlZSk7XG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LWNvbnRyYXN0LWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLWJhc2UtY29sb3IsICNmZmYpO1xuICAgIC0tbWF0ZXJpYWwtcHJpbWFyeS10ZXh0LWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yKTtcblxuICAgIC8qIEVycm9yIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtZXJyb3ItY29sb3I6IHZhcigtLWVycm9yLWNvbG9yLCAjYjAwMDIwKTtcbiAgICAtLW1hdGVyaWFsLWVycm9yLXRleHQtY29sb3I6IHZhcigtLW1hdGVyaWFsLWVycm9yLWNvbG9yKTtcblxuICAgIC8qIEJhY2tncm91bmQgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKTtcbiAgICAtLW1hdGVyaWFsLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1zZWNvbmRhcnktYmFja2dyb3VuZC1jb2xvciwgI2Y1ZjVmNSk7XG4gICAgLS1tYXRlcmlhbC1kaXNhYmxlZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjI2KTtcblxuICAgIC8qIERpdmlkZXIgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1kaXZpZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMTIpO1xuXG4gICAgLyogVW5kb2N1bWVudGVkIGludGVybmFsIHByb3BlcnRpZXMgKHByZWZpeGVkIHdpdGggdGhyZWUgZGFzaGVzKSAqL1xuXG4gICAgLyogVGV4dCBmaWVsZCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtYmFja2dyb3VuZC1jb2xvcjogaW5pdGlhbDtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtb3BhY2l0eTogaW5pdGlhbDtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtaG92ZXItb3BhY2l0eTogaW5pdGlhbDtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWZvY3VzZWQtbGFiZWwtb3BhY2l0eTogaW5pdGlhbDtcblxuICAgIC8qIEJ1dHRvbiB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1idXR0b24tcmFpc2VkLWJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XG4gICAgLS1fbWF0ZXJpYWwtYnV0dG9uLW91dGxpbmUtY29sb3I6IGluaXRpYWw7XG5cbiAgICAvKiBHcmlkIHR3ZWFrcyAqL1xuICAgIC0tX21hdGVyaWFsLWdyaWQtcm93LWhvdmVyLWJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XG5cbiAgICAvKiBTcGxpdCBsYXlvdXQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtc3BsaXQtbGF5b3V0LXNwbGl0dGVyLWJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgICBjb2xvcjogdmFyKC0tbWF0ZXJpYWwtYm9keS10ZXh0LWNvbG9yKTtcbiAgfVxuXG4gIFt0aGVtZX49J2RhcmsnXSB7XG4gICAgLyogVGV4dCBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWJvZHktdGV4dC1jb2xvcjogdmFyKC0tZGFyay10aGVtZS10ZXh0LWNvbG9yLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDEpKTtcbiAgICAtLW1hdGVyaWFsLXNlY29uZGFyeS10ZXh0LWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLXNlY29uZGFyeS1jb2xvciwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpKTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLXRleHQtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtZGlzYWJsZWQtY29sb3IsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSk7XG5cbiAgICAvKiBQcmltYXJ5IGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtcHJpbWFyeS1jb2xvcjogdmFyKC0tbGlnaHQtcHJpbWFyeS1jb2xvciwgIzdlM2ZmMik7XG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LXRleHQtY29sb3I6ICNiNzk0ZjY7XG5cbiAgICAvKiBFcnJvciBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWVycm9yLWNvbG9yOiB2YXIoLS1lcnJvci1jb2xvciwgI2RlMjgzOSk7XG4gICAgLS1tYXRlcmlhbC1lcnJvci10ZXh0LWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1lcnJvci1jb2xvcik7XG5cbiAgICAvKiBCYWNrZ3JvdW5kIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZGFyay10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yLCAjMzAzMDMwKTtcbiAgICAtLW1hdGVyaWFsLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yLCAjM2IzYjNiKTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG5cbiAgICAvKiBEaXZpZGVyIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtZGl2aWRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKTtcblxuICAgIC8qIFVuZG9jdW1lbnRlZCBpbnRlcm5hbCBwcm9wZXJ0aWVzIChwcmVmaXhlZCB3aXRoIHRocmVlIGRhc2hlcykgKi9cblxuICAgIC8qIFRleHQgZmllbGQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtdGV4dC1maWVsZC1pbnB1dC1saW5lLWJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgLS1fbWF0ZXJpYWwtdGV4dC1maWVsZC1pbnB1dC1saW5lLW9wYWNpdHk6IDAuNztcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtaG92ZXItb3BhY2l0eTogMTtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWZvY3VzZWQtbGFiZWwtb3BhY2l0eTogMTtcblxuICAgIC8qIEJ1dHRvbiB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1idXR0b24tcmFpc2VkLWJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOCk7XG4gICAgLS1fbWF0ZXJpYWwtYnV0dG9uLW91dGxpbmUtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcblxuICAgIC8qIEdyaWQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtZ3JpZC1yb3ctaG92ZXItYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KTtcbiAgICAtLV9tYXRlcmlhbC1ncmlkLXJvdy1zZWxlY3RlZC1vdmVybGF5LW9wYWNpdHk6IDAuMTY7XG5cbiAgICAvKiBTcGxpdCBsYXlvdXQgdHdlYWtzICovXG4gICAgLS1fbWF0ZXJpYWwtc3BsaXQtbGF5b3V0LXNwbGl0dGVyLWJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLW1hdGVyaWFsLWJhY2tncm91bmQtY29sb3IpO1xuICAgIGNvbG9yOiB2YXIoLS1tYXRlcmlhbC1ib2R5LXRleHQtY29sb3IpO1xuICB9XG5cbiAgYSB7XG4gICAgY29sb3I6IGluaGVyaXQ7XG4gIH1cbmA7XG5cbnJlZ2lzdGVyU3R5bGVzKCcnLCBjb2xvckxpZ2h0LCB7IG1vZHVsZUlkOiAnbWF0ZXJpYWwtY29sb3ItbGlnaHQnIH0pO1xuXG5jb25zdCBjb2xvckRhcmsgPSBjc3NgXG4gIDpob3N0IHtcbiAgICAvKiBUZXh0IGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtYm9keS10ZXh0LWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLXRleHQtY29sb3IsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMSkpO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LXRleHQtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWNvbG9yLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNykpO1xuICAgIC0tbWF0ZXJpYWwtZGlzYWJsZWQtdGV4dC1jb2xvcjogdmFyKC0tZGFyay10aGVtZS1kaXNhYmxlZC1jb2xvciwgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpKTtcblxuICAgIC8qIFByaW1hcnkgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1saWdodC1wcmltYXJ5LWNvbG9yLCAjN2UzZmYyKTtcbiAgICAtLW1hdGVyaWFsLXByaW1hcnktdGV4dC1jb2xvcjogI2I3OTRmNjtcblxuICAgIC8qIEVycm9yIGNvbG9ycyAqL1xuICAgIC0tbWF0ZXJpYWwtZXJyb3ItY29sb3I6IHZhcigtLWVycm9yLWNvbG9yLCAjZGUyODM5KTtcbiAgICAtLW1hdGVyaWFsLWVycm9yLXRleHQtY29sb3I6IHZhcigtLW1hdGVyaWFsLWVycm9yLWNvbG9yKTtcblxuICAgIC8qIEJhY2tncm91bmQgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLWJhY2tncm91bmQtY29sb3IsICMzMDMwMzApO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LWJhY2tncm91bmQtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWJhY2tncm91bmQtY29sb3IsICMzYjNiM2IpO1xuICAgIC0tbWF0ZXJpYWwtZGlzYWJsZWQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcblxuICAgIC8qIERpdmlkZXIgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1kaXZpZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpO1xuXG4gICAgLyogVW5kb2N1bWVudGVkIGludGVybmFsIHByb3BlcnRpZXMgKHByZWZpeGVkIHdpdGggdGhyZWUgZGFzaGVzKSAqL1xuXG4gICAgLyogVGV4dCBmaWVsZCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgICAtLV9tYXRlcmlhbC10ZXh0LWZpZWxkLWlucHV0LWxpbmUtb3BhY2l0eTogMC43O1xuICAgIC0tX21hdGVyaWFsLXRleHQtZmllbGQtaW5wdXQtbGluZS1ob3Zlci1vcGFjaXR5OiAxO1xuICAgIC0tX21hdGVyaWFsLXRleHQtZmllbGQtZm9jdXNlZC1sYWJlbC1vcGFjaXR5OiAxO1xuXG4gICAgLyogQnV0dG9uIHR3ZWFrcyAqL1xuICAgIC0tX21hdGVyaWFsLWJ1dHRvbi1yYWlzZWQtYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KTtcbiAgICAtLV9tYXRlcmlhbC1idXR0b24tb3V0bGluZS1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuXG4gICAgLyogR3JpZCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1ncmlkLXJvdy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDgpO1xuICAgIC0tX21hdGVyaWFsLWdyaWQtcm93LXNlbGVjdGVkLW92ZXJsYXktb3BhY2l0eTogMC4xNjtcblxuICAgIC8qIFNwbGl0IGxheW91dCB0d2Vha3MgKi9cbiAgICAtLV9tYXRlcmlhbC1zcGxpdC1sYXlvdXQtc3BsaXR0ZXItYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbWF0ZXJpYWwtYmFja2dyb3VuZC1jb2xvcik7XG4gICAgY29sb3I6IHZhcigtLW1hdGVyaWFsLWJvZHktdGV4dC1jb2xvcik7XG4gIH1cbmA7XG5cbnJlZ2lzdGVyU3R5bGVzKCcnLCBjb2xvckRhcmssIHsgbW9kdWxlSWQ6ICdtYXRlcmlhbC1jb2xvci1kYXJrJyB9KTtcblxuY29uc3QgY29sb3JCYXNlID0gY3NzYFxuICA6aG9zdCB7XG4gICAgLyogVGV4dCBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWJvZHktdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvciwgcmdiYSgwLCAwLCAwLCAwLjg3KSk7XG4gICAgLS1tYXRlcmlhbC1zZWNvbmRhcnktdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtc2Vjb25kYXJ5LWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuNTQpKTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yLCByZ2JhKDAsIDAsIDAsIDAuMzgpKTtcblxuICAgIC8qIFByaW1hcnkgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yLCAjNjIwMGVlKTtcbiAgICAtLW1hdGVyaWFsLXByaW1hcnktY29udHJhc3QtY29sb3I6IHZhcigtLWRhcmstdGhlbWUtYmFzZS1jb2xvciwgI2ZmZik7XG4gICAgLS1tYXRlcmlhbC1wcmltYXJ5LXRleHQtY29sb3I6IHZhcigtLW1hdGVyaWFsLXByaW1hcnktY29sb3IpO1xuXG4gICAgLyogRXJyb3IgY29sb3JzICovXG4gICAgLS1tYXRlcmlhbC1lcnJvci1jb2xvcjogdmFyKC0tZXJyb3ItY29sb3IsICNiMDAwMjApO1xuICAgIC0tbWF0ZXJpYWwtZXJyb3ItdGV4dC1jb2xvcjogdmFyKC0tbWF0ZXJpYWwtZXJyb3ItY29sb3IpO1xuXG4gICAgLyogQmFja2dyb3VuZCBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWJhY2tncm91bmQtY29sb3IsICNmZmYpO1xuICAgIC0tbWF0ZXJpYWwtc2Vjb25kYXJ5LWJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1iYWNrZ3JvdW5kLWNvbG9yLCAjZjVmNWY1KTtcbiAgICAtLW1hdGVyaWFsLWRpc2FibGVkLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMjYpO1xuXG4gICAgLyogRGl2aWRlciBjb2xvcnMgKi9cbiAgICAtLW1hdGVyaWFsLWRpdmlkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xMik7XG4gIH1cbmA7XG5cbmNvbnN0ICR0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuJHRwbC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7Y29sb3JCYXNlLnRvU3RyaW5nKCkucmVwbGFjZSgnOmhvc3QnLCAnaHRtbCcpfTwvc3R5bGU+YDtcbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJHRwbC5jb250ZW50KTtcblxuZXhwb3J0IHsgY29sb3JCYXNlLCBjb2xvckRhcmssIGNvbG9yTGlnaHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/color.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/mixins/loader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/mixins/loader.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loader\": () => (/* binding */ loader)\n/* harmony export */ });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\nconst loader = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  [part~='loader'] {\n    height: 2px;\n    background: var(--material-background-color)\n      linear-gradient(\n        90deg,\n        transparent 0%,\n        transparent 20%,\n        var(--material-primary-color) 20%,\n        var(--material-primary-color) 40%,\n        transparent 40%,\n        transparent 60%,\n        var(--material-primary-color) 60%,\n        var(--material-primary-color) 80%,\n        transparent 80%,\n        transparent 100%\n      )\n      0 0 / 400% 100% repeat-x;\n    opacity: 0;\n  }\n\n  :host(:not([loading])) [part~='loader'] {\n    display: none;\n  }\n\n  :host([loading]) [part='loader'] {\n    animation: 3s linear infinite material-loader-progress, 0.3s 0.1s both material-loader-fade-in;\n  }\n\n  [part='loader']::before {\n    content: '';\n    display: block;\n    height: 100%;\n    opacity: 0.16;\n    background: var(--material-primary-color);\n  }\n\n  @keyframes material-loader-fade-in {\n    0% {\n      opacity: 0;\n    }\n\n    100% {\n      opacity: 1;\n    }\n  }\n\n  @keyframes material-loader-progress {\n    0% {\n      background-position: 0 0;\n      background-size: 300% 100%;\n    }\n\n    33% {\n      background-position: -100% 0;\n      background-size: 400% 100%;\n    }\n\n    67% {\n      background-position: -200% 0;\n      background-size: 250% 100%;\n    }\n\n    100% {\n      background-position: -300% 0;\n      background-size: 300% 100%;\n    }\n  }\n\n  /* RTL specific styles */\n\n  @keyframes material-loader-progress-rtl {\n    0% {\n      background-position: 100% 0;\n      background-size: 300% 100%;\n    }\n\n    33% {\n      background-position: 200% 0;\n      background-size: 400% 100%;\n    }\n\n    67% {\n      background-position: 300% 0;\n      background-size: 250% 100%;\n    }\n\n    100% {\n      background-position: 400% 0;\n      background-size: 300% 100%;\n    }\n  }\n\n  :host([loading][dir='rtl']) [part='loader'] {\n    animation: 3s linear infinite material-loader-progress-rtl, 0.3s 0.1s both material-loader-fade-in;\n  }\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9sb2FkZXIuanM/NDg3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0ICcuLi9jb2xvci5qcyc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanMnO1xuXG5jb25zdCBsb2FkZXIgPSBjc3NgXG4gIFtwYXJ0fj0nbG9hZGVyJ10ge1xuICAgIGhlaWdodDogMnB4O1xuICAgIGJhY2tncm91bmQ6IHZhcigtLW1hdGVyaWFsLWJhY2tncm91bmQtY29sb3IpXG4gICAgICBsaW5lYXItZ3JhZGllbnQoXG4gICAgICAgIDkwZGVnLFxuICAgICAgICB0cmFuc3BhcmVudCAwJSxcbiAgICAgICAgdHJhbnNwYXJlbnQgMjAlLFxuICAgICAgICB2YXIoLS1tYXRlcmlhbC1wcmltYXJ5LWNvbG9yKSAyMCUsXG4gICAgICAgIHZhcigtLW1hdGVyaWFsLXByaW1hcnktY29sb3IpIDQwJSxcbiAgICAgICAgdHJhbnNwYXJlbnQgNDAlLFxuICAgICAgICB0cmFuc3BhcmVudCA2MCUsXG4gICAgICAgIHZhcigtLW1hdGVyaWFsLXByaW1hcnktY29sb3IpIDYwJSxcbiAgICAgICAgdmFyKC0tbWF0ZXJpYWwtcHJpbWFyeS1jb2xvcikgODAlLFxuICAgICAgICB0cmFuc3BhcmVudCA4MCUsXG4gICAgICAgIHRyYW5zcGFyZW50IDEwMCVcbiAgICAgIClcbiAgICAgIDAgMCAvIDQwMCUgMTAwJSByZXBlYXQteDtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG5cbiAgOmhvc3QoOm5vdChbbG9hZGluZ10pKSBbcGFydH49J2xvYWRlciddIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgOmhvc3QoW2xvYWRpbmddKSBbcGFydD0nbG9hZGVyJ10ge1xuICAgIGFuaW1hdGlvbjogM3MgbGluZWFyIGluZmluaXRlIG1hdGVyaWFsLWxvYWRlci1wcm9ncmVzcywgMC4zcyAwLjFzIGJvdGggbWF0ZXJpYWwtbG9hZGVyLWZhZGUtaW47XG4gIH1cblxuICBbcGFydD0nbG9hZGVyJ106OmJlZm9yZSB7XG4gICAgY29udGVudDogJyc7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIG9wYWNpdHk6IDAuMTY7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tbWF0ZXJpYWwtcHJpbWFyeS1jb2xvcik7XG4gIH1cblxuICBAa2V5ZnJhbWVzIG1hdGVyaWFsLWxvYWRlci1mYWRlLWluIHtcbiAgICAwJSB7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgIH1cblxuICAgIDEwMCUge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG4gIH1cblxuICBAa2V5ZnJhbWVzIG1hdGVyaWFsLWxvYWRlci1wcm9ncmVzcyB7XG4gICAgMCUge1xuICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiAzMDAlIDEwMCU7XG4gICAgfVxuXG4gICAgMzMlIHtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IC0xMDAlIDA7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6IDQwMCUgMTAwJTtcbiAgICB9XG5cbiAgICA2NyUge1xuICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTIwMCUgMDtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogMjUwJSAxMDAlO1xuICAgIH1cblxuICAgIDEwMCUge1xuICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogLTMwMCUgMDtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogMzAwJSAxMDAlO1xuICAgIH1cbiAgfVxuXG4gIC8qIFJUTCBzcGVjaWZpYyBzdHlsZXMgKi9cblxuICBAa2V5ZnJhbWVzIG1hdGVyaWFsLWxvYWRlci1wcm9ncmVzcy1ydGwge1xuICAgIDAlIHtcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDEwMCUgMDtcbiAgICAgIGJhY2tncm91bmQtc2l6ZTogMzAwJSAxMDAlO1xuICAgIH1cblxuICAgIDMzJSB7XG4gICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiAyMDAlIDA7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6IDQwMCUgMTAwJTtcbiAgICB9XG5cbiAgICA2NyUge1xuICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMzAwJSAwO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiAyNTAlIDEwMCU7XG4gICAgfVxuXG4gICAgMTAwJSB7XG4gICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiA0MDAlIDA7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6IDMwMCUgMTAwJTtcbiAgICB9XG4gIH1cblxuICA6aG9zdChbbG9hZGluZ11bZGlyPSdydGwnXSkgW3BhcnQ9J2xvYWRlciddIHtcbiAgICBhbmltYXRpb246IDNzIGxpbmVhciBpbmZpbml0ZSBtYXRlcmlhbC1sb2FkZXItcHJvZ3Jlc3MtcnRsLCAwLjNzIDAuMXMgYm90aCBtYXRlcmlhbC1sb2FkZXItZmFkZS1pbjtcbiAgfVxuYDtcblxuZXhwb3J0IHsgbG9hZGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/mixins/loader.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"menuOverlay\": () => (/* binding */ menuOverlay)\n/* harmony export */ });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overlay.js */ \"./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\nconst menuOverlay = _overlay_js__WEBPACK_IMPORTED_MODULE_2__.overlay;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.registerStyles)('', menuOverlay, {\n  moduleId: 'material-menu-overlay'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9tZW51LW92ZXJsYXkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9tZW51LW92ZXJsYXkuanM/MzYyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCAnLi4vY29sb3IuanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJTdHlsZXMgfSBmcm9tICdAdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanMnO1xuaW1wb3J0IHsgb3ZlcmxheSB9IGZyb20gJy4vb3ZlcmxheS5qcyc7XG5cbmNvbnN0IG1lbnVPdmVybGF5ID0gb3ZlcmxheTtcblxucmVnaXN0ZXJTdHlsZXMoJycsIG1lbnVPdmVybGF5LCB7IG1vZHVsZUlkOiAnbWF0ZXJpYWwtbWVudS1vdmVybGF5JyB9KTtcblxuZXhwb3J0IHsgbWVudU92ZXJsYXkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/mixins/menu-overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"overlay\": () => (/* binding */ overlay)\n/* harmony export */ });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ \"./node_modules/@vaadin/vaadin-material-styles/color.js\");\n/* harmony import */ var _typography_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typography.js */ \"./node_modules/@vaadin/vaadin-material-styles/typography.js\");\n/* harmony import */ var _shadow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shadow.js */ \"./node_modules/@vaadin/vaadin-material-styles/shadow.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\nconst overlay = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.css`\n  :host {\n    top: 16px;\n    right: 16px;\n    /* TODO (@jouni): remove unnecessary multiplication after https://github.com/vaadin/vaadin-overlay/issues/90 is fixed */\n    bottom: calc(1px * var(--vaadin-overlay-viewport-bottom) + 16px);\n    left: 16px;\n  }\n\n  [part='overlay'] {\n    background-color: var(--material-background-color);\n    border-radius: 4px;\n    box-shadow: var(--material-shadow-elevation-4dp);\n    color: var(--material-body-text-color);\n    font-family: var(--material-font-family);\n    font-size: var(--material-body-font-size);\n    font-weight: 400;\n  }\n\n  [part='content'] {\n    padding: 8px 0;\n  }\n\n  [part='backdrop'] {\n    opacity: 0.2;\n    animation: 0.2s vaadin-overlay-backdrop-enter;\n    will-change: opacity;\n  }\n\n  @keyframes vaadin-overlay-backdrop-enter {\n    0% {\n      opacity: 0;\n    }\n  }\n`;\n(0,_vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_3__.registerStyles)('', overlay, {\n  moduleId: 'material-overlay'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9vdmVybGF5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL21peGlucy9vdmVybGF5LmpzPzU4YjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgJy4uL2NvbG9yLmpzJztcbmltcG9ydCAnLi4vdHlwb2dyYXBoeS5qcyc7XG5pbXBvcnQgJy4uL3NoYWRvdy5qcyc7XG5pbXBvcnQgeyBjc3MsIHJlZ2lzdGVyU3R5bGVzIH0gZnJvbSAnQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcblxuY29uc3Qgb3ZlcmxheSA9IGNzc2BcbiAgOmhvc3Qge1xuICAgIHRvcDogMTZweDtcbiAgICByaWdodDogMTZweDtcbiAgICAvKiBUT0RPIChAam91bmkpOiByZW1vdmUgdW5uZWNlc3NhcnkgbXVsdGlwbGljYXRpb24gYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL3ZhYWRpbi92YWFkaW4tb3ZlcmxheS9pc3N1ZXMvOTAgaXMgZml4ZWQgKi9cbiAgICBib3R0b206IGNhbGMoMXB4ICogdmFyKC0tdmFhZGluLW92ZXJsYXktdmlld3BvcnQtYm90dG9tKSArIDE2cHgpO1xuICAgIGxlZnQ6IDE2cHg7XG4gIH1cblxuICBbcGFydD0nb3ZlcmxheSddIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1tYXRlcmlhbC1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYm94LXNoYWRvdzogdmFyKC0tbWF0ZXJpYWwtc2hhZG93LWVsZXZhdGlvbi00ZHApO1xuICAgIGNvbG9yOiB2YXIoLS1tYXRlcmlhbC1ib2R5LXRleHQtY29sb3IpO1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1tYXRlcmlhbC1mb250LWZhbWlseSk7XG4gICAgZm9udC1zaXplOiB2YXIoLS1tYXRlcmlhbC1ib2R5LWZvbnQtc2l6ZSk7XG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgfVxuXG4gIFtwYXJ0PSdjb250ZW50J10ge1xuICAgIHBhZGRpbmc6IDhweCAwO1xuICB9XG5cbiAgW3BhcnQ9J2JhY2tkcm9wJ10ge1xuICAgIG9wYWNpdHk6IDAuMjtcbiAgICBhbmltYXRpb246IDAuMnMgdmFhZGluLW92ZXJsYXktYmFja2Ryb3AtZW50ZXI7XG4gICAgd2lsbC1jaGFuZ2U6IG9wYWNpdHk7XG4gIH1cblxuICBAa2V5ZnJhbWVzIHZhYWRpbi1vdmVybGF5LWJhY2tkcm9wLWVudGVyIHtcbiAgICAwJSB7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbiAgfVxuYDtcblxucmVnaXN0ZXJTdHlsZXMoJycsIG92ZXJsYXksIHsgbW9kdWxlSWQ6ICdtYXRlcmlhbC1vdmVybGF5JyB9KTtcblxuZXhwb3J0IHsgb3ZlcmxheSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/mixins/overlay.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemableMixin\": () => (/* binding */ ThemableMixin),\n/* harmony export */   \"__themeRegistry\": () => (/* binding */ themeRegistry),\n/* harmony export */   \"css\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* binding */ registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/@vaadin/vaadin-material-styles/node_modules/lit/index.js\");\n/* harmony import */ var _vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-theme-property-mixin.js */ \"./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nfunction registerStyles(themeFor, styles, options = {}) {\n  if (themeFor) {\n    if (hasThemes(themeFor)) {\n      console.warn(`The custom element definition for \"${themeFor}\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element.`);\n    }\n  }\n  styles = flattenStyles(styles);\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId\n    });\n  }\n}\n\n/**\n * Returns all registered themes. By default the themeRegistry is returned as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  }\n  return themeRegistry;\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some(themeForToken => {\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`).test(tagName);\n  });\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\n    includePriority = 1;\n  } else if (moduleName.startsWith('vaadin-')) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\nfunction flattenStyles(styles = []) {\n  return [styles].flat(Infinity).filter(style => {\n    if (style instanceof lit__WEBPACK_IMPORTED_MODULE_0__.CSSResult) {\n      return true;\n    }\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n    return false;\n  });\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach(includeModuleId => {\n      const includedTheme = getAllThemes().find(s => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = styles.map(style => style.cssText).join('\\n');\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = `${tagName}-default-theme`;\n  const themes = getAllThemes()\n  // Filter by matching themeFor properties\n  .filter(theme => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map(theme => ({\n    ...theme,\n    // Prepend styles from included themes\n    styles: [...getIncludedStyles(theme), ...theme.styles],\n    // Map moduleId to includePriority\n    includePriority: getIncludePriority(theme.moduleId)\n  }))\n  // Sort by includePriority\n  .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n  if (themes.length > 0) {\n    return themes;\n  }\n  // No theme modules found, return the default module if it exists\n  return getAllThemes().filter(theme => theme.moduleId === defaultModuleName);\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction hasThemes(tagName) {\n  return classHasThemes(customElements.get(tagName));\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {Function} elementClass\n * @returns {boolean}\n */\nfunction classHasThemes(elementClass) {\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nconst ThemableMixin = superClass => class VaadinThemableMixin extends (0,_vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ThemePropertyMixin)(superClass) {\n  /**\n   * Covers PolymerElement based component styling\n   * @protected\n   */\n  static finalize() {\n    super.finalize();\n\n    // Make sure not to run the logic intended for PolymerElement when LitElement is used.\n    if (this.elementStyles) {\n      return;\n    }\n    const template = this.prototype._template;\n    if (!template || classHasThemes(this)) {\n      return;\n    }\n    addStylesToTemplate(this.getStylesForThis(), template);\n  }\n\n  /**\n   * Covers LitElement based component styling\n   *\n   * @protected\n   */\n  static finalizeStyles(styles) {\n    // The \"styles\" object originates from the \"static get styles()\" function of\n    // a LitElement based component. The theme styles are added after it\n    // so that they can override the component styles.\n    const themeStyles = this.getStylesForThis();\n    return styles ? [...super.finalizeStyles(styles), ...themeStyles] : themeStyles;\n  }\n\n  /**\n   * Get styles for the component type\n   *\n   * @private\n   */\n  static getStylesForThis() {\n    const parent = Object.getPrototypeOf(this.prototype);\n    const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\n    this.__themes = [...inheritedThemes, ...getThemes(this.is)];\n    const themeStyles = this.__themes.flatMap(theme => theme.styles);\n    // Remove duplicates\n    return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcz9mNTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuaW1wb3J0IHsgY3NzLCBDU1NSZXN1bHQsIHVuc2FmZUNTUyB9IGZyb20gJ2xpdCc7XG5pbXBvcnQgeyBUaGVtZVByb3BlcnR5TWl4aW4gfSBmcm9tICcuL3ZhYWRpbi10aGVtZS1wcm9wZXJ0eS1taXhpbi5qcyc7XG5cbmV4cG9ydCB7IGNzcywgdW5zYWZlQ1NTIH07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGhlbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aGVtZUZvclxuICogQHByb3BlcnR5IHtDU1NSZXN1bHRbXX0gc3R5bGVzXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IHN0cmluZ1tdfSBbaW5jbHVkZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbW9kdWxlSWRdXG4gKlxuICogQHR5cGVkZWYge0NTU1Jlc3VsdFtdIHwgQ1NTUmVzdWx0fSBDU1NSZXN1bHRHcm91cFxuICovXG5cbi8qKlxuICogQHR5cGUge1RoZW1lW119XG4gKi9cbmNvbnN0IHRoZW1lUmVnaXN0cnkgPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgQ1NTIHN0eWxlcyBmb3IgYSBjb21wb25lbnQgdHlwZS4gTWFrZSBzdXJlIHRvIHJlZ2lzdGVyIHRoZSBzdHlsZXMgYmVmb3JlXG4gKiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgb2YgdGhlIHR5cGUgaXMgYXR0YWNoZWQgdG8gRE9NLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZUZvciBUaGUgbG9jYWwvdGFnIG5hbWUgb2YgdGhlIGNvbXBvbmVudCB0eXBlIHRvIHJlZ2lzdGVyIHRoZSBzdHlsZXMgZm9yXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdEdyb3VwfSBzdHlsZXMgVGhlIENTUyBzdHlsZSBydWxlcyB0byBiZSByZWdpc3RlcmVkIGZvciB0aGUgY29tcG9uZW50IHR5cGVcbiAqIG1hdGNoaW5nIHRoZW1lRm9yIGFuZCBpbmNsdWRlZCBpbiB0aGUgbG9jYWwgc2NvcGUgb2YgZWFjaCBjb21wb25lbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7e21vZHVsZUlkPzogc3RyaW5nLCBpbmNsdWRlPzogc3RyaW5nIHwgc3RyaW5nW119fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKHRoZW1lRm9yLCBzdHlsZXMsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodGhlbWVGb3IpIHtcbiAgICBpZiAoaGFzVGhlbWVzKHRoZW1lRm9yKSkge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgY3VzdG9tIGVsZW1lbnQgZGVmaW5pdGlvbiBmb3IgXCIke3RoZW1lRm9yfVwiXG4gICAgICB3YXMgZmluYWxpemVkIGJlZm9yZSBhIHN0eWxlIG1vZHVsZSB3YXMgcmVnaXN0ZXJlZC5cbiAgICAgIE1ha2Ugc3VyZSB0byBhZGQgY29tcG9uZW50IHNwZWNpZmljIHN0eWxlIG1vZHVsZXMgYmVmb3JlXG4gICAgICBpbXBvcnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgfVxuICB9XG5cbiAgc3R5bGVzID0gZmxhdHRlblN0eWxlcyhzdHlsZXMpO1xuXG4gIGlmICh3aW5kb3cuVmFhZGluICYmIHdpbmRvdy5WYWFkaW4uc3R5bGVNb2R1bGVzKSB7XG4gICAgd2luZG93LlZhYWRpbi5zdHlsZU1vZHVsZXMucmVnaXN0ZXJTdHlsZXModGhlbWVGb3IsIHN0eWxlcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhlbWVSZWdpc3RyeS5wdXNoKHtcbiAgICAgIHRoZW1lRm9yLFxuICAgICAgc3R5bGVzLFxuICAgICAgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlLFxuICAgICAgbW9kdWxlSWQ6IG9wdGlvbnMubW9kdWxlSWQsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIHRoZW1lcy4gQnkgZGVmYXVsdCB0aGUgdGhlbWVSZWdpc3RyeSBpcyByZXR1cm5lZCBhcyBpcy5cbiAqIEluIGNhc2UgdGhlIHN0eWxlLW1vZHVsZXMgYWRhcHRlciBpcyBpbXBvcnRlZCwgdGhlIHRoZW1lcyBhcmUgb2J0YWluZWQgZnJvbSB0aGVyZSBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7VGhlbWVbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsVGhlbWVzKCkge1xuICBpZiAod2luZG93LlZhYWRpbiAmJiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcykge1xuICAgIHJldHVybiB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcy5nZXRBbGxUaGVtZXMoKTtcbiAgfVxuICByZXR1cm4gdGhlbWVSZWdpc3RyeTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRoZW1lRm9yIHN0cmluZyBtYXRjaGVzIHRoZSB0YWcgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lRm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNUaGVtZUZvcih0aGVtZUZvciwgdGFnTmFtZSkge1xuICByZXR1cm4gKHRoZW1lRm9yIHx8ICcnKS5zcGxpdCgnICcpLnNvbWUoKHRoZW1lRm9yVG9rZW4pID0+IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGhlbWVGb3JUb2tlbi5zcGxpdCgnKicpLmpvaW4oJy4qJyl9JGApLnRlc3QodGFnTmFtZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hcHMgdGhlIG1vZHVsZU5hbWUgdG8gYW4gaW5jbHVkZSBwcmlvcml0eSBudW1iZXIgd2hpY2ggaXMgdXNlZCBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBvcmRlciBpbiB3aGljaCBzdHlsZXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0SW5jbHVkZVByaW9yaXR5KG1vZHVsZU5hbWUgPSAnJykge1xuICBsZXQgaW5jbHVkZVByaW9yaXR5ID0gMDtcbiAgaWYgKG1vZHVsZU5hbWUuc3RhcnRzV2l0aCgnbHVtby0nKSB8fCBtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ21hdGVyaWFsLScpKSB7XG4gICAgaW5jbHVkZVByaW9yaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChtb2R1bGVOYW1lLnN0YXJ0c1dpdGgoJ3ZhYWRpbi0nKSkge1xuICAgIGluY2x1ZGVQcmlvcml0eSA9IDI7XG4gIH1cbiAgcmV0dXJuIGluY2x1ZGVQcmlvcml0eTtcbn1cblxuLyoqXG4gKiBGbGF0dGVucyB0aGUgc3R5bGVzIGludG8gYSBzaW5nbGUgYXJyYXkgb2Ygc3R5bGVzLlxuICogQHBhcmFtIHtDU1NSZXN1bHRHcm91cH0gc3R5bGVzXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdFtdfSByZXN1bHRcbiAqIEByZXR1cm5zIHtDU1NSZXN1bHRbXX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhzdHlsZXMgPSBbXSkge1xuICByZXR1cm4gW3N0eWxlc10uZmxhdChJbmZpbml0eSkuZmlsdGVyKChzdHlsZSkgPT4ge1xuICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIENTU1Jlc3VsdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybignQW4gaXRlbSBpbiBzdHlsZXMgaXMgbm90IG9mIHR5cGUgQ1NTUmVzdWx0LiBVc2UgYHVuc2FmZUNTU2Agb3IgYGNzc2AuJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGFycmF5IG9mIENTU1Jlc3VsdHMgbWF0Y2hpbmcgdGhlIGluY2x1ZGUgcHJvcGVydHkgb2YgdGhlIHRoZW1lLlxuICogQHBhcmFtIHtUaGVtZX0gdGhlbWVcbiAqIEByZXR1cm5zIHtDU1NSZXN1bHRbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0SW5jbHVkZWRTdHlsZXModGhlbWUpIHtcbiAgY29uc3QgaW5jbHVkZWRTdHlsZXMgPSBbXTtcbiAgaWYgKHRoZW1lLmluY2x1ZGUpIHtcbiAgICBbXS5jb25jYXQodGhlbWUuaW5jbHVkZSkuZm9yRWFjaCgoaW5jbHVkZU1vZHVsZUlkKSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlZFRoZW1lID0gZ2V0QWxsVGhlbWVzKCkuZmluZCgocykgPT4gcy5tb2R1bGVJZCA9PT0gaW5jbHVkZU1vZHVsZUlkKTtcbiAgICAgIGlmIChpbmNsdWRlZFRoZW1lKSB7XG4gICAgICAgIGluY2x1ZGVkU3R5bGVzLnB1c2goLi4uZ2V0SW5jbHVkZWRTdHlsZXMoaW5jbHVkZWRUaGVtZSksIC4uLmluY2x1ZGVkVGhlbWUuc3R5bGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW5jbHVkZWQgbW9kdWxlSWQgJHtpbmNsdWRlTW9kdWxlSWR9IG5vdCBmb3VuZCBpbiBzdHlsZSByZWdpc3RyeWApO1xuICAgICAgfVxuICAgIH0sIHRoZW1lLnN0eWxlcyk7XG4gIH1cbiAgcmV0dXJuIGluY2x1ZGVkU3R5bGVzO1xufVxuXG4vKipcbiAqIEluY2x1ZGVzIHRoZSBzdHlsZXMgdG8gdGhlIHRlbXBsYXRlLlxuICogQHBhcmFtIHtDU1NSZXN1bHRbXX0gc3R5bGVzXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvVGVtcGxhdGUoc3R5bGVzLCB0ZW1wbGF0ZSkge1xuICBjb25zdCBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGVFbC5pbm5lckhUTUwgPSBzdHlsZXMubWFwKChzdHlsZSkgPT4gc3R5bGUuY3NzVGV4dCkuam9pbignXFxuJyk7XG4gIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGVtZXMgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3Igc3R5bGluZyBhIGNvbXBvbmVudCBtYXRjaGluZ1xuICogdGhlIHRhZyBuYW1lLiBUaGUgYXJyYXkgaXMgc29ydGVkIGJ5IHRoZSBpbmNsdWRlIG9yZGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAqIEByZXR1cm5zIHtUaGVtZVtdfVxuICovXG5mdW5jdGlvbiBnZXRUaGVtZXModGFnTmFtZSkge1xuICBjb25zdCBkZWZhdWx0TW9kdWxlTmFtZSA9IGAke3RhZ05hbWV9LWRlZmF1bHQtdGhlbWVgO1xuXG4gIGNvbnN0IHRoZW1lcyA9IGdldEFsbFRoZW1lcygpXG4gICAgLy8gRmlsdGVyIGJ5IG1hdGNoaW5nIHRoZW1lRm9yIHByb3BlcnRpZXNcbiAgICAuZmlsdGVyKCh0aGVtZSkgPT4gdGhlbWUubW9kdWxlSWQgIT09IGRlZmF1bHRNb2R1bGVOYW1lICYmIG1hdGNoZXNUaGVtZUZvcih0aGVtZS50aGVtZUZvciwgdGFnTmFtZSkpXG4gICAgLm1hcCgodGhlbWUpID0+ICh7XG4gICAgICAuLi50aGVtZSxcbiAgICAgIC8vIFByZXBlbmQgc3R5bGVzIGZyb20gaW5jbHVkZWQgdGhlbWVzXG4gICAgICBzdHlsZXM6IFsuLi5nZXRJbmNsdWRlZFN0eWxlcyh0aGVtZSksIC4uLnRoZW1lLnN0eWxlc10sXG4gICAgICAvLyBNYXAgbW9kdWxlSWQgdG8gaW5jbHVkZVByaW9yaXR5XG4gICAgICBpbmNsdWRlUHJpb3JpdHk6IGdldEluY2x1ZGVQcmlvcml0eSh0aGVtZS5tb2R1bGVJZCksXG4gICAgfSkpXG4gICAgLy8gU29ydCBieSBpbmNsdWRlUHJpb3JpdHlcbiAgICAuc29ydCgodGhlbWVBLCB0aGVtZUIpID0+IHRoZW1lQi5pbmNsdWRlUHJpb3JpdHkgLSB0aGVtZUEuaW5jbHVkZVByaW9yaXR5KTtcblxuICBpZiAodGhlbWVzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdGhlbWVzO1xuICB9XG4gIC8vIE5vIHRoZW1lIG1vZHVsZXMgZm91bmQsIHJldHVybiB0aGUgZGVmYXVsdCBtb2R1bGUgaWYgaXQgZXhpc3RzXG4gIHJldHVybiBnZXRBbGxUaGVtZXMoKS5maWx0ZXIoKHRoZW1lKSA9PiB0aGVtZS5tb2R1bGVJZCA9PT0gZGVmYXVsdE1vZHVsZU5hbWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXN0b20gZWxlbWVudCB0eXBlIGhhcyB0aGVtZXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzVGhlbWVzKHRhZ05hbWUpIHtcbiAgcmV0dXJuIGNsYXNzSGFzVGhlbWVzKGN1c3RvbUVsZW1lbnRzLmdldCh0YWdOYW1lKSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1c3RvbSBlbGVtZW50IHR5cGUgaGFzIHRoZW1lcyBhcHBsaWVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWxlbWVudENsYXNzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2xhc3NIYXNUaGVtZXMoZWxlbWVudENsYXNzKSB7XG4gIHJldHVybiBlbGVtZW50Q2xhc3MgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnRDbGFzcywgJ19fdGhlbWVzJyk7XG59XG5cbi8qKlxuICogQHBvbHltZXJNaXhpblxuICogQG1peGVzIFRoZW1lUHJvcGVydHlNaXhpblxuICovXG5leHBvcnQgY29uc3QgVGhlbWFibGVNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5UaGVtYWJsZU1peGluIGV4dGVuZHMgVGhlbWVQcm9wZXJ0eU1peGluKHN1cGVyQ2xhc3MpIHtcbiAgICAvKipcbiAgICAgKiBDb3ZlcnMgUG9seW1lckVsZW1lbnQgYmFzZWQgY29tcG9uZW50IHN0eWxpbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgc3VwZXIuZmluYWxpemUoKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIG5vdCB0byBydW4gdGhlIGxvZ2ljIGludGVuZGVkIGZvciBQb2x5bWVyRWxlbWVudCB3aGVuIExpdEVsZW1lbnQgaXMgdXNlZC5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnRTdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZTtcbiAgICAgIGlmICghdGVtcGxhdGUgfHwgY2xhc3NIYXNUaGVtZXModGhpcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhZGRTdHlsZXNUb1RlbXBsYXRlKHRoaXMuZ2V0U3R5bGVzRm9yVGhpcygpLCB0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ292ZXJzIExpdEVsZW1lbnQgYmFzZWQgY29tcG9uZW50IHN0eWxpbmdcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemVTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAvLyBUaGUgXCJzdHlsZXNcIiBvYmplY3Qgb3JpZ2luYXRlcyBmcm9tIHRoZSBcInN0YXRpYyBnZXQgc3R5bGVzKClcIiBmdW5jdGlvbiBvZlxuICAgICAgLy8gYSBMaXRFbGVtZW50IGJhc2VkIGNvbXBvbmVudC4gVGhlIHRoZW1lIHN0eWxlcyBhcmUgYWRkZWQgYWZ0ZXIgaXRcbiAgICAgIC8vIHNvIHRoYXQgdGhleSBjYW4gb3ZlcnJpZGUgdGhlIGNvbXBvbmVudCBzdHlsZXMuXG4gICAgICBjb25zdCB0aGVtZVN0eWxlcyA9IHRoaXMuZ2V0U3R5bGVzRm9yVGhpcygpO1xuICAgICAgcmV0dXJuIHN0eWxlcyA/IFsuLi5zdXBlci5maW5hbGl6ZVN0eWxlcyhzdHlsZXMpLCAuLi50aGVtZVN0eWxlc10gOiB0aGVtZVN0eWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc3R5bGVzIGZvciB0aGUgY29tcG9uZW50IHR5cGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0eWxlc0ZvclRoaXMoKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5wcm90b3R5cGUpO1xuICAgICAgY29uc3QgaW5oZXJpdGVkVGhlbWVzID0gKHBhcmVudCA/IHBhcmVudC5jb25zdHJ1Y3Rvci5fX3RoZW1lcyA6IFtdKSB8fCBbXTtcbiAgICAgIHRoaXMuX190aGVtZXMgPSBbLi4uaW5oZXJpdGVkVGhlbWVzLCAuLi5nZXRUaGVtZXModGhpcy5pcyldO1xuICAgICAgY29uc3QgdGhlbWVTdHlsZXMgPSB0aGlzLl9fdGhlbWVzLmZsYXRNYXAoKHRoZW1lKSA9PiB0aGVtZS5zdHlsZXMpO1xuICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgIHJldHVybiB0aGVtZVN0eWxlcy5maWx0ZXIoKHN0eWxlLCBpbmRleCkgPT4gaW5kZXggPT09IHRoZW1lU3R5bGVzLmxhc3RJbmRleE9mKHN0eWxlKSk7XG4gICAgfVxuICB9O1xuXG5leHBvcnQgeyB0aGVtZVJlZ2lzdHJ5IGFzIF9fdGhlbWVSZWdpc3RyeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemePropertyMixin\": () => (/* binding */ ThemePropertyMixin)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nconst ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @deprecated The `theme` property is not supposed for public use and will be dropped in Vaadin 24.\n       * Please, use the `theme` attribute instead.\n       * @protected\n       */\n      theme: {\n        type: String,\n        reflectToAttribute: true,\n        observer: '__deprecatedThemePropertyChanged'\n      },\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @protected\n       */\n      _theme: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n\n  /** @private */\n  __deprecatedThemePropertyChanged(theme) {\n    this._set_theme(theme);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWUtcHJvcGVydHktbWl4aW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLW1hdGVyaWFsLXN0eWxlcy9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzPzM4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG4vKipcbiAqIEBwb2x5bWVyTWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IFRoZW1lUHJvcGVydHlNaXhpbiA9IChzdXBlckNsYXNzKSA9PlxuICBjbGFzcyBWYWFkaW5UaGVtZVByb3BlcnR5TWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIHByb3BlcnR5IHdpdGggdGhlbWUgYXR0cmlidXRlIHZhbHVlIGZhY2lsaXRhdGluZyBwcm9wYWdhdGlvblxuICAgICAgICAgKiBpbiBzaGFkb3cgRE9NLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gdG8gcHJvcGFnYXRlIHRoZSBgdGhlbWVgXG4gICAgICAgICAqIGF0dHJpYnV0ZSB2YWx1ZSB0byB0aGUgc3ViLWNvbXBvbmVudHMgaW4gU2hhZG93IERPTSBieSBiaW5kaW5nXG4gICAgICAgICAqIHRoZSBzdWItY29tcG9uZW504oCZcyBcInRoZW1lXCIgYXR0cmlidXRlIHRvIHRoZSBgdGhlbWVgIHByb3BlcnR5IG9mXG4gICAgICAgICAqIHRoZSBob3N0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEU6KiogRXh0ZW5kaW5nIHRoZSBtaXhpbiBvbmx5IHByb3ZpZGVzIHRoZSBwcm9wZXJ0eSBmb3IgYmluZGluZyxcbiAgICAgICAgICogYW5kIGRvZXMgbm90IG1ha2UgdGhlIHByb3BhZ2F0aW9uIGFsb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgW1N0eWxpbmcgQ29tcG9uZW50czogU3ViLWNvbXBvbmVudHNdKGh0dHBzOi8vdmFhZGluLmNvbS9kb2NzL2xhdGVzdC9zdHlsaW5nL2N1c3RvbS10aGVtZS9zdHlsaW5nLWNvbXBvbmVudHMvI3N1Yi1jb21wb25lbnRzKS5cbiAgICAgICAgICogcGFnZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVGhlIGB0aGVtZWAgcHJvcGVydHkgaXMgbm90IHN1cHBvc2VkIGZvciBwdWJsaWMgdXNlIGFuZCB3aWxsIGJlIGRyb3BwZWQgaW4gVmFhZGluIDI0LlxuICAgICAgICAgKiBQbGVhc2UsIHVzZSB0aGUgYHRoZW1lYCBhdHRyaWJ1dGUgaW5zdGVhZC5cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgICAgIG9ic2VydmVyOiAnX19kZXByZWNhdGVkVGhlbWVQcm9wZXJ0eUNoYW5nZWQnLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgcHJvcGVydHkgd2l0aCB0aGVtZSBhdHRyaWJ1dGUgdmFsdWUgZmFjaWxpdGF0aW5nIHByb3BhZ2F0aW9uXG4gICAgICAgICAqIGluIHNoYWRvdyBET00uXG4gICAgICAgICAqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbiB0byBwcm9wYWdhdGUgdGhlIGB0aGVtZWBcbiAgICAgICAgICogYXR0cmlidXRlIHZhbHVlIHRvIHRoZSBzdWItY29tcG9uZW50cyBpbiBTaGFkb3cgRE9NIGJ5IGJpbmRpbmdcbiAgICAgICAgICogdGhlIHN1Yi1jb21wb25lbnTigJlzIFwidGhlbWVcIiBhdHRyaWJ1dGUgdG8gdGhlIGB0aGVtZWAgcHJvcGVydHkgb2ZcbiAgICAgICAgICogdGhlIGhvc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URToqKiBFeHRlbmRpbmcgdGhlIG1peGluIG9ubHkgcHJvdmlkZXMgdGhlIHByb3BlcnR5IGZvciBiaW5kaW5nLFxuICAgICAgICAgKiBhbmQgZG9lcyBub3QgbWFrZSB0aGUgcHJvcGFnYXRpb24gYWxvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBbU3R5bGluZyBDb21wb25lbnRzOiBTdWItY29tcG9uZW50c10oaHR0cHM6Ly92YWFkaW4uY29tL2RvY3MvbGF0ZXN0L3N0eWxpbmcvY3VzdG9tLXRoZW1lL3N0eWxpbmctY29tcG9uZW50cy8jc3ViLWNvbXBvbmVudHMpLlxuICAgICAgICAgKiBwYWdlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdGhlbWU6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIF9fZGVwcmVjYXRlZFRoZW1lUHJvcGVydHlDaGFuZ2VkKHRoZW1lKSB7XG4gICAgICB0aGlzLl9zZXRfdGhlbWUodGhlbWUpO1xuICAgIH1cbiAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/node_modules/lit/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/node_modules/lit/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSResult": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.CSSResult),
/* harmony export */   "LitElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.LitElement),
/* harmony export */   "ReactiveElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.ReactiveElement),
/* harmony export */   "UpdatingElement": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.UpdatingElement),
/* harmony export */   "_$LE": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LE),
/* harmony export */   "_$LH": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__._$LH),
/* harmony export */   "adoptStyles": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.adoptStyles),
/* harmony export */   "css": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.css),
/* harmony export */   "defaultConverter": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.defaultConverter),
/* harmony export */   "getCompatibleStyle": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.getCompatibleStyle),
/* harmony export */   "html": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.html),
/* harmony export */   "isServer": () => (/* reexport safe */ lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__.isServer),
/* harmony export */   "noChange": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.noChange),
/* harmony export */   "notEqual": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.notEqual),
/* harmony export */   "nothing": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.nothing),
/* harmony export */   "render": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.render),
/* harmony export */   "supportsAdoptingStyleSheets": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.supportsAdoptingStyleSheets),
/* harmony export */   "svg": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.svg),
/* harmony export */   "unsafeCSS": () => (/* reexport safe */ lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__.unsafeCSS)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element */ "./node_modules/@lit/reactive-element/development/reactive-element.js");
/* harmony import */ var lit_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit-html */ "./node_modules/lit-html/development/lit-html.js");
/* harmony import */ var lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit-element/lit-element.js */ "./node_modules/lit-element/development/lit-element.js");
/* harmony import */ var lit_html_is_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit-html/is-server.js */ "./node_modules/lit-html/development/is-server.js");





/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/shadow.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/shadow.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shadow\": () => (/* binding */ shadow)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"./node_modules/@vaadin/vaadin-material-styles/version.js\");\n/* harmony import */ var _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-material-styles/node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\nconst shadow = _vaadin_vaadin_themable_mixin_vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_1__.css`\n  /* prettier-ignore */\n  :host {\n    /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */\n    --material-shadow-elevation-2dp: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);\n    --material-shadow-elevation-3dp: 0 3px 4px 0 rgba(0, 0, 0, 0.14), 0 1px 8px 0 rgba(0, 0, 0, 0.12), 0 3px 3px -2px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-4dp: 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12), 0 2px 4px -1px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-6dp: 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12), 0 3px 5px -1px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-8dp: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-12dp: 0 12px 16px 1px rgba(0, 0, 0, 0.14), 0 4px 22px 3px rgba(0, 0, 0, 0.12), 0 6px 7px -4px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-16dp: 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12), 0 8px 10px -5px rgba(0, 0, 0, 0.4);\n    --material-shadow-elevation-24dp: 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12), 0 11px 15px -7px rgba(0, 0, 0, 0.4);\n  }\n`;\nconst $tpl = document.createElement('template');\n$tpl.innerHTML = `<style>${shadow.toString().replace(':host', 'html')}</style>`;\ndocument.head.appendChild($tpl.content);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL3NoYWRvdy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B2YWFkaW4vdmFhZGluLW1hdGVyaWFsLXN0eWxlcy9zaGFkb3cuanM/ODViYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmltcG9ydCAnLi92ZXJzaW9uLmpzJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0B2YWFkaW4vdmFhZGluLXRoZW1hYmxlLW1peGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi5qcyc7XG5cbmNvbnN0IHNoYWRvdyA9IGNzc2BcbiAgLyogcHJldHRpZXItaWdub3JlICovXG4gIDpob3N0IHtcbiAgICAvKiBmcm9tIGh0dHA6Ly9jb2RlcGVuLmlvL3NoeW5kbWFuL3Blbi9jNTM5NGRkZjJlOGIyYTVjOTE4NTkwNGI1NzQyMWNkYiAqL1xuICAgIC0tbWF0ZXJpYWwtc2hhZG93LWVsZXZhdGlvbi0yZHA6IDAgMnB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICAtLW1hdGVyaWFsLXNoYWRvdy1lbGV2YXRpb24tM2RwOiAwIDNweCA0cHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDFweCA4cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDNweCAzcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgLS1tYXRlcmlhbC1zaGFkb3ctZWxldmF0aW9uLTRkcDogMCA0cHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAxcHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgMnB4IDRweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAtLW1hdGVyaWFsLXNoYWRvdy1lbGV2YXRpb24tNmRwOiAwIDZweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAxcHggMThweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgM3B4IDVweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAtLW1hdGVyaWFsLXNoYWRvdy1lbGV2YXRpb24tOGRwOiAwIDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDNweCAxNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgLS1tYXRlcmlhbC1zaGFkb3ctZWxldmF0aW9uLTEyZHA6IDAgMTJweCAxNnB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDRweCAyMnB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDZweCA3cHggLTRweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgLS1tYXRlcmlhbC1zaGFkb3ctZWxldmF0aW9uLTE2ZHA6IDAgMTZweCAyNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDZweCAzMHB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDhweCAxMHB4IC01cHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgIC0tbWF0ZXJpYWwtc2hhZG93LWVsZXZhdGlvbi0yNGRwOiAwIDI0cHggMzhweCAzcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCA5cHggNDZweCA4cHggcmdiYSgwLCAwLCAwLCAwLjEyKSwgMCAxMXB4IDE1cHggLTdweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gIH1cbmA7XG5cbmNvbnN0ICR0cGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuJHRwbC5pbm5lckhUTUwgPSBgPHN0eWxlPiR7c2hhZG93LnRvU3RyaW5nKCkucmVwbGFjZSgnOmhvc3QnLCAnaHRtbCcpfTwvc3R5bGU+YDtcbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJHRwbC5jb250ZW50KTtcblxuZXhwb3J0IHsgc2hhZG93IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/shadow.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-material-styles/version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-material-styles/version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Material\": () => (/* binding */ Material)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * Dummy custom element used for collecting\n * development time usage statistics.\n *\n * @private\n */\nclass Material extends HTMLElement {\n  static get version() {\n    return '23.3.7';\n  }\n}\ncustomElements.define('vaadin-material-styles', Material);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tbWF0ZXJpYWwtc3R5bGVzL3ZlcnNpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMvdmVyc2lvbi5qcz8zNjI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyAtIDIwMjIgVmFhZGluIEx0ZC5cbiAqIFRoaXMgcHJvZ3JhbSBpcyBhdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIGF2YWlsYWJsZSBhdCBodHRwczovL3ZhYWRpbi5jb20vbGljZW5zZS9cbiAqL1xuXG4vKipcbiAqIER1bW15IGN1c3RvbSBlbGVtZW50IHVzZWQgZm9yIGNvbGxlY3RpbmdcbiAqIGRldmVsb3BtZW50IHRpbWUgdXNhZ2Ugc3RhdGlzdGljcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBNYXRlcmlhbCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAnMjMuMy43JztcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3ZhYWRpbi1tYXRlcmlhbC1zdHlsZXMnLCBNYXRlcmlhbCk7XG5cbmV4cG9ydCB7IE1hdGVyaWFsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-material-styles/version.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/register-styles.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/register-styles.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"css\": () => (/* reexport safe */ _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* reexport safe */ _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__.registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var _vaadin_themable_mixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vaadin-themable-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vcmVnaXN0ZXItc3R5bGVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi9yZWdpc3Rlci1zdHlsZXMuanM/NjIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbmV4cG9ydCB7IHJlZ2lzdGVyU3R5bGVzLCBjc3MsIHVuc2FmZUNTUyB9IGZyb20gJy4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-themable-mixin/register-styles.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemableMixin\": () => (/* binding */ ThemableMixin),\n/* harmony export */   \"__themeRegistry\": () => (/* binding */ themeRegistry),\n/* harmony export */   \"css\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.css),\n/* harmony export */   \"registerStyles\": () => (/* binding */ registerStyles),\n/* harmony export */   \"unsafeCSS\": () => (/* reexport safe */ lit__WEBPACK_IMPORTED_MODULE_0__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var _vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vaadin-theme-property-mixin.js */ \"./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\");\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n\n\n\n/**\n * @typedef {Object} Theme\n * @property {string} themeFor\n * @property {CSSResult[]} styles\n * @property {string | string[]} [include]\n * @property {string} [moduleId]\n *\n * @typedef {CSSResult[] | CSSResult} CSSResultGroup\n */\n\n/**\n * @type {Theme[]}\n */\nconst themeRegistry = [];\n\n/**\n * Registers CSS styles for a component type. Make sure to register the styles before\n * the first instance of a component of the type is attached to DOM.\n *\n * @param {string} themeFor The local/tag name of the component type to register the styles for\n * @param {CSSResultGroup} styles The CSS style rules to be registered for the component type\n * matching themeFor and included in the local scope of each component instance\n * @param {{moduleId?: string, include?: string | string[]}} options Additional options\n * @return {void}\n */\nfunction registerStyles(themeFor, styles, options = {}) {\n  if (themeFor) {\n    if (hasThemes(themeFor)) {\n      console.warn(`The custom element definition for \"${themeFor}\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element.`);\n    }\n  }\n  styles = flattenStyles(styles);\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    window.Vaadin.styleModules.registerStyles(themeFor, styles, options);\n  } else {\n    themeRegistry.push({\n      themeFor,\n      styles,\n      include: options.include,\n      moduleId: options.moduleId\n    });\n  }\n}\n\n/**\n * Returns all registered themes. By default the themeRegistry is returned as is.\n * In case the style-modules adapter is imported, the themes are obtained from there instead\n * @returns {Theme[]}\n */\nfunction getAllThemes() {\n  if (window.Vaadin && window.Vaadin.styleModules) {\n    return window.Vaadin.styleModules.getAllThemes();\n  }\n  return themeRegistry;\n}\n\n/**\n * Returns true if the themeFor string matches the tag name\n * @param {string} themeFor\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction matchesThemeFor(themeFor, tagName) {\n  return (themeFor || '').split(' ').some(themeForToken => {\n    return new RegExp(`^${themeForToken.split('*').join('.*')}$`).test(tagName);\n  });\n}\n\n/**\n * Maps the moduleName to an include priority number which is used for\n * determining the order in which styles are applied.\n * @param {string} moduleName\n * @returns {number}\n */\nfunction getIncludePriority(moduleName = '') {\n  let includePriority = 0;\n  if (moduleName.startsWith('lumo-') || moduleName.startsWith('material-')) {\n    includePriority = 1;\n  } else if (moduleName.startsWith('vaadin-')) {\n    includePriority = 2;\n  }\n  return includePriority;\n}\n\n/**\n * Flattens the styles into a single array of styles.\n * @param {CSSResultGroup} styles\n * @param {CSSResult[]} result\n * @returns {CSSResult[]}\n */\nfunction flattenStyles(styles = []) {\n  return [styles].flat(Infinity).filter(style => {\n    if (style instanceof lit__WEBPACK_IMPORTED_MODULE_0__.CSSResult) {\n      return true;\n    }\n    console.warn('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');\n    return false;\n  });\n}\n\n/**\n * Gets an array of CSSResults matching the include property of the theme.\n * @param {Theme} theme\n * @returns {CSSResult[]}\n */\nfunction getIncludedStyles(theme) {\n  const includedStyles = [];\n  if (theme.include) {\n    [].concat(theme.include).forEach(includeModuleId => {\n      const includedTheme = getAllThemes().find(s => s.moduleId === includeModuleId);\n      if (includedTheme) {\n        includedStyles.push(...getIncludedStyles(includedTheme), ...includedTheme.styles);\n      } else {\n        console.warn(`Included moduleId ${includeModuleId} not found in style registry`);\n      }\n    }, theme.styles);\n  }\n  return includedStyles;\n}\n\n/**\n * Includes the styles to the template.\n * @param {CSSResult[]} styles\n * @param {HTMLTemplateElement} template\n */\nfunction addStylesToTemplate(styles, template) {\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = styles.map(style => style.cssText).join('\\n');\n  template.content.appendChild(styleEl);\n}\n\n/**\n * Returns an array of themes that should be used for styling a component matching\n * the tag name. The array is sorted by the include order.\n * @param {string} tagName\n * @returns {Theme[]}\n */\nfunction getThemes(tagName) {\n  const defaultModuleName = `${tagName}-default-theme`;\n  const themes = getAllThemes()\n  // Filter by matching themeFor properties\n  .filter(theme => theme.moduleId !== defaultModuleName && matchesThemeFor(theme.themeFor, tagName)).map(theme => ({\n    ...theme,\n    // Prepend styles from included themes\n    styles: [...getIncludedStyles(theme), ...theme.styles],\n    // Map moduleId to includePriority\n    includePriority: getIncludePriority(theme.moduleId)\n  }))\n  // Sort by includePriority\n  .sort((themeA, themeB) => themeB.includePriority - themeA.includePriority);\n  if (themes.length > 0) {\n    return themes;\n  }\n  // No theme modules found, return the default module if it exists\n  return getAllThemes().filter(theme => theme.moduleId === defaultModuleName);\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {string} tagName\n * @returns {boolean}\n */\nfunction hasThemes(tagName) {\n  return classHasThemes(customElements.get(tagName));\n}\n\n/**\n * Check if the custom element type has themes applied.\n * @param {Function} elementClass\n * @returns {boolean}\n */\nfunction classHasThemes(elementClass) {\n  return elementClass && Object.prototype.hasOwnProperty.call(elementClass, '__themes');\n}\n\n/**\n * @polymerMixin\n * @mixes ThemePropertyMixin\n */\nconst ThemableMixin = superClass => class VaadinThemableMixin extends (0,_vaadin_theme_property_mixin_js__WEBPACK_IMPORTED_MODULE_1__.ThemePropertyMixin)(superClass) {\n  /**\n   * Covers PolymerElement based component styling\n   * @protected\n   */\n  static finalize() {\n    super.finalize();\n\n    // Make sure not to run the logic intended for PolymerElement when LitElement is used.\n    if (this.elementStyles) {\n      return;\n    }\n    const template = this.prototype._template;\n    if (!template || classHasThemes(this)) {\n      return;\n    }\n    addStylesToTemplate(this.getStylesForThis(), template);\n  }\n\n  /**\n   * Covers LitElement based component styling\n   *\n   * @protected\n   */\n  static finalizeStyles(styles) {\n    // The \"styles\" object originates from the \"static get styles()\" function of\n    // a LitElement based component. The theme styles are added after it\n    // so that they can override the component styles.\n    const themeStyles = this.getStylesForThis();\n    return styles ? [...super.finalizeStyles(styles), ...themeStyles] : themeStyles;\n  }\n\n  /**\n   * Get styles for the component type\n   *\n   * @private\n   */\n  static getStylesForThis() {\n    const parent = Object.getPrototypeOf(this.prototype);\n    const inheritedThemes = (parent ? parent.constructor.__themes : []) || [];\n    this.__themes = [...inheritedThemes, ...getThemes(this.is)];\n    const themeStyles = this.__themes.flatMap(theme => theme.styles);\n    // Remove duplicates\n    return themeStyles.filter((style, index) => index === themeStyles.lastIndexOf(style));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1hYmxlLW1peGluLmpzP2FlMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IC0gMjAyMiBWYWFkaW4gTHRkLlxuICogVGhpcyBwcm9ncmFtIGlzIGF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgYXZhaWxhYmxlIGF0IGh0dHBzOi8vdmFhZGluLmNvbS9saWNlbnNlL1xuICovXG5pbXBvcnQgeyBjc3MsIENTU1Jlc3VsdCwgdW5zYWZlQ1NTIH0gZnJvbSAnbGl0JztcbmltcG9ydCB7IFRoZW1lUHJvcGVydHlNaXhpbiB9IGZyb20gJy4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzJztcblxuZXhwb3J0IHsgY3NzLCB1bnNhZmVDU1MgfTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaGVtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRoZW1lRm9yXG4gKiBAcHJvcGVydHkge0NTU1Jlc3VsdFtdfSBzdHlsZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgc3RyaW5nW119IFtpbmNsdWRlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2R1bGVJZF1cbiAqXG4gKiBAdHlwZWRlZiB7Q1NTUmVzdWx0W10gfCBDU1NSZXN1bHR9IENTU1Jlc3VsdEdyb3VwXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7VGhlbWVbXX1cbiAqL1xuY29uc3QgdGhlbWVSZWdpc3RyeSA9IFtdO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBDU1Mgc3R5bGVzIGZvciBhIGNvbXBvbmVudCB0eXBlLiBNYWtlIHN1cmUgdG8gcmVnaXN0ZXIgdGhlIHN0eWxlcyBiZWZvcmVcbiAqIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBvZiB0aGUgdHlwZSBpcyBhdHRhY2hlZCB0byBET00uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lRm9yIFRoZSBsb2NhbC90YWcgbmFtZSBvZiB0aGUgY29tcG9uZW50IHR5cGUgdG8gcmVnaXN0ZXIgdGhlIHN0eWxlcyBmb3JcbiAqIEBwYXJhbSB7Q1NTUmVzdWx0R3JvdXB9IHN0eWxlcyBUaGUgQ1NTIHN0eWxlIHJ1bGVzIHRvIGJlIHJlZ2lzdGVyZWQgZm9yIHRoZSBjb21wb25lbnQgdHlwZVxuICogbWF0Y2hpbmcgdGhlbWVGb3IgYW5kIGluY2x1ZGVkIGluIHRoZSBsb2NhbCBzY29wZSBvZiBlYWNoIGNvbXBvbmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHt7bW9kdWxlSWQ/OiBzdHJpbmcsIGluY2x1ZGU/OiBzdHJpbmcgfCBzdHJpbmdbXX19IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJTdHlsZXModGhlbWVGb3IsIHN0eWxlcywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICh0aGVtZUZvcikge1xuICAgIGlmIChoYXNUaGVtZXModGhlbWVGb3IpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRoZSBjdXN0b20gZWxlbWVudCBkZWZpbml0aW9uIGZvciBcIiR7dGhlbWVGb3J9XCJcbiAgICAgIHdhcyBmaW5hbGl6ZWQgYmVmb3JlIGEgc3R5bGUgbW9kdWxlIHdhcyByZWdpc3RlcmVkLlxuICAgICAgTWFrZSBzdXJlIHRvIGFkZCBjb21wb25lbnQgc3BlY2lmaWMgc3R5bGUgbW9kdWxlcyBiZWZvcmVcbiAgICAgIGltcG9ydGluZyB0aGUgY29ycmVzcG9uZGluZyBjdXN0b20gZWxlbWVudC5gKTtcbiAgICB9XG4gIH1cblxuICBzdHlsZXMgPSBmbGF0dGVuU3R5bGVzKHN0eWxlcyk7XG5cbiAgaWYgKHdpbmRvdy5WYWFkaW4gJiYgd2luZG93LlZhYWRpbi5zdHlsZU1vZHVsZXMpIHtcbiAgICB3aW5kb3cuVmFhZGluLnN0eWxlTW9kdWxlcy5yZWdpc3RlclN0eWxlcyh0aGVtZUZvciwgc3R5bGVzLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0aGVtZVJlZ2lzdHJ5LnB1c2goe1xuICAgICAgdGhlbWVGb3IsXG4gICAgICBzdHlsZXMsXG4gICAgICBpbmNsdWRlOiBvcHRpb25zLmluY2x1ZGUsXG4gICAgICBtb2R1bGVJZDogb3B0aW9ucy5tb2R1bGVJZCxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgdGhlbWVzLiBCeSBkZWZhdWx0IHRoZSB0aGVtZVJlZ2lzdHJ5IGlzIHJldHVybmVkIGFzIGlzLlxuICogSW4gY2FzZSB0aGUgc3R5bGUtbW9kdWxlcyBhZGFwdGVyIGlzIGltcG9ydGVkLCB0aGUgdGhlbWVzIGFyZSBvYnRhaW5lZCBmcm9tIHRoZXJlIGluc3RlYWRcbiAqIEByZXR1cm5zIHtUaGVtZVtdfVxuICovXG5mdW5jdGlvbiBnZXRBbGxUaGVtZXMoKSB7XG4gIGlmICh3aW5kb3cuVmFhZGluICYmIHdpbmRvdy5WYWFkaW4uc3R5bGVNb2R1bGVzKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5WYWFkaW4uc3R5bGVNb2R1bGVzLmdldEFsbFRoZW1lcygpO1xuICB9XG4gIHJldHVybiB0aGVtZVJlZ2lzdHJ5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGhlbWVGb3Igc3RyaW5nIG1hdGNoZXMgdGhlIHRhZyBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhlbWVGb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1RoZW1lRm9yKHRoZW1lRm9yLCB0YWdOYW1lKSB7XG4gIHJldHVybiAodGhlbWVGb3IgfHwgJycpLnNwbGl0KCcgJykuc29tZSgodGhlbWVGb3JUb2tlbikgPT4ge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt0aGVtZUZvclRva2VuLnNwbGl0KCcqJykuam9pbignLionKX0kYCkudGVzdCh0YWdOYW1lKTtcbiAgfSk7XG59XG5cbi8qKlxuICogTWFwcyB0aGUgbW9kdWxlTmFtZSB0byBhbiBpbmNsdWRlIHByaW9yaXR5IG51bWJlciB3aGljaCBpcyB1c2VkIGZvclxuICogZGV0ZXJtaW5pbmcgdGhlIG9yZGVyIGluIHdoaWNoIHN0eWxlcyBhcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRJbmNsdWRlUHJpb3JpdHkobW9kdWxlTmFtZSA9ICcnKSB7XG4gIGxldCBpbmNsdWRlUHJpb3JpdHkgPSAwO1xuICBpZiAobW9kdWxlTmFtZS5zdGFydHNXaXRoKCdsdW1vLScpIHx8IG1vZHVsZU5hbWUuc3RhcnRzV2l0aCgnbWF0ZXJpYWwtJykpIHtcbiAgICBpbmNsdWRlUHJpb3JpdHkgPSAxO1xuICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUuc3RhcnRzV2l0aCgndmFhZGluLScpKSB7XG4gICAgaW5jbHVkZVByaW9yaXR5ID0gMjtcbiAgfVxuICByZXR1cm4gaW5jbHVkZVByaW9yaXR5O1xufVxuXG4vKipcbiAqIEZsYXR0ZW5zIHRoZSBzdHlsZXMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBzdHlsZXMuXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdEdyb3VwfSBzdHlsZXNcbiAqIEBwYXJhbSB7Q1NTUmVzdWx0W119IHJlc3VsdFxuICogQHJldHVybnMge0NTU1Jlc3VsdFtdfVxuICovXG5mdW5jdGlvbiBmbGF0dGVuU3R5bGVzKHN0eWxlcyA9IFtdKSB7XG4gIHJldHVybiBbc3R5bGVzXS5mbGF0KEluZmluaXR5KS5maWx0ZXIoKHN0eWxlKSA9PiB7XG4gICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgQ1NTUmVzdWx0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKCdBbiBpdGVtIGluIHN0eWxlcyBpcyBub3Qgb2YgdHlwZSBDU1NSZXN1bHQuIFVzZSBgdW5zYWZlQ1NTYCBvciBgY3NzYC4nKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldHMgYW4gYXJyYXkgb2YgQ1NTUmVzdWx0cyBtYXRjaGluZyB0aGUgaW5jbHVkZSBwcm9wZXJ0eSBvZiB0aGUgdGhlbWUuXG4gKiBAcGFyYW0ge1RoZW1lfSB0aGVtZVxuICogQHJldHVybnMge0NTU1Jlc3VsdFtdfVxuICovXG5mdW5jdGlvbiBnZXRJbmNsdWRlZFN0eWxlcyh0aGVtZSkge1xuICBjb25zdCBpbmNsdWRlZFN0eWxlcyA9IFtdO1xuICBpZiAodGhlbWUuaW5jbHVkZSkge1xuICAgIFtdLmNvbmNhdCh0aGVtZS5pbmNsdWRlKS5mb3JFYWNoKChpbmNsdWRlTW9kdWxlSWQpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVkVGhlbWUgPSBnZXRBbGxUaGVtZXMoKS5maW5kKChzKSA9PiBzLm1vZHVsZUlkID09PSBpbmNsdWRlTW9kdWxlSWQpO1xuICAgICAgaWYgKGluY2x1ZGVkVGhlbWUpIHtcbiAgICAgICAgaW5jbHVkZWRTdHlsZXMucHVzaCguLi5nZXRJbmNsdWRlZFN0eWxlcyhpbmNsdWRlZFRoZW1lKSwgLi4uaW5jbHVkZWRUaGVtZS5zdHlsZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbmNsdWRlZCBtb2R1bGVJZCAke2luY2x1ZGVNb2R1bGVJZH0gbm90IGZvdW5kIGluIHN0eWxlIHJlZ2lzdHJ5YCk7XG4gICAgICB9XG4gICAgfSwgdGhlbWUuc3R5bGVzKTtcbiAgfVxuICByZXR1cm4gaW5jbHVkZWRTdHlsZXM7XG59XG5cbi8qKlxuICogSW5jbHVkZXMgdGhlIHN0eWxlcyB0byB0aGUgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge0NTU1Jlc3VsdFtdfSBzdHlsZXNcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZnVuY3Rpb24gYWRkU3R5bGVzVG9UZW1wbGF0ZShzdHlsZXMsIHRlbXBsYXRlKSB7XG4gIGNvbnN0IHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZUVsLmlubmVySFRNTCA9IHN0eWxlcy5tYXAoKHN0eWxlKSA9PiBzdHlsZS5jc3NUZXh0KS5qb2luKCdcXG4nKTtcbiAgdGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZW1lcyB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBzdHlsaW5nIGEgY29tcG9uZW50IG1hdGNoaW5nXG4gKiB0aGUgdGFnIG5hbWUuIFRoZSBhcnJheSBpcyBzb3J0ZWQgYnkgdGhlIGluY2x1ZGUgb3JkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZVxuICogQHJldHVybnMge1RoZW1lW119XG4gKi9cbmZ1bmN0aW9uIGdldFRoZW1lcyh0YWdOYW1lKSB7XG4gIGNvbnN0IGRlZmF1bHRNb2R1bGVOYW1lID0gYCR7dGFnTmFtZX0tZGVmYXVsdC10aGVtZWA7XG5cbiAgY29uc3QgdGhlbWVzID0gZ2V0QWxsVGhlbWVzKClcbiAgICAvLyBGaWx0ZXIgYnkgbWF0Y2hpbmcgdGhlbWVGb3IgcHJvcGVydGllc1xuICAgIC5maWx0ZXIoKHRoZW1lKSA9PiB0aGVtZS5tb2R1bGVJZCAhPT0gZGVmYXVsdE1vZHVsZU5hbWUgJiYgbWF0Y2hlc1RoZW1lRm9yKHRoZW1lLnRoZW1lRm9yLCB0YWdOYW1lKSlcbiAgICAubWFwKCh0aGVtZSkgPT4gKHtcbiAgICAgIC4uLnRoZW1lLFxuICAgICAgLy8gUHJlcGVuZCBzdHlsZXMgZnJvbSBpbmNsdWRlZCB0aGVtZXNcbiAgICAgIHN0eWxlczogWy4uLmdldEluY2x1ZGVkU3R5bGVzKHRoZW1lKSwgLi4udGhlbWUuc3R5bGVzXSxcbiAgICAgIC8vIE1hcCBtb2R1bGVJZCB0byBpbmNsdWRlUHJpb3JpdHlcbiAgICAgIGluY2x1ZGVQcmlvcml0eTogZ2V0SW5jbHVkZVByaW9yaXR5KHRoZW1lLm1vZHVsZUlkKSxcbiAgICB9KSlcbiAgICAvLyBTb3J0IGJ5IGluY2x1ZGVQcmlvcml0eVxuICAgIC5zb3J0KCh0aGVtZUEsIHRoZW1lQikgPT4gdGhlbWVCLmluY2x1ZGVQcmlvcml0eSAtIHRoZW1lQS5pbmNsdWRlUHJpb3JpdHkpO1xuXG4gIGlmICh0aGVtZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB0aGVtZXM7XG4gIH1cbiAgLy8gTm8gdGhlbWUgbW9kdWxlcyBmb3VuZCwgcmV0dXJuIHRoZSBkZWZhdWx0IG1vZHVsZSBpZiBpdCBleGlzdHNcbiAgcmV0dXJuIGdldEFsbFRoZW1lcygpLmZpbHRlcigodGhlbWUpID0+IHRoZW1lLm1vZHVsZUlkID09PSBkZWZhdWx0TW9kdWxlTmFtZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1c3RvbSBlbGVtZW50IHR5cGUgaGFzIHRoZW1lcyBhcHBsaWVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNUaGVtZXModGFnTmFtZSkge1xuICByZXR1cm4gY2xhc3NIYXNUaGVtZXMoY3VzdG9tRWxlbWVudHMuZ2V0KHRhZ05hbWUpKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VzdG9tIGVsZW1lbnQgdHlwZSBoYXMgdGhlbWVzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbGVtZW50Q2xhc3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjbGFzc0hhc1RoZW1lcyhlbGVtZW50Q2xhc3MpIHtcbiAgcmV0dXJuIGVsZW1lbnRDbGFzcyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWxlbWVudENsYXNzLCAnX190aGVtZXMnKTtcbn1cblxuLyoqXG4gKiBAcG9seW1lck1peGluXG4gKiBAbWl4ZXMgVGhlbWVQcm9wZXJ0eU1peGluXG4gKi9cbmV4cG9ydCBjb25zdCBUaGVtYWJsZU1peGluID0gKHN1cGVyQ2xhc3MpID0+XG4gIGNsYXNzIFZhYWRpblRoZW1hYmxlTWl4aW4gZXh0ZW5kcyBUaGVtZVByb3BlcnR5TWl4aW4oc3VwZXJDbGFzcykge1xuICAgIC8qKlxuICAgICAqIENvdmVycyBQb2x5bWVyRWxlbWVudCBiYXNlZCBjb21wb25lbnQgc3R5bGluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICBzdXBlci5maW5hbGl6ZSgpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgbm90IHRvIHJ1biB0aGUgbG9naWMgaW50ZW5kZWQgZm9yIFBvbHltZXJFbGVtZW50IHdoZW4gTGl0RWxlbWVudCBpcyB1c2VkLlxuICAgICAgaWYgKHRoaXMuZWxlbWVudFN0eWxlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5wcm90b3R5cGUuX3RlbXBsYXRlO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSB8fCBjbGFzc0hhc1RoZW1lcyh0aGlzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFkZFN0eWxlc1RvVGVtcGxhdGUodGhpcy5nZXRTdHlsZXNGb3JUaGlzKCksIHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3ZlcnMgTGl0RWxlbWVudCBiYXNlZCBjb21wb25lbnQgc3R5bGluZ1xuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5hbGl6ZVN0eWxlcyhzdHlsZXMpIHtcbiAgICAgIC8vIFRoZSBcInN0eWxlc1wiIG9iamVjdCBvcmlnaW5hdGVzIGZyb20gdGhlIFwic3RhdGljIGdldCBzdHlsZXMoKVwiIGZ1bmN0aW9uIG9mXG4gICAgICAvLyBhIExpdEVsZW1lbnQgYmFzZWQgY29tcG9uZW50LiBUaGUgdGhlbWUgc3R5bGVzIGFyZSBhZGRlZCBhZnRlciBpdFxuICAgICAgLy8gc28gdGhhdCB0aGV5IGNhbiBvdmVycmlkZSB0aGUgY29tcG9uZW50IHN0eWxlcy5cbiAgICAgIGNvbnN0IHRoZW1lU3R5bGVzID0gdGhpcy5nZXRTdHlsZXNGb3JUaGlzKCk7XG4gICAgICByZXR1cm4gc3R5bGVzID8gWy4uLnN1cGVyLmZpbmFsaXplU3R5bGVzKHN0eWxlcyksIC4uLnRoZW1lU3R5bGVzXSA6IHRoZW1lU3R5bGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzdHlsZXMgZm9yIHRoZSBjb21wb25lbnQgdHlwZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3R5bGVzRm9yVGhpcygpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLnByb3RvdHlwZSk7XG4gICAgICBjb25zdCBpbmhlcml0ZWRUaGVtZXMgPSAocGFyZW50ID8gcGFyZW50LmNvbnN0cnVjdG9yLl9fdGhlbWVzIDogW10pIHx8IFtdO1xuICAgICAgdGhpcy5fX3RoZW1lcyA9IFsuLi5pbmhlcml0ZWRUaGVtZXMsIC4uLmdldFRoZW1lcyh0aGlzLmlzKV07XG4gICAgICBjb25zdCB0aGVtZVN0eWxlcyA9IHRoaXMuX190aGVtZXMuZmxhdE1hcCgodGhlbWUpID0+IHRoZW1lLnN0eWxlcyk7XG4gICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICAgICAgcmV0dXJuIHRoZW1lU3R5bGVzLmZpbHRlcigoc3R5bGUsIGluZGV4KSA9PiBpbmRleCA9PT0gdGhlbWVTdHlsZXMubGFzdEluZGV4T2Yoc3R5bGUpKTtcbiAgICB9XG4gIH07XG5cbmV4cG9ydCB7IHRoZW1lUmVnaXN0cnkgYXMgX190aGVtZVJlZ2lzdHJ5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js\n");

/***/ }),

/***/ "./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ThemePropertyMixin\": () => (/* binding */ ThemePropertyMixin)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2017 - 2022 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/**\n * @polymerMixin\n */\nconst ThemePropertyMixin = superClass => class VaadinThemePropertyMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @deprecated The `theme` property is not supposed for public use and will be dropped in Vaadin 24.\n       * Please, use the `theme` attribute instead.\n       * @protected\n       */\n      theme: {\n        type: String,\n        reflectToAttribute: true,\n        observer: '__deprecatedThemePropertyChanged'\n      },\n      /**\n       * Helper property with theme attribute value facilitating propagation\n       * in shadow DOM.\n       *\n       * Enables the component implementation to propagate the `theme`\n       * attribute value to the sub-components in Shadow DOM by binding\n       * the sub-components \"theme\" attribute to the `theme` property of\n       * the host.\n       *\n       * **NOTE:** Extending the mixin only provides the property for binding,\n       * and does not make the propagation alone.\n       *\n       * See [Styling Components: Sub-components](https://vaadin.com/docs/latest/styling/custom-theme/styling-components/#sub-components).\n       * page for more information.\n       *\n       * @protected\n       */\n      _theme: {\n        type: String,\n        readOnly: true\n      }\n    };\n  }\n\n  /** @private */\n  __deprecatedThemePropertyChanged(theme) {\n    this._set_theme(theme);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZhYWRpbi92YWFkaW4tdGhlbWFibGUtbWl4aW4vdmFhZGluLXRoZW1lLXByb3BlcnR5LW1peGluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdmFhZGluL3ZhYWRpbi10aGVtYWJsZS1taXhpbi92YWFkaW4tdGhlbWUtcHJvcGVydHktbWl4aW4uanM/YjhiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDIyIFZhYWRpbiBMdGQuXG4gKiBUaGlzIHByb2dyYW0gaXMgYXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wLCBhdmFpbGFibGUgYXQgaHR0cHM6Ly92YWFkaW4uY29tL2xpY2Vuc2UvXG4gKi9cbi8qKlxuICogQHBvbHltZXJNaXhpblxuICovXG5leHBvcnQgY29uc3QgVGhlbWVQcm9wZXJ0eU1peGluID0gKHN1cGVyQ2xhc3MpID0+XG4gIGNsYXNzIFZhYWRpblRoZW1lUHJvcGVydHlNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgcHJvcGVydHkgd2l0aCB0aGVtZSBhdHRyaWJ1dGUgdmFsdWUgZmFjaWxpdGF0aW5nIHByb3BhZ2F0aW9uXG4gICAgICAgICAqIGluIHNoYWRvdyBET00uXG4gICAgICAgICAqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvbiB0byBwcm9wYWdhdGUgdGhlIGB0aGVtZWBcbiAgICAgICAgICogYXR0cmlidXRlIHZhbHVlIHRvIHRoZSBzdWItY29tcG9uZW50cyBpbiBTaGFkb3cgRE9NIGJ5IGJpbmRpbmdcbiAgICAgICAgICogdGhlIHN1Yi1jb21wb25lbnTigJlzIFwidGhlbWVcIiBhdHRyaWJ1dGUgdG8gdGhlIGB0aGVtZWAgcHJvcGVydHkgb2ZcbiAgICAgICAgICogdGhlIGhvc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URToqKiBFeHRlbmRpbmcgdGhlIG1peGluIG9ubHkgcHJvdmlkZXMgdGhlIHByb3BlcnR5IGZvciBiaW5kaW5nLFxuICAgICAgICAgKiBhbmQgZG9lcyBub3QgbWFrZSB0aGUgcHJvcGFnYXRpb24gYWxvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBbU3R5bGluZyBDb21wb25lbnRzOiBTdWItY29tcG9uZW50c10oaHR0cHM6Ly92YWFkaW4uY29tL2RvY3MvbGF0ZXN0L3N0eWxpbmcvY3VzdG9tLXRoZW1lL3N0eWxpbmctY29tcG9uZW50cy8jc3ViLWNvbXBvbmVudHMpLlxuICAgICAgICAgKiBwYWdlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBUaGUgYHRoZW1lYCBwcm9wZXJ0eSBpcyBub3Qgc3VwcG9zZWQgZm9yIHB1YmxpYyB1c2UgYW5kIHdpbGwgYmUgZHJvcHBlZCBpbiBWYWFkaW4gMjQuXG4gICAgICAgICAqIFBsZWFzZSwgdXNlIHRoZSBgdGhlbWVgIGF0dHJpYnV0ZSBpbnN0ZWFkLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGVtZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlcHJlY2F0ZWRUaGVtZVByb3BlcnR5Q2hhbmdlZCcsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciBwcm9wZXJ0eSB3aXRoIHRoZW1lIGF0dHJpYnV0ZSB2YWx1ZSBmYWNpbGl0YXRpbmcgcHJvcGFnYXRpb25cbiAgICAgICAgICogaW4gc2hhZG93IERPTS5cbiAgICAgICAgICpcbiAgICAgICAgICogRW5hYmxlcyB0aGUgY29tcG9uZW50IGltcGxlbWVudGF0aW9uIHRvIHByb3BhZ2F0ZSB0aGUgYHRoZW1lYFxuICAgICAgICAgKiBhdHRyaWJ1dGUgdmFsdWUgdG8gdGhlIHN1Yi1jb21wb25lbnRzIGluIFNoYWRvdyBET00gYnkgYmluZGluZ1xuICAgICAgICAgKiB0aGUgc3ViLWNvbXBvbmVudOKAmXMgXCJ0aGVtZVwiIGF0dHJpYnV0ZSB0byB0aGUgYHRoZW1lYCBwcm9wZXJ0eSBvZlxuICAgICAgICAgKiB0aGUgaG9zdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFOioqIEV4dGVuZGluZyB0aGUgbWl4aW4gb25seSBwcm92aWRlcyB0aGUgcHJvcGVydHkgZm9yIGJpbmRpbmcsXG4gICAgICAgICAqIGFuZCBkb2VzIG5vdCBtYWtlIHRoZSBwcm9wYWdhdGlvbiBhbG9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIFtTdHlsaW5nIENvbXBvbmVudHM6IFN1Yi1jb21wb25lbnRzXShodHRwczovL3ZhYWRpbi5jb20vZG9jcy9sYXRlc3Qvc3R5bGluZy9jdXN0b20tdGhlbWUvc3R5bGluZy1jb21wb25lbnRzLyNzdWItY29tcG9uZW50cykuXG4gICAgICAgICAqIHBhZ2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIF90aGVtZToge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgX19kZXByZWNhdGVkVGhlbWVQcm9wZXJ0eUNoYW5nZWQodGhlbWUpIHtcbiAgICAgIHRoaXMuX3NldF90aGVtZSh0aGVtZSk7XG4gICAgfVxuICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js\n");

/***/ })

}]);