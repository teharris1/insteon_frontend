"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseLayout\": () => (/* binding */ BaseLayout),\n/* harmony export */   \"dim1\": () => (/* binding */ dim1),\n/* harmony export */   \"dim2\": () => (/* binding */ dim2),\n/* harmony export */   \"pos1\": () => (/* binding */ pos1),\n/* harmony export */   \"pos2\": () => (/* binding */ pos2)\n/* harmony export */ });\n/* harmony import */ var _polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../polyfillLoaders/EventTarget.js */ \"./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nfunction dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nfunction dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nfunction pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nfunction pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nclass BaseLayout {\n  constructor(config) {\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    this.totalScrollSize = {\n      width: 0,\n      height: 0\n    };\n    this.offsetWithinScroller = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Flag for debouncing asynchnronous reflow requests.\n     */\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n    this._lastVisible = 0;\n    this._eventTargetPromise = (0,_polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then(Ctor => {\n      this._eventTarget = new Ctor();\n    });\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n    this._items = [];\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n    this._overhang = 1000;\n    this._eventTarget = null;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(() => this.config = config || this._defaultConfig);\n  }\n  get _defaultConfig() {\n    return {\n      direction: 'vertical'\n    };\n  }\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(items) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize() {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {\n      _viewDim1,\n      _viewDim2\n    } = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._updateVisibleIndices({\n        emit: true\n      });\n    }\n    this._checkThresholds();\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n  set pin(options) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n  get pin() {\n    if (this._pin !== null) {\n      const {\n        index,\n        block\n      } = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block\n      };\n    }\n    return null;\n  }\n  _clampScrollPosition(val) {\n    return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n  }\n  unpin() {\n    if (this._pin !== null) {\n      this._emitUnpinned();\n      this._pin = null;\n    }\n  }\n  async dispatchEvent(evt) {\n    await this._eventTargetPromise;\n    this._eventTarget.dispatchEvent(evt);\n  }\n  async addEventListener(type, listener, options) {\n    await this._eventTargetPromise;\n    this._eventTarget.addEventListener(type, listener, options);\n  }\n  async removeEventListener(type, callback, options) {\n    await this._eventTargetPromise;\n    this._eventTarget.removeEventListener(type, callback, options);\n  }\n  _updateLayout() {\n    // Override\n  }\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._emitScrollSize();\n    this._emitRange();\n    this._emitChildPositions();\n    this._emitScrollError();\n  }\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {\n        index,\n        block\n      } = this.pin;\n      this._scrollPosition = this._calculateScrollIntoViewPosition({\n        index,\n        block: block || 'start'\n      }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  _calculateScrollIntoViewPosition(options) {\n    const {\n      block\n    } = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n  getScrollIntoViewCoordinates(options) {\n    return {\n      [this._positionDim]: this._calculateScrollIntoViewPosition(options)\n    };\n  }\n  _emitUnpinned() {\n    this.dispatchEvent(new CustomEvent('unpinned'));\n  }\n  _emitRange() {\n    const detail = {\n      first: this._first,\n      last: this._last,\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    };\n    this.dispatchEvent(new CustomEvent('rangechange', {\n      detail\n    }));\n  }\n  _emitScrollSize() {\n    const detail = {\n      [this._sizeDim]: this._scrollSize,\n      [this._secondarySizeDim]: null\n    };\n    this.dispatchEvent(new CustomEvent('scrollsizechange', {\n      detail\n    }));\n  }\n  _emitScrollError() {\n    if (this._scrollError) {\n      const detail = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this.dispatchEvent(new CustomEvent('scrollerrorchange', {\n        detail\n      }));\n      this._scrollError = 0;\n    }\n  }\n  /**\n   * Get or estimate the top and left positions of items in the current range.\n   * Emit an itempositionchange event with these positions.\n   */\n  _emitChildPositions() {\n    if (this._first !== -1 && this._last !== -1) {\n      const detail = new Map();\n      for (let idx = this._first; idx <= this._last; idx++) {\n        detail.set(idx, this._getItemPosition(idx));\n      }\n      this.dispatchEvent(new CustomEvent('itempositionchange', {\n        detail\n      }));\n    }\n  }\n  /**\n   * Number of items to display.\n   */\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1) return;\n    let firstVisible = this._first;\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n    let lastVisible = this._last;\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._emitRange();\n      }\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL0Jhc2VMYXlvdXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFtQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUF5SEE7QUF4SEE7OztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7OztBQUlBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7QUFHQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBd0JBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOzs7QUFHQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFPQTs7QUFHQTtBQUNBO0FBS0E7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uLy4uL3NyYy9sYXlvdXRzL3NoYXJlZC9CYXNlTGF5b3V0LnRzP2RkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi8uLi9wb2x5ZmlsbExvYWRlcnMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IHtcbiAgTGF5b3V0LFxuICBDaGlsZFBvc2l0aW9ucyxcbiAgUG9zaXRpb25zLFxuICBTY3JvbGxEaXJlY3Rpb24sXG4gIFNpemUsXG4gIGRpbWVuc2lvbixcbiAgcG9zaXRpb24sXG4gIEludGVybmFsUmFuZ2UsXG4gIFBpbk9wdGlvbnMsXG4gIFNjcm9sbFRvQ29vcmRpbmF0ZXMsXG4gIEJhc2VMYXlvdXRDb25maWcsXG59IGZyb20gJy4vTGF5b3V0LmpzJztcblxudHlwZSBVcGRhdGVWaXNpYmxlSW5kaWNlc09wdGlvbnMgPSB7XG4gIGVtaXQ/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbTEoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBkaW1lbnNpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW0yKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogZGltZW5zaW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zMShkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IHBvc2l0aW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2xlZnQnIDogJ3RvcCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3MyKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogcG9zaXRpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndG9wJyA6ICdsZWZ0Jztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VMYXlvdXQ8QyBleHRlbmRzIEJhc2VMYXlvdXRDb25maWc+IGltcGxlbWVudHMgTGF5b3V0IHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IHNldCB2aWV3cG9ydCBzY3JvbGwgcG9zaXRpb24uXG4gICAqL1xuICBwcml2YXRlIF9sYXRlc3RDb29yZHM6IFBvc2l0aW9ucyA9IHtsZWZ0OiAwLCB0b3A6IDB9O1xuXG4gIC8qKlxuICAgKiBTY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBfZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogRGltZW5zaW9ucyBvZiB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF92aWV3cG9ydFNpemU6IFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG5cbiAgcHVibGljIHRvdGFsU2Nyb2xsU2l6ZTogU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcblxuICBwdWJsaWMgb2Zmc2V0V2l0aGluU2Nyb2xsZXI6IFBvc2l0aW9ucyA9IHtsZWZ0OiAwLCB0b3A6IDB9O1xuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBkZWJvdW5jaW5nIGFzeW5jaG5yb25vdXMgcmVmbG93IHJlcXVlc3RzLlxuICAgKi9cbiAgcHJpdmF0ZSBfcGVuZGluZ1JlZmxvdyA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3BlbmRpbmdMYXlvdXRVcGRhdGUgPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgX3BpbjogUGluT3B0aW9ucyB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gaW50ZXJzZWN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByb3RlY3RlZCBfZmlyc3RWaXNpYmxlID0gMDtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gaW50ZXJzZWN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByb3RlY3RlZCBfbGFzdFZpc2libGUgPSAwO1xuXG4gIHByaXZhdGUgX2V2ZW50VGFyZ2V0UHJvbWlzZTogUHJvbWlzZTx2b2lkPiA9IEV2ZW50VGFyZ2V0KCkudGhlbigoQ3RvcikgPT4ge1xuICAgIHRoaXMuX2V2ZW50VGFyZ2V0ID0gbmV3IEN0b3IoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBpeGVsIG9mZnNldCBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbiBvZiB0aGUgZmlyc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3BoeXNpY2FsTWluID0gMDtcblxuICAvKipcbiAgICogUGl4ZWwgb2Zmc2V0IGluIHRoZSBzY3JvbGwgZGlyZWN0aW9uIG9mIHRoZSBsYXN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9waHlzaWNhbE1heCA9IDA7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBjaGlsZC5cbiAgICovXG4gIHByb3RlY3RlZCBfZmlyc3QgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xhc3QgPSAtMTtcblxuICAvKipcbiAgICogTGVuZ3RoIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zaXplRGltOiBkaW1lbnNpb24gPSAnaGVpZ2h0JztcblxuICAvKipcbiAgICogTGVuZ3RoIGluIHRoZSBub24tc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Vjb25kYXJ5U2l6ZURpbTogZGltZW5zaW9uID0gJ3dpZHRoJztcblxuICAvKipcbiAgICogUG9zaXRpb24gaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Bvc2l0aW9uRGltOiBwb3NpdGlvbiA9ICd0b3AnO1xuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpbiB0aGUgbm9uLXNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NlY29uZGFyeVBvc2l0aW9uRGltOiBwb3NpdGlvbiA9ICdsZWZ0JztcblxuICAvKipcbiAgICogQ3VycmVudCBzY3JvbGwgb2Zmc2V0IGluIHBpeGVscy5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Nyb2xsUG9zaXRpb24gPSAwO1xuXG4gIC8qKlxuICAgKiBEaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBzY3JvbGwgb2Zmc2V0IGFuZCBzY3JvbGwgb2Zmc2V0IGNhbGN1bGF0ZWQgZHVlXG4gICAqIHRvIGEgcmVmbG93LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zY3JvbGxFcnJvciA9IDA7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiBpdGVtcyB0aGF0IGNvdWxkIHBvc3NpYmx5IGJlIGRpc3BsYXllZC4gVXNlZCB0byBoZWxwXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2Nyb2xsIHNpemUuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2l0ZW1zOiB1bmtub3duW10gPSBbXTtcblxuICAvKipcbiAgICogVGhlIHRvdGFsIChlc3RpbWF0ZWQpIGxlbmd0aCBvZiBhbGwgaXRlbXMgaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbFNpemUgPSAxO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJleW9uZCB0aGUgdmlld3BvcnQgdG8gc3RpbGwgaW5jbHVkZVxuICAgKiBpbiB0aGUgYWN0aXZlIHJhbmdlIG9mIGl0ZW1zLlxuICAgKi9cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFByb2JhYmx5IHdhbnQgdG8gbWFrZSB0aGlzIHNvbWV0aGluZyB3ZSBjYWxjdWxhdGUgYmFzZWRcbiAgLy8gb24gdmlld3BvcnQgc2l6ZSwgaXRlbSBzaXplLCBvdGhlciBmYWN0b3JzLCBwb3NzaWJseSBzdGlsbCB3aXRoIGEgZGlhbCBvZiBzb21lIGtpbmRcbiAgcHJvdGVjdGVkIF9vdmVyaGFuZyA9IDEwMDA7XG5cbiAgcHJpdmF0ZSBfZXZlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJvdGVjdGVkIGdldCBfZGVmYXVsdENvbmZpZygpOiBDIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICAgIH0gYXMgQztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZz86IEMpIHtcbiAgICAvLyBEZWxheSBzZXR0aW5nIGNvbmZpZyBzbyB0aGF0IHN1YmNsYXNzZXMgZG8gc2V0dXAgd29yayBmaXJzdFxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gKHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHRoaXMuX2RlZmF1bHRDb25maWcpKTtcbiAgfVxuXG4gIHNldCBjb25maWcoY29uZmlnOiBDKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9kZWZhdWx0Q29uZmlnLCBjb25maWcpKTtcbiAgfVxuXG4gIGdldCBjb25maWcoKTogQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXG4gICAgfSBhcyBDO1xuICB9XG5cbiAgLyoqXG4gICAqIE1heGltdW0gaW5kZXggb2YgY2hpbGRyZW4gKyAxLCB0byBoZWxwIGVzdGltYXRlIHRvdGFsIGhlaWdodCBvZiB0aGUgc2Nyb2xsXG4gICAqIHNwYWNlLlxuICAgKi9cbiAgZ2V0IGl0ZW1zKCk6IHVua25vd25bXSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICB9XG4gIHNldCBpdGVtcyhpdGVtczogdW5rbm93bltdKSB7XG4gICAgaWYgKGl0ZW1zICE9PSB0aGlzLl9pdGVtcykge1xuICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByaW1hcnkgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIGdldCBkaXJlY3Rpb24oKTogU2Nyb2xsRGlyZWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uITtcbiAgfVxuICBzZXQgZGlyZWN0aW9uKGRpcikge1xuICAgIC8vIEZvcmNlIGl0IHRvIGJlIGVpdGhlciBob3Jpem9udGFsIG9yIHZlcnRpY2FsLlxuICAgIGRpciA9IGRpciA9PT0gJ2hvcml6b250YWwnID8gZGlyIDogJ3ZlcnRpY2FsJztcbiAgICBpZiAoZGlyICE9PSB0aGlzLl9kaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcjtcbiAgICAgIHRoaXMuX3NpemVEaW0gPSBkaXIgPT09ICdob3Jpem9udGFsJyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgIHRoaXMuX3NlY29uZGFyeVNpemVEaW0gPSBkaXIgPT09ICdob3Jpem9udGFsJyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHRoaXMuX3Bvc2l0aW9uRGltID0gZGlyID09PSAnaG9yaXpvbnRhbCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHRoaXMuX3NlY29uZGFyeVBvc2l0aW9uRGltID0gZGlyID09PSAnaG9yaXpvbnRhbCcgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgIHRoaXMuX3RyaWdnZXJSZWZsb3coKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBnZXQgdmlld3BvcnRTaXplKCk6IFNpemUge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNpemU7XG4gIH1cbiAgc2V0IHZpZXdwb3J0U2l6ZShkaW1zKSB7XG4gICAgY29uc3Qge192aWV3RGltMSwgX3ZpZXdEaW0yfSA9IHRoaXM7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl92aWV3cG9ydFNpemUsIGRpbXMpO1xuICAgIGlmIChfdmlld0RpbTIgIT09IHRoaXMuX3ZpZXdEaW0yKSB7XG4gICAgICAvLyB0aGlzLl92aWV3RGltMkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0VXBkYXRlKCk7XG4gICAgfSBlbHNlIGlmIChfdmlld0RpbTEgIT09IHRoaXMuX3ZpZXdEaW0xKSB7XG4gICAgICB0aGlzLl9jaGVja1RocmVzaG9sZHMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIG9mZnNldCBvZiB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBnZXQgdmlld3BvcnRTY3JvbGwoKTogUG9zaXRpb25zIHtcbiAgICByZXR1cm4gdGhpcy5fbGF0ZXN0Q29vcmRzO1xuICB9XG4gIHNldCB2aWV3cG9ydFNjcm9sbChjb29yZHMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX2xhdGVzdENvb3JkcywgY29vcmRzKTtcbiAgICBjb25zdCBvbGRQb3MgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbjtcbiAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiA9IHRoaXMuX2xhdGVzdENvb3Jkc1t0aGlzLl9wb3NpdGlvbkRpbV07XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5hYnMob2xkUG9zIC0gdGhpcy5fc2Nyb2xsUG9zaXRpb24pO1xuICAgIGlmIChjaGFuZ2UgPj0gMSkge1xuICAgICAgdGhpcy5fdXBkYXRlVmlzaWJsZUluZGljZXMoe2VtaXQ6IHRydWV9KTtcbiAgICB9XG4gICAgdGhpcy5fY2hlY2tUaHJlc2hvbGRzKCk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIHJlZmxvdyBpZiBvbmUgaGFzIGJlZW4gc2NoZWR1bGVkLlxuICAgKi9cbiAgcmVmbG93SWZOZWVkZWQoZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmIChmb3JjZSB8fCB0aGlzLl9wZW5kaW5nUmVmbG93KSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVmbG93ID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICB9XG4gIH1cblxuICBzZXQgcGluKG9wdGlvbnM6IFBpbk9wdGlvbnMgfCBudWxsKSB7XG4gICAgdGhpcy5fcGluID0gb3B0aW9ucztcbiAgICB0aGlzLl90cmlnZ2VyUmVmbG93KCk7XG4gIH1cblxuICBnZXQgcGluKCkge1xuICAgIGlmICh0aGlzLl9waW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtpbmRleCwgYmxvY2t9ID0gdGhpcy5fcGluO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpKSxcbiAgICAgICAgYmxvY2ssXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9jbGFtcFNjcm9sbFBvc2l0aW9uKHZhbDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgLXRoaXMub2Zmc2V0V2l0aGluU2Nyb2xsZXJbdGhpcy5fcG9zaXRpb25EaW1dLFxuICAgICAgTWF0aC5taW4odmFsLCB0aGlzLnRvdGFsU2Nyb2xsU2l6ZVtkaW0xKHRoaXMuZGlyZWN0aW9uKV0gLSB0aGlzLl92aWV3RGltMSlcbiAgICApO1xuICB9XG5cbiAgdW5waW4oKSB7XG4gICAgaWYgKHRoaXMuX3BpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW1pdFVucGlubmVkKCk7XG4gICAgICB0aGlzLl9waW4gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRpc3BhdGNoRXZlbnQoZXZ0OiBFdmVudCkge1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICB0aGlzLl9ldmVudFRhcmdldCEuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgYXN5bmMgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXIgfCBFdmVudExpc3RlbmVyT2JqZWN0IHwgbnVsbCxcbiAgICBvcHRpb25zPzogYm9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgdW5kZWZpbmVkXG4gICkge1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICB0aGlzLl9ldmVudFRhcmdldCEuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyByZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBjYWxsYmFjazogRXZlbnRMaXN0ZW5lciB8IEV2ZW50TGlzdGVuZXJPYmplY3QgfCBudWxsLFxuICAgIG9wdGlvbnM/OiBib29sZWFuIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCB1bmRlZmluZWRcbiAgKSB7XG4gICAgYXdhaXQgdGhpcy5fZXZlbnRUYXJnZXRQcm9taXNlO1xuICAgIHRoaXMuX2V2ZW50VGFyZ2V0IS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvcCBhbmQgbGVmdCBwb3NpdGlvbmluZyBvZiB0aGUgaXRlbSBhdCBpZHguXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2dldEl0ZW1Qb3NpdGlvbihpZHg6IG51bWJlcik6IFBvc2l0aW9ucztcblxuICAvKipcbiAgICogVXBkYXRlIF9maXJzdCBhbmQgX2xhc3QgYmFzZWQgb24gaXRlbXMgdGhhdCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnRcbiAgICogcmFuZ2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2dldEFjdGl2ZUl0ZW1zKCk6IHZvaWQ7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXRJdGVtU2l6ZShfaWR4OiBudW1iZXIpOiBTaXplO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIChwcmVjaXNlbHkgb3IgYnkgZXN0aW1hdGluZywgaWYgbmVlZGVkKSB0aGUgdG90YWwgbGVuZ3RoIG9mIGFsbCBpdGVtcyBpblxuICAgKiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiwgaW5jbHVkaW5nIHNwYWNpbmcsIGNhY2hpbmcgdGhlIHZhbHVlIGluIHRoZSBgX3Njcm9sbFNpemVgIGZpZWxkLlxuICAgKlxuICAgKiBTaG91bGQgcmV0dXJuIGEgbWluaW11bSB2YWx1ZSBvZiAxIHRvIGVuc3VyZSBhdCBsZWFzdCBvbmUgaXRlbSBpcyByZW5kZXJlZC5cbiAgICogVE9ETyAoZ3JheW5vcnRvbik6IFBvc3NpYmx5IG5vIGxvbmdlciByZXF1aXJlZCwgYnV0IGxlYXZpbmcgaGVyZSB1bnRpbCBpdCBjYW4gYmUgdmVyaWZpZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX3VwZGF0ZVNjcm9sbFNpemUoKTogdm9pZDtcblxuICBwcm90ZWN0ZWQgX3VwZGF0ZUxheW91dCgpOiB2b2lkIHtcbiAgICAvLyBPdmVycmlkZVxuICB9XG5cbiAgLy8gcHJvdGVjdGVkIF92aWV3RGltMkNoYW5nZWQoKTogdm9pZCB7XG4gIC8vICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRVcGRhdGUoKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCwgd2hpY2hldmVyIGNvcnJlc3BvbmRzIHRvIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBfdmlld0RpbTEoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTaXplW3RoaXMuX3NpemVEaW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIHZpZXdwb3J0LCB3aGljaGV2ZXIgZG9lcyBOT1QgY29ycmVzcG9uZCB0byB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBnZXQgX3ZpZXdEaW0yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZVt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2NoZWR1bGVSZWZsb3coKSB7XG4gICAgdGhpcy5fcGVuZGluZ1JlZmxvdyA9IHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NjaGVkdWxlTGF5b3V0VXBkYXRlKCkge1xuICAgIHRoaXMuX3BlbmRpbmdMYXlvdXRVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gIH1cblxuICAvLyBGb3IgdHJpZ2dlcmluZyBhIHJlZmxvdyBiYXNlZCBvbiBpbmNvbWluZyBjaGFuZ2VzIHRvXG4gIC8vIHRoZSBsYXlvdXQgY29uZmlnLlxuICBwcm90ZWN0ZWQgX3RyaWdnZXJSZWZsb3coKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRVcGRhdGUoKTtcbiAgICAvLyBUT0RPIGdyYXlub3J0b25AOiByZWZsb3dJZk5lZWRlZCgpIGlzbid0IHJlYWxseSBzdXBwb3NlZFxuICAgIC8vIHRvIGJlIGNhbGxlZCBpbnRlcm5hbGx5LiBBZGRyZXNzIGluIGxhcmdlciBjbGVhbnVwXG4gICAgLy8gb2YgdmlydHVhbGl6ZXIgLyBsYXlvdXQgaW50ZXJhY3Rpb24gcGF0dGVybi5cbiAgICAvLyB0aGlzLnJlZmxvd0lmTmVlZGVkKHRydWUpO1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy5yZWZsb3dJZk5lZWRlZCgpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVmbG93KCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nTGF5b3V0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcbiAgICAgIHRoaXMuX3BlbmRpbmdMYXlvdXRVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsU2l6ZSgpO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uRnJvbVBpbigpO1xuICAgIHRoaXMuX2dldEFjdGl2ZUl0ZW1zKCk7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcbiAgICB0aGlzLl9lbWl0U2Nyb2xsU2l6ZSgpO1xuICAgIHRoaXMuX2VtaXRSYW5nZSgpO1xuICAgIHRoaXMuX2VtaXRDaGlsZFBvc2l0aW9ucygpO1xuICAgIHRoaXMuX2VtaXRTY3JvbGxFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGFyZSBzdXBwb3NlZCB0byBiZSBwaW5uZWQgdG8gYSBwYXJ0aWN1bGFyXG4gICAqIGl0ZW0gb3Igc2V0IG9mIGNvb3JkaW5hdGVzLCB3ZSBzZXQgYF9zY3JvbGxQb3NpdGlvbmBcbiAgICogYWNjb3JkaW5nbHkgYW5kIGFkanVzdCBgX3Njcm9sbEVycm9yYCBhcyBuZWVkZWRcbiAgICogc28gdGhhdCB0aGUgdmlydHVhbGl6ZXIgY2FuIGtlZXAgdGhlIHNjcm9sbFxuICAgKiBwb3NpdGlvbiBpbiB0aGUgRE9NIGluIHN5bmNcbiAgICovXG4gIHByb3RlY3RlZCBfc2V0UG9zaXRpb25Gcm9tUGluKCkge1xuICAgIGlmICh0aGlzLnBpbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFzdFNjcm9sbFBvc2l0aW9uID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgICBjb25zdCB7aW5kZXgsIGJsb2NrfSA9IHRoaXMucGluO1xuICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVTY3JvbGxJbnRvVmlld1Bvc2l0aW9uKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBibG9jazogYmxvY2sgfHwgJ3N0YXJ0JyxcbiAgICAgICAgfSkgLSB0aGlzLm9mZnNldFdpdGhpblNjcm9sbGVyW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yID0gbGFzdFNjcm9sbFBvc2l0aW9uIC0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIHRvIHNjcm9sbCB0bywgZ2l2ZW5cbiAgICogYSByZXF1ZXN0IHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCBhdCBhIHNwZWNpZmljXG4gICAqIGluZGV4LlxuICAgKlxuICAgKiBTdXBwb3J0cyB0aGUgc2FtZSBwb3NpdGlvbmluZyBvcHRpb25zIChgc3RhcnRgLFxuICAgKiBgY2VudGVyYCwgYGVuZGAsIGBuZWFyZXN0YCkgYXMgdGhlIHN0YW5kYXJkXG4gICAqIGBFbGVtZW50LnNjcm9sbEludG9WaWV3KClgIG1ldGhvZCwgYnV0IGN1cnJlbnRseVxuICAgKiBvbmx5IGNvbnNpZGVycyB0aGUgcHJvdmlkZWQgdmFsdWUgaW4gdGhlIGBibG9ja2BcbiAgICogZGltZW5zaW9uLCBzaW5jZSB3ZSBkb24ndCB5ZXQgaGF2ZSBhbnkgbGF5b3V0c1xuICAgKiB0aGF0IHN1cHBvcnQgdmlydHVhbGl6YXRpb24gaW4gdHdvIGRpbWVuc2lvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZVNjcm9sbEludG9WaWV3UG9zaXRpb24ob3B0aW9uczogUGluT3B0aW9ucykge1xuICAgIGNvbnN0IHtibG9ja30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5taW4odGhpcy5pdGVtcy5sZW5ndGgsIE1hdGgubWF4KDAsIG9wdGlvbnMuaW5kZXgpKTtcbiAgICBjb25zdCBpdGVtU3RhcnRQb3NpdGlvbiA9IHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpbmRleClbdGhpcy5fcG9zaXRpb25EaW1dO1xuICAgIGxldCBzY3JvbGxQb3NpdGlvbiA9IGl0ZW1TdGFydFBvc2l0aW9uO1xuICAgIGlmIChibG9jayAhPT0gJ3N0YXJ0Jykge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLl9nZXRJdGVtU2l6ZShpbmRleClbdGhpcy5fc2l6ZURpbV07XG4gICAgICBpZiAoYmxvY2sgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHNjcm9sbFBvc2l0aW9uID1cbiAgICAgICAgICBpdGVtU3RhcnRQb3NpdGlvbiAtIDAuNSAqIHRoaXMuX3ZpZXdEaW0xICsgMC41ICogaXRlbVNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtRW5kUG9zaXRpb24gPSBpdGVtU3RhcnRQb3NpdGlvbiAtIHRoaXMuX3ZpZXdEaW0xICsgaXRlbVNpemU7XG4gICAgICAgIGlmIChibG9jayA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICBzY3JvbGxQb3NpdGlvbiA9IGl0ZW1FbmRQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBibG9jayA9PT0gJ25lYXJlc3QnXG4gICAgICAgICAgY29uc3QgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgICAgICAgc2Nyb2xsUG9zaXRpb24gPVxuICAgICAgICAgICAgTWF0aC5hYnMoY3VycmVudFNjcm9sbFBvc2l0aW9uIC0gaXRlbVN0YXJ0UG9zaXRpb24pIDxcbiAgICAgICAgICAgIE1hdGguYWJzKGN1cnJlbnRTY3JvbGxQb3NpdGlvbiAtIGl0ZW1FbmRQb3NpdGlvbilcbiAgICAgICAgICAgICAgPyBpdGVtU3RhcnRQb3NpdGlvblxuICAgICAgICAgICAgICA6IGl0ZW1FbmRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGxQb3NpdGlvbiArPSB0aGlzLm9mZnNldFdpdGhpblNjcm9sbGVyW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICByZXR1cm4gdGhpcy5fY2xhbXBTY3JvbGxQb3NpdGlvbihzY3JvbGxQb3NpdGlvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0U2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlcyhcbiAgICBvcHRpb25zOiBQaW5PcHRpb25zXG4gICk6IFNjcm9sbFRvQ29vcmRpbmF0ZXMge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fcG9zaXRpb25EaW0gYXMgcG9zaXRpb25dOlxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVTY3JvbGxJbnRvVmlld1Bvc2l0aW9uKG9wdGlvbnMpLFxuICAgIH0gYXMgU2Nyb2xsVG9PcHRpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBfZW1pdFVucGlubmVkKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3VucGlubmVkJykpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lbWl0UmFuZ2UoKSB7XG4gICAgY29uc3QgZGV0YWlsOiBJbnRlcm5hbFJhbmdlID0ge1xuICAgICAgZmlyc3Q6IHRoaXMuX2ZpcnN0LFxuICAgICAgbGFzdDogdGhpcy5fbGFzdCxcbiAgICAgIGZpcnN0VmlzaWJsZTogdGhpcy5fZmlyc3RWaXNpYmxlLFxuICAgICAgbGFzdFZpc2libGU6IHRoaXMuX2xhc3RWaXNpYmxlLFxuICAgIH07XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgncmFuZ2VjaGFuZ2UnLCB7ZGV0YWlsfSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lbWl0U2Nyb2xsU2l6ZSgpIHtcbiAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICBbdGhpcy5fc2l6ZURpbV06IHRoaXMuX3Njcm9sbFNpemUsXG4gICAgICBbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV06IG51bGwsXG4gICAgfTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzY3JvbGxzaXplY2hhbmdlJywge2RldGFpbH0pKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfZW1pdFNjcm9sbEVycm9yKCkge1xuICAgIGlmICh0aGlzLl9zY3JvbGxFcnJvcikge1xuICAgICAgY29uc3QgZGV0YWlsID0ge1xuICAgICAgICBbdGhpcy5fcG9zaXRpb25EaW1dOiB0aGlzLl9zY3JvbGxFcnJvcixcbiAgICAgICAgW3RoaXMuX3NlY29uZGFyeVBvc2l0aW9uRGltXTogMCxcbiAgICAgIH07XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzY3JvbGxlcnJvcmNoYW5nZScsIHtkZXRhaWx9KSk7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBlc3RpbWF0ZSB0aGUgdG9wIGFuZCBsZWZ0IHBvc2l0aW9ucyBvZiBpdGVtcyBpbiB0aGUgY3VycmVudCByYW5nZS5cbiAgICogRW1pdCBhbiBpdGVtcG9zaXRpb25jaGFuZ2UgZXZlbnQgd2l0aCB0aGVzZSBwb3NpdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2VtaXRDaGlsZFBvc2l0aW9ucygpIHtcbiAgICBpZiAodGhpcy5fZmlyc3QgIT09IC0xICYmIHRoaXMuX2xhc3QgIT09IC0xKSB7XG4gICAgICBjb25zdCBkZXRhaWw6IENoaWxkUG9zaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChsZXQgaWR4ID0gdGhpcy5fZmlyc3Q7IGlkeCA8PSB0aGlzLl9sYXN0OyBpZHgrKykge1xuICAgICAgICBkZXRhaWwuc2V0KGlkeCwgdGhpcy5fZ2V0SXRlbVBvc2l0aW9uKGlkeCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaXRlbXBvc2l0aW9uY2hhbmdlJywge2RldGFpbH0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIHRvIGRpc3BsYXkuXG4gICAqL1xuICBwcml2YXRlIGdldCBfbnVtKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ID09PSAtMSB8fCB0aGlzLl9sYXN0ID09PSAtMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sYXN0IC0gdGhpcy5fZmlyc3QgKyAxO1xuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tUaHJlc2hvbGRzKCkge1xuICAgIGlmICgodGhpcy5fdmlld0RpbTEgPT09IDAgJiYgdGhpcy5fbnVtID4gMCkgfHwgdGhpcy5fcGluICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIHRoaXMuX292ZXJoYW5nKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKFxuICAgICAgICB0aGlzLl9zY3JvbGxTaXplLFxuICAgICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xICsgdGhpcy5fb3ZlcmhhbmdcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5fcGh5c2ljYWxNaW4gPiBtaW4gfHwgdGhpcy5fcGh5c2ljYWxNYXggPCBtYXgpIHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kaWNlcyBvZiB0aGUgZmlyc3QgYW5kIGxhc3QgaXRlbXMgdG8gaW50ZXJzZWN0IHRoZSB2aWV3cG9ydC5cbiAgICogRW1pdCBhIHZpc2libGVpbmRpY2VzY2hhbmdlIGV2ZW50IHdoZW4gZWl0aGVyIGluZGV4IGNoYW5nZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3VwZGF0ZVZpc2libGVJbmRpY2VzKG9wdGlvbnM/OiBVcGRhdGVWaXNpYmxlSW5kaWNlc09wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fZmlyc3QgPT09IC0xIHx8IHRoaXMuX2xhc3QgPT09IC0xKSByZXR1cm47XG5cbiAgICBsZXQgZmlyc3RWaXNpYmxlID0gdGhpcy5fZmlyc3Q7XG4gICAgd2hpbGUgKFxuICAgICAgZmlyc3RWaXNpYmxlIDwgdGhpcy5fbGFzdCAmJlxuICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgdGhpcy5fZ2V0SXRlbVBvc2l0aW9uKGZpcnN0VmlzaWJsZSlbdGhpcy5fcG9zaXRpb25EaW1dICtcbiAgICAgICAgICB0aGlzLl9nZXRJdGVtU2l6ZShmaXJzdFZpc2libGUpW3RoaXMuX3NpemVEaW1dXG4gICAgICApIDw9IE1hdGgucm91bmQodGhpcy5fc2Nyb2xsUG9zaXRpb24pXG4gICAgKSB7XG4gICAgICBmaXJzdFZpc2libGUrKztcbiAgICB9XG5cbiAgICBsZXQgbGFzdFZpc2libGUgPSB0aGlzLl9sYXN0O1xuICAgIHdoaWxlIChcbiAgICAgIGxhc3RWaXNpYmxlID4gdGhpcy5fZmlyc3QgJiZcbiAgICAgIE1hdGgucm91bmQodGhpcy5fZ2V0SXRlbVBvc2l0aW9uKGxhc3RWaXNpYmxlKVt0aGlzLl9wb3NpdGlvbkRpbV0pID49XG4gICAgICAgIE1hdGgucm91bmQodGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSlcbiAgICApIHtcbiAgICAgIGxhc3RWaXNpYmxlLS07XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZmlyc3RWaXNpYmxlICE9PSB0aGlzLl9maXJzdFZpc2libGUgfHxcbiAgICAgIGxhc3RWaXNpYmxlICE9PSB0aGlzLl9sYXN0VmlzaWJsZVxuICAgICkge1xuICAgICAgdGhpcy5fZmlyc3RWaXNpYmxlID0gZmlyc3RWaXNpYmxlO1xuICAgICAgdGhpcy5fbGFzdFZpc2libGUgPSBsYXN0VmlzaWJsZTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW1pdCkge1xuICAgICAgICB0aGlzLl9lbWl0UmFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventTarget)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\nlet ET;\nasync function EventTarget() {\n  return ET || init();\n}\nasync function init() {\n  _ET = window.EventTarget;\n  try {\n    new _ET();\n  } catch {\n    _ET = (await __webpack_require__.e(/*! import() */ \"vendors-node_modules_event-target-shim_index_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! event-target-shim */ \"./node_modules/event-target-shim/index.mjs\"))).EventTarget;\n  }\n  return ET = _ET;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3BvbHlmaWxsTG9hZGVycy9FdmVudFRhcmdldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0FBWUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvcG9seWZpbGxMb2FkZXJzL0V2ZW50VGFyZ2V0LnRzP2MxYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbnR5cGUgRXZlbnRUYXJnZXRNb2R1bGUgPSB0eXBlb2YgaW1wb3J0KCdldmVudC10YXJnZXQtc2hpbScpO1xuXG5pbnRlcmZhY2UgRXZlbnRUYXJnZXRDb25zdHJ1Y3RvciB7XG4gIG5ldyAoKTogRXZlbnRUYXJnZXQ7XG59XG5cbmxldCBfRVQ6IEV2ZW50VGFyZ2V0TW9kdWxlIHwgRXZlbnRUYXJnZXRDb25zdHJ1Y3RvcjtcbmxldCBFVDogRXZlbnRUYXJnZXRDb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHJldHVybiBFVCB8fCBpbml0KCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXQoKSB7XG4gIF9FVCA9IHdpbmRvdy5FdmVudFRhcmdldDtcbiAgdHJ5IHtcbiAgICBuZXcgX0VUKCk7XG4gIH0gY2F0Y2gge1xuICAgIF9FVCA9IChhd2FpdCBpbXBvcnQoJ2V2ZW50LXRhcmdldC1zaGltJykpLkV2ZW50VGFyZ2V0O1xuICB9XG4gIHJldHVybiAoRVQgPSBfRVQpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\n");

/***/ })

}]);