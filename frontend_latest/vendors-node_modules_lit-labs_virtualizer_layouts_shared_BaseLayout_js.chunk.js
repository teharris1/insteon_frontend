"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseLayout\": () => (/* binding */ BaseLayout),\n/* harmony export */   \"dim1\": () => (/* binding */ dim1),\n/* harmony export */   \"dim2\": () => (/* binding */ dim2),\n/* harmony export */   \"pos1\": () => (/* binding */ pos1),\n/* harmony export */   \"pos2\": () => (/* binding */ pos2)\n/* harmony export */ });\n/* harmony import */ var _polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../polyfillLoaders/EventTarget.js */ \"./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nfunction dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nfunction dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nfunction pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nfunction pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nclass BaseLayout {\n  constructor(config) {\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    /**\n     * Flag for debouncing asynchnronous reflow requests.\n     */\n\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    /**\n     * Index of the item that has been scrolled to via the public API. When the\n     * viewport is otherwise scrolled, this value is set back to -1.\n     */\n\n    this._scrollToIndex = -1;\n    /**\n     * When a child is scrolled to, the offset from the top of the child and the\n     * top of the viewport. Value is a proportion of the item size.\n     */\n\n    this._scrollToAnchor = 0;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n\n    this._lastVisible = 0;\n    this._eventTargetPromise = (0,_polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then(Ctor => {\n      this._eventTarget = new Ctor();\n    });\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n\n    this._totalItems = 0;\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n\n    this._overhang = 1000;\n    this._eventTarget = null; // Delay setting config so that subclasses do setup work first\n\n    Promise.resolve().then(() => this.config = config || this._defaultConfig);\n  }\n\n  get _defaultConfig() {\n    return {\n      direction: 'vertical'\n    };\n  }\n\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n\n\n  get totalItems() {\n    return this._totalItems;\n  }\n\n  set totalItems(num) {\n    const _num = Number(num);\n\n    if (_num !== this._totalItems) {\n      this._totalItems = _num;\n\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n\n\n  get direction() {\n    return this._direction;\n  }\n\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n\n\n  get viewportSize() {\n    return this._viewportSize;\n  }\n\n  set viewportSize(dims) {\n    const {\n      _viewDim1,\n      _viewDim2\n    } = this;\n    Object.assign(this._viewportSize, dims);\n\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n\n\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n\n    if (oldPos !== this._scrollPosition) {\n      this._scrollPositionChanged(oldPos, this._scrollPosition);\n\n      this._updateVisibleIndices({\n        emit: true\n      });\n    }\n\n    this._checkThresholds();\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n\n\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n\n      this._reflow();\n    }\n  }\n  /**\n   * Scroll to the child at the given index, and the given position within that\n   * child.\n   */\n\n\n  scrollToIndex(index, position = 'start') {\n    if (!Number.isFinite(index)) return;\n    index = Math.min(this.totalItems, Math.max(0, index));\n    this._scrollToIndex = index;\n\n    if (position === 'nearest') {\n      position = index > this._first + this._num / 2 ? 'end' : 'start';\n    }\n\n    switch (position) {\n      case 'start':\n        this._scrollToAnchor = 0;\n        break;\n\n      case 'center':\n        this._scrollToAnchor = 0.5;\n        break;\n\n      case 'end':\n        this._scrollToAnchor = 1;\n        break;\n\n      default:\n        throw new TypeError('position must be one of: start, center, end, nearest');\n    }\n\n    this._scheduleReflow();\n  }\n\n  async dispatchEvent(evt) {\n    await this._eventTargetPromise;\n\n    this._eventTarget.dispatchEvent(evt);\n  }\n\n  async addEventListener(type, listener, options) {\n    await this._eventTargetPromise;\n\n    this._eventTarget.addEventListener(type, listener, options);\n  }\n\n  async removeEventListener(type, callback, options) {\n    await this._eventTargetPromise;\n\n    this._eventTarget.removeEventListener(type, callback, options);\n  }\n\n  _updateLayout() {// Override\n  } // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n\n\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n\n\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n\n    this._scheduleReflow();\n  } // For triggering a reflow based on incoming changes to\n  // the layout config.\n\n\n  _triggerReflow() {\n    this._scheduleLayoutUpdate(); // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n\n\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n\n      this._pendingLayoutUpdate = false;\n    }\n\n    this._updateScrollSize();\n\n    this._getActiveItems();\n\n    this._scrollIfNeeded();\n\n    this._updateVisibleIndices();\n\n    this._emitScrollSize();\n\n    this._emitRange();\n\n    this._emitChildPositions();\n\n    this._emitScrollError();\n  }\n\n  _scrollIfNeeded() {\n    if (this._scrollToIndex === -1) {\n      return;\n    }\n\n    const index = this._scrollToIndex;\n    const anchor = this._scrollToAnchor;\n\n    const pos = this._getItemPosition(index)[this._positionDim];\n\n    const size = this._getItemSize(index)[this._sizeDim];\n\n    const curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n    const newAnchorPos = pos + size * anchor; // Ensure scroll position is an integer within scroll bounds.\n\n    const scrollPosition = Math.floor(Math.min(this._scrollSize - this._viewDim1, Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n    this._scrollError += this._scrollPosition - scrollPosition;\n    this._scrollPosition = scrollPosition;\n  }\n\n  _emitRange(inProps = undefined) {\n    const detail = Object.assign({\n      first: this._first,\n      last: this._last,\n      num: this._num,\n      stable: true,\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    }, inProps);\n    this.dispatchEvent(new CustomEvent('rangechange', {\n      detail\n    }));\n  }\n\n  _emitScrollSize() {\n    const detail = {\n      [this._sizeDim]: this._scrollSize\n    };\n    this.dispatchEvent(new CustomEvent('scrollsizechange', {\n      detail\n    }));\n  }\n\n  _emitScrollError() {\n    if (this._scrollError) {\n      const detail = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this.dispatchEvent(new CustomEvent('scrollerrorchange', {\n        detail\n      }));\n      this._scrollError = 0;\n    }\n  }\n  /**\n   * Get or estimate the top and left positions of items in the current range.\n   * Emit an itempositionchange event with these positions.\n   */\n\n\n  _emitChildPositions() {\n    const detail = {};\n\n    for (let idx = this._first; idx <= this._last; idx++) {\n      detail[idx] = this._getItemPosition(idx);\n    }\n\n    this.dispatchEvent(new CustomEvent('itempositionchange', {\n      detail\n    }));\n  }\n  /**\n   * Number of items to display.\n   */\n\n\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n\n    return this._last - this._first + 1;\n  }\n\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n\n\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1) return;\n    let firstVisible = this._first;\n\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n\n      if (options && options.emit) {\n        this._emitRange();\n      }\n    }\n  }\n\n  _scrollPositionChanged(oldPos, newPos) {\n    // When both values are bigger than the max scroll position, keep the\n    // current _scrollToIndex, otherwise invalidate it.\n    const maxPos = this._scrollSize - this._viewDim1;\n\n    if (oldPos < maxPos || newPos < maxPos) {\n      this._scrollToIndex = -1;\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL0Jhc2VMYXlvdXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFXQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQStIQTtBQTlIQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBR0E7QUFFQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBOzs7O0FBR0E7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBOzs7O0FBR0E7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFJQTtBQUNBOztBQUNBO0FBRUE7O0FBVUE7QUFDQTs7QUFUQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFYQTs7QUFjQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQXdCQTtBQUVBO0FBR0E7QUFDQTs7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBRUE7O0FBQ0E7QUFTQTtBQUNBOztBQUVBOztBQUNBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE1ZEEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uLy4uL3NyYy9sYXlvdXRzL3NoYXJlZC9CYXNlTGF5b3V0LnRzP2RkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi8uLi9wb2x5ZmlsbExvYWRlcnMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IHtMYXlvdXQsIFBvc2l0aW9ucywgU2Nyb2xsRGlyZWN0aW9uLCBTaXplLCBkaW1lbnNpb24sIHBvc2l0aW9ufSBmcm9tICcuL0xheW91dC5qcyc7XG5cbnR5cGUgVXBkYXRlVmlzaWJsZUluZGljZXNPcHRpb25zID0ge1xuICBlbWl0PzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VMYXlvdXRDb25maWcge1xuICBkaXJlY3Rpb24/OiBTY3JvbGxEaXJlY3Rpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpbTEoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBkaW1lbnNpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnOiAnaGVpZ2h0Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpbTIoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBkaW1lbnNpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnaGVpZ2h0JzogJ3dpZHRoJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvczEoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBwb3NpdGlvbiB7XG4gIHJldHVybiBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICdsZWZ0JzogJ3RvcCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3MyKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogcG9zaXRpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndG9wJzogJ2xlZnQnO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUxheW91dDxDIGV4dGVuZHMgQmFzZUxheW91dENvbmZpZz4gaW1wbGVtZW50cyBMYXlvdXQge1xuICAvKipcbiAgICogVGhlIGxhc3Qgc2V0IHZpZXdwb3J0IHNjcm9sbCBwb3NpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX2xhdGVzdENvb3JkczogUG9zaXRpb25zID0ge2xlZnQ6IDAsIHRvcDogMH07XG5cbiAgLyoqXG4gICAqIFNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIF9kaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBEaW1lbnNpb25zIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByaXZhdGUgX3ZpZXdwb3J0U2l6ZTogU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcblxuICAvKipcbiAgICogRmxhZyBmb3IgZGVib3VuY2luZyBhc3luY2hucm9ub3VzIHJlZmxvdyByZXF1ZXN0cy5cbiAgICovXG4gIHByaXZhdGUgX3BlbmRpbmdSZWZsb3cgPSBmYWxzZTtcblxuICBwcml2YXRlIF9wZW5kaW5nTGF5b3V0VXBkYXRlID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBpdGVtIHRoYXQgaGFzIGJlZW4gc2Nyb2xsZWQgdG8gdmlhIHRoZSBwdWJsaWMgQVBJLiBXaGVuIHRoZVxuICAgKiB2aWV3cG9ydCBpcyBvdGhlcndpc2Ugc2Nyb2xsZWQsIHRoaXMgdmFsdWUgaXMgc2V0IGJhY2sgdG8gLTEuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbFRvSW5kZXggPSAtMTtcblxuICAvKipcbiAgICogV2hlbiBhIGNoaWxkIGlzIHNjcm9sbGVkIHRvLCB0aGUgb2Zmc2V0IGZyb20gdGhlIHRvcCBvZiB0aGUgY2hpbGQgYW5kIHRoZVxuICAgKiB0b3Agb2YgdGhlIHZpZXdwb3J0LiBWYWx1ZSBpcyBhIHByb3BvcnRpb24gb2YgdGhlIGl0ZW0gc2l6ZS5cbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbFRvQW5jaG9yID0gMDtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2ZpcnN0VmlzaWJsZSA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xhc3RWaXNpYmxlID0gMDtcblxuICBwcml2YXRlIF9ldmVudFRhcmdldFByb21pc2U6IFByb21pc2U8dm9pZD4gPSAoRXZlbnRUYXJnZXQoKS50aGVuKChDdG9yKSA9PiB7XG4gICAgdGhpcy5fZXZlbnRUYXJnZXQgPSBuZXcgQ3RvcigpO1xuICB9KSk7XG5cbiAgLyoqXG4gICAqIFBpeGVsIG9mZnNldCBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbiBvZiB0aGUgZmlyc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3BoeXNpY2FsTWluID0gMDtcblxuICAvKipcbiAgICogUGl4ZWwgb2Zmc2V0IGluIHRoZSBzY3JvbGwgZGlyZWN0aW9uIG9mIHRoZSBsYXN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9waHlzaWNhbE1heCA9IDA7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBjaGlsZC5cbiAgICovXG4gIHByb3RlY3RlZCBfZmlyc3QgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xhc3QgPSAtMTtcblxuICAvKipcbiAgICogTGVuZ3RoIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zaXplRGltOiBkaW1lbnNpb24gPSAnaGVpZ2h0JztcblxuICAvKipcbiAgICogTGVuZ3RoIGluIHRoZSBub24tc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Vjb25kYXJ5U2l6ZURpbTogZGltZW5zaW9uID0gJ3dpZHRoJztcblxuICAvKipcbiAgICogUG9zaXRpb24gaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Bvc2l0aW9uRGltOiBwb3NpdGlvbiA9ICd0b3AnO1xuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpbiB0aGUgbm9uLXNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NlY29uZGFyeVBvc2l0aW9uRGltOiBwb3NpdGlvbiA9ICdsZWZ0JztcblxuICAvKipcbiAgICogQ3VycmVudCBzY3JvbGwgb2Zmc2V0IGluIHBpeGVscy5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Nyb2xsUG9zaXRpb24gPSAwO1xuXG4gIC8qKlxuICAgKiBEaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBzY3JvbGwgb2Zmc2V0IGFuZCBzY3JvbGwgb2Zmc2V0IGNhbGN1bGF0ZWQgZHVlXG4gICAqIHRvIGEgcmVmbG93LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zY3JvbGxFcnJvciA9IDA7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiBpdGVtcyB0aGF0IGNvdWxkIHBvc3NpYmx5IGJlIGRpc3BsYXllZC4gVXNlZCB0byBoZWxwXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2Nyb2xsIHNpemUuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3RvdGFsSXRlbXMgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgdG90YWwgKGVzdGltYXRlZCkgbGVuZ3RoIG9mIGFsbCBpdGVtcyBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Nyb2xsU2l6ZSA9IDE7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgYmV5b25kIHRoZSB2aWV3cG9ydCB0byBzdGlsbCBpbmNsdWRlXG4gICAqIGluIHRoZSBhY3RpdmUgcmFuZ2Ugb2YgaXRlbXMuXG4gICAqL1xuICAvLyBUT0RPIChncmF5bm9ydG9uKTogUHJvYmFibHkgd2FudCB0byBtYWtlIHRoaXMgc29tZXRoaW5nIHdlIGNhbGN1bGF0ZSBiYXNlZFxuICAvLyBvbiB2aWV3cG9ydCBzaXplLCBpdGVtIHNpemUsIG90aGVyIGZhY3RvcnMsIHBvc3NpYmx5IHN0aWxsIHdpdGggYSBkaWFsIG9mIHNvbWUga2luZFxuICBwcm90ZWN0ZWQgX292ZXJoYW5nID0gMTAwMDtcblxuICBwcml2YXRlIF9ldmVudFRhcmdldDogRXZlbnRUYXJnZXQgfCBudWxsID0gbnVsbDtcblxuICBwcm90ZWN0ZWQgZ2V0IF9kZWZhdWx0Q29uZmlnKCkgOiBDIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnXG4gICAgfSBhcyBDXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBDKSB7XG4gICAgLy8gRGVsYXkgc2V0dGluZyBjb25maWcgc28gdGhhdCBzdWJjbGFzc2VzIGRvIHNldHVwIHdvcmsgZmlyc3RcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHRoaXMuX2RlZmF1bHRDb25maWcpO1xuICB9XG5cbiAgc2V0IGNvbmZpZyhjb25maWc6IEMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2RlZmF1bHRDb25maWcsIGNvbmZpZykpO1xuICB9XG5cbiAgZ2V0IGNvbmZpZygpOiBDIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvblxuICAgIH0gYXMgQztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIGluZGV4IG9mIGNoaWxkcmVuICsgMSwgdG8gaGVscCBlc3RpbWF0ZSB0b3RhbCBoZWlnaHQgb2YgdGhlIHNjcm9sbFxuICAgKiBzcGFjZS5cbiAgICovXG4gIGdldCB0b3RhbEl0ZW1zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsSXRlbXM7XG4gIH1cbiAgc2V0IHRvdGFsSXRlbXMobnVtKSB7XG4gICAgY29uc3QgX251bSA9IE51bWJlcihudW0pO1xuICAgIGlmIChfbnVtICE9PSB0aGlzLl90b3RhbEl0ZW1zKSB7XG4gICAgICB0aGlzLl90b3RhbEl0ZW1zID0gX251bTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByaW1hcnkgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIGdldCBkaXJlY3Rpb24oKTogU2Nyb2xsRGlyZWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uITtcbiAgfVxuICBzZXQgZGlyZWN0aW9uKGRpcikge1xuICAgIC8vIEZvcmNlIGl0IHRvIGJlIGVpdGhlciBob3Jpem9udGFsIG9yIHZlcnRpY2FsLlxuICAgIGRpciA9IChkaXIgPT09ICdob3Jpem9udGFsJykgPyBkaXIgOiAndmVydGljYWwnO1xuICAgIGlmIChkaXIgIT09IHRoaXMuX2RpcmVjdGlvbikge1xuICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyO1xuICAgICAgdGhpcy5fc2l6ZURpbSA9IChkaXIgPT09ICdob3Jpem9udGFsJykgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICB0aGlzLl9zZWNvbmRhcnlTaXplRGltID0gKGRpciA9PT0gJ2hvcml6b250YWwnKSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHRoaXMuX3Bvc2l0aW9uRGltID0gKGRpciA9PT0gJ2hvcml6b250YWwnKSA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW0gPSAoZGlyID09PSAnaG9yaXpvbnRhbCcpID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICB0aGlzLl90cmlnZ2VyUmVmbG93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlaWdodCBhbmQgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgZ2V0IHZpZXdwb3J0U2l6ZSgpOiBTaXplIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTaXplO1xuICB9XG4gIHNldCB2aWV3cG9ydFNpemUoZGltcykge1xuICAgIGNvbnN0IHtfdmlld0RpbTEsIF92aWV3RGltMn0gPSB0aGlzO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdmlld3BvcnRTaXplLCBkaW1zKTtcbiAgICBpZiAoX3ZpZXdEaW0yICE9PSB0aGlzLl92aWV3RGltMikge1xuICAgICAgLy8gdGhpcy5fdmlld0RpbTJDaGFuZ2VkKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZUxheW91dFVwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoX3ZpZXdEaW0xICE9PSB0aGlzLl92aWV3RGltMSkge1xuICAgICAgdGhpcy5fY2hlY2tUaHJlc2hvbGRzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbCBvZmZzZXQgb2YgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgZ2V0IHZpZXdwb3J0U2Nyb2xsKCk6IFBvc2l0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMuX2xhdGVzdENvb3JkcztcbiAgfVxuICBzZXQgdmlld3BvcnRTY3JvbGwoY29vcmRzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9sYXRlc3RDb29yZHMsIGNvb3Jkcyk7XG4gICAgY29uc3Qgb2xkUG9zID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9sYXRlc3RDb29yZHNbdGhpcy5fcG9zaXRpb25EaW1dO1xuICAgIGlmIChvbGRQb3MgIT09IHRoaXMuX3Njcm9sbFBvc2l0aW9uKSB7XG4gICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbkNoYW5nZWQob2xkUG9zLCB0aGlzLl9zY3JvbGxQb3NpdGlvbik7XG4gICAgICB0aGlzLl91cGRhdGVWaXNpYmxlSW5kaWNlcyh7ZW1pdDogdHJ1ZX0pO1xuICAgIH1cbiAgICB0aGlzLl9jaGVja1RocmVzaG9sZHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcmVmbG93IGlmIG9uZSBoYXMgYmVlbiBzY2hlZHVsZWQuXG4gICAqL1xuICByZWZsb3dJZk5lZWRlZChmb3JjZTogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgaWYgKGZvcmNlIHx8IHRoaXMuX3BlbmRpbmdSZWZsb3cpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZWZsb3cgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gdGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aXRoaW4gdGhhdFxuICAgKiBjaGlsZC5cbiAgICovXG4gIHNjcm9sbFRvSW5kZXgoaW5kZXg6IG51bWJlciwgcG9zaXRpb24gPSAnc3RhcnQnKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5kZXgpKVxuICAgICAgcmV0dXJuO1xuICAgIGluZGV4ID0gTWF0aC5taW4odGhpcy50b3RhbEl0ZW1zLCBNYXRoLm1heCgwLCBpbmRleCkpO1xuICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSBpbmRleDtcbiAgICBpZiAocG9zaXRpb24gPT09ICduZWFyZXN0Jykge1xuICAgICAgcG9zaXRpb24gPSBpbmRleCA+IHRoaXMuX2ZpcnN0ICsgdGhpcy5fbnVtIC8gMiA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICB9XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICB0aGlzLl9zY3JvbGxUb0FuY2hvciA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9BbmNob3IgPSAwLjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9BbmNob3IgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAncG9zaXRpb24gbXVzdCBiZSBvbmUgb2Y6IHN0YXJ0LCBjZW50ZXIsIGVuZCwgbmVhcmVzdCcpO1xuICAgIH1cbiAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICB9XG5cbiAgYXN5bmMgZGlzcGF0Y2hFdmVudChldnQ6IEV2ZW50KSB7XG4gICAgYXdhaXQgdGhpcy5fZXZlbnRUYXJnZXRQcm9taXNlO1xuICAgIHRoaXMuX2V2ZW50VGFyZ2V0IS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH1cblxuICBhc3luYyBhZGRFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXIgfCBFdmVudExpc3RlbmVyT2JqZWN0IHwgbnVsbCwgb3B0aW9ucz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyB8IHVuZGVmaW5lZCkge1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICB0aGlzLl9ldmVudFRhcmdldCEuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyByZW1vdmVFdmVudExpc3RlbmVyKHR5cGU6IHN0cmluZywgY2FsbGJhY2s6IEV2ZW50TGlzdGVuZXIgfCBFdmVudExpc3RlbmVyT2JqZWN0IHwgbnVsbCwgb3B0aW9ucz86IGJvb2xlYW4gfCBFdmVudExpc3RlbmVyT3B0aW9ucyB8IHVuZGVmaW5lZCkge1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICB0aGlzLl9ldmVudFRhcmdldCEucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb25pbmcgb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXRJdGVtUG9zaXRpb24oaWR4OiBudW1iZXIpOiBQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBfZmlyc3QgYW5kIF9sYXN0IGJhc2VkIG9uIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50XG4gICAqIHJhbmdlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXRBY3RpdmVJdGVtcygpOiB2b2lkXG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXRJdGVtU2l6ZShfaWR4OiBudW1iZXIpOiBTaXplXG5cbiAgICAvKipcbiAgICogQ2FsY3VsYXRlcyAocHJlY2lzZWx5IG9yIGJ5IGVzdGltYXRpbmcsIGlmIG5lZWRlZCkgdGhlIHRvdGFsIGxlbmd0aCBvZiBhbGwgaXRlbXMgaW5cbiAgICogdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24sIGluY2x1ZGluZyBzcGFjaW5nLCBjYWNoaW5nIHRoZSB2YWx1ZSBpbiB0aGUgYF9zY3JvbGxTaXplYCBmaWVsZC5cbiAgICogXG4gICAqIFNob3VsZCByZXR1cm4gYSBtaW5pbXVtIHZhbHVlIG9mIDEgdG8gZW5zdXJlIGF0IGxlYXN0IG9uZSBpdGVtIGlzIHJlbmRlcmVkLlxuICAgKiBUT0RPIChncmF5bm9ydG9uKTogUG9zc2libHkgbm8gbG9uZ2VyIHJlcXVpcmVkLCBidXQgbGVhdmluZyBoZXJlIHVudGlsIGl0IGNhbiBiZSB2ZXJpZmllZC5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfdXBkYXRlU2Nyb2xsU2l6ZSgpOiB2b2lkXG5cbiAgcHJvdGVjdGVkIF91cGRhdGVMYXlvdXQoKTogdm9pZCB7XG4gICAgLy8gT3ZlcnJpZGVcbiAgfVxuXG4gIC8vIHByb3RlY3RlZCBfdmlld0RpbTJDaGFuZ2VkKCk6IHZvaWQge1xuICAvLyAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0VXBkYXRlKCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvciB3aWR0aCBvZiB0aGUgdmlld3BvcnQsIHdoaWNoZXZlciBjb3JyZXNwb25kcyB0byB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBnZXQgX3ZpZXdEaW0xKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZVt0aGlzLl9zaXplRGltXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCwgd2hpY2hldmVyIGRvZXMgTk9UIGNvcnJlc3BvbmQgdG8gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IF92aWV3RGltMigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNpemVbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV07XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NjaGVkdWxlUmVmbG93KCkge1xuICAgIHRoaXMuX3BlbmRpbmdSZWZsb3cgPSB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zY2hlZHVsZUxheW91dFVwZGF0ZSgpIHtcbiAgICB0aGlzLl9wZW5kaW5nTGF5b3V0VXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICB9XG5cbiAgLy8gRm9yIHRyaWdnZXJpbmcgYSByZWZsb3cgYmFzZWQgb24gaW5jb21pbmcgY2hhbmdlcyB0b1xuICAvLyB0aGUgbGF5b3V0IGNvbmZpZy5cbiAgcHJvdGVjdGVkIF90cmlnZ2VyUmVmbG93KCkge1xuICAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0VXBkYXRlKCk7XG4gICAgLy8gVE9ETyBncmF5bm9ydG9uQDogcmVmbG93SWZOZWVkZWQoKSBpc24ndCByZWFsbHkgc3VwcG9zZWRcbiAgICAvLyB0byBiZSBjYWxsZWQgaW50ZXJuYWxseS4gQWRkcmVzcyBpbiBsYXJnZXIgY2xlYW51cFxuICAgIC8vIG9mIHZpcnR1YWxpemVyIC8gbGF5b3V0IGludGVyYWN0aW9uIHBhdHRlcm4uXG4gICAgLy8gdGhpcy5yZWZsb3dJZk5lZWRlZCh0cnVlKTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMucmVmbG93SWZOZWVkZWQoKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3JlZmxvdygpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0xheW91dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlTGF5b3V0KCk7XG4gICAgICB0aGlzLl9wZW5kaW5nTGF5b3V0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFNpemUoKTtcbiAgICB0aGlzLl9nZXRBY3RpdmVJdGVtcygpO1xuICAgIHRoaXMuX3Njcm9sbElmTmVlZGVkKCk7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcbiAgICB0aGlzLl9lbWl0U2Nyb2xsU2l6ZSgpO1xuICAgIHRoaXMuX2VtaXRSYW5nZSgpO1xuICAgIHRoaXMuX2VtaXRDaGlsZFBvc2l0aW9ucygpO1xuICAgIHRoaXMuX2VtaXRTY3JvbGxFcnJvcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zY3JvbGxJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5fc2Nyb2xsVG9JbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9zY3JvbGxUb0luZGV4O1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX3Njcm9sbFRvQW5jaG9yO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpbmRleClbdGhpcy5fcG9zaXRpb25EaW1dO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRJdGVtU2l6ZShpbmRleClbdGhpcy5fc2l6ZURpbV07XG5cbiAgICBjb25zdCBjdXJBbmNob3JQb3MgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xICogYW5jaG9yO1xuICAgIGNvbnN0IG5ld0FuY2hvclBvcyA9IHBvcyArIHNpemUgKiBhbmNob3I7XG4gICAgLy8gRW5zdXJlIHNjcm9sbCBwb3NpdGlvbiBpcyBhbiBpbnRlZ2VyIHdpdGhpbiBzY3JvbGwgYm91bmRzLlxuICAgIGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1pbihcbiAgICAgICAgdGhpcy5fc2Nyb2xsU2l6ZSAtIHRoaXMuX3ZpZXdEaW0xLFxuICAgICAgICBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIGN1ckFuY2hvclBvcyArIG5ld0FuY2hvclBvcykpKTtcbiAgICB0aGlzLl9zY3JvbGxFcnJvciArPSB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gc2Nyb2xsUG9zaXRpb247XG4gIH1cblxuICBwcm90ZWN0ZWQgX2VtaXRSYW5nZShpblByb3BzOiB1bmtub3duID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZGV0YWlsID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIGZpcnN0OiB0aGlzLl9maXJzdCxcbiAgICAgICAgICBsYXN0OiB0aGlzLl9sYXN0LFxuICAgICAgICAgIG51bTogdGhpcy5fbnVtLFxuICAgICAgICAgIHN0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBmaXJzdFZpc2libGU6IHRoaXMuX2ZpcnN0VmlzaWJsZSxcbiAgICAgICAgICBsYXN0VmlzaWJsZTogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgICAgIH0sXG4gICAgICAgIGluUHJvcHMpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JhbmdlY2hhbmdlJywge2RldGFpbH0pKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfZW1pdFNjcm9sbFNpemUoKSB7XG4gICAgY29uc3QgZGV0YWlsID0ge1xuICAgICAgW3RoaXMuX3NpemVEaW1dOiB0aGlzLl9zY3JvbGxTaXplLFxuICAgIH07XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc2Nyb2xsc2l6ZWNoYW5nZScsIHtkZXRhaWx9KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2VtaXRTY3JvbGxFcnJvcigpIHtcbiAgICBpZiAodGhpcy5fc2Nyb2xsRXJyb3IpIHtcbiAgICAgIGNvbnN0IGRldGFpbCA9IHtcbiAgICAgICAgW3RoaXMuX3Bvc2l0aW9uRGltXTogdGhpcy5fc2Nyb2xsRXJyb3IsXG4gICAgICAgIFt0aGlzLl9zZWNvbmRhcnlQb3NpdGlvbkRpbV06IDAsXG4gICAgICB9O1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc2Nyb2xsZXJyb3JjaGFuZ2UnLCB7ZGV0YWlsfSkpO1xuICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3IgZXN0aW1hdGUgdGhlIHRvcCBhbmQgbGVmdCBwb3NpdGlvbnMgb2YgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcmFuZ2UuXG4gICAqIEVtaXQgYW4gaXRlbXBvc2l0aW9uY2hhbmdlIGV2ZW50IHdpdGggdGhlc2UgcG9zaXRpb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9lbWl0Q2hpbGRQb3NpdGlvbnMoKSB7XG4gICAgY29uc3QgZGV0YWlsOiB7W2tleTogbnVtYmVyXTogUG9zaXRpb25zfSA9IHt9O1xuICAgIGZvciAobGV0IGlkeCA9IHRoaXMuX2ZpcnN0OyBpZHggPD0gdGhpcy5fbGFzdDsgaWR4KyspIHtcbiAgICAgIGRldGFpbFtpZHhdID0gdGhpcy5fZ2V0SXRlbVBvc2l0aW9uKGlkeCk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2l0ZW1wb3NpdGlvbmNoYW5nZScsIHtkZXRhaWx9KSk7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIHRvIGRpc3BsYXkuXG4gICAqL1xuICBwcml2YXRlIGdldCBfbnVtKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ID09PSAtMSB8fCB0aGlzLl9sYXN0ID09PSAtMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sYXN0IC0gdGhpcy5fZmlyc3QgKyAxO1xuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tUaHJlc2hvbGRzKCkge1xuICAgIGlmICh0aGlzLl92aWV3RGltMSA9PT0gMCAmJiB0aGlzLl9udW0gPiAwKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIHRoaXMuX292ZXJoYW5nKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKFxuICAgICAgICAgIHRoaXMuX3Njcm9sbFNpemUsXG4gICAgICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSArIHRoaXMuX292ZXJoYW5nKTtcbiAgICAgIGlmICh0aGlzLl9waHlzaWNhbE1pbiA+IG1pbiB8fCB0aGlzLl9waHlzaWNhbE1heCA8IG1heCkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBmaXJzdCBhbmQgbGFzdCBpdGVtcyB0byBpbnRlcnNlY3QgdGhlIHZpZXdwb3J0LlxuICAgKiBFbWl0IGEgdmlzaWJsZWluZGljZXNjaGFuZ2UgZXZlbnQgd2hlbiBlaXRoZXIgaW5kZXggY2hhbmdlcy5cbiAgICovXG4gICBwcm90ZWN0ZWQgX3VwZGF0ZVZpc2libGVJbmRpY2VzKG9wdGlvbnM/OiBVcGRhdGVWaXNpYmxlSW5kaWNlc09wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fZmlyc3QgPT09IC0xIHx8IHRoaXMuX2xhc3QgPT09IC0xKSByZXR1cm47XG5cbiAgICBsZXQgZmlyc3RWaXNpYmxlID0gdGhpcy5fZmlyc3Q7XG4gICAgd2hpbGUgKFxuICAgICAgZmlyc3RWaXNpYmxlIDwgdGhpcy5fbGFzdCAmJlxuICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgdGhpcy5fZ2V0SXRlbVBvc2l0aW9uKGZpcnN0VmlzaWJsZSlbdGhpcy5fcG9zaXRpb25EaW1dICtcbiAgICAgICAgdGhpcy5fZ2V0SXRlbVNpemUoZmlyc3RWaXNpYmxlKVt0aGlzLl9zaXplRGltXVxuICAgICAgKVxuICAgICAgPD1cbiAgICAgIE1hdGgucm91bmQgKHRoaXMuX3Njcm9sbFBvc2l0aW9uKVxuICAgICApIHtcbiAgICAgIGZpcnN0VmlzaWJsZSsrO1xuICAgIH1cblxuICAgIGxldCBsYXN0VmlzaWJsZSA9IHRoaXMuX2xhc3Q7XG4gICAgd2hpbGUgKFxuICAgICAgbGFzdFZpc2libGUgPiB0aGlzLl9maXJzdCAmJlxuICAgICAgTWF0aC5yb3VuZCh0aGlzLl9nZXRJdGVtUG9zaXRpb24obGFzdFZpc2libGUpW3RoaXMuX3Bvc2l0aW9uRGltXSlcbiAgICAgID49XG4gICAgICBNYXRoLnJvdW5kKHRoaXMuX3Njcm9sbFBvc2l0aW9uICsgdGhpcy5fdmlld0RpbTEpXG4gICAgKSB7XG4gICAgICBsYXN0VmlzaWJsZS0tO1xuICAgIH1cblxuICAgIGlmIChmaXJzdFZpc2libGUgIT09IHRoaXMuX2ZpcnN0VmlzaWJsZSB8fCBsYXN0VmlzaWJsZSAhPT0gdGhpcy5fbGFzdFZpc2libGUpIHtcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSA9IGZpcnN0VmlzaWJsZTtcbiAgICAgIHRoaXMuX2xhc3RWaXNpYmxlID0gbGFzdFZpc2libGU7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVtaXQpIHtcbiAgICAgICAgdGhpcy5fZW1pdFJhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfc2Nyb2xsUG9zaXRpb25DaGFuZ2VkKG9sZFBvczogbnVtYmVyLCBuZXdQb3M6IG51bWJlcikge1xuICAgIC8vIFdoZW4gYm90aCB2YWx1ZXMgYXJlIGJpZ2dlciB0aGFuIHRoZSBtYXggc2Nyb2xsIHBvc2l0aW9uLCBrZWVwIHRoZVxuICAgIC8vIGN1cnJlbnQgX3Njcm9sbFRvSW5kZXgsIG90aGVyd2lzZSBpbnZhbGlkYXRlIGl0LlxuICAgIGNvbnN0IG1heFBvcyA9IHRoaXMuX3Njcm9sbFNpemUgLSB0aGlzLl92aWV3RGltMTtcbiAgICBpZiAob2xkUG9zIDwgbWF4UG9zIHx8IG5ld1BvcyA8IG1heFBvcykge1xuICAgICAgdGhpcy5fc2Nyb2xsVG9JbmRleCA9IC0xO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventTarget)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\n\nlet ET;\nasync function EventTarget() {\n  return ET || init();\n}\n\nasync function init() {\n  _ET = window.EventTarget;\n\n  try {\n    new _ET();\n  } catch (_a) {\n    _ET = (await __webpack_require__.e(/*! import() */ \"vendors-node_modules_event-target-shim_dist_event-target-shim_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! event-target-shim */ \"./node_modules/event-target-shim/dist/event-target-shim.js\", 19))).default.EventTarget;\n  }\n\n  return ET = _ET;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3BvbHlmaWxsTG9hZGVycy9FdmVudFRhcmdldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0FBWUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9wb2x5ZmlsbExvYWRlcnMvRXZlbnRUYXJnZXQudHM/YzFjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxudHlwZSBFdmVudFRhcmdldE1vZHVsZSA9IHR5cGVvZiBpbXBvcnQoJ2V2ZW50LXRhcmdldC1zaGltJyk7XG5cbmludGVyZmFjZSBFdmVudFRhcmdldENvbnN0cnVjdG9yIHtcbiAgICBuZXcoKTogRXZlbnRUYXJnZXRcbn1cblxubGV0IF9FVDogRXZlbnRUYXJnZXRNb2R1bGUgfCBFdmVudFRhcmdldENvbnN0cnVjdG9yO1xubGV0IEVUOiBFdmVudFRhcmdldENvbnN0cnVjdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICByZXR1cm4gRVQgfHwgaW5pdCgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0KCkge1xuICAgIF9FVCA9IHdpbmRvdy5FdmVudFRhcmdldDtcbiAgICB0cnkge1xuICAgICAgICBuZXcgX0VUKCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgX0VUID0gKGF3YWl0IGltcG9ydCgnZXZlbnQtdGFyZ2V0LXNoaW0nKSkuRXZlbnRUYXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiAoRVQgPSBfRVQpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\n");

/***/ })

}]);