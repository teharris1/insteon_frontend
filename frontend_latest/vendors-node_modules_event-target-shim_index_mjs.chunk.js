"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkinsteon_panel_frontend"] = self["webpackChunkinsteon_panel_frontend"] || []).push([["vendors-node_modules_event-target-shim_index_mjs"],{

/***/ "./node_modules/event-target-shim/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/event-target-shim/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Event\": () => (/* binding */ Event),\n/* harmony export */   \"EventTarget\": () => (/* binding */ EventTarget),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"defineCustomEventTarget\": () => (/* binding */ defineCustomEventTarget),\n/* harmony export */   \"defineEventAttribute\": () => (/* binding */ defineEventAttribute),\n/* harmony export */   \"getEventAttributeValue\": () => (/* binding */ getEventAttributeValue),\n/* harmony export */   \"setErrorHandler\": () => (/* binding */ setErrorHandler),\n/* harmony export */   \"setEventAttributeValue\": () => (/* binding */ setEventAttributeValue),\n/* harmony export */   \"setWarningHandler\": () => (/* binding */ setWarningHandler)\n/* harmony export */ });\n/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nfunction assertType(condition, message, ...args) {\n  if (!condition) {\n    throw new TypeError(format(message, args));\n  }\n}\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nfunction format(message, args) {\n  let i = 0;\n  return message.replace(/%[os]/gu, () => anyToString(args[i++]));\n}\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nfunction anyToString(x) {\n  if (typeof x !== \"object\" || x === null) {\n    return String(x);\n  }\n  return Object.prototype.toString.call(x);\n}\nlet currentErrorHandler;\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nfunction setErrorHandler(value) {\n  assertType(typeof value === \"function\" || value === undefined, \"The error handler must be a function or undefined, but got %o.\", value);\n  currentErrorHandler = value;\n}\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nfunction reportError(maybeError) {\n  try {\n    const error = maybeError instanceof Error ? maybeError : new Error(anyToString(maybeError));\n    // Call the user-defined error handler if exists.\n    if (currentErrorHandler) {\n      currentErrorHandler(error);\n      return;\n    }\n    // Dispatch an `error` event if this is on a browser.\n    if (typeof dispatchEvent === \"function\" && typeof ErrorEvent === \"function\") {\n      dispatchEvent(new ErrorEvent(\"error\", {\n        error,\n        message: error.message\n      }));\n    }\n    // Emit an `uncaughtException` event if this is on Node.js.\n    //istanbul ignore else\n    else if (typeof process !== \"undefined\" && typeof process.emit === \"function\") {\n      process.emit(\"uncaughtException\", error);\n      return;\n    }\n    // Otherwise, print the error.\n    console.error(error);\n  } catch (_a) {\n    // ignore.\n  }\n}\n\n/**\n * The global object.\n */\n//istanbul ignore next\nconst Global = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof globalThis !== \"undefined\" ? globalThis : undefined;\nlet currentWarnHandler;\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nfunction setWarningHandler(value) {\n  assertType(typeof value === \"function\" || value === undefined, \"The warning handler must be a function or undefined, but got %o.\", value);\n  currentWarnHandler = value;\n}\n/**\n * The warning information.\n */\nclass Warning {\n  constructor(code, message) {\n    this.code = code;\n    this.message = message;\n  }\n  /**\n   * Report this warning.\n   * @param args The arguments of the warning.\n   */\n  warn(...args) {\n    var _a;\n    try {\n      // Call the user-defined warning handler if exists.\n      if (currentWarnHandler) {\n        currentWarnHandler({\n          ...this,\n          args\n        });\n        return;\n      }\n      // Otherwise, print the warning.\n      const stack = ((_a = new Error().stack) !== null && _a !== void 0 ? _a : \"\").replace(/^(?:.+?\\n){2}/gu, \"\\n\");\n      console.warn(this.message, ...args, stack);\n    } catch (_b) {\n      // Ignore.\n    }\n  }\n}\nconst InitEventWasCalledWhileDispatching = new Warning(\"W01\", \"Unable to initialize event under dispatching.\");\nconst FalsyWasAssignedToCancelBubble = new Warning(\"W02\", \"Assigning any falsy value to 'cancelBubble' property has no effect.\");\nconst TruthyWasAssignedToReturnValue = new Warning(\"W03\", \"Assigning any truthy value to 'returnValue' property has no effect.\");\nconst NonCancelableEventWasCanceled = new Warning(\"W04\", \"Unable to preventDefault on non-cancelable events.\");\nconst CanceledInPassiveListener = new Warning(\"W05\", \"Unable to preventDefault inside passive event listener invocation.\");\nconst EventListenerWasDuplicated = new Warning(\"W06\", \"An event listener wasn't added because it has been added already: %o, %o\");\nconst OptionWasIgnored = new Warning(\"W07\", \"The %o option value was abandoned because the event listener wasn't added as duplicated.\");\nconst InvalidEventListener = new Warning(\"W08\", \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\");\nconst InvalidAttributeHandler = new Warning(\"W09\", \"Event attribute handler must be a function: %o\");\n\n/*eslint-disable class-methods-use-this */\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nclass Event {\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-none\n   */\n  static get NONE() {\n    return NONE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n   */\n  static get CAPTURING_PHASE() {\n    return CAPTURING_PHASE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-at_target\n   */\n  static get AT_TARGET() {\n    return AT_TARGET;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n   */\n  static get BUBBLING_PHASE() {\n    return BUBBLING_PHASE;\n  }\n  /**\n   * Initialize this event instance.\n   * @param type The type of this event.\n   * @param eventInitDict Options to initialize.\n   * @see https://dom.spec.whatwg.org/#dom-event-event\n   */\n  constructor(type, eventInitDict) {\n    Object.defineProperty(this, \"isTrusted\", {\n      value: false,\n      enumerable: true\n    });\n    const opts = eventInitDict !== null && eventInitDict !== void 0 ? eventInitDict : {};\n    internalDataMap.set(this, {\n      type: String(type),\n      bubbles: Boolean(opts.bubbles),\n      cancelable: Boolean(opts.cancelable),\n      composed: Boolean(opts.composed),\n      target: null,\n      currentTarget: null,\n      stopPropagationFlag: false,\n      stopImmediatePropagationFlag: false,\n      canceledFlag: false,\n      inPassiveListenerFlag: false,\n      dispatchFlag: false,\n      timeStamp: Date.now()\n    });\n  }\n  /**\n   * The type of this event.\n   * @see https://dom.spec.whatwg.org/#dom-event-type\n   */\n  get type() {\n    return $(this).type;\n  }\n  /**\n   * The event target of the current dispatching.\n   * @see https://dom.spec.whatwg.org/#dom-event-target\n   */\n  get target() {\n    return $(this).target;\n  }\n  /**\n   * The event target of the current dispatching.\n   * @deprecated Use the `target` property instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n   */\n  get srcElement() {\n    return $(this).target;\n  }\n  /**\n   * The event target of the current dispatching.\n   * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n   */\n  get currentTarget() {\n    return $(this).currentTarget;\n  }\n  /**\n   * The event target of the current dispatching.\n   * This doesn't support node tree.\n   * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n   */\n  composedPath() {\n    const currentTarget = $(this).currentTarget;\n    if (currentTarget) {\n      return [currentTarget];\n    }\n    return [];\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-none\n   */\n  get NONE() {\n    return NONE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n   */\n  get CAPTURING_PHASE() {\n    return CAPTURING_PHASE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-at_target\n   */\n  get AT_TARGET() {\n    return AT_TARGET;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n   */\n  get BUBBLING_PHASE() {\n    return BUBBLING_PHASE;\n  }\n  /**\n   * The current event phase.\n   * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n   */\n  get eventPhase() {\n    return $(this).dispatchFlag ? 2 : 0;\n  }\n  /**\n   * Stop event bubbling.\n   * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n   * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n   */\n  stopPropagation() {\n    $(this).stopPropagationFlag = true;\n  }\n  /**\n   * `true` if event bubbling was stopped.\n   * @deprecated\n   * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n   */\n  get cancelBubble() {\n    return $(this).stopPropagationFlag;\n  }\n  /**\n   * Stop event bubbling if `true` is set.\n   * @deprecated Use the `stopPropagation()` method instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n   */\n  set cancelBubble(value) {\n    if (value) {\n      $(this).stopPropagationFlag = true;\n    } else {\n      FalsyWasAssignedToCancelBubble.warn();\n    }\n  }\n  /**\n   * Stop event bubbling and subsequent event listener callings.\n   * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n   */\n  stopImmediatePropagation() {\n    const data = $(this);\n    data.stopPropagationFlag = data.stopImmediatePropagationFlag = true;\n  }\n  /**\n   * `true` if this event will bubble.\n   * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n   */\n  get bubbles() {\n    return $(this).bubbles;\n  }\n  /**\n   * `true` if this event can be canceled by the `preventDefault()` method.\n   * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n   */\n  get cancelable() {\n    return $(this).cancelable;\n  }\n  /**\n   * `true` if the default behavior will act.\n   * @deprecated Use the `defaultPrevented` proeprty instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n   */\n  get returnValue() {\n    return !$(this).canceledFlag;\n  }\n  /**\n   * Cancel the default behavior if `false` is set.\n   * @deprecated Use the `preventDefault()` method instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n   */\n  set returnValue(value) {\n    if (!value) {\n      setCancelFlag($(this));\n    } else {\n      TruthyWasAssignedToReturnValue.warn();\n    }\n  }\n  /**\n   * Cancel the default behavior.\n   * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n   */\n  preventDefault() {\n    setCancelFlag($(this));\n  }\n  /**\n   * `true` if the default behavior was canceled.\n   * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n   */\n  get defaultPrevented() {\n    return $(this).canceledFlag;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-composed\n   */\n  get composed() {\n    return $(this).composed;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n   */\n  //istanbul ignore next\n  get isTrusted() {\n    return false;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n   */\n  get timeStamp() {\n    return $(this).timeStamp;\n  }\n  /**\n   * @deprecated Don't use this method. The constructor did initialization.\n   */\n  initEvent(type, bubbles = false, cancelable = false) {\n    const data = $(this);\n    if (data.dispatchFlag) {\n      InitEventWasCalledWhileDispatching.warn();\n      return;\n    }\n    internalDataMap.set(this, {\n      ...data,\n      type: String(type),\n      bubbles: Boolean(bubbles),\n      cancelable: Boolean(cancelable),\n      target: null,\n      currentTarget: null,\n      stopPropagationFlag: false,\n      stopImmediatePropagationFlag: false,\n      canceledFlag: false\n    });\n  }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst NONE = 0;\nconst CAPTURING_PHASE = 1;\nconst AT_TARGET = 2;\nconst BUBBLING_PHASE = 3;\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event, name = \"this\") {\n  const retv = internalDataMap.get(event);\n  assertType(retv != null, \"'%s' must be an object that Event constructor created, but got another one: %o\", name, event);\n  return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data) {\n  if (data.inPassiveListenerFlag) {\n    CanceledInPassiveListener.warn();\n    return;\n  }\n  if (!data.cancelable) {\n    NonCancelableEventWasCanceled.warn();\n    return;\n  }\n  data.canceledFlag = true;\n}\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"CAPTURING_PHASE\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"AT_TARGET\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"BUBBLING_PHASE\", {\n  enumerable: true\n});\nconst keys = Object.getOwnPropertyNames(Event.prototype);\nfor (let i = 0; i < keys.length; ++i) {\n  if (keys[i] === \"constructor\") {\n    continue;\n  }\n  Object.defineProperty(Event.prototype, keys[i], {\n    enumerable: true\n  });\n}\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, Global.Event.prototype);\n}\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nfunction createInvalidStateError(message) {\n  if (Global.DOMException) {\n    return new Global.DOMException(message, \"InvalidStateError\");\n  }\n  if (DOMException == null) {\n    DOMException = class DOMException extends Error {\n      constructor(msg) {\n        super(msg);\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(this, DOMException);\n        }\n      }\n      // eslint-disable-next-line class-methods-use-this\n      get code() {\n        return 11;\n      }\n      // eslint-disable-next-line class-methods-use-this\n      get name() {\n        return \"InvalidStateError\";\n      }\n    };\n    Object.defineProperties(DOMException.prototype, {\n      code: {\n        enumerable: true\n      },\n      name: {\n        enumerable: true\n      }\n    });\n    defineErrorCodeProperties(DOMException);\n    defineErrorCodeProperties(DOMException.prototype);\n  }\n  return new DOMException(message);\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nlet DOMException;\nconst ErrorCodeMap = {\n  INDEX_SIZE_ERR: 1,\n  DOMSTRING_SIZE_ERR: 2,\n  HIERARCHY_REQUEST_ERR: 3,\n  WRONG_DOCUMENT_ERR: 4,\n  INVALID_CHARACTER_ERR: 5,\n  NO_DATA_ALLOWED_ERR: 6,\n  NO_MODIFICATION_ALLOWED_ERR: 7,\n  NOT_FOUND_ERR: 8,\n  NOT_SUPPORTED_ERR: 9,\n  INUSE_ATTRIBUTE_ERR: 10,\n  INVALID_STATE_ERR: 11,\n  SYNTAX_ERR: 12,\n  INVALID_MODIFICATION_ERR: 13,\n  NAMESPACE_ERR: 14,\n  INVALID_ACCESS_ERR: 15,\n  VALIDATION_ERR: 16,\n  TYPE_MISMATCH_ERR: 17,\n  SECURITY_ERR: 18,\n  NETWORK_ERR: 19,\n  ABORT_ERR: 20,\n  URL_MISMATCH_ERR: 21,\n  QUOTA_EXCEEDED_ERR: 22,\n  TIMEOUT_ERR: 23,\n  INVALID_NODE_TYPE_ERR: 24,\n  DATA_CLONE_ERR: 25\n};\nfunction defineErrorCodeProperties(obj) {\n  const keys = Object.keys(ErrorCodeMap);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const value = ErrorCodeMap[key];\n    Object.defineProperty(obj, key, {\n      get() {\n        return value;\n      },\n      configurable: true,\n      enumerable: true\n    });\n  }\n}\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nclass EventWrapper extends Event {\n  /**\n   * Wrap a given event object to control states.\n   * @param event The event-like object to wrap.\n   */\n  static wrap(event) {\n    return new (getWrapperClassOf(event))(event);\n  }\n  constructor(event) {\n    super(event.type, {\n      bubbles: event.bubbles,\n      cancelable: event.cancelable,\n      composed: event.composed\n    });\n    if (event.cancelBubble) {\n      super.stopPropagation();\n    }\n    if (event.defaultPrevented) {\n      super.preventDefault();\n    }\n    internalDataMap$1.set(this, {\n      original: event\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (!(key in this)) {\n        Object.defineProperty(this, key, defineRedirectDescriptor(event, key));\n      }\n    }\n  }\n  stopPropagation() {\n    super.stopPropagation();\n    const {\n      original\n    } = $$1(this);\n    if (\"stopPropagation\" in original) {\n      original.stopPropagation();\n    }\n  }\n  get cancelBubble() {\n    return super.cancelBubble;\n  }\n  set cancelBubble(value) {\n    super.cancelBubble = value;\n    const {\n      original\n    } = $$1(this);\n    if (\"cancelBubble\" in original) {\n      original.cancelBubble = value;\n    }\n  }\n  stopImmediatePropagation() {\n    super.stopImmediatePropagation();\n    const {\n      original\n    } = $$1(this);\n    if (\"stopImmediatePropagation\" in original) {\n      original.stopImmediatePropagation();\n    }\n  }\n  get returnValue() {\n    return super.returnValue;\n  }\n  set returnValue(value) {\n    super.returnValue = value;\n    const {\n      original\n    } = $$1(this);\n    if (\"returnValue\" in original) {\n      original.returnValue = value;\n    }\n  }\n  preventDefault() {\n    super.preventDefault();\n    const {\n      original\n    } = $$1(this);\n    if (\"preventDefault\" in original) {\n      original.preventDefault();\n    }\n  }\n  get timeStamp() {\n    const {\n      original\n    } = $$1(this);\n    if (\"timeStamp\" in original) {\n      return original.timeStamp;\n    }\n    return super.timeStamp;\n  }\n}\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap$1 = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $$1(event) {\n  const retv = internalDataMap$1.get(event);\n  assertType(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap();\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper);\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n  wrapperClassCache.set(Global.Event.prototype, EventWrapper);\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf(originalEvent) {\n  const prototype = Object.getPrototypeOf(originalEvent);\n  if (prototype == null) {\n    return EventWrapper;\n  }\n  let wrapper = wrapperClassCache.get(prototype);\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapperClassOf(prototype), prototype);\n    wrapperClassCache.set(prototype, wrapper);\n  }\n  return wrapper;\n}\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper, originalPrototype) {\n  class CustomEventWrapper extends BaseEventWrapper {}\n  const keys = Object.keys(originalPrototype);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(CustomEventWrapper.prototype, keys[i], defineRedirectDescriptor(originalPrototype, keys[i]));\n  }\n  return CustomEventWrapper;\n}\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj, key) {\n  const d = Object.getOwnPropertyDescriptor(obj, key);\n  return {\n    get() {\n      const original = $$1(this).original;\n      const value = original[key];\n      if (typeof value === \"function\") {\n        return value.bind(original);\n      }\n      return value;\n    },\n    set(value) {\n      const original = $$1(this).original;\n      original[key] = value;\n    },\n    configurable: d.configurable,\n    enumerable: d.enumerable\n  };\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nfunction createListener(callback, capture, passive, once, signal, signalListener) {\n  return {\n    callback,\n    flags: (capture ? 1 /* Capture */ : 0) | (passive ? 2 /* Passive */ : 0) | (once ? 4 /* Once */ : 0),\n    signal,\n    signalListener\n  };\n}\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nfunction setRemoved(listener) {\n  listener.flags |= 8 /* Removed */;\n}\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nfunction isCapture(listener) {\n  return (listener.flags & 1 /* Capture */) === 1 /* Capture */;\n}\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nfunction isPassive(listener) {\n  return (listener.flags & 2 /* Passive */) === 2 /* Passive */;\n}\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nfunction isOnce(listener) {\n  return (listener.flags & 4 /* Once */) === 4 /* Once */;\n}\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nfunction isRemoved(listener) {\n  return (listener.flags & 8 /* Removed */) === 8 /* Removed */;\n}\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nfunction invokeCallback({\n  callback\n}, target, event) {\n  try {\n    if (typeof callback === \"function\") {\n      callback.call(target, event);\n    } else if (typeof callback.handleEvent === \"function\") {\n      callback.handleEvent(event);\n    }\n  } catch (thrownError) {\n    reportError(thrownError);\n  }\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nfunction findIndexOfListener({\n  listeners\n}, callback, capture) {\n  for (let i = 0; i < listeners.length; ++i) {\n    if (listeners[i].callback === callback && isCapture(listeners[i]) === capture) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nfunction addListener(list, callback, capture, passive, once, signal) {\n  let signalListener;\n  if (signal) {\n    signalListener = removeListener.bind(null, list, callback, capture);\n    signal.addEventListener(\"abort\", signalListener);\n  }\n  const listener = createListener(callback, capture, passive, once, signal, signalListener);\n  if (list.cow) {\n    list.cow = false;\n    list.listeners = [...list.listeners, listener];\n  } else {\n    list.listeners.push(listener);\n  }\n  return listener;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nfunction removeListener(list, callback, capture) {\n  const index = findIndexOfListener(list, callback, capture);\n  if (index !== -1) {\n    return removeListenerAt(list, index);\n  }\n  return false;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nfunction removeListenerAt(list, index, disableCow = false) {\n  const listener = list.listeners[index];\n  // Set the removed flag.\n  setRemoved(listener);\n  // Dispose the abort signal listener if exists.\n  if (listener.signal) {\n    listener.signal.removeEventListener(\"abort\", listener.signalListener);\n  }\n  // Remove it from the array.\n  if (list.cow && !disableCow) {\n    list.cow = false;\n    list.listeners = list.listeners.filter((_, i) => i !== index);\n    return false;\n  }\n  list.listeners.splice(index, 1);\n  return true;\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nfunction createListenerListMap() {\n  return Object.create(null);\n}\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nfunction ensureListenerList(listenerMap, type) {\n  var _a;\n  return (_a = listenerMap[type]) !== null && _a !== void 0 ? _a : listenerMap[type] = {\n    attrCallback: undefined,\n    attrListener: undefined,\n    cow: false,\n    listeners: []\n  };\n}\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nclass EventTarget {\n  /**\n   * Initialize this instance.\n   */\n  constructor() {\n    internalDataMap$2.set(this, createListenerListMap());\n  }\n  // Implementation\n  addEventListener(type0, callback0, options0) {\n    const listenerMap = $$2(this);\n    const {\n      callback,\n      capture,\n      once,\n      passive,\n      signal,\n      type\n    } = normalizeAddOptions(type0, callback0, options0);\n    if (callback == null || (signal === null || signal === void 0 ? void 0 : signal.aborted)) {\n      return;\n    }\n    const list = ensureListenerList(listenerMap, type);\n    // Find existing listener.\n    const i = findIndexOfListener(list, callback, capture);\n    if (i !== -1) {\n      warnDuplicate(list.listeners[i], passive, once, signal);\n      return;\n    }\n    // Add the new listener.\n    addListener(list, callback, capture, passive, once, signal);\n  }\n  // Implementation\n  removeEventListener(type0, callback0, options0) {\n    const listenerMap = $$2(this);\n    const {\n      callback,\n      capture,\n      type\n    } = normalizeOptions(type0, callback0, options0);\n    const list = listenerMap[type];\n    if (callback != null && list) {\n      removeListener(list, callback, capture);\n    }\n  }\n  // Implementation\n  dispatchEvent(e) {\n    const list = $$2(this)[String(e.type)];\n    if (list == null) {\n      return true;\n    }\n    const event = e instanceof Event ? e : EventWrapper.wrap(e);\n    const eventData = $(event, \"event\");\n    if (eventData.dispatchFlag) {\n      throw createInvalidStateError(\"This event has been in dispatching.\");\n    }\n    eventData.dispatchFlag = true;\n    eventData.target = eventData.currentTarget = this;\n    if (!eventData.stopPropagationFlag) {\n      const {\n        cow,\n        listeners\n      } = list;\n      // Set copy-on-write flag.\n      list.cow = true;\n      // Call listeners.\n      for (let i = 0; i < listeners.length; ++i) {\n        const listener = listeners[i];\n        // Skip if removed.\n        if (isRemoved(listener)) {\n          continue;\n        }\n        // Remove this listener if has the `once` flag.\n        if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n          // Because this listener was removed, the next index is the\n          // same as the current value.\n          i -= 1;\n        }\n        // Call this listener with the `passive` flag.\n        eventData.inPassiveListenerFlag = isPassive(listener);\n        invokeCallback(listener, this, event);\n        eventData.inPassiveListenerFlag = false;\n        // Stop if the `event.stopImmediatePropagation()` method was called.\n        if (eventData.stopImmediatePropagationFlag) {\n          break;\n        }\n      }\n      // Restore copy-on-write flag.\n      if (!cow) {\n        list.cow = false;\n      }\n    }\n    eventData.target = null;\n    eventData.currentTarget = null;\n    eventData.stopImmediatePropagationFlag = false;\n    eventData.stopPropagationFlag = false;\n    eventData.dispatchFlag = false;\n    return !eventData.canceledFlag;\n  }\n}\n/**\n * Internal data.\n */\nconst internalDataMap$2 = new WeakMap();\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $$2(target, name = \"this\") {\n  const retv = internalDataMap$2.get(target);\n  assertType(retv != null, \"'%s' must be an object that EventTarget constructor created, but got another one: %o\", name, target);\n  return retv;\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(type, callback, options) {\n  var _a;\n  assertCallback(callback);\n  if (typeof options === \"object\" && options !== null) {\n    return {\n      type: String(type),\n      callback: callback !== null && callback !== void 0 ? callback : undefined,\n      capture: Boolean(options.capture),\n      passive: Boolean(options.passive),\n      once: Boolean(options.once),\n      signal: (_a = options.signal) !== null && _a !== void 0 ? _a : undefined\n    };\n  }\n  return {\n    type: String(type),\n    callback: callback !== null && callback !== void 0 ? callback : undefined,\n    capture: Boolean(options),\n    passive: false,\n    once: false,\n    signal: undefined\n  };\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(type, callback, options) {\n  assertCallback(callback);\n  if (typeof options === \"object\" && options !== null) {\n    return {\n      type: String(type),\n      callback: callback !== null && callback !== void 0 ? callback : undefined,\n      capture: Boolean(options.capture)\n    };\n  }\n  return {\n    type: String(type),\n    callback: callback !== null && callback !== void 0 ? callback : undefined,\n    capture: Boolean(options)\n  };\n}\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback) {\n  if (typeof callback === \"function\" || typeof callback === \"object\" && callback !== null && typeof callback.handleEvent === \"function\") {\n    return;\n  }\n  if (callback == null || typeof callback === \"object\") {\n    InvalidEventListener.warn(callback);\n    return;\n  }\n  throw new TypeError(format(InvalidEventListener.message, [callback]));\n}\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(listener, passive, once, signal) {\n  EventListenerWasDuplicated.warn(isCapture(listener) ? \"capture\" : \"bubble\", listener.callback);\n  if (isPassive(listener) !== passive) {\n    OptionWasIgnored.warn(\"passive\");\n  }\n  if (isOnce(listener) !== once) {\n    OptionWasIgnored.warn(\"once\");\n  }\n  if (listener.signal !== signal) {\n    OptionWasIgnored.warn(\"signal\");\n  }\n}\n// Set enumerable\nconst keys$1 = Object.getOwnPropertyNames(EventTarget.prototype);\nfor (let i = 0; i < keys$1.length; ++i) {\n  if (keys$1[i] === \"constructor\") {\n    continue;\n  }\n  Object.defineProperty(EventTarget.prototype, keys$1[i], {\n    enumerable: true\n  });\n}\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype);\n}\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nfunction getEventAttributeValue(target, type) {\n  var _a, _b;\n  const listMap = $$2(target, \"target\");\n  return (_b = (_a = listMap[type]) === null || _a === void 0 ? void 0 : _a.attrCallback) !== null && _b !== void 0 ? _b : null;\n}\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction setEventAttributeValue(target, type, callback) {\n  if (callback != null && typeof callback !== \"function\") {\n    InvalidAttributeHandler.warn(callback);\n  }\n  if (typeof callback === \"function\" || typeof callback === \"object\" && callback !== null) {\n    upsertEventAttributeListener(target, type, callback);\n  } else {\n    removeEventAttributeListener(target, type);\n  }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener(target, type, callback) {\n  const list = ensureListenerList($$2(target, \"target\"), String(type));\n  list.attrCallback = callback;\n  if (list.attrListener == null) {\n    list.attrListener = addListener(list, defineEventAttributeCallback(list), false, false, false, undefined);\n  }\n}\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(target, type) {\n  const listMap = $$2(target, \"target\");\n  const list = listMap[String(type)];\n  if (list && list.attrListener) {\n    removeListener(list, list.attrListener.callback, false);\n    list.attrCallback = list.attrListener = undefined;\n  }\n}\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(list) {\n  return function (event) {\n    const callback = list.attrCallback;\n    if (typeof callback === \"function\") {\n      callback.call(this, event);\n    }\n  };\n}\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineCustomEventTarget(...types) {\n  class CustomEventTarget extends EventTarget {}\n  for (let i = 0; i < types.length; ++i) {\n    defineEventAttribute(CustomEventTarget.prototype, types[i]);\n  }\n  return CustomEventTarget;\n}\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineEventAttribute(target, type, _eventClass) {\n  Object.defineProperty(target, `on${type}`, {\n    get() {\n      return getEventAttributeValue(this, type);\n    },\n    set(value) {\n      setEventAttributeValue(this, type, value);\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventTarget);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnQtdGFyZ2V0LXNoaW0vaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFNQTtBQUtBO0FBQ0E7O0FBRUE7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUM1QkE7QUFFQTs7OztBQUlBO0FBR0E7QUFLQTtBQUNBO0FBU0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBOzs7QUFJQTtBQUlBO0FBQ0E7QUFBQTtBQUFBOzs7O0FBTUE7QUFJQTtBQUNBOzs7QUFJQTtBQUNBOzs7QUFHQTs7QUNwRUE7OztBQUdBO0FBQ0E7QUNMQTtBQUVBOzs7O0FBSUE7QUFHQTtBQUtBO0FBQ0E7QUEyQkE7OztBQUdBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7QUFPQTs7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUlBO0FBSUE7QUFDQTs7Ozs7QUN6RUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBT0E7QUFPQTtBQU9BOztBQ3RDQTtBQUVBOzs7OztBQUtBOzs7O0FBSUE7QUFDQTs7Ozs7QUFNQTtBQUNBOzs7OztBQU1BO0FBQ0E7Ozs7O0FBTUE7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBOzs7Ozs7QUFPQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTs7Ozs7O0FBT0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQU1BO0FBQ0E7Ozs7O0FBTUE7QUFDQTs7Ozs7QUFNQTtBQUNBOzs7OztBQU1BO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7Ozs7O0FBTUE7QUFDQTs7Ozs7O0FBT0E7QUFDQTs7Ozs7QUFNQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBb0JBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBeURBOzs7QUFHQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTs7O0FDOWFBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FDbEZBOzs7OztBQUtBOzs7OztBQUtBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBU0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBOzs7QUFnQkE7OztBQUdBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7Ozs7QUFJQTtBQUdBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFPQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBOzs7Ozs7Ozs7QUFTQTtBQVFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQ3BIQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFLQTs7QUFHQTs7QUFHQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FDbklBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDRkE7Ozs7QUFJQTs7OztBQU9BO0FBQ0E7OztBQXlEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBOzs7QUF5REE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUVBO0FBQ0E7Ozs7QUFtQkE7QUFLQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBR0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBOzs7QUFJQTs7O0FBR0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOzs7O0FBS0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFzSEE7OztBQUdBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTs7OztBQUlBOztBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFNQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUlBOzs7QUNuaUJBOzs7OztBQUtBOztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUtBO0FBQ0E7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFPQTtBQUlBO0FBRUE7QUFDQTs7QUFTQTtBQUVBOzs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDM0dBOzs7OztBQUtBO0FBTUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUE4QkE7Ozs7Ozs7QUFPQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9saWIvbWlzYy50cz85ODA4Iiwid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL2xpYi9lcnJvci1oYW5kbGVyLnRzP2E0Y2QiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvbGliL2dsb2JhbC50cz85NTFjIiwid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL2xpYi93YXJuaW5nLWhhbmRsZXIudHM/NWMyNSIsIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9saWIvd2FybmluZ3MudHM/ZjA5OCIsIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9saWIvZXZlbnQudHM/MmNjZCIsIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9saWIvZG9tLWV4Y2VwdGlvbi50cz85NmJlIiwid2VicGFjazovL2luc3Rlb24tcGFuZWwtZnJvbnRlbmQvLi4vc3JjL2xpYi9ldmVudC13cmFwcGVyLnRzPzM4Y2QiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvbGliL2xpc3RlbmVyLnRzPzc0ZTIiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvbGliL2xpc3RlbmVyLWxpc3QudHM/ZTZjMiIsIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9saWIvbGlzdGVuZXItbGlzdC1tYXAudHM/M2VmNSIsIndlYnBhY2s6Ly9pbnN0ZW9uLXBhbmVsLWZyb250ZW5kLy4uL3NyYy9saWIvZXZlbnQtdGFyZ2V0LnRzPzQ0NGIiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvbGliL2V2ZW50LWF0dHJpYnV0ZS1oYW5kbGVyLnRzP2RjZjkiLCJ3ZWJwYWNrOi8vaW5zdGVvbi1wYW5lbC1mcm9udGVuZC8uLi9zcmMvbGliL2xlZ2FjeS50cz83MjI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXNzZXJ0IGEgY29uZGl0aW9uLlxuICogQHBhcmFtIGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHRoYXQgaXQgc2hvdWxkIHNhdGlzZnkuXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgZm9yIHJlcGxhY2luZyBwbGFjZWhvbGRlcnMgaW4gdGhlIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlKFxuICAgIGNvbmRpdGlvbjogYm9vbGVhbixcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgLi4uYXJnczogYW55W11cbik6IGFzc2VydHMgY29uZGl0aW9uIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZvcm1hdChtZXNzYWdlLCBhcmdzKSlcbiAgICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIHRleHQgYW5kIGFyZ3VtZW50cyB0byBvbmUgc3RyaW5nLlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIGZvcm1hdGluZyB0ZXh0XG4gKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2U6IHN0cmluZywgYXJnczogYW55W10pOiBzdHJpbmcge1xuICAgIGxldCBpID0gMFxuICAgIHJldHVybiBtZXNzYWdlLnJlcGxhY2UoLyVbb3NdL2d1LCAoKSA9PiBhbnlUb1N0cmluZyhhcmdzW2krK10pKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBnZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFueVRvU3RyaW5nKHg6IGFueSk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSBcIm9iamVjdFwiIHx8IHggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh4KVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpXG59XG4iLCJpbXBvcnQgeyBhbnlUb1N0cmluZywgYXNzZXJ0VHlwZSB9IGZyb20gXCIuL21pc2NcIlxuXG5kZWNsYXJlIGNvbnN0IGNvbnNvbGU6IGFueVxuZGVjbGFyZSBjb25zdCBkaXNwYXRjaEV2ZW50OiBhbnlcbmRlY2xhcmUgY29uc3QgRXJyb3JFdmVudDogYW55XG5kZWNsYXJlIGNvbnN0IHByb2Nlc3M6IGFueVxuXG5sZXQgY3VycmVudEVycm9ySGFuZGxlcjogc2V0RXJyb3JIYW5kbGVyLkVycm9ySGFuZGxlciB8IHVuZGVmaW5lZFxuXG4vKipcbiAqIFNldCB0aGUgZXJyb3IgaGFuZGxlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgZXJyb3IgaGFuZGxlciB0byBzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFcnJvckhhbmRsZXIoXG4gICAgdmFsdWU6IHNldEVycm9ySGFuZGxlci5FcnJvckhhbmRsZXIgfCB1bmRlZmluZWQsXG4pOiB2b2lkIHtcbiAgICBhc3NlcnRUeXBlKFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICBcIlRoZSBlcnJvciBoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWQsIGJ1dCBnb3QgJW8uXCIsXG4gICAgICAgIHZhbHVlLFxuICAgIClcbiAgICBjdXJyZW50RXJyb3JIYW5kbGVyID0gdmFsdWVcbn1cbmV4cG9ydCBuYW1lc3BhY2Ugc2V0RXJyb3JIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZXJyb3IgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gZXJyb3IgVGhlIHRocm93biBlcnJvciBvYmplY3QuXG4gICAgICovXG4gICAgZXhwb3J0IHR5cGUgRXJyb3JIYW5kbGVyID0gKGVycm9yOiBFcnJvcikgPT4gdm9pZFxufVxuXG4vKipcbiAqIFByaW50IGEgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSBtYXliZUVycm9yIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRFcnJvcihtYXliZUVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPVxuICAgICAgICAgICAgbWF5YmVFcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgPyBtYXliZUVycm9yXG4gICAgICAgICAgICAgICAgOiBuZXcgRXJyb3IoYW55VG9TdHJpbmcobWF5YmVFcnJvcikpXG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgdXNlci1kZWZpbmVkIGVycm9yIGhhbmRsZXIgaWYgZXhpc3RzLlxuICAgICAgICBpZiAoY3VycmVudEVycm9ySGFuZGxlcikge1xuICAgICAgICAgICAgY3VycmVudEVycm9ySGFuZGxlcihlcnJvcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggYW4gYGVycm9yYCBldmVudCBpZiB0aGlzIGlzIG9uIGEgYnJvd3Nlci5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGRpc3BhdGNoRXZlbnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIEVycm9yRXZlbnQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yRXZlbnQoXCJlcnJvclwiLCB7IGVycm9yLCBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIH0pLFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW1pdCBhbiBgdW5jYXVnaHRFeGNlcHRpb25gIGV2ZW50IGlmIHRoaXMgaXMgb24gTm9kZS5qcy5cbiAgICAgICAgLy9pc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBwcmludCB0aGUgZXJyb3IuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGlnbm9yZS5cbiAgICB9XG59XG4iLCJkZWNsYXJlIGNvbnN0IGdsb2JhbFRoaXM6IGFueVxuZGVjbGFyZSBjb25zdCB3aW5kb3c6IGFueVxuZGVjbGFyZSBjb25zdCBzZWxmOiBhbnlcbmRlY2xhcmUgY29uc3QgZ2xvYmFsOiBhbnlcblxuLyoqXG4gKiBUaGUgZ2xvYmFsIG9iamVjdC5cbiAqL1xuLy9pc3RhbmJ1bCBpZ25vcmUgbmV4dFxuZXhwb3J0IGNvbnN0IEdsb2JhbDogYW55ID1cbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICA/IGdsb2JhbFxuICAgICAgICA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IHVuZGVmaW5lZFxuIiwiaW1wb3J0IHsgYXNzZXJ0VHlwZSB9IGZyb20gXCIuL21pc2NcIlxuXG5kZWNsYXJlIGNvbnN0IGNvbnNvbGU6IGFueVxuXG5sZXQgY3VycmVudFdhcm5IYW5kbGVyOiBzZXRXYXJuaW5nSGFuZGxlci5XYXJuaW5nSGFuZGxlciB8IHVuZGVmaW5lZFxuXG4vKipcbiAqIFNldCB0aGUgd2FybmluZyBoYW5kbGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSB3YXJuaW5nIGhhbmRsZXIgdG8gc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0V2FybmluZ0hhbmRsZXIoXG4gICAgdmFsdWU6IHNldFdhcm5pbmdIYW5kbGVyLldhcm5pbmdIYW5kbGVyIHwgdW5kZWZpbmVkLFxuKTogdm9pZCB7XG4gICAgYXNzZXJ0VHlwZShcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCxcbiAgICAgICAgXCJUaGUgd2FybmluZyBoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWQsIGJ1dCBnb3QgJW8uXCIsXG4gICAgICAgIHZhbHVlLFxuICAgIClcbiAgICBjdXJyZW50V2FybkhhbmRsZXIgPSB2YWx1ZVxufVxuZXhwb3J0IG5hbWVzcGFjZSBzZXRXYXJuaW5nSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogVGhlIHdhcm5pbmcgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZXhwb3J0IGludGVyZmFjZSBXYXJuaW5nIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2RlIG9mIHRoaXMgd2FybmluZy5cbiAgICAgICAgICovXG4gICAgICAgIGNvZGU6IHN0cmluZ1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1lc3NhZ2UgaW4gRW5nbGlzaC5cbiAgICAgICAgICovXG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZ1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFyZ3VtZW50cyBmb3IgcmVwbGFjaW5nIHBsYWNlaG9sZGVycyBpbiB0aGUgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIGFyZ3M6IGFueVtdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHdhcm5pbmcgaGFuZGxlci5cbiAgICAgKiBAcGFyYW0gd2FybmluZyBUaGUgd2FybmluZy5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBXYXJuaW5nSGFuZGxlciA9ICh3YXJuaW5nOiBXYXJuaW5nKSA9PiB2b2lkXG59XG5cbi8qKlxuICogVGhlIHdhcm5pbmcgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBXYXJuaW5nPFRBcmdzIGV4dGVuZHMgYW55W10+IHtcbiAgICByZWFkb25seSBjb2RlOiBzdHJpbmdcbiAgICByZWFkb25seSBtZXNzYWdlOiBzdHJpbmdcblxuICAgIGNvbnN0cnVjdG9yKGNvZGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcG9ydCB0aGlzIHdhcm5pbmcuXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyBvZiB0aGUgd2FybmluZy5cbiAgICAgKi9cbiAgICB3YXJuKC4uLmFyZ3M6IFRBcmdzKTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSB1c2VyLWRlZmluZWQgd2FybmluZyBoYW5kbGVyIGlmIGV4aXN0cy5cbiAgICAgICAgICAgIGlmIChjdXJyZW50V2FybkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2FybkhhbmRsZXIoeyAuLi50aGlzLCBhcmdzIH0pXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcHJpbnQgdGhlIHdhcm5pbmcuXG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IChuZXcgRXJyb3IoKS5zdGFjayA/PyBcIlwiKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC9eKD86Lis/XFxuKXsyfS9ndSxcbiAgICAgICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVzc2FnZSwgLi4uYXJncywgc3RhY2spXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudC10YXJnZXRcIiAvLyBVc2VkIGFzIG9ubHkgdHlwZSwgc28gbm8gY2lyY3VsYXIuXG5pbXBvcnQgeyBXYXJuaW5nIH0gZnJvbSBcIi4vd2FybmluZy1oYW5kbGVyXCJcblxuZXhwb3J0IGNvbnN0IEluaXRFdmVudFdhc0NhbGxlZFdoaWxlRGlzcGF0Y2hpbmcgPSBuZXcgV2FybmluZzxbXT4oXG4gICAgXCJXMDFcIixcbiAgICBcIlVuYWJsZSB0byBpbml0aWFsaXplIGV2ZW50IHVuZGVyIGRpc3BhdGNoaW5nLlwiLFxuKVxuXG5leHBvcnQgY29uc3QgRmFsc3lXYXNBc3NpZ25lZFRvQ2FuY2VsQnViYmxlID0gbmV3IFdhcm5pbmc8W10+KFxuICAgIFwiVzAyXCIsXG4gICAgXCJBc3NpZ25pbmcgYW55IGZhbHN5IHZhbHVlIHRvICdjYW5jZWxCdWJibGUnIHByb3BlcnR5IGhhcyBubyBlZmZlY3QuXCIsXG4pXG5cbmV4cG9ydCBjb25zdCBUcnV0aHlXYXNBc3NpZ25lZFRvUmV0dXJuVmFsdWUgPSBuZXcgV2FybmluZzxbXT4oXG4gICAgXCJXMDNcIixcbiAgICBcIkFzc2lnbmluZyBhbnkgdHJ1dGh5IHZhbHVlIHRvICdyZXR1cm5WYWx1ZScgcHJvcGVydHkgaGFzIG5vIGVmZmVjdC5cIixcbilcblxuZXhwb3J0IGNvbnN0IE5vbkNhbmNlbGFibGVFdmVudFdhc0NhbmNlbGVkID0gbmV3IFdhcm5pbmc8W10+KFxuICAgIFwiVzA0XCIsXG4gICAgXCJVbmFibGUgdG8gcHJldmVudERlZmF1bHQgb24gbm9uLWNhbmNlbGFibGUgZXZlbnRzLlwiLFxuKVxuXG5leHBvcnQgY29uc3QgQ2FuY2VsZWRJblBhc3NpdmVMaXN0ZW5lciA9IG5ldyBXYXJuaW5nPFtdPihcbiAgICBcIlcwNVwiLFxuICAgIFwiVW5hYmxlIHRvIHByZXZlbnREZWZhdWx0IGluc2lkZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIGludm9jYXRpb24uXCIsXG4pXG5cbmV4cG9ydCBjb25zdCBFdmVudExpc3RlbmVyV2FzRHVwbGljYXRlZCA9IG5ldyBXYXJuaW5nPFxuICAgIFt0eXBlOiBcImJ1YmJsZVwiIHwgXCJjYXB0dXJlXCIsIGNhbGxiYWNrOiBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPGFueSwgYW55Pl1cbj4oXG4gICAgXCJXMDZcIixcbiAgICBcIkFuIGV2ZW50IGxpc3RlbmVyIHdhc24ndCBhZGRlZCBiZWNhdXNlIGl0IGhhcyBiZWVuIGFkZGVkIGFscmVhZHk6ICVvLCAlb1wiLFxuKVxuXG5leHBvcnQgY29uc3QgT3B0aW9uV2FzSWdub3JlZCA9IG5ldyBXYXJuaW5nPFxuICAgIFtuYW1lOiBcInBhc3NpdmVcIiB8IFwib25jZVwiIHwgXCJzaWduYWxcIl1cbj4oXG4gICAgXCJXMDdcIixcbiAgICBcIlRoZSAlbyBvcHRpb24gdmFsdWUgd2FzIGFiYW5kb25lZCBiZWNhdXNlIHRoZSBldmVudCBsaXN0ZW5lciB3YXNuJ3QgYWRkZWQgYXMgZHVwbGljYXRlZC5cIixcbilcblxuZXhwb3J0IGNvbnN0IEludmFsaWRFdmVudExpc3RlbmVyID0gbmV3IFdhcm5pbmc8XG4gICAgW2NhbGxiYWNrOiBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPGFueSwgYW55PiB8IHt9IHwgbnVsbCB8IHVuZGVmaW5lZF1cbj4oXG4gICAgXCJXMDhcIixcbiAgICBcIlRoZSAnY2FsbGJhY2snIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QgdGhhdCBoYXMgJ2hhbmRsZUV2ZW50JyBtZXRob2Q6ICVvXCIsXG4pXG5cbmV4cG9ydCBjb25zdCBJbnZhbGlkQXR0cmlidXRlSGFuZGxlciA9IG5ldyBXYXJuaW5nPFxuICAgIFtjYWxsYmFjazogRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjxhbnksIGFueT4gfCB7fV1cbj4oXCJXMDlcIiwgXCJFdmVudCBhdHRyaWJ1dGUgaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb246ICVvXCIpXG4iLCJpbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50LXRhcmdldFwiIC8vIFVzZWQgYXMgb25seSB0eXBlLCBzbyBubyBjaXJjdWxhci5cbmltcG9ydCB7IEdsb2JhbCB9IGZyb20gXCIuL2dsb2JhbFwiXG5pbXBvcnQgeyBhc3NlcnRUeXBlIH0gZnJvbSBcIi4vbWlzY1wiXG5pbXBvcnQge1xuICAgIENhbmNlbGVkSW5QYXNzaXZlTGlzdGVuZXIsXG4gICAgRmFsc3lXYXNBc3NpZ25lZFRvQ2FuY2VsQnViYmxlLFxuICAgIEluaXRFdmVudFdhc0NhbGxlZFdoaWxlRGlzcGF0Y2hpbmcsXG4gICAgTm9uQ2FuY2VsYWJsZUV2ZW50V2FzQ2FuY2VsZWQsXG4gICAgVHJ1dGh5V2FzQXNzaWduZWRUb1JldHVyblZhbHVlLFxufSBmcm9tIFwiLi93YXJuaW5nc1wiXG5cbi8qZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBFdmVudGAgaW50ZXJmYWNlLCB0aGF0IHdyYXBzIGEgZ2l2ZW4gZXZlbnQgb2JqZWN0LlxuICogYEV2ZW50VGFyZ2V0YCBzaGltIGNhbiBjb250cm9sIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGlzIGBFdmVudGAgb2JqZWN0cy5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNldmVudFxuICovXG5leHBvcnQgY2xhc3MgRXZlbnQ8VEV2ZW50VHlwZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtbm9uZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTk9ORSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTk9ORVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FwdHVyaW5nX3BoYXNlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBDQVBUVVJJTkdfUEhBU0UoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIENBUFRVUklOR19QSEFTRVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtYXRfdGFyZ2V0XG4gICAgICovXG4gICAgc3RhdGljIGdldCBBVF9UQVJHRVQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIEFUX1RBUkdFVFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtYnViYmxpbmdfcGhhc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEJVQkJMSU5HX1BIQVNFKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBCVUJCTElOR19QSEFTRVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBldmVudCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudEluaXREaWN0IE9wdGlvbnMgdG8gaW5pdGlhbGl6ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWV2ZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZTogVEV2ZW50VHlwZSwgZXZlbnRJbml0RGljdD86IEV2ZW50LkV2ZW50SW5pdCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RydXN0ZWRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBvcHRzID0gZXZlbnRJbml0RGljdCA/PyB7fVxuICAgICAgICBpbnRlcm5hbERhdGFNYXAuc2V0KHRoaXMsIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyh0eXBlKSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IEJvb2xlYW4ob3B0cy5idWJibGVzKSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IEJvb2xlYW4ob3B0cy5jYW5jZWxhYmxlKSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiBCb29sZWFuKG9wdHMuY29tcG9zZWQpLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbkZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZzogZmFsc2UsXG4gICAgICAgICAgICBjYW5jZWxlZEZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgaW5QYXNzaXZlTGlzdGVuZXJGbGFnOiBmYWxzZSxcbiAgICAgICAgICAgIGRpc3BhdGNoRmxhZzogZmFsc2UsXG4gICAgICAgICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXR5cGVcbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpOiBURXZlbnRUeXBlIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudHlwZSBhcyBURXZlbnRUeXBlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHRhcmdldCBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGluZy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXRhcmdldFxuICAgICAqL1xuICAgIGdldCB0YXJnZXQoKTogRXZlbnRUYXJnZXQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudGFyZ2V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHRhcmdldCBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGluZy5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGB0YXJnZXRgIHByb3BlcnR5IGluc3RlYWQuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1zcmNlbGVtZW50XG4gICAgICovXG4gICAgZ2V0IHNyY0VsZW1lbnQoKTogRXZlbnRUYXJnZXQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudGFyZ2V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHRhcmdldCBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGluZy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWN1cnJlbnR0YXJnZXRcbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFRhcmdldCgpOiBFdmVudFRhcmdldCB8IG51bGwge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHRhcmdldCBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGluZy5cbiAgICAgKiBUaGlzIGRvZXNuJ3Qgc3VwcG9ydCBub2RlIHRyZWUuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jb21wb3NlZHBhdGhcbiAgICAgKi9cbiAgICBjb21wb3NlZFBhdGgoKTogRXZlbnRUYXJnZXRbXSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSAkKHRoaXMpLmN1cnJlbnRUYXJnZXRcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LW5vbmVcbiAgICAgKi9cbiAgICBnZXQgTk9ORSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTk9ORVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FwdHVyaW5nX3BoYXNlXG4gICAgICovXG4gICAgZ2V0IENBUFRVUklOR19QSEFTRSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gQ0FQVFVSSU5HX1BIQVNFXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1hdF90YXJnZXRcbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBBVF9UQVJHRVRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWJ1YmJsaW5nX3BoYXNlXG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBCVUJCTElOR19QSEFTRVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGV2ZW50IHBoYXNlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtZXZlbnRwaGFzZVxuICAgICAqL1xuICAgIGdldCBldmVudFBoYXNlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLmRpc3BhdGNoRmxhZyA/IDIgOiAwXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBCZWNhdXNlIHRoaXMgc2hpbSBkb2Vzbid0IHN1cHBvcnQgbm9kZSB0cmVlLCB0aGlzIG1lcmVseSBjaGFuZ2VzIHRoZSBgY2FuY2VsQnViYmxlYCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXN0b3Bwcm9wYWdhdGlvblxuICAgICAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbigpOiB2b2lkIHtcbiAgICAgICAgJCh0aGlzKS5zdG9wUHJvcGFnYXRpb25GbGFnID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGB0cnVlYCBpZiBldmVudCBidWJibGluZyB3YXMgc3RvcHBlZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FuY2VsYnViYmxlXG4gICAgICovXG4gICAgZ2V0IGNhbmNlbEJ1YmJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykuc3RvcFByb3BhZ2F0aW9uRmxhZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcgaWYgYHRydWVgIGlzIHNldC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBzdG9wUHJvcGFnYXRpb24oKWAgbWV0aG9kIGluc3RlYWQuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jYW5jZWxidWJibGVcbiAgICAgKi9cbiAgICBzZXQgY2FuY2VsQnViYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgJCh0aGlzKS5zdG9wUHJvcGFnYXRpb25GbGFnID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRmFsc3lXYXNBc3NpZ25lZFRvQ2FuY2VsQnViYmxlLndhcm4oKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZyBhbmQgc3Vic2VxdWVudCBldmVudCBsaXN0ZW5lciBjYWxsaW5ncy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXN0b3BpbW1lZGlhdGVwcm9wYWdhdGlvblxuICAgICAqL1xuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0YSA9ICQodGhpcylcbiAgICAgICAgZGF0YS5zdG9wUHJvcGFnYXRpb25GbGFnID0gZGF0YS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25GbGFnID0gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGB0cnVlYCBpZiB0aGlzIGV2ZW50IHdpbGwgYnViYmxlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtYnViYmxlc1xuICAgICAqL1xuICAgIGdldCBidWJibGVzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5idWJibGVzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGVkIGJ5IHRoZSBgcHJldmVudERlZmF1bHQoKWAgbWV0aG9kLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FuY2VsYWJsZVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5jYW5jZWxhYmxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYWN0LlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYGRlZmF1bHRQcmV2ZW50ZWRgIHByb2VwcnR5IGluc3RlYWQuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1yZXR1cm52YWx1ZVxuICAgICAqL1xuICAgIGdldCByZXR1cm5WYWx1ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEkKHRoaXMpLmNhbmNlbGVkRmxhZ1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiBgZmFsc2VgIGlzIHNldC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBwcmV2ZW50RGVmYXVsdCgpYCBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXJldHVybnZhbHVlXG4gICAgICovXG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHNldENhbmNlbEZsYWcoJCh0aGlzKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRydXRoeVdhc0Fzc2lnbmVkVG9SZXR1cm5WYWx1ZS53YXJuKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXByZXZlbnRkZWZhdWx0XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKTogdm9pZCB7XG4gICAgICAgIHNldENhbmNlbEZsYWcoJCh0aGlzKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2FzIGNhbmNlbGVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtZGVmYXVsdHByZXZlbnRlZFxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0UHJldmVudGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5jYW5jZWxlZEZsYWdcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWNvbXBvc2VkXG4gICAgICovXG4gICAgZ2V0IGNvbXBvc2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5jb21wb3NlZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtaXN0cnVzdGVkXG4gICAgICovXG4gICAgLy9pc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGdldCBpc1RydXN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtdGltZXN0YW1wXG4gICAgICovXG4gICAgZ2V0IHRpbWVTdGFtcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS50aW1lU3RhbXBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBEb24ndCB1c2UgdGhpcyBtZXRob2QuIFRoZSBjb25zdHJ1Y3RvciBkaWQgaW5pdGlhbGl6YXRpb24uXG4gICAgICovXG4gICAgaW5pdEV2ZW50KHR5cGU6IHN0cmluZywgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9ICQodGhpcylcbiAgICAgICAgaWYgKGRhdGEuZGlzcGF0Y2hGbGFnKSB7XG4gICAgICAgICAgICBJbml0RXZlbnRXYXNDYWxsZWRXaGlsZURpc3BhdGNoaW5nLndhcm4oKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpbnRlcm5hbERhdGFNYXAuc2V0KHRoaXMsIHtcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcodHlwZSksXG4gICAgICAgICAgICBidWJibGVzOiBCb29sZWFuKGJ1YmJsZXMpLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogQm9vbGVhbihjYW5jZWxhYmxlKSxcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IG51bGwsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb25GbGFnOiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbkZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgY2FuY2VsZWRGbGFnOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbi8qZXNsaW50LWVuYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5cbmV4cG9ydCBuYW1lc3BhY2UgRXZlbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25zIG9mIHRoZSBgRXZlbnRgIGNvbnN0cnVjdG9yLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkaWN0ZGVmLWV2ZW50aW5pdFxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgRXZlbnRJbml0IHtcbiAgICAgICAgYnViYmxlcz86IGJvb2xlYW5cbiAgICAgICAgY2FuY2VsYWJsZT86IGJvb2xlYW5cbiAgICAgICAgY29tcG9zZWQ/OiBib29sZWFuXG4gICAgfVxufVxuXG5leHBvcnQgeyAkIGFzIGdldEV2ZW50SW50ZXJuYWxEYXRhIH1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IE5PTkUgPSAwXG5jb25zdCBDQVBUVVJJTkdfUEhBU0UgPSAxXG5jb25zdCBBVF9UQVJHRVQgPSAyXG5jb25zdCBCVUJCTElOR19QSEFTRSA9IDNcblxuLyoqXG4gKiBQcml2YXRlIGRhdGEuXG4gKi9cbmludGVyZmFjZSBFdmVudEludGVybmFsRGF0YSB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIGB0eXBlYCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgcmVhZG9ubHkgdHlwZTogc3RyaW5nXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIGBidWJibGVzYCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgcmVhZG9ubHkgYnViYmxlczogYm9vbGVhblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiBgY2FuY2VsYWJsZWAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNhbmNlbGFibGU6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgYGNvbXBvc2VkYCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29tcG9zZWQ6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgYHRpbWVTdGFtcGAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHRpbWVTdGFtcDogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXRhcmdldFxuICAgICAqL1xuICAgIHRhcmdldDogRXZlbnRUYXJnZXQgfCBudWxsXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jdXJyZW50dGFyZ2V0XG4gICAgICovXG4gICAgY3VycmVudFRhcmdldDogRXZlbnRUYXJnZXQgfCBudWxsXG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3N0b3AtcHJvcGFnYXRpb24tZmxhZ1xuICAgICAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbkZsYWc6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jc3RvcC1pbW1lZGlhdGUtcHJvcGFnYXRpb24tZmxhZ1xuICAgICAqL1xuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbkZsYWc6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY2FuY2VsZWQtZmxhZ1xuICAgICAqL1xuICAgIGNhbmNlbGVkRmxhZzogYm9vbGVhblxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbi1wYXNzaXZlLWxpc3RlbmVyLWZsYWdcbiAgICAgKi9cbiAgICBpblBhc3NpdmVMaXN0ZW5lckZsYWc6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZGlzcGF0Y2gtZmxhZ1xuICAgICAqL1xuICAgIGRpc3BhdGNoRmxhZzogYm9vbGVhblxufVxuXG4vKipcbiAqIFByaXZhdGUgZGF0YSBmb3IgZXZlbnQgd3JhcHBlcnMuXG4gKi9cbmNvbnN0IGludGVybmFsRGF0YU1hcCA9IG5ldyBXZWFrTWFwPGFueSwgRXZlbnRJbnRlcm5hbERhdGE+KClcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSBuYW1lIFRoZSB2YXJpYWJsZSBuYW1lIHRvIHJlcG9ydC5cbiAqIEByZXR1cm5zIFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICovXG5mdW5jdGlvbiAkKGV2ZW50OiB1bmtub3duLCBuYW1lID0gXCJ0aGlzXCIpOiBFdmVudEludGVybmFsRGF0YSB7XG4gICAgY29uc3QgcmV0diA9IGludGVybmFsRGF0YU1hcC5nZXQoZXZlbnQpXG4gICAgYXNzZXJ0VHlwZShcbiAgICAgICAgcmV0diAhPSBudWxsLFxuICAgICAgICBcIiclcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBFdmVudCBjb25zdHJ1Y3RvciBjcmVhdGVkLCBidXQgZ290IGFub3RoZXIgb25lOiAlb1wiLFxuICAgICAgICBuYW1lLFxuICAgICAgICBldmVudCxcbiAgICApXG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3NldC10aGUtY2FuY2VsZWQtZmxhZ1xuICogQHBhcmFtIGRhdGEgcHJpdmF0ZSBkYXRhLlxuICovXG5mdW5jdGlvbiBzZXRDYW5jZWxGbGFnKGRhdGE6IEV2ZW50SW50ZXJuYWxEYXRhKSB7XG4gICAgaWYgKGRhdGEuaW5QYXNzaXZlTGlzdGVuZXJGbGFnKSB7XG4gICAgICAgIENhbmNlbGVkSW5QYXNzaXZlTGlzdGVuZXIud2FybigpXG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIWRhdGEuY2FuY2VsYWJsZSkge1xuICAgICAgICBOb25DYW5jZWxhYmxlRXZlbnRXYXNDYW5jZWxlZC53YXJuKClcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZGF0YS5jYW5jZWxlZEZsYWcgPSB0cnVlXG59XG5cbi8vIFNldCBlbnVtZXJhYmxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQsIFwiTk9ORVwiLCB7IGVudW1lcmFibGU6IHRydWUgfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudCwgXCJDQVBUVVJJTkdfUEhBU0VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQsIFwiQVRfVEFSR0VUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LCBcIkJVQkJMSU5HX1BIQVNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KVxuY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEV2ZW50LnByb3RvdHlwZSlcbmZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChrZXlzW2ldID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgY29udGludWVcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwga2V5c1tpXSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pXG59XG5cbi8vIEVuc3VyZSBgZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2YgR2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBHbG9iYWwuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnQucHJvdG90eXBlLCBHbG9iYWwuRXZlbnQucHJvdG90eXBlKVxufVxuIiwiaW1wb3J0IHsgR2xvYmFsIH0gZnJvbSBcIi4vZ2xvYmFsXCJcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgSW52YWxpZFN0YXRlRXJyb3IgaW5zdGFuY2UuXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUludmFsaWRTdGF0ZUVycm9yKG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIHtcbiAgICBpZiAoR2xvYmFsLkRPTUV4Y2VwdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IEdsb2JhbC5ET01FeGNlcHRpb24obWVzc2FnZSwgXCJJbnZhbGlkU3RhdGVFcnJvclwiKVxuICAgIH1cblxuICAgIGlmIChET01FeGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBET01FeGNlcHRpb24gPSBjbGFzcyBET01FeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihtc2c6IHN0cmluZykge1xuICAgICAgICAgICAgICAgIHN1cGVyKG1zZylcbiAgICAgICAgICAgICAgICBpZiAoKEVycm9yIGFzIGFueSkuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgOyhFcnJvciBhcyBhbnkpLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIERPTUV4Y2VwdGlvbilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgICAgICAgICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDExXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgICAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKERPTUV4Y2VwdGlvbi5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvZGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICAgICAgbmFtZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIH0pXG4gICAgICAgIGRlZmluZUVycm9yQ29kZVByb3BlcnRpZXMoRE9NRXhjZXB0aW9uKVxuICAgICAgICBkZWZpbmVFcnJvckNvZGVQcm9wZXJ0aWVzKERPTUV4Y2VwdGlvbi5wcm90b3R5cGUpXG4gICAgfVxuICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKG1lc3NhZ2UpXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgRE9NRXhjZXB0aW9uOiB7IG5ldyAobWVzc2FnZTogc3RyaW5nKTogRXJyb3IgfSB8IHVuZGVmaW5lZFxuXG5jb25zdCBFcnJvckNvZGVNYXAgPSB7XG4gICAgSU5ERVhfU0laRV9FUlI6IDEsXG4gICAgRE9NU1RSSU5HX1NJWkVfRVJSOiAyLFxuICAgIEhJRVJBUkNIWV9SRVFVRVNUX0VSUjogMyxcbiAgICBXUk9OR19ET0NVTUVOVF9FUlI6IDQsXG4gICAgSU5WQUxJRF9DSEFSQUNURVJfRVJSOiA1LFxuICAgIE5PX0RBVEFfQUxMT1dFRF9FUlI6IDYsXG4gICAgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiA3LFxuICAgIE5PVF9GT1VORF9FUlI6IDgsXG4gICAgTk9UX1NVUFBPUlRFRF9FUlI6IDksXG4gICAgSU5VU0VfQVRUUklCVVRFX0VSUjogMTAsXG4gICAgSU5WQUxJRF9TVEFURV9FUlI6IDExLFxuICAgIFNZTlRBWF9FUlI6IDEyLFxuICAgIElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUjogMTMsXG4gICAgTkFNRVNQQUNFX0VSUjogMTQsXG4gICAgSU5WQUxJRF9BQ0NFU1NfRVJSOiAxNSxcbiAgICBWQUxJREFUSU9OX0VSUjogMTYsXG4gICAgVFlQRV9NSVNNQVRDSF9FUlI6IDE3LFxuICAgIFNFQ1VSSVRZX0VSUjogMTgsXG4gICAgTkVUV09SS19FUlI6IDE5LFxuICAgIEFCT1JUX0VSUjogMjAsXG4gICAgVVJMX01JU01BVENIX0VSUjogMjEsXG4gICAgUVVPVEFfRVhDRUVERURfRVJSOiAyMixcbiAgICBUSU1FT1VUX0VSUjogMjMsXG4gICAgSU5WQUxJRF9OT0RFX1RZUEVfRVJSOiAyNCxcbiAgICBEQVRBX0NMT05FX0VSUjogMjUsXG59XG50eXBlIEVycm9yQ29kZU1hcCA9IHR5cGVvZiBFcnJvckNvZGVNYXBcblxuZnVuY3Rpb24gZGVmaW5lRXJyb3JDb2RlUHJvcGVydGllcyhvYmo6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhFcnJvckNvZGVNYXApIGFzIChrZXlvZiBFcnJvckNvZGVNYXApW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICBjb25zdCB2YWx1ZSA9IEVycm9yQ29kZU1hcFtrZXldXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0pXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnQgfSBmcm9tIFwiLi9ldmVudFwiXG5pbXBvcnQgeyBHbG9iYWwgfSBmcm9tIFwiLi9nbG9iYWxcIlxuaW1wb3J0IHsgYXNzZXJ0VHlwZSB9IGZyb20gXCIuL21pc2NcIlxuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBFdmVudGAgaW50ZXJmYWNlLCB0aGF0IHdyYXBzIGEgZ2l2ZW4gZXZlbnQgb2JqZWN0LlxuICogVGhpcyBjbGFzcyBjb250cm9scyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYEV2ZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50V3JhcHBlcjxURXZlbnRUeXBlIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIEV2ZW50PFRFdmVudFR5cGU+IHtcbiAgICAvKipcbiAgICAgKiBXcmFwIGEgZ2l2ZW4gZXZlbnQgb2JqZWN0IHRvIGNvbnRyb2wgc3RhdGVzLlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQtbGlrZSBvYmplY3QgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd3JhcDxUIGV4dGVuZHMgRXZlbnRMaWtlPihldmVudDogVCk6IEV2ZW50V3JhcHBlck9mPFQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyAoZ2V0V3JhcHBlckNsYXNzT2YoZXZlbnQpKShldmVudClcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoZXZlbnQ6IEV2ZW50PFRFdmVudFR5cGU+KSB7XG4gICAgICAgIHN1cGVyKGV2ZW50LnR5cGUsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50LmJ1YmJsZXMsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgY29tcG9zZWQ6IGV2ZW50LmNvbXBvc2VkLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChldmVudC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgIHN1cGVyLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIHN1cGVyLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfVxuXG4gICAgICAgIGludGVybmFsRGF0YU1hcC5zZXQodGhpcywgeyBvcmlnaW5hbDogZXZlbnQgfSlcblxuICAgICAgICAvLyBEZWZpbmUgYWNjZXNzb3JzXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGV2ZW50LCBrZXkpLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BQcm9wYWdhdGlvbigpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkKHRoaXMpXG4gICAgICAgIGlmIChcInN0b3BQcm9wYWdhdGlvblwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5zdG9wUHJvcGFnYXRpb24hKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjYW5jZWxCdWJibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdXBlci5jYW5jZWxCdWJibGVcbiAgICB9XG4gICAgc2V0IGNhbmNlbEJ1YmJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBzdXBlci5jYW5jZWxCdWJibGUgPSB2YWx1ZVxuXG4gICAgICAgIGNvbnN0IHsgb3JpZ2luYWwgfSA9ICQodGhpcylcbiAgICAgICAgaWYgKFwiY2FuY2VsQnViYmxlXCIgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsLmNhbmNlbEJ1YmJsZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgY29uc3QgeyBvcmlnaW5hbCB9ID0gJCh0aGlzKVxuICAgICAgICBpZiAoXCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIiBpbiBvcmlnaW5hbCkge1xuICAgICAgICAgICAgb3JpZ2luYWwuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uISgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcmV0dXJuVmFsdWUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdXBlci5yZXR1cm5WYWx1ZVxuICAgIH1cbiAgICBzZXQgcmV0dXJuVmFsdWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgc3VwZXIucmV0dXJuVmFsdWUgPSB2YWx1ZVxuXG4gICAgICAgIGNvbnN0IHsgb3JpZ2luYWwgfSA9ICQodGhpcylcbiAgICAgICAgaWYgKFwicmV0dXJuVmFsdWVcIiBpbiBvcmlnaW5hbCkge1xuICAgICAgICAgICAgb3JpZ2luYWwucmV0dXJuVmFsdWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJldmVudERlZmF1bHQoKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnByZXZlbnREZWZhdWx0KClcblxuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkKHRoaXMpXG4gICAgICAgIGlmIChcInByZXZlbnREZWZhdWx0XCIgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsLnByZXZlbnREZWZhdWx0ISgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGltZVN0YW1wKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luYWwgfSA9ICQodGhpcylcbiAgICAgICAgaWYgKFwidGltZVN0YW1wXCIgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC50aW1lU3RhbXAhXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnRpbWVTdGFtcFxuICAgIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnR5cGUgRXZlbnRMaWtlID0geyByZWFkb25seSB0eXBlOiBzdHJpbmcgfSAmIFBhcnRpYWw8RXZlbnQ+XG50eXBlIEV2ZW50V3JhcHBlck9mPFQgZXh0ZW5kcyBFdmVudExpa2U+ID0gRXZlbnQ8VFtcInR5cGVcIl0+ICZcbiAgICBPbWl0PFQsIGtleW9mIEV2ZW50PlxuXG5pbnRlcmZhY2UgRXZlbnRXcmFwcGVySW50ZXJuYWxEYXRhIHtcbiAgICByZWFkb25seSBvcmlnaW5hbDogRXZlbnRMaWtlXG59XG5cbi8qKlxuICogUHJpdmF0ZSBkYXRhIGZvciBldmVudCB3cmFwcGVycy5cbiAqL1xuY29uc3QgaW50ZXJuYWxEYXRhTWFwID0gbmV3IFdlYWtNYXA8YW55LCBFdmVudFdyYXBwZXJJbnRlcm5hbERhdGE+KClcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEByZXR1cm5zIFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICovXG5mdW5jdGlvbiAkKGV2ZW50OiB1bmtub3duKTogRXZlbnRXcmFwcGVySW50ZXJuYWxEYXRhIHtcbiAgICBjb25zdCByZXR2ID0gaW50ZXJuYWxEYXRhTWFwLmdldChldmVudClcbiAgICBhc3NlcnRUeXBlKFxuICAgICAgICByZXR2ICE9IG51bGwsXG4gICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLFxuICAgICAgICBldmVudCxcbiAgICApXG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVyQ2xhc3NDYWNoZSA9IG5ldyBXZWFrTWFwKClcblxuLy8gTWFrZSBhc3NvY2lhdGlvbiBmb3Igd3JhcHBlcnMuXG53cmFwcGVyQ2xhc3NDYWNoZS5zZXQoT2JqZWN0LnByb3RvdHlwZSwgRXZlbnRXcmFwcGVyKVxuaWYgKHR5cGVvZiBHbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEdsb2JhbC5FdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdyYXBwZXJDbGFzc0NhY2hlLnNldChHbG9iYWwuRXZlbnQucHJvdG90eXBlLCBFdmVudFdyYXBwZXIpXG59XG5cbi8qKlxuICogR2V0IHRoZSB3cmFwcGVyIGNsYXNzIG9mIGEgZ2l2ZW4gcHJvdG90eXBlLlxuICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgVGhlIGV2ZW50IG9iamVjdCB0byB3cmFwLlxuICovXG5mdW5jdGlvbiBnZXRXcmFwcGVyQ2xhc3NPZjxUIGV4dGVuZHMgRXZlbnRMaWtlPihcbiAgICBvcmlnaW5hbEV2ZW50OiBULFxuKTogeyBuZXcgKGU6IFQpOiBFdmVudFdyYXBwZXJPZjxUPiB9IHtcbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWxFdmVudClcbiAgICBpZiAocHJvdG90eXBlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50V3JhcHBlciBhcyBhbnlcbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjogYW55ID0gd3JhcHBlckNsYXNzQ2FjaGUuZ2V0KHByb3RvdHlwZSlcbiAgICBpZiAod3JhcHBlciA9PSBudWxsKSB7XG4gICAgICAgIHdyYXBwZXIgPSBkZWZpbmVXcmFwcGVyKGdldFdyYXBwZXJDbGFzc09mKHByb3RvdHlwZSksIHByb3RvdHlwZSlcbiAgICAgICAgd3JhcHBlckNsYXNzQ2FjaGUuc2V0KHByb3RvdHlwZSwgd3JhcHBlcilcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIERlZmluZSBuZXcgd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSBCYXNlRXZlbnRXcmFwcGVyIFRoZSBiYXNlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0gb3JpZ2luYWxQcm90b3R5cGUgVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVdyYXBwZXIoQmFzZUV2ZW50V3JhcHBlcjogYW55LCBvcmlnaW5hbFByb3RvdHlwZTogYW55KTogYW55IHtcbiAgICBjbGFzcyBDdXN0b21FdmVudFdyYXBwZXIgZXh0ZW5kcyBCYXNlRXZlbnRXcmFwcGVyIHt9XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3JpZ2luYWxQcm90b3R5cGUpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIEN1c3RvbUV2ZW50V3JhcHBlci5wcm90b3R5cGUsXG4gICAgICAgICAgICBrZXlzW2ldLFxuICAgICAgICAgICAgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKG9yaWdpbmFsUHJvdG90eXBlLCBrZXlzW2ldKSxcbiAgICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFdyYXBwZXJcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgYSBnaXZlbiBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKG9iajogYW55LCBrZXk6IHN0cmluZyk6IFByb3BlcnR5RGVzY3JpcHRvciB7XG4gICAgY29uc3QgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIVxuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsOiBhbnkgPSAkKHRoaXMpLm9yaWdpbmFsXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsW2tleV1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKG9yaWdpbmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZTogYW55KSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbDogYW55ID0gJCh0aGlzKS5vcmlnaW5hbFxuICAgICAgICAgICAgb3JpZ2luYWxba2V5XSA9IHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZC5jb25maWd1cmFibGUsXG4gICAgICAgIGVudW1lcmFibGU6IGQuZW51bWVyYWJsZSxcbiAgICB9XG59XG4iLCJpbXBvcnQgeyByZXBvcnRFcnJvciB9IGZyb20gXCIuL2Vycm9yLWhhbmRsZXJcIlxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tIFwiLi9ldmVudFwiIC8vIFVzZWQgYXMgb25seSB0eXBlLCBzbyBubyBjaXJjdWxhci5cbmltcG9ydCB7IEV2ZW50VGFyZ2V0IH0gZnJvbSBcIi4vZXZlbnQtdGFyZ2V0XCIgLy8gVXNlZCBhcyBvbmx5IHR5cGUsIHNvIG5vIGNpcmN1bGFyLlxuXG4vKipcbiAqIFRoZSBldmVudCBsaXN0ZW5lciBjb25jZXB0LlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZXZlbnQtbGlzdGVuZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXN0ZW5lciB7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNhbGxiYWNrOiBMaXN0ZW5lci5DYWxsYmFjazxhbnksIGFueT5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZ3Mgb2YgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBUaGlzIGlzIHdyaXRhYmxlIHRvIGFkZCB0aGUgcmVtb3ZlZCBmbGFnLlxuICAgICAqL1xuICAgIGZsYWdzOiBMaXN0ZW5lckZsYWdzXG4gICAgLyoqXG4gICAgICogVGhlIGBBYm9ydFNpZ25hbGAgdG8gcmVtb3ZlIHRoaXMgbGlzdGVuZXIuXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2lnbmFsOiBMaXN0ZW5lci5BYm9ydFNpZ25hbCB8IHVuZGVmaW5lZFxuICAgIC8qKlxuICAgICAqIFRoZSBgYWJvcnRgIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgYHNpZ25hbGAuXG4gICAgICogVG8gcmVtb3ZlIGl0IGZyb20gdGhlIGBzaWduYWxgLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHNpZ25hbExpc3RlbmVyOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBMaXN0ZW5lciB7XG4gICAgZXhwb3J0IHR5cGUgQ2FsbGJhY2s8XG4gICAgICAgIFRFdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICAgICAgVEV2ZW50IGV4dGVuZHMgRXZlbnRcbiAgICA+ID0gQ2FsbGJhY2tGdW5jdGlvbjxURXZlbnRUYXJnZXQsIFRFdmVudD4gfCBDYWxsYmFja09iamVjdDxURXZlbnQ+XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIENhbGxiYWNrRnVuY3Rpb248XG4gICAgICAgIFRFdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICAgICAgVEV2ZW50IGV4dGVuZHMgRXZlbnRcbiAgICA+IHtcbiAgICAgICAgKHRoaXM6IFRFdmVudFRhcmdldCwgZXZlbnQ6IFRFdmVudCk6IHZvaWRcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIENhbGxiYWNrT2JqZWN0PFRFdmVudCBleHRlbmRzIEV2ZW50PiB7XG4gICAgICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBURXZlbnQpOiB2b2lkXG4gICAgfVxuXG4gICAgZXhwb3J0IGludGVyZmFjZSBBYm9ydFNpZ25hbCB7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZTogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2s8YW55LCBFdmVudD4pOiB2b2lkXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZTogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2s8YW55LCBFdmVudD4pOiB2b2lkXG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBsaXN0ZW5lci5cbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnLlxuICogQHBhcmFtIHBhc3NpdmUgVGhlIHBhc3NpdmUgZmxhZy5cbiAqIEBwYXJhbSBvbmNlIFRoZSBvbmNlIGZsYWcuXG4gKiBAcGFyYW0gc2lnbmFsIFRoZSBhYm9ydCBzaWduYWwuXG4gKiBAcGFyYW0gc2lnbmFsTGlzdGVuZXIgVGhlIGFib3J0IGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgYWJvcnQgc2lnbmFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIoXG4gICAgY2FsbGJhY2s6IExpc3RlbmVyLkNhbGxiYWNrPGFueSwgYW55PixcbiAgICBjYXB0dXJlOiBib29sZWFuLFxuICAgIHBhc3NpdmU6IGJvb2xlYW4sXG4gICAgb25jZTogYm9vbGVhbixcbiAgICBzaWduYWw6IExpc3RlbmVyLkFib3J0U2lnbmFsIHwgdW5kZWZpbmVkLFxuICAgIHNpZ25hbExpc3RlbmVyOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQsXG4pOiBMaXN0ZW5lciB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIGZsYWdzOlxuICAgICAgICAgICAgKGNhcHR1cmUgPyBMaXN0ZW5lckZsYWdzLkNhcHR1cmUgOiAwKSB8XG4gICAgICAgICAgICAocGFzc2l2ZSA/IExpc3RlbmVyRmxhZ3MuUGFzc2l2ZSA6IDApIHxcbiAgICAgICAgICAgIChvbmNlID8gTGlzdGVuZXJGbGFncy5PbmNlIDogMCksXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgc2lnbmFsTGlzdGVuZXIsXG4gICAgfVxufVxuXG4vKipcbiAqIFNldCB0aGUgYHJlbW92ZWRgIGZsYWcgdG8gdGhlIGdpdmVuIGxpc3RlbmVyLlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFJlbW92ZWQobGlzdGVuZXI6IExpc3RlbmVyKTogdm9pZCB7XG4gICAgbGlzdGVuZXIuZmxhZ3MgfD0gTGlzdGVuZXJGbGFncy5SZW1vdmVkXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGxpc3RlbmVyIGhhcyB0aGUgYGNhcHR1cmVgIGZsYWcgb3Igbm90LlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FwdHVyZShsaXN0ZW5lcjogTGlzdGVuZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgTGlzdGVuZXJGbGFncy5DYXB0dXJlKSA9PT0gTGlzdGVuZXJGbGFncy5DYXB0dXJlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGxpc3RlbmVyIGhhcyB0aGUgYHBhc3NpdmVgIGZsYWcgb3Igbm90LlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFzc2l2ZShsaXN0ZW5lcjogTGlzdGVuZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgTGlzdGVuZXJGbGFncy5QYXNzaXZlKSA9PT0gTGlzdGVuZXJGbGFncy5QYXNzaXZlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGxpc3RlbmVyIGhhcyB0aGUgYG9uY2VgIGZsYWcgb3Igbm90LlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT25jZShsaXN0ZW5lcjogTGlzdGVuZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgTGlzdGVuZXJGbGFncy5PbmNlKSA9PT0gTGlzdGVuZXJGbGFncy5PbmNlXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGxpc3RlbmVyIGhhcyB0aGUgYHJlbW92ZWRgIGZsYWcgb3Igbm90LlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjaGVjay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVtb3ZlZChsaXN0ZW5lcjogTGlzdGVuZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgTGlzdGVuZXJGbGFncy5SZW1vdmVkKSA9PT0gTGlzdGVuZXJGbGFncy5SZW1vdmVkXG59XG5cbi8qKlxuICogQ2FsbCBhbiBldmVudCBsaXN0ZW5lci5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbC5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvYmplY3QgZm9yIGB0aGlzQXJnYC5cbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IGZvciB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0gYXR0cmlidXRlIGB0cnVlYCBpZiB0aGlzIGNhbGxiYWNrIGlzIGFuIGV2ZW50IGF0dHJpYnV0ZSBoYW5kbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soXG4gICAgeyBjYWxsYmFjayB9OiBMaXN0ZW5lcixcbiAgICB0YXJnZXQ6IEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICBldmVudDogRXZlbnQ8YW55Pixcbik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0YXJnZXQsIGV2ZW50KVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjYWxsYmFjay5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5oYW5kbGVFdmVudChldmVudClcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKHRocm93bkVycm9yKSB7XG4gICAgICAgIHJlcG9ydEVycm9yKHRocm93bkVycm9yKVxuICAgIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVGhlIGZsYWdzIG9mIGxpc3RlbmVycy5cbiAqL1xuY29uc3QgZW51bSBMaXN0ZW5lckZsYWdzIHtcbiAgICBDYXB0dXJlID0gMHgwMSxcbiAgICBQYXNzaXZlID0gMHgwMixcbiAgICBPbmNlID0gMHgwNCxcbiAgICBSZW1vdmVkID0gMHgwOCxcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUxpc3RlbmVyLCBpc0NhcHR1cmUsIExpc3RlbmVyLCBzZXRSZW1vdmVkIH0gZnJvbSBcIi4vbGlzdGVuZXJcIlxuXG4vKipcbiAqIEluZm9ybWF0aW9uIG9mIGFuIGxpc3RlbmVyIGxpc3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGVuZXJMaXN0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IGF0dHJpYnV0ZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIGF0dHJDYWxsYmFjazogTGlzdGVuZXIuQ2FsbGJhY2tGdW5jdGlvbjxhbnksIGFueT4gfCB1bmRlZmluZWRcbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGV2ZW50IGF0dHJpYnV0ZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIGF0dHJMaXN0ZW5lcjogTGlzdGVuZXIgfCB1bmRlZmluZWRcbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlIGBkaXNwYXRjaEV2ZW50YCBtZXRob2QgaXMgdHJhdmVyc2luZyB0aGUgY3VycmVudCBgbGlzdGVuZXJzYCBhcnJheS5cbiAgICAgKi9cbiAgICBjb3c6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBUaGUgbGlzdGVuZXJzLlxuICAgICAqIFRoaXMgaXMgd3JpdGFibGUgZm9yIGNvcHktb24td3JpdGUuXG4gICAgICovXG4gICAgbGlzdGVuZXJzOiBMaXN0ZW5lcltdXG59XG5cbi8qKlxuICogRmluZCB0aGUgaW5kZXggb2YgZ2l2ZW4gbGlzdGVuZXIuXG4gKiBUaGlzIHJldHVybnMgYC0xYCBpZiBub3QgZm91bmQuXG4gKiBAcGFyYW0gbGlzdCBUaGUgbGlzdGVuZXIgbGlzdC5cbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmluZC5cbiAqIEBwYXJhbSBjYXB0dXJlIFRoZSBjYXB0dXJlIGZsYWcgdG8gZmluZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbmRleE9mTGlzdGVuZXIoXG4gICAgeyBsaXN0ZW5lcnMgfTogTGlzdGVuZXJMaXN0LFxuICAgIGNhbGxiYWNrOiBMaXN0ZW5lci5DYWxsYmFjazxhbnksIGFueT4sXG4gICAgY2FwdHVyZTogYm9vbGVhbixcbik6IG51bWJlciB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgaXNDYXB0dXJlKGxpc3RlbmVyc1tpXSkgPT09IGNhcHR1cmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gbGlzdGVuZXIuXG4gKiBEb2VzIGNvcHktb24td3JpdGUgaWYgbmVlZGVkLlxuICogQHBhcmFtIGxpc3QgVGhlIGxpc3RlbmVyIGxpc3QuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIGNhcHR1cmUgVGhlIGNhcHR1cmUgZmxhZy5cbiAqIEBwYXJhbSBwYXNzaXZlIFRoZSBwYXNzaXZlIGZsYWcuXG4gKiBAcGFyYW0gb25jZSBUaGUgb25jZSBmbGFnLlxuICogQHBhcmFtIHNpZ25hbCBUaGUgYWJvcnQgc2lnbmFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkTGlzdGVuZXIoXG4gICAgbGlzdDogTGlzdGVuZXJMaXN0LFxuICAgIGNhbGxiYWNrOiBMaXN0ZW5lci5DYWxsYmFjazxhbnksIGFueT4sXG4gICAgY2FwdHVyZTogYm9vbGVhbixcbiAgICBwYXNzaXZlOiBib29sZWFuLFxuICAgIG9uY2U6IGJvb2xlYW4sXG4gICAgc2lnbmFsOiBMaXN0ZW5lci5BYm9ydFNpZ25hbCB8IHVuZGVmaW5lZCxcbik6IExpc3RlbmVyIHtcbiAgICBsZXQgc2lnbmFsTGlzdGVuZXI6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZFxuICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgc2lnbmFsTGlzdGVuZXIgPSByZW1vdmVMaXN0ZW5lci5iaW5kKG51bGwsIGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlKVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHNpZ25hbExpc3RlbmVyKVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVyID0gY3JlYXRlTGlzdGVuZXIoXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBjYXB0dXJlLFxuICAgICAgICBwYXNzaXZlLFxuICAgICAgICBvbmNlLFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHNpZ25hbExpc3RlbmVyLFxuICAgIClcblxuICAgIGlmIChsaXN0LmNvdykge1xuICAgICAgICBsaXN0LmNvdyA9IGZhbHNlXG4gICAgICAgIGxpc3QubGlzdGVuZXJzID0gWy4uLmxpc3QubGlzdGVuZXJzLCBsaXN0ZW5lcl1cbiAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Lmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0ZW5lclxufVxuXG4vKipcbiAqIFJlbW92ZSBhIGxpc3RlbmVyLlxuICogQHBhcmFtIGxpc3QgVGhlIGxpc3RlbmVyIGxpc3QuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpbmQuXG4gKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnIHRvIGZpbmQuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgaXQgbXV0YXRlZCB0aGUgbGlzdCBkaXJlY3RseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKFxuICAgIGxpc3Q6IExpc3RlbmVyTGlzdCxcbiAgICBjYWxsYmFjazogTGlzdGVuZXIuQ2FsbGJhY2s8YW55LCBhbnk+LFxuICAgIGNhcHR1cmU6IGJvb2xlYW4sXG4pOiBib29sZWFuIHtcbiAgICBjb25zdCBpbmRleCA9IGZpbmRJbmRleE9mTGlzdGVuZXIobGlzdCwgY2FsbGJhY2ssIGNhcHR1cmUpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlTGlzdGVuZXJBdChsaXN0LCBpbmRleClcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogUmVtb3ZlIGEgbGlzdGVuZXIuXG4gKiBAcGFyYW0gbGlzdCBUaGUgbGlzdGVuZXIgbGlzdC5cbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhcmdldCBsaXN0ZW5lci5cbiAqIEBwYXJhbSBkaXNhYmxlQ293IERpc2FibGUgY29weS1vbi13cml0ZSBpZiB0cnVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIGl0IG11dGF0ZWQgdGhlIGBsaXN0ZW5lcnNgIGFycmF5IGRpcmVjdGx5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJBdChcbiAgICBsaXN0OiBMaXN0ZW5lckxpc3QsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICBkaXNhYmxlQ293ID0gZmFsc2UsXG4pOiBib29sZWFuIHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3QubGlzdGVuZXJzW2luZGV4XVxuXG4gICAgLy8gU2V0IHRoZSByZW1vdmVkIGZsYWcuXG4gICAgc2V0UmVtb3ZlZChsaXN0ZW5lcilcblxuICAgIC8vIERpc3Bvc2UgdGhlIGFib3J0IHNpZ25hbCBsaXN0ZW5lciBpZiBleGlzdHMuXG4gICAgaWYgKGxpc3RlbmVyLnNpZ25hbCkge1xuICAgICAgICBsaXN0ZW5lci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyLnNpZ25hbExpc3RlbmVyISlcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXkuXG4gICAgaWYgKGxpc3QuY293ICYmICFkaXNhYmxlQ293KSB7XG4gICAgICAgIGxpc3QuY293ID0gZmFsc2VcbiAgICAgICAgbGlzdC5saXN0ZW5lcnMgPSBsaXN0Lmxpc3RlbmVycy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgbGlzdC5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgIHJldHVybiB0cnVlXG59XG4iLCJpbXBvcnQgeyBMaXN0ZW5lckxpc3QgfSBmcm9tIFwiLi9saXN0ZW5lci1saXN0XCJcblxuLyoqXG4gKiBUaGUgbWFwIGZyb20gZXZlbnQgdHlwZXMgdG8gZWFjaCBsaXN0ZW5lciBsaXN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExpc3RlbmVyTGlzdE1hcCB7XG4gICAgW3R5cGU6IHN0cmluZ106IExpc3RlbmVyTGlzdCB8IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBgTGlzdGVuZXJMaXN0TWFwYCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckxpc3RNYXAoKTogTGlzdGVuZXJMaXN0TWFwIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKVxufVxuXG4vKipcbiAqIEdldCB0aGUgbGlzdGVuZXIgbGlzdCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIElmIHRoZSBsaXN0ZW5lciBsaXN0IGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCwgaW5pdGlhbGl6ZSBhbmQgcmV0dXJuIGl0LlxuICogQHBhcmFtIGxpc3RlbmVyTWFwIFRoZSBsaXN0ZW5lciBsaXN0IG1hcC5cbiAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlIHRvIGdldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUxpc3RlbmVyTGlzdChcbiAgICBsaXN0ZW5lck1hcDogUmVjb3JkPHN0cmluZywgTGlzdGVuZXJMaXN0IHwgdW5kZWZpbmVkPixcbiAgICB0eXBlOiBzdHJpbmcsXG4pOiBMaXN0ZW5lckxpc3Qge1xuICAgIHJldHVybiAobGlzdGVuZXJNYXBbdHlwZV0gPz89IHtcbiAgICAgICAgYXR0ckNhbGxiYWNrOiB1bmRlZmluZWQsXG4gICAgICAgIGF0dHJMaXN0ZW5lcjogdW5kZWZpbmVkLFxuICAgICAgICBjb3c6IGZhbHNlLFxuICAgICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIH0pXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvciB9IGZyb20gXCIuL2RvbS1leGNlcHRpb25cIlxuaW1wb3J0IHsgRXZlbnQsIGdldEV2ZW50SW50ZXJuYWxEYXRhIH0gZnJvbSBcIi4vZXZlbnRcIlxuaW1wb3J0IHsgRXZlbnRXcmFwcGVyIH0gZnJvbSBcIi4vZXZlbnQtd3JhcHBlclwiXG5pbXBvcnQgeyBHbG9iYWwgfSBmcm9tIFwiLi9nbG9iYWxcIlxuaW1wb3J0IHtcbiAgICBpbnZva2VDYWxsYmFjayxcbiAgICBpc0NhcHR1cmUsXG4gICAgaXNPbmNlLFxuICAgIGlzUGFzc2l2ZSxcbiAgICBpc1JlbW92ZWQsXG4gICAgTGlzdGVuZXIsXG59IGZyb20gXCIuL2xpc3RlbmVyXCJcbmltcG9ydCB7XG4gICAgYWRkTGlzdGVuZXIsXG4gICAgZmluZEluZGV4T2ZMaXN0ZW5lcixcbiAgICByZW1vdmVMaXN0ZW5lcixcbiAgICByZW1vdmVMaXN0ZW5lckF0LFxufSBmcm9tIFwiLi9saXN0ZW5lci1saXN0XCJcbmltcG9ydCB7XG4gICAgY3JlYXRlTGlzdGVuZXJMaXN0TWFwLFxuICAgIGVuc3VyZUxpc3RlbmVyTGlzdCxcbiAgICBMaXN0ZW5lckxpc3RNYXAsXG59IGZyb20gXCIuL2xpc3RlbmVyLWxpc3QtbWFwXCJcbmltcG9ydCB7IGFzc2VydFR5cGUsIGZvcm1hdCB9IGZyb20gXCIuL21pc2NcIlxuaW1wb3J0IHtcbiAgICBFdmVudExpc3RlbmVyV2FzRHVwbGljYXRlZCxcbiAgICBJbnZhbGlkRXZlbnRMaXN0ZW5lcixcbiAgICBPcHRpb25XYXNJZ25vcmVkLFxufSBmcm9tIFwiLi93YXJuaW5nc1wiXG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2V2ZW50dGFyZ2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFRhcmdldDxcbiAgICBURXZlbnRNYXAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBFdmVudD4gPSBSZWNvcmQ8c3RyaW5nLCBFdmVudD4sXG4gICAgVE1vZGUgZXh0ZW5kcyBcInN0YW5kYXJkXCIgfCBcInN0cmljdFwiID0gXCJzdGFuZGFyZFwiXG4+IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGludGVybmFsRGF0YU1hcC5zZXQodGhpcywgY3JlYXRlTGlzdGVuZXJMaXN0TWFwKCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBURXZlbnRNYXA+KFxuICAgICAgICB0eXBlOiBULFxuICAgICAgICBjYWxsYmFjaz86IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8dGhpcywgVEV2ZW50TWFwW1RdPiB8IG51bGwsXG4gICAgICAgIG9wdGlvbnM/OiBFdmVudFRhcmdldC5BZGRPcHRpb25zLFxuICAgICk6IHZvaWRcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgdHlwZTogc3RyaW5nLFxuICAgICAgICBjYWxsYmFjaz86IEV2ZW50VGFyZ2V0LkZhbGxiYWNrRXZlbnRMaXN0ZW5lcjx0aGlzLCBUTW9kZT4sXG4gICAgICAgIG9wdGlvbnM/OiBFdmVudFRhcmdldC5BZGRPcHRpb25zLFxuICAgICk6IHZvaWRcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBjYXB0dXJlIFRoZSBjYXB0dXJlIGZsYWcuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB7Y2FwdHVyZTogYm9vbGVhbn1gIG9iamVjdCBpbnN0ZWFkIG9mIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBURXZlbnRNYXA+KFxuICAgICAgICB0eXBlOiBULFxuICAgICAgICBjYWxsYmFjazpcbiAgICAgICAgICAgIHwgRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjx0aGlzLCBURXZlbnRNYXBbVF0+XG4gICAgICAgICAgICB8IG51bGxcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkLFxuICAgICAgICBjYXB0dXJlOiBib29sZWFuLFxuICAgICk6IHZvaWRcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSBjYXB0dXJlIFRoZSBjYXB0dXJlIGZsYWcuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB7Y2FwdHVyZTogYm9vbGVhbn1gIG9iamVjdCBpbnN0ZWFkIG9mIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNhbGxiYWNrOiBFdmVudFRhcmdldC5GYWxsYmFja0V2ZW50TGlzdGVuZXI8dGhpcywgVE1vZGU+LFxuICAgICAgICBjYXB0dXJlOiBib29sZWFuLFxuICAgICk6IHZvaWRcblxuICAgIC8vIEltcGxlbWVudGF0aW9uXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgc3RyaW5nICYga2V5b2YgVEV2ZW50TWFwPihcbiAgICAgICAgdHlwZTA6IFQsXG4gICAgICAgIGNhbGxiYWNrMD86IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8dGhpcywgVEV2ZW50TWFwW1RdPiB8IG51bGwsXG4gICAgICAgIG9wdGlvbnMwPzogYm9vbGVhbiB8IEV2ZW50VGFyZ2V0LkFkZE9wdGlvbnMsXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyTWFwID0gJCh0aGlzKVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICBvbmNlLFxuICAgICAgICAgICAgcGFzc2l2ZSxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0gPSBub3JtYWxpemVBZGRPcHRpb25zKHR5cGUwLCBjYWxsYmFjazAsIG9wdGlvbnMwKVxuICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCB8fCBzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3QgPSBlbnN1cmVMaXN0ZW5lckxpc3QobGlzdGVuZXJNYXAsIHR5cGUpXG5cbiAgICAgICAgLy8gRmluZCBleGlzdGluZyBsaXN0ZW5lci5cbiAgICAgICAgY29uc3QgaSA9IGZpbmRJbmRleE9mTGlzdGVuZXIobGlzdCwgY2FsbGJhY2ssIGNhcHR1cmUpXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgd2FybkR1cGxpY2F0ZShsaXN0Lmxpc3RlbmVyc1tpXSwgcGFzc2l2ZSwgb25jZSwgc2lnbmFsKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBsaXN0ZW5lci5cbiAgICAgICAgYWRkTGlzdGVuZXIobGlzdCwgY2FsbGJhY2ssIGNhcHR1cmUsIHBhc3NpdmUsIG9uY2UsIHNpZ25hbClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gYWRkZWQgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIHN0cmluZyAmIGtleW9mIFRFdmVudE1hcD4oXG4gICAgICAgIHR5cGU6IFQsXG4gICAgICAgIGNhbGxiYWNrPzogRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjx0aGlzLCBURXZlbnRNYXBbVF0+IHwgbnVsbCxcbiAgICAgICAgb3B0aW9ucz86IEV2ZW50VGFyZ2V0Lk9wdGlvbnMsXG4gICAgKTogdm9pZFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGFkZGVkIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICB0eXBlOiBzdHJpbmcsXG4gICAgICAgIGNhbGxiYWNrPzogRXZlbnRUYXJnZXQuRmFsbGJhY2tFdmVudExpc3RlbmVyPHRoaXMsIFRNb2RlPixcbiAgICAgICAgb3B0aW9ucz86IEV2ZW50VGFyZ2V0Lk9wdGlvbnMsXG4gICAgKTogdm9pZFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGFkZGVkIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIGNhcHR1cmUgVGhlIGNhcHR1cmUgZmxhZy5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHtjYXB0dXJlOiBib29sZWFufWAgb2JqZWN0IGluc3RlYWQgb2YgYSBib29sZWFuIHZhbHVlLlxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIHN0cmluZyAmIGtleW9mIFRFdmVudE1hcD4oXG4gICAgICAgIHR5cGU6IFQsXG4gICAgICAgIGNhbGxiYWNrOlxuICAgICAgICAgICAgfCBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPHRoaXMsIFRFdmVudE1hcFtUXT5cbiAgICAgICAgICAgIHwgbnVsbFxuICAgICAgICAgICAgfCB1bmRlZmluZWQsXG4gICAgICAgIGNhcHR1cmU6IGJvb2xlYW4sXG4gICAgKTogdm9pZFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGFkZGVkIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIGNhcHR1cmUgVGhlIGNhcHR1cmUgZmxhZy5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHtjYXB0dXJlOiBib29sZWFufWAgb2JqZWN0IGluc3RlYWQgb2YgYSBib29sZWFuIHZhbHVlLlxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIHR5cGU6IHN0cmluZyxcbiAgICAgICAgY2FsbGJhY2s6IEV2ZW50VGFyZ2V0LkZhbGxiYWNrRXZlbnRMaXN0ZW5lcjx0aGlzLCBUTW9kZT4sXG4gICAgICAgIGNhcHR1cmU6IGJvb2xlYW4sXG4gICAgKTogdm9pZFxuXG4gICAgLy8gSW1wbGVtZW50YXRpb25cbiAgICByZW1vdmVFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBURXZlbnRNYXA+KFxuICAgICAgICB0eXBlMDogVCxcbiAgICAgICAgY2FsbGJhY2swPzogRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjx0aGlzLCBURXZlbnRNYXBbVF0+IHwgbnVsbCxcbiAgICAgICAgb3B0aW9uczA/OiBib29sZWFuIHwgRXZlbnRUYXJnZXQuT3B0aW9ucyxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJNYXAgPSAkKHRoaXMpXG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIGNhcHR1cmUsIHR5cGUgfSA9IG5vcm1hbGl6ZU9wdGlvbnMoXG4gICAgICAgICAgICB0eXBlMCxcbiAgICAgICAgICAgIGNhbGxiYWNrMCxcbiAgICAgICAgICAgIG9wdGlvbnMwLFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IGxpc3QgPSBsaXN0ZW5lck1hcFt0eXBlXVxuXG4gICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIGxpc3QpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYW4gZXZlbnQuXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBgRXZlbnRgIG9iamVjdCB0byBkaXNwYXRjaC5cbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50PFQgZXh0ZW5kcyBzdHJpbmcgJiBrZXlvZiBURXZlbnRNYXA+KFxuICAgICAgICBldmVudDogRXZlbnRUYXJnZXQuRXZlbnREYXRhPFRFdmVudE1hcCwgVE1vZGUsIFQ+LFxuICAgICk6IGJvb2xlYW5cblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgYEV2ZW50YCBvYmplY3QgdG8gZGlzcGF0Y2guXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudDogRXZlbnRUYXJnZXQuRmFsbGJhY2tFdmVudDxUTW9kZT4pOiBib29sZWFuXG5cbiAgICAvLyBJbXBsZW1lbnRhdGlvblxuICAgIGRpc3BhdGNoRXZlbnQoXG4gICAgICAgIGU6XG4gICAgICAgICAgICB8IEV2ZW50VGFyZ2V0LkV2ZW50RGF0YTxURXZlbnRNYXAsIFRNb2RlLCBzdHJpbmc+XG4gICAgICAgICAgICB8IEV2ZW50VGFyZ2V0LkZhbGxiYWNrRXZlbnQ8VE1vZGU+LFxuICAgICk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBsaXN0ID0gJCh0aGlzKVtTdHJpbmcoZS50eXBlKV1cbiAgICAgICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZSBpbnN0YW5jZW9mIEV2ZW50ID8gZSA6IEV2ZW50V3JhcHBlci53cmFwKGUpXG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGdldEV2ZW50SW50ZXJuYWxEYXRhKGV2ZW50LCBcImV2ZW50XCIpXG4gICAgICAgIGlmIChldmVudERhdGEuZGlzcGF0Y2hGbGFnKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcihcIlRoaXMgZXZlbnQgaGFzIGJlZW4gaW4gZGlzcGF0Y2hpbmcuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBldmVudERhdGEuZGlzcGF0Y2hGbGFnID0gdHJ1ZVxuICAgICAgICBldmVudERhdGEudGFyZ2V0ID0gZXZlbnREYXRhLmN1cnJlbnRUYXJnZXQgPSB0aGlzXG5cbiAgICAgICAgaWYgKCFldmVudERhdGEuc3RvcFByb3BhZ2F0aW9uRmxhZykge1xuICAgICAgICAgICAgY29uc3QgeyBjb3csIGxpc3RlbmVycyB9ID0gbGlzdFxuXG4gICAgICAgICAgICAvLyBTZXQgY29weS1vbi13cml0ZSBmbGFnLlxuICAgICAgICAgICAgbGlzdC5jb3cgPSB0cnVlXG5cbiAgICAgICAgICAgIC8vIENhbGwgbGlzdGVuZXJzLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXVxuXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpZiByZW1vdmVkLlxuICAgICAgICAgICAgICAgIGlmIChpc1JlbW92ZWQobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaGFzIHRoZSBgb25jZWAgZmxhZy5cbiAgICAgICAgICAgICAgICBpZiAoaXNPbmNlKGxpc3RlbmVyKSAmJiByZW1vdmVMaXN0ZW5lckF0KGxpc3QsIGksICFjb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhpcyBsaXN0ZW5lciB3YXMgcmVtb3ZlZCwgdGhlIG5leHQgaW5kZXggaXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lciB3aXRoIHRoZSBgcGFzc2l2ZWAgZmxhZy5cbiAgICAgICAgICAgICAgICBldmVudERhdGEuaW5QYXNzaXZlTGlzdGVuZXJGbGFnID0gaXNQYXNzaXZlKGxpc3RlbmVyKVxuICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGxpc3RlbmVyLCB0aGlzLCBldmVudClcbiAgICAgICAgICAgICAgICBldmVudERhdGEuaW5QYXNzaXZlTGlzdGVuZXJGbGFnID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIC8vIFN0b3AgaWYgdGhlIGBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKWAgbWV0aG9kIHdhcyBjYWxsZWQuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50RGF0YS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25GbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIGNvcHktb24td3JpdGUgZmxhZy5cbiAgICAgICAgICAgIGlmICghY293KSB7XG4gICAgICAgICAgICAgICAgbGlzdC5jb3cgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnREYXRhLnRhcmdldCA9IG51bGxcbiAgICAgICAgZXZlbnREYXRhLmN1cnJlbnRUYXJnZXQgPSBudWxsXG4gICAgICAgIGV2ZW50RGF0YS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25GbGFnID0gZmFsc2VcbiAgICAgICAgZXZlbnREYXRhLnN0b3BQcm9wYWdhdGlvbkZsYWcgPSBmYWxzZVxuICAgICAgICBldmVudERhdGEuZGlzcGF0Y2hGbGFnID0gZmFsc2VcblxuICAgICAgICByZXR1cm4gIWV2ZW50RGF0YS5jYW5jZWxlZEZsYWdcbiAgICB9XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgRXZlbnRUYXJnZXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBFdmVudExpc3RlbmVyPFxuICAgICAgICBURXZlbnRUYXJnZXQgZXh0ZW5kcyBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgICAgIFRFdmVudCBleHRlbmRzIEV2ZW50XG4gICAgPiA9IENhbGxiYWNrRnVuY3Rpb248VEV2ZW50VGFyZ2V0LCBURXZlbnQ+IHwgQ2FsbGJhY2tPYmplY3Q8VEV2ZW50PlxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgQ2FsbGJhY2tGdW5jdGlvbjxcbiAgICAgICAgVEV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQ8YW55LCBhbnk+LFxuICAgICAgICBURXZlbnQgZXh0ZW5kcyBFdmVudFxuICAgID4ge1xuICAgICAgICAodGhpczogVEV2ZW50VGFyZ2V0LCBldmVudDogVEV2ZW50KTogdm9pZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBsaXN0ZW5lciBvYmplY3QuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NhbGxiYWNrZGVmLWV2ZW50bGlzdGVuZXJcbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIENhbGxiYWNrT2JqZWN0PFRFdmVudCBleHRlbmRzIEV2ZW50PiB7XG4gICAgICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBURXZlbnQpOiB2b2lkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbW1vbiBvcHRpb25zIGZvciBib3RoIGBhZGRFdmVudExpc3RlbmVyYCBhbmQgYHJlbW92ZUV2ZW50TGlzdGVuZXJgIG1ldGhvZHMuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RpY3RkZWYtZXZlbnRsaXN0ZW5lcm9wdGlvbnNcbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMge1xuICAgICAgICBjYXB0dXJlPzogYm9vbGVhblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25zIGZvciB0aGUgYGFkZEV2ZW50TGlzdGVuZXJgIG1ldGhvZHMuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RpY3RkZWYtYWRkZXZlbnRsaXN0ZW5lcm9wdGlvbnNcbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIEFkZE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zIHtcbiAgICAgICAgcGFzc2l2ZT86IGJvb2xlYW5cbiAgICAgICAgb25jZT86IGJvb2xlYW5cbiAgICAgICAgc2lnbmFsPzogQWJvcnRTaWduYWwgfCBudWxsIHwgdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGFib3J0IHNpZ25hbC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jYWJvcnRzaWduYWxcbiAgICAgKi9cbiAgICBleHBvcnQgaW50ZXJmYWNlIEFib3J0U2lnbmFsIGV4dGVuZHMgRXZlbnRUYXJnZXQ8eyBhYm9ydDogRXZlbnQgfT4ge1xuICAgICAgICByZWFkb25seSBhYm9ydGVkOiBib29sZWFuXG4gICAgICAgIG9uYWJvcnQ6IENhbGxiYWNrRnVuY3Rpb248dGhpcywgRXZlbnQ+IHwgbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBkYXRhIHRvIGRpc3BhdGNoIGluIHN0cmljdCBtb2RlLlxuICAgICAqL1xuICAgIGV4cG9ydCB0eXBlIEV2ZW50RGF0YTxcbiAgICAgICAgVEV2ZW50TWFwIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgRXZlbnQ+LFxuICAgICAgICBUTW9kZSBleHRlbmRzIFwic3RhbmRhcmRcIiB8IFwic3RyaWN0XCIsXG4gICAgICAgIFRFdmVudFR5cGUgZXh0ZW5kcyBzdHJpbmdcbiAgICA+ID0gVE1vZGUgZXh0ZW5kcyBcInN0cmljdFwiXG4gICAgICAgID8gSXNWYWxpZEV2ZW50TWFwPFRFdmVudE1hcD4gZXh0ZW5kcyB0cnVlXG4gICAgICAgICAgICA/IEV4cGxpY2l0VHlwZTxURXZlbnRUeXBlPiAmXG4gICAgICAgICAgICAgICAgICBPbWl0PFRFdmVudE1hcFtURXZlbnRUeXBlXSwga2V5b2YgRXZlbnQ+ICZcbiAgICAgICAgICAgICAgICAgIFBhcnRpYWw8T21pdDxFdmVudCwgXCJ0eXBlXCI+PlxuICAgICAgICAgICAgOiBuZXZlclxuICAgICAgICA6IG5ldmVyXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgZXhwbGljaXQgYHR5cGVgIHByb3BlcnR5IGlmIGBUYCBpcyBhIHN0cmluZyBsaXRlcmFsLlxuICAgICAqIE90aGVyd2lzZSwgbmV2ZXIuXG4gICAgICovXG4gICAgZXhwb3J0IHR5cGUgRXhwbGljaXRUeXBlPFQgZXh0ZW5kcyBzdHJpbmc+ID0gc3RyaW5nIGV4dGVuZHMgVFxuICAgICAgICA/IG5ldmVyXG4gICAgICAgIDogeyByZWFkb25seSB0eXBlOiBUIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBsaXN0ZW5lciB0eXBlIGluIHN0YW5kYXJkIG1vZGUuXG4gICAgICogT3RoZXJ3aXNlLCBuZXZlci5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBGYWxsYmFja0V2ZW50TGlzdGVuZXI8XG4gICAgICAgIFRFdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICAgICAgVE1vZGUgZXh0ZW5kcyBcInN0YW5kYXJkXCIgfCBcInN0cmljdFwiXG4gICAgPiA9IFRNb2RlIGV4dGVuZHMgXCJzdGFuZGFyZFwiXG4gICAgICAgID8gRXZlbnRMaXN0ZW5lcjxURXZlbnRUYXJnZXQsIEV2ZW50PiB8IG51bGwgfCB1bmRlZmluZWRcbiAgICAgICAgOiBuZXZlclxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHR5cGUgaW4gc3RhbmRhcmQgbW9kZS5cbiAgICAgKiBPdGhlcndpc2UsIG5ldmVyLlxuICAgICAqL1xuICAgIGV4cG9ydCB0eXBlIEZhbGxiYWNrRXZlbnQ8XG4gICAgICAgIFRNb2RlIGV4dGVuZHMgXCJzdGFuZGFyZFwiIHwgXCJzdHJpY3RcIlxuICAgID4gPSBUTW9kZSBleHRlbmRzIFwic3RhbmRhcmRcIiA/IEV2ZW50IDogbmV2ZXJcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGdpdmVuIGV2ZW50IG1hcCBpcyB2YWxpZC5cbiAgICAgKiBJdCdzIHZhbGlkIGlmIHRoZSBrZXlzIG9mIHRoZSBldmVudCBtYXAgYXJlIG5hcnJvd2VyIHRoYW4gYHN0cmluZ2AuXG4gICAgICovXG4gICAgZXhwb3J0IHR5cGUgSXNWYWxpZEV2ZW50TWFwPFQ+ID0gc3RyaW5nIGV4dGVuZHMga2V5b2YgVCA/IGZhbHNlIDogdHJ1ZVxufVxuXG5leHBvcnQgeyAkIGFzIGdldEV2ZW50VGFyZ2V0SW50ZXJuYWxEYXRhIH1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogSW50ZXJuYWwgZGF0YSBmb3IgRXZlbnRUYXJnZXRcbiAqL1xudHlwZSBFdmVudFRhcmdldEludGVybmFsRGF0YSA9IExpc3RlbmVyTGlzdE1hcFxuXG4vKipcbiAqIEludGVybmFsIGRhdGEuXG4gKi9cbmNvbnN0IGludGVybmFsRGF0YU1hcCA9IG5ldyBXZWFrTWFwPGFueSwgRXZlbnRUYXJnZXRJbnRlcm5hbERhdGE+KClcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIHRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9iamVjdCB0byBnZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIG5hbWUgVGhlIHZhcmlhYmxlIG5hbWUgdG8gcmVwb3J0LlxuICogQHJldHVybnMgVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uICQodGFyZ2V0OiBhbnksIG5hbWUgPSBcInRoaXNcIik6IEV2ZW50VGFyZ2V0SW50ZXJuYWxEYXRhIHtcbiAgICBjb25zdCByZXR2ID0gaW50ZXJuYWxEYXRhTWFwLmdldCh0YXJnZXQpXG4gICAgYXNzZXJ0VHlwZShcbiAgICAgICAgcmV0diAhPSBudWxsLFxuICAgICAgICBcIiclcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBFdmVudFRhcmdldCBjb25zdHJ1Y3RvciBjcmVhdGVkLCBidXQgZ290IGFub3RoZXIgb25lOiAlb1wiLFxuICAgICAgICBuYW1lLFxuICAgICAgICB0YXJnZXQsXG4gICAgKVxuICAgIHJldHVybiByZXR2XG59XG5cbi8qKlxuICogTm9ybWFsaXplIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFkZE9wdGlvbnMoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiBFdmVudFRhcmdldC5FdmVudExpc3RlbmVyPGFueSwgYW55PiB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogYm9vbGVhbiB8IEV2ZW50VGFyZ2V0LkFkZE9wdGlvbnMgfCB1bmRlZmluZWQsXG4pOiB7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgY2FsbGJhY2s6IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8YW55LCBhbnk+IHwgdW5kZWZpbmVkXG4gICAgY2FwdHVyZTogYm9vbGVhblxuICAgIHBhc3NpdmU6IGJvb2xlYW5cbiAgICBvbmNlOiBib29sZWFuXG4gICAgc2lnbmFsOiBFdmVudFRhcmdldC5BYm9ydFNpZ25hbCB8IHVuZGVmaW5lZFxufSB7XG4gICAgYXNzZXJ0Q2FsbGJhY2soY2FsbGJhY2spXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nKHR5cGUpLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKSxcbiAgICAgICAgICAgIHBhc3NpdmU6IEJvb2xlYW4ob3B0aW9ucy5wYXNzaXZlKSxcbiAgICAgICAgICAgIG9uY2U6IEJvb2xlYW4ob3B0aW9ucy5vbmNlKSxcbiAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwgPz8gdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogU3RyaW5nKHR5cGUpLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgPz8gdW5kZWZpbmVkLFxuICAgICAgICBjYXB0dXJlOiBCb29sZWFuKG9wdGlvbnMpLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgIHNpZ25hbDogdW5kZWZpbmVkLFxuICAgIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IEV2ZW50VGFyZ2V0LkV2ZW50TGlzdGVuZXI8YW55LCBhbnk+IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiBib29sZWFuIHwgRXZlbnRUYXJnZXQuT3B0aW9ucyB8IHVuZGVmaW5lZCxcbik6IHtcbiAgICB0eXBlOiBzdHJpbmdcbiAgICBjYWxsYmFjazogRXZlbnRUYXJnZXQuRXZlbnRMaXN0ZW5lcjxhbnksIGFueT4gfCB1bmRlZmluZWRcbiAgICBjYXB0dXJlOiBib29sZWFuXG59IHtcbiAgICBhc3NlcnRDYWxsYmFjayhjYWxsYmFjaylcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcodHlwZSksXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogU3RyaW5nKHR5cGUpLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgPz8gdW5kZWZpbmVkLFxuICAgICAgICBjYXB0dXJlOiBCb29sZWFuKG9wdGlvbnMpLFxuICAgIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgJ2NhbGxiYWNrJyBhcmd1bWVudC5cbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGFzc2VydENhbGxiYWNrKGNhbGxiYWNrOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICh0eXBlb2YgY2FsbGJhY2sgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGNhbGxiYWNrICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FsbGJhY2suaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIilcbiAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjYWxsYmFjayA9PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBJbnZhbGlkRXZlbnRMaXN0ZW5lci53YXJuKGNhbGxiYWNrKVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZvcm1hdChJbnZhbGlkRXZlbnRMaXN0ZW5lci5tZXNzYWdlLCBbY2FsbGJhY2tdKSlcbn1cblxuLyoqXG4gKiBQcmludCB3YXJuaW5nIGZvciBkdXBsaWNhdGVkLlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBjdXJyZW50IGxpc3RlbmVyIHRoYXQgaXMgZHVwbGljYXRlZC5cbiAqIEBwYXJhbSBwYXNzaXZlIFRoZSBwYXNzaXZlIGZsYWcgb2YgdGhlIG5ldyBkdXBsaWNhdGVkIGxpc3RlbmVyLlxuICogQHBhcmFtIG9uY2UgVGhlIG9uY2UgZmxhZyBvZiB0aGUgbmV3IGR1cGxpY2F0ZWQgbGlzdGVuZXIuXG4gKiBAcGFyYW0gc2lnbmFsIFRoZSBzaWduYWwgb2JqZWN0IG9mIHRoZSBuZXcgZHVwbGljYXRlZCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gd2FybkR1cGxpY2F0ZShcbiAgICBsaXN0ZW5lcjogTGlzdGVuZXIsXG4gICAgcGFzc2l2ZTogYm9vbGVhbixcbiAgICBvbmNlOiBib29sZWFuLFxuICAgIHNpZ25hbDogRXZlbnRUYXJnZXQuQWJvcnRTaWduYWwgfCB1bmRlZmluZWQsXG4pOiB2b2lkIHtcbiAgICBFdmVudExpc3RlbmVyV2FzRHVwbGljYXRlZC53YXJuKFxuICAgICAgICBpc0NhcHR1cmUobGlzdGVuZXIpID8gXCJjYXB0dXJlXCIgOiBcImJ1YmJsZVwiLFxuICAgICAgICBsaXN0ZW5lci5jYWxsYmFjayxcbiAgICApXG5cbiAgICBpZiAoaXNQYXNzaXZlKGxpc3RlbmVyKSAhPT0gcGFzc2l2ZSkge1xuICAgICAgICBPcHRpb25XYXNJZ25vcmVkLndhcm4oXCJwYXNzaXZlXCIpXG4gICAgfVxuICAgIGlmIChpc09uY2UobGlzdGVuZXIpICE9PSBvbmNlKSB7XG4gICAgICAgIE9wdGlvbldhc0lnbm9yZWQud2FybihcIm9uY2VcIilcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVyLnNpZ25hbCAhPT0gc2lnbmFsKSB7XG4gICAgICAgIE9wdGlvbldhc0lnbm9yZWQud2FybihcInNpZ25hbFwiKVxuICAgIH1cbn1cblxuLy8gU2V0IGVudW1lcmFibGVcbmNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhFdmVudFRhcmdldC5wcm90b3R5cGUpXG5mb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoa2V5c1tpXSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFRhcmdldC5wcm90b3R5cGUsIGtleXNbaV0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KVxufVxuXG4vLyBFbnN1cmUgYGV2ZW50VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50VGFyZ2V0YCBpcyBgdHJ1ZWAuXG5pZiAoXG4gICAgdHlwZW9mIEdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBHbG9iYWwuRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCJcbikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudFRhcmdldC5wcm90b3R5cGUsIEdsb2JhbC5FdmVudFRhcmdldC5wcm90b3R5cGUpXG59XG4iLCJpbXBvcnQgeyBFdmVudCB9IGZyb20gXCIuL2V2ZW50XCJcbmltcG9ydCB7IEV2ZW50VGFyZ2V0LCBnZXRFdmVudFRhcmdldEludGVybmFsRGF0YSB9IGZyb20gXCIuL2V2ZW50LXRhcmdldFwiXG5pbXBvcnQgeyBhZGRMaXN0ZW5lciwgTGlzdGVuZXJMaXN0LCByZW1vdmVMaXN0ZW5lciB9IGZyb20gXCIuL2xpc3RlbmVyLWxpc3RcIlxuaW1wb3J0IHsgZW5zdXJlTGlzdGVuZXJMaXN0IH0gZnJvbSBcIi4vbGlzdGVuZXItbGlzdC1tYXBcIlxuaW1wb3J0IHsgSW52YWxpZEF0dHJpYnV0ZUhhbmRsZXIgfSBmcm9tIFwiLi93YXJuaW5nc1wiXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgZ2l2ZW4gZXZlbnQgYXR0cmlidXRlLlxuICogQHBhcmFtIHRhcmdldCBUaGUgYEV2ZW50VGFyZ2V0YCBvYmplY3QgdG8gZ2V0LlxuICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudEF0dHJpYnV0ZVZhbHVlPFxuICAgIFRFdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICBURXZlbnQgZXh0ZW5kcyBFdmVudFxuPihcbiAgICB0YXJnZXQ6IFRFdmVudFRhcmdldCxcbiAgICB0eXBlOiBzdHJpbmcsXG4pOiBFdmVudFRhcmdldC5DYWxsYmFja0Z1bmN0aW9uPFRFdmVudFRhcmdldCwgVEV2ZW50PiB8IG51bGwge1xuICAgIGNvbnN0IGxpc3RNYXAgPSBnZXRFdmVudFRhcmdldEludGVybmFsRGF0YSh0YXJnZXQsIFwidGFyZ2V0XCIpXG4gICAgcmV0dXJuIGxpc3RNYXBbdHlwZV0/LmF0dHJDYWxsYmFjayA/PyBudWxsXG59XG5cbi8qKlxuICogU2V0IGFuIGV2ZW50IGxpc3RlbmVyIHRvIGEgZ2l2ZW4gZXZlbnQgYXR0cmlidXRlLlxuICogQHBhcmFtIHRhcmdldCBUaGUgYEV2ZW50VGFyZ2V0YCBvYmplY3QgdG8gc2V0LlxuICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZShcbiAgICB0YXJnZXQ6IEV2ZW50VGFyZ2V0PGFueSwgYW55PixcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IEV2ZW50VGFyZ2V0LkNhbGxiYWNrRnVuY3Rpb248YW55LCBhbnk+IHwgbnVsbCxcbik6IHZvaWQge1xuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEludmFsaWRBdHRyaWJ1dGVIYW5kbGVyLndhcm4oY2FsbGJhY2spXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiICYmIGNhbGxiYWNrICE9PSBudWxsKVxuICAgICkge1xuICAgICAgICB1cHNlcnRFdmVudEF0dHJpYnV0ZUxpc3RlbmVyKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRBdHRyaWJ1dGVMaXN0ZW5lcih0YXJnZXQsIHR5cGUpXG4gICAgfVxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBVcGRhdGUgb3IgaW5zZXJ0IHRoZSBnaXZlbiBldmVudCBhdHRyaWJ1dGUgaGFuZGxlci5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGBFdmVudFRhcmdldGAgb2JqZWN0IHRvIHNldC5cbiAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBldmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gdXBzZXJ0RXZlbnRBdHRyaWJ1dGVMaXN0ZW5lcjxcbiAgICBURXZlbnRUYXJnZXQgZXh0ZW5kcyBFdmVudFRhcmdldDxhbnksIGFueT5cbj4oXG4gICAgdGFyZ2V0OiBURXZlbnRUYXJnZXQsXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiBFdmVudFRhcmdldC5DYWxsYmFja0Z1bmN0aW9uPFRFdmVudFRhcmdldCwgYW55Pixcbik6IHZvaWQge1xuICAgIGNvbnN0IGxpc3QgPSBlbnN1cmVMaXN0ZW5lckxpc3QoXG4gICAgICAgIGdldEV2ZW50VGFyZ2V0SW50ZXJuYWxEYXRhKHRhcmdldCwgXCJ0YXJnZXRcIiksXG4gICAgICAgIFN0cmluZyh0eXBlKSxcbiAgICApXG4gICAgbGlzdC5hdHRyQ2FsbGJhY2sgPSBjYWxsYmFja1xuXG4gICAgaWYgKGxpc3QuYXR0ckxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgbGlzdC5hdHRyTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZUNhbGxiYWNrKGxpc3QpLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gZXZlbnQgYXR0cmlidXRlIGhhbmRsZXIuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBgRXZlbnRUYXJnZXRgIG9iamVjdCB0byByZW1vdmUuXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZXZlbnQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50QXR0cmlidXRlTGlzdGVuZXIoXG4gICAgdGFyZ2V0OiBFdmVudFRhcmdldDxhbnksIGFueT4sXG4gICAgdHlwZTogc3RyaW5nLFxuKTogdm9pZCB7XG4gICAgY29uc3QgbGlzdE1hcCA9IGdldEV2ZW50VGFyZ2V0SW50ZXJuYWxEYXRhKHRhcmdldCwgXCJ0YXJnZXRcIilcbiAgICBjb25zdCBsaXN0ID0gbGlzdE1hcFtTdHJpbmcodHlwZSldXG4gICAgaWYgKGxpc3QgJiYgbGlzdC5hdHRyTGlzdGVuZXIpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdCwgbGlzdC5hdHRyTGlzdGVuZXIuY2FsbGJhY2ssIGZhbHNlKVxuICAgICAgICBsaXN0LmF0dHJDYWxsYmFjayA9IGxpc3QuYXR0ckxpc3RlbmVyID0gdW5kZWZpbmVkXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBsaXN0ZW5lciBsaXN0IG9iamVjdC5cbiAqIEl0IGNhbGxzIGBhdHRyQ2FsbGJhY2tgIHByb3BlcnR5IGlmIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIGxpc3QgVGhlIGBMaXN0ZW5lckxpc3RgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVDYWxsYmFjayhcbiAgICBsaXN0OiBMaXN0ZW5lckxpc3QsXG4pOiBFdmVudFRhcmdldC5DYWxsYmFja0Z1bmN0aW9uPGFueSwgYW55PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGxpc3QuYXR0ckNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50IH0gZnJvbSBcIi4vZXZlbnRcIlxuaW1wb3J0IHtcbiAgICBnZXRFdmVudEF0dHJpYnV0ZVZhbHVlLFxuICAgIHNldEV2ZW50QXR0cmlidXRlVmFsdWUsXG59IGZyb20gXCIuL2V2ZW50LWF0dHJpYnV0ZS1oYW5kbGVyXCJcbmltcG9ydCB7IEV2ZW50VGFyZ2V0IH0gZnJvbSBcIi4vZXZlbnQtdGFyZ2V0XCJcblxuLyoqXG4gKiBEZWZpbmUgYW4gYEV2ZW50VGFyZ2V0YCBjbGFzcyB0aGF0IGhhcyBldmVudCBhdHRpYnV0ZXMuXG4gKiBAcGFyYW0gdHlwZXMgVGhlIHR5cGVzIHRvIGRlZmluZSBldmVudCBhdHRyaWJ1dGVzLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBnZXRFdmVudEF0dHJpYnV0ZVZhbHVlYC9gc2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZWAgcGFpciBvbiB5b3VyIGRlcml2ZWQgY2xhc3MgaW5zdGVhZCBiZWNhdXNlIG9mIHN0YXRpYyBhbmFseXNpcyBmcmllbmRseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0PFxuICAgIFRFdmVudE1hcCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIEV2ZW50PixcbiAgICBUTW9kZSBleHRlbmRzIFwic3RhbmRhcmRcIiB8IFwic3RyaWN0XCIgPSBcInN0YW5kYXJkXCJcbj4oXG4gICAgLi4udHlwZXM6IChzdHJpbmcgJiBrZXlvZiBURXZlbnRNYXApW11cbik6IGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0LkN1c3RvbUV2ZW50VGFyZ2V0Q29uc3RydWN0b3I8VEV2ZW50TWFwLCBUTW9kZT4ge1xuICAgIGNsYXNzIEN1c3RvbUV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge31cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlKEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgdHlwZXNbaV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50VGFyZ2V0IGFzIGFueVxufVxuXG5leHBvcnQgbmFtZXNwYWNlIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJmYWNlIG9mIEN1c3RvbUV2ZW50VGFyZ2V0IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGV4cG9ydCB0eXBlIEN1c3RvbUV2ZW50VGFyZ2V0Q29uc3RydWN0b3I8XG4gICAgICAgIFRFdmVudE1hcCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIEV2ZW50PixcbiAgICAgICAgVE1vZGUgZXh0ZW5kcyBcInN0YW5kYXJkXCIgfCBcInN0cmljdFwiXG4gICAgPiA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIG5ldyAoKTogQ3VzdG9tRXZlbnRUYXJnZXQ8VEV2ZW50TWFwLCBUTW9kZT5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm90b3R5cGU6IEN1c3RvbUV2ZW50VGFyZ2V0PFRFdmVudE1hcCwgVE1vZGU+XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyZmFjZSBvZiBDdXN0b21FdmVudFRhcmdldC5cbiAgICAgKi9cbiAgICBleHBvcnQgdHlwZSBDdXN0b21FdmVudFRhcmdldDxcbiAgICAgICAgVEV2ZW50TWFwIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgRXZlbnQ+LFxuICAgICAgICBUTW9kZSBleHRlbmRzIFwic3RhbmRhcmRcIiB8IFwic3RyaWN0XCJcbiAgICA+ID0gRXZlbnRUYXJnZXQ8VEV2ZW50TWFwLCBUTW9kZT4gJlxuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZS5FdmVudEF0dHJpYnV0ZXM8YW55LCBURXZlbnRNYXA+XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGV2ZW50IGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGBFdmVudFRhcmdldGAgb2JqZWN0IHRvIGRlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZSB0byBkZWZpbmUuXG4gKiBAcGFyYW0gX2V2ZW50Q2xhc3MgVW51c2VkLCBidXQgdG8gaW5mZXIgYEV2ZW50YCBjbGFzcyB0eXBlLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBnZXRFdmVudEF0dHJpYnV0ZVZhbHVlYC9gc2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZWAgcGFpciBvbiB5b3VyIGRlcml2ZWQgY2xhc3MgaW5zdGVhZCBiZWNhdXNlIG9mIHN0YXRpYyBhbmFseXNpcyBmcmllbmRseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlPFxuICAgIFRFdmVudFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0LFxuICAgIFRFdmVudFR5cGUgZXh0ZW5kcyBzdHJpbmcsXG4gICAgVEV2ZW50Q29uc3RydWNvciBleHRlbmRzIHR5cGVvZiBFdmVudFxuPihcbiAgICB0YXJnZXQ6IFRFdmVudFRhcmdldCxcbiAgICB0eXBlOiBURXZlbnRUeXBlLFxuICAgIF9ldmVudENsYXNzPzogVEV2ZW50Q29uc3RydWNvcixcbik6IGFzc2VydHMgdGFyZ2V0IGlzIFRFdmVudFRhcmdldCAmXG4gICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGUuRXZlbnRBdHRyaWJ1dGVzPFxuICAgICAgICBURXZlbnRUYXJnZXQsXG4gICAgICAgIFJlY29yZDxURXZlbnRUeXBlLCBJbnN0YW5jZVR5cGU8VEV2ZW50Q29uc3RydWNvcj4+XG4gICAgPiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYG9uJHt0eXBlfWAsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV2ZW50QXR0cmlidXRlVmFsdWUodGhpcywgdHlwZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRFdmVudEF0dHJpYnV0ZVZhbHVlKHRoaXMsIHR5cGUsIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfSlcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBkZWZpbmVFdmVudEF0dHJpYnV0ZSB7XG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBldmVudCBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIGV4cG9ydCB0eXBlIEV2ZW50QXR0cmlidXRlczxcbiAgICAgICAgVEV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQ8YW55LCBhbnk+LFxuICAgICAgICBURXZlbnRNYXAgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBFdmVudD5cbiAgICA+ID0ge1xuICAgICAgICBbUCBpbiBzdHJpbmcgJlxuICAgICAgICAgICAga2V5b2YgVEV2ZW50TWFwIGFzIGBvbiR7UH1gXTogRXZlbnRUYXJnZXQuQ2FsbGJhY2tGdW5jdGlvbjxcbiAgICAgICAgICAgIFRFdmVudFRhcmdldCxcbiAgICAgICAgICAgIFRFdmVudE1hcFtQXVxuICAgICAgICA+IHwgbnVsbFxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/event-target-shim/index.mjs\n");

/***/ })

}]);